<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤲🏾 🦂 👓 Integración continua en Yandex 🌙 💅🏻 👿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mantener una gran base de código mientras se garantiza una alta productividad para un gran número de desarrolladores es un desafío serio. En los últim...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Integración continua en Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/428972/"><p>  Mantener una gran base de código mientras se garantiza una alta productividad para un gran número de desarrolladores es un desafío serio.  En los últimos 5 años, Yandex ha estado desarrollando un sistema especial para la integración continua.  En este artículo, hablaremos sobre la escala de la base de código Yandex, sobre la transferencia del desarrollo a un único repositorio con un enfoque de desarrollo basado en troncales, sobre qué tareas debe resolver un sistema de integración continua para trabajar de manera efectiva en tales condiciones. </p><br><img src="https://habrastorage.org/webt/wb/mt/xc/wbmtxcvurtd6cdv1aomjrtcyfw8.png"><br><p>  Hace muchos años, Yandex no tenía reglas especiales en el desarrollo de servicios: cada departamento podía usar cualquier idioma, cualquier tecnología, cualquier sistema de implementación.  Y como la práctica ha demostrado, esa libertad no siempre ayudó a avanzar más rápido.  En ese momento, para resolver los mismos problemas, a menudo había varios desarrollos propietarios o de código abierto.  A medida que la empresa creció, ese ecosistema funcionó peor.  Al mismo tiempo, queríamos seguir siendo un gran Yandex, y no dividirnos en muchas compañías independientes, porque ofrece muchas ventajas: muchas personas hacen las mismas tareas, los resultados de su trabajo pueden reutilizarse.  Comenzando desde una variedad de estructuras de datos, como tablas hash distribuidas y colas sin bloqueo, y terminando con una gran cantidad de códigos especializados diferentes que hemos escrito durante 20 años. </p><a name="habracut"></a><br><p>  Muchas de las tareas que resolvemos no se resuelven en el mundo de código abierto.  No hay MapReduce que funcione bien en nuestros volúmenes (más de 5000 servidores) y nuestras tareas; no hay un rastreador de tareas que pueda manejar todas nuestras decenas de millones de tickets.  Esto es atractivo en Yandex: puedes hacer cosas realmente geniales. </p><br><p>  Pero estamos perdiendo eficiencia de manera importante cuando resolvemos los mismos problemas de nuevo, rehacemos soluciones ya hechas, lo que dificulta la integración entre componentes.  Es bueno y conveniente hacer todo solo por ti mismo en tu propio rincón, no puedes pensar en los demás por el momento.  Pero tan pronto como el servicio sea lo suficientemente notable, tendrá dependencias.  Solo parece que varios servicios dependen débilmente entre sí, de hecho, hay muchas conexiones entre diferentes partes de la empresa.  Muchos servicios están disponibles a través de la aplicación Yandex / Navegador / etc., o están integrados entre sí.  Por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alice</a> aparece en el navegador, usando Alice puedes pedir un taxi.  Todos usamos componentes comunes: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">YT</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">YQL</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nirvana</a> . </p><br><p>  El antiguo modelo de desarrollo tenía problemas importantes.  Debido a la presencia de muchos repositorios, es difícil para un desarrollador ordinario, especialmente un principiante, descubrir: </p><br><ul><li>  donde esta el componente </li><li>  cómo funciona: no hay forma de "tomar y leer" </li><li>  ¿Quién lo está desarrollando y apoyando ahora? </li><li>  ¿Cómo empezar a usarlo? </li></ul><br><p>  Como resultado, surgió el problema del uso mutuo de componentes.  Los componentes casi no podían usar otros componentes porque representaban "cajas negras" entre sí.  Esto afectó negativamente a la empresa, ya que los componentes no solo no se reutilizaron, sino que a menudo no mejoraron.  Muchos componentes se duplicaron, la cantidad de código que tenía que ser compatible crecía significativamente.  Generalmente nos movíamos más despacio de lo que podíamos. </p><br><h3 id="edinyy-repozitoriy-i-infrastruktura">  Repositorio único e infraestructura </h3><br><p>  Hace 5 años, comenzamos un proyecto para transferir el desarrollo a un único repositorio, con sistemas comunes de ensamblaje, prueba, implementación y monitoreo. </p><br><p>  El objetivo principal que queríamos lograr era eliminar los obstáculos que impiden la integración del código de otra persona.  El sistema debe proporcionar un acceso fácil al código de trabajo terminado, un esquema claro para su conexión y uso, capacidad de recolección: los proyectos siempre se recopilan (y pasan las pruebas). </p><br><p>  Como resultado del proyecto, surgió una sola pila de tecnologías de infraestructura para la empresa: almacenamiento de código fuente, sistema de revisión de código, sistema de construcción, sistema de integración continua, implementación, monitoreo. </p><br><p>  Ahora, la mayor parte del código fuente para los proyectos de Yandex se almacena en un único repositorio, o está en proceso de pasar a él: </p><br><ul><li>  Más de 2000 desarrolladores trabajan en proyectos. </li><li>  Más de 50,000 proyectos y bibliotecas. </li><li>  El tamaño del repositorio supera los 25 GB. </li><li>  Ya se han comprometido más de 3.000.000 de confirmaciones en el repositorio. </li></ul><br><p>  Ventajas para la empresa: </p><br><ul><li>  Cualquier proyecto del repositorio recibe una infraestructura preparada: <br><ul><li>  un sistema para ver y navegar el código fuente y un sistema de revisión de código. </li><li>  Sistema de montaje y montaje distribuido.  Este es un gran tema separado, y definitivamente lo cubriremos en los siguientes artículos. </li><li>  Sistema de integración continua. </li><li>  implementación, integración con el sistema de monitoreo. </li></ul></li><li>  código compartido, interacción activa del equipo. </li><li>  todo el código es común, puede venir a otro proyecto y hacer los cambios que necesita allí.  Esto es especialmente importante en una gran empresa, porque otro equipo del que necesita algo puede no tener los recursos.  Con el código común, tiene la oportunidad de hacer parte del trabajo usted mismo y "ayudar a que suceda" los cambios que necesita. </li><li>  Existe la oportunidad de llevar a cabo una refactorización global.  No necesita admitir versiones antiguas de su API o biblioteca, puede cambiarlas y cambiar los lugares donde se usan en otros proyectos. </li><li>  el código se vuelve menos "diverso".  Tiene un conjunto de formas de resolver problemas, y no es necesario agregar otra forma que haga lo mismo, pero con ligeras diferencias. </li><li>  en el proyecto a su lado, lo más probable es que no haya bibliotecas y lenguajes absolutamente exóticos. </li></ul><br><p>  También debe entenderse que dicho modelo de desarrollo tiene desventajas que deben considerarse: </p><br><ul><li>  Un repositorio compartido requiere una infraestructura separada y específica. </li><li>  la biblioteca que necesita puede no estar en el repositorio, pero está en código abierto.  Hay costos para agregarlo y actualizarlo.  Muy dependiente del idioma y la biblioteca, en algún lugar casi gratis, en algún lugar muy costoso. </li><li>  necesita trabajar constantemente en la "salud" del código.  Esto incluye al menos la lucha contra las dependencias innecesarias y el código muerto. </li></ul><br><p>  Nuestro enfoque hacia un repositorio común impone reglas generales que todos deben seguir.  En el caso de utilizar un único repositorio, se imponen restricciones en los idiomas utilizados, las bibliotecas y los métodos de implementación.  Pero en el proyecto vecino todo será igual o muy similar al tuyo, e incluso puedes arreglar algo allí. </p><br><p>  El modelo de un repositorio común gravita en todas las grandes empresas.  El repositorio monolítico es un tema amplio, bien estudiado y discutido, por lo que ahora no entraremos mucho en él.  Si desea saber más, al final del artículo encontrará varios enlaces útiles que revelan este tema con más detalle. </p><br><h3 id="usloviya-v-kotoryh-rabotaet-sistema-nepreryvnoy-integracii">  Condiciones en las que opera el sistema de integración continua </h3><br><p>  El desarrollo se lleva a cabo de acuerdo con el modelo de desarrollo basado en Trunk.  La mayoría de los usuarios trabajan con HEAD, o la copia más reciente del repositorio, obtenida de la rama principal llamada troncal, en la que se está desarrollando.  La confirmación de los cambios en el repositorio se realiza de forma secuencial.  Inmediatamente después de la confirmación, el nuevo código es visible y puede ser utilizado por todos los desarrolladores.  No se recomienda el desarrollo en ramas separadas, aunque las ramas se pueden usar para lanzamientos. </p><br><p>  Los proyectos dependen del código fuente.  Los proyectos y las bibliotecas forman un gráfico de dependencia complejo.  Y esto significa que los cambios realizados en un proyecto afectan potencialmente al resto del repositorio. </p><br><p>  Una gran secuencia de confirmaciones va al repositorio: </p><br><ul><li>  Más de 2000 confirmaciones por día. </li><li>  hasta 10 cambios por minuto durante las horas pico. </li></ul><br><p>  La base de código contiene más de 500,000 objetivos de compilación y pruebas. </p><br><p>  Sin un sistema especial de integración continua en tales condiciones, sería muy difícil avanzar rápidamente. </p><br><h3 id="sistema-nepreryvnoy-integracii">  Sistema de integración continua </h3><br><p>  El sistema de integración continua lanza ensamblajes y pruebas para cada cambio: </p><br><ul><li>  Verificaciones preliminares.  Permiten verificar el código antes de comprometerse y evitar romper las pruebas en el tronco.  Los ensamblajes y las pruebas se ejecutan encima de HEAD.  Por el momento, los controles previos a la auditoría se inician voluntariamente.  Para proyectos críticos, se requieren verificaciones previas a la auditoría. </li><li>  Verificaciones posteriores a la confirmación después de confirmar en el repositorio. </li></ul><br><p>  Las compilaciones y las pruebas se ejecutan en paralelo en grandes grupos de cientos de servidores.  Las compilaciones y las pruebas se ejecutan en diferentes plataformas.  Bajo la plataforma principal (Linux), todos los proyectos se ensamblan y todas las pruebas se ejecutan, bajo las otras plataformas, un subconjunto de las configurables por el usuario. </p><br><p>  Después de recibir y analizar los resultados de los ensamblajes y ejecutar las pruebas, el usuario recibe comentarios, por ejemplo, si los cambios rompen alguna prueba. </p><br><img src="https://habrastorage.org/webt/kr/7s/re/kr7srek9pwwq-88vz8b3orjmtqc.png"><br><br><p>  En caso de nuevas fallas de ensamblaje o pruebas, enviamos una notificación a los propietarios de las pruebas y al autor de los cambios.  El sistema también almacena y muestra los resultados de las comprobaciones en una interfaz especial.  La interfaz web del sistema de integración muestra el progreso y el resultado de la prueba, desglosados ​​por tipo de prueba.  La pantalla con los resultados del análisis ahora puede verse así: </p><br><img src="https://habrastorage.org/webt/c_/p-/p3/c_p-p3pb17bzgmefh0-su2gmrnc.png"><br><br><h3 id="osobennosti-i-vozmozhnosti-sistemy-nepreryvnoy-integracii">  Características y capacidades del sistema de integración continua. </h3><br><p>  Resolviendo varios problemas que enfrentan los desarrolladores y probadores, desarrollamos nuestro sistema de integración continua.  El sistema ya resuelve muchos problemas, pero queda mucho por mejorar. </p><br><h4 id="tipy-i-razmery-testov">  Tipos y tamaños de pruebas. </h4><br><p>  Hay varios tipos de objetivos que puede activar un sistema de integración continua: </p><br><ul><li>  configurar  La fase de configuración realizada por el sistema de compilación.  La configuración incluye un análisis de los archivos de configuración del sistema de ensamblaje, determinando las dependencias entre los proyectos y los parámetros del ensamblaje y ejecutando las pruebas. </li><li>  construir.  Montaje de bibliotecas y proyectos. </li><li>  estilo  En esta etapa, el estilo del código coincide con los requisitos especificados. </li><li>  prueba  Las pruebas se dividen en etapas según su tiempo de espera para el tiempo de trabajo y los requisitos para los recursos informáticos. <br><ul><li>  pequeño  &lt;1 min </li><li>  medio  &lt;10 min </li><li>  grande  &gt; 10 min  Además, puede haber requisitos especiales para los recursos informáticos. </li><li>  extra grande  Este es un tipo especial de prueba.  Dichas pruebas se caracterizan por un conjunto de las siguientes características: un tiempo de funcionamiento prolongado, un gran consumo de recursos, una gran cantidad de datos de entrada, pueden requerir accesos especiales y, lo más importante, soporte para los escenarios de prueba complejos que se describen a continuación.  Hay menos pruebas de este tipo que otros tipos de pruebas, pero son muy importantes. </li></ul></li></ul><br><h4 id="chastota-zapuska-testov-i-binarnyy-poisk-polomok">  Pruebe la frecuencia de lanzamiento y la detección de fallas binarias </h4><br><p>  Se asignan enormes recursos para pruebas en Yandex, cientos de servidores potentes.  Pero incluso con una gran cantidad de recursos, no podemos ejecutar todas las pruebas para cada cambio que los afecte.  Pero al mismo tiempo, es muy importante para nosotros ayudar siempre al desarrollador a localizar el lugar donde se rompe la prueba, especialmente en un repositorio tan grande. </p><br><p>  Que estamos haciendo  Para cada cambio para todos los proyectos afectados, se ejecutan ensamblajes, comprobaciones de estilo y pruebas con tamaños pequeños y medianos.  El resto de las pruebas se ejecutan no para cada confirmación que influye, sino con cierta periodicidad, si hay confirmaciones que afectan las pruebas.  En algunos casos, los usuarios pueden controlar la frecuencia de inicio; en otros casos, el sistema establece la frecuencia de inicio.  Cuando se detecta una falla de prueba, comienza el proceso de búsqueda de una confirmación de ruptura de prueba.  Cuanto menos se ejecute la prueba, más tiempo buscaremos una confirmación de ruptura después de detectar una falla. </p><br><img width="700" src="https://habrastorage.org/webt/1b/7r/hg/1b7rhgcpvzuuqnkue2cmn8yytam.png"><br><br><p>  Al iniciar las comprobaciones previas a la auditoría, también ejecutamos solo ensamblajes y pruebas ligeras.  Luego, el usuario puede iniciar manualmente el lanzamiento de pruebas pesadas seleccionando de la lista de pruebas afectadas por los cambios proporcionados por el sistema. </p><br><h4 id="obnaruzhenie-migayuschih-testov">  Detección de prueba intermitente </h4><br><p>  Las pruebas intermitentes son pruebas cuyos resultados de ejecución (Aprobado / Fallido) en el mismo código pueden depender de varios factores.  Las causas de las pruebas de flasheo pueden ser diferentes: suspensión en el código de prueba, errores al trabajar con subprocesos múltiples, problemas de infraestructura (falta de disponibilidad de cualquier sistema), etc.  Las pruebas intermitentes presentan un problema grave: </p><br><ul><li>  Conducen al hecho de que el sistema de integración continua envía alertas falsas sobre fallas en las pruebas. </li><li>  Contaminar los resultados de la prueba.  Cada vez es más difícil decidir sobre el éxito de los resultados de la verificación. </li><li>  Retrasar lanzamientos de productos. </li><li>  Difícil de detectar.  Las pruebas pueden parpadear muy raramente. <br>  Los desarrolladores pueden ignorar las pruebas parpadeantes al analizar los resultados de las pruebas.  A veces incorrecto <br>  Es imposible eliminar por completo las pruebas de parpadeo, esto debe tenerse en cuenta en un sistema de integración continua. </li></ul><br><p>  Actualmente, para cada prueba, ejecutamos todas las pruebas dos veces para detectar pruebas de flasheo.  También tomamos en cuenta las quejas de los usuarios (destinatarios de las notificaciones).  Si detectamos un parpadeo, marcamos la prueba con una bandera especial (silenciada) e informamos al propietario de la prueba.  Después de esto, solo los propietarios de las pruebas recibirán notificaciones de fallas en las pruebas.  A continuación, continuamos ejecutando la prueba en modo normal, mientras analizamos el historial de sus lanzamientos.  Si la prueba no parpadeó en un período de tiempo determinado, la automatización puede decidir que la prueba ha dejado de parpadear y puede borrar la bandera. </p><br><p>  Nuestro algoritmo actual es bastante simple y se planean muchas mejoras en este lugar.  En primer lugar, queremos usar señales mucho más útiles. </p><br><h4 id="avtomaticheskoe-obnovlenie-vhodnyh-dannyh-testov">  Actualización automática de entrada de prueba </h4><br><p>  Cuando se prueban los sistemas Yandex más complejos, además de otros métodos de prueba, a menudo se utilizan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pruebas de estrategia de caja negra</a> + <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pruebas basadas en datos</a> .  Para garantizar una buena cobertura, tales pruebas requieren un gran conjunto de datos de entrada.  Los datos se pueden seleccionar de grupos de producción.  Pero hay un problema con el hecho de que los datos se vuelven obsoletos rápidamente.  El mundo no se detiene, nuestros sistemas están en constante evolución.  Los datos de prueba obsoletos a lo largo del tiempo no proporcionarán una buena cobertura de prueba, y luego conducirán completamente a un desglose de la prueba debido al hecho de que los programas comienzan a usar datos nuevos que no están disponibles en los datos de prueba obsoletos. </p><br><p>  Para que los datos no queden desactualizados, el sistema de integración continua puede actualizarlos automáticamente.  Como funciona </p><br><ol><li>  Los datos de prueba se almacenan en un almacenamiento especial de recursos. </li><li>  La prueba contiene metadatos que describen la entrada requerida. </li><li>  La correspondencia entre la entrada de prueba requerida y los recursos se almacena en un sistema de integración continua. </li><li>  El desarrollador proporciona la entrega regular de datos nuevos al almacén de recursos. </li><li>  El sistema de integración continua busca nuevas versiones de datos de prueba en el repositorio de recursos y cambia los datos de entrada. </li></ol><br><p>  Es importante actualizar los datos para que no se realice la prueba falsa.  No puede simplemente tomar y, a partir de una determinada confirmación, comenzar a usar nuevos datos, porque  En el caso de un desglose de la prueba, no estará claro quién es el culpable: el compromiso o los nuevos datos.  También hará que las pruebas de diferencias (descritas a continuación) no funcionen. </p><br><img width="600" src="https://habrastorage.org/webt/yz/xq/ew/yzxqew6kgfu-irgksx-mbgejtz8.png"><br><p>  Por lo tanto, lo hacemos para que haya un pequeño intervalo de confirmaciones, en el que la prueba se inicia tanto con la versión anterior como con la nueva de los datos de entrada. </p><br><img width="700" src="https://habrastorage.org/webt/r1/zr/j8/r1zrj8e-kxo8bmnd0evq6tgzktg.png"><br><br><h4 id="diff-testy">  Diferentes pruebas </h4><br><p>  Las pruebas de diferencia que llamamos un tipo especial de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pruebas basadas en datos</a> , que difieren del enfoque generalmente aceptado en que la prueba no tiene un resultado de referencia, pero al mismo tiempo necesitamos encontrar en qué confirmaciones la prueba cambió su comportamiento. </p><br><p>  El enfoque estándar en las pruebas basadas en datos es el siguiente.  La prueba tiene un resultado de referencia obtenido cuando la prueba se ejecutó por primera vez.  El resultado de referencia se puede almacenar en el repositorio al lado de la prueba.  Las ejecuciones posteriores de la prueba deberían producir el mismo resultado. </p><br><img width="600" src="https://habrastorage.org/webt/gj/bq/gx/gjbqgx1rtrgb1lwxhih01ojki3k.png"><br><p>  Si el resultado difiere de la referencia, el desarrollador debe decidir si este cambio esperado o error.  Si se espera el cambio, el desarrollador debe actualizar el resultado de referencia al mismo tiempo que confirma los cambios en el repositorio. </p><br><p>  Existen dificultades al usar este enfoque en un repositorio grande con grandes flujos de confirmación: </p><br><ol><li>  Puede haber muchas pruebas y las pruebas pueden ser muy difíciles.  El desarrollador no tiene la capacidad de ejecutar todas las pruebas afectadas en un entorno de trabajo. </li><li>  Después de realizar cambios, la prueba puede interrumpirse si el resultado de referencia no se actualizó simultáneamente con los cambios en el código.  Luego, otro desarrollador puede hacer cambios en el mismo componente y el resultado de la prueba cambiará nuevamente.  Obtenemos la imposición de un error sobre otro.  Es muy difícil lidiar con tales problemas, lleva tiempo de los desarrolladores. </li></ol><br><p>  Que estamos haciendo  Las pruebas de diferencias constan de 2 partes: </p><br><ul><li>  Comprobar componente. <br><ul><li>  Comenzamos la prueba y guardamos el resultado en el almacenamiento de recursos. </li><li>  No compare el resultado con la referencia. </li><li>  Podemos detectar algunos de los errores, por ejemplo, el programa no se inicia / no finaliza, se bloquea, el programa no responde.  La validación del resultado también se puede realizar: la presencia de cualquier campo en la respuesta, etc. </li></ul></li><li>  Componente diferencial. <br><ul><li>  Compare los resultados obtenidos en diferentes lanzamientos y compile diff.  En el caso más simple, esta es una función que toma 2 parámetros y devuelve diff. </li><li>  La apariencia de diff depende de la prueba, pero debería ser algo comprensible para alguien que lo vea.  diff    html . </li></ul></li></ul><br><p>  check  diff     . </p><br><img width="600" src="https://habrastorage.org/webt/jp/g2/2z/jpg22zjvje4rqvytyy8-qlrf-yo.png"><br><br><p>      diff,        .         diff     ,   :  diff  (     )   / ""  . </p><br><h3 id="prodolzhenie-sleduet">  Para continuar </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a>    ,     . </p><br><h3 id="ssylki">  Referencias </h3><br><p>  , Trunk-based development </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Monorepo — Wikipedia</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://trunkbaseddevelopment.com</a> </li></ul><br><p> Data-driven testing </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Data-driven testing — Wikipedia</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es428972/">https://habr.com/ru/post/es428972/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es428954/index.html">Cómo nos disparamos en la pierna y tratamos de averiguar qué es exactamente</a></li>
<li><a href="../es428956/index.html">Drones en la ISS</a></li>
<li><a href="../es428960/index.html">Informe del Club de Roma 2018, Capítulo 1.5: Desafío climático</a></li>
<li><a href="../es428962/index.html">Reubicación en Luxoft: como queda la vida</a></li>
<li><a href="../es428964/index.html">Las vulnerabilidades de SSD cifradas por hardware permiten a los atacantes eludir fácilmente las medidas de protección</a></li>
<li><a href="../es428974/index.html">Interesante en Interlight 2018</a></li>
<li><a href="../es428976/index.html">Hormiguero o fortaleza? Estoy construyendo una casa por el precio de un apartamento. Parte 2: calentamiento</a></li>
<li><a href="../es428980/index.html">JavaScript Offline Broker</a></li>
<li><a href="../es428982/index.html">Cómo escribir D en ARM</a></li>
<li><a href="../es428984/index.html">Julia y retratos de fase de sistemas dinámicos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>