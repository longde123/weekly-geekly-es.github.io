<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚓 👩🏿‍🤝‍👨🏾 🏪 Docotic.Pdf: Welche Probleme erkennt PVS-Studio in einem ausgereiften Projekt? 😜 🐢 👩‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Qualität ist uns wichtig. Und wir haben von PVS-Studio gehört. All dies führte zu dem Wunsch, Docotic.Pdf zu überprüfen und herauszufinden, was noch v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docotic.Pdf: Welche Probleme erkennt PVS-Studio in einem ausgereiften Projekt?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425741/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/tt/fj/-u/ttfj-uhwy2ogamewgz6zit48lni.png" alt="Docotic.Pdf und PVS-Studio"></div><br>  Qualität ist uns wichtig.  Und wir haben von PVS-Studio gehört.  All dies führte zu dem Wunsch, Docotic.Pdf zu überprüfen und herauszufinden, was noch verbessert werden kann. <br><a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docotic.Pdf</a> ist eine Allzweckbibliothek für die Arbeit mit PDF-Dateien.  Es ist in C # geschrieben, es gibt keinen unsicheren Code, keine anderen externen Abhängigkeiten als die .NET-Laufzeit.  Es funktioniert sowohl unter .NET 4+ als auch unter .NET Standard 2+. <br><br>  Die Bibliothek befindet sich seit etwas mehr als 10 Jahren in der Entwicklung und verfügt über 110.000 Codezeilen, ohne Tests, Beispiele und andere Dinge zu berücksichtigen.  Für die statische Analyse verwenden wir ständig Code Analysis und StyleCop.  Mehrere tausend automatisierte Tests schützen uns vor Regressionen.  Unsere Kunden aus verschiedenen Ländern und Branchen vertrauen auf die Qualität der Bibliothek. <br><br>  Welche Probleme erkennt PVS-Studio? <br><br><h3>  Installation und erster Eindruck </h3><br>  Ich habe die Testversion von der PVS-Studio-Website heruntergeladen.  Angenehm überrascht von der geringen Größe des Installateurs.  Mit Standardeinstellungen installiert: Analyse-Engines, eine separate PVS-Studio-Umgebung, Integration in Visual Studio 2017. <br><br>  Nach der Installation wurde nichts gestartet und dem Startmenü wurden zwei Verknüpfungen mit denselben Symbolen hinzugefügt: Standalone und PVS-Studio.  Für einen Moment überlegte ich, was ich anfangen sollte.  Standalone gestartet und war von der Benutzeroberfläche unangenehm überrascht.  Die für Windows festgelegte 200% -Skala wird schief unterstützt.  Ein Teil des Textes ist zu klein, ein Teil des Textes passt nicht in den dafür vorgesehenen Raum.  Der Name, das Einhorn und die Aktionsliste werden für jede Fenstergröße zugeschnitten.  Auch bei Vollbild. <br><br><img src="https://habrastorage.org/webt/ll/3k/c5/ll3kc5bovj5wkbvtldfz9zhzpzk.png"><br><br>  Okay, ich habe beschlossen, meine Projektdatei zu öffnen.  Plötzlich fand das Menü Datei keine solche Gelegenheit.  Dort wurde mir nur angeboten, einzelne Dateien zu öffnen.  Danke, dachte ich, ich würde lieber eine andere Option ausprobieren.  PVS-Studio gestartet - sie zeigten mir ein Fenster mit verschwommenem Text.  Die Skala von 200% machte sich erneut bemerkbar.  Der gemeldete Text: <s>Suchen Sie in Three Crowns nach mir,</s> suchen Sie in Visual Studio nach dem PVS-Studio-Menü.  Ok, öffnete das Studio. <br><br>  Geöffnete Lösung.  In der Tat gibt es ein PVS-Studio-Menü, mit dem das „Aktuelle Projekt“ überprüft werden kann.  Er hat das Projekt, das ich brauche, aktuell gemacht und einen Check gestartet.  Im Studio wurde ein Fenster mit den Ergebnissen der Analyse angezeigt.  Im Hintergrund erschien ein Fenster mit dem Fortschritt des Scans, das ich jedoch nicht sofort fand.  Zuerst hatte man das Gefühl, dass die Prüfung nicht begann oder sofort endete. <br><br><h3>  Erstes Prüfergebnis </h3><br>  Der Analysator überprüfte alle 1253 Projektdateien in ungefähr 9 Minuten und 30 Sekunden.  Am Ende der Prüfung änderte sich der Dateizähler nicht so schnell wie zu Beginn.  Möglicherweise besteht eine nichtlineare Abhängigkeit der Scandauer von der Anzahl der gescannten Dateien. <br><br>  Informationen zu 81 hohen, 109 mittleren und 175 niedrigen Warnungen wurden im Ergebnisfenster angezeigt.  Wenn Sie die Häufigkeit berechnen, erhalten Sie 0,06 hohe Warnungen / Datei, 0,09 mittlere Warnungen / Datei und 0,14 niedrige Warnungen / Datei.  Oder <br>  0,74 Hohe Warnungen pro tausend Codezeilen, 0,99 Mittlere Warnungen pro tausend Codezeilen und 1,59 Niedrige Warnungen pro tausend Codezeilen. <br><br>  Hier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in diesem Artikel</a> wird darauf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hingewiesen,</a> dass der Analysator in CruiseControl.NET mit seinen 256.000 Codezeilen 15 Warnungen für Hoch, 151 Mittel und 32 Niedrig gefunden hat. <br><br>  Es stellt sich heraus, dass in Docotic.Pdf prozentual mehr Warnungen in jeder der Gruppen ausgegeben wurden. <br><br><h3>  Was wird gefunden? </h3><br>  Ich habe mich entschlossen, niedrige Warnungen zu diesem Zeitpunkt zu ignorieren. <br><br>  Ich habe die Warnungen nach der Spalte Code sortiert und es stellte sich heraus, dass der absolute Rekordhalter für die Häufigkeit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3022</a> „Ausdruck ist immer wahr / falsch“ und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3063</a> „Ein Teil des bedingten Ausdrucks ist immer wahr / falsch, wenn er ausgewertet wird“ war.  Meiner Meinung nach geht es um eine Sache.  Insgesamt ergeben diese beiden Warnungen 92 von 190 Fällen. Relative Häufigkeit = 48%. <br><br>  Die Logik der Unterteilung in Hoch und Mittel ist nicht ganz klar.  Ich hatte erwartet, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3072</a> "Die ' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">A'</a> -Klasse, die IDisposable-Mitglieder enthält, IDisposable selbst nicht implementiert" und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3073</a> "Nicht alle IDisposable-Mitglieder sind ordnungsgemäß entsorgt.  Rufen Sie 'Dispose' auf, wenn Sie beispielsweise 'A' class 'in der High-Gruppe entsorgen.  Aber das ist natürlich Geschmack. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Überrascht,</a> dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3095</a> „Das Objekt wurde verwendet, bevor es gegen Null verifiziert wurde.  Kontrolllinien: N1, N2 ”ist doppelt so hoch und einmal so mittel markiert.  Bug? <br><br><img src="https://habrastorage.org/webt/kz/dk/e8/kzdke88cvkewlgqplmw4xlp55ym.png"><br><br><h3>  Vertrauen, aber überprüfen </h3><br>  Es ist Zeit zu überprüfen, wie vernünftig die Warnungen sind.  Gibt es echte Fehler?  Gibt es falsche Warnungen? <br><br>  Ich habe die gefundenen Warnungen in die folgenden Gruppen unterteilt. <br><br><h4>  Wichtige Warnungen </h4><br>  Ihre Korrektur erhöhte die Stabilität, löste Probleme mit Speicherlecks usw.  Echte Fehler / Unvollkommenheiten. <br><br>  16 davon wurden ausgegeben, was etwa 8% aller Warnungen entspricht. <br><br>  Ich werde einige Beispiele geben. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3019</a> "Möglicherweise wird eine falsche Variable nach der Typkonvertierung mit dem Schlüsselwort 'as' mit null verglichen.  Überprüfen Sie die Variablen 'Farbe', 'indiziert' » <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsCompatible</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ColorImpl color</span></span></span><span class="hljs-function">)</span></span> { IndexedColorImpl indexed = color <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> IndexedColorImpl; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (color == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> indexed.ColorSpace.Equals(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  Wie Sie sehen können, wird die variable Farbe anstelle von indiziert mit null verglichen.  Dies ist falsch und kann zu NRE führen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080</a> “Mögliche Null-Dereferenzierung.  Überprüfen Sie 'cstr_index.tile_index' » <br><br>  Ein kleines Fragment zur Veranschaulichung: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cstr_index.tile_index == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cstr_index.tile_index[<span class="hljs-number"><span class="hljs-number">0</span></span>].tp_index == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// .. } }</span></span></code> </pre><br>  Offensichtlich implizierte die erste Bedingung! = Null.  In der aktuellen Form löst der Code bei jedem Aufruf NRE aus. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3083</a> “Unsicherer Aufruf des Ereignisses 'OnProgress', NullReferenceException ist möglich.  Überlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen möchten, bevor Sie es aufrufen. “ <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Updated</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (OnProgress != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) OnProgress(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventArgs()); }</code> </pre><br>  Eine Warnung hat geholfen, eine mögliche Ausnahme zu beheben.  Warum kann es entstehen?  Stackoverflow hat eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gute Erklärung</a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3106</a> „Möglicherweise ist der Index außerhalb der Grenzen.  Der '0'-Index zeigt über die' v'-Grenze hinaus » <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;FontStringPair&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; text.Length; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;FontStringPair&gt;(); createPairs(text[i].ToString(CultureInfo.InvariantCulture)); result.Add(v[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre><br>  Der Fehler besteht darin, dass das Ergebnis von createPairs ignoriert wird und stattdessen auf eine leere Liste zugegriffen wird.  Anscheinend hat createPairs die Liste zunächst als Parameter akzeptiert, aber beim Ändern der Methode ist ein Fehler aufgetreten. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3117</a> 'Konstruktorparameter' validateType 'wird nicht verwendet <br><br>  Für einen ähnlichen Code wurde eine Warnung ausgegeben <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IDocument document, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> validateType = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">document, </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span></span><span class="hljs-function">)</span></span> { m_provider = document; }</code> </pre><br>  Die Warnung selbst scheint nicht wichtig zu sein.  Das Problem ist jedoch schwerwiegender, als es auf den ersten Blick scheint.  Beim Hinzufügen des optionalen Parameters validateType wurde vergessen, den Aufruf an den Konstruktor der Basisklasse zu korrigieren. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3127</a> „Es wurden zwei ähnliche Codefragmente gefunden.  Vielleicht ist dies ein Tippfehler und die Variable 'range' sollte anstelle von 'domain' verwendet werden. “ <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillTransferFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PdfStreamImpl function</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// .. PdfArrayImpl domain = new PdfArrayImpl(); domain.AddReal(0); domain.AddReal(1); function.Add(Field.Domain, domain); PdfArrayImpl range = new PdfArrayImpl(); range.AddReal(0); range.AddReal(1); function.Add(Field.Range, domain); // .... }</span></span></code> </pre><br>  Möglicherweise wird keine Warnung ausgegeben, wenn sich die Teile des Codes geringfügig unterscheiden.  In diesem Fall wurde jedoch beim Kopieren und Einfügen ein Fehler festgestellt. <br><br><h4>  Theoretische / formale Warnungen </h4><br>  Sie sind entweder korrekt, aber ihre Korrektur behebt keine spezifischen Fehler und beeinträchtigt nicht die Lesbarkeit des Codes.  Oder sie zeigen auf Stellen, an denen möglicherweise ein Fehler vorliegt, der jedoch nicht vorhanden ist.  Beispielsweise wird die Reihenfolge der Parameter absichtlich geändert.  Für solche Warnungen müssen Sie nichts im Programm ändern. <br><br>  Davon wurden 57 ausgegeben, was etwa 30% aller Warnungen entspricht.  Ich werde Beispiele für Fälle geben, die Aufmerksamkeit verdienen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3013</a> „Es ist seltsam, dass der Hauptteil der Funktion 'BeginText' dem Hauptteil der Funktion 'EndText' (166, Zeile 171) vollständig entspricht.“ <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { m_state.ResetTextParameters(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EndText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { m_state.ResetTextParameters(); }</code> </pre><br>  Beide Körperfunktionen sind eigentlich gleich.  Aber es ist richtig.  Und ist es wirklich so seltsam, wenn die Funktionskörper einer Zeile zusammenfallen? <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3106</a> „Möglicher negativer Indexwert.  Der Wert des 'c1'-Index könnte -1 erreichen. “ <br><br><pre> <code class="cs hljs">freq[<span class="hljs-number"><span class="hljs-number">256</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// .... c1 = -1; v = 1000000000L; for (i = 0; i &lt;= 256; i++) { if (freq[i] != 0 &amp;&amp; freq[i] &lt;= v) { v = freq[i]; c1 = i; } } // .... freq[c1] += freq[c2];</span></span></code> </pre><br>  Ich stimme zu, ich habe einen Teil des nicht so klaren Algorithmus gegeben.  Aber meiner Meinung nach macht sich der Analysator in diesem Fall vergeblich Sorgen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3107</a> "Identischer Ausdruck" Nachbar "links und rechts von der zusammengesetzten Zuordnung" <br><br>  Die Warnung wird durch einen ziemlich alltäglichen Code verursacht: <br><br><pre> <code class="cs hljs">neighsum += neighsum;</code> </pre><br>  Ja, es kann durch Multiplikation umgeschrieben werden.  Aber es gibt keinen Fehler. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3109</a> „Der Unterausdruck 'l_cblk.data_current_size' ist auf beiden Seiten des Operators vorhanden.  Der Ausdruck ist falsch oder kann vereinfacht werden. “ <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/* Check possible overflow on size */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((l_cblk.data_current_size + l_seg.newlen) &lt; l_cblk.data_current_size) { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>  Ein Kommentar im Code verdeutlicht die Absicht.  Wieder falscher Alarm. <br><br><h4>  Begründete Warnungen </h4><br>  Ihre Korrektur wirkte sich positiv auf die Lesbarkeit des Codes aus.  Das heißt, es wurden unnötige Bedingungen, Überprüfungen usw. reduziert.  Die Auswirkung auf die Funktionsweise des Codes ist nicht offensichtlich. <br><br>  Davon wurden 103 ausgegeben, was etwa 54% aller Warnungen entspricht. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3008</a> „Der Variablen 'l_mct_deco_data' werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler “ <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_nb_mct_records == m_nb_max_mct_records) { ResizeMctRecords(); l_mct_deco_data = (OPJ_INT32)m_nb_mct_records; } l_mct_deco_data = (OPJ_INT32)m_nb_mct_records;</code> </pre><br>  Rechte-Analysator: Zuordnung innerhalb, falls nicht erforderlich. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3009</a> „Es ist seltsam, dass diese Methode immer ein und denselben Wert zurückgibt.“ <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opj_dwt_decode_tile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">opj_tcd_tilecomp_t tilec, OPJ_UINT32 numres</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numres == <span class="hljs-number"><span class="hljs-number">1U</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... return true; }</span></span></code> </pre><br>  Auf Anraten des Analysators wurde die Methode geändert und gibt nichts mehr zurück. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3022</a> "Ausdruck '! Hinzufügen' ist immer wahr" <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addToFields</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PdfDictionaryImpl controlDict, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">add</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... if (add) { // .. return; } if (!add) { // ... } // ... }</span></span></code> </pre><br>  In der Tat hat das zweite Wenn keinen Sinn.  Die Bedingung wird immer wahr sein. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3029</a> "Der bedingte Ausdruck der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nebeneinander angeordneten</a> ' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">if'</a> -Anweisungen ist identisch." <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stroke) extGState.OpacityStroke = opacity; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stroke) state.AddReal(Field.CA, opacity);</code> </pre><br>  Es ist unklar, wie dieser Code entstanden ist.  Aber jetzt haben wir es behoben. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3031</a> „Eine übermäßige Prüfung kann vereinfacht werden.  Das '||'  Der Operator ist von entgegengesetzten Ausdrücken umgeben. “ <br><br>  Dies ist ein Albtraum: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(cp.m_enc.m_tp_on != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; ((!opj_codec_t.OPJ_IS_CINEMA(cp.rsiz) &amp;&amp; (t2_mode == J2K_T2_MODE.FINAL_PASS)) || opj_codec_t.OPJ_IS_CINEMA(cp.rsiz)))) { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>  Nach den Änderungen wurde es viel besser <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(cp.m_enc.m_tp_on != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; (opj_codec_t.OPJ_IS_CINEMA(cp.rsiz) || t2_mode == J2K_T2_MODE.FINAL_PASS))) { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3063</a> „Ein Teil des bedingten Ausdrucks ist immer wahr, wenn er ausgewertet wird: x! = Null“ <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3022</a> "Ausdruck 'x! = Null' ist immer wahr" <br><br>  Hier habe ich Warnungen eingefügt, dass die Überprüfung auf Null keinen Sinn macht.  Ob dies richtig ist, ist eine kontroverse Frage.  Im Folgenden habe ich das Wesentliche des Problems ausführlicher beschrieben. <br><br><h4>  Grundlose Warnungen </h4><br>  False Positives  Aufgrund von Fehlern bei der Durchführung eines bestimmten Tests oder einer Art Analysatorfehler. <br><br>  Davon wurden 14 ausgegeben, was etwa 7% aller Warnungen entspricht. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3081</a> “Der ' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">i'</a> -Zähler wird nicht in einer verschachtelten Schleife verwendet.  Überprüfen Sie die Verwendung des 'j'-Zählers. “ <br><br>  Eine leicht vereinfachte Version des Codes, für den diese Warnung ausgegeben wurde: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; initialGlyphsCount - <span class="hljs-number"><span class="hljs-number">1</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; initialGlyphsCount - i - <span class="hljs-number"><span class="hljs-number">1</span></span>; ++j) { <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre><br>  Offensichtlich wird i in einer verschachtelten Schleife verwendet. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3125</a> „Das Objekt wurde verwendet, nachdem es gegen Null verifiziert wurde.“ <br><br>  Code, für den eine Warnung ausgegeben wird: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Compare_SecondGreater</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cmapEncodingRecord er1, cmapEncodingRecord er2</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (er1 == er2) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (er1 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; er2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (er1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; er2 != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> er1.CompareTo(er2); }</code> </pre><br>  er1 kann nicht null sein, wenn CompareTo () aufgerufen wird. <br><br>  Ein weiterer Code, für den diese Warnung ausgegeben wird: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">realloc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] table, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newSize</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] newTable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[newSize][]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> existingSize = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (table != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) existingSize = table.Length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; existingSize; i++) newTable[i] = table[i]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = existingSize; i &lt; newSize; i++) newTable[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>]; table = newTable; }</code> </pre><br>  Tabelle kann in einer Schleife nicht null sein. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3134</a> „Die Verschiebung um [32..255] Bits ist größer als die Größe des Ausdruckstyps 'UInt32' '(uint) 1'“ <br><br>  Ein Code, für den diese Warnung ausgegeben wird: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> bitPos = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(numBits &amp; <span class="hljs-number"><span class="hljs-number">0x1F</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> mask = (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; bitPos;</code> </pre><br>  Es ist ersichtlich, dass bitPos einen Wert aus dem Bereich [0..31] haben kann, aber der Analysator glaubt, dass er einen Wert aus dem Bereich [0..31] haben kann, was falsch ist. <br><br>  Ich werde keine ähnlichen Fälle nennen, da sie gleichwertig sind. <br><br><h4>  Zusätzliche Gedanken zu einigen Schecks </h4><br>  Es schien mir unerwünscht zu warnen, dass 'x! = Null' immer dann wahr ist, wenn x das Ergebnis des Aufrufs einer Methode ist.  Ein Beispiel: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X(...); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X(...); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentOutOfRangeException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(x)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... X x = GetX(..); if (x != null) { // ... } }</span></span></code> </pre><br>  Ja, formal hat der Analysator Recht: x ist immer nicht null, da GetX entweder eine vollwertige Instanz zurückgibt oder eine Ausnahme auslöst.  Aber wird der Code das Entfernen der Prüfung um null verbessern?  Was ist, wenn sich GetX später ändert?  Muss Method die GetX-Implementierung kennen? <br><br>  Innerhalb des Teams waren die Meinungen geteilt.  Es wurde vorgeschlagen, dass die aktuelle Methode einen Vertrag hat, nach dem sie nicht null zurückgeben sollte.  Und es macht keinen Sinn, bei jedem Aufruf redundanten Code „für die Zukunft“ zu schreiben.  Und wenn sich der Vertrag ändert, muss der Anrufcode aktualisiert werden. <br><br>  Zur Unterstützung dieser Meinung wurde das folgende Urteil gefällt: Das Überprüfen auf Null ist wie das Umschließen jedes Aufrufs in try / catch, falls die Methode in Zukunft Ausnahmen auslöst. <br><br>  Infolgedessen beschlossen sie nach dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">YAGNI-</a> Prinzip, die Schecks nicht festzuhalten, und löschten sie.  Alle Warnungen wurden von theoretisch / formal auf gerechtfertigt übertragen. <br><br>  Gerne lese ich Ihre Meinung in den Kommentaren. <br><br><h3>  Schlussfolgerungen </h3><br>  Statische Analyse ist eine gute Sache.  Mit PVS-Studio können Sie echte Fehler finden. <br><br>  Ja, es gibt unangemessene / falsche Warnungen.  Trotzdem hat PVS-Studio echte Fehler in einem Projekt gefunden, das bereits Code Analysis verwendet.  Unser Produkt wird durch Tests ziemlich gut abgedeckt, es wird auf die eine oder andere Weise von unseren Kunden getestet, aber <s>Roboter machen es besser. Eine</s> statische Analyse ist immer noch von Vorteil. <br><br>  Zum Schluss noch einige Statistiken. <br><br><h4>  Top 3 unangemessene Warnungen </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3081</a> „Der ' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">X'</a> -Zähler wird nicht in einer verschachtelten Schleife verwendet.  Überprüfen Sie die Verwendung des 'Y'-Zählers. “ <br>  1 von 1 für unvernünftig befunden <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3125</a> „Das Objekt wurde verwendet, nachdem es gegen null verifiziert wurde.  Linien prüfen: N1, N2 “ <br>  9 von 10 werden für unbegründet erklärt <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3134</a> "Verschiebung um N Bits ist größer als die Größe des Typs" <br>  4 von 5 erwiesen sich als unbegründet <br><br><h4>  Top 3 wichtige Warnungen </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3083</a> “Unsicherer Aufruf des Ereignisses, NullReferenceException ist möglich.  Überlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen möchten, bevor Sie es aufrufen. “ <br>  5 von 5 wurden als wichtig angesehen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3020</a> „Ein bedingungsloses 'Break / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Continue</a> / Return / Goto' innerhalb einer Schleife“ <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080</a> "Mögliche Null-Dereferenzierung" <br>  2 von 2 wurden als wichtig anerkannt. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3019</a> „Es ist möglich, dass eine falsche Variable nach der Typkonvertierung mit dem Schlüsselwort 'as' mit null verglichen wird.“ <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3127</a> „Es wurden zwei ähnliche Codefragmente gefunden.  Vielleicht ist dies ein Tippfehler und 'X'-Variable sollte anstelle von' Y 'verwendet werden. “ <br>  1 von 1 wurde als wichtig angesehen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425741/">https://habr.com/ru/post/de425741/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425727/index.html">Bis zum nächsten Mal</a></li>
<li><a href="../de425729/index.html">Hackathon Pro Willkommen: Wie war der erste Charity SmartMail Hack?</a></li>
<li><a href="../de425731/index.html">Geheimnisse des unmöglichen GPU-Computing</a></li>
<li><a href="../de425737/index.html">Karten auf dem Tisch: Auswählen eines Kartenanbieters für eine mobile Anwendung</a></li>
<li><a href="../de425739/index.html">Microsoft kündigt Project xCloud an - einen hochmodernen Gaming-Streaming-Dienst</a></li>
<li><a href="../de425743/index.html">Psychotherapie Mars im Haus des Saturn und intrazerebrale Injektionen von homöopathischem Psilocybin</a></li>
<li><a href="../de425747/index.html">Was ist mit "Timur und seinem Team" passiert oder Gedanken über die Partnerschaft militanter Techniker?</a></li>
<li><a href="../de425749/index.html">Das Web steht auf dem Spiel. Mach mit und kämpfe für sie</a></li>
<li><a href="../de425751/index.html">Zum ersten Mal wurde erfolgreich eine Polymerprothese implantiert, die die Knochenstruktur imitiert</a></li>
<li><a href="../de425753/index.html">Google+ RIP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>