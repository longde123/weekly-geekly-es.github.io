<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëù ‚ò∏Ô∏è üÖ±Ô∏è Como o quadro de Rise of the Tomb Raider √© renderizado üë®‚Äçüîß ‚õëÔ∏è üôáüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rise of the Tomb Raider (2015) √© a sequela do excelente rein√≠cio de Tomb Raider (2013). Pessoalmente, acho as duas partes interessantes porque elas se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como o quadro de Rise of the Tomb Raider √© renderizado</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436500/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/1k/5p/s6/1k5ps6qnv2soku_ymxsemz7wnxa.gif"></div><br>  Rise of the Tomb Raider (2015) √© a sequela do excelente rein√≠cio de Tomb Raider (2013).  Pessoalmente, acho as duas partes interessantes porque elas se afastaram da s√©rie original estagnada e contaram a hist√≥ria de Lara novamente.  Neste jogo, como no prequel, o enredo toma o centro do palco, fornece mec√¢nicas fascinantes de cria√ß√£o, ca√ßa e escalada / pesquisa. <br><br>  O Tomb Raider usou o Crystal Engine, desenvolvido pela Crystal Dynamics, tamb√©m usado em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Deus Ex: Human Revolution</a> .  A sequela usou um novo mecanismo chamado Foundation, desenvolvido anteriormente para Lara Croft e o Temple of Osiris (2014).  Sua renderiza√ß√£o geralmente pode ser descrita como um mecanismo de ladrilhos com passo de ilumina√ß√£o preliminar, e mais tarde descobriremos o que isso significa.  O mecanismo permite escolher entre os renderizadores DX11 e DX12;  Eu escolhi o √∫ltimo, pelas raz√µes que discutimos abaixo.  Para capturar o quadro, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Renderdoc</a> 1.2 foi usado no Geforce 980 Ti, o jogo inclui todas as fun√ß√µes e decora√ß√µes. <br><br><h2>  Quadro analisado </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/254/df9/0bb/254df90bbbfd5498710f37624e12d1f4.jpg"></div><br>  Para evitar spoilers, direi que nesse quadro os bandidos est√£o perseguindo Lara, porque ela est√° procurando um artefato que eles est√£o procurando.  Este conflito de interesses n√£o pode ser resolvido sem armas.  Lara entrou furtivamente na base inimiga √† noite.  Eu escolhi um quadro com ilumina√ß√£o atmosf√©rica e de contraste, na qual o motor pode se mostrar. <a name="habracut"></a><br><br><h4>  Avan√ßo de profundidade </h4><br>  Aqui, a otimiza√ß√£o usual para muitos jogos √© realizada - um pequeno passo preliminar da profundidade (aproximadamente 100 chamadas de empate).  O jogo renderiza os maiores objetos (e n√£o aqueles que ocupam mais espa√ßo na tela) para aproveitar os recursos do processador de v√≠deo Early-Z.  Leia mais sobre isso em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um artigo da Intel</a> .  Em resumo, as GPUs s√£o capazes de evitar a execu√ß√£o de um sombreador de pixels se puderem determinar que ele se sobrep√µe ao pixel anterior.  Esta √© uma passagem de baixo custo, preenchendo previamente o buffer Z com os valores de profundidade. <br><br>  Nesse ponto, descobri uma t√©cnica interessante de n√≠vel de detalhe (LOD) chamada "fracassar" ou "tabuleiro de damas".  Essa √© uma maneira comum de exibir ou ocultar gradualmente objetos √† dist√¢ncia, para que mais tarde eles possam ser substitu√≠dos por uma malha de qualidade inferior ou ocult√°-los completamente.  Olhe para esse caminh√£o.  Parece que est√° sendo renderizado duas vezes, mas na verdade est√° sendo renderizado com um LOD alto e um LOD baixo na mesma posi√ß√£o.  Cada um dos n√≠veis renderiza os pixels que o outro n√£o processou.  O primeiro LOD possui 182.226 v√©rtices e o segundo LOD possui 47.250. A uma grande dist√¢ncia, eles s√£o indistingu√≠veis, mas um deles √© tr√™s vezes menos caro.  Nesse quadro, o LOD 0 quase desaparece e o LOD 1 √© quase completamente renderizado.  Ap√≥s o desaparecimento completo do LOD 0, apenas o LOD 1 ser√° renderizado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c31/d8d/24e/c31d8d24e58229c27fb4edf6f635974d.png"></div><br>  <i>LOD 0</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bf/3b4/5bb/7bf3b45bbe13521b4bae010f72a702a7.png"></div><br>  <i>LOD 1</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jy/7r/it/jy7rit_bwqm4n0lwpzzlydyx5rs.gif"></div><br>  A textura pseudo-aleat√≥ria e o coeficiente de probabilidade nos permitem descartar pixels que n√£o ultrapassaram o valor limite.  Essa textura √© usada no ROTR.  Pode-se perguntar por que a mistura alfa n√£o √© usada.  A mistura alfa tem muitas desvantagens em compara√ß√£o com o desbotamento. <br><br><ol><li>  <strong>Conveni√™ncia para a passagem preliminar das profundezas:</strong> gra√ßas √† renderiza√ß√£o de um objeto opaco com orif√≠cios feitos, podemos renderizar na passagem preliminar e usar o in√≠cio-z.  Objetos com mistura alfa em um est√°gio t√£o inicial n√£o ser√£o renderizados no buffer de profundidade devido a problemas de classifica√ß√£o. </li><li>  <strong>A necessidade de sombreadores adicionais</strong> : se um renderizador diferido for usado, o sombreador de objetos opacos n√£o conter√° nenhuma ilumina√ß√£o.  Se voc√™ precisar substituir um objeto opaco por um transparente, precisar√° de uma op√ß√£o separada na qual exista ilumina√ß√£o.  Al√©m de aumentar a quantidade de mem√≥ria necess√°ria e a complexidade devido a pelo menos um sombreador adicional para todos os objetos opacos, eles devem ser precisos para evitar que os objetos avancem.  Isso √© complicado por v√°rios motivos, mas tudo se resume ao fato de que a renderiza√ß√£o agora √© feita em um caminho de c√≥digo diferente. </li><li>  <strong>Redesenhos maiores</strong> : a mistura alfa pode criar redesenhos grandes e, em um certo n√≠vel de complexidade de objetos, uma grande fra√ß√£o da largura de banda pode ser necess√°ria para sombrear o LOD. </li><li>  <strong>Z-conflitos</strong> : z-conflitos s√£o um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">efeito de cintila√ß√£o</a> quando dois pol√≠gonos s√£o renderizados a uma profundidade muito pr√≥xima um do outro.  Nesse caso, a imprecis√£o dos c√°lculos de ponto flutuante obriga a serem renderizados por sua vez.  Se renderizarmos dois LODs consecutivos, ocultando gradualmente um e mostrando o segundo, eles podem causar um conflito z, porque est√£o muito pr√≥ximos um do outro.  Sempre h√° maneiras de contornar isso, por exemplo, preferindo um pol√≠gono a outro, mas esse sistema √© complexo. </li><li>  <strong>Efeitos do buffer Z</strong> : muitos efeitos como o SSAO usam apenas o buffer de profundidade.  Se renderizamos objetos transparentes no final do pipeline quando a oclus√£o do ambiente j√° estava conclu√≠da, n√£o poder√≠amos levar em considera√ß√£o. </li></ol><br>  A desvantagem dessa t√©cnica √© que ela parece pior do que a mistura alfa, mas um bom padr√£o de ru√≠do, borr√£o ap√≥s o fracasso ou anti-aliasing tempor√°rio podem quase ocult√°-la completamente.  Nesse sentido, o ROTR n√£o faz nada particularmente incomum. <br><br><h4>  Passe Normal </h4><br>  O Crystal Dynamics usa um padr√£o de ilumina√ß√£o bastante incomum em seus jogos, que abordaremos no corredor de ilumina√ß√£o.  Por enquanto, basta dizer que o mecanismo n√£o possui um passe G-buffer;  pelo menos na medida em que √© familiar em outros jogos.  Nesta passagem, os objetos transmitem apenas informa√ß√µes sobre a profundidade e os normais √† sa√≠da.  As normais s√£o registradas no destino de renderiza√ß√£o do formato RGBA16_SNORM no espa√ßo do mundo.  √â curioso que esse mecanismo use o esquema Z-up, n√£o o Y-up (o eixo Z √© direcionado para cima, n√£o o eixo Y), que √© mais frequentemente usado em outros modelos / pacotes de modelagem.  O canal alfa cont√©m brilho, que √© descompactado como <code>exp2(glossiness * 12 + 1.0)</code> .  O valor de brilho tamb√©m pode ser negativo, porque o sinal √© usado como uma bandeira indicando se a superf√≠cie √© met√°lica.  Isso pode ser observado por si s√≥, porque todas as cores escuras no canal alfa est√£o relacionadas a objetos de metal. <br><br><table><tbody><tr><td>  <strong><font color="#ff0000">R</font></strong> </td><td>  <strong><font color="#00ff00">G</font></strong> </td><td>  <strong><font color="0000ff">B</font></strong> </td><td></td></tr><tr><td>  <strong>Normal.x</strong> </td><td>  <strong>Normal.y</strong> </td><td>  <strong>Normal.z</strong> </td><td>  <b>Brilho + Metalicidade</b> </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e8/209/484/1e8209484fe730d178c4afffef4c8f93.jpg"></div><br>  <i>Normal</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fb/dd3/b2d/8fbdd3b2d2ddbce3111a4c017e7daef3.jpg"></div><br>  <i>Brilho / metalidade</i> <br><br>  <strong>Vantagens da partida</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa1/b15/52b/aa1b1552b0f81c2122d094441e531f3f.jpg"></div><br>  Lembre-se de que na se√ß√£o "Profundidade preliminar", falamos sobre economia de custos de pixels?  Voltarei um pouco para ilustr√°-lo.  Tire a seguinte imagem.  Isso est√° tornando a parte detalhada da montanha no buffer normal.  O Renderdoc destacou os pixels que passaram no teste de profundidade com verde e os que n√£o passaram no vermelho (eles n√£o ser√£o renderizados).  O n√∫mero total de pixels que seriam renderizados sem essa passagem preliminar √© aproximadamente igual a 104518 (calculado no Photoshop).  O n√∫mero total de pixels realmente renderizados √© 23858 (calculado pelo Renderdoc).  Economize cerca de 77%!  Como vemos, com o uso inteligente, esse passe preliminar pode dar um grande ganho e requer apenas cerca de cem chamadas em sorteio. <br><br>  <strong>Gravando comandos multithread</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/919/5d0/623/9195d06236fd6247cea6e6065f05e9e8.png"></div><br>  Vale a pena notar um aspecto interessante, pelo qual escolhi o renderizador DX12 - grava√ß√£o de comandos multithread.  Nas APIs anteriores, como o DX11, a renderiza√ß√£o geralmente √© executada em um √∫nico encadeamento.  O driver gr√°fico recebeu comandos de renderiza√ß√£o do jogo e transmitiu constantemente solicita√ß√µes de GPU, mas o jogo n√£o sabia quando isso aconteceria.  Isso leva √† inefici√™ncia, porque o driver deve, de alguma forma, adivinhar o que o aplicativo est√° tentando fazer e n√£o √© escal√°vel para v√°rios segmentos.  APIs mais recentes, como o DX12, entregam o controle a um desenvolvedor que pode decidir como escrever comandos e quando envi√°-los.  Embora o Renderdoc n√£o possa mostrar como a grava√ß√£o √© feita, voc√™ ver√° que h√° sete passagens de cores marcadas como Passagem de cor N e cada uma delas √© envolvida em um par de ExecuteCommandList: Reset / Close.  Marca o in√≠cio e o fim da lista de comandos.  A lista √© respons√°vel por aproximadamente 100-200 chamadas em sorteio.  Isso n√£o significa que eles foram gravados usando v√°rios fluxos, mas sugerem isso. <br><br>  <strong>Pegadas na neve</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca6/d21/2e8/ca6d212e89b61f52738dfbd01363e366.jpg"></div><br>  Se voc√™ olhar para Lara, poder√° ver que, ao se mover na frente da captura de tela, ela deixou rastros na neve.  Em cada quadro, √© executado um sombreador de computa√ß√£o, que registra deforma√ß√µes em determinadas √°reas e as aplica com base no tipo e altura da superf√≠cie.  Aqui, apenas o mapa normal √© aplicado √† neve (ou seja, a geometria n√£o muda), mas em algumas √°reas onde a neve √© ‚Äã‚Äãmais espessa, a deforma√ß√£o √© realmente realizada!  Voc√™ tamb√©m pode ver como a neve "cai" no lugar e preenche os trilhos deixados por Lara.  Essa t√©cnica √© descrita com muito mais detalhes no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GPU Pro 7</a> .  A textura da teia de neve √© ‚Äã‚Äãuma esp√©cie de mapa de eleva√ß√£o que rastreia os movimentos de Lara e colado nas bordas para que o shader de amostragem possa tirar proveito dessa dobra. <br><br><h4>  Atlas das Sombras </h4><br>  Ao criar o mapeamento de Sombra, √© usada uma abordagem bastante comum - agrupar o maior n√∫mero poss√≠vel de cart√µes de sombra em uma textura de sombra comum.  Esse atlas de sombras √© na verdade uma enorme textura de 16 bits com um tamanho de 16384 √ó 8196.  Isso permite reutilizar e escalar com flexibilidade os mapas de sombra no atlas.  No quadro que estamos analisando, 8 mapas de sombra s√£o registrados no atlas.  Quatro deles se relacionam com a principal fonte de ilumina√ß√£o direcional (a lua, porque acontece √† noite), porque usam mapas de sombras em cascata - uma t√©cnica bastante padr√£o de sombras de longa dist√¢ncia para ilumina√ß√£o direcional, que eu j√° expliquei um pouco <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">antes</a> .  Mais interessante, v√°rias fontes de proje√ß√£o e de destaque tamb√©m est√£o inclu√≠das na captura desse quadro.  O fato de 8 mapas de sombra serem gravados nesse quadro n√£o significa que existem apenas 8 fontes de proje√ß√£o de ilumina√ß√£o de sombra nele.  O jogo pode armazenar em cache os c√°lculos de sombra, ou seja, a ilumina√ß√£o que n√£o mudou a posi√ß√£o da fonte ou a geometria no escopo n√£o deve atualizar seu mapa de sombra. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f00/8d9/169/f008d9169bd3490c26f923bcc4ea8e85.jpg"></div><br>  Parece que a renderiza√ß√£o de mapas de sombra tamb√©m se beneficia da grava√ß√£o de comandos multithread na lista e, nesse caso, at√© 19 listas de comandos foram escritas para renderizar mapas de sombra. <br><br>  <strong>Sombras da ilumina√ß√£o direcional</strong> <br><br>  As sombras da ilumina√ß√£o direcional s√£o calculadas antes da passagem da luz e depois amostradas.  N√£o sei o que aconteceria se houvesse v√°rias fontes de ilumina√ß√£o direcional na cena. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cef/209/845/cef209845628db5e68588f07880542eb.jpg"></div><br><h4>  Oclus√£o ambiental </h4><br>  Para oclus√£o ambiental, o ROTR permite que voc√™ use o HBAO ou uma variante do HBAO + (essa t√©cnica foi publicada originalmente pela NVIDIA).  Existem v√°rias varia√ß√µes desse algoritmo, por isso considerarei o que encontrei no ROTR.  Primeiro, o buffer de profundidade √© dividido em 16 texturas, cada uma das quais cont√©m 1/16 de todos os valores de profundidade.  A separa√ß√£o √© realizada de forma que cada textura contenha um valor de um bloco 4 √ó 4 da textura original mostrada na figura abaixo.  A primeira textura cont√©m todos os valores marcados em vermelho (1), a segunda cont√©m os valores marcados em azul (2) e assim por diante.  Se voc√™ quiser saber mais sobre essa t√©cnica, aqui est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um artigo de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Louis Bavoil</a> , que tamb√©m foi um dos autores do artigo sobre HBAO. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c9/2dc/60f/1c92dc60fe369caed766efe18dd2739d.png"></div><br>  O pr√≥ximo passo calcula a oclus√£o do ambiente para cada textura, o que fornece 16 texturas AO.  Uma oclus√£o ambiental √© gerada da seguinte forma: o buffer de profundidade √© amostrado v√°rias vezes, recriando a posi√ß√£o e acumulando o resultado do c√°lculo para cada uma das amostras.  Cada textura de oclus√£o do ambiente √© calculada usando coordenadas de amostragem diferentes, ou seja, em um bloco de pixels 4x4, cada pixel conta sua pr√≥pria parte da hist√≥ria.  Isso √© feito por raz√µes de desempenho.  Cada pixel j√° obt√©m uma amostra do buffer de profundidade 32 vezes e o efeito total exigir√° 16 √ó 32 = 512 amostras, o que √© um fracasso mesmo para as GPUs mais poderosas.  Em seguida, eles se recombinam em uma textura de tela cheia, o que resulta bastante barulhento; portanto, para suavizar os resultados logo em seguida, √© realizada uma passagem de desfoque em tela cheia.  Vimos uma solu√ß√£o muito semelhante em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Shadow of Mordor</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/25f/e57/dd8/25fe57dd8001f561e9a971b36b57085e.png" alt="imagem"></div><br>  <i>Pe√ßas HBAO</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/113/e1b/7d0/113e1b7d065a25b8f4dfb8dce29c808c.png" alt="imagem"></div><br>  <i>HBAO completo com ru√≠do</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/063/bfe/cd1/063bfecd15cdf8d62a0b6221fddfe4ee.png" alt="imagem"></div><br>  <i>Desfoque horizontal completo do HBAO</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51d/af9/8e2/51daf98e295b549a57089b4d17df1975.png" alt="imagem"></div><br>  <i>Ready HBAO</i> <br><br><h4>  Pr√©-passe para ilumina√ß√£o de azulejos </h4><br>  O Light Prepass √© uma t√©cnica bastante incomum.  A maioria das equipes de desenvolvimento usa uma combina√ß√£o de c√°lculo de ilumina√ß√£o diferida + direta (com varia√ß√µes, por exemplo, com bloco, cluster) ou completamente direta para alguns efeitos do espa√ßo na tela.  A t√©cnica de pr√©-ilumina√ß√£o √© t√£o incomum que merece uma explica√ß√£o.  Se o conceito de ilumina√ß√£o retardada tradicional √© separar as propriedades dos materiais da ilumina√ß√£o, a id√©ia de separar a ilumina√ß√£o das propriedades dos materiais √© a pedra angular da passagem preliminar da ilumina√ß√£o.  Embora essa reda√ß√£o pare√ßa um pouco tola, a diferen√ßa da ilumina√ß√£o diferida tradicional √© que armazenamos todas as propriedades do material (como albedo, cor especular, rugosidade, metalidade, micro-oclus√£o, emissivo) em um enorme buffer G e usamos mais tarde dados de entrada para passes de ilumina√ß√£o subsequentes.  A ilumina√ß√£o diferida tradicional pode apresentar uma grande carga na taxa de transfer√™ncia;  quanto mais complexos os materiais, mais informa√ß√µes e opera√ß√µes s√£o necess√°rias no buffer G.  No entanto, no passe de ilumina√ß√£o preliminar, primeiro acumulamos toda a ilumina√ß√£o separadamente, usando a quantidade m√≠nima de dados e, em seguida, aplicamos-os nas passagens subsequentes aos materiais.  Nesse caso, a ilumina√ß√£o √© suficiente apenas para normais, rugosidade e metalidez.  Os shaders (duas passagens s√£o usadas aqui) emitem dados em tr√™s formatos de destino de renderiza√ß√£o RGBA16F.  Um cont√©m ilumina√ß√£o difusa, o segundo cont√©m ilumina√ß√£o especular e o terceiro cont√©m ilumina√ß√£o ambiente.  Neste ponto, todos os dados de sombra s√£o levados em considera√ß√£o.  √â curioso que na primeira passagem (difusa + ilumina√ß√£o espelhada) para uma passagem em tela cheia, um quadril√°tero de dois tri√¢ngulos seja usado e, em outros efeitos, um tri√¢ngulo em tela cheia (por que isso √© importante, voc√™ pode descobrir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ).  Deste ponto de vista, todo o quadro n√£o √© integral. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41d/6ba/a3b/41d6baa3b45cc3e0df1423eaf015d416.jpg" alt="imagem"></div><br>  <i>Ilumina√ß√£o difusa</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9cd/0c5/137/9cd0c513782787daa220b7627b11b28e.jpg" alt="imagem"></div><br>  <i>Ilumina√ß√£o de espelho</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33d/ed9/cbc/33ded9cbc62470319b7729b542b7e830.jpg" alt="imagem"></div><br>  <i>Ilumina√ß√£o ambiente</i> <br><br>  <strong>Otimiza√ß√£o de blocos</strong> <br><br>  A ilumina√ß√£o de azulejos √© uma t√©cnica de otimiza√ß√£o projetada para renderizar um grande n√∫mero de fontes de luz.  O ROTR divide a tela em blocos 16 √ó 16 e salva as informa√ß√µes sobre quais fontes cruzam cada bloco, ou seja, os c√°lculos de ilumina√ß√£o ser√£o executados apenas para as fontes relacionadas aos blocos.  No in√≠cio do quadro, √© iniciada uma sequ√™ncia de sombreadores computacionais que determina quais fontes se relacionam com os blocos.  No est√°gio de ilumina√ß√£o, cada pixel determina em qual bloco ele est√° e passa por cada fonte de luz no bloco, realizando todos os c√°lculos de ilumina√ß√£o.  Se as fontes estiverem vinculadas aos blocos de maneira eficiente, voc√™ poder√° economizar bastante computa√ß√£o e grande parte da largura de banda, al√©m de aumentar a produtividade. <br><br>  <strong>Zoom de profundidade</strong> <br><br>  A upsampling baseada em profundidade √© uma t√©cnica interessante, √∫til nesta e em passagens subsequentes.  √Äs vezes, os algoritmos computacionalmente caros n√£o podem ser renderizados em resolu√ß√£o m√°xima; portanto, eles s√£o renderizados em uma resolu√ß√£o mais baixa e depois ampliados.  No nosso caso, a ilumina√ß√£o ambiente √© calculada em meia resolu√ß√£o, ou seja, ap√≥s os c√°lculos, a ilumina√ß√£o deve ser recriada corretamente.  Na forma mais simples, 4 pixels de baixa resolu√ß√£o s√£o capturados e interpolados para obter algo parecido com a imagem original.  Isso funciona para transi√ß√µes suaves, mas n√£o parece bom em descontinuidades, porque ali misturamos valores n√£o relacionados que podem ser adjacentes no espa√ßo da tela, mas distantes um do outro no espa√ßo do mundo.  Em solu√ß√µes para esse problema, v√°rias amostras de buffer de profundidade geralmente s√£o coletadas e comparadas com a amostra de profundidade que queremos recriar.  Se a amostra estiver muito distante, n√£o a levaremos em considera√ß√£o na reconstru√ß√£o.  Esse esquema funciona bem, mas significa que o shader de recrea√ß√£o consome muita largura de banda. <br><br>  O ROTR faz um movimento complicado com o descarte antecipado do est√™ncil.  Depois de passar as normais, o buffer de profundidade fica completamente cheio, de modo que o mecanismo executa uma passagem em tela cheia, marcando todos os pixels interrompidos no buffer de est√™ncil.  Quando chega a hora de recriar o buffer de ilumina√ß√£o ambiente, o mecanismo usa dois shaders: um √© muito simples para √°reas sem intervalos de profundidade, o outro √© mais complexo para pixels com intervalos.  O est√™ncil inicial descarta os pixels se eles n√£o pertencerem √† regi√£o correspondente, ou seja, h√° custos apenas nas regi√µes necess√°rias.  As seguintes imagens s√£o muito mais claras: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/747/912/729/747912729abfecffd281c72e8ca4e258.jpg" alt="imagem"></div><br>  <i>Ilumina√ß√£o ambiente de meia resolu√ß√£o</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0d/e46/b7e/f0de46b7e19ace552377d1a39d86ed22.png" alt="imagem"></div><br>  <i>Escalando as profundezas do interior</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d64/354/63b/d6435463b209e7361831b279abcf1ae1.jpg" alt="imagem"></div><br>  <i>Ilumina√ß√£o ambiente de resolu√ß√£o total, sem costelas</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db5/e12/702/db5e1270220121c5ca9c2a9277d519ed.png" alt="imagem"></div><br>  <i>Aumentando a profundidade das costelas</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ea/971/5cf/3ea9715cf0c57785d926b0711808b256.jpg" alt="imagem"></div><br>  <i>Ilumina√ß√£o ambiente pronta</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a5/5d2/128/4a55d2128ab191fb120ca3c1c4310c95.jpg" alt="imagem"></div><br>  <i>Visualiza√ß√£o em meia resolu√ß√£o</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd4/eaa/a07/cd4eaaa0719a527bcdd1add09f00597b.jpg" alt="imagem"></div><br>  <i>Uma vis√£o em close da imagem recriada</i> <br><br>  Ap√≥s uma passagem preliminar da ilumina√ß√£o, a geometria √© transferida para o transportador, somente dessa vez cada objeto mostra texturas de ilumina√ß√£o, textura de oclus√£o ambiental e outras propriedades dos materiais que n√£o gravamos no buffer G desde o in√≠cio.  Isso √© bom, porque a largura de banda √© muito salva aqui devido ao fato de que voc√™ n√£o precisa ler um monte de texturas para grav√°-las em um grande buffer G e depois l√™-las / decodific√°-las novamente.  A desvantagem √≥bvia dessa abordagem √© que toda a geometria precisa ser retransmitida, e a textura da passagem preliminar da ilumina√ß√£o por si s√≥ representa uma grande carga no rendimento.  Eu me perguntei por que n√£o usar um formato mais leve, por exemplo, R11G11B10F, para texturas preliminares de ilumina√ß√£o de passagem, mas h√° informa√ß√µes adicionais no canal alfa, portanto isso seria imposs√≠vel.  Seja como for, esta √© uma solu√ß√£o t√©cnica interessante.  Nesse ponto, toda a geometria opaca j√° est√° renderizada e acesa.  Observe que ele inclui objetos emissores de luz, como o c√©u e a tela do laptop. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2eb/3cb/0a3/2eb3cb0a3f58c521079fc2bbd1b3fd67.jpg"></div><br><h4>  Reflex√µes </h4><br>  Esta cena n√£o √© um bom exemplo para demonstrar reflex√µes, ent√£o eu escolhi outra.  O shader de reflex√£o √© uma combina√ß√£o bastante complicada de ciclos que pode ser reduzida para duas partes: uma mostra mapas c√∫bicos e a outra executa SSR (Reflex√£o do espa√ßo da tela - c√°lculo das reflex√µes no espa√ßo da tela);  tudo isso √© feito de uma s√≥ vez e no final √© misturado, levando em considera√ß√£o o coeficiente que determina se o SSR detectou a reflex√£o (provavelmente o coeficiente n√£o √© bin√°rio, mas √© um valor no intervalo [0, 1]).  O SSR funciona de maneira padr√£o em muitos jogos - rastreia repetidamente o buffer de profundidade, tentando encontrar a melhor interse√ß√£o entre o raio refletido pela superf√≠cie sombreada e outra superf√≠cie em qualquer lugar da tela.  O SSR trabalha com a cadeia mip da escala anteriormente reduzida do buffer HDR atual, e n√£o com o buffer inteiro. <br><br>  Tamb√©m existem fatores de corre√ß√£o como o brilho da reflex√£o, bem como a textura peculiar de Fresnel, calculada antes dessa passagem, com base nas normais e na rugosidade.  N√£o tenho muita certeza, mas depois de estudar o c√≥digo de montagem, parece-me que o ROTR s√≥ pode calcular o SSR para superf√≠cies lisas.  O mecanismo n√£o possui uma cadeia mip de desfoque ap√≥s o est√°gio SSR, que existe em outros <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mecanismos</a> , e n√£o h√° nada como rastrear o buffer de profundidade usando raios, que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">varia com base na rugosidade</a> .  Em geral, superf√≠cies mais √°speras recebem reflex√µes de mapas c√∫bicos ou nem sequer as recebem.  No entanto, onde o SSR trabalha, sua qualidade √© muito alta e est√°vel, levando em considera√ß√£o que ele n√£o se acumula ao longo do tempo e que o desfoque espacial n√£o √© realizado.  Os dados alfa tamb√©m suportam SSR (em alguns templos voc√™ pode ver reflexos muito bonitos na √°gua) e isso √© uma boa adi√ß√£o que voc√™ n√£o v√™ frequentemente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5af/b6f/093/5afb6f0937fe9b172b8e38d3f0459b9b.jpg" alt="imagem"></div><br>  <i>Reflex√µes para</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecc/66d/c6c/ecc66dc6ca98108593b9a5ec4695dc63.jpg" alt="imagem"></div><br>  <i>Buffer de reflex√£o</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec9/6ff/e57/ec96ffe5730e775b678a47ae23906b73.jpg" alt="imagem"></div><br>  <i>Reflex√µes depois</i> <br><br><h4>  Nevoeiro iluminado </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/578/565/d2a/578565d2af38eac19d8aff86b82cf710.jpg"></div><br>  Em nossa cena, o nevoeiro √© mal representado porque escurece o fundo e, portanto, √© criado por part√≠culas, para que possamos usar novamente o exemplo com reflex√µes.  O nevoeiro √© relativamente simples, mas bastante eficaz.  Existem dois modos: global, a cor geral do nevoeiro e a cor da dispers√£o interna obtida no mapa c√∫bico.  Talvez o mapa c√∫bico tenha sido retirado novamente dos mapas de reflex√£o c√∫bica, ou talvez criado novamente.  Nos dois modos, a rarefa√ß√£o do nevoeiro √© obtida da textura global de rarefa√ß√£o, na qual as curvas de rarefa√ß√£o s√£o compactadas para v√°rios efeitos.  Nesse esquema, √© not√°vel que ele produza um nevoeiro iluminado de custo muito baixo, isto √©,  espalhando mudan√ßas internas no espa√ßo, criando a ilus√£o de intera√ß√£o do nevoeiro com ilumina√ß√£o distante.  Essa abordagem tamb√©m pode ser usada para dispers√£o atmosf√©rica interna perto do c√©u. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e33/e0e/c3a/e33e0ec3aee95a3cd5a669b332946083.jpg" alt="imagem"></div><br>  <i>Nevoeiro para</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acb/5ed/c78/acb5edc78ab74eb97b9350c1e7aba261.jpg" alt="imagem"></div><br>  <i>Nevoeiro depois</i> <br><br><h4>  Ilumina√ß√£o volum√©trica </h4><br>  Nos est√°gios iniciais do quadro, v√°rias opera√ß√µes s√£o executadas para preparar a ilumina√ß√£o volum√©trica.  Dois buffers s√£o copiados da CPU para a GPU: √≠ndices da fonte de luz e dados da fonte de luz.  Ambos s√£o lidos por um sombreador computacional que gera uma textura 3D de 40x23x16 da visualiza√ß√£o da c√¢mera, contendo o n√∫mero de fontes de luz que atravessam esta √°rea.  A textura √© 40 √ó 23 porque cada bloco ocupa 32 √ó 32 pixels (1280/32 = 40, 720/32 = 22,5) e 16 √© o n√∫mero de pixels em profundidade.  A textura n√£o inclui todas as fontes de luz, mas apenas aquelas marcadas como volumosas (h√° tr√™s em nossa cena).  Como veremos abaixo, existem outros efeitos volum√©tricos falsos criados por texturas planas.  A textura exibida tem uma resolu√ß√£o mais alta - 160x90x64.  Ap√≥s determinar o n√∫mero de fontes de luz por bloco e seu √≠ndice, tr√™s shaders computacionais s√£o executados sequencialmente, executando as seguintes opera√ß√µes: <br><br><ol><li>  A primeira passagem determina a quantidade de luz que entra na c√©lula dentro do volume na forma de uma pir√¢mide de visibilidade.  Cada c√©lula acumula a influ√™ncia de todas as fontes de luz, como se tivessem suspensas part√≠culas que reagem √† luz e devolvem parte dela √† c√¢mera. </li><li>  A segunda passagem borra a ilumina√ß√£o com um pequeno raio.  Provavelmente, isso √© necess√°rio para evitar oscila√ß√µes ao mover a c√¢mera, porque a resolu√ß√£o √© muito baixa. </li><li>  A terceira passagem ignora a textura do volume da frente para tr√°s, adicionando gradualmente a influ√™ncia de cada fonte e fornecendo a textura final.  De fato, simula a quantidade total de ilumina√ß√£o recebida ao longo do feixe a uma determinada dist√¢ncia.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como cada c√©lula cont√©m uma parte da luz refletida pelas part√≠culas na dire√ß√£o da c√¢mera, em cada uma delas receberemos uma contribui√ß√£o conjunta de todas as c√©lulas passadas anteriormente. </font><font style="vertical-align: inherit;">Esta passagem tamb√©m se confunde.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando tudo isso √© conclu√≠do, obtemos uma textura 3D que relata quanta luz uma determinada posi√ß√£o recebe em rela√ß√£o √† c√¢mera. </font><font style="vertical-align: inherit;">Tudo o que resta a ser feito na passagem em tela cheia √© determinar essa posi√ß√£o, encontrar o voxel correspondente da textura e adicion√°-lo ao buffer HDR. </font><font style="vertical-align: inherit;">O sombreador de ilumina√ß√£o em si √© muito simples e cont√©m apenas cerca de 16 instru√ß√µes.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b58/939/e8a/b58939e8ae5abf2320c519abc51f6e8a.jpg" alt="imagem"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ilumina√ß√£o volum√©trica</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ab/006/e9d/1ab006e9d0b62e0ea0470751185ffe41.jpg" alt="imagem"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ilumina√ß√£o volum√©trica ap√≥s</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rendi√ß√£o do cabelo </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se a fun√ß√£o PureHair n√£o estiver ativada, as camadas de cabelo padr√£o ser√£o renderizadas umas sobre as outras. </font><font style="vertical-align: inherit;">Essa solu√ß√£o ainda parece √≥tima, mas eu gostaria de focar na tecnologia mais recente. </font><font style="vertical-align: inherit;">Se a fun√ß√£o estiver ativada, o quadro come√ßa com uma simula√ß√£o dos cabelos de Lara com uma sequ√™ncia de shaders computacionais. </font><font style="vertical-align: inherit;">A primeira parte do Tomb Raider usou uma tecnologia chamada TressFX e, na sequ√™ncia, a Crystal Dynamics implementou uma tecnologia aprimorada. </font><font style="vertical-align: inherit;">Ap√≥s os c√°lculos iniciais, obtemos at√© 7 buffers. </font><font style="vertical-align: inherit;">Todos eles s√£o usados ‚Äã‚Äãpara controlar os cabelos de Lara. </font><font style="vertical-align: inherit;">O processo √© o seguinte:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inicie um sombreador computacional para calcular valores de movimento com base nas posi√ß√µes anteriores e atuais (para desfoque de movimento) </font></font></li><li>          1√ó1        () </li><li>   122       (Triangle Strip) (   ‚Äî  ).     ,         .    7 ,      .     ,      ,  .      ¬´ ¬ª. </li><li>  /   quad    ,     ,     .  ,          ,    . </li><li>       4,      (    ¬´ ¬ª) </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se voc√™ estiver interessado em aprender mais sobre isso, a AMD possui muitos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recursos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apresenta√ß√µes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , porque √© uma </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">biblioteca p√∫blica</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> criada pela empresa </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Fiquei confuso com o est√°gio anterior ao est√°gio 1, no qual a mesma chamada de empate √© realizada como no est√°gio 3; diz-se que ele gera apenas valores de profundidade, mas, na verdade, o conte√∫do n√£o √© renderizado, e isso √© interessante; </font><font style="vertical-align: inherit;">talvez o Renderdoc n√£o esteja me dizendo nada. </font><font style="vertical-align: inherit;">Eu suspeito que ele pode ter tentado executar uma solicita√ß√£o de renderiza√ß√£o condicional, mas n√£o vejo nenhuma chamada de previs√£o.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21f/127/76f/21f12776f41f0893c37a677deca12529.jpg" alt="imagem"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hair up</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/832/f49/ecd/832f49ecd96406db87ee99f3b1089de0.jpg" alt="imagem"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pixels vis√≠veis do cabelo</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/289/33e/030/28933e0309107cfcb3120564d55fd412.jpg" alt="imagem"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cabelos sombreados</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Renderiza√ß√£o em mosaico de dados e part√≠culas alfa </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objetos transparentes novamente usam a classifica√ß√£o de ladrilhos das fontes de luz calculadas para o passo de ilumina√ß√£o preliminar dos ladrilhos. Cada objeto transparente calcula sua pr√≥pria ilumina√ß√£o em uma passagem, ou seja, o n√∫mero de instru√ß√µes e ciclos se torna bastante assustador (e √© por isso que a passagem preliminar da ilumina√ß√£o foi usada para objetos opacos). Objetos transparentes podem at√© refletir reflexos no espa√ßo da tela se estiverem ativados! Cada objeto √© renderizado em ordem de classifica√ß√£o, de tr√°s para a frente, diretamente no buffer HDR, incluindo vidro, chama, √°gua de rotina, etc. A passagem alfa tamb√©m mostra as bordas destacadas quando Lara foca em algum objeto (por exemplo, uma garrafa com uma mistura combust√≠vel em uma caixa √† esquerda).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/445/4a8/311/4454a83115f4118ab092fc1ff3bcaaf1.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, as part√≠culas s√£o renderizadas em um buffer de meia resolu√ß√£o para suavizar a enorme carga na largura de banda criada pela repintura, especialmente quando muitas part√≠culas grandes que cobrem a tela s√£o usadas para criar neblina, neblina, chama, etc. Portanto, o buffer HDR e o buffer de profundidade diminuem pela metade de cada lado, ap√≥s o qual a renderiza√ß√£o de part√≠culas come√ßa. As part√≠culas criam uma enorme quantidade de redesenho, alguns pixels s√£o sombreados cerca de 40 vezes. O mapa de calor mostra o que quero dizer. Como as part√≠culas foram renderizadas em meia resolu√ß√£o, o mesmo truque de zoom inteligente √© usado aqui como na ilumina√ß√£o ambiente (as lacunas s√£o marcadas no est√™ncil, a primeira passagem √© renderizada em pixels internos, a segunda recria as bordas). Voc√™ pode notar que as part√≠culas produzem outros efeitos alfa, como chama,brilhar, etc. Isso √© necess√°rio para que o alfa possa ser classificado corretamente em rela√ß√£o a, por exemplo, fuma√ßa. Voc√™ tamb√©m pode notar que os raios de luz "volum√©tricos" aparecem aqui, provenientes de focos de seguran√ßa. Eles s√£o adicionados aqui e n√£o criados no est√°gio da ilumina√ß√£o volum√©trica. Essa √© uma maneira barata, por√©m realista, de cri√°-los a longas dist√¢ncias.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e78/0f1/c77/e780f1c77d8c9031e10b1ddc6faf6b20.jpg" alt="imagem"></div><br> <i>  </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1db/409/09c/1db40909cea712bec3b9f1d4eab109d7.jpg" alt="imagem"></div><br> <i> -</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c1/8f2/80a/2c18f280ab65f272470ff711def4b89e.jpg" alt="imagem"></div><br> <i>   1</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/098/e29/66c/098e2966cf5d8bdc62a7d76bfdc2344e.jpg" alt="imagem"></div><br> <i>   2</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0b/c73/f5a/e0bc73f5ab35af88840eebe45f175074.jpg" alt="imagem"></div><br> <i>   3</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb0/6ef/e9e/eb06efe9eb6fe1db3e749e6b1a6c1c9c.jpg" alt="imagem"><br> <i>   </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56e/263/ba6/56e263ba63ae60ee5af108c172711410.jpg" alt="imagem"></div><br> <i>  </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e8f/564/288/e8f564288ae2310272be7ac9899409d9.jpg" alt="imagem"></div><br> <i> -</i> <br><br><h4>     </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ROTR executa a velocidade do obturador e a corre√ß√£o de tom em uma √∫nica passagem. No entanto, embora geralmente acreditemos que a corre√ß√£o gama ocorre com a corre√ß√£o do tom, esse n√£o √© o caso aqui. Existem muitas maneiras de implementar a exposi√ß√£o, como vimos em </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">outros </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jogos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . O c√°lculo da lumin√¢ncia no ROTR √© muito interessante e requer quase nenhum dado ou passagem intermedi√°rios, portanto explicaremos esse processo com mais detalhes. A tela inteira √© dividida em blocos de 64 √ó 64, ap√≥s o qual o c√°lculo dos grupos (20, 12, 1) de 256 fluxos em cada um come√ßa a preencher a tela inteira. Cada encadeamento executa essencialmente a seguinte tarefa (o pseudoc√≥digo √© apresentado abaixo):</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; ++i) { uint2 iCoord = CalculateCoord(threadID, i, j); <span class="hljs-comment"><span class="hljs-comment">// Obtain coordinate float3 hdrValue = Load(hdrTexture, iCoord.xyz); // Read HDR float maxHDRValue = max3(hdrValue); // Find max component float minHDRValue = min3(hdrValue); // Find min component float clampedAverage = max(0.0, (maxHDRValue + minHDRValue) / 2.0); float logAverage = log(clampedAverage); // Natural logarithm sumLogAverage += logAverage; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada grupo calcula a soma logar√≠tmica de todos os 64 pixels (256 threads, cada um dos quais processa 16 valores). Em vez de armazenar o valor m√©dio, ele salva a soma e o n√∫mero de pixels realmente processados ‚Äã‚Äã(nem todos os grupos processam exatamente 64 √ó 64 pixels, porque, por exemplo, eles podem ir al√©m das bordas da tela). Shader sabiamente usa armazenamento de encadeamento local para dividir a soma; cada fluxo trabalha primeiro com 16 valores horizontais e, em seguida, os fluxos separados resumem todos esses valores verticalmente e, finalmente, o fluxo de controle desse grupo (fluxo 0) adiciona o resultado e salva todos no buffer. Esse buffer cont√©m 240 elementos, essencialmente fornecendo o brilho m√©dio de muitas √°reas da tela. O comando a seguir inicia 64 threads que circundam todos esses valores e os adicionam,para obter o brilho final da tela. Ele tamb√©m retorna do logaritmo para unidades lineares.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o tenho muita experi√™ncia com t√©cnicas de exposi√ß√£o, mas a leitura </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deste post de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Krzysztof Narkovic esclareceu algumas coisas. √â necess√°rio salvar em uma matriz de 64 elementos para calcular a m√©dia m√≥vel, na qual √© poss√≠vel visualizar os valores calculados anteriores e suavizar a curva para evitar mudan√ßas muito n√≠tidas no brilho, criando mudan√ßas n√≠tidas na velocidade do obturador. Esse √© um shader muito complexo e ainda n√£o descobri todos os detalhes, mas o resultado final √© o valor da velocidade do obturador correspondente ao quadro atual. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de encontrar velocidades adequadas do obturador, uma passagem executa a velocidade final do obturador mais a corre√ß√£o de tons. O ROTR parece usar o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mapeamento de tom fotogr√°fico</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que explica o uso de meios logar√≠tmicos em vez dos meios usuais. </font><font style="vertical-align: inherit;">A f√≥rmula de corre√ß√£o tonal no sombreador (ap√≥s a exposi√ß√£o) pode ser expandida da seguinte maneira:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bz/yv/-k/bzyv-kjhv-hs6lj3mh4yfrh427w.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/id/zn/1d/idzn1d3rn-3qs7vrokrn94d9z1m.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma breve explica√ß√£o pode ser encontrada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">N√£o consegui descobrir por que √© necess√°ria uma divis√£o adicional por Lm, porque cancela a influ√™ncia da multiplica√ß√£o. </font><font style="vertical-align: inherit;">De qualquer forma, o whitePoint √© 1.0, portanto, o processo n√£o faz muito nesse quadro; a imagem altera apenas a velocidade do obturador. </font><font style="vertical-align: inherit;">N√£o h√° limite para os valores do intervalo LDR! </font><font style="vertical-align: inherit;">Ocorre durante a classifica√ß√£o de cores, quando o cubo de cores limita indiretamente valores maiores que 1,0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1a/92f/2e8/e1a92f2e852892aa137c170a56718f8e.jpg" alt="imagem"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exposi√ß√£o a</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/788/c4f/905/788c4f905eecffaa8d5dbd12d1c8972d.jpg" alt="imagem"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exposi√ß√£o Ap√≥s</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reflexo da lente </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os reflexos das lentes s√£o renderizados de uma maneira interessante. Um pequeno passo preliminar calcula uma textura 1xN (onde N √© o n√∫mero total de elementos ofuscantes que ser√£o renderizados como reflexos de lente, no nosso caso, existem 28). Essa textura cont√©m o valor alfa da part√≠cula e outras informa√ß√µes n√£o utilizadas, mas, em vez de calcul√°-lo a partir de uma solicita√ß√£o de visibilidade ou algo semelhante, o mecanismo calcula-o analisando o buffer de profundidade em torno da part√≠cula no c√≠rculo. Para fazer isso, as informa√ß√µes sobre os v√©rtices s√£o armazenadas em um buffer dispon√≠vel para o pixel shader.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a0/604/e96/8a0604e96d5a4fe4ebf691719f03d75f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, cada elemento √© renderizado como simples plano alinhado ao plano emitido a partir de fontes de luz. </font><font style="vertical-align: inherit;">Se o valor alfa for menor que 0,01, o valor NaN ser√° atribu√≠do √† posi√ß√£o para que essa part√≠cula n√£o rasterize. </font><font style="vertical-align: inherit;">Eles s√£o um pouco como o efeito bloom e adicionam brilho, mas esse efeito em si √© criado mais tarde.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/526/da9/a18/526da9a184f303dc8e3bfd82cd16034a.jpg" alt="imagem"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A lente se incendeia</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/465/440/335/4654403353e5b94dc7bae2a68b95ed88.jpg" alt="imagem"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elementos de alargamento da lente</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c1/f10/c43/5c1f10c4396cbd6a8502a28b5a53fe0f.jpg" alt="imagem"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A lente flare ap√≥s</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bloom </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Bloom usa uma abordagem padr√£o: diminuindo a amostragem do buffer HDR, os pixels brilhantes s√£o isolados e sua escala √© aumentada sequencialmente com desfoque para expandir sua √°rea de influ√™ncia. O resultado √© ampliado para a resolu√ß√£o da tela e a composi√ß√£o √© sobreposta. Vale a pena explorar alguns pontos interessantes. Todo o processo √© realizado usando 7 shaders computacionais: 2 para downsampling, 1 para desfoque simples, 4 para ampliar.</font></font><br><br><ol><li>                  target   (mip 1).        .  ,   mip-    ,           0.02. </li><li>     mip      mip 2, 3, 4  5. </li><li>       mip 5.        ,    .       ,             . </li><li>   ‚Äî   .  3          ,   mip N    mip N + 1,       ,     .     bloom      ,     . </li><li>     mip 1      HDR-,      bloom. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b0c/478/bc7/b0c478bc7ccc0c4774cea8b2aaa4ec8b.jpg" alt="imagem"></div><br> <i>Bloom </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f77/b74/99b/f77b7499b451e0f232b06d183ccc04f4.jpg"></div><br> <i>MIP 1   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c65/ae2/875/c65ae2875487b8a9b441a9ce0b137430.jpg"></div><br> <i>MIP 2   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55b/9a4/757/55b9a4757f48867201dc76df90ea0dd1.jpg"></div><br> <i>MIP 3   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba5/17d/a6f/ba517da6f179cca1067a08115579c155.jpg"></div><br> <i>MIP 4   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33f/91f/44d/33f91f44dcc1f9a395375fce8535ac2d.jpg" alt="imagem"></div><br> <i>MIP 5   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecb/561/33d/ecb56133d1965bcc93024c5cded95ec7.jpg"></div><br> <i> MIP 5  Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/235/0ed/474/2350ed47490101cda12baffbd61fc8f0.jpg"></div><br> <i>MIP 4   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff0/cfb/4df/ff0cfb4dfeea995b8666d4b8aec057a1.jpg"></div><br> <i>MIP 3   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/980/7ca/a31/9807caa31251495050af2e2fd32b5e90.jpg" alt="imagem"></div><br> <i>MIP 2   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/857/4be/854/8574be854f2526857ef9b6854d6f7235.jpg"></div><br> <i>MIP 1   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9be/aa8/8a1/9beaa88a1bf00876801bb103ef85dd16.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Florescer depois O</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aspecto curioso √© que as texturas em escala reduzida alteram a propor√ß√£o. </font><font style="vertical-align: inherit;">Para fins de visualiza√ß√£o, eu os corrigi e s√≥ posso adivinhar as raz√µes para isso; </font><font style="vertical-align: inherit;">talvez isso seja feito para que os tamanhos das texturas sejam m√∫ltiplos de 16. Outro ponto interessante: como esses shaders geralmente s√£o muito limitados em largura de banda, os valores armazenados na mem√≥ria compartilhada do grupo s√£o convertidos de float32 para float16! </font><font style="vertical-align: inherit;">Isso permite que o shader troque opera√ß√µes matem√°ticas pela duplica√ß√£o de mem√≥ria livre e largura de banda. </font><font style="vertical-align: inherit;">Para que isso se torne um problema, o intervalo de valores deve se tornar bastante grande.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fxaa </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ROTR suporta uma ampla variedade de t√©cnicas diferentes de suaviza√ß√£o de serrilhado, como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FXAA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Fast Approximate AA) e SSAA (Super Sampling AA). </font><font style="vertical-align: inherit;">Vale ressaltar que a op√ß√£o de ativar o AA temporal est√° ausente, porque para a maioria dos jogos modernos do AAA, ela se torna padr√£o. </font><font style="vertical-align: inherit;">Seja como for, o FXAA lida com sua tarefa notavelmente, o SSAA tamb√©m funciona bem, essa √© uma op√ß√£o bastante "pesada" se o jogo n√£o apresentar desempenho.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Desfoque de movimento </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parece que o Motion blur usa uma abordagem muito semelhante √† solu√ß√£o em </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shadows of Mordor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ap√≥s renderizar a ilumina√ß√£o volum√©trica, uma passagem de renderiza√ß√£o separada gera os vetores de movimento dos objetos animados para o buffer de movimento. Em seguida, esse buffer √© combinado com o movimento causado pela c√¢mera, e o buffer de movimento final passa a ser inserido na passagem de desfoque, que executa o desfoque na dire√ß√£o indicada pelos vetores de movimento do espa√ßo na tela. Para estimar o raio de desfoque em algumas passagens, a textura dos vetores de movimento em uma escala reduzida √© calculada para que cada pixel tenha uma id√©ia aproximada do tipo de movimento nas proximidades. O desfoque √© realizado em v√°rias passagens com meia resolu√ß√£o e, como vimos, posteriormente sua escala com a ajuda do est√™ncil aumenta em duas passagens. V√°rios passes s√£o realizados por dois motivos: primeiro,para reduzir o n√∫mero de leituras de textura necess√°rias para criar desfoque com um raio potencialmente muito grande e, em segundo lugar, porque s√£o executados diferentes tipos de desfoque. Depende se o personagem animado estava nos pixels atuais.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f4/91d/df6/3f491ddf60c6a1a6b9caeaec316eab4f.jpg" alt="imagem"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desfoque de movimento para</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e5/eb5/d42/2e5eb5d42d4e0c36c4c96e764538f8c8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Velocidade de desfoque de movimento</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edf/3ed/2e7/edf3ed2e7144ec27ba21b3b16e606c7f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motion Blur Pass 1</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c5/c65/931/7c5c6593183900a85a3d0372fce9eb03.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passe de desfoque de movimento 2</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a3/bc5/bcc/8a3bc5bcc85c92d698fc081e49c0f318.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motion Blur Pass 3</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04f/5e1/a7e/04f5e1a7e722d9818c8a23ef5759c172.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motion Blur Pass 4</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9d/98f/579/f9d98f579e02acec8e3ef99e90bdd0c0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passe de desfoque de movimento 5</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99e/3ca/b5c/99e3cab5cbf5d25b2eea0d3311eae7cf.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passe de desfoque de movimento 6</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/042/af0/5bd/042af05bd488751c53bd97c73cb037fc.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desfoque de movimento, aproximando e afastando o zoom</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e10/26d/c47/e1026dc47d9035e8713422ad8210e6a7.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desfoque de movimento, bordas de zoom</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recursos e detalhes adicionais </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> H√° mais algumas coisas que vale a pena mencionar sem muitos detalhes. </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Congelamento da c√¢mera: em clima frio, adiciona flocos de neve e gelo √† c√¢mera </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√¢mera suja: adiciona sujeira √† c√¢mera. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Corre√ß√£o de cores: no final do quadro, √© realizada uma pequena corre√ß√£o de cores, usando um cubo de cores razoavelmente padr√£o para executar a corre√ß√£o de cores, conforme descrito acima, e tamb√©m adiciona ru√≠do para tornar algumas cenas mais severas </font></font></li></ol><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UI </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A interface do usu√°rio √© implementada um pouco incomum - renderiza todos os elementos no espa√ßo linear. </font><font style="vertical-align: inherit;">Normalmente, no momento da renderiza√ß√£o, a interface do usu√°rio j√° havia feito a corre√ß√£o de tom e a gama. </font><font style="vertical-align: inherit;">No entanto, o ROTR usa espa√ßo linear at√© o final do quadro. </font><font style="vertical-align: inherit;">Isso faz sentido, porque o jogo usa uma reminisc√™ncia da interface do usu√°rio 3D; </font><font style="vertical-align: inherit;">no entanto, antes de gravar imagens sRGB no buffer HDR, elas devem ser convertidas em espa√ßo linear para que a opera√ß√£o mais recente (corre√ß√£o gama) n√£o distor√ßa as cores.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resumir </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espero que voc√™ tenha gostado de ler essa an√°lise da mesma maneira que eu fiz. </font><font style="vertical-align: inherit;">Pessoalmente, eu definitivamente aprendi muito com isso. </font><font style="vertical-align: inherit;">Parab√©ns aos talentosos desenvolvedores do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crystal Dynamics</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pelo fant√°stico trabalho realizado para criar esse mecanismo. </font><font style="vertical-align: inherit;">Tamb√©m quero agradecer a Baldur Karlsson por seu fant√°stico trabalho no Renderdoc. </font><font style="vertical-align: inherit;">Seu trabalho tornou a depura√ß√£o de gr√°ficos em um PC um processo muito mais conveniente. </font><font style="vertical-align: inherit;">Eu acho que a √∫nica coisa um pouco complicada nessa an√°lise foi rastrear os lan√ßamentos de shader, porque no momento em que escrevemos esse recurso n√£o estava dispon√≠vel para o DX12. </font><font style="vertical-align: inherit;">Espero que, com o tempo, apare√ßa e todos ficaremos muito satisfeitos.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt436500/">https://habr.com/ru/post/pt436500/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt436490/index.html">Motorola planeja introduzir a encarna√ß√£o Razr v3</a></li>
<li><a href="../pt436492/index.html">Estamos √† procura de oradores no 10o DIY Mitap 17 de fevereiro de 2019</a></li>
<li><a href="../pt436494/index.html">Substituindo um disco enquanto mant√©m a numera√ß√£o adequada no CEPH</a></li>
<li><a href="../pt436496/index.html">PVS-Studio para Java</a></li>
<li><a href="../pt436498/index.html">Software AG: N√£o apenas ARIS</a></li>
<li><a href="../pt436502/index.html">Pampers de assinatura ou como vender mais para os mesmos clientes</a></li>
<li><a href="../pt436504/index.html">Sistema no pacote ou O que h√° sob a cobertura do pacote de chips?</a></li>
<li><a href="../pt436506/index.html">Como criar um racista de IA sem muito esfor√ßo</a></li>
<li><a href="../pt436508/index.html">US $ 10 milh√µes em investimentos e elogios de Wozniak - criando um computador educacional para crian√ßas</a></li>
<li><a href="../pt436510/index.html">Dados principais em detalhes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>