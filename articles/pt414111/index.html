<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõÄüèº üêÑ üöú Depura√ß√£o e solu√ß√£o de problemas na replica√ß√£o de streaming PostgreSQL ‚öæÔ∏è üèÆ üìö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A replica√ß√£o de fluxo, que apareceu em 2010, tornou-se um dos principais recursos do PostgreSQL e, atualmente, quase nenhuma instala√ß√£o √© conclu√≠da se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Depura√ß√£o e solu√ß√£o de problemas na replica√ß√£o de streaming PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/414111/">  A replica√ß√£o de fluxo, que apareceu em 2010, tornou-se um dos principais recursos do PostgreSQL e, atualmente, quase nenhuma instala√ß√£o √© conclu√≠da sem o uso da replica√ß√£o de fluxo.  √â confi√°vel, f√°cil de configurar, sem exigir recursos.  No entanto, por todas as suas qualidades positivas, durante sua opera√ß√£o, v√°rios problemas e situa√ß√µes desagrad√°veis ‚Äã‚Äãpodem surgir. <br><br>  <strong>Alexey Lesovsky</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@lesovsky</a> ) do Highload ++ 2017 contou como <strong>diagnosticar v√°rios tipos de problemas</strong> usando ferramentas internas e de terceiros <strong>e como corrigi-los</strong> .  Sob os cortes, a decodifica√ß√£o deste relat√≥rio, baseada em um princ√≠pio espiral: primeiro, listamos todas as ferramentas de diagn√≥stico poss√≠veis, depois listamos problemas comuns e diagnosticamos, depois vemos quais medidas de emerg√™ncia podem ser tomadas e, finalmente, como lidar radicalmente com o problema. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/on2yVvKejwc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Sobre o palestrante</strong> : Alexei Lesovsky, administrador de banco de dados da Data Egret.  Um dos t√≥picos favoritos de Alexey no PostgreSQL √© transmitir replica√ß√£o e trabalhar com estat√≠sticas; portanto, o relat√≥rio no Highload ++ 2017 foi dedicado a como encontrar problemas usando estat√≠sticas e quais m√©todos usar para resolv√™-los. <br><br><h2>  Planejar <br></h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Um pouco de teoria ou como a replica√ß√£o funciona no PostgreSQL</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ferramentas de solu√ß√£o de problemas ou o que o PostgreSQL e a comunidade possuem</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Resolu√ß√£o de casos:</a> <br><ul><li>  problemas: seus sintomas e diagn√≥stico </li><li>  decis√µes </li><li>  medidas a serem tomadas para que esses problemas n√£o surjam. </li></ul></li></ol><br>  <strong>Por que tudo isso?</strong>  Este artigo ajudar√° voc√™ a entender melhor a replica√ß√£o de streaming, aprender a encontrar e corrigir problemas rapidamente, a fim de reduzir o tempo de rea√ß√£o a incidentes desagrad√°veis. <br><a name="habracut"></a><a name="replicationSql"></a><br><h2>  Pouco de teoria <br></h2><br>  O PostgreSQL possui uma entidade como o Write-Ahead Log (XLOG), um log de transa√ß√µes.  <em>Quase</em> todas as altera√ß√µes que ocorrem com dados e metadados dentro do banco de dados s√£o registradas neste log.  Se ocorrer um acidente repentino, o PostgreSQL inicia, l√™ o log de transa√ß√µes e restaura as altera√ß√µes registradas nos dados.  Isso garante confiabilidade - uma das propriedades mais importantes de qualquer DBMS e PostgreSQL tamb√©m. <br><br>  O log de transa√ß√µes pode ser preenchido de duas maneiras: <br><br><ol><li>  Por padr√£o, quando os back-end fazem algumas altera√ß√µes no banco de dados (INSERT, UPDATE, DELETE etc.), todas as altera√ß√µes s√£o registradas no log de transa√ß√µes de forma <strong>s√≠ncrona</strong> : <br><ul><li>  O cliente enviou um comando COMMIT para confirmar os dados. <br></li><li>  Os dados s√£o registrados no log de transa√ß√µes. <br></li><li>  Depois que a fixa√ß√£o ocorre, o controle √© dado ao back-end e ele pode continuar recebendo comandos do cliente. <br></li></ul></li><li>  A segunda op√ß√£o √© a <strong>grava√ß√£o ass√≠ncrona</strong> no log de transa√ß√µes, quando um processo de gravador WAL dedicado separado grava as altera√ß√µes no log de transa√ß√µes com um determinado intervalo de tempo.  Por esse motivo, √© alcan√ßado um aumento no desempenho de back-end, pois n√£o h√° necessidade de esperar at√© que o comando COMMIT seja conclu√≠do. <br></li></ol><br>  Mais importante, a replica√ß√£o de streaming √© baseada nesse log de transa√ß√µes.  Temos v√°rios membros de replica√ß√£o de streaming: <br><br><ul><li>  mestre onde todas as mudan√ßas ocorrem; <br></li><li>  v√°rias r√©plicas que aceitam o log de transa√ß√µes do mestre e reproduzem todas essas altera√ß√µes nos dados locais.  Isso √© replica√ß√£o de streaming. <br></li></ul><br>  Vale lembrar que todos esses logs de transa√ß√µes s√£o armazenados no diret√≥rio pg_xlog em $ DATADIR - o diret√≥rio com os principais arquivos de dados DBMS.  Na 10¬™ vers√£o do PostgreSQL, esse diret√≥rio foi renomeado para pg_wal /, porque n√£o √© incomum o pg_xlog / ocupar muito espa√ßo, e desenvolvedores ou administradores, sem saber, confundi-lo com logs, excluir alegremente e tudo fica ruim. <br><br>  O PostgreSQL possui v√°rios servi√ßos em segundo plano envolvidos na replica√ß√£o de streaming.  Vamos examin√°-los do ponto de vista do sistema operacional. <br><br><ul><li>  Do lado do mestre - processo WAL Sender.  Este √© um processo que envia logs de transa√ß√µes para r√©plicas, cada r√©plica ter√° seu pr√≥prio WAL Sender. <br></li><li>  A r√©plica, por sua vez, executa o processo WAL Receiver, que recebe os logs de transa√ß√µes pela conex√£o de rede do remetente WAL e os passa para o processo de inicializa√ß√£o. <br></li><li>  O processo de inicializa√ß√£o l√™ os logs e reproduz no diret√≥rio de dados todas as altera√ß√µes registradas no log de transa√ß√µes. <br></li></ul><br><img src="https://habrastorage.org/webt/ek/g2/rd/ekg2rdtwkvfjw8hlpj0rhhzhogu.jpeg"><br>  Esquematicamente, √© algo parecido com isto: <br><br><ul><li>  As altera√ß√µes s√£o gravadas nos buffers WAL, que ser√£o gravados no log de transa√ß√µes; <br></li><li>  Os logs est√£o armazenados no diret√≥rio pg_wal /; <br></li><li>  O WAL Sender l√™ o log de transa√ß√µes do reposit√≥rio e os transmite pela rede; <br></li><li>  O receptor WAL recebe e armazena em seu armazenamento - no local pg_wal /; <br></li><li>  O processo de inicializa√ß√£o l√™ tudo o que √© aceito e reproduzido. <br></li></ul><br>  O esquema √© simples.  A replica√ß√£o de fluxo funciona de maneira bastante confi√°vel e foi excelentemente explorada por muitos anos. <br><a name="tools"></a><br><h2>  Ferramentas de solu√ß√£o de problemas <br></h2><br>  Vamos ver quais ferramentas e utilit√°rios a comunidade e o PostgreSQL oferecem para investigar os problemas encontrados na replica√ß√£o de streaming. <br><br><h3>  Ferramentas de terceiros <br></h3><br>  Vamos come√ßar com ferramentas de terceiros.  Esses utilit√°rios t√™m um <strong>plano</strong> bastante <strong>universal</strong> ; podem ser usados ‚Äã‚Äãn√£o apenas para investigar incidentes relacionados √† replica√ß√£o de streaming.  Geralmente, s√£o <strong>utilit√°rios de qualquer administrador do sistema</strong> . <br><br><ul><li>  <strong>top</strong> do pacote procps.  Como um substituto para o top, voc√™ pode usar quaisquer utilit√°rios, como top, htop e similares.  Eles oferecem funcionalidade semelhante. </li></ul><br>  Com a ajuda do topo, analisamos: utiliza√ß√£o de processadores (CPU), carga m√©dia (carga m√©dia) e uso de mem√≥ria e espa√ßo de troca. <br><br><ul><li>  iostat de sysstat e iotop.  Esses utilit√°rios mostram a utiliza√ß√£o de dispositivos de disco e qual E / S √© criada pelos processos no sistema operacional. </li></ul><br>  Com a ajuda do iostat, procuramos: utiliza√ß√£o do armazenamento, quantos lops no momento, qual taxa de transfer√™ncia nos dispositivos, quais atrasos no processamento de solicita√ß√µes de E / S (lat√™ncia).  Essas informa√ß√µes bastante detalhadas s√£o obtidas do sistema de arquivos procfs e fornecidas ao usu√°rio de forma visual. <br><br><ul><li>  O nicstat √© um an√°logo do iostat, apenas para interfaces de rede.  Neste utilit√°rio, voc√™ pode assistir a utiliza√ß√£o de interfaces. </li></ul><br>  Usando o nicstat, observamos: da mesma forma, utiliza√ß√£o da interface, alguns erros que ocorrem nas interfaces, a taxa de transfer√™ncia tamb√©m √© um utilit√°rio muito √∫til. <br><br><ul><li>  O pgCenter √© um utilit√°rio para trabalhar apenas com o PostgreSQL.  Ele mostra as estat√≠sticas do PostgreSQL em uma interface de ponta, e voc√™ tamb√©m pode ver estat√≠sticas relacionadas √† replica√ß√£o de streaming. </li></ul><br>  Com a ajuda do pgCenter, olhamos: estat√≠sticas sobre replica√ß√£o.  Voc√™ pode observar o atraso na replica√ß√£o, de alguma forma avali√°-lo e prever trabalhos futuros. <br><br><ul><li>  perf √© um utilit√°rio para uma investiga√ß√£o mais profunda das causas de "golpes subterr√¢neos", quando em opera√ß√£o existem problemas estranhos no n√≠vel de c√≥digo do PostgreSQL. </li></ul><br>  Com a ajuda do perf, procuramos: batidas subterr√¢neas.  Para que o perf funcione totalmente com o PostgreSQL, este √∫ltimo deve ser compilado com caracteres de depura√ß√£o, para que voc√™ possa ver a pilha de fun√ß√µes nos processos e quais fun√ß√µes levam mais tempo na CPU. <br><br>  Todos esses utilit√°rios s√£o necess√°rios para <strong>testar hip√≥teses</strong> que surgem ao solucionar problemas - verifique onde e o que diminui, onde e o que voc√™ precisa corrigir.  Esses utilit√°rios ajudam a garantir que estamos no caminho certo. <br><br><h3>  Ferramentas Incorporadas <br></h3><br>  O que o pr√≥prio PostgreSQL oferece? <br><br><h4>  Visualiza√ß√µes do sistema <br></h4><br>  Em geral, existem muitas ferramentas para trabalhar com o PostgreSQL.  Cada empresa fornecedora que fornece suporte ao PostgreSQL oferece suas pr√≥prias ferramentas.  Mas, como regra, essas ferramentas s√£o baseadas em estat√≠sticas internas do PostgreSQL.  Nesse sentido, o PostgreSQL fornece visualiza√ß√µes de sistema nas quais voc√™ pode fazer v√°rias sele√ß√µes e obter as informa√ß√µes necess√°rias.  Ou seja, usando um cliente comum, geralmente psql, podemos fazer consultas e ver o que acontece nas estat√≠sticas. <br><br>  Existem algumas visualiza√ß√µes do sistema.  Para trabalhar com a replica√ß√£o de streaming e investigar problemas, precisamos apenas de: pg_stat_replication, pg_stat_wal_receiver, pg_stat_databases, pg_stat_databases_conflicts e auxiliar pg_stat_activity e pg_stat_archiver. <br><br>  Existem alguns deles, mas esse conjunto √© suficiente para verificar se h√° algum problema. <br><br><h4>  Fun√ß√µes auxiliares <br></h4><br>  Usando fun√ß√µes auxiliares, voc√™ pode obter dados das representa√ß√µes estat√≠sticas do sistema e transform√°-los em uma forma mais conveniente para si mesmo.  As fun√ß√µes auxiliares tamb√©m s√£o apenas algumas pe√ßas. <br><br><ul><li>  pg_current_wal_lsn () (o antigo an√°logo de pg_current_xlog_location ()) √© a fun√ß√£o mais necess√°ria que permite ver a posi√ß√£o atual no log de transa√ß√µes.  Um log de transa√ß√µes √© uma sequ√™ncia cont√≠nua de dados.  Usando esta fun√ß√£o, voc√™ pode ver o √∫ltimo ponto, obter a posi√ß√£o em que o log de transa√ß√µes parou agora. <br></li><li>  pg_last_wal_receive_lsn (), pg_last_xlog_receive_location () √© uma fun√ß√£o semelhante ao anterior, apenas para r√©plicas.  A r√©plica recebe o log de transa√ß√µes e voc√™ pode ver a √∫ltima posi√ß√£o do log de transa√ß√µes recebidas; <br></li><li>  pg_wal_lsn_diff (), pg_xlog_location_diff () √© outra fun√ß√£o √∫til.  N√≥s damos a ela duas posi√ß√µes no log de transa√ß√µes, e ela mostra a diferen√ßa - a dist√¢ncia entre esses dois pontos em bytes.  Essa fun√ß√£o √© sempre √∫til para determinar o atraso entre o mestre e as r√©plicas em bytes. <br></li></ul><br>  Uma lista completa de fun√ß√µes pode ser obtida com o meta-comando psql: \ df * (wal | xlog | lsn | location) *. <br><br>  Voc√™ pode digit√°-lo no psql e ver todas as fun√ß√µes que wal, xlog, Isn, location cont√™m.  Haver√° cerca de 20 a 30 fun√ß√µes, e elas tamb√©m fornecem v√°rias informa√ß√µes no log de transa√ß√µes.  Eu recomendo que voc√™ se familiarize. <br><br><h4>  Utilit√°rio Pg_waldump <br></h4><br>  Antes da vers√£o 10.0, era chamado pg_xlogdump.  O utilit√°rio pg_waldump √© necess√°rio quando queremos examinar os segmentos do log de transa√ß√µes, descobrir quais registros de recursos chegaram l√° e o que o PostgreSQL escreveu l√°, ou seja, para um estudo mais detalhado. <br><br><blockquote>  Na vers√£o 10.0, todas as visualiza√ß√µes, fun√ß√µes e utilit√°rios do sistema que inclu√≠am a palavra xlog foram renomeadas.  Todas as ocorr√™ncias das palavras xlog e location foram substitu√≠das pelas palavras wal e lsn, respectivamente.  O mesmo foi feito com o diret√≥rio pg_xlog, que se tornou o diret√≥rio pg_wal. <br></blockquote><br>  O utilit√°rio pg_waldump simplesmente decodifica o conte√∫do dos segmentos XLOG em um formato leg√≠vel por humanos.  Voc√™ pode ver quais registros de recursos se enquadram nos logs de segmentos durante o trabalho do PostgreSQL, quais √≠ndices e arquivos de heap foram alterados, quais informa√ß√µes foram direcionadas para o modo de espera.  Assim, muitas informa√ß√µes podem ser visualizadas usando pg_waldump. <br><br><blockquote>  Mas h√° um aviso de isen√ß√£o de responsabilidade escrito na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o oficial</a> : pg_waldump pode mostrar dados ligeiramente incorretos quando o PostgreSQL est√° em execu√ß√£o (pode gerar resultados incorretos quando o servidor est√° em execu√ß√£o - o que isso significa) </blockquote><br>  Voc√™ pode usar o comando: <br><br><pre><code class="sql hljs">pg_waldump -f - /wal_10 \ $(psql -qAtX - "<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_walfile_name(pg_current_wal_lsn())<span class="hljs-string"><span class="hljs-string">")</span></span></code> </pre> <br>  Este √© um an√°logo do comando tail -f apenas para logs de transa√ß√µes.  Este comando mostra a cauda do log de transa√ß√µes que est√° acontecendo no momento.  Voc√™ pode executar este comando, ele encontrar√° o √∫ltimo segmento com a entrada mais recente do log de transa√ß√µes, se conectar√° a ele e come√ßar√° a exibir o conte√∫do do log de transa√ß√µes.  Uma equipe um pouco complicada, mas, no entanto, funciona.  Costumo us√°-lo. <br><a name="cases"></a><br><h2>  Casos de solu√ß√£o de problemas <br></h2><br>  Aqui, examinamos os problemas mais comuns que surgem na pr√°tica dos consultores, quais podem ser os sintomas e como diagnostic√°-los: <br><br>  <strong>As defasagens de replica√ß√£o s√£o o problema mais comum</strong> .  Mais recentemente, tivemos correspond√™ncia com o cliente: <br><br><blockquote>  - <em>Quebramos a replica√ß√£o mestre-escravo entre os dois servidores.</em> <br><br>  - Detec√ß√£o de atraso 2 horas, iniciado pg_dump. <br><br>  - <em>entendi.</em>  <em>Qual √© o nosso atraso permitido?</em> <br><br>  - 16 horas em max_standby_streaming_delay. <br><br>  <em>- O que acontecer√° quando esse atraso for excedido?</em>  <em>Sirene uivante?</em> <br><br>  - N√£o, as transa√ß√µes ser√£o vencidas e o rolo WAL ser√° retomado. <br></blockquote><br>  Temos problemas com atrasos na replica√ß√£o o tempo todo, e quase toda semana n√≥s os resolvemos. <br><br>  <strong>O aumento do diret√≥rio pg_wal / em</strong> que os segmentos do log de transa√ß√µes est√£o armazenados √© um problema que ocorre com menos frequ√™ncia.  Por√©m, neste caso, √© necess√°rio tomar medidas imediatas para que o problema n√£o se transforme em uma situa√ß√£o de emerg√™ncia quando as r√©plicas ca√≠rem. <br><br>  <strong>Consultas longas</strong> executadas na r√©plica levam a <strong>conflitos durante a recupera√ß√£o</strong> .  Essa √© uma situa√ß√£o em que iniciamos algum tipo de carregamento na r√©plica, voc√™ pode executar consultas de leitura nas r√©plicas e, nesse momento, essas consultas interferem na reprodu√ß√£o do log de transa√ß√µes.  Existe um conflito, e o PostgreSQL precisa decidir se deve aguardar a conclus√£o da consulta ou conclu√≠-la e continuar reproduzindo o log de transa√ß√µes.  Este √© um conflito de replica√ß√£o ou de recupera√ß√£o. <br><br>  <strong>Processo de recupera√ß√£o: 100% de uso da CPU - O</strong> processo de recupera√ß√£o de um log de transa√ß√µes em r√©plicas leva 100% do tempo do processador.  Essa tamb√©m √© uma situa√ß√£o rara, mas √© bastante desagrad√°vel, porque  leva a um aumento no atraso na replica√ß√£o e geralmente √© dif√≠cil de investigar. <br><br><h3>  Atrasos na replica√ß√£o <br></h3><br>  As defasagens de replica√ß√£o ocorrem quando a mesma solicita√ß√£o, executada no mestre e na r√©plica, retorna dados diferentes.  Isso significa que os dados s√£o inconsistentes entre o mestre e as r√©plicas, e h√° algum atraso.  A r√©plica precisa reproduzir parte dos logs de transa√ß√µes para acompanhar o assistente.  O principal sintoma se parece exatamente com isso: h√° uma consulta e eles retornam resultados diferentes. <br><br>  <strong>Como procurar por esses problemas?</strong> <br><br><ul><li>  H√° uma vis√£o b√°sica no assistente e nas r√©plicas - <strong>pg_stat_replication</strong> .  Ele mostra informa√ß√µes sobre todo o WAL Sender, ou seja, sobre processos que enviam logs de transa√ß√µes.  Cada r√©plica ter√° uma linha separada que mostra estat√≠sticas para essa r√©plica espec√≠fica. <br></li><li>  A fun√ß√£o auxiliar <strong>pg_wal_lsn_diff ()</strong> permite comparar posi√ß√µes diferentes no log de transa√ß√µes e calcular o mesmo atraso.  Com sua ajuda, podemos obter n√∫meros espec√≠ficos e determinar onde temos um grande atraso, onde √© pequeno e j√° de alguma forma respondemos ao problema. <br></li><li>  A fun√ß√£o <strong>pg_last_xact_replay_timestamp ()</strong> funciona apenas na r√©plica e permite ver o hor√°rio em que a √∫ltima transa√ß√£o perdida foi executada.  Existe uma fun√ß√£o now () bem conhecida que mostra a hora atual, subtra√≠mos a hora que nos √© mostrada pela fun√ß√£o pg_last_xact_replay_timestamp () da fun√ß√£o now () e obtemos o intervalo de tempo. <br></li></ul><br>  Na 10¬™ vers√£o do pg_stat_replication, surgiram campos adicionais que mostram o intervalo de tempo j√° existente no assistente; portanto, esse m√©todo j√° est√° desatualizado, mas, no entanto, pode ser usado. <br><br>  H√° uma pequena armadilha.  Se n√£o houver transa√ß√µes no assistente por um longo per√≠odo de tempo e ele n√£o gerar logs de transa√ß√µes, a √∫ltima fun√ß√£o mostrar√° um atraso crescente.  De fato, o sistema est√° simplesmente ocioso, n√£o h√° atividade, mas no monitoramento podemos ver que o atraso est√° crescendo.  Vale a pena lembrar dessa armadilha. <br><br>  A vista √© a seguinte. <br><br><img src="https://habrastorage.org/webt/sb/jg/6k/sbjg6kswtdtymuecundldk180r8.jpeg"><br><br>  Ele cont√©m informa√ß√µes sobre cada remetente WAL e v√°rios campos que s√£o importantes para n√≥s.  Isso √© principalmente <strong>client_addr</strong> - o endere√ßo de rede da r√©plica conectada (geralmente um endere√ßo IP) e um conjunto de campos <strong>lsn</strong> (em vers√µes mais antigas √© chamado de localiza√ß√£o), falarei um pouco mais sobre eles. <br><br>  Na 10¬™ vers√£o, os campos de <strong>lag</strong> apareceram - este √© um atraso expresso no tempo, ou seja, um formato mais leg√≠vel para humanos.  O atraso pode ser expresso em bytes ou no tempo - voc√™ pode escolher o que mais gosta. <br><br>  Como regra, eu uso essa solicita√ß√£o. <br><br><img src="https://habrastorage.org/webt/ff/8g/kv/ff8gkvz-kzdihuxabphcb0rfd4e.jpeg"><br><br>  Esta n√£o √© a consulta mais complexa que pg_stat_replication imprime em um formato mais conveniente e compreens√≠vel.  Aqui eu uso as seguintes fun√ß√µes: <br><br><ul><li>  <strong>pg_wal_lsn_diff ()</strong> para ler as diferen√ßas.  Mas entre o que eu acho que diffs s√£o?  Temos v√°rios campos - sent_lsn, write_lsn, flush_lsn, replay_lsn.  Ao calcular a diferen√ßa entre o campo atual e o anterior, podemos entender com precis√£o onde ficamos, onde exatamente ocorre o atraso. <br></li><li>  <strong>pg_current_wal_lsn ()</strong> , que mostra a posi√ß√£o atual do log de transa√ß√µes.  Aqui, examinamos a dist√¢ncia entre a posi√ß√£o atual no log e a enviada - quantos logs de transa√ß√µes foram gerados, mas n√£o enviados. <br></li><li>  <strong>sent_lsn</strong> , <strong>write_lsn</strong> - √© quanto √© enviado para a r√©plica, mas n√£o gravado.  Ou seja, agora est√° localizado em algum lugar da rede ou foi recebido por uma r√©plica, mas ainda n√£o foi gravado dos buffers de rede no armazenamento em disco. <br></li><li>  <strong>write_lsn, flush_lsn</strong> - est√° gravado, mas n√£o foi emitido pelo comando fsync - como se estivesse gravado, mas pode estar localizado em algum lugar na RAM, no cache da p√°gina do sistema operacional.  Assim que fazemos o fsync, os dados s√£o sincronizados com o disco, chegam ao armazenamento persistente e tudo parece confi√°vel. <br></li><li>  <strong>replay_lsn, flush_lsn</strong> - dados despejados, fsync executado, mas n√£o replicado. <br></li><li>  <strong>current_wal_lsn</strong> e <strong>replay_lsn</strong> √© um tipo de atraso total que inclui todas as posi√ß√µes anteriores. <br></li></ul><br><h4>  <strong>Alguns exemplos</strong> <br></h4><br><img src="https://habrastorage.org/webt/7c/9n/tt/7c9nttg6yp-uyimrxa4ji3ll1ha.jpeg"><br><br>  A r√©plica 10.6.6.8 est√° destacada acima.  Ela tem um <strong>atraso pendente</strong> , gerou alguns logs de transa√ß√µes, mas eles ainda n√£o foram enviados e est√£o no mestre.  Provavelmente, h√° algum tipo de problema com o desempenho da rede.  Vamos verificar isso usando o utilit√°rio nicstat. <br><br>  Lan√ßaremos o nicstat, veremos a utiliza√ß√£o da interface, se houver algum problema ou erro.  Para que possamos testar esta hip√≥tese. <br><br><img src="https://habrastorage.org/webt/co/-m/fj/co-mfjznunlrsuurikvz7xy9gh0.jpeg"><br><br>  O <strong>atraso de grava√ß√£o est√°</strong> marcado acima.  De fato, esse atraso √© bastante raro, quase n√£o vejo que seja grande.  O problema pode estar nos discos e usamos o utilit√°rio iostat ou iotop - examinamos a utiliza√ß√£o dos armazenamentos de disco, que a E / S √© criada pelos processos e depois descobrimos o porqu√™. <br><br><img src="https://habrastorage.org/webt/to/xw/2j/toxw2jutr7yaof38fwbohph9lva.jpeg"><br><br>  <strong>Liberar e reproduzir atrasos</strong> - geralmente o atraso ocorre quando o dispositivo de disco na r√©plica n√£o tem tempo para simplesmente perder todas as altera√ß√µes que chegam do mestre. <br><br>  Tamb√©m com os utilit√°rios iostat e iotop, examinamos o que acontece com a utiliza√ß√£o do disco e por que os freios. <br><br>  E o √∫ltimo <strong>total_lag</strong> √© uma m√©trica √∫til para sistemas de monitoramento.  Se nosso limite total_lag for excedido, uma caixa de sele√ß√£o ser√° exibida no monitoramento e come√ßaremos a investigar o que est√° acontecendo l√°. <br><br><h4>  <strong>Teste de hip√≥tese</strong> <br></h4><br>  Agora voc√™ precisa descobrir como investigar mais um problema espec√≠fico.  Eu j√° disse que, se houver um atraso na rede, precisamos verificar se est√° tudo em ordem com a rede. <br><br>  Agora, quase todos os hosters fornecem 1 Gb / s ou at√© 10 Gb / s, portanto, uma <strong>largura de banda entupida √© o cen√°rio mais improv√°vel</strong> .  Como regra, voc√™ precisa observar os erros.  O nicstat cont√©m informa√ß√µes sobre erros nas interfaces. Voc√™ pode descobrir que h√° problemas com os drivers, com a pr√≥pria placa de rede ou com os cabos. <br><br>  Investigamos <strong>problemas de armazenamento</strong> usando o iostat e o iotop.  O iostat √© necess√°rio para visualizar a imagem geral do armazenamento em disco: reciclagem de dispositivos, largura de banda, lat√™ncia.  iotop - para pesquisas mais precisas, quando precisamos identificar qual processo est√° carregando o subsistema de disco.  Se esse √© algum tipo de processo de terceiros, ele pode ser simplesmente detectado, conclu√≠do e talvez o problema desapare√ßa. <br><br>  Primeiro, analisamos <strong>os atrasos</strong> na <strong>recupera√ß√£o e os conflitos de replica√ß√£o</strong> por meio de top ou pg_stat_activity: quais processos est√£o em execu√ß√£o, quais solicita√ß√µes est√£o em execu√ß√£o, seu tempo de execu√ß√£o e quanto tempo est√£o em execu√ß√£o.  Se houver algumas consultas longas, veremos por que elas funcionam por um longo tempo, filmamos, entendemos e <strong>otimizamos</strong> - examinaremos as pr√≥prias consultas. <br><br>  Se houver uma <strong>grande quantidade de logs de transa√ß√µes</strong> gerados pelo assistente, podemos detectar isso por <strong>pg_stat_activity</strong> .  Talvez alguns processos de backup sejam iniciados l√°, algum tipo de v√°cuo tenha sido iniciado (pg_stat_progress_vacuum) ou o ponto de verifica√ß√£o esteja sendo executado.  Ou seja, se muitos logs de transa√ß√µes forem gerados e a r√©plica simplesmente n√£o tiver tempo para process√°-la, em algum momento ela poder√° cair e isso ser√° um problema para n√≥s. <br><br>  E, √© claro, <strong>pg_wal_lsn_diff ()</strong> para determinar o atraso e determinar onde o temos especificamente - na rede, em discos ou em processadores. <br><br><h4>  <strong>Op√ß√µes de solu√ß√£o</strong> <br></h4><br>  <strong>Problemas de rede / armazenamento</strong> <br><br>  Tudo √© bem simples aqui, mas do ponto de vista da configura√ß√£o, isso geralmente n√£o √© resolvido.  Voc√™ pode apertar algumas porcas, mas em geral existem 2 op√ß√µes: <br><br><ul><li>  Verificar carga de trabalho </li></ul><br>  Verifique quais pedidos est√£o em execu√ß√£o.  Talvez seja iniciado algum tipo de migra√ß√£o que gere muitos logs de transa√ß√µes, ou possa ser transfer√™ncia, exclus√£o ou inser√ß√£o de dados.  <strong>Qualquer processo que gera logs de transa√ß√£o pode levar a um atraso na transa√ß√£o</strong> .  Todos os dados no assistente s√£o gerados o mais r√°pido poss√≠vel, fizemos uma altera√ß√£o nos dados, enviamos para a r√©plica e a r√©plica pode lidar ou falhar - isso n√£o diz respeito ao assistente.  Um atraso pode aparecer aqui e voc√™ precisa fazer algo com ele. <br><br><ul><li>  Atualizar hardware <br></li></ul><br>  A op√ß√£o mais est√∫pida - talvez tenhamos encontrado desempenho de ferro e voc√™ s√≥ precise alter√°-lo.  Pode ser discos antigos ou SSDs de baixa qualidade ou um plug-in no desempenho de um controlador RAID.  Aqui n√£o estamos mais explorando a base em si, mas verificando o desempenho de nossas gl√¢ndulas. <br><br>  <strong>Atrasos na recupera√ß√£o</strong> <br><br>  Se houver algum tipo de conflito de replica√ß√£o devido a solicita√ß√µes longas, resultando em um aumento no atraso na reprodu√ß√£o, a <strong>primeira coisa</strong> que fazemos √© <strong>disparar solicita√ß√µes longas</strong> que s√£o executadas na r√©plica, porque atrasam a reprodu√ß√£o dos logs de transa√ß√µes. <br><br>  Se consultas longas estiverem relacionadas √† n√£o otimiza√ß√£o da pr√≥pria consulta SQL (n√≥s descobrimos isso usando EXPLAIN ANALYZE), basta abordar essa consulta de maneira diferente e reescrev√™-la.  Ou existe uma op√ß√£o para configurar uma <strong>r√©plica separada para relat√≥rios de consultas</strong> .  Se fizermos relat√≥rios que funcionem por um longo per√≠odo, eles precisam ser enviados para uma r√©plica separada. <br><br>  Ainda h√° a op√ß√£o de <strong>apenas esperar</strong> .  Se tivermos algum tipo de atraso no n√≠vel de alguns kilobytes ou mesmo dezenas de megabytes, mas achamos que isso √© aceit√°vel, esperamos apenas que a solicita√ß√£o seja conclu√≠da e o atraso se resolva.  Isso tamb√©m √© uma op√ß√£o, e muitas vezes acontece que √© aceit√°vel. <br><br>  <strong>WAL de alto volume</strong> <br><br>  Se gerarmos um grande volume de log de transa√ß√µes, precisamos reduzir esse <strong>volume por unidade de tempo</strong> , para fazer com que a r√©plica mastigue menos logs de transa√ß√µes. <br><br>  Isso geralmente √© feito <strong>atrav√©s da configura√ß√£o</strong> .  Solu√ß√£o parcial na configura√ß√£o do par√¢metro full_page_writes = off.  Essa op√ß√£o ativa / desativa a grava√ß√£o de imagens completas das p√°ginas alteradas no log de transa√ß√µes.  Isso significa que, quando tivemos a opera√ß√£o de servi√ßo de escrever um ponto de verifica√ß√£o (CHECKPOINT), na pr√≥xima vez que alterarmos algum bloco de dados na √°rea de buffers compartilhados, a imagem completa desta p√°gina ir√° para o log de transa√ß√µes, e n√£o apenas a altera√ß√£o em si.  Com todas as altera√ß√µes subsequentes na mesma p√°gina, apenas as altera√ß√µes ser√£o registradas no log de transa√ß√µes.  E assim por diante at√© o pr√≥ximo ponto de verifica√ß√£o. <br><br>  Ap√≥s o ponto de verifica√ß√£o, registramos a imagem completa da p√°gina e isso afeta o volume do log de transa√ß√µes gravado.  Se houver muitos pontos de verifica√ß√£o por unidade de tempo, digamos que 4 pontos de verifica√ß√£o sejam feitos por hora e haver√° muitas imagens de p√°gina inteira, isso ser√° um problema.  Voc√™ pode desativar a grava√ß√£o de imagens completas e isso afetar√° o volume do WAL.  Mas, novamente, esta √© uma meia medida. <br><br>  <i>Nota: A recomenda√ß√£o para desativar full_page_writes deve ser considerada com cuidado, pois o autor esqueceu de esclarecer durante o relat√≥rio que a desativa√ß√£o de um par√¢metro pode, em algumas circunst√¢ncias, ocorrer em situa√ß√µes de emerg√™ncia (danos ao sistema de arquivos ou ao seu log, grava√ß√£o parcial em blocos etc.) arquivos de banco de dados potencialmente corrompidos.</i>  <i>Portanto, tenha cuidado, desabilitar o par√¢metro pode aumentar o risco de corrup√ß√£o de dados em situa√ß√µes de emerg√™ncia.</i> <br><br>  Outra metade da medida √© <strong>aumentar o intervalo entre os pontos de verifica√ß√£o</strong> .  Por padr√£o, o ponto de verifica√ß√£o √© feito a cada 5 minutos, e isso √© bastante comum.  Como regra, esse intervalo √© aumentado para 30 a 60 minutos - esse √© um per√≠odo aceit√°vel para o qual todas as p√°ginas sujas conseguem se sincronizar com o disco. <br><br>  Mas a solu√ß√£o principal √©, obviamente, <strong>examinar nossa carga de trabalho</strong> - que tipo de opera√ß√µes pesadas est√£o acontecendo l√°, associadas √† altera√ß√£o dos dados e, talvez, tentar fazer essas altera√ß√µes em lotes. <br><br>  Suponha que tenhamos uma tabela, queremos excluir v√°rios milh√µes de registros dela.  A melhor op√ß√£o √© n√£o excluir esses milh√µes de uma s√≥ vez com uma solicita√ß√£o, mas dividi-los em pacotes de 100 a 200 mil, para que, primeiro, sejam gerados pequenos volumes de WAL, em segundo lugar, o v√°cuo tenha tempo para passar pelos dados exclu√≠dos e, portanto, o atraso n√£o foi t√£o grande e cr√≠tico. <br><br><h3>  Incha√ßo pg_wal / <br></h3><br>  Agora, vamos falar sobre como voc√™ pode descobrir que o diret√≥rio pg_wal / est√° inchado. <br><br>  Em teoria, o PostgreSQL sempre o mant√©m em um estado ideal para si mesmo no n√≠vel de certos arquivos de configura√ß√£o e, como regra, n√£o deve crescer acima de certos limites. <br><br>  Existe um par√¢metro max_wal_size, que determina o valor m√°ximo.  Al√©m disso, existe o par√¢metro wal_keep_segments - um n√∫mero adicional de segmentos que o mestre armazena para a r√©plica, se a r√©plica estiver subitamente indispon√≠vel por um longo per√≠odo de tempo. <br><br>  Tendo calculado a soma de max_wal_size e wal_keep_segments, podemos estimar aproximadamente quanto espa√ßo o diret√≥rio pg_wal / ocupar√°.  Se crescer rapidamente e ocupar muito mais espa√ßo do que o valor calculado, isso significa que h√° algum problema e voc√™ precisa fazer algo a respeito. <br><br><h4>  Como detectar tais problemas? <br></h4><br>  No sistema operacional Linux, existe o <strong>comando du -csh</strong> .  Podemos simplesmente monitorar o valor e monitorar quantos logs de transa√ß√µes temos l√°;  mantenha um r√≥tulo calculado, quanto ele deve e quanto ele realmente recebe e, de alguma forma, responde a mudan√ßas nos n√∫meros. <br><br>  Outro lugar que examinamos s√£o as <strong>visualiza√ß√µes pg_replication_slots</strong> e <strong>pg_stat_archiver</strong> .  Os motivos mais comuns pelos quais o pg_wal / ocupa muito espa√ßo s√£o slots de replica√ß√£o esquecidos ou arquivamento interrompido.  Outras raz√µes tamb√©m t√™m um lugar para estar, mas na minha pr√°tica eram muito raras. <br><br>  E, √© claro, sempre h√° erros nos logs do PostgreSQL associados ao comando archive.  Infelizmente, n√£o haver√° outros motivos relacionados ao pg_wal / overflow.  Podemos pegar apenas erros de arquivamento l√°. <br><br><h4>  Op√ß√µes para problemas: <br></h4><br>  <strong>CRUD</strong> pesado - <strong>opera√ß√µes</strong> pesadas de atualiza√ß√£o de dados - INSERT, DELETE, UPDATE pesado, associado √† altera√ß√£o de v√°rios milh√µes de linhas.  Se o PostgreSQL precisar fazer essa opera√ß√£o, √© claro que uma grande quantidade de log de transa√ß√µes ser√° gerada.  Ele ser√° armazenado em pg_wal /, e isso aumentar√° o espa√ßo ocupado.  Ou seja, como j√° disse anteriormente, √© uma boa pr√°tica simplesmente dividi-los em pacotes e atualizar n√£o toda a matriz, mas 100, 200, 300 mil cada. <br><br>  <strong>Um slot de replica√ß√£o esquecido ou n√£o usado</strong> √© outro problema comum.  As pessoas costumam usar replica√ß√£o l√≥gica para algumas de suas tarefas: configuram barramentos que enviam dados para Kafka, enviam dados para um aplicativo de terceiros que decodifica a replica√ß√£o l√≥gica para outro formato e os processa de alguma forma.  <strong>A replica√ß√£o l√≥gica normalmente funciona atrav√©s de slots</strong> .  Ocorre que configuramos um slot de replica√ß√£o, reproduzido com o aplicativo, percebemos que esse aplicativo n√£o nos conv√©m, desativamos o aplicativo, o exclu√≠mos <strong>e os slots de replica√ß√£o continuam ativos</strong> . <br><br>  O PostgreSQL para cada slot de replica√ß√£o salva segmentos do log de transa√ß√µes, caso um aplicativo ou r√©plica remota se conecte a esse slot novamente e, em seguida, o assistente pode enviar esses logs de transa√ß√£o. <br><br>  Mas o tempo passa, ningu√©m se conecta ao slot, os logs de transa√ß√µes s√£o acumulados e, em algum momento, ocupam 90% do espa√ßo.  Precisamos descobrir o que √©, por que tanto espa√ßo √© ocupado.  Como regra, esse slot esquecido e n√£o utilizado precisa ser removido e o problema ser√° resolvido.  Mas mais sobre isso mais tarde. <br><br>  Outra op√ß√£o pode ser um <strong>arquivo morto_command</strong> .  Quando temos algum tipo de reposit√≥rio de log de transa√ß√µes externo que mantemos para tarefas de recupera√ß√£o de desastre, geralmente um comando de arquivamento √© configurado, menos frequentemente o pg_receivexlog √© configurado.  O comando registrado no archive_command geralmente √© um comando separado ou algum script que pega segmentos do log de transa√ß√µes de pg_wal / e o copia para o armazenamento do archive. <br><br>  Ocorre que realizamos algum tipo de atualiza√ß√£o de pacotes do sistema, por exemplo, no rsync, a vers√£o foi alterada, os sinalizadores foram atualizados ou alterados, ou em algum outro comando usado no comando archive, o formato tamb√©m foi alterado - e o script ou o pr√≥prio programa especificado em archive_command breaks.  Consequentemente, os arquivos deixam de ser copiados. <br><br>  Se o comando archive funcionou com uma sa√≠da diferente de 0, uma mensagem sobre isso ser√° gravada no log e o segmento permanecer√° no diret√≥rio pg_wal /.  <strong>At√© descobrirmos que nossa equipe de arquivamento est√° quebrada, os segmentos se acumular√£o</strong> e o local tamb√©m terminar√° em algum momento. <br><br>  <strong>Conjunto de medidas de emerg√™ncia (100% de espa√ßo usado):</strong> <br><br> 1. <strong>   CRUD </strong> ,        ‚Äî pg_terminate_backend(). <br>    -  ,  , ,      ..       ,      pg_wal/,     . <br><br> 2. <strong>    </strong>    root ‚Äî reserved space ratio (ext filesystems). <br>       ext      ext     5%.  ,         ,  5% ‚Äî  . ,   ,     1%  ,     tune2fs -m 1.       PostgreSQL     ,    .      100%     . <br><br> 3. <strong>  </strong> (LVM, ZFS,...). <br>    LVM  ZFS,        LVM  ZFS,            ,   ,           .       ,   . <br><br> 4.    ‚Äî <strong>, , HE    pg_wal/</strong> . <br>          ,     ,   ,   .     ! PostgreSQL     ,   .     ,  ,   ,    . <br><br> , pg_xlog/   pg_wal/     ‚Äî  log    ,   , , ,  -   ‚Äî  ! <br><br><h4>    <br></h4><br>  ,         100%  CPU,      . <br><br>   <strong> workload  </strong> .    ,       ?  ,     - ,      -.         :   ,   tablespace,    tablespace. <br><br>   <strong> </strong> .       ,  ,    ,    , ,  ,            . <strong>   ‚Äî      .</strong> <br><br>   <strong>  checkpoints_segments/max_wal_size, wal_keep_segments</strong> .  ,    ,      ‚Äî 10-20   wal_keep_segments,     max_wal_size.  ,        .  PostgreSQL       pg_wal/  . <br><br>  <strong>  </strong>   pg_replication_slots ‚Äî     .   ,   <strong> </strong> ,        ‚Äî      .   ,    ,    .    . <br><br>      WAL,       ,  <strong>    pg_stat_archiver</strong> ,    . ,  <strong>  </strong> , ,    ,    . <br><br>    <strong>   checkpoint</strong> .       ,        ,      . , PostgreSQL        . <strong>   ,    checkpoint</strong> . <br><br><h3>       <br></h3><br>    ,   ,   ‚Äî        .   -             ,       .      ,         . <br><br> <strong> </strong> ‚Äî    PostgreSQL  : <br><br><ul><li> User was holding shared bufer pin for too long. <br></li><li> User query might have needed to see row versions that must be removed. <br></li><li> User was holding a relation lock for too long. <br></li><li> User was or might have been using table space that must be dropped. <br></li><li> User transaction caused bufer deadlock with recovery. <br></li><li> User was connected to a database that must be dropped. <br></li></ul><br>  2  ‚Äî    ,       ,      .   :  ,   ,      .        (  30 ),  <strong>PostgreSQL       </strong> ‚Äî  . <br><br>    .  ,    ,             .    -    ,     timeout     .     ‚Äî    ALTER,    ,    . <br><br>     .     ,  tablespace     ,            tablespace.   ,    ,  -   ‚Äî   . <br><br><h4> <strong> ?</strong> <br></h4><br>       <strong>pg_stat_databases, pg_stat_databases_conflicts</strong> .         ,    .     ,    . <br><br>  <strong>  </strong> ,       <strong> </strong> .  ,      .   ,    . ,       ,    ,    . <br><br><h4> <strong> ?</strong> <br></h4><br>   ,    ‚Äî    : <br><br><ol><li> <strong> max_standby_streaming_delay</strong> (  ).     ,       .    <strong>   </strong> . <br></li><li> <strong> hot_stadby_feedback</strong> (  /).  ,  vacuum   - ,       .     <strong> bloat  </strong> .     ,    ,  ,   hot_stadby_feedback  . <br></li><li>     DBA     ‚Äî  <strong>  </strong> .   <strong> </strong> ,    .  ,    ,     ,   -    ,  . <br></li><li>  , ,  ,   ,  DBA ‚Äî  <strong>     </strong> , ,  .    max_standby_streaming_delay  .       ,   .      ,  ,    ,  .  <strong>   </strong> ‚Äî    ,     . <br></li></ol><br><h2> Recovery process: 100% CPU usage <br></h2><br>  ,  ,    , <strong> 100%   </strong> .  ,      ,      100%.  ,    pg_stat_replication,  ,     replay,       ,    . <br><br> <strong></strong>  : <br><br><ul><li> <strong>top</strong> ‚Äî       ‚Äî    100% CPU usage  recovery process; <br></li><li> <strong>pg_stat_replication</strong> ‚Äî  ,   ,     . <br></li></ul><br><h4> <strong>   </strong> <br></h4><br>      ,    .  ,     : <br><br><ul><li> perf top/record/report ( debug‚Äî); <br></li><li> GDB; <br></li><li>  pg_waldump. <br></li></ul><br>  ,   ,       .     workload,   <strong>        </strong> .  ,    , PostgreSQL     shared buffers       ( ).        . <br><br><h4>  <strong>Solu√ß√£o</strong> <br></h4><br>    ,      <strong>   </strong> . -   workload, - , -    : ¬´      ,  -  ¬ª. <br><br>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pgsql-hackers</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pgsql-bugs</a> ,   ,   .  ,    . <br><br>     ‚Äî <strong>-   ,  , </strong> . <br><br><h2>  <br></h2><br> <strong>      </strong> .  ,             ,    ,      . <br><br> <strong>     </strong> .    , ,  ,    ,   ,   ‚Äî . <br><br>  , <strong>  </strong> ,   ‚Äî .   ,   ,  ,         . <br><br>  ,    ,  <strong>  </strong> ‚Äî  ,      ,   . <br><br><h3>  Links √∫teis <br></h3><br><ul><li> PostgreSQL official documentation ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">The Statistics Collector</a> </li><li> PostgreSQL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mailing Lists</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">general</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">performance</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">hackers</a> ) </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PostgreSQL-Consulting company blog</a> </li></ul><br><blockquote>             , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Highload++ Siberia</a> ,   <strong>25  26   </strong> .   ,     ,  . <br><br><ul><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>     MySQL  ClickHouse. </li><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> ,            Oracle. </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nikolay Golov </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lhe dir√°</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como implementar transa√ß√µes se o dinheiro estiver em um servi√ßo, servi√ßos em outro e cada servi√ßo tiver sua pr√≥pria base isolada.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yuri Nasretdinov </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">explicar√°</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em detalhes </font><font style="vertical-align: inherit;">por que a VK precisa do ClickHouse, a quantidade de dados armazenados e muito mais.</font></font></li></ul><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt414111/">https://habr.com/ru/post/pt414111/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt414095/index.html">[Tradu√ß√£o] Elasticsearch 6.3.0 lan√ßado</a></li>
<li><a href="../pt414097/index.html">Computadores Apple fecham vulnerabilidade de firmware encontrada por especialistas da Positive Technologies</a></li>
<li><a href="../pt414103/index.html">Semin√°rio on-line aberto: ‚ÄúRedes neurais para tarefas farmac√™uticas‚Äù</a></li>
<li><a href="../pt414105/index.html">Prevendo os resultados da Copa do Mundo de 2018 usando o algoritmo de florestas aleat√≥rias</a></li>
<li><a href="../pt414109/index.html">Usando o Docker para criar e executar um projeto C ++</a></li>
<li><a href="../pt414115/index.html">O que √© o Lazy FP State Restore: uma nova vulnerabilidade descoberta nos processadores Intel</a></li>
<li><a href="../pt414117/index.html">Formato bin√°rio decimal misto vs IEEE754</a></li>
<li><a href="../pt414119/index.html">A oportunidade adormeceu devido a uma tempestade de areia em Marte. N√£o est√° claro se o rover poder√° trabalhar novamente</a></li>
<li><a href="../pt414121/index.html">Drone aut√¥nomo DIY com controle da Internet</a></li>
<li><a href="../pt414123/index.html">Atualizamos os protocolos de texto para bin√°rios e combatemos o c√≥digo legado em uma reuni√£o do Grupo de Usu√°rios C ++</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>