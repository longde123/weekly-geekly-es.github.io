<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆒 🤲🏼 👲 FFI: menulis di Rust dalam program PHP 🛋️ 🗓️ 🚹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di PHP 7.4, FFI akan muncul, mis. Anda dapat menghubungkan pustaka di C (atau, misalnya, Karat) secara langsung, tanpa harus menulis seluruh ekstensi ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>FFI: menulis di Rust dalam program PHP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455614/"><p>  Di PHP 7.4, FFI akan muncul, mis.  Anda dapat menghubungkan pustaka di C (atau, misalnya, Karat) secara langsung, tanpa harus menulis seluruh ekstensi dan memahami banyak nuansanya. </p><br><blockquote>  Mari kita coba menulis kode dalam <strong>Rust</strong> , dan menggunakannya dalam program <strong>PHP</strong> </blockquote><a name="habracut"></a><br><p>  Gagasan menerapkan FFI di PHP 7.4 diambil dari LuaJIT dan Python, yaitu: parser dibangun ke dalam bahasa yang memahami deklarasi fungsi, struktur, dll.  Bahasa C.  Bahkan, Anda dapat menyelipkan seluruh konten file header di sana dan segera mulai menggunakannya. </p><br><p>  Contoh: </p><br><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">//    printf    $ffi = FFI::cdef( "int printf(const char *format, ...);", //     "libc.so.6"); //    //  printf $ffi-&gt;printf("Hello %s!\n", "world");</span></span></code> </pre> <br><p>  Menghubungkan orang yang sudah selesai itu sederhana dan menyenangkan, tetapi Anda juga ingin menulis sesuatu sendiri.  Misalnya, Anda perlu mem-parsing file dengan cepat, dan menggunakan hasil parsing dari php. </p><br><p>  Dari tiga bahasa sistem (C, C ++, Rust), saya pribadi memilih yang terakhir.  Alasannya sederhana: Saya tidak memiliki cukup kompetensi untuk segera menulis program memori-aman dalam C atau C ++.  Karat memang rumit, tetapi dalam hal ini terlihat lebih andal.  Kompiler segera memberi tahu Anda di mana Anda salah.  Hampir mustahil untuk mencapai Perilaku Tidak Terdefinisi. </p><br><p>  Penafian: Saya bukan pemrogram sistem, jadi gunakan sisanya dengan risiko Anda sendiri. </p><br><p>  Mari kita mulai dengan menulis sesuatu yang sangat sederhana, fungsi sederhana untuk menambahkan angka.  Hanya untuk pelatihan.  Lalu mari kita beralih ke tugas yang lebih sulit. </p><br><p>  Buat proyek sebagai perpustakaan </p><br><p> <code>cargo new hellofromrust --lib</code> </p> <br><p>  dan tunjukkan dalam cargo.toml bahwa itu adalah pustaka dinamis (dylib) </p><br><pre> <code class="plaintext hljs"> …. [lib] name="hellofromrust" crate-type = ["dylib"] ….</code> </pre> <br><p>  Fungsi itu sendiri pada Rast terlihat seperti ini </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addNumbers</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { x + y }</code> </pre> <br><p>  baik saya  fungsi normal, hanya beberapa kata ajaib no_mangle dan extern "C" yang ditambahkan </p><br><p>  Selanjutnya, kami melakukan pembangunan kargo untuk mendapatkan file-jadi (di Linux) </p><br><p>  Dapat digunakan dari php: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $ffi = FFI::cdef(<span class="hljs-string"><span class="hljs-string">"int addNumbers(int x, int y);"</span></span>, <span class="hljs-string"><span class="hljs-string">'./libhellofromrust.so'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"1+2="</span></span> . $ffi-&gt;addNumbers(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1+2=3</span></span></code> </pre> <br><p>  Menambahkan angka itu mudah.  Fungsi ini mengambil argumen integer berdasarkan nilai, dan mengembalikan integer baru. </p><br><p>  Tetapi bagaimana jika Anda perlu menggunakan string?  Tetapi bagaimana jika suatu fungsi mengembalikan tautan ke pohon elemen?  Dan bagaimana cara menggunakan konstruksi spesifik Rast dalam fungsi tanda tangan? </p><br><p>  Pertanyaan-pertanyaan ini menyiksa saya, jadi saya menulis parser ekspresi aritmatika pada Rast.  Dan saya memutuskan untuk menggunakannya dari PHP untuk mempelajari semua nuansa. </p><br><p>  Kode proyek lengkapnya ada di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">simple-rust-arithmetic-parser</a> .  Omong-omong, saya juga memasukkan gambar buruh pelabuhan di dalamnya yang berisi PHP (dikompilasi dengan FFI), Rust, Cbindgen, dll.  Semua yang Anda butuhkan untuk dijalankan. </p><br><p>  Pengurai, jika kita menganggap bahasa Rast murni, melakukan hal berikut: </p><br><p>  mengambil string dari bentuk " <code>100500*(2+35)-2*5</code> " dan mengubah ekspresi.rs menjadi <a href="">ekspresi</a> pohon: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expression</span></span></span></span> { Add(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expression&gt;, <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expression&gt;), Subtract(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expression&gt;, <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expression&gt;), Multiply(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expression&gt;, <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expression&gt;), Divide(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expression&gt;, <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expression&gt;), UnaryMinus(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expression&gt;), Value(<span class="hljs-built_in"><span class="hljs-built_in">i64</span></span>), }</code> </pre> <br><p>  itu adalah Rast enum, dan di Rast, seperti yang Anda tahu, enum bukan hanya seperangkat konstanta, tetapi Anda masih dapat mengikat nilai kepada mereka.  Di sini, jika jenis simpul adalah Ekspresi :: Nilai, maka bilangan bulat ditulis padanya, misalnya 100500. Untuk simpul tipe Tambah, kami juga akan menyimpan dua tautan (Kotak) ke ekspresi operan dari penambahan ini. <br></p><p>  Saya menulis parser dengan cepat, meskipun pengetahuan Rust terbatas, tetapi saya harus menyiksa diri sendiri dengan FFI.  Jika dalam C string adalah pointer ke tipe char *, mis.  pointer ke array karakter yang diakhiri dengan \ 0, kemudian di Rast itu adalah tipe yang sama sekali berbeda.  Oleh karena itu, Anda harus mengubah string input ke tipe &amp; str sebagai berikut: </p><br><pre> <code class="rust hljs">CStr::from_ptr(s).to_str()</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lebih lanjut tentang CStr</a> </p><br><p>  Ini semua setengah masalah.  Masalah sebenarnya adalah bahwa tidak ada Enums Rast atau tautan Kotak aman di C.  Oleh karena itu, saya harus membuat struktur ExpressionFfi terpisah untuk menyimpan pohon ekspresi C-style, yaitu  melalui struct, union dan pointer sederhana ( <a href="">ffi.rs</a> ). </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpressionFfi</span></span></span></span> { expression_type: ExpressionType, data: ExpressionData, } <span class="hljs-meta"><span class="hljs-meta">#[repr(u8)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpressionType</span></span></span></span> { Add = <span class="hljs-number"><span class="hljs-number">0</span></span>, Subtract = <span class="hljs-number"><span class="hljs-number">1</span></span>, Multiply = <span class="hljs-number"><span class="hljs-number">2</span></span>, Divide = <span class="hljs-number"><span class="hljs-number">3</span></span>, UnaryMinus = <span class="hljs-number"><span class="hljs-number">4</span></span>, Value = <span class="hljs-number"><span class="hljs-number">5</span></span>, } <span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">union</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpressionData</span></span></span></span> { pair_operands: PairOperands, single_operand: *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> ExpressionFfi, value: <span class="hljs-built_in"><span class="hljs-built_in">i64</span></span>, } <span class="hljs-meta"><span class="hljs-meta">#[derive(Copy, Clone)]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PairOperands</span></span></span></span> { left: *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> ExpressionFfi, right: *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> ExpressionFfi, }</code> </pre> <br><p>  Nah, dan metode untuk mengubahnya menjadi: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Expression { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert_to_c</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> ExpressionFfi { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> expression_data = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { Value(value) =&gt; ExpressionData { value: *value }, Add(left, right) | Subtract(left, right) | Multiply(left, right) | Divide(left, right) =&gt; ExpressionData { pair_operands: PairOperands { left: left.convert_to_c(), right: right.convert_to_c(), }, }, UnaryMinus(operand) =&gt; ExpressionData { single_operand: operand.convert_to_c(), }, }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> expression_ffi = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { Add(_, _) =&gt; ExpressionFfi { expression_type: ExpressionType::Add, data: expression_data, }, Subtract(_, _) =&gt; ExpressionFfi { expression_type: ExpressionType::Subtract, data: expression_data, }, Multiply(_, _) =&gt; ExpressionFfi { expression_type: ExpressionType::Multiply, data: expression_data, }, Divide(_, _) =&gt; ExpressionFfi { expression_type: ExpressionType::Multiply, data: expression_data, }, UnaryMinus(_) =&gt; ExpressionFfi { expression_type: ExpressionType::UnaryMinus, data: expression_data, }, Value(_) =&gt; ExpressionFfi { expression_type: ExpressionType::Value, data: expression_data, }, }; <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::into_raw(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(expression_ffi)) } }</code> </pre> <br><p>  <code>Box::into_raw</code> mengubah tipe <code>Box</code> menjadi pointer mentah </p><br><p>  Akibatnya, fungsi yang akan kami ekspor ke PHP terlihat seperti ini: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_arithmetic</span></span></span></span>(s: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c_char) -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> ExpressionFfi { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-comment"><span class="hljs-comment">// todo: error handling let rust_string = CStr::from_ptr(s).to_str().unwrap(); parse(rust_string).unwrap().convert_to_c() } }</span></span></code> </pre> <br><p>  Berikut adalah sekelompok unwrap (), yang berarti "panik untuk kesalahan apa pun."  Dalam kode produksi normal, tentu saja, kesalahan harus ditangani secara normal dan kesalahan dilewatkan sebagai bagian dari kembalinya fungsi-C. </p><br><p>  Nah, di sini kita melihat blok paksa yang tidak aman, tanpanya, tidak ada yang bisa dikompilasi.  Sayangnya, pada titik ini dalam program, compiler Rust tidak dapat bertanggung jawab atas keamanan memori.  Ini bisa dimengerti dan wajar.  Di persimpangan Rust dan C, ini akan selalu terjadi.  Namun, di semua tempat lain semuanya benar-benar terkontrol dan aman. </p><br><p>  Fuf, sepertinya semuanya bisa dikompilasi.  Tetapi sebenarnya ada satu nuansa lagi: Anda masih perlu menulis konstruksi header agar PHP memahami tanda tangan fungsi dan tipe. </p><br><p>  Untungnya, Rast memiliki alat cbindgen yang nyaman.  Secara otomatis mencari dalam kode Rast untuk konstruksi yang diberi label extern "C", repr (C), dll.  dan menghasilkan file header </p><br><p>  Saya harus menderita sedikit dengan pengaturan cbindgen, mereka ternyata seperti ini ( <a href="">cbindgen.toml</a> ): </p><br><pre> <code class="plaintext hljs">language = "C" no_includes = true style="tag" [parse] parse_deps = true</code> </pre> <br><p>  Saya tidak yakin bahwa saya mengerti dengan jelas semua nuansa, tetapi berhasil) </p><br><p>  Contoh Peluncuran: </p><br><pre> <code class="plaintext hljs">cbindgen . -o target/testffi.h</code> </pre> <br><p>  Hasilnya akan seperti ini: </p><br><pre> <code class="plaintext hljs">enum ExpressionType { Add = 0, Subtract = 1, Multiply = 2, Divide = 3, UnaryMinus = 4, Value = 5, }; typedef uint8_t ExpressionType; struct PairOperands { struct ExpressionFfi *left; struct ExpressionFfi *right; }; union ExpressionData { struct PairOperands pair_operands; struct ExpressionFfi *single_operand; int64_t value; }; struct ExpressionFfi { ExpressionType expression_type; union ExpressionData data; }; struct ExpressionFfi *parse_arithmetic(const char *s);</code> </pre> <br><p>  Jadi, kami membuat file-h, mengkompilasi pustaka <code>cargo build</code> dan Anda dapat menulis kode php kami.  Kode hanya menampilkan apa yang diuraikan oleh perpustakaan Rust kami di layar dengan fungsi rekursi printExpression. </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $cdef = \FFI::cdef(file_get_contents(<span class="hljs-string"><span class="hljs-string">"target/testffi.h"</span></span>), <span class="hljs-string"><span class="hljs-string">"target/debug/libexpr_parser.so"</span></span>); $expression = $cdef-&gt;parse_arithmetic(<span class="hljs-string"><span class="hljs-string">"-6-(4+5)+(5+5)*(4-4)"</span></span>); printExpression($expression); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpressionKind</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Add = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Subtract = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Multiply = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Divide = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UnaryMinus = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Value = <span class="hljs-number"><span class="hljs-number">5</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printExpression</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($expression)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> ($expression-&gt;expression_type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ExpressionKind::Add: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ExpressionKind::Subtract: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ExpressionKind::Multiply: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ExpressionKind::Divide: $operations = [<span class="hljs-string"><span class="hljs-string">"+"</span></span>, <span class="hljs-string"><span class="hljs-string">"-"</span></span>, <span class="hljs-string"><span class="hljs-string">"*"</span></span>, <span class="hljs-string"><span class="hljs-string">"/"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"("</span></span>; printExpression($expression-&gt;data-&gt;pair_operands-&gt;left); <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $operations[$expression-&gt;expression_type]; printExpression($expression-&gt;data-&gt;pair_operands-&gt;right); <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">")"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ExpressionKind::UnaryMinus: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"-"</span></span>; printExpression($expression-&gt;data-&gt;single_operand); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ExpressionKind::Value: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $expression-&gt;data-&gt;value; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><p>  Yah, itu dia, terima kasih sudah menonton. </p><br><p>  Persetan ada "segalanya."  Memori masih perlu dibersihkan.  Rast tidak dapat menerapkan sihirnya di luar kode Rast. </p><br><p>  Tambahkan fungsi penghancuran lainnya </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">destroy</span></span></span></span>(expression: *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> ExpressionFfi) { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> (*expression).expression_type { ExpressionType::Add | ExpressionType::Subtract | ExpressionType::Multiply | ExpressionType::Divide =&gt; { destroy((*expression).data.pair_operands.right); destroy((*expression).data.pair_operands.left); <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::from_raw(expression); } ExpressionType::UnaryMinus =&gt; { destroy((*expression).data.single_operand); <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::from_raw(expression); } ExpressionType::Value =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::from_raw(expression); } }; } }</code> </pre> <br><p> <code>Box::from_raw(expression);</code>  - Mengonversi penunjuk mentah ke jenis Kotak, dan karena hasil konversi ini tidak digunakan oleh siapa pun, memori secara otomatis dihancurkan ketika Anda keluar dari ruang lingkup. </p><br><p>  Jangan lupa untuk membuat dan menghasilkan file header. </p><br><p>  dan di php kita menambahkan panggilan ke fungsi kita </p><br><pre> <code class="plaintext hljs">$cdef-&gt;destroy($expression);</code> </pre> <br><p>  Nah, itu saja.  Jika Anda ingin menambahkan atau memberi tahu bahwa saya salah, silakan berkomentar. </p><br><p>  Repositori dengan contoh lengkap terdapat di tautan: [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/anton-okolelov/simple-rust-arithmetic-parser</a> ] </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># build docker-compose build docker-compose run php74 cargo build docker-compose run php74 cbindgen . -o target/testffi.h #run php docker-compose run php74 php testffi.php</span></span></code> </pre> <br><p>  NB. Kita akan membahas ini dalam edisi berikutnya podcast <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Zinc Prod</a> , jadi pastikan untuk berlangganan podcast. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455614/">https://habr.com/ru/post/id455614/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455604/index.html">Dimungkinkan untuk mengelola konfigurasi Windows. Kisah sukses</a></li>
<li><a href="../id455606/index.html">Pembelajaran Mesin dan Analisis Data: Program Master di Sekolah Tinggi Ekonomi di St. Petersburg</a></li>
<li><a href="../id455608/index.html">Indeks Bitmap di Go: kecepatan pencarian yang luar biasa</a></li>
<li><a href="../id455610/index.html">Intel Core i7-2600K Legendaris: menguji Sandy Bridge pada 2019 (bagian 1)</a></li>
<li><a href="../id455612/index.html">Kami memikirkan karakter permainan dan dialog berdasarkan saran dari penulis dan pada contoh pendukung teori Bumi yang datar</a></li>
<li><a href="../id455616/index.html">Mengapa pergi ke "Pemrograman Industri" di HSE St. Petersburg?</a></li>
<li><a href="../id455618/index.html">DevOps LEGO: bagaimana kami meletakkan pipa di atas kubus</a></li>
<li><a href="../id455620/index.html">BISA atau tidak BISA? Atau mengapa saya membutuhkan jaringan mikrokontroler?</a></li>
<li><a href="../id455622/index.html">Intel Core i7-2600K yang legendaris: menguji Sandy Bridge pada 2019 (bagian 2)</a></li>
<li><a href="../id455624/index.html">Korban hiper dan apa yang bisa dipelajari oleh perancang permainan dari mereka</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>