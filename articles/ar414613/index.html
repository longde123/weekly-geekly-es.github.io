<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚴🏼 👩🏾‍🤝‍👩🏼 🍠 Kaggle Home Credit منافسة المخاطر الافتراضية - تحليل البيانات والنماذج التنبؤية البسيطة 👲🏻 👩🏽‍⚕️ 👉🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="في مهرجان البيانات 2 في مينسك ، لاحظ فلاديمير إيغلوفيكوف ، مهندس الرؤية الآلية في Lyft ، تمامًا أن أفضل طريقة لتعلم علوم البيانات هي المشاركة في المسا...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kaggle Home Credit منافسة المخاطر الافتراضية - تحليل البيانات والنماذج التنبؤية البسيطة</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414613/" style=";text-align:right;direction:rtl">  في مهرجان البيانات 2 في مينسك ، لاحظ فلاديمير إيغلوفيكوف ، مهندس الرؤية الآلية في Lyft ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تمامًا</a> أن أفضل طريقة لتعلم علوم البيانات هي المشاركة في المسابقات ، وتشغيل حلول الآخرين ، ودمجها ، وتحقيق النتائج وإظهار عملك.  في الواقع ، في إطار هذا النموذج ، قررت أن أنظر عن كثب في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مسابقة</a> تقييم مخاطر الائتمان الرئيسية وأشرح (للمبتدئين والعلماء وقبل كل شيء بنفسي) كيفية تحليل مجموعات البيانات هذه بشكل صحيح وبناء نماذج لهم. <br><br><img src="https://habrastorage.org/webt/iv/ji/-t/ivji-tusvam8d05dqef8wjbmbye.png"><br><a name="habracut"></a><br>  (صورة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">من هنا</a> ) <br><br><img src="https://habrastorage.org/webt/xc/er/pe/xcerpefrjvrblmubhxyeljevcie.png" width="250" align="right">  مجموعة الائتمان الرئيسية هي مجموعة من البنوك والمنظمات الائتمانية غير المصرفية التي تجري عمليات في 11 دولة (بما في ذلك روسيا كبنك الائتمان والتمويل المنزلي ذ.م.م).  الغرض من المسابقة هو إنشاء منهجية لتقييم الجدارة الائتمانية للمقترضين الذين ليس لديهم تاريخ ائتماني.  وهو ما يبدو نبيلًا إلى حد ما - غالبًا ما لا يتمكن المقترضون من هذه الفئة من الحصول على أي ائتمان من البنك ويضطرون إلى اللجوء إلى المحتالين والقروض الصغيرة.  من المثير للاهتمام أن العميل لم يحدد متطلبات الشفافية وقابلية تفسير النموذج (كما هو الحال عادة مع البنوك) ، يمكنك استخدام أي شيء ، حتى الشبكة العصبية. <br><br>  تتكون عينة التدريب من أكثر من 300 ألف سجل ، وهناك الكثير من العلامات - 122 ، من بينها العديد من العلامات الفئوية (غير العددية).  تصف اللافتات المقترض بتفاصيل كافية ، وصولاً إلى المواد التي تصنع منها جدران منزله.  جزء من البيانات موجود في 6 جداول إضافية (بيانات عن مكتب الائتمان ورصيد بطاقة الائتمان والقروض السابقة) ، ويجب أيضًا معالجة هذه البيانات بطريقة أو بأخرى وتحميلها على الجداول الرئيسية. <br><br>  تبدو المنافسة كمهمة تصنيف قياسية (1 في حقل TARGET يعني أي صعوبات في الدفع ، 0 يعني عدم وجود صعوبات).  ومع ذلك ، فليس من 0/1 ما ينبغي توقعه ، ولكن احتمالية المشاكل (التي ، بالمناسبة ، يمكن حلها بسهولة من خلال طرق التنبؤ الاحتمالية للتنبؤ بها التي تمتلكها جميع النماذج المعقدة). <br><br>  للوهلة الأولى ، تعد مجموعة البيانات معيارًا جيدًا لمهام التعلم الآلي ، وقد قدم المنظمون جائزة كبيرة بقيمة 70 ألف دولار ، ونتيجة لذلك ، يشارك أكثر من 2600 فريق في المسابقة اليوم ، والمعركة في الألف من المئة.  ومع ذلك ، من ناحية أخرى ، تعني هذه الشعبية أن مجموعة البيانات قد تمت دراستها صعودًا وهبوطًا وتم إنشاء العديد من النوى باستخدام EDA جيد (تحليلات البيانات الاستكشافية - البحث وتحليل البيانات في الشبكة ، بما في ذلك الرسوم البيانية) ، هندسة الميزات (العمل مع السمات) ومع نماذج مثيرة للاهتمام.  (Kernel هو مثال على العمل مع مجموعة بيانات يمكن لأي شخص وضعها لعرض عملهم على kugglers الآخرين.) <br><br>  تستحق الألباب الاهتمام: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">EDA مع وصف مفصل للمبتدئين والنماذج البسيطة</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">EDA العميق مع حزمة Plotly + تحميل بيانات المكتب</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">إيدا لطيفة مع حزمة سيبورن</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تحليل مقارن للمشكلة والمقترضين المتعثرين</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">15 سطر LightGBM على ثلاث لافتات بسرعة أخيرة 0.714</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تحليل اللافتات بحسب مكاتب الائتمان</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">إضافة معالجة.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">طاولات + LightGBM</a> </li></ul><br>  للعمل مع البيانات ، يوصى عادةً بالخطة التالية ، والتي سنحاول اتباعها. <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  فهم المشكلة والتعرف على البيانات </li><li style=";text-align:right;direction:rtl">  تنظيف وتنسيق البيانات </li><li style=";text-align:right;direction:rtl">  جمعية الإمارات للغوص </li><li style=";text-align:right;direction:rtl">  نموذج أساسي </li><li style=";text-align:right;direction:rtl">  تحسين النموذج </li><li style=";text-align:right;direction:rtl">  تفسير النموذج </li></ol><br>  في هذه الحالة ، يجب أن تأخذ في الاعتبار حقيقة أن البيانات واسعة جدًا ولا يمكن التغلب عليها على الفور ، فمن المنطقي التصرف على مراحل. <br><br>  لنبدأ باستيراد المكتبات التي نحتاجها في التحليل للعمل مع البيانات في شكل جداول ، وإنشاء الرسوم البيانية ، والعمل مع المصفوفات. <br><br><pre style=";text-align:right;direction:rtl"><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> seaborn <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> sns %matplotlib inline</code> </pre> <br>  قم بتنزيل البيانات.  دعونا نرى ما لدينا جميعا.  بالمناسبة ، هذا الموقع في دليل "../input/" مرتبط بمتطلبات وضع حباتك على Kaggle. <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os PATH=<span class="hljs-string"><span class="hljs-string">"../input/"</span></span> print(os.listdir(PATH))</code> </pre> <br> <code>['application_test.csv', 'application_train.csv', 'bureau.csv', 'bureau_balance.csv', 'credit_card_balance.csv', 'HomeCredit_columns_description.csv', 'installments_payments.csv', 'POS_CASH_balance.csv', 'previous_application.csv']</code> <br> <br>  هناك 8 جداول بالبيانات (لا تحسب الجدول HomeCredit_columns_description.csv ، الذي يحتوي على وصف للحقول) ، وهي مترابطة فيما يلي: <br><br><img src="https://habrastorage.org/webt/vn/yr/84/vnyr84vhzozgnfinu2to2tyhlp8.png"><br><br>  application_train / application_test: بيانات رئيسية ، يتم تحديد المقترض بواسطة الحقل SK_ID_CURR <br>  المكتب: بيانات القروض السابقة من مؤسسات ائتمانية أخرى من مكتب ائتمان <br>  bureau_balance: بيانات شهرية عن قروض المكتب السابقة.  كل سطر هو شهر استخدام القرض <br>  previous_application: التطبيقات السابقة للحصول على قروض في الائتمان المنزلي ، لكل منها حقل فريد SK_ID_PREV <br>  POS_CASH_BALANCE: بيانات شهرية عن القروض في الائتمان السكني مع إصدار النقد والقروض لشراء السلع <br>  credit_card_balance: بيانات رصيد بطاقة الائتمان الشهرية في رصيد المنزل <br>  الأقساط: تاريخ السداد للقروض السابقة في الائتمان المنزلي. <br><br>  دعونا نركز أولاً على مصدر البيانات الرئيسي ونرى ما هي المعلومات التي يمكن استخلاصها منها والنماذج التي نبنيها.  قم بتنزيل البيانات الأساسية. <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  app_train = pd.read_csv (PATH + 'application_train.csv'،) </li><li style=";text-align:right;direction:rtl">  app_test = pd.read_csv (PATH + 'application_test.csv'،) </li><li style=";text-align:right;direction:rtl">  print ("تنسيق مجموعة التدريب:"، app_train.shape) </li><li style=";text-align:right;direction:rtl">  طباعة ("تنسيق عينة الاختبار:" ، app_test.shape) </li><li style=";text-align:right;direction:rtl">  شكل عينة التدريب: (307511 ، 122) </li><li style=";text-align:right;direction:rtl">  تنسيق عينة الاختبار: (48744 ، 121) </li></ul><br>  في المجموع ، لدينا 307 آلاف سجل و 122 علامة في عينة التدريب و 49 ألف سجل و 121 علامة في الاختبار.  من الواضح أن التناقض يرجع إلى حقيقة أنه لا توجد سمة الهدف TARGET في عينة الاختبار ، وسوف نتوقع ذلك. <br><br>  دعونا نلقي نظرة فاحصة على البيانات <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">pd.set_option(<span class="hljs-string"><span class="hljs-string">'display.max_columns'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>) <span class="hljs-comment"><span class="hljs-comment">#  pandas     app_train.head()</span></span></code> </pre> <br><br><img src="https://habrastorage.org/webt/xo/yc/rg/xoycrgiodfhonfrjbt50ncthrls.png"><br>  (أول 8 أعمدة معروضة) <br><br>  من الصعب جدًا مشاهدة البيانات بهذا التنسيق.  دعونا نلقي نظرة على قائمة الأعمدة: <br><br> <code>app_train.info(max_cols=122) <br> &lt;class 'pandas.core.frame.DataFrame'&gt; <br> RangeIndex: 307511 entries, 0 to 307510 <br> Data columns (total 122 columns): <br> SK_ID_CURR 307511 non-null int64 <br> TARGET 307511 non-null int64 <br> NAME_CONTRACT_TYPE 307511 non-null object <br> CODE_GENDER 307511 non-null object <br> FLAG_OWN_CAR 307511 non-null object <br> FLAG_OWN_REALTY 307511 non-null object <br> CNT_CHILDREN 307511 non-null int64 <br> AMT_INCOME_TOTAL 307511 non-null float64 <br> AMT_CREDIT 307511 non-null float64 <br> AMT_ANNUITY 307499 non-null float64 <br> AMT_GOODS_PRICE 307233 non-null float64 <br> NAME_TYPE_SUITE 306219 non-null object <br> NAME_INCOME_TYPE 307511 non-null object <br> NAME_EDUCATION_TYPE 307511 non-null object <br> NAME_FAMILY_STATUS 307511 non-null object <br> NAME_HOUSING_TYPE 307511 non-null object <br> REGION_POPULATION_RELATIVE 307511 non-null float64 <br> DAYS_BIRTH 307511 non-null int64 <br> DAYS_EMPLOYED 307511 non-null int64 <br> DAYS_REGISTRATION 307511 non-null float64 <br> DAYS_ID_PUBLISH 307511 non-null int64 <br> OWN_CAR_AGE 104582 non-null float64 <br> FLAG_MOBIL 307511 non-null int64 <br> FLAG_EMP_PHONE 307511 non-null int64 <br> FLAG_WORK_PHONE 307511 non-null int64 <br> FLAG_CONT_MOBILE 307511 non-null int64 <br> FLAG_PHONE 307511 non-null int64 <br> FLAG_EMAIL 307511 non-null int64 <br> OCCUPATION_TYPE 211120 non-null object <br> CNT_FAM_MEMBERS 307509 non-null float64 <br> REGION_RATING_CLIENT 307511 non-null int64 <br> REGION_RATING_CLIENT_W_CITY 307511 non-null int64 <br> WEEKDAY_APPR_PROCESS_START 307511 non-null object <br> HOUR_APPR_PROCESS_START 307511 non-null int64 <br> REG_REGION_NOT_LIVE_REGION 307511 non-null int64 <br> REG_REGION_NOT_WORK_REGION 307511 non-null int64 <br> LIVE_REGION_NOT_WORK_REGION 307511 non-null int64 <br> REG_CITY_NOT_LIVE_CITY 307511 non-null int64 <br> REG_CITY_NOT_WORK_CITY 307511 non-null int64 <br> LIVE_CITY_NOT_WORK_CITY 307511 non-null int64 <br> ORGANIZATION_TYPE 307511 non-null object <br> EXT_SOURCE_1 134133 non-null float64 <br> EXT_SOURCE_2 306851 non-null float64 <br> EXT_SOURCE_3 246546 non-null float64 <br> APARTMENTS_AVG 151450 non-null float64 <br> BASEMENTAREA_AVG 127568 non-null float64 <br> YEARS_BEGINEXPLUATATION_AVG 157504 non-null float64 <br> YEARS_BUILD_AVG 103023 non-null float64 <br> COMMONAREA_AVG 92646 non-null float64 <br> ELEVATORS_AVG 143620 non-null float64 <br> ENTRANCES_AVG 152683 non-null float64 <br> FLOORSMAX_AVG 154491 non-null float64 <br> FLOORSMIN_AVG 98869 non-null float64 <br> LANDAREA_AVG 124921 non-null float64 <br> LIVINGAPARTMENTS_AVG 97312 non-null float64 <br> LIVINGAREA_AVG 153161 non-null float64 <br> NONLIVINGAPARTMENTS_AVG 93997 non-null float64 <br> NONLIVINGAREA_AVG 137829 non-null float64 <br> APARTMENTS_MODE 151450 non-null float64 <br> BASEMENTAREA_MODE 127568 non-null float64 <br> YEARS_BEGINEXPLUATATION_MODE 157504 non-null float64 <br> YEARS_BUILD_MODE 103023 non-null float64 <br> COMMONAREA_MODE 92646 non-null float64 <br> ELEVATORS_MODE 143620 non-null float64 <br> ENTRANCES_MODE 152683 non-null float64 <br> FLOORSMAX_MODE 154491 non-null float64 <br> FLOORSMIN_MODE 98869 non-null float64 <br> LANDAREA_MODE 124921 non-null float64 <br> LIVINGAPARTMENTS_MODE 97312 non-null float64 <br> LIVINGAREA_MODE 153161 non-null float64 <br> NONLIVINGAPARTMENTS_MODE 93997 non-null float64 <br> NONLIVINGAREA_MODE 137829 non-null float64 <br> APARTMENTS_MEDI 151450 non-null float64 <br> BASEMENTAREA_MEDI 127568 non-null float64 <br> YEARS_BEGINEXPLUATATION_MEDI 157504 non-null float64 <br> YEARS_BUILD_MEDI 103023 non-null float64 <br> COMMONAREA_MEDI 92646 non-null float64 <br> ELEVATORS_MEDI 143620 non-null float64 <br> ENTRANCES_MEDI 152683 non-null float64 <br> FLOORSMAX_MEDI 154491 non-null float64 <br> FLOORSMIN_MEDI 98869 non-null float64 <br> LANDAREA_MEDI 124921 non-null float64 <br> LIVINGAPARTMENTS_MEDI 97312 non-null float64 <br> LIVINGAREA_MEDI 153161 non-null float64 <br> NONLIVINGAPARTMENTS_MEDI 93997 non-null float64 <br> NONLIVINGAREA_MEDI 137829 non-null float64 <br> FONDKAPREMONT_MODE 97216 non-null object <br> HOUSETYPE_MODE 153214 non-null object <br> TOTALAREA_MODE 159080 non-null float64 <br> WALLSMATERIAL_MODE 151170 non-null object <br> EMERGENCYSTATE_MODE 161756 non-null object <br> OBS_30_CNT_SOCIAL_CIRCLE 306490 non-null float64 <br> DEF_30_CNT_SOCIAL_CIRCLE 306490 non-null float64 <br> OBS_60_CNT_SOCIAL_CIRCLE 306490 non-null float64 <br> DEF_60_CNT_SOCIAL_CIRCLE 306490 non-null float64 <br> DAYS_LAST_PHONE_CHANGE 307510 non-null float64 <br> FLAG_DOCUMENT_2 307511 non-null int64 <br> FLAG_DOCUMENT_3 307511 non-null int64 <br> FLAG_DOCUMENT_4 307511 non-null int64 <br> FLAG_DOCUMENT_5 307511 non-null int64 <br> FLAG_DOCUMENT_6 307511 non-null int64 <br> FLAG_DOCUMENT_7 307511 non-null int64 <br> FLAG_DOCUMENT_8 307511 non-null int64 <br> FLAG_DOCUMENT_9 307511 non-null int64 <br> FLAG_DOCUMENT_10 307511 non-null int64 <br> FLAG_DOCUMENT_11 307511 non-null int64 <br> FLAG_DOCUMENT_12 307511 non-null int64 <br> FLAG_DOCUMENT_13 307511 non-null int64 <br> FLAG_DOCUMENT_14 307511 non-null int64 <br> FLAG_DOCUMENT_15 307511 non-null int64 <br> FLAG_DOCUMENT_16 307511 non-null int64 <br> FLAG_DOCUMENT_17 307511 non-null int64 <br> FLAG_DOCUMENT_18 307511 non-null int64 <br> FLAG_DOCUMENT_19 307511 non-null int64 <br> FLAG_DOCUMENT_20 307511 non-null int64 <br> FLAG_DOCUMENT_21 307511 non-null int64 <br> AMT_REQ_CREDIT_BUREAU_HOUR 265992 non-null float64 <br> AMT_REQ_CREDIT_BUREAU_DAY 265992 non-null float64 <br> AMT_REQ_CREDIT_BUREAU_WEEK 265992 non-null float64 <br> AMT_REQ_CREDIT_BUREAU_MON 265992 non-null float64 <br> AMT_REQ_CREDIT_BUREAU_QRT 265992 non-null float64 <br> AMT_REQ_CREDIT_BUREAU_YEAR 265992 non-null float64 <br> dtypes: float64(65), int64(41), object(16) <br> memory usage: 286.2+ MB</code> <br> <br>  استرجع التعليقات التوضيحية التفصيلية حسب الحقل في ملف HomeCredit_columns_description.  كما ترى من المعلومات ، جزء من البيانات غير مكتمل وجزء فئوي ، يتم عرضها ككائن.  معظم النماذج لا تعمل مع هذه البيانات ، سيتعين علينا فعل شيء معها.  على هذا ، يمكن اعتبار التحليل الأولي مكتملاً ، وسوف ننتقل مباشرةً إلى جمعية الإمارات للغوص <br><br><h2 style=";text-align:right;direction:rtl">  تحليل البيانات الاستكشافية أو استخراج البيانات الأولية </h2><br>  في عملية EDA ، نحسب الإحصائيات الأساسية ونرسم الرسوم البيانية للعثور على الاتجاهات والشذوذ والأنماط والعلاقات داخل البيانات.  هدف EDA هو معرفة ما يمكن أن تخبره البيانات.  عادة ، ينتقل التحليل من الأعلى إلى الأسفل - من نظرة عامة إلى دراسة المناطق الفردية التي تجذب الانتباه وقد تكون ذات فائدة.  بعد ذلك ، يمكن استخدام هذه النتائج في بناء النموذج ، واختيار الميزات له وتفسيره. <br><br><h3 style=";text-align:right;direction:rtl">  التوزيع المتغير الهدف </h3><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">app_train.TARGET.value_counts()</code> </pre> <br> <code>0 282686 <br> 1 24825 <br> Name: TARGET, dtype: int64</code> <br> <br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">plt.style.use(<span class="hljs-string"><span class="hljs-string">'fivethirtyeight'</span></span>) plt.rcParams[<span class="hljs-string"><span class="hljs-string">"figure.figsize"</span></span>] = [<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>]​ plt.hist(app_train.TARGET) plt.show()</code> </pre> <br><img src="https://habrastorage.org/webt/xm/rd/ch/xmrdchcab8eqbwt2p1pie4jmaeu.png"><br><br>  دعني أذكرك أن 1 تعني مشاكل من أي نوع مع عودة ، 0 لا تعني مشاكل.  كما ترون ، ليس لدى المقترضين بشكل رئيسي أي مشاكل في السداد ، تبلغ حصة الإشكالية حوالي 8 ٪.  هذا يعني أن الفصول غير متوازنة وقد يلزم أخذ ذلك في الاعتبار عند بناء النموذج. <br><br><h3 style=";text-align:right;direction:rtl">  البحث عن البيانات المفقودة </h3><br>  لقد رأينا أن نقص البيانات كبير للغاية.  دعونا نرى بمزيد من التفصيل أين وماذا ينقص. <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      def missing_values_table(df): #   mis_val = df.isnull().sum() #    mis_val_percent = 100 * df.isnull().sum() / len(df) #    mis_val_table = pd.concat([mis_val, mis_val_percent], axis=1) #   mis_val_table_ren_columns = mis_val_table.rename( columns = {0 : 'Missing Values', 1 : '% of Total Values'}) #    mis_val_table_ren_columns = mis_val_table_ren_columns[ mis_val_table_ren_columns.iloc[:,1] != 0].sort_values( '% of Total Values', ascending=False).round(1) #  print ("   " + str(df.shape[1]) + " .\n" " " + str(mis_val_table_ren_columns.shape[0]) + "    .") #     return mis_val_table_ren_columns missing_values = missing_values_table(app_train) missing_values.head(10)</span></span></code> </pre> <br><br> <code>   122 . <br>  67    .</code> <br> <img src="https://habrastorage.org/webt/oa/jm/tp/oajmtpuvkymt4asczwqmhqziria.png"><br><br>  بتنسيق رسومي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">plt.style.use(<span class="hljs-string"><span class="hljs-string">'seaborn-talk'</span></span>)​ fig = plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">18</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>)) miss_train = pd.DataFrame((app_train.isnull().sum())*<span class="hljs-number"><span class="hljs-number">100</span></span>/app_train.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>]).reset_index() miss_test = pd.DataFrame((app_test.isnull().sum())*<span class="hljs-number"><span class="hljs-number">100</span></span>/app_test.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>]).reset_index() miss_train[<span class="hljs-string"><span class="hljs-string">"type"</span></span>] = <span class="hljs-string"><span class="hljs-string">""</span></span> miss_test[<span class="hljs-string"><span class="hljs-string">"type"</span></span>] = <span class="hljs-string"><span class="hljs-string">""</span></span> missing = pd.concat([miss_train,miss_test],axis=<span class="hljs-number"><span class="hljs-number">0</span></span>) ax = sns.pointplot(<span class="hljs-string"><span class="hljs-string">"index"</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,data=missing,hue=<span class="hljs-string"><span class="hljs-string">"type"</span></span>) plt.xticks(rotation =<span class="hljs-number"><span class="hljs-number">90</span></span>,fontsize =<span class="hljs-number"><span class="hljs-number">7</span></span>) plt.title(<span class="hljs-string"><span class="hljs-string">"    "</span></span>) plt.ylabel(<span class="hljs-string"><span class="hljs-string">"  %"</span></span>) plt.xlabel(<span class="hljs-string"><span class="hljs-string">""</span></span>)</code> </pre> <br><br><img src="https://habrastorage.org/webt/iv/fc/ib/ivfcibv85aaktlxybl8bps2vurw.png"><br><br>  هناك العديد من الإجابات على السؤال "ماذا تفعل بكل هذا".  يمكنك ملئه بالأصفار ، يمكنك استخدام القيم المتوسطة ، يمكنك فقط حذف الأسطر بدون المعلومات الضرورية.  كل هذا يتوقف على النموذج الذي نخطط لاستخدامه ، حيث يتعامل بعضها بشكل مثالي مع القيم المفقودة.  بينما نتذكر هذه الحقيقة ونترك كل شيء كما هو. <br><br><h3 style=";text-align:right;direction:rtl">  أنواع الأعمدة والترميز القاطع </h3><br>  كما نتذكر.  جزء من الأعمدة من نوع الكائن ، أي أنه ليس له قيمة عددية ، ولكنه يعكس بعض الفئات.  دعونا نلقي نظرة على هذه الأعمدة عن كثب. <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">app_train.dtypes.value_counts()</code> </pre> <br> <code>float64 65 <br> int64 41 <br> object 16 <br> dtype: int64</code> <br> <br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">app_train.select_dtypes(include=[object]).apply(pd.Series.nunique, axis = <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br> <code>NAME_CONTRACT_TYPE 2 <br> CODE_GENDER 3 <br> FLAG_OWN_CAR 2 <br> FLAG_OWN_REALTY 2 <br> NAME_TYPE_SUITE 7 <br> NAME_INCOME_TYPE 8 <br> NAME_EDUCATION_TYPE 5 <br> NAME_FAMILY_STATUS 6 <br> NAME_HOUSING_TYPE 6 <br> OCCUPATION_TYPE 18 <br> WEEKDAY_APPR_PROCESS_START 7 <br> ORGANIZATION_TYPE 58 <br> FONDKAPREMONT_MODE 4 <br> HOUSETYPE_MODE 3 <br> WALLSMATERIAL_MODE 7 <br> EMERGENCYSTATE_MODE 2 <br> dtype: int64</code> <br> <br>  لدينا 16 عمودًا ، لكل منها 2 إلى 58 خيارًا مختلفًا للقيمة.  بشكل عام ، لا يمكن لنماذج تعلُّم الآلة أن تفعل أي شيء مع هذه الأعمدة (باستثناء البعض ، مثل LightGBM أو CatBoost).  نظرًا لأننا نخطط لتجربة نماذج مختلفة في مجموعة البيانات ، فلا بد من عمل شيء ما بهذا.  هناك نهجان في الأساس: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  ترميز التسمية - يتم تعيين الفئات للأرقام 0 و 1 و 2 وما إلى ذلك ويتم كتابتها في نفس العمود </li><li style=";text-align:right;direction:rtl">  ترميز واحد ساخن - يتحلل عمود واحد إلى عدة وفقا لعدد الخيارات وتشير هذه الأعمدة إلى الخيار الذي يحتويه هذا السجل. </li></ul><br>  من بين <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الأنواع</a> الشائعة ، تجدر الإشارة إلى <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ترميز الهدف المتوسط</a> (شكرًا للتوضيح <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">roryorangepants</a> ). <br><br>  هناك مشكلة صغيرة في Label Encoding - فهو يعين القيم العددية التي لا علاقة لها بالواقع.  على سبيل المثال ، إذا كنا نتعامل مع قيمة عددية ، فإن دخل المقترض البالغ 100000 بالتأكيد أكبر وأفضل من دخل 20000. ولكن يمكننا القول ، على سبيل المثال ، أن مدينة واحدة أفضل من أخرى لأنه تم تعيين القيمة 100 والآخر 200 ؟؟؟ <br><br>  من ناحية أخرى ، يعد ترميز One-Hot أكثر أمانًا ، ولكن يمكنه إنتاج أعمدة "إضافية".  على سبيل المثال ، إذا قمنا بتشفير نفس الجنس باستخدام One-Hot ، نحصل على عمودين ، "جنس الذكور" و "جنس الإناث" ، على الرغم من أن أحد الأعمدة سيكون كافيًا ، "هل هو ذكر". <br><br>  للحصول على مجموعة بيانات جيدة ، سيكون من الضروري ترميز العلامات ذات التباين المنخفض باستخدام ترميز التسمية وكل شيء آخر - One-Hot ، ولكن من أجل البساطة ، نقوم بترميز كل شيء وفقًا لـ One-Hot.  لن تؤثر عمليًا على سرعة الحساب والنتيجة.  عملية ترميز الباندا نفسها بسيطة للغاية. <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">app_train = pd.get_dummies(app_train) app_test = pd.get_dummies(app_test)​ print(<span class="hljs-string"><span class="hljs-string">'Training Features shape: '</span></span>, app_train.shape) print(<span class="hljs-string"><span class="hljs-string">'Testing Features shape: '</span></span>, app_test.shape)</code> </pre> <br> <code>Training Features shape: (307511, 246) <br> Testing Features shape: (48744, 242)</code> <br> <br>  نظرًا لأن عدد الخيارات في أعمدة التحديد غير متساوٍ ، فإن عدد الأعمدة لا يتطابق الآن.  المحاذاة مطلوبة - تحتاج إلى إزالة الأعمدة من مجموعة التدريب غير الموجودة في مجموعة الاختبار.  هذا يجعل طريقة المحاذاة ، تحتاج إلى تحديد المحور = 1 (للأعمدة). <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ,           . train_labels = app_train['TARGET']​ #  -   .     app_train, app_test = app_train.align(app_test, join = 'inner', axis = 1)​ print('  : ', app_train.shape) print('  : ', app_test.shape)​ # Add target back in to the data app_train['TARGET'] = train_labels</span></span></code> </pre> <br> <code>  : (307511, 242) <br>   : (48744, 242)</code> <br> <br><h3 style=";text-align:right;direction:rtl">  ارتباط البيانات </h3><br>  طريقة جيدة لفهم البيانات هي حساب معاملات ارتباط بيرسون للبيانات المتعلقة بالسمة الهدف.  هذه ليست أفضل طريقة لإظهار مدى صلة الميزات ، ولكنها بسيطة وتسمح لك بالحصول على فكرة عن البيانات.  يمكن تفسير المعاملات على النحو التالي: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  00 -19 "ضعيف جدًا" </li><li style=";text-align:right;direction:rtl">  20 -39 "ضعيف" </li><li style=";text-align:right;direction:rtl">  40-59 "متوسط" </li><li style=";text-align:right;direction:rtl">  60 -79 قوية </li><li style=";text-align:right;direction:rtl">  80-1.0 "قوي جدا" </li></ul><br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    correlations = app_train.corr()['TARGET'].sort_values()​ #  print('  : \n', correlations.tail(15)) print('\n  : \n', correlations.head(15))</span></span></code> </pre> <br> <code>  : <br> DAYS_REGISTRATION 0.041975 <br> OCCUPATION_TYPE_Laborers 0.043019 <br> FLAG_DOCUMENT_3 0.044346 <br> REG_CITY_NOT_LIVE_CITY 0.044395 <br> FLAG_EMP_PHONE 0.045982 <br> NAME_EDUCATION_TYPE_Secondary / secondary special 0.049824 <br> REG_CITY_NOT_WORK_CITY 0.050994 <br> DAYS_ID_PUBLISH 0.051457 <br> CODE_GENDER_M 0.054713 <br> DAYS_LAST_PHONE_CHANGE 0.055218 <br> NAME_INCOME_TYPE_Working 0.057481 <br> REGION_RATING_CLIENT 0.058899 <br> REGION_RATING_CLIENT_W_CITY 0.060893 <br> DAYS_BIRTH 0.078239 <br> TARGET 1.000000 <br> Name: TARGET, dtype: float64 <br> <br>   : <br> EXT_SOURCE_3 -0.178919 <br> EXT_SOURCE_2 -0.160472 <br> EXT_SOURCE_1 -0.155317 <br> NAME_EDUCATION_TYPE_Higher education -0.056593 <br> CODE_GENDER_F -0.054704 <br> NAME_INCOME_TYPE_Pensioner -0.046209 <br> ORGANIZATION_TYPE_XNA -0.045987 <br> DAYS_EMPLOYED -0.044932 <br> FLOORSMAX_AVG -0.044003 <br> FLOORSMAX_MEDI -0.043768 <br> FLOORSMAX_MODE -0.043226 <br> EMERGENCYSTATE_MODE_No -0.042201 <br> HOUSETYPE_MODE_block of flats -0.040594 <br> AMT_GOODS_PRICE -0.039645 <br> REGION_POPULATION_RELATIVE -0.037227 <br> Name: TARGET, dtype: float64</code> <br> <br>  وبالتالي ، فإن جميع البيانات ترتبط ارتباطًا ضعيفًا بالهدف (باستثناء الهدف نفسه ، والذي بالطبع يساوي نفسه).  ومع ذلك ، يتم تمييز العمر وبعض "مصادر البيانات الخارجية" عن البيانات.  ربما هذه بعض البيانات الإضافية من منظمات الائتمان الأخرى.  من المضحك أنه على الرغم من إعلان الهدف على أنه الاستقلال عن هذه البيانات في اتخاذ قرار ائتماني ، إلا أننا في الواقع سنستند إليها في المقام الأول. <br><br><h3 style=";text-align:right;direction:rtl">  العمر </h3><br>  من الواضح أنه كلما كبر العميل ، زاد احتمال العائد (حتى حد معين ، بالطبع).  ولكن لسبب ما ، يشار إلى العمر في الأيام السلبية قبل إصدار القرض ، وبالتالي ، يرتبط ارتباطًا إيجابيًا بعدم السداد (والذي يبدو غريبًا إلى حد ما).  نأتي بها إلى قيمة إيجابية ونلقي نظرة على العلاقة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">app_train[<span class="hljs-string"><span class="hljs-string">'DAYS_BIRTH'</span></span>] = abs(app_train[<span class="hljs-string"><span class="hljs-string">'DAYS_BIRTH'</span></span>]) app_train[<span class="hljs-string"><span class="hljs-string">'DAYS_BIRTH'</span></span>].corr(app_train[<span class="hljs-string"><span class="hljs-string">'TARGET'</span></span>])</code> </pre> <br> <code>-0.078239308309827088</code> <br> <br>  دعونا نلقي نظرة فاحصة على المتغير.  لنبدأ بالرسم البياني. <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#     ,  25  plt.hist(app_train['DAYS_BIRTH'] / 365, edgecolor = 'k', bins = 25) plt.title('Age of Client'); plt.xlabel('Age (years)'); plt.ylabel('Count');</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/v2/zq/1q/v2zq1qolo8rc5wx0tyao4ucygxc.png"><br><br>  قد يقول الرسم البياني للتوزيع نفسه مفيدًا بعض الشيء ، باستثناء أننا لا نرى أي قيم متطرفة وكل شيء يبدو أكثر أو أقل تصديقًا.  لإظهار تأثير تأثير العمر على النتيجة ، يمكننا إنشاء رسم بياني لتقدير كثافة النواة (KDE) - توزيع الكثافة النووية ، مطلية بألوان السمة المستهدفة.  يظهر توزيع متغير واحد ويمكن تفسيره على أنه رسم بياني سلس (محسوب كنواة غوسية لكل نقطة ، والتي يتم حسابها بعد ذلك لتنعيمها). <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># KDE ,   sns.kdeplot(app_train.loc[app_train['TARGET'] == 0, 'DAYS_BIRTH'] / 365, label = 'target == 0')​ # KDE   sns.kdeplot(app_train.loc[app_train['TARGET'] == 1, 'DAYS_BIRTH'] / 365, label = 'target == 1')​ #  plt.xlabel('Age (years)'); plt.ylabel('Density'); plt.title('Distribution of Ages');</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/st/xs/e1/stxse1wipiaqcf0a7trlm0lwz0g.png"><br><br>  كما يتبين ، فإن نسبة التخلف عن السداد أعلى للشباب وتنخفض مع تقدم العمر.  هذا ليس سببا لرفض الائتمان للشباب دائما ، مثل هذه "التوصية" لن تؤدي إلا إلى فقدان الدخل والسوق للبنك.  هذه مناسبة للتفكير في رصد أكثر شمولاً لمثل هذه القروض والتقييم ، وربما حتى نوع من التعليم المالي للمقترضين الشباب. <br><br><h3 style=";text-align:right;direction:rtl">  مصادر خارجية </h3><br>  دعونا نلقي نظرة فاحصة على "مصادر البيانات الخارجية" EXT_SOURCE وارتباطها. <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">ext_data = app_train[[<span class="hljs-string"><span class="hljs-string">'TARGET'</span></span>, <span class="hljs-string"><span class="hljs-string">'EXT_SOURCE_1'</span></span>, <span class="hljs-string"><span class="hljs-string">'EXT_SOURCE_2'</span></span>, <span class="hljs-string"><span class="hljs-string">'EXT_SOURCE_3'</span></span>, <span class="hljs-string"><span class="hljs-string">'DAYS_BIRTH'</span></span>]] ext_data_corrs = ext_data.corr() ext_data_corrs</code> </pre> <br><img src="https://habrastorage.org/webt/5k/ba/fe/5kbafej-y0vvcexlt6iebcjvjbs.png"><br><br>  كما أنه مناسب لعرض الارتباط باستخدام مخطط الحرارة <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">sns.heatmap(ext_data_corrs, cmap = plt.cm.RdYlBu_r, vmin = <span class="hljs-number"><span class="hljs-number">-0.25</span></span>, annot = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, vmax = <span class="hljs-number"><span class="hljs-number">0.6</span></span>) plt.title(<span class="hljs-string"><span class="hljs-string">'Correlation Heatmap'</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/e6/wj/vw/e6wjvwnetgs2y-i65_4okda-6t8.png"><br><br>  كما ترى ، تظهر جميع المصادر علاقة سلبية مع الهدف.  دعونا نلقي نظرة على توزيع كيدي لكل مصدر. <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">plt.figure(figsize = (<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>))​ <span class="hljs-comment"><span class="hljs-comment">#    for i, source in enumerate(['EXT_SOURCE_1', 'EXT_SOURCE_2', 'EXT_SOURCE_3']): #  plt.subplot(3, 1, i + 1) #    sns.kdeplot(app_train.loc[app_train['TARGET'] == 0, source], label = 'target == 0') #    sns.kdeplot(app_train.loc[app_train['TARGET'] == 1, source], label = 'target == 1') #  plt.title('Distribution of %s by Target Value' % source) plt.xlabel('%s' % source); plt.ylabel('Density'); plt.tight_layout(h_pad = 2.5)</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/lf/ig/xm/lfigxmxlck1s4w2uyygfudghajm.png"><br><br>  الصورة مشابهة للتوزيع حسب العمر - مع زيادة المؤشر ، يزداد احتمال عودة القرض.  المصدر الثالث هو الأقوى في هذا الصدد.  على الرغم من أن العلاقة مع المتغير الهدف لا تزال من حيث القيمة المطلقة في الفئة "منخفضة جدًا" ، إلا أن مصادر البيانات الخارجية والعمر ستكون ذات أهمية قصوى في بناء النموذج. <br><br><h3 style=";text-align:right;direction:rtl">  جدول الزوج </h3><br>  لفهم علاقة هذه المتغيرات بشكل أفضل ، يمكنك إنشاء مخطط زوجي ، حيث يمكننا أن نرى علاقة كل زوج ومخطط بياني للتوزيع على طول القطر.  فوق القطر ، يمكنك إظهار مخطط النقاط ، وأدناه - 2d كيدي. <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#       age_data = app_train[['TARGET', 'DAYS_BIRTH']] age_data['YEARS_BIRTH'] = age_data['DAYS_BIRTH'] / 365​ #     plot_data = ext_data.drop(labels = ['DAYS_BIRTH'], axis=1).copy()​ #   plot_data['YEARS_BIRTH'] = age_data['YEARS_BIRTH']​ #         100 .  plot_data = plot_data.dropna().loc[:100000, :]​ #     def corr_func(x, y, **kwargs): r = np.corrcoef(x, y)[0][1] ax = plt.gca() ax.annotate("r = {:.2f}".format(r), xy=(.2, .8), xycoords=ax.transAxes, size = 20)​ #   pairgrid object grid = sns.PairGrid(data = plot_data, size = 3, diag_sharey=False, hue = 'TARGET', vars = [x for x in list(plot_data.columns) if x != 'TARGET'])​ #  -  grid.map_upper(plt.scatter, alpha = 0.2)​ #  -  grid.map_diag(sns.kdeplot)​ #  -   grid.map_lower(sns.kdeplot, cmap = plt.cm.OrRd_r);​ plt.suptitle('Ext Source and Age Features Pairs Plot', size = 32, y = 1.05);</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/wu/bm/ut/wubmutz04p4kwsmmk34gbuoq71g.png"><br><br>  تظهر القروض القابلة للسداد باللون الأزرق وغير قابلة للسداد باللون الأحمر.  إن تفسير كل هذا أمر صعب إلى حد ما ، ولكن يمكن أن تظهر صورة جيدة على قميص أو صورة في متحف للفن الحديث من هذه الصورة. <br><br><h3 style=";text-align:right;direction:rtl">  فحص العلامات الأخرى </h3><br>  دعونا نفكر بمزيد من التفصيل في الميزات الأخرى واعتمادها على المتغير المستهدف.  نظرًا لوجود العديد من الفئات الفئوية (وتمكنا بالفعل من ترميزها) ، نحتاج مرة أخرى إلى البيانات الأولية.  دعنا نسميها بشكل مختلف قليلاً لتجنب الارتباك <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">application_train = pd.read_csv(PATH+<span class="hljs-string"><span class="hljs-string">"application_train.csv"</span></span>) application_test = pd.read_csv(PATH+<span class="hljs-string"><span class="hljs-string">"application_test.csv"</span></span>)</code> </pre> <br>  سنحتاج أيضًا إلى وظيفتين لعرض التوزيعات وتأثيرها على المتغير المستهدف بشكل جميل.  شكرا جزيلا لهم <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">لمؤلف</a> هذه <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">النواة</a> <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plot_stats</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(feature,label_rotation=False,horizontal_layout=True)</span></span></span><span class="hljs-function">:</span></span> temp = application_train[feature].value_counts() df1 = pd.DataFrame({feature: temp.index,<span class="hljs-string"><span class="hljs-string">' '</span></span>: temp.values})​ <span class="hljs-comment"><span class="hljs-comment">#   target=1   cat_perc = application_train[[feature, 'TARGET']].groupby([feature],as_index=False).mean() cat_perc.sort_values(by='TARGET', ascending=False, inplace=True) if(horizontal_layout): fig, (ax1, ax2) = plt.subplots(ncols=2, figsize=(12,6)) else: fig, (ax1, ax2) = plt.subplots(nrows=2, figsize=(12,14)) sns.set_color_codes("pastel") s = sns.barplot(ax=ax1, x = feature, y=" ",data=df1) if(label_rotation): s.set_xticklabels(s.get_xticklabels(),rotation=90) s = sns.barplot(ax=ax2, x = feature, y='TARGET', order=cat_perc[feature], data=cat_perc) if(label_rotation): s.set_xticklabels(s.get_xticklabels(),rotation=90) plt.ylabel(' ', fontsize=10) plt.tick_params(axis='both', which='major', labelsize=10)​ plt.show();</span></span></code> </pre> <br>  لذا ، سننظر في العلامات الرئيسية للعملاء <br><br><h3 style=";text-align:right;direction:rtl">  نوع القرض </h3><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">plot_stats(<span class="hljs-string"><span class="hljs-string">'NAME_CONTRACT_TYPE'</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/gf/xr/hd/gfxrhdfhqe7zyvlvwjmtgg-opam.png"><br><br>  ومن المثير للاهتمام أن القروض المتجددة (على الأرجح السحب على المكشوف أو شيء من هذا القبيل) تشكل أقل من 10٪ من إجمالي عدد القروض.  وفي الوقت نفسه ، فإن نسبة عدم العودة بينهم أعلى بكثير.  سبب وجيه لمراجعة منهجية العمل مع هذه القروض ، وربما حتى التخلي عنها. <br><br><h3 style=";text-align:right;direction:rtl">  جنس العميل </h3><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">plot_stats(<span class="hljs-string"><span class="hljs-string">'CODE_GENDER'</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/fj/vu/eu/fjvueuchpemqvpmijfzsslyiy5m.png"><br><br>  هناك ما يقرب من ضعف عدد العملاء من النساء ، حيث يظهر الرجال خطرًا أكبر بكثير. <br><br><h3 style=";text-align:right;direction:rtl">  ملكية السيارة والممتلكات </h3><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">plot_stats(<span class="hljs-string"><span class="hljs-string">'FLAG_OWN_CAR'</span></span>) plot_stats(<span class="hljs-string"><span class="hljs-string">'FLAG_OWN_REALTY'</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/l4/iv/u4/l4ivu4-yhdkdma8yjrnhj07evdq.png"><br><img src="https://habrastorage.org/webt/fg/qn/2-/fgqn2-3qqhjvkbovec9zm_qkfgo.png"><br><br>  عملاء السيارة هم نصف "بلا حصان".  الخطر هو نفسه تقريبًا ، يدفع العملاء الذين لديهم الماكينة أفضل قليلاً. <br><br>  بالنسبة للعقار ، فإن العكس هو الصحيح - هناك نصف عدد قليل من العملاء بدونه.  كما أن الخطر على مالكي العقارات أقل بقليل. <br><br><h3 style=";text-align:right;direction:rtl">  الحالة الزوجية </h3><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">plot_stats(<span class="hljs-string"><span class="hljs-string">'NAME_FAMILY_STATUS'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/7u/qt/t1/7uqtt10kghqs01w-_y_1e6vx2jw.png"><br><br>  في حين أن معظم العملاء متزوجون ، فإن الأكثر خطورة هم العملاء المدنيون والعزاب.  يظهر الأرامل الحد الأدنى من المخاطر. <br><br><h3 style=";text-align:right;direction:rtl">  عدد الاطفال </h3><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">plot_stats(<span class="hljs-string"><span class="hljs-string">'CNT_CHILDREN'</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/5s/ux/o8/5suxo8vh8yl68pnxqf4vm7c-ixa.png"><br><br>  معظم العملاء بلا أطفال.  في الوقت نفسه ، يُظهر العملاء الذين لديهم 9 و 11 طفلاً عدم استرداد الأموال بالكامل <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">application_train.CNT_CHILDREN.value_counts()</code> </pre> <br> <code>0 215371 <br> 1 61119 <br> 2 26749 <br> 3 3717 <br> 4 429 <br> 5 84 <br> 6 21 <br> 7 7 <br> 14 3 <br> 19 2 <br> 12 2 <br> 10 2 <br> 9 2 <br> 8 2 <br> 11 1 <br> Name: CNT_CHILDREN, dtype: int64</code> <br> <br>  كما يظهر حساب القيم ، فإن هذه البيانات غير مهمة إحصائيًا - فقط عميلان من الفئتين.  ومع ذلك ، فقد عجز الثلاثة عن العمل ، كما فعل نصف العملاء الذين لديهم 6 أطفال. <br><br><h3 style=";text-align:right;direction:rtl">  عدد أفراد الأسرة </h3><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">plot_stats(<span class="hljs-string"><span class="hljs-string">'CNT_FAM_MEMBERS'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/bw/tg/sc/bwtgsctk9vk_y8tcx9bv9fraogu.png"><br><br>  الوضع مشابه - كلما قل عدد الأفواه ، كلما زاد العائد. <br><br><h3 style=";text-align:right;direction:rtl">  نوع الدخل </h3><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">plot_stats(<span class="hljs-string"><span class="hljs-string">'NAME_INCOME_TYPE'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/ow/la/kf/owlakfzs7cqh74msyjw9ngeq8h4.png"><br><br>  من المرجح أن تنقطع الأمهات العازبات والعاطلات عن العمل في مرحلة التقديم - فهناك القليل جدًا منهن في العينة.  لكن المشاكل تظهر بثبات. <br><br><h3 style=";text-align:right;direction:rtl">  نوع النشاط </h3><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">plot_stats(<span class="hljs-string"><span class="hljs-string">'OCCUPATION_TYPE'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/pw/m4/eu/pwm4eui3y46rrd0380w5jnkqiug.png"><br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">application_train.OCCUPATION_TYPE.value_counts()</code> </pre> <br> <code>Laborers 55186 <br> Sales staff 32102 <br> Core staff 27570 <br> Managers 21371 <br> Drivers 18603 <br> High skill tech staff 11380 <br> Accountants 9813 <br> Medicine staff 8537 <br> Security staff 6721 <br> Cooking staff 5946 <br> Cleaning staff 4653 <br> Private service staff 2652 <br> Low-skill Laborers 2093 <br> Waiters/barmen staff 1348 <br> Secretaries 1305 <br> Realty agents 751 <br> HR staff 563 <br> IT staff 526 <br> Name: OCCUPATION_TYPE, dtype: int64</code> <br> <br>  إنها ذات أهمية للسائقين وضباط الأمن الذين هم كثيرون ويواجهون مشاكل في كثير من الأحيان أكثر من الفئات الأخرى. <br><br><h3 style=";text-align:right;direction:rtl">  التعليم </h3><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">plot_stats(<span class="hljs-string"><span class="hljs-string">'NAME_EDUCATION_TYPE'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/dh/g9/-t/dhg9-t4wl5oaaultg0m4ujq4ky0.png"><br><br>  كلما زاد التعليم ، كلما كان التكرار أفضل. <br><br><h3 style=";text-align:right;direction:rtl">  نوع المنظمة - صاحب العمل </h3><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">plot_stats(<span class="hljs-string"><span class="hljs-string">'ORGANIZATION_TYPE'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/nm/eq/p-/nmeqp-rvrmowwpqhkjzvygeah20.png"><br><br>  لوحظت أعلى نسبة من عدم العودة في النقل: النوع 3 (16٪) ، الصناعة: النوع 13 (13.5٪) ، الصناعة: النوع 8 (12.5٪) والمطعم (حتى 12٪). <br><br><h3 style=";text-align:right;direction:rtl">  تخصيص القرض </h3><br>  النظر في توزيع مبالغ القروض وأثرها على السداد <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>)) plt.title(<span class="hljs-string"><span class="hljs-string">" AMT_CREDIT"</span></span>) ax = sns.distplot(app_train[<span class="hljs-string"><span class="hljs-string">"AMT_CREDIT"</span></span>])</code> </pre> <br><img src="https://habrastorage.org/webt/x1/8k/qg/x18kqghr1tue4io96l_keuqcr94.png"><br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>))​ <span class="hljs-comment"><span class="hljs-comment"># KDE ,   sns.kdeplot(app_train.loc[app_train['TARGET'] == 0, 'AMT_CREDIT'], label = 'target == 0')​ # KDE   sns.kdeplot(app_train.loc[app_train['TARGET'] == 1, 'AMT_CREDIT'], label = 'target == 1')​ #  plt.xlabel(' '); plt.ylabel(''); plt.title(' ');</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/_3/fu/cj/_3fucjn19lmxvjjaamrrlwumh5m.png"><br><br>  كما يظهر الرسم البياني للكثافة ، يتم إرجاع كميات قوية في كثير من الأحيان <br><br><h3 style=";text-align:right;direction:rtl">  توزيع الكثافة </h3><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>)) plt.title(<span class="hljs-string"><span class="hljs-string">" REGION_POPULATION_RELATIVE"</span></span>) ax = sns.distplot(app_train[<span class="hljs-string"><span class="hljs-string">"REGION_POPULATION_RELATIVE"</span></span>])</code> </pre> <br><img src="https://habrastorage.org/webt/26/3h/os/263hoss0mbvvq2p0ewagrw5v-sm.png"><br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>))​ <span class="hljs-comment"><span class="hljs-comment"># KDE ,   sns.kdeplot(app_train.loc[app_train['TARGET'] == 0, 'REGION_POPULATION_RELATIVE'], label = 'target == 0')​ # KDE   sns.kdeplot(app_train.loc[app_train['TARGET'] == 1, 'REGION_POPULATION_RELATIVE'], label = 'target == 1')​ #  plt.xlabel(''); plt.ylabel(' '); plt.title(' ');</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/fs/ez/82/fsez82q5fbqdkiqizkxjralpm-8.png"><br><br>  يميل العملاء من المناطق الأكثر سكانًا إلى دفع القروض بشكل أفضل. <br><br>  وهكذا ، حصلنا على فكرة عن السمات الرئيسية لمجموعة البيانات وتأثيرها على النتيجة.  لن نفعل أي شيء على وجه التحديد مع تلك المدرجة في هذه المقالة ، ولكن يمكن أن تكون مهمة جدًا في العمل المستقبلي. <br><br><h2 style=";text-align:right;direction:rtl">  هندسة الميزات - تحويل الميزة </h2><br>  يتم الفوز بالمسابقات على Kaggle عن طريق تحويل العلامات - الشخص الذي يمكنه إنشاء أكثر العلامات المفيدة من البيانات يفوز.  على الأقل بالنسبة للبيانات المنظمة ، فإن النماذج الفائزة هي الآن خيارات مختلفة لتعزيز التدرج.  في أغلب الأحيان ، يكون قضاء الوقت في تحويل السمات أكثر كفاءة من إعداد المعلمات المفرطة أو اختيار النماذج.  لا يزال بإمكان النموذج التعلم فقط من البيانات التي تم نقلها إليه.  إن التأكد من أن البيانات ذات صلة بالمهمة هي المسؤولية الرئيسية عن تاريخ العالم. <br><br>  قد تتضمن عملية تحويل الخصائص إنشاء بيانات جديدة متاحة واختيار أهم البيانات المتاحة وما إلى ذلك.  سنحاول هذه المرة علامات كثيرة الحدود. <br><br><h3 style=";text-align:right;direction:rtl">  علامات كثيرة الحدود </h3><br>  إن الطريقة متعددة الحدود لبناء الميزات هي أننا نقوم ببساطة بإنشاء ميزات هي درجة الميزات المتاحة ومنتجاتها.  في بعض الحالات ، قد يكون لهذه السمات المركبة ارتباط أقوى مع المتغير المستهدف من "آبائهم".  على الرغم من أن هذه الأساليب غالبًا ما تستخدم في النماذج الإحصائية ، إلا أنها أقل شيوعًا في التعلم الآلي.  ومع ذلك.  لا شيء يمنعنا من تجربتها ، خاصة وأن Scikit-Learn لديها فئة مخصصة لهذه الأغراض - PolynomialFeatures - التي تخلق ميزات متعددة الحدود ومنتجاتها ، ما عليك سوى تحديد الميزات الأصلية نفسها وأقصى درجة يجب رفعها.  نحن نستخدم التأثيرات الأكثر قوة على نتيجة 4 سمات ودرجة 3 حتى لا نعقد النموذج كثيرًا وتجنب الإفراط في التجهيز (الإفراط في تدريب النموذج - تعديله المفرط لعينة التدريب). <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#       poly_features = app_train[['EXT_SOURCE_1', 'EXT_SOURCE_2', 'EXT_SOURCE_3', 'DAYS_BIRTH', 'TARGET']] poly_features_test = app_test[['EXT_SOURCE_1', 'EXT_SOURCE_2', 'EXT_SOURCE_3', 'DAYS_BIRTH']]​ #    from sklearn.preprocessing import Imputer imputer = Imputer(strategy = 'median')​ poly_target = poly_features['TARGET']​ poly_features = poly_features.drop('TARGET', axis=1)​ poly_features = imputer.fit_transform(poly_features) poly_features_test = imputer.transform(poly_features_test) from sklearn.preprocessing import PolynomialFeatures #     3 poly_transformer = PolynomialFeatures(degree = 3) #    poly_transformer.fit(poly_features) #   poly_features = poly_transformer.transform(poly_features) poly_features_test = poly_transformer.transform(poly_features_test) print('  : ', poly_features.shape)</span></span></code> </pre> <br> <code>  : (307511, 35) <br>        get_feature_names</code> <br> <br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">poly_transformer.get_feature_names(input_features = [<span class="hljs-string"><span class="hljs-string">'EXT_SOURCE_1'</span></span>, <span class="hljs-string"><span class="hljs-string">'EXT_SOURCE_2'</span></span>, <span class="hljs-string"><span class="hljs-string">'EXT_SOURCE_3'</span></span>, <span class="hljs-string"><span class="hljs-string">'DAYS_BIRTH'</span></span>])[:<span class="hljs-number"><span class="hljs-number">15</span></span>]</code> </pre> <br> <code>['1', <br> 'EXT_SOURCE_1', <br> 'EXT_SOURCE_2', <br> 'EXT_SOURCE_3', <br> 'DAYS_BIRTH', <br> 'EXT_SOURCE_1^2', <br> 'EXT_SOURCE_1 EXT_SOURCE_2', <br> 'EXT_SOURCE_1 EXT_SOURCE_3', <br> 'EXT_SOURCE_1 DAYS_BIRTH', <br> 'EXT_SOURCE_2^2', <br> 'EXT_SOURCE_2 EXT_SOURCE_3', <br> 'EXT_SOURCE_2 DAYS_BIRTH', <br> 'EXT_SOURCE_3^2', <br> 'EXT_SOURCE_3 DAYS_BIRTH', <br> 'DAYS_BIRTH^2']</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ما مجموعه 35 سمة متعددة الحدود ومشتقة. </font><font style="vertical-align: inherit;">تحقق من ارتباطها بالهدف.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#     poly_features = pd.DataFrame(poly_features, columns = poly_transformer.get_feature_names(['EXT_SOURCE_1', 'EXT_SOURCE_2', 'EXT_SOURCE_3', 'DAYS_BIRTH']))​ #   poly_features['TARGET'] = poly_target​ #   poly_corrs = poly_features.corr()['TARGET'].sort_values()​ #      print(poly_corrs.head(10)) print(poly_corrs.tail(5))</span></span></code> </pre> <br> <code>EXT_SOURCE_2 EXT_SOURCE_3 -0.193939 <br> EXT_SOURCE_1 EXT_SOURCE_2 EXT_SOURCE_3 -0.189605 <br> EXT_SOURCE_2 EXT_SOURCE_3 DAYS_BIRTH -0.181283 <br> EXT_SOURCE_2^2 EXT_SOURCE_3 -0.176428 <br> EXT_SOURCE_2 EXT_SOURCE_3^2 -0.172282 <br> EXT_SOURCE_1 EXT_SOURCE_2 -0.166625 <br> EXT_SOURCE_1 EXT_SOURCE_3 -0.164065 <br> EXT_SOURCE_2 -0.160295 <br> EXT_SOURCE_2 DAYS_BIRTH -0.156873 <br> EXT_SOURCE_1 EXT_SOURCE_2^2 -0.156867 <br> Name: TARGET, dtype: float64 <br> DAYS_BIRTH -0.078239 <br> DAYS_BIRTH^2 -0.076672 <br> DAYS_BIRTH^3 -0.074273 <br> TARGET 1.000000 <br> 1 NaN <br> Name: TARGET, dtype: float64</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لذا ، تظهر بعض العلامات ارتباطًا أعلى من الأصل. </font><font style="vertical-align: inherit;">من المنطقي محاولة التعلم معهم وبدونهم (مثل الكثير في التعلم الآلي ، يمكن تحديد ذلك تجريبيًا). </font><font style="vertical-align: inherit;">للقيام بذلك ، قم بإنشاء نسخة من إطارات البيانات وإضافة ميزات جديدة هناك.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      poly_features_test = pd.DataFrame(poly_features_test, columns = poly_transformer.get_feature_names(['EXT_SOURCE_1', 'EXT_SOURCE_2', 'EXT_SOURCE_3', 'DAYS_BIRTH']))​ #    poly_features['SK_ID_CURR'] = app_train['SK_ID_CURR'] app_train_poly = app_train.merge(poly_features, on = 'SK_ID_CURR', how = 'left')​ #    poly_features_test['SK_ID_CURR'] = app_test['SK_ID_CURR'] app_test_poly = app_test.merge(poly_features_test, on = 'SK_ID_CURR', how = 'left')​ #   app_train_poly, app_test_poly = app_train_poly.align(app_test_poly, join = 'inner', axis = 1)​ #   print('    : ', app_train_poly.shape) print('    : ', app_test_poly.shape)</span></span></code> </pre> <br> <code>    : (307511, 277) <br>     : (48744, 277)</code> <br> <br><h2 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تدريب نموذجي </font></font></h2><br><h3 style=";text-align:right;direction:rtl">  المستوى الأساسي </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في الحسابات ، تحتاج إلى البدء من بعض المستوى الأساسي للنموذج ، والذي لم يعد من الممكن أن ينخفض. </font><font style="vertical-align: inherit;">في حالتنا ، يمكن أن يكون هذا 0.5 لجميع عملاء الاختبار - وهذا يدل على أنه ليس لدينا أي فكرة على الإطلاق عما إذا كان العميل سوف يسدد القرض أم لا. </font><font style="vertical-align: inherit;">في حالتنا ، تم بالفعل العمل التمهيدي ويمكن استخدام نماذج أكثر تعقيدًا.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الانحدار اللوجستي </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لحساب </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الانحدار اللوجستي ،</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> نحتاج إلى أخذ جداول بميزات فئوية مشفرة ، وملء البيانات المفقودة وتطبيعها (نقلها إلى قيم من 0 إلى 1). </font><font style="vertical-align: inherit;">كل هذا ينفذ الكود التالي:</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.preprocessing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MinMaxScaler, Imputer​ <span class="hljs-comment"><span class="hljs-comment">#      if 'TARGET' in app_train: train = app_train.drop(labels = ['TARGET'], axis=1) else: train = app_train.copy() features = list(train.columns)​ #    test = app_test.copy()​ #     imputer = Imputer(strategy = 'median')​ #  scaler = MinMaxScaler(feature_range = (0, 1))​ #    imputer.fit(train)​ #      train = imputer.transform(train) test = imputer.transform(app_test)​ #      scaler.fit(train) train = scaler.transform(train) test = scaler.transform(test)​ print('  : ', train.shape) print('  : ', test.shape)</span></span></code> </pre> <br> <code>  : (307511, 242) <br>   : (48744, 242)</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نستخدم الانحدار اللوجستي من Scikit-Learn كنموذج أول. </font><font style="vertical-align: inherit;">لنأخذ نموذج التكسير بتصحيح واحد - نخفض معلمة التسوية C لتجنب الإفراط في التجهيز. </font><font style="vertical-align: inherit;">بناء الجملة أمر طبيعي - نحن ننشئ نموذجًا ، ندربه ونتنبأ بالاحتمالية باستخدام prob_proba (نحتاج إلى الاحتمالية ، وليس 0/1)</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.linear_model <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> LogisticRegression​ <span class="hljs-comment"><span class="hljs-comment">#   log_reg = LogisticRegression(C = 0.0001)​ #   log_reg.fit(train, train_labels) LogisticRegression(C=0.0001, class_weight=None, dual=False, fit_intercept=True, intercept_scaling=1, max_iter=100, multi_class='ovr', n_jobs=1, penalty='l2', random_state=None, solver='liblinear', tol=0.0001, verbose=0, warm_start=False)      .  prdict_proba     mx 2,  m -  ,   -  0,  -  1.    ( ). log_reg_pred = log_reg.predict_proba(test)[:, 1]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكنك الآن إنشاء ملف للتحميل إلى Kaggle. </font><font style="vertical-align: inherit;">إنشاء إطار بيانات من الرقم التعريفي للعميل واحتمال عدم الإرجاع وتحميله.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">submit = app_test[[<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>]] submit[<span class="hljs-string"><span class="hljs-string">'TARGET'</span></span>] = log_reg_pred​ submit.head()</code> </pre> <br> <code>SK_ID_CURR TARGET <br> 0 100001 0.087954 <br> 1 100005 0.163151 <br> 2 100013 0.109923 <br> 3 100028 0.077124 <br> 4 100038 0.151694</code> <br> <br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">submit.to_csv(<span class="hljs-string"><span class="hljs-string">'log_reg_baseline.csv'</span></span>, index = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>)</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إذن ، نتيجة عملنا العملاق: 0.673 ، مع أفضل نتيجة لهذا اليوم هي 0.802.</font></font></b> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> نموذج محسن - غابة عشوائية </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لا يظهر لوجريج نفسه جيدًا ، فلنحاول استخدام نموذج محسّن - غابة عشوائية. </font><font style="vertical-align: inherit;">هذا نموذج أكثر قوة يمكنه بناء مئات الأشجار وتحقيق نتيجة أكثر دقة. </font><font style="vertical-align: inherit;">نستخدم 100 شجرة. </font><font style="vertical-align: inherit;">مخطط العمل مع النموذج هو نفسه ، قياسي تمامًا - تحميل المصنف ، التدريب. </font><font style="vertical-align: inherit;">التنبؤ.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.ensemble <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> RandomForestClassifier​ <span class="hljs-comment"><span class="hljs-comment">#   random_forest = RandomForestClassifier(n_estimators = 100, random_state = 50)​ #     random_forest.fit(train, train_labels)​ #     predictions = random_forest.predict_proba(test)[:, 1]​ #     submit = app_test[['SK_ID_CURR']] submit['TARGET'] = predictions​ #  submit.to_csv('random_forest_baseline.csv', index = False)</span></span></code> </pre> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نتيجة الغابات العشوائية أفضل قليلاً - 0.683</font></font></b> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> نموذج تدريب مع ميزات كثيرة الحدود </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الآن لدينا نموذج. </font><font style="vertical-align: inherit;">الذي يفعل شيئًا على الأقل - حان الوقت لاختبار علاماتنا متعددة الحدود. </font><font style="vertical-align: inherit;">لنفعل نفس الشيء معهم ومقارنة النتيجة.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">poly_features_names = list(app_train_poly.columns)​ <span class="hljs-comment"><span class="hljs-comment">#         imputer = Imputer(strategy = 'median')​ poly_features = imputer.fit_transform(app_train_poly) poly_features_test = imputer.transform(app_test_poly)​ #  scaler = MinMaxScaler(feature_range = (0, 1))​ poly_features = scaler.fit_transform(poly_features) poly_features_test = scaler.transform(poly_features_test)​ random_forest_poly = RandomForestClassifier(n_estimators = 100, random_state = 50) #     random_forest_poly.fit(poly_features, train_labels)​ #  predictions = random_forest_poly.predict_proba(poly_features_test)[:, 1]​ #    submit = app_test[['SK_ID_CURR']] submit['TARGET'] = predictions​ #   submit.to_csv('random_forest_baseline_engineered.csv', index = False)</span></span></code> </pre> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نتيجة غابة عشوائية ذات سمات كثيرة الحدود أصبحت أسوأ - 0.633. </font><font style="vertical-align: inherit;">الأمر الذي يشكك كثيرًا في الحاجة إلى استخدامها.</font></font></b> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تعزيز التدرج </font></font></h3><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تعزيز التدرج</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> هو "نموذج جاد" لتعلم الآلة. </font><font style="vertical-align: inherit;">يتم تقريبًا إجراء جميع المسابقات الأخيرة تقريبًا. </font><font style="vertical-align: inherit;">دعونا نبني نموذجًا بسيطًا ونختبر أدائه.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> lightgbm <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> LGBMClassifier​ clf = LGBMClassifier() clf.fit(train, train_labels)​ predictions = clf.predict_proba(test)[:, <span class="hljs-number"><span class="hljs-number">1</span></span>]​ <span class="hljs-comment"><span class="hljs-comment">#    submit = app_test[['SK_ID_CURR']] submit['TARGET'] = predictions​ #   submit.to_csv('lightgbm_baseline.csv', index = False)</span></span></code> </pre> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نتيجة LightGBM هي 0.735 ، والتي تترك وراءها جميع الموديلات الأخرى.</font></font></b> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تفسير النموذج - أهمية السمات </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أسهل طريقة لتفسير النموذج هي النظر إلى أهمية الميزات (التي لا يمكن لجميع الموديلات فعلها). </font><font style="vertical-align: inherit;">نظرًا لأن المصنف قد عالج الصفيف ، فسوف يستغرق الأمر بعض العمل لإعادة تعيين أسماء الأعمدة وفقًا لأعمدة هذا الصفيف.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      def show_feature_importances(model, features): plt.figure(figsize = (12, 8)) #          results = pd.DataFrame({'feature': features, 'importance': model.feature_importances_}) results = results.sort_values('importance', ascending = False) #  print(results.head(10)) print('\n     0.01 = ', np.sum(results['importance'] &gt; 0.01)) #  results.head(20).plot(x = 'feature', y = 'importance', kind = 'barh', color = 'red', edgecolor = 'k', title = 'Feature Importances'); return results #         feature_importances = show_feature_importances(clf, features)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">وكما هو متوقع، والأكثر أهمية لنموذج كل نفس 4 ميزات. </font><font style="vertical-align: inherit;">أهمية السمات ليست أفضل طريقة لتفسير النموذج ، ولكنها تتيح لك فهم العوامل الرئيسية التي يستخدمها النموذج للتنبؤات</font></font><code>feature importance <br> 28 EXT_SOURCE_1 310 <br> 30 EXT_SOURCE_3 282 <br> 29 EXT_SOURCE_2 271 <br> 7 DAYS_BIRTH 192 <br> 3 AMT_CREDIT 161 <br> 4 AMT_ANNUITY 142 <br> 5 AMT_GOODS_PRICE 129 <br> 8 DAYS_EMPLOYED 127 <br> 10 DAYS_ID_PUBLISH 102 <br> 9 DAYS_REGISTRATION 69 <br> <br>     0.01 = 158</code> <br> <br><img src="https://habrastorage.org/webt/uc/pi/ox/ucpiox1dno_vps4lsuk0lmxk7si.png"><br><br><font style="vertical-align: inherit;"></font><br><br><h2 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إضافة بيانات من جداول أخرى </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الآن سننظر بعناية في الجداول الإضافية وما يمكن فعله بها. </font><font style="vertical-align: inherit;">ابدأ فورًا في إعداد الجداول لمزيد من التدريب. </font><font style="vertical-align: inherit;">ولكن أولاً ، احذف الجداول الضخمة السابقة من الذاكرة ، وامسح الذاكرة باستخدام جامع القمامة ، واستورد المكتبات اللازمة لمزيد من التحليل.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gc​ <span class="hljs-comment"><span class="hljs-comment">#del app_train, app_test, train_labels, application_train, application_test, poly_features, poly_features_test​ gc.collect() import pandas as pd import numpy as np​ from sklearn.preprocessing import MinMaxScaler, LabelEncoder from sklearn.model_selection import train_test_split, KFold from sklearn.metrics import accuracy_score, roc_auc_score, confusion_matrix from sklearn.feature_selection import VarianceThreshold​ from lightgbm import LGBMClassifier</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> استيراد البيانات ، قم بإزالة العمود الهدف على الفور في عمود منفصل </font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">data = pd.read_csv(<span class="hljs-string"><span class="hljs-string">'../input/application_train.csv'</span></span>) test = pd.read_csv(<span class="hljs-string"><span class="hljs-string">'../input/application_test.csv'</span></span>) prev = pd.read_csv(<span class="hljs-string"><span class="hljs-string">'../input/previous_application.csv'</span></span>) buro = pd.read_csv(<span class="hljs-string"><span class="hljs-string">'../input/bureau.csv'</span></span>) buro_balance = pd.read_csv(<span class="hljs-string"><span class="hljs-string">'../input/bureau_balance.csv'</span></span>) credit_card = pd.read_csv(<span class="hljs-string"><span class="hljs-string">'../input/credit_card_balance.csv'</span></span>) POS_CASH = pd.read_csv(<span class="hljs-string"><span class="hljs-string">'../input/POS_CASH_balance.csv'</span></span>) payments = pd.read_csv(<span class="hljs-string"><span class="hljs-string">'../input/installments_payments.csv'</span></span>)​ <span class="hljs-comment"><span class="hljs-comment">#Separate target variable y = data['TARGET'] del data['TARGET']</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ترميز الميزات الفئوية على الفور. </font><font style="vertical-align: inherit;">لقد قمنا بذلك بالفعل من قبل ، وقمنا بتشفير عينات التدريب والاختبار بشكل منفصل ، ثم قمنا بمحاذاة البيانات. </font><font style="vertical-align: inherit;">دعنا نجرب نهجًا مختلفًا بعض الشيء - سنجد كل هذه العلامات الفئوية ، ودمج إطارات البيانات ، والتشفير من قائمة تلك الموجودة ، ثم تقسيم العينات مرة أخرى إلى تدريب واختبار.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">categorical_features = [col <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data.columns <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[col].dtype == <span class="hljs-string"><span class="hljs-string">'object'</span></span>]​ one_hot_df = pd.concat([data,test]) one_hot_df = pd.get_dummies(one_hot_df, columns=categorical_features)​ data = one_hot_df.iloc[:data.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>],:] test = one_hot_df.iloc[data.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>]:,]​ <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">'  '</span></span>, data.shape) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">'  '</span></span>, test.shape)</code> </pre> <br> <code>   (307511, 245) <br>    (48744, 245)</code> <br> <br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> بيانات مكتب الائتمان حول رصيد القرض الشهري. </font></font></h3><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">buro_balance.head()</code> </pre> <br><img src="https://habrastorage.org/webt/pa/im/0s/paim0sea2cdjnvm7lok--vi8oke.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MONTHS_BALANCE - عدد الأشهر قبل تاريخ تقديم طلب الحصول على قرض. </font><font style="vertical-align: inherit;">ألق نظرة عن كثب على "الحالات"</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">buro_balance.STATUS.value_counts()</code> </pre> <br> <code>C 13646993 <br> 0 7499507 <br> X 5810482 <br> 1 242347 <br> 5 62406 <br> 2 23419 <br> 3 8924 <br> 4 5847 <br> Name: STATUS, dtype: int64</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الحالات تعني ما يلي: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - مغلق ، أي قرض مدفوع. </font><font style="vertical-align: inherit;">X حالة غير معروفة. </font><font style="vertical-align: inherit;">0 - القرض الحالي بدون انحراف. </font><font style="vertical-align: inherit;">1 - التأخير من 1-30 يومًا ، 2 - التأخير من 31-60 يومًا ، وهكذا حتى الوضع 5 - يباع القرض لطرف ثالث أو يتم شطبه. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هنا ، على سبيل المثال ، يمكن تمييز العلامات التالية: buro_grouped_size - عدد الإدخالات في قاعدة البيانات buro_grouped_max - الحد الأقصى لرصيد القرض buro_grouped_min - الحد الأدنى لرصيد </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">القرض ويمكن تشفير جميع حالات القرض هذه (نستخدم طريقة unstack ، ثم نرفق البيانات المستلمة بجدول المكتب ، حيث إن SK_ID_BUREAU هو نفسه هنا وهناك.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">buro_grouped_size = buro_balance.groupby(<span class="hljs-string"><span class="hljs-string">'SK_ID_BUREAU'</span></span>)[<span class="hljs-string"><span class="hljs-string">'MONTHS_BALANCE'</span></span>].size() buro_grouped_max = buro_balance.groupby(<span class="hljs-string"><span class="hljs-string">'SK_ID_BUREAU'</span></span>)[<span class="hljs-string"><span class="hljs-string">'MONTHS_BALANCE'</span></span>].max() buro_grouped_min = buro_balance.groupby(<span class="hljs-string"><span class="hljs-string">'SK_ID_BUREAU'</span></span>)[<span class="hljs-string"><span class="hljs-string">'MONTHS_BALANCE'</span></span>].min()​ buro_counts = buro_balance.groupby(<span class="hljs-string"><span class="hljs-string">'SK_ID_BUREAU'</span></span>)[<span class="hljs-string"><span class="hljs-string">'STATUS'</span></span>].value_counts(normalize = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) buro_counts_unstacked = buro_counts.unstack(<span class="hljs-string"><span class="hljs-string">'STATUS'</span></span>) buro_counts_unstacked.columns = [<span class="hljs-string"><span class="hljs-string">'STATUS_0'</span></span>, <span class="hljs-string"><span class="hljs-string">'STATUS_1'</span></span>,<span class="hljs-string"><span class="hljs-string">'STATUS_2'</span></span>,<span class="hljs-string"><span class="hljs-string">'STATUS_3'</span></span>,<span class="hljs-string"><span class="hljs-string">'STATUS_4'</span></span>,<span class="hljs-string"><span class="hljs-string">'STATUS_5'</span></span>,<span class="hljs-string"><span class="hljs-string">'STATUS_C'</span></span>,<span class="hljs-string"><span class="hljs-string">'STATUS_X'</span></span>,] buro_counts_unstacked[<span class="hljs-string"><span class="hljs-string">'MONTHS_COUNT'</span></span>] = buro_grouped_size buro_counts_unstacked[<span class="hljs-string"><span class="hljs-string">'MONTHS_MIN'</span></span>] = buro_grouped_min buro_counts_unstacked[<span class="hljs-string"><span class="hljs-string">'MONTHS_MAX'</span></span>] = buro_grouped_max​ buro = buro.join(buro_counts_unstacked, how=<span class="hljs-string"><span class="hljs-string">'left'</span></span>, on=<span class="hljs-string"><span class="hljs-string">'SK_ID_BUREAU'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> buro_balance gc.collect()</code> </pre> <br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> معلومات عامة عن مكاتب الائتمان </font></font></h3><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">buro.head()</code> </pre> <br><img src="https://habrastorage.org/webt/00/7q/dz/007qdzakfbvd5qiizsxqwxvoari.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(يتم عرض الأعمدة السبعة الأولى) هناك </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قدر كبير من البيانات ، بشكل عام ، يمكنك محاولة التشفير ببساطة باستخدام One-Hot-Encoding ، وتجميعها حسب SK_ID_CURR ، في المتوسط ​​، وبنفس الطريقة ، الاستعداد للانضمام مع الجدول الرئيسي</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">buro_cat_features = [bcol <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> bcol <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> buro.columns <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> buro[bcol].dtype == <span class="hljs-string"><span class="hljs-string">'object'</span></span>] buro = pd.get_dummies(buro, columns=buro_cat_features) avg_buro = buro.groupby(<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>).mean() avg_buro[<span class="hljs-string"><span class="hljs-string">'buro_count'</span></span>] = buro[[<span class="hljs-string"><span class="hljs-string">'SK_ID_BUREAU'</span></span>, <span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>]].groupby(<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>).count()[<span class="hljs-string"><span class="hljs-string">'SK_ID_BUREAU'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> avg_buro[<span class="hljs-string"><span class="hljs-string">'SK_ID_BUREAU'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> buro gc.collect()</code> </pre> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> بيانات عن التطبيقات السابقة </font></font></h3><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">prev.head()</code> </pre> <br><img src="https://habrastorage.org/webt/nx/sv/z-/nxsvz-simhdingy0zqgnwg9xxpi.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> وبالمثل ، نقوم بتشفير الميزات الفئوية والمتوسط ​​والجمع بين المعرّف الحالي. </font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">prev_cat_features = [pcol <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pcol <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> prev.columns <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> prev[pcol].dtype == <span class="hljs-string"><span class="hljs-string">'object'</span></span>] prev = pd.get_dummies(prev, columns=prev_cat_features) avg_prev = prev.groupby(<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>).mean() cnt_prev = prev[[<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>, <span class="hljs-string"><span class="hljs-string">'SK_ID_PREV'</span></span>]].groupby(<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>).count() avg_prev[<span class="hljs-string"><span class="hljs-string">'nb_app'</span></span>] = cnt_prev[<span class="hljs-string"><span class="hljs-string">'SK_ID_PREV'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> avg_prev[<span class="hljs-string"><span class="hljs-string">'SK_ID_PREV'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> prev gc.collect()</code> </pre> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> رصيد بطاقة الائتمان </font></font></h3><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">POS_CASH.head()</code> </pre> <br><img src="https://habrastorage.org/webt/aq/25/er/aq25erq2wzuknck85ina4twk2g8.png"><br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">POS_CASH.NAME_CONTRACT_STATUS.value_counts()</code> </pre> <br> <code>Active 9151119 <br> Completed 744883 <br> Signed 87260 <br> Demand 7065 <br> Returned to the store 5461 <br> Approved 4917 <br> Amortized debt 636 <br> Canceled 15 <br> XNA 2 <br> Name: NAME_CONTRACT_STATUS, dtype: int64</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> نقوم بتشفير الميزات الفئوية وإعداد جدول للجمع </font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">le = LabelEncoder() POS_CASH[<span class="hljs-string"><span class="hljs-string">'NAME_CONTRACT_STATUS'</span></span>] = le.fit_transform(POS_CASH[<span class="hljs-string"><span class="hljs-string">'NAME_CONTRACT_STATUS'</span></span>].astype(str)) nunique_status = POS_CASH[[<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>, <span class="hljs-string"><span class="hljs-string">'NAME_CONTRACT_STATUS'</span></span>]].groupby(<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>).nunique() nunique_status2 = POS_CASH[[<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>, <span class="hljs-string"><span class="hljs-string">'NAME_CONTRACT_STATUS'</span></span>]].groupby(<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>).max() POS_CASH[<span class="hljs-string"><span class="hljs-string">'NUNIQUE_STATUS'</span></span>] = nunique_status[<span class="hljs-string"><span class="hljs-string">'NAME_CONTRACT_STATUS'</span></span>] POS_CASH[<span class="hljs-string"><span class="hljs-string">'NUNIQUE_STATUS2'</span></span>] = nunique_status2[<span class="hljs-string"><span class="hljs-string">'NAME_CONTRACT_STATUS'</span></span>] POS_CASH.drop([<span class="hljs-string"><span class="hljs-string">'SK_ID_PREV'</span></span>, <span class="hljs-string"><span class="hljs-string">'NAME_CONTRACT_STATUS'</span></span>], axis=<span class="hljs-number"><span class="hljs-number">1</span></span>, inplace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> بيانات البطاقة </font></font></h3><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">credit_card.head()</code> </pre> <br><img src="https://habrastorage.org/webt/q5/wj/pj/q5wjpj8s-vak-svacdtlhqrwlus.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(الأعمدة السبعة الأولى) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عمل مماثل</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">credit_card[<span class="hljs-string"><span class="hljs-string">'NAME_CONTRACT_STATUS'</span></span>] = le.fit_transform(credit_card[<span class="hljs-string"><span class="hljs-string">'NAME_CONTRACT_STATUS'</span></span>].astype(str)) nunique_status = credit_card[[<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>, <span class="hljs-string"><span class="hljs-string">'NAME_CONTRACT_STATUS'</span></span>]].groupby(<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>).nunique() nunique_status2 = credit_card[[<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>, <span class="hljs-string"><span class="hljs-string">'NAME_CONTRACT_STATUS'</span></span>]].groupby(<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>).max() credit_card[<span class="hljs-string"><span class="hljs-string">'NUNIQUE_STATUS'</span></span>] = nunique_status[<span class="hljs-string"><span class="hljs-string">'NAME_CONTRACT_STATUS'</span></span>] credit_card[<span class="hljs-string"><span class="hljs-string">'NUNIQUE_STATUS2'</span></span>] = nunique_status2[<span class="hljs-string"><span class="hljs-string">'NAME_CONTRACT_STATUS'</span></span>] credit_card.drop([<span class="hljs-string"><span class="hljs-string">'SK_ID_PREV'</span></span>, <span class="hljs-string"><span class="hljs-string">'NAME_CONTRACT_STATUS'</span></span>], axis=<span class="hljs-number"><span class="hljs-number">1</span></span>, inplace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> بيانات الدفع </font></font></h3><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">payments.head()</code> </pre> <br><img src="https://habrastorage.org/webt/ay/fy/3y/ayfy3yp5tzdxsffurkrgjd4udwu.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(تظهر الأعمدة السبعة الأولى) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لننشئ ثلاثة جداول - بالقيم المتوسطة والحد الأدنى والحد الأقصى من هذا الجدول.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">avg_payments = payments.groupby(<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>).mean() avg_payments2 = payments.groupby(<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>).max() avg_payments3 = payments.groupby(<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>).min() <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> avg_payments[<span class="hljs-string"><span class="hljs-string">'SK_ID_PREV'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> payments gc.collect()</code> </pre> <br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ربط الجدول </font></font></h3><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">data = data.merge(right=avg_prev.reset_index(), how=<span class="hljs-string"><span class="hljs-string">'left'</span></span>, on=<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>) test = test.merge(right=avg_prev.reset_index(), how=<span class="hljs-string"><span class="hljs-string">'left'</span></span>, on=<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>)​ data = data.merge(right=avg_buro.reset_index(), how=<span class="hljs-string"><span class="hljs-string">'left'</span></span>, on=<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>) test = test.merge(right=avg_buro.reset_index(), how=<span class="hljs-string"><span class="hljs-string">'left'</span></span>, on=<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>)​ data = data.merge(POS_CASH.groupby(<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>).mean().reset_index(), how=<span class="hljs-string"><span class="hljs-string">'left'</span></span>, on=<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>) test = test.merge(POS_CASH.groupby(<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>).mean().reset_index(), how=<span class="hljs-string"><span class="hljs-string">'left'</span></span>, on=<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>)​ data = data.merge(credit_card.groupby(<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>).mean().reset_index(), how=<span class="hljs-string"><span class="hljs-string">'left'</span></span>, on=<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>) test = test.merge(credit_card.groupby(<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>).mean().reset_index(), how=<span class="hljs-string"><span class="hljs-string">'left'</span></span>, on=<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>)​ data = data.merge(right=avg_payments.reset_index(), how=<span class="hljs-string"><span class="hljs-string">'left'</span></span>, on=<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>) test = test.merge(right=avg_payments.reset_index(), how=<span class="hljs-string"><span class="hljs-string">'left'</span></span>, on=<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>)​ data = data.merge(right=avg_payments2.reset_index(), how=<span class="hljs-string"><span class="hljs-string">'left'</span></span>, on=<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>) test = test.merge(right=avg_payments2.reset_index(), how=<span class="hljs-string"><span class="hljs-string">'left'</span></span>, on=<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>)​ data = data.merge(right=avg_payments3.reset_index(), how=<span class="hljs-string"><span class="hljs-string">'left'</span></span>, on=<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>) test = test.merge(right=avg_payments3.reset_index(), how=<span class="hljs-string"><span class="hljs-string">'left'</span></span>, on=<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> avg_prev, avg_buro, POS_CASH, credit_card, avg_payments, avg_payments2, avg_payments3 gc.collect() <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">'  '</span></span>, data.shape) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">'  '</span></span>, test.shape) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">'  '</span></span>, y.shape)</code> </pre> <br> <code>   (307511, 504) <br>    (48744, 504) <br>    (307511,)</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> وفي الواقع ، سنصل إلى هذا الجدول المضاعف مع تعزيز التدرج! </font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> lightgbm <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> LGBMClassifier​ clf2 = LGBMClassifier() clf2.fit(data, y)​ predictions = clf2.predict_proba(test)[:, <span class="hljs-number"><span class="hljs-number">1</span></span>]​ <span class="hljs-comment"><span class="hljs-comment">#    submission = test[['SK_ID_CURR']] submission['TARGET'] = predictions​ #   submission.to_csv('lightgbm_full.csv', index = False)</span></span></code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تكون النتيجة 0.770. </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حسنًا ، أخيرًا ، دعنا نجرب تقنية أكثر تعقيدًا مع الطي في الطيات والتحقق المتقاطع واختيار أفضل تكرار.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">folds = KFold(n_splits=<span class="hljs-number"><span class="hljs-number">5</span></span>, shuffle=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, random_state=<span class="hljs-number"><span class="hljs-number">546789</span></span>) oof_preds = np.zeros(data.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>]) sub_preds = np.zeros(test.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>])​ feature_importance_df = pd.DataFrame()​ feats = [f <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data.columns <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-string"><span class="hljs-string">'SK_ID_CURR'</span></span>]]​ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n_fold, (trn_idx, val_idx) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(folds.split(data)): trn_x, trn_y = data[feats].iloc[trn_idx], y.iloc[trn_idx] val_x, val_y = data[feats].iloc[val_idx], y.iloc[val_idx] clf = LGBMClassifier( n_estimators=<span class="hljs-number"><span class="hljs-number">10000</span></span>, learning_rate=<span class="hljs-number"><span class="hljs-number">0.03</span></span>, num_leaves=<span class="hljs-number"><span class="hljs-number">34</span></span>, colsample_bytree=<span class="hljs-number"><span class="hljs-number">0.9</span></span>, subsample=<span class="hljs-number"><span class="hljs-number">0.8</span></span>, max_depth=<span class="hljs-number"><span class="hljs-number">8</span></span>, reg_alpha=<span class="hljs-number"><span class="hljs-number">.1</span></span>, reg_lambda=<span class="hljs-number"><span class="hljs-number">.1</span></span>, min_split_gain=<span class="hljs-number"><span class="hljs-number">.01</span></span>, min_child_weight=<span class="hljs-number"><span class="hljs-number">375</span></span>, silent=<span class="hljs-number"><span class="hljs-number">-1</span></span>, verbose=<span class="hljs-number"><span class="hljs-number">-1</span></span>, ) clf.fit(trn_x, trn_y, eval_set= [(trn_x, trn_y), (val_x, val_y)], eval_metric=<span class="hljs-string"><span class="hljs-string">'auc'</span></span>, verbose=<span class="hljs-number"><span class="hljs-number">100</span></span>, early_stopping_rounds=<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-comment"><span class="hljs-comment">#30 ) oof_preds[val_idx] = clf.predict_proba(val_x, num_iteration=clf.best_iteration_)[:, 1] sub_preds += clf.predict_proba(test[feats], num_iteration=clf.best_iteration_)[:, 1] / folds.n_splits fold_importance_df = pd.DataFrame() fold_importance_df["feature"] = feats fold_importance_df["importance"] = clf.feature_importances_ fold_importance_df["fold"] = n_fold + 1 feature_importance_df = pd.concat([feature_importance_df, fold_importance_df], axis=0) print('Fold %2d AUC : %.6f' % (n_fold + 1, roc_auc_score(val_y, oof_preds[val_idx]))) del clf, trn_x, trn_y, val_x, val_y gc.collect()​ print('Full AUC score %.6f' % roc_auc_score(y, oof_preds))​ test['TARGET'] = sub_preds​ test[['SK_ID_CURR', 'TARGET']].to_csv('submission_cross.csv', index=False)</span></span></code> </pre> <br> <code>Full AUC score 0.785845</code> <br> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">النتيجة النهائية على kaggle 0.783</font></font></b> <br><br><h2 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إلى أين أذهب بعد ذلك </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بالتأكيد تواصل العمل مع العلامات. استكشف البيانات ، حدد بعض العلامات ، ودمجها ، وإرفاق جداول إضافية بطريقة مختلفة. يمكنك تجربة معاملات hyperparameters Mogheli - الكثير من الاتجاهات. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">آمل أن تكون هذه المجموعة الصغيرة قد أظهرت لك الأساليب الحديثة للبحث عن البيانات وإعداد النماذج التنبؤية. تعلم قواعد البيانات ، شارك في المسابقات ، كن هادئا! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ومرة أخرى روابط للنواة التي ساعدتني في إعداد هذا المقال. تم نشر المقالة أيضًا في شكل </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كمبيوتر محمول على Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، يمكنك تنزيله ، </font><font style="vertical-align: inherit;">ومجموعة </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">البيانات</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> والتشغيل والتجربة. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ويل كوهرسن. ابدأ هنا: </font></font></a> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;">سبان </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;">مقدمة </font></a></font><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لطيفة. HomeCreditRisk: Extensive EDA + Baseline [0.772]</font></font></a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Gabriel Preda. Home Credit Default Risk Extensive EDA</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Pavan Raj. Loan repayers v/s Loan defaulters — HOME CREDIT</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Lem Lordje Ko. 15 lines: Just EXT_SOURCE_x</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Shanth. HOME CREDIT — BUREAU DATA — FEATURE ENGINEERING</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Dmitriy Kisil. Good_fun_with_LigthGBM</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar414613/">https://habr.com/ru/post/ar414613/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar414595/index.html">حجب Roskomnadzor من قبل نشيد الاتحاد الروسي</a></li>
<li><a href="../ar414601/index.html">عندما كانت الجبال طويلة وكانت أجهزة الكمبيوتر المحمولة كبيرة: المزيد من تاريخ تكنولوجيا المعلومات</a></li>
<li><a href="../ar414605/index.html">إمبراطوريات صغيرة</a></li>
<li><a href="../ar414609/index.html">هل يمكن أن تكون 2018 PWA (تطبيقات الويب التقدمية) منافسة جديرة بالتطبيقات الأصلية؟</a></li>
<li><a href="../ar414611/index.html">قصتي حول إنشاء تطبيق تحفيزي (iOS و Android) لابنة مع ابنة في Unity و C #</a></li>
<li><a href="../ar414615/index.html">نسيان اللائحة العامة لحماية البيانات: يمكن لإصلاح حقوق النشر في الاتحاد الأوروبي أن يغير الويب تمامًا</a></li>
<li><a href="../ar414619/index.html">هوجورتس الأحمر. السلسلة 8. الشراع</a></li>
<li><a href="../ar414621/index.html">يسرع النظام الروبوتي أخذ عينات الدم والاختبار</a></li>
<li><a href="../ar414627/index.html">التنمية الآمنة في PHDays 8: نتائج اجتماع مجتمع PDUG</a></li>
<li><a href="../ar414629/index.html">تعترف منظمة الصحة العالمية رسميًا بوجود إدمان القمار</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>