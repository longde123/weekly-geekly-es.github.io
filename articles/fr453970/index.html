<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåü üë®üèº‚Äçüî¨ ‚úãüèª Nous √©crivons le proxy Reverse socks5 sur PowerShell. Partie 2 üõ´ üéá üöë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'histoire de la recherche et du d√©veloppement en 3 parties. Partie 2 - d√©veloppement. 
 Il existe de nombreux h√™tres - encore plus d'avantages. 

 Da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous √©crivons le proxy Reverse socks5 sur PowerShell. Partie 2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453970/">  L'histoire de la recherche et du d√©veloppement en 3 parties.  Partie 2 - d√©veloppement. <br>  Il existe de nombreux h√™tres - encore plus d'avantages. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dans la premi√®re partie de l'</a> article, nous nous sommes familiaris√©s avec certains outils d'organisation des tunnels inverses, avons examin√© leurs avantages et leurs inconv√©nients, √©tudi√© le m√©canisme du multiplexeur Yamux et d√©crit les exigences de base du module PowerShell nouvellement cr√©√©.  Il est temps de commencer √† d√©velopper le module PowerShell client pour l'impl√©mentation pr√™te √† l'emploi du tunnel inverse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RSocksTun</a> . <br><br>  Tout d'abord, nous devons comprendre dans quel mode notre module fonctionnera.  √âvidemment, pour le transfert de donn√©es prima, nous devrons utiliser le m√©canisme de socket Windows et les capacit√©s .Net pour diffuser en lecture-√©criture sur les sockets.  Mais, d'autre part, parce que  Puisque notre module doit servir plusieurs flux yamux en m√™me temps, toutes les op√©rations d'E / S ne doivent pas bloquer compl√®tement l'ex√©cution de notre programme.  Cela sugg√®re la conclusion que notre module devrait utiliser le multithreading logiciel et effectuer des op√©rations de lecture-√©criture avec un serveur yamux, ainsi que des op√©rations de lecture-√©criture sur les serveurs de destination dans diff√©rents flux de programme.  Eh bien, bien s√ªr, il est n√©cessaire de pr√©voir un m√©canisme d'interaction entre nos flux parall√®les.  Heureusement, powershell offre de nombreuses possibilit√©s de lancement et de gestion des flux de programmes. <br><a name="habracut"></a><br><h3>  Algorithme g√©n√©ral de travail </h3><br>  Ainsi, l'algorithme g√©n√©ral de notre client devrait ressembler √† ceci: <br><br><ul><li>  √©tablir une connexion SSL avec le serveur; </li><li>  connectez-vous avec un mot de passe pour que le serveur puisse nous distinguer d'un responsable de la s√©curit√©; </li><li>  attendez que le package yamux installe un nouveau flux, r√©pondant p√©riodiquement aux demandes de maintien du serveur; </li><li>  d√©marrer un nouveau flux de programme socksScript (√† ne pas confondre avec un flux) d√®s que le paquet yamux arrive pour installer un nouveau flux.  √Ä l'int√©rieur de socksScript, impl√©mentez le travail du serveur socks5; </li><li>  √† l'arriv√©e d'un paquet avec des donn√©es de yamux - comprendre √† partir d'un en-t√™te de 12 octets √† quels flux les donn√©es sont destin√©es, ainsi que leur taille, lire les donn√©es du serveur yamux et transf√©rer les donn√©es re√ßues vers le flux avec le num√©ro de flux correspondant; </li><li>  surveiller p√©riodiquement la disponibilit√© des donn√©es destin√©es au serveur yamux dans chacun des scripts de chaussettes en cours d'ex√©cution.  S'il existe de telles donn√©es, ajoutez-leur l'en-t√™te de 12 octets correspondant et envoyez-le au serveur yamux; </li><li>  √† l'arriv√©e d'un paquet yamux pour fermer le flux, transmettre un signal au flux correspondant pour terminer le flux et se d√©connecter, et apr√®s cela, terminer le flux lui-m√™me; </li></ul><br>  Ainsi, chez notre client, il est n√©cessaire d'impl√©menter au moins 3 flux de programme: <br><br><ol><li>  le principal, qui √©tablira la connexion, se connectera au serveur yamux, en recevra les donn√©es, traitera les en-t√™tes yamux et enverra des donn√©es d√©j√† brutes √† d'autres flux de programme; </li><li>  flux avec des serveurs de chaussettes.  Il peut y en avoir plusieurs - un pour chaque flux.  Ils impl√©mentent la fonctionnalit√© socks5.  Ces flux interagiront avec les points de destination sur le r√©seau interne; </li><li>  flux invers√©.  Il re√ßoit les donn√©es des flux de chaussettes, leur ajoute des en-t√™tes yamux et les envoie au serveur yamux; </li></ol><br>  Et, bien s√ªr, nous devons pr√©voir l'interaction entre tous ces flux. <br><br>  Nous devons non seulement fournir une telle interaction, mais √©galement obtenir la commodit√© du streaming d'entr√©e-sortie (de mani√®re similaire aux sockets).  Le m√©canisme le plus appropri√© serait d'utiliser des canaux logiciels.  Sous Windows, les canaux sont enregistr√©s lorsque chaque canal a son propre nom, et anonymes - chaque canal est identifi√© par son gestionnaire.  Par souci de confidentialit√©, nous utiliserons bien s√ªr des canaux anonymes.  (Apr√®s tout, nous ne voulons pas que notre module soit calcul√© en utilisant des tuyaux enregistr√©s dans le syst√®me - non?).  Ainsi, entre les flux principaux / inverses et les flux de chaussettes, l'interaction se fera via des canaux anonymes, prenant en charge les E / S de flux asynchrones.  Entre le flux principal et le flux de retour, la communication se fera via le m√©canisme d'objet partag√© (variables synchronis√©es partag√©es) (vous pouvez lire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> plus d'informations sur ces variables et comment vivre avec elles). <br><br>  Les informations sur l'ex√©cution des flux de chaussettes doivent √™tre stock√©es dans la structure de donn√©es correspondante.  Lors de la cr√©ation d'un fil de chaussettes dans cette structure, nous devons √©crire: <br><br><ul><li>  num√©ro de session yamux: $ ymxstream; </li><li>  4 variables pour travailler avec des pipes (canaux): $ cipipe, $ copipe, $ sipipe, $ sopipe.  √âtant donn√© que les canaux anonymes fonctionnent en IN ou OUT, pour chaque flux de chaussettes, nous avons besoin de deux canaux anonymes, dont chacun doit avoir deux extr√©mit√©s (pipestream) (serveur et client); </li><li>  le r√©sultat de l'appel au flux est $ AsyncJobResult; </li><li>  gestionnaire de flux - $ Psobj.  Gr√¢ce √† lui, nous fermerons le flux et lib√©rerons des ressources; </li><li>  le r√©sultat de la lecture asynchrone du canal anonyme par le flux inverse ($ readjob).  Cette variable est utilis√©e dans le flux yamuxScript inverse pour la lecture asynchrone √† partir du canal correspondant; </li><li>  tampon pour lire les donn√©es pour chaque flux de chaussettes; </li></ul><br><h3>  Flux principal </h3><br>  Ainsi, du point de vue du traitement des donn√©es, le travail de notre programme est construit comme suit: <br><br><ul><li>  le c√¥t√© serveur (rsockstun - impl√©ment√© sur Golang) l√®ve le serveur ssl et attend les connexions du client; </li><li>  √† la r√©ception d'une connexion du client, le serveur v√©rifie le mot de passe, et s'il est correct, √©tablit une connexion yamux, augmente le port des chaussettes et attend les connexions des clients de chaussettes (nos cha√Ænes proxy, navigateur, etc.), √©changeant p√©riodiquement des paquets persistants avec notre client.  Si le mot de passe est incorrect - une redirection vers la page que nous avons sp√©cifi√©e lors de l'installation du serveur est effectu√©e (il s'agit d'une page "l√©gale" pour l'administrateur vigilant de la s√©curit√© de l'information); </li><li>  √† la r√©ception d'une connexion d'un client chaussettes, le serveur envoie un paquet yamux √† notre client pour √©tablir un nouveau flux (YMX SYN); </li></ul><br>  <b>Obtenir et analyser un en-t√™te Yamux</b> <br><br>  Notre module √©tablit d'abord une connexion SSL au serveur et se connecte avec un mot de passe: <br><br><pre><code class="plaintext hljs">$tcpConnection = New-Object System.Net.Sockets.TcpClient($server, $port) $tcpStream = New-Object System.Net.Security.SslStream($tcpConnection.GetStream(),$false,({$True} -as [Net.Security.RemoteCertificateValidationCallback])) $tcpStream.AuthenticateAsClient('127.0.0.1')</code> </pre> <br>  Ensuite, le script attend un en-t√™te yamux de 12 octets et l'analyse. <br>  Il y a une petite nuance ... Comme le montre la pratique, il suffit de lire 12 octets √† partir du socket: <br><br><pre> <code class="plaintext hljs"> $num = $tcpStream.Read($tmpbuffer,0,12)</code> </pre> <br>  pas assez, car l'op√©ration de lecture peut √™tre termin√©e apr√®s l'arriv√©e d'une partie seulement des octets n√©cessaires.  Par cons√©quent, nous devons attendre les 12 octets de la boucle: <br><br><pre> <code class="plaintext hljs"> do { try { $num = $tcpStream.Read($tmpbuffer,0,12) } catch {} $tnum += $num $ymxbuffer += $tmpbuffer[0..($num-1)] }while ($tnum -lt 12 -and $tcpConnection.Connected)</code> </pre> <br>  Une fois la boucle termin√©e, nous devons analyser l'en-t√™te de 12 octets contenu dans la variable $ ymxbuffer pour son type et d√©finir des indicateurs conform√©ment aux sp√©cifications de Yamux. <br><br>  L'en-t√™te Yamux peut √™tre de plusieurs types: <br><br><ul><li>  ymx syn - installe un nouveau flux; </li><li>  ymx fin - ach√®vement du flux; </li><li>  donn√©es ymx - repr√©sente des informations sur les donn√©es (quelle taille et quel flux elles sont destin√©es); </li><li>  ymx ping - message keepalive; </li><li>  mise √† jour ymx win - confirmation du transfert d'une partie des donn√©es; </li></ul><br>  Tout ce qui ne correspond pas aux types d'en-t√™tes yamux r√©pertori√©s est consid√©r√© comme une situation exceptionnelle.  Il y a 10 exceptions de ce type, et nous pensons que quelque chose ne va pas ici et nous terminons le travail de notre module.  <s>(ainsi qu'effacer tous nos fichiers, essuyer le disque, changer le nom de famille, faire un nouveau passeport, quitter le pays, etc. selon la liste ...)</s> <br><br>  <b>Cr√©ation d'un nouveau fil de chaussettes</b> <br><br>  Ayant re√ßu un package yamux pour √©tablir un nouveau flux, notre client cr√©e deux canaux de serveur anonyme ($ sipipe, $ sopipe), pour in / out, respectivement, cr√©e des canaux client ($ cipipe, $ copipe) en fonction d'eux: <br><br><pre> <code class="plaintext hljs">$sipipe = new-object System.IO.Pipes.AnonymousPipeServerStream(1) $sopipe = new-object System.IO.Pipes.AnonymousPipeServerStream(2,1) $sipipe_clHandle = $sipipe.GetClientHandleAsString() $sopipe_clHandle = $sopipe.GetClientHandleAsString() $cipipe = new-object System.IO.Pipes.AnonymousPipeClientStream(1,$sopipe_clHandle) $copipe = new-object System.IO.Pipes.AnonymousPipeClientStream(2,$sipipe_clHandle)</code> </pre> <br>  cr√©e un espace d'ex√©cution pour le flux socks, d√©finit des variables partag√©es pour interagir avec ce flux (StopFlag) et ex√©cute le scriptblock SocksScript, qui impl√©mente la fonctionnalit√© du serveur socks dans un flux distinct: <br><br><pre> <code class="plaintext hljs">$state = [PSCustomObject]@{"StreamID"=$ymxstream;"inputStream"=$cipipe;"outputStream"=$copipe} $PS = [PowerShell]::Create() $socksrunspace = [runspacefactory]::CreateRunspace() $socksrunspace.Open() $socksrunspace.SessionStateProxy.SetVariable("StopFlag",$StopFlag) $PS.Runspace = $socksrunspace $PS.AddScript($socksScript).AddArgument($state) | Out-Null [System.IAsyncResult]$AsyncJobResult = $null $StopFlag[$ymxstream] = 0 $AsyncJobResult = $PS.BeginInvoke()</code> </pre> <br>  Les variables cr√©√©es sont √©crites dans une structure sp√©ciale ArrayList - un analogue de Dictionary in Python <br><br><pre> <code class="plaintext hljs">[System.Collections.ArrayList]$streams = @{}</code> </pre><br>  L'ajout s'effectue via la m√©thode Add int√©gr√©e: <br><br><pre> <code class="plaintext hljs">$streams.add(@{ymxId=$ymxstream;cinputStream=$cipipe;sinputStream=$sipipe;coutputStream=$copipe;soutputStream=$sopipe;asyncobj=$AsyncJobResult;psobj=$PS;readjob=$null;readbuffer=$readbuffer}) | out-null</code> </pre> <br>  <b>Traitement des donn√©es Yamux</b> <br><br>  Lors de la r√©ception des donn√©es destin√©es √† tout flux de chaussettes du serveur yamux, nous devons d√©terminer le num√©ro du flux yamux (le nombre de flux de chaussettes auquel ces donn√©es sont destin√©es) et le nombre d'octets de donn√©es de l'en-t√™te yamux de 12 octets: <br><br><pre> <code class="plaintext hljs">$ymxstream = [bitconverter]::ToInt32($buffer[7..4],0) $ymxcount = [bitconverter]::ToInt32($buffer[11..8],0)</code> </pre> <br>  Ensuite, √† partir du flux ArrayList, en utilisant le champ ymxId, nous obtenons les gestionnaires du serveur sortant correspondant √† ce flux de chaussettes: <br><br><pre> <code class="plaintext hljs"> if ($streams.Count -gt 1){$streamind = $streams.ymxId.IndexOf($ymxstream)} else {$streamind = 0} $outStream = $streams[$streamind].soutputStream</code> </pre> <br>  Apr√®s cela, nous lisons les donn√©es du socket, en nous rappelant que nous devons lire un certain nombre d'octets dans la boucle: <br><br><pre> <code class="plaintext hljs"> $databuffer = $null $tnum = 0 do { if ($buffer.length -le ($ymxcount-$tnum)) { $num = $tcpStream.Read($buffer,0,$buffer.Length) }else { $num = $tcpStream.Read($buffer,0,($ymxcount-$tnum)) } $tnum += $num $databuffer += $buffer[0..($num-1)] }while ($tnum -lt $ymxcount -and $tcpConnection.Connected)</code> </pre> <br>  et √©crivez les donn√©es re√ßues dans le tube correspondant: <br><br><pre> <code class="plaintext hljs">$num = $tcpStream.Read($buffer,0,$ymxcount) $outStream.Write($buffer,0,$ymxcount)</code> </pre> <br><br>  <b>Traitement Yamux FIN - Fin du flux</b> <br><br>  Lorsque nous recevons un paquet du serveur yamix qui signale la fermeture d'un flux, nous obtenons √©galement d'abord le num√©ro du flux yamux √† partir de l'en-t√™te de 12 octets: <br><br><pre> <code class="plaintext hljs"> $ymxstream = [bitconverter]::ToInt32($buffer[7..4],0)</code> </pre> <br>  puis, √† travers une variable partag√©e (ou plut√¥t, un tableau de drapeaux, o√π l'index est le num√©ro de flux yamux), nous signalons au thread socks de se terminer: <br><br><pre> <code class="plaintext hljs">if ($streams.Count -gt 1){$streamind = $streams.ymxId.IndexOf($ymxstream)} else {$streamind = 0} if ($StopFlag[$ymxstream] -eq 0){ write-host "stopflag is 0. Setting to 1" $StopFlag[$ymxstream] = 1 }</code> </pre> <br>  apr√®s avoir d√©fini l'indicateur, avant de tuer le flux de chaussettes, vous devez attendre un certain temps pour que le flux de chaussettes traite cet indicateur.  200 ms suffisent pour cela: <br><br><pre> <code class="plaintext hljs">start-sleep -milliseconds 200 #wait for thread check flag</code> </pre><br>  puis fermez tous les tuyaux li√©s √† ce flux, fermez le Runspace correspondant et tuez l'objet Powershell pour lib√©rer des ressources: <br><br><pre> <code class="plaintext hljs">$streams[$streamind].cinputStream.close() $streams[$streamind].coutputStream.close() $streams[$streamind].sinputStream.close() $streams[$streamind].soutputStream.close() $streams[$streamind].psobj.Runspace.close() $streams[$streamind].psobj.Dispose() $streams[$streamind].readbuffer.clear()</code> </pre> <br>  Apr√®s avoir ferm√© le flux de chaussettes, nous devons supprimer l'√©l√©ment correspondant des flux ArrayList: <br><br><pre> <code class="plaintext hljs">$streams.RemoveAt($streamind)</code> </pre> <br>  Et √† la fin, nous devons forcer le garbage collector .Net √† lib√©rer les ressources utilis√©es par le thread.  Sinon, notre script consommera environ 100-200 Mo de m√©moire, ce qui peut attirer l'attention d'un utilisateur exp√©riment√© et corrosif, mais nous n'en avons pas besoin: <br><br><pre> <code class="plaintext hljs">[System.GC]::Collect()#clear garbage to minimize memory usage</code> </pre> <br><h3>  Script Yamux - flux invers√© </h3><br>  Comme mentionn√© ci-dessus, les donn√©es re√ßues des flux de chaussettes sont trait√©es par un flux yamuxScript distinct, qui d√©marre depuis le tout d√©but (apr√®s une connexion r√©ussie au serveur).  Sa t√¢che consiste √† interroger p√©riodiquement les canaux de sortie des flux de chaussettes situ√©s dans les flux ArrayList $: <br><pre> <code class="plaintext hljs">foreach ($stream in $state.streams){ ... }</code> </pre> <br>  et si elles contiennent des donn√©es, envoyez-les au serveur yamux, apr√®s avoir fourni l'en-t√™te yamux de 12 octets correspondant contenant le num√©ro de la session yamux et le nombre d'octets de donn√©es: <br><br><pre> <code class="plaintext hljs"> if ($stream.readjob -eq $null){ $stream.readjob = $stream.sinputStream.ReadAsync($stream.readbuffer,0,1024) }elseif ( $stream.readjob.IsCompleted ){ #if read asyncjob completed - generate yamux header $outbuf = [byte[]](0x00,0x00,0x00,0x00)+ [bitconverter]::getbytes([int32]$stream.ymxId)[3..0]+ [bitconverter]::getbytes([int32]$stream.readjob.Result)[3..0] $state.tcpstream.Write($outbuf,0,12) #write raw data from socks thread to yamux $state.tcpstream.Write($stream.readbuffer,0,$stream.readjob.Result) $state.tcpstream.flush() #create new readasync job $stream.readjob = $stream.sinputStream.ReadAsync($stream.readbuffer,0,1024) }else{ #write-host "Not readed" }</code> </pre> <br>  YamuxScript surveille √©galement l'indicateur d√©fini dans le tableau $ StopFlag partag√© pour chacun des threads socksScript qui sont ex√©cut√©s.  Cet indicateur peut √™tre d√©fini sur 2 si le serveur distant qui utilise socksScript se d√©connecte.  Dans cette situation, les informations doivent √™tre rapport√©es au client chaussettes.  La cha√Æne est la suivante: yamuxScript doit informer le serveur yamux de la d√©connexion afin qu'il le signale √† son tour au client socks. <br><br><pre> <code class="plaintext hljs">if ($StopFlag[$stream.ymxId] -eq 2){ $stream.ymxId | out-file -Append c:\work\log.txt $outbuf = [byte[]](0x00,0x01,0x00,0x04)+ [bitconverter]::getbytes([int32]$stream.ymxId)[3..0]+ [byte[]](0x00,0x00,0x00,0x00) $state.tcpstream.Write($outbuf,0,12) $state.tcpstream.flush() }</code> </pre> <br><h3>  Mise √† jour de la fen√™tre Yamux </h3><br>  De plus, yamuxScript doit surveiller le nombre d'octets re√ßus du serveur yamux et envoyer p√©riodiquement un message YMX WinUpdate.  Ce m√©canisme dans Yamux est responsable de la surveillance et de la modification de la soi-disant taille de fen√™tre (similaire au protocole TCP) - le nombre d'octets de donn√©es qui peuvent √™tre envoy√©s sans accus√© de r√©ception.  Par d√©faut, la taille de la fen√™tre est de 256 Ko.  Cela signifie que lors de l'envoi ou de la r√©ception de fichiers ou de donn√©es sup√©rieurs √† cette taille, nous devons envoyer le package de mise √† jour windpw au serveur yamux.  Pour contr√¥ler la quantit√© de donn√©es re√ßues du serveur yamux, un tableau partag√© sp√©cial $ RcvBytes a √©t√© introduit, dans lequel le flux principal en incr√©mentant la valeur actuelle enregistre le nombre d'octets re√ßus du serveur pour chaque flux.  Si le seuil d√©fini est d√©pass√©, yamuxScript doit envoyer un paquet au serveur WinUpdate et r√©initialiser le compteur: <br><br><pre> <code class="plaintext hljs"> if ($RcvBytes[$stream.ymxId] -ge 256144){ #out win update ymx packet with 256K size $outbuf = [byte[]](0x00,0x01,0x00,0x00)+ [bitconverter]::getbytes([int32]$stream.ymxId)[3..0]+ (0x00,0x04,0x00,0x00) $state.tcpstream.Write($outbuf,0,12) $RcvBytes[$stream.ymxId] = 0 }</code> </pre> <br><h3>  SocksScript Streams </h3><br>  Passons maintenant directement √† socksScript lui-m√™me. <br>  Rappelons que socksScript est invoqu√© de mani√®re asynchrone: <br><br><pre> <code class="plaintext hljs">$state = [PSCustomObject]@{"StreamID"=$ymxstream;"inputStream"=$cipipe;"outputStream"=$copipe} $PS = [PowerShell]::Create() .... $AsyncJobResult = $PS.BeginInvoke()</code> </pre> <br>  et au moment de l'appel, les donn√©es suivantes sont pr√©sentes dans la variable $ state transf√©r√©e au flux: <br><br><ul><li>  $ state.streamId - num√©ro de session yamux; </li><li>  $ state.inputStream - lire le tube; </li><li>  $ state.oututStream - √©crire un tube; </li></ul><br>  Les donn√©es dans les tuyaux sont fournies sous forme brute sans en-t√™tes yamux, c'est-√†-dire  sous la forme dans laquelle ils provenaient du client chaussettes. <br><br>  √Ä l'int√©rieur de socksScript, tout d'abord, nous devons d√©terminer la version des chaussettes et nous assurer qu'elle est de 5: <br><br><pre> <code class="plaintext hljs">$state.inputStream.Read($buffer,0,2) | Out-Null $socksVer=$buffer[0] if ($socksVer -eq 5){ ... }</code> </pre> <br>  Eh bien, nous faisons exactement ce qui est impl√©ment√© dans le script Invoke-SocksProxy.  La seule diff√©rence sera qu'au lieu d'appels <br><br><pre> <code class="plaintext hljs">$AsyncJobResult.AsyncWaitHandle.WaitOne(); $AsyncJobResult2.AsyncWaitHandle.WaitOne();</code> </pre> <br>  Il est n√©cessaire de surveiller la connexion tcp et l'indicateur de terminaison correspondant dans le tableau $ StopFlag en mode cyclique, sinon nous ne pourrons pas reconna√Ætre la situation de la fin de la connexion du c√¥t√© du client socks et du serveur ymux: <br><br><pre> <code class="plaintext hljs">while ($StopFlag[$state.StreamID] -eq 0 -and $tmpServ.Connected ){ start-sleep -Milliseconds 50 }</code> </pre> <br>  Dans le cas o√π la connexion se termine du c√¥t√© TCP du serveur auquel nous nous connectons, nous d√©finissons cet indicateur sur 2, ce qui am√®nera yamuxscript √† le reconna√Ætre et √† envoyer le paquet ymx FIN correspondant au serveur yamux: <br><br><pre> <code class="plaintext hljs">if ($tmpServ.Connected){ $tmpServ.close() }else{ $StopFlag[$state.StreamID] = 2 }</code> </pre> <br>  Nous devons √©galement d√©finir cet indicateur si socksScript ne peut pas se connecter au serveur de destination: <br><br><pre> <code class="plaintext hljs">if($tmpServ.Connected){ ... } else{ $buffer[1]=4 $state.outputStream.Write($buffer,0,2) $StopFlag[$state.StreamID] = 2 }</code> </pre> <br><h3>  Conclusion de la deuxi√®me partie </h3><br>  Au cours de nos recherches de codage, nous avons r√©ussi √† cr√©er un client PowerShell pour notre serveur RsocksTun avec la capacit√©: <br><br><ul><li>  Connexions SSL </li><li>  autorisation sur le serveur; </li><li>  travailler avec yamux-server avec le support des pings keepalive; </li><li>  mode de fonctionnement multithread; </li><li>  prise en charge du transfert de fichiers volumineux; </li></ul><br>  En dehors de l'article, il y avait une impl√©mentation de la fonctionnalit√© de connexion via un serveur proxy et d'autorisation sur celui-ci, ainsi que la transformation de notre script en une version en ligne, qui peut √™tre ex√©cut√©e √† partir de la ligne de commande.  Ce sera dans la troisi√®me partie. <br><br>  C'est tout pour aujourd'hui.  Comme ils disent - abonnez-vous, laissez des commentaires (en particulier concernant vos r√©flexions sur l'am√©lioration du code et l'ajout de fonctionnalit√©s). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr453970/">https://habr.com/ru/post/fr453970/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr453958/index.html">Monorepositoires: veuillez</a></li>
<li><a href="../fr453960/index.html">Global DevOps Bootcamp 2019 √† Moscou</a></li>
<li><a href="../fr453962/index.html">RxSwift et Coroutines chez Kotlin - d√©veloppement mobile optionnel d'AGIMA et GeekBrains</a></li>
<li><a href="../fr453964/index.html">POO en langue R (partie 1): classes S3</a></li>
<li><a href="../fr453968/index.html">D√©sapprendre les pratiques de r√©vision des codes toxiques</a></li>
<li><a href="../fr453972/index.html">Les arch√©ologues recr√©ent une √©pingle vieille de deux mille ans √† l'aide de l'impression et de la num√©risation 3D</a></li>
<li><a href="../fr453974/index.html">Concurrence des syst√®mes ML sur le mat√©riel linguistique. Comment avons-nous appris √† remplir les blancs</a></li>
<li><a href="../fr453976/index.html">Programme √©ducatif √©conomique pour les informaticiens</a></li>
<li><a href="../fr453978/index.html">L'imprimante 3D de construction MIT imprime un b√¢timent en 14 heures</a></li>
<li><a href="../fr453980/index.html">Impression d'√©tiquettes et d'√©tiquettes de prix pour la boutique en ligne .net</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>