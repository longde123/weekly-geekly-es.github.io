<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ß ü§úüèª üë®üèø‚Äçüî¨ Punktsegmentierungsmethoden in Punktwolken üßòüèº üéã üçÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 


 Vor einiger Zeit musste ich das Problem der Segmentierung von Punkten in einer Punktwolke l√∂sen (Punktwolken sind Daten, die von Lidars...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Punktsegmentierungsmethoden in Punktwolken</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459088/"><h4 id="vvedenie">  Einf√ºhrung </h4><br><p>  Vor einiger Zeit musste ich das Problem der Segmentierung von Punkten in einer Punktwolke l√∂sen (Punktwolken sind Daten, die von Lidars erhalten wurden). </p><br><p>  Beispieldaten und die zu l√∂sende Aufgabe: <br><img src="https://habrastorage.org/webt/4m/af/zd/4mafzdmkubse90xn2vgxazge90y.png" alt="Beispieldaten"></p><br><p>  Die Suche nach einem allgemeinen √úberblick √ºber bestehende Methoden war erfolglos, so dass ich selbst Informationen sammeln musste.  Sie k√∂nnen das Ergebnis sehen: Hier sind die wichtigsten und meiner Meinung nach wichtigsten Artikel der letzten Jahre zusammengefasst.  Alle betrachteten Modelle l√∂sen das Problem der Segmentierung einer Punktwolke (zu welcher Klasse jeder Punkt geh√∂rt). </p><br><p>  Dieser Artikel ist n√ºtzlich f√ºr diejenigen, die mit neuronalen Netzen vertraut sind und verstehen m√∂chten, wie sie auf unstrukturierte Daten (z. B. Diagramme) angewendet werden. </p><a name="habracut"></a><br><h4 id="suschestvuyuschie-datasety">  Vorhandene Datens√§tze </h4><br><p>  Jetzt im √∂ffentlichen Bereich gibt es die folgenden Datens√§tze zu diesem Thema: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stanford Large-Scale 3DIndoor Spaces Dataset (S3DIS)</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beschriftete</a> Szenen in Geb√§uden </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ScanNet</a> - Beschriftete Szenen in Geb√§uden </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NYUV2</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Markierte</a> Szenen in Geb√§uden </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ShapeNet</a> - Objekte unterschiedlicher Form </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ModelNet40</a> - Objekte unterschiedlicher Form </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SHREC15</a> - verschiedene Posen von Tieren und Menschen </li></ul><br><h4 id="osobennosti-raboty-s-point-clouds">  Funktionen der Arbeit mit Punktwolken </h4><br><p>  Neuronale Netze sind vor kurzem in dieses Gebiet gekommen.  Und Standardarchitekturen wie vollst√§ndig verbundene und Faltungsnetzwerke sind nicht anwendbar, um dieses Problem zu l√∂sen.  Warum? </p><br><p>  Weil die Reihenfolge der Punkte hier nicht wichtig ist.  Ein Objekt besteht aus einer Reihe von Punkten, und es spielt keine Rolle, in welcher Reihenfolge sie angezeigt werden.  Wenn jedes Pixel seinen Platz im Bild hat, k√∂nnen wir die Punkte sicher mischen und das Objekt √§ndert sich nicht.  Das Ergebnis von Standard-Neuronalen Netzen h√§ngt im Gegensatz dazu vom Ort der Daten ab.  Wenn Sie Pixel auf das Bild mischen, erhalten Sie ein neues Objekt. </p><br><p>  Nun wollen wir sehen, wie sich neuronale Netze angepasst haben, um dieses Problem zu l√∂sen. </p><br><h4 id="naibolee-vazhnye-stati">  Wichtigste Artikel </h4><br><p>  In diesem Bereich gibt es nicht viele grundlegende Architekturen.  Wenn Sie mit Grafiken oder unstrukturierten Daten arbeiten m√∂chten, m√ºssen Sie eine Vorstellung von den folgenden Modellen haben: </p><br><ul><li>  Pointnet </li><li>  PointNet ++ </li><li>  DGCNN </li></ul><br><p>  Betrachten wir sie genauer. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PointNet: Deep Learning zu Punktmengen f√ºr die 3D-Klassifizierung und -Segmentierung</a> <br>  Pioniere bei der Arbeit mit unstrukturierten Daten. <br><ul><li>  wie sie sich entscheiden: Der Artikel beschreibt zwei Modelle: zur Segmentierung von Punkten und zur Klassifizierung eines Objekts.  Der allgemeine Teil besteht aus folgenden Bl√∂cken: <br><ul><li>  ein Netzwerk zur Bestimmung der Transformation (√úbersetzung des Koordinatensystems), das dann f√ºr alle Punkte gilt </li><li>  Transformation wird auf jeden Punkt einzeln angewendet (regul√§rer Perzeptor) </li><li>  maxpooling, das Informationen aus verschiedenen Punkten kombiniert und einen globalen Merkmalsvektor f√ºr das gesamte Objekt erstellt. </li><li>  dann beginnen die Unterschiede zwischen den Modellen: <br><ol><li>  Klassifizierungsmodell: Ein globaler Merkmalsvektor wird an die Eingabe einer vollst√§ndig verbundenen Ebene gesendet, um die Klasse der gesamten Punktwolke zu bestimmen </li><li>  Modell f√ºr die Segmentierung: Der globale Merkmalsvektor und die berechneten Merkmale f√ºr jeden Punkt gehen zur Eingabe der vollst√§ndig verbundenen Ebene, die die Klasse f√ºr jeden Punkt definiert. </li></ol></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code</a> </li></ul></li></ul><br><p><img src="https://habrastorage.org/webt/fu/pv/wi/fupvwi8uf8d2pcvxbvh9ahttf5s.png" alt="PointNet-Architektur"></p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PointNet ++: Deep Hierarchical Feature Learning f√ºr Punktmengen in einem metrischen Raum</a> <br>  Die gleichen Leute aus Stanford, die PointNet beschrieben haben. <br><ul><li>  wie sie sich entscheiden: pointNet wird rekursiv auf kleinere Subwolken angewendet, √§hnlich wie Faltungsnetzwerke.  Das hei√üt, W√ºrfel teilen den Raum, PointNet wird auf jeden angewendet, dann bestehen neue W√ºrfel aus diesen W√ºrfeln.  Auf diese Weise k√∂nnen Sie lokale Anzeichen daf√ºr hervorheben, dass die vorherige Version des Netzwerks verloren gegangen ist. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code</a> </li></ul></li></ul><br><p><img src="https://habrastorage.org/webt/py/pj/it/pypjitwxitebw0losh7ucvr43fu.png" alt="PointNet ++ Architektur"></p><br><ul><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dynamisches Diagramm CNN zum Lernen auf Punktwolken</a> </p><br><ul><li><p>  wie sie sich entscheiden: Basierend auf den verf√ºgbaren Punkten wird ein Diagramm erstellt: Die Eckpunkte sind Punkte, Kanten existieren nur zwischen dem aktuellen Punkt und den k Punkten, die ihm am n√§chsten liegen.  Als n√§chstes wird Edge Conv definiert - eine spezielle Faltung an Kanten, die vom aktuellen Punkt kommen.  Der Artikel bietet verschiedene Optionen f√ºr diese Faltung.  Als Ergebnis haben wir Folgendes verwendet: F√ºr jeden Punkt <em>x [i]</em> entlang aller seiner <em>J</em> benachbarten Punkte wurden M Vorzeichen als <em>Merkmal [i, m] = max_j (Relu (Œ∏ [m] ‚àó (x [i] - x [j]) + œÜ betrachtet [m] ‚àó x [i]))</em> .  Der empfangene Wert wird als neue Einbettung eines Punktes gespeichert.  Hier werden lokale <em>(x [j] - x [i])</em> und globale <em>(x [j])</em> Koordinaten als Eingabe f√ºr die Faltung verwendet. <br>  Nachdem die Faltung in der Grafik definiert wurde, wird ein Faltungsnetzwerk aufgebaut.  Sie k√∂nnen auch die Anzahl der Transformationen und ihre Anwendung auf jeden Punkt feststellen, √§hnlich wie bei PointNet. <br>  In diesem Artikel finden Sie einen hervorragenden √úberblick √ºber andere L√∂sungsmethoden. </p><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code</a> </p><br></li></ul><br></li></ul><br><p><img src="https://habrastorage.org/webt/0w/lp/hm/0wlphmzbejgym-a_suxjd38tea4.png" alt="DGCNN-Architektur"></p><br><h4 id="stati-na-osnove-pointnet-i-pointnet">  Artikel basierend auf PointNet und PointNet ++: </h4><br><p>  Die meisten Artikel unterscheiden sich hinsichtlich der Fehleranzahl oder der Tiefe und Komplexit√§t komplexer Bl√∂cke. </p><br><ul><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PointWise: Ein unbeaufsichtigtes punktuelles Feature-Learning-Netzwerk</a> <br>  Merkmal der Arbeit - Ausbildung ohne Lehrer </p><br><ul><li>  wie sie sich entscheiden: F√ºr jeden Punkt wird der Vektor der Einbettungen trainiert, durch den sie dann segmentiert werden. <br>  Das Hauptpostulat des Artikels lautet, dass √§hnliche Objekte trotz ihrer Abgelegenheit √§hnliche Einbettungen aufweisen sollten (z. B. zwei verschiedene Beine eines Stuhls).  PointNet wird als Basismodell verwendet.  Die Hauptinnovation ist die Fehlerfunktion.  Es besteht aus zwei Teilen: Rekonstruktionsfehlern und Gl√§ttungsfehlern. <br>  Der Rekonstruktionsfehler verwendet Punktkontextinformationen.  Ihre Aufgabe ist es, die Einbettung von Punkten mit demselben geometrischen Kontext √§hnlich zu gestalten.  Zur Berechnung werden basierend auf dem Einbettungsvektor f√ºr den ausgew√§hlten Punkt neue Punkte in der N√§he generiert.  Das hei√üt, die Merkmalsbeschreibung des Punkts sollte Informationen √ºber die Form des Objekts um den Punkt enthalten.  √úberlegen Sie als N√§chstes, wie stark die generierten Punkte aus der tats√§chlichen Form des Objekts herausfallen. <br>  Der Gl√§ttungsfehler wird ben√∂tigt, damit die Einbettungen an den benachbarten Punkten √§hnlich und an den entfernten Punkten anders sind.  Das Sch√∂nste dabei ist die Messung der N√§he, nicht nur als Norm zwischen zwei Punkten im euklidischen Raum, sondern auch die Z√§hlung der Entfernung durch die Punkte des Objekts.  F√ºr jeden Punkt wird ein Punkt aus k am n√§chsten und aus k weiter ausgew√§hlt. <br>  Die aktuelle Einbettung sollte um einen gewissen <em>Abstand</em> n√§her am n√§chsten Minimum liegen als zuvor. </li></ul><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SGPN: √Ñhnlichkeitsgruppen-Vorschlagsnetzwerk f√ºr die Segmentierung von 3D-Punktwolkeninstanzen</a> </p><br><ul><li>  wie sie sich entscheiden: Wie in PointWise ist hier das Interessanteste bei der Berechnung des Fehlers.  PointNet ++ ist die Basis. Zuerst betrachten wir den Merkmalsvektor und das Objekt geh√∂ren zu jedem Punkt einzeln, analog zu PointNet ++. <br>  Als n√§chstes betrachten wir basierend auf den Merkmalen 3 Matrizen (√Ñhnlichkeit, Vertrauen und Segmentierung). <br>  Der Lernfehler ist die Summe von drei Fehlern, die durch die entsprechenden Matrizen berechnet werden: <em>L = L1 + L2 + L3</em> <br>  Sei N die Anzahl der Punkte <br>  √Ñhnlichkeitsmatrix - Quadrat, Gr√∂√üe N * N.  Das Element am Schnittpunkt der i-ten Zeile und der j-ten Spalte gibt an, ob diese Punkte zum selben Objekt geh√∂ren oder nicht.  Punkte, die zum selben Objekt geh√∂ren, m√ºssen √§hnliche Merkmalsvektoren haben.  Elemente der Matrix k√∂nnen einen von drei Werten annehmen: Punkte i und j geh√∂ren zu einem Objekt, Punkte geh√∂ren zu einer Klasse von Objekten, aber zu verschiedenen Objekten (sowohl dieser als auch dieser Stuhl, aber die St√ºhle sind unterschiedlich) oder dies sind im Allgemeinen Punkte von Objekten verschiedener Klassen.  Diese Matrix wird nach wahren Werten berechnet. <br><img src="https://habrastorage.org/webt/s2/wl/uj/s2wlujchehww4peistxr6_l79go.png" alt="√Ñhnlichkeitsfehler"><br>  Die Konfidenzmatrix ist ein Vektor der L√§nge N. F√ºr jeden Punkt wird der Schnittpunkt √ºber der Vereinigung (IoU) zwischen der Menge von Punkten, die gem√§√ü der Arbeit unseres Algorithmus zum Objekt geh√∂ren, und der Menge von Punkten, die tats√§chlich zum Objekt mit dem aktuellen Punkt geh√∂ren, ber√ºcksichtigt.  Der Fehler ist einfach die L2-Norm zwischen der Wahrheit und der berechneten Matrix.  Das hei√üt, das Netzwerk versucht vorherzusagen, wie sicher es bei der Klassenvorhersage f√ºr Punkte auf einem Objekt ist. <br>  Die Segmentierungsmatrix hat eine Gr√∂√üe - N * die Anzahl der Klassen.  Der Fehler wird hier als Kreuzentropie im Mehrklassenklassifizierungsproblem betrachtet. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code</a> </li></ul><br></li></ul><br><p><img src="https://habrastorage.org/webt/m8/6r/ra/m86rrazo6hfvzrufhy5uyihgnui.png" alt="SGPN-Architektur"></p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wissen, was Ihre Nachbarn tun: 3D-semantische Segmentierung von Punktwolken</a> <br><ul><li>  wie sie sich entscheiden: Zuerst betrachten sie die Zeichen f√ºr eine lange Zeit, komplizierter als in PointNet, mit einer Reihe von Restverbindungen und Betr√§gen, aber im Allgemeinen - das Gleiche.  Ein kleiner Unterschied - sie z√§hlen die Vorzeichen f√ºr jeden Punkt in globalen und lokalen Koordinaten. <br>  Der Hauptunterschied ist hier wieder die Fehlerzahl.  Dies ist keine Standard-Crossentropie, sondern die Summe zweier Fehler: <br><ol><li>  paarweiser Abstandsverlust - Punkte von einem Objekt sollten n√§her als <em>œÑ_near sein</em> und Punkte von verschiedenen Objekten sollten l√§nger als <em>œÑ_far sein</em> . <br><img src="https://habrastorage.org/webt/xu/4j/ye/xu4jyel_d_sf9biwtupxtlultzu.png" alt="paarweiser Abstandsverlust"></li><li>  Schwerpunktverlust - Punkte von einem Objekt sollten nahe beieinander liegen </li></ol></li></ul></li></ul><br><h4 id="stati-na-osnove-dgcnn">  DGCNN-basierte Artikel: </h4><br><p>  DGCNN wurde k√ºrzlich (2018) ver√∂ffentlicht, daher gibt es nur wenige Artikel, die auf dieser Architektur basieren.  Ich m√∂chte Ihre Aufmerksamkeit auf eine Sache lenken: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verkn√ºpfter dynamischer Graph CNN: Lernen in der Punktwolke durch Verkn√ºpfen hierarchischer Merkmale</a> <br><ul><li>  wie sie sich entscheiden: komplizierte die urspr√ºngliche Architektur, f√ºgte verbleibende Verbindungen hinzu </li></ul></li></ul><br><p><img src="https://habrastorage.org/webt/ov/zk/h7/ovzkh78zz0cnczzdp0notx8u6ea.png" alt="Verkn√ºpfte DGCNN-Architektur"></p><br><h4 id="zaklyuchenie">  Fazit </h4><br><p>  Hier finden Sie kurze Informationen zu modernen Methoden zur L√∂sung von Klassifizierungs- und Segmentierungsproblemen in Punktwolken.  Es gibt zwei Hauptmodelle (PointNet ++, DGCNN), deren Modifikationen jetzt zur L√∂sung dieser Probleme verwendet werden.  In den meisten F√§llen wird zur √Ñnderung die Fehlerfunktion ge√§ndert, und diese Architekturen werden durch Hinzuf√ºgen von Ebenen und Verkn√ºpfungen kompliziert. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459088/">https://habr.com/ru/post/de459088/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459078/index.html">CERN wechselt zu Open Source Software - warum?</a></li>
<li><a href="../de459080/index.html">Features HttpUrlConnection von java.net</a></li>
<li><a href="../de459082/index.html">Wer sind Eidetiker, wie falsche Erinnerungen funktionieren und drei popul√§re Mythen √ºber das Ged√§chtnis</a></li>
<li><a href="../de459084/index.html">Ein wenig √ºber Google Home Hub oder wie ich einen Fotorahmen f√ºr 130 Euro gekauft habe</a></li>
<li><a href="../de459086/index.html">Statische Verteilung von FreeRTOS-Objekten</a></li>
<li><a href="../de459090/index.html">Bringen Sie Ihre Linux-Entwicklungserfahrung in Windows mit WSL und Visual Studio Code Remote auf die n√§chste Stufe</a></li>
<li><a href="../de459092/index.html">X.Spectator - Status√ºberwachung in .NET</a></li>
<li><a href="../de459094/index.html">C # oder Java? TypeScript oder JavaScript? Auf maschinellem Lernen basierende Klassifizierung von Programmiersprachen</a></li>
<li><a href="../de459098/index.html">GitHub Package Registry unterst√ºtzt Swift-Pakete</a></li>
<li><a href="../de459100/index.html">GitHub Package Registry unterst√ºtzt Swift-Pakete</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>