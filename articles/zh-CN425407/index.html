<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕹️ 👨🏾‍🤝‍👨🏽 🤲 Firecore-AVR上的有趣游戏 💰 📋 🍝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我想分享另一个晚上的长期建设，这表明即使在较弱的硬件上也可以制作游戏。 

 关于您必须做的事情，如何确定的事情以及如何做的事情不只是另一个Pong克隆而已-欢迎来到Cat。 

 警告：精美的文章，大量的访问量和多个代码插入！ 

 简要介绍游戏  射击他们！ -现在在AVR上。 

 实际上，这...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Firecore-AVR上的有趣游戏</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425407/"><img src="https://habrastorage.org/webt/dv/yz/hr/dvyzhr-e4xxmj6jbln7ngiti5d0.png"><br><br> 我想分享另一个晚上的长期建设，这表明即使在较弱的硬件上也可以制作游戏。 <br><br> 关于您必须做的事情，如何确定的事情以及如何做的事情不只是另一个Pong克隆而已-欢迎来到Cat。 <br><br> 警告：精美的文章，大量的访问量和多个代码插入！ <br><a name="habracut"></a><br><h3> 简要介绍游戏 </h3><hr> 射击他们！  -现在在AVR上。 <br><br> 实际上，这是另一张地图，因此主角<s>谢泼德（Shepard）</s>必须再次拯救银河系，使其免受未知人物的突然袭击，使其穿越太空，穿过小行星的恒星和田野，同时清除每个恒星系统。 <br> 整个游戏都是用C和C ++编写的，而没有使用Arduino的Wire库。 <br><br> 该游戏有4艘船可供选择（通过后即可使用），每艘船都有自己的特点： <br><ul><li> 可操作性 </li><li> 耐久性 </li><li> 枪的力量。 </li></ul><br> 还实现了： <br><ul><li>  2D彩色图形； </li><li> 为武器加电； </li><li> 末级老板 </li><li> 小行星的水平（及其旋转动画）； </li><li> 背景颜色发生一定程度的变化（而不仅仅是黑色空间）； </li><li> 恒星在背景中以不同速度运动（以影响深度）； </li><li> 计分并保存在EEPROM中; </li><li> 相同的声音（射击，爆炸等）； </li><li> 完全相同的对手。 </li></ul><br><h3> 平台平台 </h3><hr> 幽灵的归来。 <br><br><blockquote> 我将事先澄清一下，该平台应该被视为<s>第一</s>代第三代（80年代， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">shiru8bit</a> ）的旧游戏机。 <br></blockquote><br> 另外，禁止在原始硬件上进行硬件修改，以确保在其他任何相同的板上立即启动。 <br> 这款游戏是为Arduino Esplora主板编写的，但我认为转移到GBA或任何其他平台并不难。 <br> 但是，即使在此资源上，该委员会也只被覆盖了两次，尽管每个委员会的社区很大，但其他委员会根本不值得一提： <br><ul><li>  GameBuino META： </li><li> 波基托 </li><li>  makerBuino; </li><li>  Arduboy； </li><li>  UzeBox / FuzeBox; </li><li> 还有很多其他 </li></ul><br> 首先，Esplora上没有的功能： <br><ul><li> 大量内存（ROM 28kb，RAM 2.5kb）; </li><li> 电源（16 MHz时为8位CPU）; </li><li>  DMA </li><li> 字符生成器； </li><li> 分配的存储区或特殊寄存器。 目的地（调色板，图块，背景等）； </li><li> 控制屏幕的亮度（哦，垃圾桶里有这么多效果）； </li><li> 地址空间扩展器（映射器）； </li><li> 调试器（ <s>但是在整个屏幕上谁需要它！</s> ）。 </li></ul><br> 我将继续存在以下事实： <br><ul><li> 硬件SPI（可以以F_CPU / 2速度运行）; </li><li> 屏幕基于ST7735 160x128 1.44“； </li><li> 少量计时器（仅4个）； </li><li> 一小撮GPIO; </li><li> 少数几个按钮（5个+两轴操纵杆）； </li><li> 传感器很少（照明，加速度计，温度计）； </li><li> 压电蜂鸣器<s>刺激</s>发射器。 </li></ul><br> 显然那里几乎没有。 毫无疑问，除了傍克隆人和这段时间里的三场比赛之外，没有人愿意对她做任何事！ <br> 也许事实是，在ATmega32u4控制器（及类似产品）下进行编写类似于为Intel 8051编写程序（在发布时已使用了近40年），在该程序中您需要观察大量条件并采取各种技巧。 <br><br><h3> 周边加工 </h3><hr> 一应俱全！ <br><br> 查看电路后，可以清楚地看到所有外设都通过GPIO扩展器（74HC4067D多路复用器和其他MUX）连接，并使用GPIO PF4，PF5，PF6，PF7或高级PORTF半字节进行切换，并且在GPIO-PF1上读取了MUX输出。 <br> 通过简单地通过掩码将值分配给PORTF端口来切换输入非常方便，绝不要忘记次要字节： <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> getAnalogMux(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> chMux) { MUX_PORTX = ((MUX_PORTX &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>) | ((chMux&lt;&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>)&amp;<span class="hljs-number"><span class="hljs-number">0xF0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> readADC(); }</code> </pre> <br> 按钮点击民意调查： <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_MIN_LVL 800 bool readSwitchButton(uint8_t btn) { bool state = true; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(getAnalogMux(btn) &gt; SW_BTN_MIN_LVL) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// low state == pressed state = false; } return state; }</span></span></span></span></code> </pre><br> 以下是端口F的值： <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_1_MUX 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_2_MUX 8 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_3_MUX 4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_4_MUX 12</span></span></code> </pre><br> 通过添加一些： <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUTTON_A SW_BTN_4_MUX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUTTON_B SW_BTN_1_MUX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUTTON_X SW_BTN_2_MUX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUTTON_Y SW_BTN_3_MUX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> buttonIsPressed(a) readSwitchButton(a)</span></span></code> </pre><br> 您可以安全地采访正确的十字架： <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateBtnStates</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buttonIsPressed(BUTTON_A)) btnStates.aBtn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buttonIsPressed(BUTTON_B)) btnStates.bBtn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buttonIsPressed(BUTTON_X)) btnStates.xBtn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buttonIsPressed(BUTTON_Y)) btnStates.yBtn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br> 请注意，先前的状态不会重置，否则您可能会错过按下键的事实（它也可以防止颤动）。 <br><br><h3> 特效 </h3><hr> 嗡嗡声。 <br><br> 如果没有DAC，没有Yamaha的芯片，并且只有1位PWM矩形，该怎么办？ <br> 乍一看似乎还不多，但是尽管如此，狡猾的PWM在这里还是用来重新创建“ PDM音频”技术的，您可以借助它来做到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这一点。</a> <br><br>  Gamebuino的库提供了类似的功能，所需要的只是将弹出式生成器传输到另一个GPIO，并将计时器传输到Esplora（timer4和OCR4D输出）。 为了正确操作，timer1还用于产生中断，并用新数据重载OCR4D寄存器。 <br><br>  Gamebuino引擎使用声音模式（就像在跟踪器音乐中一样），可以节省很多空间，但是您需要自己进行所有采样，因为没有现成的库。 <br> 值得一提的是，该引擎的更新周期约为1/50秒或20帧/秒。 <br><br> 为了读取声音模式，在阅读了音频格式的Wiki之后，我在Qt上绘制了一个简单的GUI。 它不会以相同的方式输出声音，但是提供了有关音色如何发声的大致概念，并允许您加载，保存和编辑它。 <br><br><h3> 图形 </h3><hr> 不朽的Pixelart。 <br><br> 显示器将颜色编码为两个字节（RGB565），但是由于这种格式的图像会占用大量空间，因此所有这些图像都已通过调色板进行索引以节省空间，这在我之前的文章中已经多次说明。 <br> 与Famicom / NES不同，图像没有颜色限制，调色板中有更多颜色可用。 <br><br> 游戏中的每个图像都是一个字节数组，其中存储以下数据： <br><ul><li> 宽度，高度； </li><li> 开始数据标记； </li><li> 字典（如果有的话，稍后再讲）； </li><li> 有效载荷 </li><li> 数据标记结束。 </li></ul><br> 例如，这样的图片（放大10倍）： <br><img src="https://habrastorage.org/webt/zk/rr/es/zkrresh27swmtvck9fagoemando.png"><br><br> 在代码中它将如下所示： <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pic_t</span></span> weaponLaserPic1[] PROGMEM = { <span class="hljs-number"><span class="hljs-number">0x0f</span></span>,<span class="hljs-number"><span class="hljs-number">0x07</span></span>, <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-number"><span class="hljs-number">0x8f</span></span>,<span class="hljs-number"><span class="hljs-number">0x32</span></span>,<span class="hljs-number"><span class="hljs-number">0xa2</span></span>,<span class="hljs-number"><span class="hljs-number">0x05</span></span>,<span class="hljs-number"><span class="hljs-number">0x8f</span></span>,<span class="hljs-number"><span class="hljs-number">0x06</span></span>,<span class="hljs-number"><span class="hljs-number">0x22</span></span>,<span class="hljs-number"><span class="hljs-number">0x41</span></span>,<span class="hljs-number"><span class="hljs-number">0xad</span></span>,<span class="hljs-number"><span class="hljs-number">0x03</span></span>,<span class="hljs-number"><span class="hljs-number">0x41</span></span>,<span class="hljs-number"><span class="hljs-number">0x22</span></span>,<span class="hljs-number"><span class="hljs-number">0x8f</span></span>,<span class="hljs-number"><span class="hljs-number">0x06</span></span>,<span class="hljs-number"><span class="hljs-number">0xa2</span></span>,<span class="hljs-number"><span class="hljs-number">0x05</span></span>, <span class="hljs-number"><span class="hljs-number">0x8f</span></span>,<span class="hljs-number"><span class="hljs-number">0x23</span></span>,<span class="hljs-number"><span class="hljs-number">0xff</span></span>, };</code> </pre><br> 在没有这种类型的船只的地方？ 经过数百个像素差异的测试草图后，只有这些船只可供玩家使用： <br><img src="https://habrastorage.org/webt/ao/4y/jm/ao4yjmxt3bl3ydqrjajnmgy4ms8.png"><br> 值得注意的是，船上的瓷砖没有火焰（此处为清楚起见），将其单独应用以创建引擎排气的动画。 <br><br> 不要忘了每艘船的飞行员： <br><img src="https://habrastorage.org/webt/fk/fj/xf/fkfjxfoscgeu69pabaolb4zt6mo.png"><br><br> 敌方舰只的变异不会太大，但我要提醒你，空间不算太大，所以这里有三艘舰： <br><img src="https://habrastorage.org/webt/w2/-v/o3/w2-vo3itdzkpoptpywwgjn5ytc8.png"><br><br> 如果没有通过改善武器和恢复健康的形式获得正规奖励，玩家将不会持续很长时间： <br><img src="https://habrastorage.org/webt/kw/gw/7d/kwgw7duf5hnztuobgg_pwclk8nm.png"><br><br> 当然，随着枪支功率的增加，发射的炮弹类型也会发生变化： <br><img src="https://habrastorage.org/webt/yq/dn/67/yqdn67u3cvbmzbn0j46v9iiievy.png"><br><br> 就像一开始写的那样，游戏有一个小行星的等级，它紧随第二个boss之后。 有趣的是，有许多不同大小的移动和旋转对象。 另外，当玩家击中它们时，它们会部分塌陷，尺寸变小。 <br><blockquote> 提示：大型小行星可获得更多积分。 <br></blockquote><br><img src="https://habrastorage.org/webt/d6/hg/9a/d6hg9atxd8gzj9m9njyhac4i7bq.gif"><br><img src="https://habrastorage.org/webt/ow/pv/yf/owpvyfbgmn45yueagrafne4w2ng.gif"><br><img src="https://habrastorage.org/webt/jc/eh/r_/jcehr_zvccitvi24lcdmxiiewik.gif"><br> 要创建此简单动画，只需12张小图像即可： <br><img src="https://habrastorage.org/webt/yr/uz/g3/yruzg3mwjlg3bv_z2pljhzyql68.png"><br> 它们针对每种尺寸（大，中，小）分为三个，对于每个旋转角度，您还需要再旋转4个0、90、180和270度角。 在游戏中，以相等的间隔用图像替换指向数组的指针就足够了，从而产生旋转的幻觉。 <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rotateAsteroid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">asteroid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;asteroid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(RN &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) { asteroid.sprite.pPic = getAsteroidPic(asteroid); ++asteroid.angle; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">moveAsteroids</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;asteroid : asteroids) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(asteroid.onUse) { updateSprite(&amp;asteroid.sprite); rotateAsteroid(asteroid); ...</code> </pre><br> 这样做仅是由于缺乏硬件功能，并且像Affine转换这样的软件实现所花费的不仅仅是图像本身，而且非常慢。 <br><br><div class="spoiler">  <b class="spoiler_title">对那些感兴趣的人来说是一块缎子。</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/el/uf/0l/eluf0lkcjsygvumvmosh_yzreig.png"><br> 您可以注意到部分原型，以及只有通过游戏后才能在积分中显示的内容。 <br></div></div><br> 除了简单的图形之外，为了节省空间并添加复古效果，还从字体中删除了小写的字形和最多30个及127个ASCII字节后的字形。 <br><blockquote> 重要！ <br> 不要忘记AVR上的const和constexpr并不意味着数据将存储在程序存储器中，为此，您需要额外使用PROGMEM。 <br> 这是由于AVR内核基于哈佛体系结构，因此需要特殊的CPU访问代码来访问数据。 <br></blockquote><br><h3> 挤压银河系 </h3><hr> 打包最简单的方法是RLE。 <br><br> 研究了打包数据后，您会注意到未使用有效载荷字节中的最高有效位，范围从0x00到0x50。 这使您可以为重复的开始（0x80）添加数据和开始标记，以及下一个字节来指示重复的次数，这使您可以将257个相同的字节（实际上是两个字节的RLE愚蠢的事实加2）打包成两个相同的字节。 <br> 解包器的实现和显示： <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawPico_RLE_P</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pic_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pPic)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> repeatColor; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> tmpInd, repeatTimes; alphaReplaceColorId = getAlphaReplaceColorId(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmpData = getPicSize(pPic, <span class="hljs-number"><span class="hljs-number">0</span></span>); tftSetAddrWindow(x, y, x+tmpData.u8Data1, y+tmpData.u8Data2); ++pPic; <span class="hljs-comment"><span class="hljs-comment">// make offset to picture data while((tmpInd = getPicByte(++pPic)) != PIC_DATA_END) { // get color index or repeat times if(tmpInd &amp; RLE_MARK) { // is it color index? tmpInd &amp;= DATA_MARK; // get color index to repeat repeatTimes = getPicByte(++pPic)+1; // zero RLE does not exist! } ++repeatTimes; // get color from colorTable by color index repeatColor = palette_RAM[(tmpInd == ALPHA_COLOR_ID) ? alphaReplaceColorId : tmpInd]; do { pushColorFast(repeatColor); } while(--repeatTimes); } }</span></span></code> </pre><br> 最主要的是不要在屏幕外显示图像，否则将是垃圾，因为此处没有边框检查。 <br> 测试图像在约39ms内解压缩。 同时占用3040字节，而如果不进行压缩，则将占用11200字节或22400字节（不建立索引）。 <br><br> 测试图像（放大2倍）： <br><img src="https://habrastorage.org/webt/ao/nl/6n/aonl6nxjmfjhbsmp0uc4n6h7w0e.png"><br> 在上图中，您可以看到隔行扫描，但是在屏幕上可以通过硬件对其进行平滑处理，从而产生类似于CRT的效果，同时大大提高了压缩率。 <br><br><h3>  RLE不是万能药 </h3><hr> 我们接受了deja vu的待遇。 <br><br> 如您所知，RLE与类似LZ的包装机配合得很好。  WiKi提供了一系列压缩方法来进行救援。 推动力来自“ GameHut”的视频，内容涉及对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Sonic 3D Blast</a>不可能的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">介绍进行</a>分析<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a> <br> 研究了许多包装工（LZ77，LZW，LZSS，LZO，RNC等）后，我得出的结论是他们的包装工： <br><ul><li> 需要大量RAM用于解压缩的数据（至少64kb。和更多）； </li><li> 笨重且缓慢（有些需要为每个亚基构建霍夫曼树）； </li><li> 压缩比低，窗口小（非常严格的RAM要求）； </li><li> 在许可方面含糊不清。 </li></ul><br> 经过几个月的徒劳修改，决定修改现有的封隔器。 <br> 与类LZ的压缩程序类似，为了实现最大压缩，使用了字典访问，但​​是在字节级别上-字典中最频繁重复的字节对被一个字节指针替换。 <br> 但是有一个陷阱：如何区分“重复次数”和“词典标记”字节？ <br> 长时间坐在一张纸上，并用蝙蝠进行神奇的游戏后，出现了： <br><blockquote><ul><li>  “字典标记”是RLE标记（0x80）+数据字节（0x50）+词典中的位置号； </li><li> 将字节“重复次数”限制为字典标记的大小-1（0xCF）； </li><li> 字典不能使用值0xff（用于图像结尾的标记）。 </li></ul><br></blockquote><br> 应用所有这些，我们得到一个固定的字典大小：不超过46个字节对，RLE减少到209个字节。 显然，并非所有图像都可以像这样打包，但它们将不再可用。 <br> 在这两种算法中，打包图像的结构如下： <br><ul><li> 每个宽度和高度1个字节； </li><li>  1个字节，用于字典的大小，它是指向打包数据开头的标记指针； </li><li> 从0到92个字节的字典； </li><li>  1至N字节的打包数据。 </li></ul><br>  D上产生的packer实用程序（pickoPacker）足以放入带有索引* .png文件的文件夹中，并从终端（或cmd）运行。 如果需要帮助，请使用选项“ -h”或“ --help”运行。 <br> 该实用程序运行后，我们将获得* .h文件，这些文件的内容可方便地传输到项目中的正确位置（因此没有保护）。 <br><br> 在打开包装之前，请准备好屏幕，字典和初始数据： <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawPico_DIC_P</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pic_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pPic)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmpData = getPicSize(pPic, <span class="hljs-number"><span class="hljs-number">0</span></span>); tftSetAddrWindow(x, y, x+tmpData.u8Data1, y+tmpData.u8Data2); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> tmpByte, unfoldPos, dictMarker; alphaReplaceColorId = getAlphaReplaceColorId(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pDict = &amp;pPic[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// save dictionary pointer pPic += getPicByte(&amp;pPic[2]); // make offset to picture data do { unfoldPos = dictMarker = 0; do { if((tmpByte = getPicByte(++pPic)) != PIC_DATA_END) { if(tmpByte &lt; DICT_MARK) { buf_packed[unfoldPos] = tmpByte; } else { dictMarker = 1; setPicWData(&amp;buf_packed[unfoldPos]) = getPicWData(pDict, tmpByte); ++unfoldPos; } ++unfoldPos; } else { break; } } while((unfoldPos &lt; MAX_UNFOLD_SIZE) //&amp;&amp; (unfoldPos) &amp;&amp; ((tmpByte &gt; DATA_MARK) || (tmpByte &gt; MAX_DATA_LENGTH))); if(unfoldPos) { buf_packed[unfoldPos] = PIC_DATA_END; // mark end of chunk printBuf_RLE( dictMarker ? unpackBuf_DIC(pDict) : &amp;buf_packed[0] ); // V2V3 decoder } } while(unfoldPos); }</span></span></code> </pre><br> 读取的数据可以打包在字典中，因此我们检查并解压缩它： <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint8_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPackedMark</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ptr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*ptr &gt;= DICT_MARK) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*(++ptr) != PIC_DATA_END); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint8_t *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unpackBuf_DIC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pDict)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> swap = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> dictMarker = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> getBufferPtr = [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> a[], <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> b[]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> swap ? &amp;a[<span class="hljs-number"><span class="hljs-number">0</span></span>] : &amp;b[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ptrP = getBufferPtr(buf_unpacked, buf_packed); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ptrU = getBufferPtr(buf_packed, buf_unpacked); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(dictMarker) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*ptrP &gt;= DICT_MARK) { setPicWData(ptrU) = getPicWData(pDict, *ptrP); ++ptrU; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { *ptrU = *ptrP; } ++ptrU; ++ptrP; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*ptrP == PIC_DATA_END) { *ptrU = *ptrP; <span class="hljs-comment"><span class="hljs-comment">// mark end of chunk swap = !swap; ptrP = getBufferPtr(buf_unpacked, buf_packed); ptrU = getBufferPtr(buf_packed, buf_unpacked); dictMarker = findPackedMark(ptrP); } } return getBufferPtr(buf_unpacked, buf_packed); }</span></span></code> </pre><br> 现在，我们从接收到的缓冲区中以熟悉的方式解压缩RLE并将其显示在屏幕上： <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printBuf_RLE</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pData)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> repeatColor; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> repeatTimes, tmpByte; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((tmpByte = *pData) != PIC_DATA_END) { <span class="hljs-comment"><span class="hljs-comment">// get color index or repeat times if(tmpByte &amp; RLE_MARK) { // is it RLE byte? tmpByte &amp;= DATA_MARK; // get color index to repeat repeatTimes = *(++pData)+1; // zero RLE does not exist! } ++repeatTimes; ++pData; // get color from colorTable by color index repeatColor = palette_RAM[(tmpByte == ALPHA_COLOR_ID) ? alphaReplaceColorId : tmpByte]; do { pushColorFast(repeatColor); } while(--repeatTimes); } }</span></span></code> </pre><br> 令人惊讶的是，替换算法并没有显着影响拆包时间，大约为47ms。 这几乎是8毫秒。 更长，但测试映像仅占用1650个字节！ <br><br><h3> 直到最后的措施 </h3><hr> 几乎所有事情都可以更快地完成！ <br><br> 尽管存在硬件SPI，但AVR内核在使用时仍令人头疼。 <br> 众所周知，AVR上的SPI除了在F_CPU / 2上运行外，还具有仅1字节的数据寄存器（无法一次加载2字节）。 <br> 此外，我遇到的AVR上几乎所有的SPI代码都根据以下方案工作： <br><ul><li> 下载SPDR数据 </li><li> 循环询问SPSR中的SPIF位。 </li></ul><br> 如您所见，像在STM32上所做的那样，持续提供数据在这里没有味道。 但是，即使在这里，您也可以将两个拆包器的输出速度提高约3ms！ <br><br> 通过打开数据表并查看“指令集时钟”部分，您可以计算通过SPI传输字节时的CPU成本： <br><ul><li>  1个周期用于寄存器加载新数据； </li><li> 每位2拍（或每字节16拍）； </li><li> 每时钟线魔术1 bar（稍后介绍“ NOP”）； </li><li>  1个时钟来检查SPSR中的状态位（或分支上的2个时钟）； </li></ul><br> 总的来说，要传输一个像素（两个字节），应花费38个时钟周期或约425600个时钟周期用于测试图像（11,200个字节）。 <br> 知道F_CPU == 16 MHz，我们每个时钟周期得到<s>0.0000000625</s> 62.5纳秒（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">Process0169</a> ），将这些值相乘，就得出〜26毫秒。 问题来了：“我从哪儿写的，拆包时间是39ms。 和47毫秒。”？ 一切都很简单-解包逻辑+中断处理。 <br><br> 这是中断输出的示例： <br><img src="https://habrastorage.org/webt/du/ks/p1/duksp1nkfluio5sgfwyimgo9aik.png"><br> 并且没有中断： <br><img src="https://habrastorage.org/webt/v7/hp/xq/v7hpxqzhvsazrct5sbq7dkywq1w.png"><br> 这些图表明，在VRAM屏幕中设置地址窗口与开始不中断的版本中的数据传输之间的时间较短，并且在传输期间字节之间几乎没有间隙（该图是均匀的）。 <br> 不幸的是，您不能为每个图像输出禁用中断，否则整个游戏的声音和核心将中断（稍后会详细介绍）。 <br><br> 上面写的是关于时钟线的某种“神奇的NOP”。 事实是，为了稳定CLK并设置SPIF标志，恰好需要1个时钟周期，并且在读取该标志时，它已经被设置，从而避免了在BREQ指令上分支成2条。 <br> 这是一个没有NOP的示例： <br><img src="https://habrastorage.org/webt/vp/ia/w5/vpiaw5asga4dqawu3byh03k9gii.png"><br> 和他在一起： <br><img src="https://habrastorage.org/webt/jg/-q/4b/jg-q4b4ot1sy445kc5rvoyq-ixe.png"><br><br> 差异似乎微不足道，只有几微秒，但是如果采用不同的比例： <br> 大型NOP： <br><img src="https://habrastorage.org/webt/nf/ds/gi/nfdsgii8xkar_f6jo5fihrpx8ei.png"><br> 并且太大了： <br><img src="https://habrastorage.org/webt/8z/d9/e9/8zd9e9l79lnhj9qshrykzxxptmw.png"><br> 则差异变得更加明显，达到〜4.3ms。 <br><br> 现在，让我们做以下肮脏的把戏： <br><blockquote> 我们交换加载和读取寄存器的顺序，您不能等待SPIF标志的第二个字节，而只能在加载下一个像素的第一个字节之前进行检查。 <br></blockquote><br> 我们运用知识并部署函数“ pushColorFast（repeatColor）;”： <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPDR_TX_WAIT(a) asm volatile(a); while((SPSR &amp; (1&lt;&lt;SPIF)) == 0); typedef union { uint16_t val; struct { uint8_t lsb; uint8_t msb; }; } SPDR_t; ... do { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> ESPLORA_OPTIMIZE SPDR_t in = {.val = repeatColor}; SPDR_TX_WAIT(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">); SPDR = in.msb; SPDR_TX_WAIT(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"nop"</span></span></span><span class="hljs-meta">); SPDR = in.lsb; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> pushColorFast(repeatColor); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> } while(--repeatTimes); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> ESPLORA_OPTIMIZE SPDR_TX_WAIT(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// dummy wait to stable SPI #endif }</span></span></span></span></code> </pre><br> 尽管计时器中断，使用上面的技巧仍可获得近6ms的增益。 <br><img src="https://habrastorage.org/webt/ba/ah/hm/baahhmqnnvjznm1ssuihfi-ryhu.png"><br><br> 这就是简单的铁知识如何使您从中榨出更多并输出类似的东西： <br><img src="https://habrastorage.org/webt/xo/fj/wv/xofjwvtbu_w_4leeunorug-axri.gif"><br><br><h3> 罗马竞技场碰撞 </h3><hr> 盒子之战。 <br><br> 首先，整个对象（船，壳，小行星，奖金）是具有以下参数的结构（子画面）： <br><ul><li> 当前的X，Y坐标； </li><li> 新坐标X，Y； </li><li> 指向图像的指针。 </li></ul><br> 由于图像存储宽度和高度，因此无需重复这些参数，这样的组织在许多方面简化了逻辑。 <br><br> 基于矩形的交集，计算本身变得简单易行。 尽管它不够准确，也无法计算未来的冲突，但这绰绰有余。 <br> 验证是在X和Y轴上交替进行的，因此，X轴上没有相交会减少碰撞的计算。 <br><blockquote> 首先，检查第一个矩形的右侧和第二个矩形的左侧是否为X轴的公共部分；如果成功，则对第二个矩形的左侧和右侧进行类似的检查。 <br> 成功检测到沿X轴的相交后，将以相同方式对沿Y轴的矩形的上下边进行检查。 <br></blockquote><br> 上面看起来比看起来容易得多： <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkSpriteCollision</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sprite_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pSprOne, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sprite_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pSprTwo)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmpDataOne = getPicSize(pSprOne-&gt;pPic, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmpDataTwo = getPicSize(pSprTwo-&gt;pPic, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* ----------- Check X position ----------- */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> objOnePosEndX = (pSprOne-&gt;pos.Old.x + tmpDataOne.u8Data1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(objOnePosEndX &gt;= pSprTwo-&gt;pos.Old.x) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> objTwoPosEndX = (pSprTwo-&gt;pos.Old.x + tmpDataTwo.u8Data1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pSprOne-&gt;pos.Old.x &gt;= objTwoPosEndX) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">// nope, different X positions } // ok, objects on same X lines; Go next... } else { return false; // nope, absolutelly different X positions } /* ---------------------------------------- */ /* ----------- Check Y position ----------- */ uint8_t objOnePosEndY = (pSprOne-&gt;pos.Old.y + tmpDataOne.u8Data2); if(objOnePosEndY &gt;= pSprTwo-&gt;pos.Old.y) { uint8_t objTwoPosEndY = (pSprTwo-&gt;pos.Old.y + tmpDataTwo.u8Data2); if(pSprOne-&gt;pos.Old.y &lt;= objTwoPosEndY) { // ok, objects on same Y lines; Go next... // yep, if we are here // then, part of one object collide wthith another object return true; } else { return false; // nope, different Y positions } } else { return false; // nope, absolutelly different Y positions } }</span></span></code> </pre><br> 仍然需要将其添加到游戏中： <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkInVadersCollision</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(aliens[<span class="hljs-number"><span class="hljs-number">0</span></span>].weapon.ray) gopher; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;alien : aliens) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(alien.alive) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(checkSpriteCollision(&amp;ship.sprite, &amp;alien.sprite)) { gopher.sprite.pos.Old = alien.sprite.pos.Old; rocketEpxlosion(&amp;gopher); <span class="hljs-comment"><span class="hljs-comment">// now make gopher to explode \(^_^)/ removeSprite(&amp;alien.sprite); alien.alive = false; score -= SCORE_PENALTY; if(score &lt; 0) score = 0; } } } }</span></span></code> </pre><br><br><h3> 贝塞尔曲线 </h3><hr> 太空轨。 <br><br> 与其他任何使用这种类型的游戏一样，敌舰必须沿着曲线移动。 <br> 决定实施二次曲线作为控制器和此任务的最简单方法。 三个点就足够了：初始（P0），最终（P2）和虚数（P1）。 前两个指定线的起点和终点，最后一个点说明曲率的类型。 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">关于曲线的好文章。</a> <br> 由于这是贝塞尔曲线，因此还需要一个参数-起点和终点之间的中间点数。 <br><br> 总的来说，我们得到这样的结构： <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// 7 bytes position_t P0; position_t P1; position_t P2; uint8_t totalSteps; } bezier_t;</span></span></code> </pre> 其中，position_t是坐标X和Y的两个字节的结构。 <br> 使用以下公式计算每个坐标的点（thx Wiki）： <br>  B =（（（1.0-t）^ 2）P0 + 2t（1.0-t）P1 +（t ^ 2）P2， <br>  t [&gt; = 0 &amp;&amp; &lt;= 1] <br><br> 长期以来，它的实现都是在没有定点数学的情况下直接解决的： <br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = ((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)pItemLine-&gt;step)/((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)pLine-&gt;totalSteps); pPos-&gt;x = (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*pLine-&gt;P0.x + <span class="hljs-number"><span class="hljs-number">2</span></span>*t*(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*pLine-&gt;P1.x + t*t*pLine-&gt;P2.x; pPos-&gt;y = (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*pLine-&gt;P0.y + <span class="hljs-number"><span class="hljs-number">2</span></span>*t*(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*pLine-&gt;P1.y + t*t*pLine-&gt;P2.y; ...</code> </pre><br> 当然，这不能离开。 毕竟，摆脱浮点数不仅可以提高速度，还可以释放ROM，因此发现了以下实现： <br><ul><li>  avrfix; </li><li>  stdfix; </li><li>  libfixmath; </li><li>  fixedptc。 </li></ul><br> 第一个仍然是一匹黑马，因为它是一个已编译的库，并且不想弄乱反汇编程序。 <br><br>  GCC捆绑包中的第二个候选者也没有解决，因为未使用所用的avr-gcc进行修补，并且“ short _Accum”类型仍然不可用。 <br><br> 第三种选择，尽管它有大量垫子。 功能，对Q16.16格式的特定位进行硬编码位操作，这使得无法控制Q和I的值。 <br><br> 后者可以看作是“ fixedmath”的简化版本，但是主要优点是不仅可以控制变量的大小（默认情况下为32位，格式为Q24.8），而且可以控制Q和I的值。 <br><br> 在不同设置下的测试结果： <br><table><tbody><tr><th> 型式 </th><th> 智商 </th><th> 附加标志 </th><th>  ROM字节 </th><th>  Tms。* </th></tr><tr><td> 飘浮 </td><td>  -- </td><td>  -- </td><td>  4236 </td><td>  35 </td></tr><tr><td> 固定数学 </td><td>  16.16 </td><td>  -- </td><td>  4796 </td><td>  119 </td></tr><tr><td> 固定数学 </td><td>  16.16 </td><td>  FIXMATH_NO_OVERFLOW </td><td>  4664 </td><td>  89 </td></tr><tr><td> 固定数学 </td><td>  16.16 </td><td>  FIXMATH_OPTIMIZE_8BIT </td><td>  5036 </td><td>  92 </td></tr><tr><td> 固定数学 </td><td>  16.16 </td><td>  _NO_OVERFLOW + _8BIT </td><td>  4916 </td><td>  89 </td></tr><tr><td> 固定点 </td><td>  24.8 </td><td>  FIXEDPT_BITS 32 </td><td>  4420 </td><td>  64 </td></tr><tr><td> 固定点 </td><td>  9.7 </td><td>  FIXEDPT_BITS 16 </td><td>  3490 </td><td>  31 </td></tr></tbody></table>  *检查是按照“ 195,175,145,110,170,70,170”和键“ -Os”执行的。 <br><br> 从表中可以看出，当使用float时，两个库占用的ROM都比GCC的编译代码还要多，并且显示出更差的结果。 <br> 还可以看到，对Q9.7格式进行了较小的修订，并将变量减小到16位，则加速了4毫秒。 并释放大约50个字节的ROM。 <br><br> 预期的效果是准确性下降，错误数量增加： <br><img src="https://habrastorage.org/webt/sz/v0/yt/szv0ytpsb0ogl5hkp39blbggvzw.png"><br> 在这种情况下是不重要的。 <br><br><h3> 分配资源 </h3><hr> 周二和周四仅工作一个小时。 <br><br> 在大多数情况下，所有计算都是在每帧进行的，这并不总是合理的，因为帧中可能没有足够的时间来计算某些东西，因此您将不得不选择交替，计数帧或跳过它们。 因此，我走得更远-完全放弃了人员配备。 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将一切分解为小任务：计算碰撞，处理声音，按钮和显示图形，足以在一定的间隔内执行它们，而眼睛的惯性和仅更新部分屏幕的能力就可以解决问题。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们不仅使用OS来管理所有这些事情，还使用我几年前创建的状态机来管理所有这些事情，或者更简单地，不是用挤出的tinySM任务管理器来管理。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我将重复使用它而不是任何RTOS的原因：</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 较低的ROM要求（〜250字节内核）； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 较低的RAM要求（每个任务约9个字节）； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 简单易懂的工作原理； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 行为确定性； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 浪费更少的CPU时间； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 不能接触铁； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 平台无关； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 用C编写，并且易于用C ++包装； </font></font></li><li> <s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要我自己的自行车。</font></font></s> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正如我曾经描述的，针对它的任务被组织成一个指向结构的指针的数组，其中存储了指向函数及其调用间隔的指针。</font><font style="vertical-align: inherit;">这种分组简化了游戏在不同阶段的描述，还使您可以减少分支数量并动态切换任务集。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，在开始屏幕中，执行了7个任务，并且在游戏中，已经有20个任务（所有任务均在gameTasks.c文件中进行了描述）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，为了方便起见，您需要定义一些宏：</font></font><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> T(a) a##Task #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_N(a) const taskParams_t T(a) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK(a,b) TASK_N(a) PROGMEM = {.pFunc=a, .timeOut=b} #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_P(a) (taskParams_t*)&amp;T(a) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_ARR_N(a) const tasksArr_t a##TasksArr[] #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_ARR(a) TASK_ARR_N(a) PROGMEM #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_END NULL</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 任务声明实际上是在创建一个结构，初始化其字段并将其放置在ROM中： </font></font><br><pre> <code class="cpp hljs">TASK(updateBtnStates, <span class="hljs-number"><span class="hljs-number">25</span></span>);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个这样的结构占用4字节的ROM（每个指针两个，每个间隔两个）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">宏的一个好处是，它无法为每个函数创建多个唯一的结构。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">声明了必要的任务后，我们将它们添加到数组中，然后将它们放入ROM：</font></font><br><pre> <code class="cpp hljs">TASK_ARR( game ) = { TASK_P(updateBtnStates), TASK_P(playMusic), TASK_P(drawStars), TASK_P(moveShip), TASK_P(drawShip), TASK_P(checkFireButton), TASK_P(pauseMenu), TASK_P(drawPlayerWeapon), TASK_P(checkShipHealth), TASK_P(drawSomeGUI), TASK_P(checkInVaders), TASK_P(drawInVaders), TASK_P(moveInVaders), TASK_P(checkInVadersRespawn), TASK_P(checkInVadersRay), TASK_P(checkInVadersCollision), TASK_P(dropWeaponGift), TASK_END };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 将静态存储器的USE_DYNAMIC_MEM标志设置为0时，要记住的主要事情是初始化指向RAM中任务存储区的指针，并设置将要执行的最大指针数： </font></font><br><pre> <code class="cpp hljs">... tasksContainer_t tasksContainer; taskFunc_t tasksArr[MAX_GAME_TASKS]; ... initTasksArr(&amp;tasksContainer, &amp;tasksArr[<span class="hljs-number"><span class="hljs-number">0</span></span>], MAX_GAME_TASKS); …</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 设置执行任务： </font></font><br><pre> <code class="cpp hljs">... addTasksArray_P(gameTasksArr); …</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">溢出保护由USE_MEM_PANIC标志控制，如果您确定任务数，可以禁用它以保存ROM。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它仅保留运行处理程序：</font></font><br><pre> <code class="cpp hljs">... runTasks(); ...</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部是一个包含基本逻辑的无限循环。</font><font style="vertical-align: inherit;">一旦进入堆栈，由于“ __attribute__（（noreturn））”，堆栈也得以恢复。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在循环中，在间隔过去之后，将交替扫描数组的元素以查找是否需要调用任务。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">间隔的倒计时是基于timer0作为一个具有1ms量子的系统进行的... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管任务在时间上成功分配，但有时它们会重叠（抖动），这会导致游戏中所有事物的短期衰落。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">绝对必须决定，但是如何？</font><font style="vertical-align: inherit;">关于下一次如何配置所有内容，但现在尝试在源代码中找到复活节彩蛋。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 结束 </font></font></h3><hr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，使用了许多技巧（我还没有描述更多的技巧），结果证明所有内容都适合于24kb ROM和1500字节RAM。</font><font style="vertical-align: inherit;">如果您有任何疑问，我将很乐意回答。</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于那些没有找到或没有寻找复活节彩蛋的人：</font></font></b> <div class="spoiler_text">   : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invadersMagicRespawn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;alien : aliens) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!alien.alive) { alien.respawnTime = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } }</code> </pre><br>   , ? <br><div class="spoiler"> <b class="spoiler_title">  invadersMagicRespawn:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ tftSetTextSize(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { tftSetCP437(RN &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>); tftSetTextColorBG((((RN % <span class="hljs-number"><span class="hljs-number">192</span></span> + <span class="hljs-number"><span class="hljs-number">64</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFC</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>), COLOR_BLACK); tftDrawCharInt(((RN % <span class="hljs-number"><span class="hljs-number">26</span></span>) * <span class="hljs-number"><span class="hljs-number">6</span></span>), ((RN &amp; <span class="hljs-number"><span class="hljs-number">15</span></span>) * <span class="hljs-number"><span class="hljs-number">8</span></span>), (RN % <span class="hljs-number"><span class="hljs-number">255</span></span>)); tftPrintAt_P(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">58</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)creditP0); } } a(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;alien : aliens) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!alien.alive) { alien.respawnTime = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } }</code> </pre><br>   «(void)»    ,  «action()»          10 ,    «disablePause();».               «Matrix Falling code»    .       130  ROM. <br></div></div><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 要构建和运行它，只需将文件夹（或链接）“ esploraAPI”放在“ / arduino / library /”中。 </font></font><br><br> 参考文献： <br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏；</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esploraAPI;</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pickoPacker封隔器；</font></font></a> </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 附注：稍后，当我制作一个可以接受的视频时，您可以看到并听到一切。 </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN425407/">https://habr.com/ru/post/zh-CN425407/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN425395/index.html">您应该在学校知道但可能不知道的10个物理事实</a></li>
<li><a href="../zh-CN425397/index.html">每个Android开发人员都应该了解的10个库</a></li>
<li><a href="../zh-CN425401/index.html">2018年罗马俱乐部报告，第1.11章：颠覆性技术与数字革命</a></li>
<li><a href="../zh-CN425403/index.html">Craigslist创作者的财务状况：反对假新闻，歧视和互联网巨头的过分行为的网站</a></li>
<li><a href="../zh-CN425405/index.html">大功率新型</a></li>
<li><a href="../zh-CN425409/index.html">DevBoy：制作信号发生器</a></li>
<li><a href="../zh-CN425411/index.html">Scrum死了</a></li>
<li><a href="../zh-CN425413/index.html">傻瓜好吗？</a></li>
<li><a href="../zh-CN425415/index.html">Perl 5：宏如何隐藏错误</a></li>
<li><a href="../zh-CN425417/index.html">快闪给大家。 QSAN的全闪存阵列</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>