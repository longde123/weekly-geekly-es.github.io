<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçü§ù‚Äçüë®üèª üé© üâê Vom Kopieren und Einf√ºgen zu Komponenten: Wiederverwendung von Code in verschiedenen Anwendungen üï¥üèø üôçüèΩ üìò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Badoo entwickelt mehrere Anwendungen, von denen jede ein separates Produkt mit eigenen Eigenschaften, Management-, Produkt- und Entwicklungsteams ist....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vom Kopieren und Einf√ºgen zu Komponenten: Wiederverwendung von Code in verschiedenen Anwendungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/466049/"><img src="https://habrastorage.org/webt/4j/xp/to/4jxptoi9jrqf5aynpoeurc816ee.jpeg"><br><br>  Badoo entwickelt mehrere Anwendungen, von denen jede ein separates Produkt mit eigenen Eigenschaften, Management-, Produkt- und Entwicklungsteams ist.  Aber wir arbeiten alle im selben B√ºro zusammen und l√∂sen √§hnliche Probleme. <br><br>  Die Entwicklung jedes Projekts erfolgte auf seine eigene Weise.  Die Codebasis wurde nicht nur von unterschiedlichen Zeitrahmen und Produktl√∂sungen beeinflusst, sondern auch von der Vision der Entwickler.  Am Ende haben wir festgestellt, dass die Projekte dieselbe Funktionalit√§t haben, die sich in der Implementierung grundlegend unterscheidet. <br><br>  Dann haben wir uns f√ºr eine Struktur entschieden, die uns die M√∂glichkeit gibt, Funktionen zwischen Anwendungen wiederzuverwenden.  Anstatt Funktionen in einzelnen Projekten zu entwickeln, erstellen wir jetzt gemeinsame Komponenten, die in alle Produkte integriert werden.  Wenn Sie daran interessiert sind, wie wir dazu gekommen sind, begr√º√üen Sie bitte bei cat. <a name="habracut"></a><br><br>  Aber zuerst wollen wir uns mit den Problemen befassen, deren L√∂sung zur Schaffung gemeinsamer Komponenten f√ºhrte.  Es gab mehrere von ihnen: <br><br><ul><li>  Kopieren und Einf√ºgen zwischen Anwendungen; <br></li><li>  Prozesse, bei denen St√∂cke in die R√§der eingef√ºhrt werden; <br></li><li>  unterschiedliche Architektur von Projekten. <br></li></ul><br><img src="https://habrastorage.org/webt/wq/ls/ov/wqlsovroayg0xhqrwibqc37pv6y.png"><br><br>  <i>Dieser Artikel ist eine Textversion meines Berichts mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AppsConf 2019</a> , die hier eingesehen werden kann.</i> <br><br><h2>  Problem: Kopieren Einf√ºgen </h2><br>  Vor einiger Zeit, als die B√§ume unsch√§rfer waren, das Gras gr√ºner und ich ein Jahr j√ºnger, hatten wir oft die folgende Situation. <br><br>  Es gibt einen Entwickler, nennen wir ihn Lesha.  Er macht ein cooles Modul f√ºr seine Aufgabe, erz√§hlt seinen Kollegen davon und legt es im Repository f√ºr seine Anwendung ab, wo er es verwendet. <br><br>  Das Problem ist, dass sich alle unsere Anwendungen in verschiedenen Repositorys befinden. <br><br><img src="https://habrastorage.org/webt/-a/1f/zq/-a1fzqhp9m--jhxy1tcrmx7plwi.png"><br><br>  Entwickler Andrey arbeitet derzeit nur an einer anderen Anwendung in einem anderen Repository.  Er m√∂chte dieses Modul f√ºr seine Aufgabe verwenden, die der von Lesha verd√§chtig √§hnlich ist.  Es gibt jedoch ein Problem: Der Prozess der Wiederverwendung von Code ist vollst√§ndig debuggt. <br><br>  In dieser Situation schreibt Andrei entweder seine Entscheidung (was in 80% der F√§lle der Fall ist) oder kopiert die L√∂sung von Lyosha und √§ndert alles darin, damit es zu seiner Anwendung, Aufgabe oder Stimmung passt. <br><br><img src="https://habrastorage.org/webt/2e/nd/95/2end959nckg-szaxu_nwwwcqxtm.png"><br><br>  Danach kann Lesha sein Modul aktualisieren, indem er √Ñnderungen an seinem Code f√ºr seine Aufgabe hinzuf√ºgt.  Er kennt keine andere Version und aktualisiert nur sein Repository. <br><br>  Diese Situation bringt mehrere Probleme mit sich. <br><br>  Erstens haben wir mehrere Anwendungen mit jeweils eigener Entwicklungsgeschichte.  Bei der Arbeit an jeder Anwendung erstellte das Produktteam h√§ufig L√∂sungen, die sich nur schwer in eine einzelne Struktur integrieren lassen. <br><br>  Zweitens sind separate Teams an Projekten beteiligt, die schlecht miteinander kommunizieren und sich daher selten √ºber Aktualisierungen / Wiederverwendung des einen oder anderen Moduls informieren. <br><br>  Drittens ist die Anwendungsarchitektur sehr unterschiedlich: von MVP zu MVI, von Gottaktivit√§t zu Einzelaktivit√§t. <br><br>  Nun, das ‚ÄûHighlight des Programms‚Äú: Anwendungen befinden sich in verschiedenen Repositories mit jeweils eigenen Prozessen. <br><br>  Zu Beginn des Kampfes gegen diese Probleme haben wir uns das ultimative Ziel gesetzt: unsere Best Practices (sowohl Logik als auch Benutzeroberfl√§che) zwischen allen Anwendungen wiederzuverwenden. <br><br><h2>  Entscheidungen: Wir etablieren Prozesse </h2><br>  Von den oben genannten Problemen h√§ngen zwei mit den Prozessen zusammen: <br><br><ol><li>  Zwei Repositories, die Projekte mit einer undurchdringlichen Wand gemeinsam nutzen. <br></li><li>  Separate Teams ohne etablierte Kommunikation und unterschiedliche Anforderungen der Produktanwendungsteams. <br></li></ol><br>  Beginnen wir mit dem ersten: Wir haben es mit zwei Repositorys mit derselben Modulversion zu tun.  Theoretisch k√∂nnten wir git-subtree oder √§hnliche L√∂sungen verwenden und gemeinsame Projektmodule in separate Repositories stellen. <br><br><img src="https://habrastorage.org/webt/ro/q0/nr/roq0nrr9xuy2my8ajbsldfcismw.png"><br><br>  Das Problem tritt w√§hrend der √Ñnderung auf.  Im Gegensatz zu Open-Source-Projekten, die √ºber eine stabile API verf√ºgen und √ºber externe Quellen verteilt werden, treten h√§ufig √Ñnderungen an internen Komponenten auf, die alles besch√§digen.  Bei Verwendung eines Teilbaums wird jede solche Migration zu einem Schmerz. <br><br>  Meine Kollegen vom iOS-Team haben √§hnliche Erfahrungen gemacht, und es stellte sich als nicht sehr erfolgreich heraus, wie Anton Schukin letztes Jahr auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Mobius-Konferenz</a> sagte. <br><br>  Nachdem wir ihre Erfahrungen studiert und verstanden hatten, wechselten wir zu einem einzigen Repository.  Alle Android-Anwendungen befinden sich jetzt an einem Ort, was uns bestimmte Vorteile bietet: <br><br><ul><li>  Sie k√∂nnen den Code mithilfe von Gradle-Modulen sicher wiederverwenden. <br></li><li>  Wir haben es geschafft, die Toolchain auf CI mithilfe einer einzigen Infrastruktur f√ºr Builds und Tests zu verbinden. <br></li><li>  Diese √Ñnderungen haben die physische und einige mentale Barriere zwischen den Teams beseitigt, da wir nun frei sind, die Entwicklungen und L√∂sungen des anderen zu nutzen. <br></li></ul><br>  Nat√ºrlich hat diese L√∂sung auch Nachteile.  Wir haben ein riesiges Projekt, das manchmal nicht IDE und Gradle unterliegt.  Das Problem k√∂nnte teilweise durch die Lade- / Entlademodule in Android Studio gel√∂st werden. Es ist jedoch schwierig, sie zu verwenden, wenn Sie gleichzeitig an allen Anwendungen arbeiten und h√§ufig wechseln m√ºssen. <br><br>  Das zweite Problem - die Interaktion zwischen Teams - bestand aus mehreren Teilen: <br><br><ul><li>  getrennte Teams ohne etablierte Kommunikation; <br></li><li>  undeutliche Verteilung der Verantwortung f√ºr gemeinsame Module; <br></li><li>  unterschiedliche Anforderungen der Produktteams. <br></li></ul><br>  Um dieses Problem zu l√∂sen, haben wir Teams gebildet, die bestimmte Funktionen in jeder Anwendung implementieren: zum Beispiel Chat oder Registrierung.  Neben der Entwicklung sind sie auch f√ºr die Integration dieser Komponenten in die Anwendung verantwortlich. <br><br>  Produktteams haben bereits vorhandene Komponenten in der Hand, um sie zu verbessern und an die Anforderungen eines bestimmten Projekts anzupassen. <br><br>  Somit ist die Erstellung einer wiederverwendbaren Komponente nun Teil des Prozesses f√ºr das gesamte Unternehmen, von der Phase der Idee bis zum Beginn der Produktion. <br><br><h2>  L√∂sungen: Rationalisierung der Architektur </h2><br>  Unser n√§chster Schritt zur Wiederverwendung war die Rationalisierung der Architektur.  Warum haben wir das gemacht? <br><br>  Unsere Codebasis tr√§gt das historische Erbe einer mehrj√§hrigen Entwicklung.  Mit der Zeit und den Menschen √§nderten sich auch die Ans√§tze.  Wir befanden uns also in einer Situation mit einem ganzen Zoo von Architekturen, die zu folgenden Problemen f√ºhrte: <br><br><ol><li>  Die Integration g√§ngiger Module war fast langsamer als das Schreiben neuer.  Zus√§tzlich zu den Merkmalen der Funktion war es notwendig, die Struktur sowohl der Komponente als auch der Anwendung zu ertragen. <br></li><li>  Entwickler, die sehr oft zwischen Anwendungen wechseln mussten, verbrachten viel Zeit damit, neue Ans√§tze zu beherrschen. <br></li><li>  Oft wurden Wrapper von einem Ansatz zum anderen geschrieben, was der H√§lfte des Codes in der Modulintegration entsprach. <br></li></ol><br>  Am Ende haben wir uns f√ºr den MVI-Ansatz entschieden, den wir in unserer MVICore-Bibliothek ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> ) strukturiert haben.  Wir waren besonders an einer seiner Funktionen interessiert - Atomzustandsaktualisierungen, die immer die G√ºltigkeit garantieren.  Wir gingen etwas weiter und kombinierten die Zust√§nde der logischen und der Pr√§sentationsebene, um die Fragmentierung zu verringern.  Auf diese Weise gelangen wir zu einer Struktur, in der die einzige Entit√§t f√ºr die Logik verantwortlich ist und in der Ansicht nur das aus dem Status erstellte Modell angezeigt wird. <br><br><img src="https://habrastorage.org/webt/ze/4z/kr/ze4zkr0ecnm_x9il17ibon6uzkk.png"><br><br>  Die Trennung von Verantwortlichkeiten erfolgt durch die Transformation von Modellen zwischen Ebenen.  Dank dessen erhalten wir einen Bonus in Form von Wiederverwendbarkeit.  Wir verbinden die Elemente von au√üen, das hei√üt, jeder von ihnen ahnt nicht, dass der andere existiert - sie verschenken einfach einige Modelle und reagieren auf das, was zu ihnen kommt.  Auf diese Weise k√∂nnen Sie Komponenten herausziehen und an anderer Stelle verwenden, indem Sie Adapter f√ºr ihre Modelle schreiben. <br><br>  Schauen wir uns ein Beispiel eines einfachen Bildschirms an, wie er in der Realit√§t aussieht. <br><br><img src="https://habrastorage.org/webt/wm/0k/cs/wm0kcsuh1io0cr4cnil0ui11gme.png"><br><br>  Wir verwenden die grundlegenden RxJava-Schnittstellen, um die Typen anzugeben, mit denen das Element arbeitet.  Die Eingabe wird durch die Schnittstelle Consumer &lt;T&gt;, Ausgabe - ObservableSource &lt;T&gt; bezeichnet. <br><br><pre><code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// input = Consumer&lt;ViewModel&gt; // output = ObservableSource&lt;Event&gt; class View( val events: PublishRelay&lt;Event&gt; ): ObservableSource&lt;Event&gt; by events, Consumer&lt;ViewModel&gt; { val button: Button val textView: TextView init { button.setOnClickListener { events.accept(Event.ButtonClick) } } override fun accept(model: ViewModel) { textView.text = model.text } }</span></span></code> </pre> <br>  √úber diese Schnittstellen k√∂nnen wir View als Consumer &lt;ViewModel&gt; und ObservableSource &lt;Event&gt; ausdr√ºcken.  Beachten Sie, dass das ViewModel nur den Status des Bildschirms enth√§lt und wenig mit MVVM zu tun hat.  Nachdem wir das Modell erhalten haben, k√∂nnen wir die Daten daraus anzeigen. Wenn wir auf die Schaltfl√§che klicken, senden wir das Ereignis, das nach drau√üen √ºbertragen wird. <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// input = Consumer&lt;Wish&gt; // output = ObservableSource&lt;State&gt; class Feature: ReducerFeature&lt;Wish, State&gt;( initialState = State(counter = 0), reducer = ReducerImpl() ) { class ReducerImpl: Reducer&lt;Wish, State&gt; { override fun invoke(state: State, wish: Wish) = when (wish) { is Increment -&gt; state.copy(counter = state.counter + 1) } } }</span></span></code> </pre> <br>  Feature implementiert ObservableSource und Consumer bereits f√ºr uns;  Wir m√ºssen dort den Anfangszustand (Z√§hler gleich 0) √ºbertragen und angeben, wie dieser Zustand ge√§ndert werden soll. <br><br>  Nach der √úbertragung von Wish wird Reducer aufgerufen, wodurch basierend auf dem letzten Status ein neuer erstellt wird.  Zus√§tzlich zum Reduzierer kann die Logik durch andere Komponenten beschrieben werden.  Hier k√∂nnen Sie mehr dar√ºber erfahren. <br><br>  Nachdem wir die beiden Elemente erstellt haben, m√ºssen wir sie verbinden. <br><br><img width="250" src="https://habrastorage.org/webt/pq/kh/jp/pqkhjphpe4pvypmm5y8icqralhy.png" align="left"><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> eventToWish: (Event) -&gt; Wish = { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (it) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ButtonClick -&gt; Increment } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> stateToModel: (State) -&gt; ViewModel = { ViewModel(text = state.counter.toString()) } Binder().apply { bind(view to feature using eventToWish) bind(feature to view using stateToModel) }</code> </pre> <br>  Zun√§chst geben wir an, wie wir ein Element eines Typs in ein anderes umwandeln.  ButtonClick wird also zu Inkrement und das Z√§hlerfeld von State wird in Text eingef√ºgt. <br><br>  Jetzt k√∂nnen wir jede der Ketten mit der gew√ºnschten Transformation erstellen.  Daf√ºr verwenden wir Binder.  Sie k√∂nnen damit Beziehungen zwischen ObservableSource und Consumer erstellen und den Lebenszyklus beobachten.  Und das alles mit einer sch√∂nen Syntax.  Diese Art der Verbindung f√ºhrt uns zu einem flexiblen System, mit dem wir Elemente einzeln herausziehen und verwenden k√∂nnen. <br><br>  MVICore-Elemente funktionieren sehr gut mit unserem ‚ÄûZoo‚Äú von Architekturen, nachdem Wrapper von ObservableSource und Consumer geschrieben wurden.  Beispielsweise k√∂nnen wir Use-Case-Methoden aus Clean Architecture in Wish / State einschlie√üen und in der Kette anstelle von Feature verwenden. <br><br><img src="https://habrastorage.org/webt/l3/x7/ee/l3x7eef1pxxq4qbl6epceicz_1a.png"><br><br><h2>  Komponente </h2><br>  Schlie√ülich gehen wir zu den Komponenten √ºber.  Wie sind sie? <br><br>  Betrachten Sie den Bildschirm in der Anwendung und teilen Sie ihn in logische Teile. <br><br><img src="https://habrastorage.org/webt/s6/xb/mg/s6xbmgomehcdqao1psynv5mnnlc.png"><br><br>  Es kann unterschieden werden: <br><br><ul><li>  Symbolleiste mit Logo und Schaltfl√§chen oben; <br></li><li>  eine Karte mit Profil und Logo; <br></li><li>  Instagram-Bereich. <br></li></ul><br>  Jeder dieser Teile ist genau die Komponente, die in einem v√∂llig anderen Kontext wiederverwendet werden kann.  So kann der Instagram-Bereich Teil der Profilbearbeitung in einer anderen Anwendung werden. <br><br><img src="https://habrastorage.org/webt/o_/yh/c7/o_yhc7jqyzwma6l4nljmf2jasuk.png"><br><br>  Im allgemeinen Fall besteht eine Komponente aus mehreren Ansichten, Logikelementen und verschachtelten Komponenten, die durch gemeinsame Funktionen verbunden sind.  Und sofort stellt sich die Frage: Wie k√∂nnen sie zu einer unterst√ºtzten Struktur zusammengesetzt werden? <br><br>  Das erste Problem, auf das wir gesto√üen sind, ist, dass MVICore beim Erstellen und Binden von Elementen hilft, jedoch keine gemeinsame Struktur bietet.  Bei der Wiederverwendung von Elementen aus einem gemeinsamen Modul ist nicht klar, wo diese Teile zusammengesetzt werden sollen: innerhalb des gemeinsamen Teils oder auf der Anwendungsseite? <br><br>  Im allgemeinen Fall wollen wir der Anwendung definitiv keine Streust√ºcke geben.  Im Idealfall streben wir eine Struktur an, die es uns erm√∂glicht, Abh√§ngigkeiten zu erhalten und die Komponente als Ganzes mit dem gew√ºnschten Lebenszyklus zusammenzusetzen. <br><br>  Zun√§chst haben wir die Komponenten in Bildschirme unterteilt.  Die Verbindung der Elemente erfolgte neben der Erstellung von DI-Containern f√ºr Aktivit√§t oder Fragment.  Diese Container kennen bereits alle Abh√§ngigkeiten, haben Zugriff auf die Ansicht und den Lebenszyklus. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> SomeScopedComponent : ScopedComponent&lt;SomeComponent&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: SomeComponent { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DaggerSomeComponent.builder() .build() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> SomeComponent.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Array&lt;Disposable&gt; = arrayOf( Binder().apply { bind(feature().news to otherFeature()) bind(feature() to view()) } ) }</code> </pre> <br>  Probleme begannen an zwei Stellen gleichzeitig: <br><br><ol><li>  DI begann mit Logik zu arbeiten, was zur Beschreibung der gesamten Komponente in einer Klasse f√ºhrte. <br></li><li>  Da der Container an eine Aktivit√§t oder ein Fragment angeh√§ngt ist und mindestens den gesamten Bildschirm beschreibt, enth√§lt ein solcher Bildschirm / Container viele Elemente, die sich in einer gro√üen Menge an Code niederschlagen, um alle Abh√§ngigkeiten dieses Bildschirms zu verbinden. <br></li></ol><br>  Um die Probleme der Reihe nach zu l√∂sen, haben wir zun√§chst die Logik in eine separate Komponente eingef√ºgt.  So k√∂nnen wir alle Funktionen in dieser Komponente sammeln und √ºber Eingabe und Ausgabe mit View kommunizieren.  Aus Sicht der Benutzeroberfl√§che sieht es wie ein regul√§res MVICore-Element aus, wird jedoch gleichzeitig aus mehreren anderen Elementen erstellt. <br><br><img src="https://habrastorage.org/webt/bx/xf/ih/bxxfihgylnpbclxg3o9pcem9xr8.png"><br><br>  Nachdem wir dieses Problem gel√∂st hatten, teilten wir die Verantwortung f√ºr die Verbindung der Elemente.  Trotzdem haben wir die Komponenten auf den Bildschirmen geteilt, was f√ºr uns eindeutig nicht zur Hand war, was zu einer gro√üen Anzahl von Abh√§ngigkeiten an einem Ort f√ºhrte. <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Scope</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> params: ScreenParams, news: NewsRelay, <span class="hljs-meta"><span class="hljs-meta">@OnDisposeAction</span></span> onDisposeAction: () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>, globalFeature: GlobalFeature, conversationControlFeature: ConversationControlFeature, messageSyncFeature: MessageSyncFeature, conversationInfoFeature: ConversationInfoFeature, conversationPromoFeature: ConversationPromoFeature, messagesFeature: MessagesFeature, messageActionFeature: MessageActionFeature, initialScreenFeature: InitialScreenFeature, initialScreenExplanationFeature: InitialScreenExplanationFeature?, errorFeature: ErrorFeature, conversationInputFeature: ConversationInputFeature, sendRegularFeature: SendRegularFeature, sendContactForCreditsFeature: SendContactForCreditsFeature, screenEventTrackingFeature: ScreenEventTrackingFeature, messageReadFeature: MessageReadFeature?, messageTimeFeature: MessageTimeFeature?, photoGalleryFeature: PhotoGalleryFeature?, onlineStatusFeature: OnlineStatusFeature?, favouritesFeature: FavouritesFeature?, isTypingFeature: IsTypingFeature?, giftStoreFeature: GiftStoreFeature?, messageSelectionFeature: MessageSelectionFeature?, reportingFeature: ReportingFeature?, takePhotoFeature: TakePhotoFeature?, giphyFeature: GiphyFeature, goodOpenersFeature: GoodOpenersFeature?, matchExpirationFeature: MatchExpirationFeature, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pushIntegration: PushIntegration ) : AbstractMviComponent&lt;UiEvent, States&gt;(</code> </pre> <br>  Die richtige L√∂sung in dieser Situation besteht darin, die Komponente zu besch√§digen.  Wie wir oben gesehen haben, besteht jeder Bildschirm aus vielen logischen Elementen, die wir in unabh√§ngige Teile unterteilen k√∂nnen. <br><br>  Nach einigem Nachdenken kamen wir zu einer Baumstruktur und bauten sie naiv aus vorhandenen Komponenten auf und erhielten dieses Schema: <br><br><img src="https://habrastorage.org/webt/el/yl/v1/elylv1elwdrgyoqdamiepx0lleo.png"><br><br>  Nat√ºrlich ist es fast unm√∂glich, die Synchronisation zweier B√§ume (aus der Ansicht und aus der Logik) aufrechtzuerhalten.  Wenn die Komponente jedoch f√ºr die Anzeige ihrer Ansicht verantwortlich ist, k√∂nnen wir dieses Schema vereinfachen.  Nachdem wir die bereits erstellten L√∂sungen untersucht hatten, √ºberlegten wir unseren Ansatz und st√ºtzten uns auf die RIBs von Uber. <br><br><img src="https://habrastorage.org/webt/sy/xt/kd/syxtkdw8uiusbnrneqna1-bqfbe.png"><br><br>  Die Ideen hinter diesem Ansatz sind den Grundlagen von MVICore sehr √§hnlich.  RIB ist eine Art ‚ÄûBlack Box‚Äú, deren Kommunikation √ºber eine streng definierte Schnittstelle von Abh√§ngigkeiten (n√§mlich Eingabe und Ausgabe) erfolgt.  Trotz der offensichtlichen Komplexit√§t der Unterst√ºtzung einer solchen Schnittstelle in einem schnell iterativen Produkt erhalten wir gro√üartige M√∂glichkeiten zur Wiederverwendung von Code. <br><br>  Im Vergleich zu fr√ºheren Iterationen erhalten wir also: <br><br><ul><li>  gekapselte Logik innerhalb einer Komponente; <br></li><li>  Unterst√ºtzung f√ºr das Verschachteln, wodurch Bildschirme in Teile unterteilt werden k√∂nnen; <br></li><li>  Interaktion mit anderen Komponenten √ºber eine strikte Schnittstelle von Eingabe / Ausgabe mit Unterst√ºtzung f√ºr MVICore; <br></li><li>  Kompilierzeitsichere Verbindung von Komponentenabh√§ngigkeiten (basierend auf Dagger als DI). <br></li></ul><br>  Das ist nat√ºrlich alles andere als gut.  Das Repository auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> enth√§lt eine detailliertere und aktuellere Beschreibung. <br><br>  Und hier haben wir eine perfekte Welt.  Es enth√§lt Komponenten, aus denen wir einen vollst√§ndig wiederverwendbaren Baum erstellen k√∂nnen. <br><br>  Aber wir leben in einer unvollkommenen Welt. <br><br><h2>  Willkommen in der Realit√§t! </h2><br>  In einer unvollkommenen Welt gibt es eine Reihe von Dingen, die wir ertragen m√ºssen.  Wir sind besorgt √ºber Folgendes: <br><br><ul><li>  Unterschiedliche Funktionen: Trotz aller Vereinheitlichung haben wir es immer noch mit einzelnen Produkten mit unterschiedlichen Anforderungen zu tun. <br></li><li>  Support: Wie ohne neue Funktionalit√§t bei A / B-Tests? <br></li><li>  Verm√§chtnis (alles, was vor unserer neuen Architektur geschrieben wurde). <br></li></ul><br>  Die Komplexit√§t von L√∂sungen nimmt exponentiell zu, da jede Anwendung gemeinsamen Komponenten etwas Eigenes hinzuf√ºgt. <br><br>  Betrachten Sie den Registrierungsprozess als Beispiel f√ºr eine allgemeine Komponente, die in Anwendungen integriert wird.  Im Allgemeinen ist die Registrierung eine Kette von Bildschirmen mit Aktionen, die sich auf den gesamten Ablauf auswirken.  Jede Anwendung verf√ºgt √ºber unterschiedliche Bildschirme und eine eigene Benutzeroberfl√§che.  Das ultimative Ziel ist es, eine flexible wiederverwendbare Komponente herzustellen, die uns auch hilft, die Probleme aus der obigen Liste zu l√∂sen. <br><br><img src="https://habrastorage.org/webt/22/v6/cd/22v6cdpd9uf8ebuxcdo0j4mgc5a.png"><br><br><h3>  Verschiedene Anforderungen </h3><br>  Jede Anwendung hat ihre eigenen Registrierungsvarianten, sowohl von der Logikseite als auch von der UI-Seite.  Daher beginnen wir, die Funktionalit√§t in der Komponente mit einem Minimum zu verallgemeinern: indem wir Daten herunterladen und den gesamten Fluss weiterleiten. <br><br><img src="https://habrastorage.org/webt/nv/lr/1b/nvlr1bpwh_s1bw0lrlfk0py2zww.png"><br><br>  Ein solcher Container √ºbertr√§gt Daten vom Server an die Anwendung, die mit Logik in einen fertigen Bildschirm konvertiert werden.  Die einzige Anforderung besteht darin, dass an einen solchen Container √ºbergebene Bildschirme Abh√§ngigkeiten erf√ºllen m√ºssen, um mit der Logik des gesamten Flusses zu interagieren. <br><br>  Nachdem wir diesen Trick mit einigen Anwendungen durchgef√ºhrt hatten, stellten wir fest, dass die Logik der Bildschirme fast dieselbe ist.  In einer idealen Welt w√ºrden wir eine gemeinsame Logik erstellen, indem wir die Ansicht anpassen.  Die Frage ist, wie man sie anpasst. <br><br>  Wie Sie der Beschreibung von MVICore entnehmen k√∂nnen, basieren sowohl Ansicht als auch Funktion auf der Schnittstelle von ObservableSource und Consumer.  Wenn wir sie als Abstraktion verwenden, k√∂nnen wir die Implementierung ersetzen, ohne die Hauptteile zu √§ndern. <br><br><img src="https://habrastorage.org/webt/ay/ox/lo/ayoxlo24e49tsprdsdxplsdv4yo.png"><br><br>  Also verwenden wir die Logik wieder, indem wir die Benutzeroberfl√§che teilen.  Infolgedessen wird die Unterst√ºtzung viel bequemer. <br><br><h3>  Unterst√ºtzung </h3><br>  Betrachten Sie den A / B-Test f√ºr die Variation visueller Elemente.  In diesem Fall √§ndert sich unsere Logik nicht, sodass wir die vorhandene Schnittstelle von ObservableSource und Consumer durch eine andere View-Implementierung ersetzen k√∂nnen. <br><br><img src="https://habrastorage.org/webt/ag/qg/vm/agqgvmwnzn_cztnwovas8jk9ydw.png"><br><br>  Nat√ºrlich widersprechen manchmal neue Anforderungen bereits geschriebener Logik.  In diesem Fall k√∂nnen wir jederzeit zum urspr√ºnglichen Schema zur√ºckkehren, in dem die Anwendung den gesamten Bildschirm bereitstellt.  F√ºr uns ist es eine Art "Black Box", und es spielt f√ºr den Container keine Rolle, was er an ihn weitergibt, solange seine Schnittstelle respektiert wird. <br><br><h3>  Integration </h3><br>  Wie die Praxis zeigt, verwenden die meisten Anwendungen Aktivit√§t als Grundeinheit, deren Kommunikationsmittel seit langem bekannt sind.  Wir mussten lediglich lernen, wie Komponenten in Activity verpackt und Daten durch Eingabe und Ausgabe √ºbertragen werden.  Wie sich herausstellte, funktioniert dieser Ansatz gut mit Fragmenten. <br><br>  Bei Anwendungen mit einer Aktivit√§t √§ndert sich nicht viel.  Fast alle Frameworks bieten ihre Grundelemente an, in die sich RIB-Komponenten einwickeln lassen. <br><br><h2>  Zusammenfassend </h2><br>  Nach diesen Phasen haben wir den Prozentsatz der Wiederverwendung von Code zwischen den Projekten unseres Unternehmens erheblich erh√∂ht.  Derzeit n√§hert sich die Anzahl der Komponenten 100, und die meisten von ihnen implementieren Funktionen f√ºr mehrere Anwendungen gleichzeitig. <br><br>  Unsere Erfahrung zeigt, dass: <br><br><ul><li>  Trotz der zunehmenden Komplexit√§t beim Entwerfen gemeinsamer Komponenten ist ihre Unterst√ºtzung angesichts der Anforderungen unterschiedlicher Anwendungen auf lange Sicht viel einfacher. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Indem</a> wir Komponenten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">isoliert voneinander bauen</a> , haben wir ihre Integration in Anwendungen, die auf unterschiedlichen Prinzipien basieren, erheblich vereinfacht. <br></li><li>  Prozessrevisionen wirken sich zusammen mit der Betonung der Komponentenentwicklung und -unterst√ºtzung positiv auf die Qualit√§t der Gesamtfunktionalit√§t aus. <br></li></ul><br>  Mein Kollege Zsolt Kocsi hat zuvor √ºber MVICore und die Ideen dahinter geschrieben.  Ich empfehle dringend, seine Artikel zu lesen, die wir in unserem Blog √ºbersetzt haben ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3</a> ). <br><br>  √úber RIBs k√∂nnen Sie den Originalartikel von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Uber</a> lesen.  Und f√ºr praktisches Wissen empfehle ich, ein paar Lektionen <a href="">von uns zu nehmen</a> (auf Englisch). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466049/">https://habr.com/ru/post/de466049/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466033/index.html">Wie man ein Team in die Suche nach Ideen einbezieht und viel mehr als nur Ideen bekommt</a></li>
<li><a href="../de466039/index.html">PHP-Bibliotheken f√ºr den E-Commerce: Arbeiten mit ATOL und Payture, Parsen von GS1-Codes und anderen Aufgaben</a></li>
<li><a href="../de466041/index.html">Das erste Offline-Event des Facebook Developer Circle: Moskauer Community - Launch Event</a></li>
<li><a href="../de466045/index.html">Wie man eine Marke wiederbelebt: Storytelling, das funktioniert hat</a></li>
<li><a href="../de466047/index.html">Online-Shops gestalten. Teil 3. Homepage und Katalog</a></li>
<li><a href="../de466051/index.html">Automatisieren Sie die Profilerstellung f√ºr Java Meetup 10/09</a></li>
<li><a href="../de466053/index.html">Vertretung russischer IT-Unternehmen in Singapur: Warum nicht?</a></li>
<li><a href="../de466059/index.html">Buch ‚ÄûDesign Thinking. Vom Einblick zu neuen Produkten und M√§rkten ‚Äú</a></li>
<li><a href="../de466065/index.html">PostgreSQL News Digest. Ausgabe Nr. 17</a></li>
<li><a href="../de466067/index.html">Bezaubernder Bildschirmschoner f√ºr Kodi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>