<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🤝‍👨🏻 🎩 🉐 Vom Kopieren und Einfügen zu Komponenten: Wiederverwendung von Code in verschiedenen Anwendungen 🕴🏿 🙍🏽 📘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Badoo entwickelt mehrere Anwendungen, von denen jede ein separates Produkt mit eigenen Eigenschaften, Management-, Produkt- und Entwicklungsteams ist....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vom Kopieren und Einfügen zu Komponenten: Wiederverwendung von Code in verschiedenen Anwendungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/466049/"><img src="https://habrastorage.org/webt/4j/xp/to/4jxptoi9jrqf5aynpoeurc816ee.jpeg"><br><br>  Badoo entwickelt mehrere Anwendungen, von denen jede ein separates Produkt mit eigenen Eigenschaften, Management-, Produkt- und Entwicklungsteams ist.  Aber wir arbeiten alle im selben Büro zusammen und lösen ähnliche Probleme. <br><br>  Die Entwicklung jedes Projekts erfolgte auf seine eigene Weise.  Die Codebasis wurde nicht nur von unterschiedlichen Zeitrahmen und Produktlösungen beeinflusst, sondern auch von der Vision der Entwickler.  Am Ende haben wir festgestellt, dass die Projekte dieselbe Funktionalität haben, die sich in der Implementierung grundlegend unterscheidet. <br><br>  Dann haben wir uns für eine Struktur entschieden, die uns die Möglichkeit gibt, Funktionen zwischen Anwendungen wiederzuverwenden.  Anstatt Funktionen in einzelnen Projekten zu entwickeln, erstellen wir jetzt gemeinsame Komponenten, die in alle Produkte integriert werden.  Wenn Sie daran interessiert sind, wie wir dazu gekommen sind, begrüßen Sie bitte bei cat. <a name="habracut"></a><br><br>  Aber zuerst wollen wir uns mit den Problemen befassen, deren Lösung zur Schaffung gemeinsamer Komponenten führte.  Es gab mehrere von ihnen: <br><br><ul><li>  Kopieren und Einfügen zwischen Anwendungen; <br></li><li>  Prozesse, bei denen Stöcke in die Räder eingeführt werden; <br></li><li>  unterschiedliche Architektur von Projekten. <br></li></ul><br><img src="https://habrastorage.org/webt/wq/ls/ov/wqlsovroayg0xhqrwibqc37pv6y.png"><br><br>  <i>Dieser Artikel ist eine Textversion meines Berichts mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AppsConf 2019</a> , die hier eingesehen werden kann.</i> <br><br><h2>  Problem: Kopieren Einfügen </h2><br>  Vor einiger Zeit, als die Bäume unschärfer waren, das Gras grüner und ich ein Jahr jünger, hatten wir oft die folgende Situation. <br><br>  Es gibt einen Entwickler, nennen wir ihn Lesha.  Er macht ein cooles Modul für seine Aufgabe, erzählt seinen Kollegen davon und legt es im Repository für seine Anwendung ab, wo er es verwendet. <br><br>  Das Problem ist, dass sich alle unsere Anwendungen in verschiedenen Repositorys befinden. <br><br><img src="https://habrastorage.org/webt/-a/1f/zq/-a1fzqhp9m--jhxy1tcrmx7plwi.png"><br><br>  Entwickler Andrey arbeitet derzeit nur an einer anderen Anwendung in einem anderen Repository.  Er möchte dieses Modul für seine Aufgabe verwenden, die der von Lesha verdächtig ähnlich ist.  Es gibt jedoch ein Problem: Der Prozess der Wiederverwendung von Code ist vollständig debuggt. <br><br>  In dieser Situation schreibt Andrei entweder seine Entscheidung (was in 80% der Fälle der Fall ist) oder kopiert die Lösung von Lyosha und ändert alles darin, damit es zu seiner Anwendung, Aufgabe oder Stimmung passt. <br><br><img src="https://habrastorage.org/webt/2e/nd/95/2end959nckg-szaxu_nwwwcqxtm.png"><br><br>  Danach kann Lesha sein Modul aktualisieren, indem er Änderungen an seinem Code für seine Aufgabe hinzufügt.  Er kennt keine andere Version und aktualisiert nur sein Repository. <br><br>  Diese Situation bringt mehrere Probleme mit sich. <br><br>  Erstens haben wir mehrere Anwendungen mit jeweils eigener Entwicklungsgeschichte.  Bei der Arbeit an jeder Anwendung erstellte das Produktteam häufig Lösungen, die sich nur schwer in eine einzelne Struktur integrieren lassen. <br><br>  Zweitens sind separate Teams an Projekten beteiligt, die schlecht miteinander kommunizieren und sich daher selten über Aktualisierungen / Wiederverwendung des einen oder anderen Moduls informieren. <br><br>  Drittens ist die Anwendungsarchitektur sehr unterschiedlich: von MVP zu MVI, von Gottaktivität zu Einzelaktivität. <br><br>  Nun, das „Highlight des Programms“: Anwendungen befinden sich in verschiedenen Repositories mit jeweils eigenen Prozessen. <br><br>  Zu Beginn des Kampfes gegen diese Probleme haben wir uns das ultimative Ziel gesetzt: unsere Best Practices (sowohl Logik als auch Benutzeroberfläche) zwischen allen Anwendungen wiederzuverwenden. <br><br><h2>  Entscheidungen: Wir etablieren Prozesse </h2><br>  Von den oben genannten Problemen hängen zwei mit den Prozessen zusammen: <br><br><ol><li>  Zwei Repositories, die Projekte mit einer undurchdringlichen Wand gemeinsam nutzen. <br></li><li>  Separate Teams ohne etablierte Kommunikation und unterschiedliche Anforderungen der Produktanwendungsteams. <br></li></ol><br>  Beginnen wir mit dem ersten: Wir haben es mit zwei Repositorys mit derselben Modulversion zu tun.  Theoretisch könnten wir git-subtree oder ähnliche Lösungen verwenden und gemeinsame Projektmodule in separate Repositories stellen. <br><br><img src="https://habrastorage.org/webt/ro/q0/nr/roq0nrr9xuy2my8ajbsldfcismw.png"><br><br>  Das Problem tritt während der Änderung auf.  Im Gegensatz zu Open-Source-Projekten, die über eine stabile API verfügen und über externe Quellen verteilt werden, treten häufig Änderungen an internen Komponenten auf, die alles beschädigen.  Bei Verwendung eines Teilbaums wird jede solche Migration zu einem Schmerz. <br><br>  Meine Kollegen vom iOS-Team haben ähnliche Erfahrungen gemacht, und es stellte sich als nicht sehr erfolgreich heraus, wie Anton Schukin letztes Jahr auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Mobius-Konferenz</a> sagte. <br><br>  Nachdem wir ihre Erfahrungen studiert und verstanden hatten, wechselten wir zu einem einzigen Repository.  Alle Android-Anwendungen befinden sich jetzt an einem Ort, was uns bestimmte Vorteile bietet: <br><br><ul><li>  Sie können den Code mithilfe von Gradle-Modulen sicher wiederverwenden. <br></li><li>  Wir haben es geschafft, die Toolchain auf CI mithilfe einer einzigen Infrastruktur für Builds und Tests zu verbinden. <br></li><li>  Diese Änderungen haben die physische und einige mentale Barriere zwischen den Teams beseitigt, da wir nun frei sind, die Entwicklungen und Lösungen des anderen zu nutzen. <br></li></ul><br>  Natürlich hat diese Lösung auch Nachteile.  Wir haben ein riesiges Projekt, das manchmal nicht IDE und Gradle unterliegt.  Das Problem könnte teilweise durch die Lade- / Entlademodule in Android Studio gelöst werden. Es ist jedoch schwierig, sie zu verwenden, wenn Sie gleichzeitig an allen Anwendungen arbeiten und häufig wechseln müssen. <br><br>  Das zweite Problem - die Interaktion zwischen Teams - bestand aus mehreren Teilen: <br><br><ul><li>  getrennte Teams ohne etablierte Kommunikation; <br></li><li>  undeutliche Verteilung der Verantwortung für gemeinsame Module; <br></li><li>  unterschiedliche Anforderungen der Produktteams. <br></li></ul><br>  Um dieses Problem zu lösen, haben wir Teams gebildet, die bestimmte Funktionen in jeder Anwendung implementieren: zum Beispiel Chat oder Registrierung.  Neben der Entwicklung sind sie auch für die Integration dieser Komponenten in die Anwendung verantwortlich. <br><br>  Produktteams haben bereits vorhandene Komponenten in der Hand, um sie zu verbessern und an die Anforderungen eines bestimmten Projekts anzupassen. <br><br>  Somit ist die Erstellung einer wiederverwendbaren Komponente nun Teil des Prozesses für das gesamte Unternehmen, von der Phase der Idee bis zum Beginn der Produktion. <br><br><h2>  Lösungen: Rationalisierung der Architektur </h2><br>  Unser nächster Schritt zur Wiederverwendung war die Rationalisierung der Architektur.  Warum haben wir das gemacht? <br><br>  Unsere Codebasis trägt das historische Erbe einer mehrjährigen Entwicklung.  Mit der Zeit und den Menschen änderten sich auch die Ansätze.  Wir befanden uns also in einer Situation mit einem ganzen Zoo von Architekturen, die zu folgenden Problemen führte: <br><br><ol><li>  Die Integration gängiger Module war fast langsamer als das Schreiben neuer.  Zusätzlich zu den Merkmalen der Funktion war es notwendig, die Struktur sowohl der Komponente als auch der Anwendung zu ertragen. <br></li><li>  Entwickler, die sehr oft zwischen Anwendungen wechseln mussten, verbrachten viel Zeit damit, neue Ansätze zu beherrschen. <br></li><li>  Oft wurden Wrapper von einem Ansatz zum anderen geschrieben, was der Hälfte des Codes in der Modulintegration entsprach. <br></li></ol><br>  Am Ende haben wir uns für den MVI-Ansatz entschieden, den wir in unserer MVICore-Bibliothek ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> ) strukturiert haben.  Wir waren besonders an einer seiner Funktionen interessiert - Atomzustandsaktualisierungen, die immer die Gültigkeit garantieren.  Wir gingen etwas weiter und kombinierten die Zustände der logischen und der Präsentationsebene, um die Fragmentierung zu verringern.  Auf diese Weise gelangen wir zu einer Struktur, in der die einzige Entität für die Logik verantwortlich ist und in der Ansicht nur das aus dem Status erstellte Modell angezeigt wird. <br><br><img src="https://habrastorage.org/webt/ze/4z/kr/ze4zkr0ecnm_x9il17ibon6uzkk.png"><br><br>  Die Trennung von Verantwortlichkeiten erfolgt durch die Transformation von Modellen zwischen Ebenen.  Dank dessen erhalten wir einen Bonus in Form von Wiederverwendbarkeit.  Wir verbinden die Elemente von außen, das heißt, jeder von ihnen ahnt nicht, dass der andere existiert - sie verschenken einfach einige Modelle und reagieren auf das, was zu ihnen kommt.  Auf diese Weise können Sie Komponenten herausziehen und an anderer Stelle verwenden, indem Sie Adapter für ihre Modelle schreiben. <br><br>  Schauen wir uns ein Beispiel eines einfachen Bildschirms an, wie er in der Realität aussieht. <br><br><img src="https://habrastorage.org/webt/wm/0k/cs/wm0kcsuh1io0cr4cnil0ui11gme.png"><br><br>  Wir verwenden die grundlegenden RxJava-Schnittstellen, um die Typen anzugeben, mit denen das Element arbeitet.  Die Eingabe wird durch die Schnittstelle Consumer &lt;T&gt;, Ausgabe - ObservableSource &lt;T&gt; bezeichnet. <br><br><pre><code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// input = Consumer&lt;ViewModel&gt; // output = ObservableSource&lt;Event&gt; class View( val events: PublishRelay&lt;Event&gt; ): ObservableSource&lt;Event&gt; by events, Consumer&lt;ViewModel&gt; { val button: Button val textView: TextView init { button.setOnClickListener { events.accept(Event.ButtonClick) } } override fun accept(model: ViewModel) { textView.text = model.text } }</span></span></code> </pre> <br>  Über diese Schnittstellen können wir View als Consumer &lt;ViewModel&gt; und ObservableSource &lt;Event&gt; ausdrücken.  Beachten Sie, dass das ViewModel nur den Status des Bildschirms enthält und wenig mit MVVM zu tun hat.  Nachdem wir das Modell erhalten haben, können wir die Daten daraus anzeigen. Wenn wir auf die Schaltfläche klicken, senden wir das Ereignis, das nach draußen übertragen wird. <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// input = Consumer&lt;Wish&gt; // output = ObservableSource&lt;State&gt; class Feature: ReducerFeature&lt;Wish, State&gt;( initialState = State(counter = 0), reducer = ReducerImpl() ) { class ReducerImpl: Reducer&lt;Wish, State&gt; { override fun invoke(state: State, wish: Wish) = when (wish) { is Increment -&gt; state.copy(counter = state.counter + 1) } } }</span></span></code> </pre> <br>  Feature implementiert ObservableSource und Consumer bereits für uns;  Wir müssen dort den Anfangszustand (Zähler gleich 0) übertragen und angeben, wie dieser Zustand geändert werden soll. <br><br>  Nach der Übertragung von Wish wird Reducer aufgerufen, wodurch basierend auf dem letzten Status ein neuer erstellt wird.  Zusätzlich zum Reduzierer kann die Logik durch andere Komponenten beschrieben werden.  Hier können Sie mehr darüber erfahren. <br><br>  Nachdem wir die beiden Elemente erstellt haben, müssen wir sie verbinden. <br><br><img width="250" src="https://habrastorage.org/webt/pq/kh/jp/pqkhjphpe4pvypmm5y8icqralhy.png" align="left"><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> eventToWish: (Event) -&gt; Wish = { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (it) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ButtonClick -&gt; Increment } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> stateToModel: (State) -&gt; ViewModel = { ViewModel(text = state.counter.toString()) } Binder().apply { bind(view to feature using eventToWish) bind(feature to view using stateToModel) }</code> </pre> <br>  Zunächst geben wir an, wie wir ein Element eines Typs in ein anderes umwandeln.  ButtonClick wird also zu Inkrement und das Zählerfeld von State wird in Text eingefügt. <br><br>  Jetzt können wir jede der Ketten mit der gewünschten Transformation erstellen.  Dafür verwenden wir Binder.  Sie können damit Beziehungen zwischen ObservableSource und Consumer erstellen und den Lebenszyklus beobachten.  Und das alles mit einer schönen Syntax.  Diese Art der Verbindung führt uns zu einem flexiblen System, mit dem wir Elemente einzeln herausziehen und verwenden können. <br><br>  MVICore-Elemente funktionieren sehr gut mit unserem „Zoo“ von Architekturen, nachdem Wrapper von ObservableSource und Consumer geschrieben wurden.  Beispielsweise können wir Use-Case-Methoden aus Clean Architecture in Wish / State einschließen und in der Kette anstelle von Feature verwenden. <br><br><img src="https://habrastorage.org/webt/l3/x7/ee/l3x7eef1pxxq4qbl6epceicz_1a.png"><br><br><h2>  Komponente </h2><br>  Schließlich gehen wir zu den Komponenten über.  Wie sind sie? <br><br>  Betrachten Sie den Bildschirm in der Anwendung und teilen Sie ihn in logische Teile. <br><br><img src="https://habrastorage.org/webt/s6/xb/mg/s6xbmgomehcdqao1psynv5mnnlc.png"><br><br>  Es kann unterschieden werden: <br><br><ul><li>  Symbolleiste mit Logo und Schaltflächen oben; <br></li><li>  eine Karte mit Profil und Logo; <br></li><li>  Instagram-Bereich. <br></li></ul><br>  Jeder dieser Teile ist genau die Komponente, die in einem völlig anderen Kontext wiederverwendet werden kann.  So kann der Instagram-Bereich Teil der Profilbearbeitung in einer anderen Anwendung werden. <br><br><img src="https://habrastorage.org/webt/o_/yh/c7/o_yhc7jqyzwma6l4nljmf2jasuk.png"><br><br>  Im allgemeinen Fall besteht eine Komponente aus mehreren Ansichten, Logikelementen und verschachtelten Komponenten, die durch gemeinsame Funktionen verbunden sind.  Und sofort stellt sich die Frage: Wie können sie zu einer unterstützten Struktur zusammengesetzt werden? <br><br>  Das erste Problem, auf das wir gestoßen sind, ist, dass MVICore beim Erstellen und Binden von Elementen hilft, jedoch keine gemeinsame Struktur bietet.  Bei der Wiederverwendung von Elementen aus einem gemeinsamen Modul ist nicht klar, wo diese Teile zusammengesetzt werden sollen: innerhalb des gemeinsamen Teils oder auf der Anwendungsseite? <br><br>  Im allgemeinen Fall wollen wir der Anwendung definitiv keine Streustücke geben.  Im Idealfall streben wir eine Struktur an, die es uns ermöglicht, Abhängigkeiten zu erhalten und die Komponente als Ganzes mit dem gewünschten Lebenszyklus zusammenzusetzen. <br><br>  Zunächst haben wir die Komponenten in Bildschirme unterteilt.  Die Verbindung der Elemente erfolgte neben der Erstellung von DI-Containern für Aktivität oder Fragment.  Diese Container kennen bereits alle Abhängigkeiten, haben Zugriff auf die Ansicht und den Lebenszyklus. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> SomeScopedComponent : ScopedComponent&lt;SomeComponent&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: SomeComponent { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DaggerSomeComponent.builder() .build() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> SomeComponent.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Array&lt;Disposable&gt; = arrayOf( Binder().apply { bind(feature().news to otherFeature()) bind(feature() to view()) } ) }</code> </pre> <br>  Probleme begannen an zwei Stellen gleichzeitig: <br><br><ol><li>  DI begann mit Logik zu arbeiten, was zur Beschreibung der gesamten Komponente in einer Klasse führte. <br></li><li>  Da der Container an eine Aktivität oder ein Fragment angehängt ist und mindestens den gesamten Bildschirm beschreibt, enthält ein solcher Bildschirm / Container viele Elemente, die sich in einer großen Menge an Code niederschlagen, um alle Abhängigkeiten dieses Bildschirms zu verbinden. <br></li></ol><br>  Um die Probleme der Reihe nach zu lösen, haben wir zunächst die Logik in eine separate Komponente eingefügt.  So können wir alle Funktionen in dieser Komponente sammeln und über Eingabe und Ausgabe mit View kommunizieren.  Aus Sicht der Benutzeroberfläche sieht es wie ein reguläres MVICore-Element aus, wird jedoch gleichzeitig aus mehreren anderen Elementen erstellt. <br><br><img src="https://habrastorage.org/webt/bx/xf/ih/bxxfihgylnpbclxg3o9pcem9xr8.png"><br><br>  Nachdem wir dieses Problem gelöst hatten, teilten wir die Verantwortung für die Verbindung der Elemente.  Trotzdem haben wir die Komponenten auf den Bildschirmen geteilt, was für uns eindeutig nicht zur Hand war, was zu einer großen Anzahl von Abhängigkeiten an einem Ort führte. <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Scope</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> params: ScreenParams, news: NewsRelay, <span class="hljs-meta"><span class="hljs-meta">@OnDisposeAction</span></span> onDisposeAction: () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>, globalFeature: GlobalFeature, conversationControlFeature: ConversationControlFeature, messageSyncFeature: MessageSyncFeature, conversationInfoFeature: ConversationInfoFeature, conversationPromoFeature: ConversationPromoFeature, messagesFeature: MessagesFeature, messageActionFeature: MessageActionFeature, initialScreenFeature: InitialScreenFeature, initialScreenExplanationFeature: InitialScreenExplanationFeature?, errorFeature: ErrorFeature, conversationInputFeature: ConversationInputFeature, sendRegularFeature: SendRegularFeature, sendContactForCreditsFeature: SendContactForCreditsFeature, screenEventTrackingFeature: ScreenEventTrackingFeature, messageReadFeature: MessageReadFeature?, messageTimeFeature: MessageTimeFeature?, photoGalleryFeature: PhotoGalleryFeature?, onlineStatusFeature: OnlineStatusFeature?, favouritesFeature: FavouritesFeature?, isTypingFeature: IsTypingFeature?, giftStoreFeature: GiftStoreFeature?, messageSelectionFeature: MessageSelectionFeature?, reportingFeature: ReportingFeature?, takePhotoFeature: TakePhotoFeature?, giphyFeature: GiphyFeature, goodOpenersFeature: GoodOpenersFeature?, matchExpirationFeature: MatchExpirationFeature, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pushIntegration: PushIntegration ) : AbstractMviComponent&lt;UiEvent, States&gt;(</code> </pre> <br>  Die richtige Lösung in dieser Situation besteht darin, die Komponente zu beschädigen.  Wie wir oben gesehen haben, besteht jeder Bildschirm aus vielen logischen Elementen, die wir in unabhängige Teile unterteilen können. <br><br>  Nach einigem Nachdenken kamen wir zu einer Baumstruktur und bauten sie naiv aus vorhandenen Komponenten auf und erhielten dieses Schema: <br><br><img src="https://habrastorage.org/webt/el/yl/v1/elylv1elwdrgyoqdamiepx0lleo.png"><br><br>  Natürlich ist es fast unmöglich, die Synchronisation zweier Bäume (aus der Ansicht und aus der Logik) aufrechtzuerhalten.  Wenn die Komponente jedoch für die Anzeige ihrer Ansicht verantwortlich ist, können wir dieses Schema vereinfachen.  Nachdem wir die bereits erstellten Lösungen untersucht hatten, überlegten wir unseren Ansatz und stützten uns auf die RIBs von Uber. <br><br><img src="https://habrastorage.org/webt/sy/xt/kd/syxtkdw8uiusbnrneqna1-bqfbe.png"><br><br>  Die Ideen hinter diesem Ansatz sind den Grundlagen von MVICore sehr ähnlich.  RIB ist eine Art „Black Box“, deren Kommunikation über eine streng definierte Schnittstelle von Abhängigkeiten (nämlich Eingabe und Ausgabe) erfolgt.  Trotz der offensichtlichen Komplexität der Unterstützung einer solchen Schnittstelle in einem schnell iterativen Produkt erhalten wir großartige Möglichkeiten zur Wiederverwendung von Code. <br><br>  Im Vergleich zu früheren Iterationen erhalten wir also: <br><br><ul><li>  gekapselte Logik innerhalb einer Komponente; <br></li><li>  Unterstützung für das Verschachteln, wodurch Bildschirme in Teile unterteilt werden können; <br></li><li>  Interaktion mit anderen Komponenten über eine strikte Schnittstelle von Eingabe / Ausgabe mit Unterstützung für MVICore; <br></li><li>  Kompilierzeitsichere Verbindung von Komponentenabhängigkeiten (basierend auf Dagger als DI). <br></li></ul><br>  Das ist natürlich alles andere als gut.  Das Repository auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> enthält eine detailliertere und aktuellere Beschreibung. <br><br>  Und hier haben wir eine perfekte Welt.  Es enthält Komponenten, aus denen wir einen vollständig wiederverwendbaren Baum erstellen können. <br><br>  Aber wir leben in einer unvollkommenen Welt. <br><br><h2>  Willkommen in der Realität! </h2><br>  In einer unvollkommenen Welt gibt es eine Reihe von Dingen, die wir ertragen müssen.  Wir sind besorgt über Folgendes: <br><br><ul><li>  Unterschiedliche Funktionen: Trotz aller Vereinheitlichung haben wir es immer noch mit einzelnen Produkten mit unterschiedlichen Anforderungen zu tun. <br></li><li>  Support: Wie ohne neue Funktionalität bei A / B-Tests? <br></li><li>  Vermächtnis (alles, was vor unserer neuen Architektur geschrieben wurde). <br></li></ul><br>  Die Komplexität von Lösungen nimmt exponentiell zu, da jede Anwendung gemeinsamen Komponenten etwas Eigenes hinzufügt. <br><br>  Betrachten Sie den Registrierungsprozess als Beispiel für eine allgemeine Komponente, die in Anwendungen integriert wird.  Im Allgemeinen ist die Registrierung eine Kette von Bildschirmen mit Aktionen, die sich auf den gesamten Ablauf auswirken.  Jede Anwendung verfügt über unterschiedliche Bildschirme und eine eigene Benutzeroberfläche.  Das ultimative Ziel ist es, eine flexible wiederverwendbare Komponente herzustellen, die uns auch hilft, die Probleme aus der obigen Liste zu lösen. <br><br><img src="https://habrastorage.org/webt/22/v6/cd/22v6cdpd9uf8ebuxcdo0j4mgc5a.png"><br><br><h3>  Verschiedene Anforderungen </h3><br>  Jede Anwendung hat ihre eigenen Registrierungsvarianten, sowohl von der Logikseite als auch von der UI-Seite.  Daher beginnen wir, die Funktionalität in der Komponente mit einem Minimum zu verallgemeinern: indem wir Daten herunterladen und den gesamten Fluss weiterleiten. <br><br><img src="https://habrastorage.org/webt/nv/lr/1b/nvlr1bpwh_s1bw0lrlfk0py2zww.png"><br><br>  Ein solcher Container überträgt Daten vom Server an die Anwendung, die mit Logik in einen fertigen Bildschirm konvertiert werden.  Die einzige Anforderung besteht darin, dass an einen solchen Container übergebene Bildschirme Abhängigkeiten erfüllen müssen, um mit der Logik des gesamten Flusses zu interagieren. <br><br>  Nachdem wir diesen Trick mit einigen Anwendungen durchgeführt hatten, stellten wir fest, dass die Logik der Bildschirme fast dieselbe ist.  In einer idealen Welt würden wir eine gemeinsame Logik erstellen, indem wir die Ansicht anpassen.  Die Frage ist, wie man sie anpasst. <br><br>  Wie Sie der Beschreibung von MVICore entnehmen können, basieren sowohl Ansicht als auch Funktion auf der Schnittstelle von ObservableSource und Consumer.  Wenn wir sie als Abstraktion verwenden, können wir die Implementierung ersetzen, ohne die Hauptteile zu ändern. <br><br><img src="https://habrastorage.org/webt/ay/ox/lo/ayoxlo24e49tsprdsdxplsdv4yo.png"><br><br>  Also verwenden wir die Logik wieder, indem wir die Benutzeroberfläche teilen.  Infolgedessen wird die Unterstützung viel bequemer. <br><br><h3>  Unterstützung </h3><br>  Betrachten Sie den A / B-Test für die Variation visueller Elemente.  In diesem Fall ändert sich unsere Logik nicht, sodass wir die vorhandene Schnittstelle von ObservableSource und Consumer durch eine andere View-Implementierung ersetzen können. <br><br><img src="https://habrastorage.org/webt/ag/qg/vm/agqgvmwnzn_cztnwovas8jk9ydw.png"><br><br>  Natürlich widersprechen manchmal neue Anforderungen bereits geschriebener Logik.  In diesem Fall können wir jederzeit zum ursprünglichen Schema zurückkehren, in dem die Anwendung den gesamten Bildschirm bereitstellt.  Für uns ist es eine Art "Black Box", und es spielt für den Container keine Rolle, was er an ihn weitergibt, solange seine Schnittstelle respektiert wird. <br><br><h3>  Integration </h3><br>  Wie die Praxis zeigt, verwenden die meisten Anwendungen Aktivität als Grundeinheit, deren Kommunikationsmittel seit langem bekannt sind.  Wir mussten lediglich lernen, wie Komponenten in Activity verpackt und Daten durch Eingabe und Ausgabe übertragen werden.  Wie sich herausstellte, funktioniert dieser Ansatz gut mit Fragmenten. <br><br>  Bei Anwendungen mit einer Aktivität ändert sich nicht viel.  Fast alle Frameworks bieten ihre Grundelemente an, in die sich RIB-Komponenten einwickeln lassen. <br><br><h2>  Zusammenfassend </h2><br>  Nach diesen Phasen haben wir den Prozentsatz der Wiederverwendung von Code zwischen den Projekten unseres Unternehmens erheblich erhöht.  Derzeit nähert sich die Anzahl der Komponenten 100, und die meisten von ihnen implementieren Funktionen für mehrere Anwendungen gleichzeitig. <br><br>  Unsere Erfahrung zeigt, dass: <br><br><ul><li>  Trotz der zunehmenden Komplexität beim Entwerfen gemeinsamer Komponenten ist ihre Unterstützung angesichts der Anforderungen unterschiedlicher Anwendungen auf lange Sicht viel einfacher. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Indem</a> wir Komponenten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">isoliert voneinander bauen</a> , haben wir ihre Integration in Anwendungen, die auf unterschiedlichen Prinzipien basieren, erheblich vereinfacht. <br></li><li>  Prozessrevisionen wirken sich zusammen mit der Betonung der Komponentenentwicklung und -unterstützung positiv auf die Qualität der Gesamtfunktionalität aus. <br></li></ul><br>  Mein Kollege Zsolt Kocsi hat zuvor über MVICore und die Ideen dahinter geschrieben.  Ich empfehle dringend, seine Artikel zu lesen, die wir in unserem Blog übersetzt haben ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3</a> ). <br><br>  Über RIBs können Sie den Originalartikel von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Uber</a> lesen.  Und für praktisches Wissen empfehle ich, ein paar Lektionen <a href="">von uns zu nehmen</a> (auf Englisch). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466049/">https://habr.com/ru/post/de466049/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466033/index.html">Wie man ein Team in die Suche nach Ideen einbezieht und viel mehr als nur Ideen bekommt</a></li>
<li><a href="../de466039/index.html">PHP-Bibliotheken für den E-Commerce: Arbeiten mit ATOL und Payture, Parsen von GS1-Codes und anderen Aufgaben</a></li>
<li><a href="../de466041/index.html">Das erste Offline-Event des Facebook Developer Circle: Moskauer Community - Launch Event</a></li>
<li><a href="../de466045/index.html">Wie man eine Marke wiederbelebt: Storytelling, das funktioniert hat</a></li>
<li><a href="../de466047/index.html">Online-Shops gestalten. Teil 3. Homepage und Katalog</a></li>
<li><a href="../de466051/index.html">Automatisieren Sie die Profilerstellung für Java Meetup 10/09</a></li>
<li><a href="../de466053/index.html">Vertretung russischer IT-Unternehmen in Singapur: Warum nicht?</a></li>
<li><a href="../de466059/index.html">Buch „Design Thinking. Vom Einblick zu neuen Produkten und Märkten “</a></li>
<li><a href="../de466065/index.html">PostgreSQL News Digest. Ausgabe Nr. 17</a></li>
<li><a href="../de466067/index.html">Bezaubernder Bildschirmschoner für Kodi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>