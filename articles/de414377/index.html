<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí¶ üö¨ üë®üèΩ Innovationen von Objektliteralen in JavaScript ES6 üßùüèΩ üö¥üèæ ‚õìÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Material, dessen √úbersetzung wir Ihnen vorstellen, widmet sich der Untersuchung der Merkmale von Objektliteralen in JavaScript, insbesondere der I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Innovationen von Objektliteralen in JavaScript ES6</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/414377/">  Das Material, dessen √úbersetzung wir Ihnen vorstellen, widmet sich der Untersuchung der Merkmale von Objektliteralen in JavaScript, insbesondere der Innovationen, die in neueren Versionen des ECMAScript-Standards erschienen sind. <br><br>  JavaScript bietet eine leistungsstarke und bequeme M√∂glichkeit, Objekte mithilfe von Objektliteralen zu erstellen.  Der ES2015 (ES6) -Standard vereinfacht das Arbeiten mit Objekten beim Erstellen von Anwendungen f√ºr moderne Browser (au√üer IE) und f√ºr die Node.js-Plattform. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/z0/iq/f2/z0iqf21z0nrwpezfudp6vjkmfvc.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Die Grundlagen</font> </h2><br>  Das Erstellen von Objekten in einigen Sprachen kann ressourcenintensiv sein. Damit meinen wir sowohl die Arbeitszeit des Programmierers als auch die Rechenressourcen der Systeme.  Insbesondere geht es um die Tatsache, dass Sie vor dem Erstellen von Objekten die Klassen beschreiben m√ºssen (z. B. mit dem Schl√ºsselwort <code>class</code> ).  In JavaScript k√∂nnen Objekte sehr schnell und einfach erstellt werden, ohne dass vorbereitende Schritte erforderlich sind.  Betrachten Sie ein Beispiel: <br><br><pre> <code class="hljs lua">// ES5 var myObject = { prop1: <span class="hljs-string"><span class="hljs-string">'hello'</span></span>, prop2: <span class="hljs-string"><span class="hljs-string">'world'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(this.prop1 + <span class="hljs-string"><span class="hljs-string">' '</span></span> + this.prop2); } }; myObject.<span class="hljs-built_in"><span class="hljs-built_in">output</span></span>(); // hello world</code> </pre> <br>  Bei der Programmierung werden h√§ufig "Einweg" -Objekte verwendet.  Sie speichern Einstellungen und andere Daten, sie werden als Parameter von Funktionen, als von Funktionen zur√ºckgegebene Werte und in anderen Situationen verwendet.  In solchen F√§llen erweisen sich JavaScript-Objektliterale als sehr n√ºtzlich, und ES6 erweitert ihre Funktionen. <br><br><h2>  <font color="#3AC1EF">Initialisierung von Objekten aus Variablen</font> </h2><br>  Eigenschaften von Objekten werden h√§ufig aus Variablen erstellt, indem ihnen dieselben Namen zugewiesen werden, die diesen Variablen bereits zugewiesen sind.  Zum Beispiel: <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// ES5 var a = 1, b = 2, c = 3; obj = {   a: a,   b: b,   c: c }; // obj.a = 1, obj.b = 2, obj.c = 3</span></span></code> </pre> <br>  In ES6 m√ºssen Sie Variablennamen nicht mehr wiederholen: <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// ES6 const a = 1, b = 2, c = 3; obj = {   a,   b,   c }; // obj.a = 1, obj.b = 2, obj.c = 3</span></span></code> </pre> <br>  Diese Technik kann f√ºr zur√ºckgegebene Objekte n√ºtzlich sein, wenn Sie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Revealing Module-</a> Muster verwenden, mit dem Sie Namespaces f√ºr verschiedene Codefragmente erstellen k√∂nnen, um Namenskonflikte zu vermeiden.  Zum Beispiel: <br><br><pre> <code class="hljs lua">// ES6 const lib = (() =&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span></span>  { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {   sum,   mult }; }()); console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>( lib.sum(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) );  // <span class="hljs-number"><span class="hljs-number">5</span></span> console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>( lib.mult(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) ); // <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre> <br>  M√∂glicherweise haben Sie gesehen, wie diese Technik in ES6-Modulen verwendet wird: <br><br><pre> <code class="hljs powershell">// lib.js <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span></span>  { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * b; } export { sum, mult };</code> </pre> <br><h2>  <font color="#3AC1EF">Kurzsyntax zum Deklarieren von Objektmethoden</font> </h2><br>  Wenn Sie Objektmethoden in ES5 deklarieren, m√ºssen Sie das <code>function</code> : <br><br><pre> <code class="hljs lua">// ES5 var lib = { sum:  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; }, mult: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * b; } }; console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>( lib.sum(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) );  // <span class="hljs-number"><span class="hljs-number">5</span></span> console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>( lib.mult(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) ); // <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre> <br>  In ES6 k√∂nnen Sie dies jetzt nicht mehr tun.  Die folgende Kurzform zur Deklaration von Methoden ist hier zul√§ssig: <br><br><pre> <code class="hljs pgsql">// ES6 const lib = { sum(a, b)  { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; }, mult(a, b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * b; } }; console.log( lib.sum(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) );  // <span class="hljs-number"><span class="hljs-number">5</span></span> console.log( lib.mult(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) ); // <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre> <br>  Es ist zu beachten, dass ES6-Pfeilfunktionen ( <code>=&gt;</code> ) hier nicht verwendet werden k√∂nnen, da Methoden Namen haben m√ºssen.  Pfeilfunktionen k√∂nnen jedoch verwendet werden, wenn Sie Methoden explizit Namen zuweisen (wie in ES5).  Zum Beispiel: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ES6 const lib = { sum:  <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span><span class="hljs-function"> =&gt;</span></span> a + b, mult: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span><span class="hljs-function"> =&gt;</span></span> a * b }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( lib.sum(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) );  <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( lib.mult(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) ); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Dynamische Tasten</font> </h2><br>  In ES5 konnten Sie keine Variablen als Schl√ºsselnamen verwenden, obwohl der Schl√ºssel, dessen Name der Variablen zugewiesen wurde, nach dem Erstellen des Objekts hinzugef√ºgt werden konnte.  Zum Beispiel: <br><br><pre> <code class="hljs powershell">// ES5 var key1 = <span class="hljs-string"><span class="hljs-string">'one'</span></span>, obj = {   two: <span class="hljs-number"><span class="hljs-number">2</span></span>,   three: <span class="hljs-number"><span class="hljs-number">3</span></span> }; obj[<span class="hljs-type"><span class="hljs-type">key1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; // obj.one = <span class="hljs-number"><span class="hljs-number">1</span></span>, obj.two = <span class="hljs-number"><span class="hljs-number">2</span></span>, obj.three = <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  In ES6 k√∂nnen Schl√ºssel dynamisch zugewiesen werden, indem ein Namensausdruck in eckige Klammern ( <code>[]</code> ) gesetzt wird.  Zum Beispiel: <br><br><pre> <code class="hljs powershell">// ES6 const key1 = <span class="hljs-string"><span class="hljs-string">'one'</span></span>, obj = {   [<span class="hljs-type"><span class="hljs-type">key1</span></span>]: <span class="hljs-number"><span class="hljs-number">1</span></span>,   two: <span class="hljs-number"><span class="hljs-number">2</span></span>,   three: <span class="hljs-number"><span class="hljs-number">3</span></span> }; // obj.one = <span class="hljs-number"><span class="hljs-number">1</span></span>, obj.two = <span class="hljs-number"><span class="hljs-number">2</span></span>, obj.three = <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Um einen Schl√ºssel zu erstellen, k√∂nnen Sie einen beliebigen Ausdruck verwenden: <br><br><pre> <code class="hljs powershell">// ES6 const i = <span class="hljs-number"><span class="hljs-number">1</span></span>, obj = {   [<span class="hljs-string"><span class="hljs-string">'i'</span></span> + <span class="hljs-type"><span class="hljs-type">i</span></span>]: i }; console.log(obj.i1); // <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Dynamische Schl√ºssel k√∂nnen sowohl f√ºr Methoden als auch f√ºr Eigenschaften verwendet werden: <br><br><pre> <code class="hljs powershell">// ES6 const i = <span class="hljs-number"><span class="hljs-number">2</span></span>, obj = {   [<span class="hljs-string"><span class="hljs-string">'mult'</span></span> + <span class="hljs-type"><span class="hljs-type">i</span></span>]: x =&gt; x * i }; console.log( obj.mult2(<span class="hljs-number"><span class="hljs-number">5</span></span>) ); // <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre> <br>  Eine andere Frage ist, ob Eigenschaften und Methoden mit dynamisch generierten Namen erstellt werden sollen.  Die Lesbarkeit des Codes, der diese Technik verwendet, kann beeintr√§chtigt sein.  Wenn Sie mit Situationen konfrontiert sind, in denen dynamische Namen angemessen erscheinen, ist es m√∂glicherweise besser, √ºber die Verwendung von Factory-Funktionen oder -Klassen zum Erstellen von Objekten nachzudenken. <br><br><h2>  <font color="#3AC1EF">Umstrukturierung</font> </h2><br>  Destrukturierung ist die Extraktion von Eigenschaften von Objekten und deren Zuordnung zu Variablen.  W√§hrend der Anwendungsentwicklung m√ºssen Sie h√§ufig den Wert einer Objekteigenschaft extrahieren und in eine Variable schreiben.  In ES5 mussten Sie dies mithilfe der Eigenschaftszugriffsbefehle wie folgt beschreiben: <br><br><pre> <code class="hljs pgsql">// ES5 var myObject = { one:   <span class="hljs-string"><span class="hljs-string">'a'</span></span>, two:   <span class="hljs-string"><span class="hljs-string">'b'</span></span>, three: <span class="hljs-string"><span class="hljs-string">'c'</span></span> }; var one   = myObject.one, // <span class="hljs-string"><span class="hljs-string">'a'</span></span> two   = myObject.two, // <span class="hljs-string"><span class="hljs-string">'b'</span></span> three = myObject.three; // <span class="hljs-string"><span class="hljs-string">'c'</span></span></code> </pre> <br>  ES6 unterst√ºtzt die Destrukturierung.  Sie k√∂nnen eine Variable mit demselben Namen erstellen, die die entsprechende Eigenschaft des Objekts tr√§gt, und Folgendes tun: <br><br><pre> <code class="hljs julia">// ES6 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myObject = { one:   <span class="hljs-string"><span class="hljs-string">'a'</span></span>, two:   <span class="hljs-string"><span class="hljs-string">'b'</span></span>, three: <span class="hljs-string"><span class="hljs-string">'c'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { one, two, three } = myObject; // one = <span class="hljs-string"><span class="hljs-string">'a'</span></span>, two = <span class="hljs-string"><span class="hljs-string">'b'</span></span>, three = <span class="hljs-string"><span class="hljs-string">'c'</span></span></code> </pre> <br>  Variablen, die Objekteigenschaftswerte erhalten, k√∂nnen tats√§chlich beliebige Namen haben. Wenn sie sich jedoch von Eigenschaftsnamen unterscheiden, m√ºssen Sie das <code>{ propertyName: newVariable }</code> : <br><br><pre> <code class="hljs julia">// ES6 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myObject = { one:   <span class="hljs-string"><span class="hljs-string">'a'</span></span>, two:   <span class="hljs-string"><span class="hljs-string">'b'</span></span>, three: <span class="hljs-string"><span class="hljs-string">'c'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { one: first, two: second, three: third } = myObject; // first = <span class="hljs-string"><span class="hljs-string">'a'</span></span>, second = <span class="hljs-string"><span class="hljs-string">'b'</span></span>, third = <span class="hljs-string"><span class="hljs-string">'c'</span></span></code> </pre> <br>  Objekte mit einer komplexen Struktur, in die Arrays und andere Objekte eingebettet sind, k√∂nnen auch f√ºr destruktive Zuweisungsoperationen verwendet werden: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ ES6 const meta = { title: 'Enhanced Object Literals', pageinfo: {   url: 'https:/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/www.sitepoint.com/</span></span><span class="hljs-string"><span class="hljs-string">',   description: '</span></span>How to use object literals <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ES2015 (ES6).<span class="hljs-string"><span class="hljs-string">',   keywords: '</span></span>javascript, object, literal<span class="hljs-string"><span class="hljs-string">' } }; const { title   : doc, pageinfo: { keywords: topic } } = meta; /* doc   = '</span></span>Enhanced Object Literals<span class="hljs-string"><span class="hljs-string">' topic = '</span></span>javascript, object, literal<span class="hljs-string"><span class="hljs-string">' */</span></span></code> </pre> <br>  Auf den ersten Blick mag dies alles kompliziert erscheinen, es ist jedoch nicht so schwer, es herauszufinden. Die Hauptsache ist, sich an Folgendes zu erinnern: <br><br><ul><li>  Die rechte Seite des Ausdrucks ist die Datenquelle - ein Array oder Objekt, in dem die abzurufenden Daten gespeichert sind. </li><li>  Die linke Seite des Ausdrucks ist das Ziel der destruktiven Zuweisung - eine Struktur, die die Variablen beschreibt, denen die aus dem Array oder Objekt extrahierten Werte zugewiesen werden. </li></ul><br>  Bei der Verwendung der Destrukturierung k√∂nnen einige Schwierigkeiten auftreten.  Ein Ausdruck kann also nicht mit einer geschweiften Klammer gestartet werden, da er dann wie ein Codeblock aussieht.  Zum Beispiel: <br><br><pre> <code class="hljs swift">{ a, b, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> } = myObject; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br>  Dieses Design wird normalerweise vom System bei der Deklaration von Variablen wahrgenommen: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-comment"><span class="hljs-comment">{ a, b, c }</span></span> = myObject; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br>  Wenn die Variablen bereits deklariert sind, m√ºssen Sie den Ausdruck in Klammern setzen: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a, b, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>; ({ a, b, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> } = myObject); <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br>  Daher sollten Sie beim Umgang mit Destrukturierung vorsichtig mit dem Code sein und keine deklarierten und nicht deklarierten Variablen mischen. <br><br>  Destrukturierung ist eine Technik, die in vielen Situationen n√ºtzlich sein kann. <br><br><h2>  <font color="#3AC1EF">Standardfunktionsparameter</font> </h2><br>  Wenn eine Funktion eine lange Liste von Argumenten ben√∂tigt, ist es normalerweise einfacher, ihr ein einzelnes Objekt mit Parametern zu √ºbergeben.  Zum Beispiel: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">prettyPrint</span></span>( { <span class="hljs-attribute"><span class="hljs-attribute">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Enhanced Object Literals'</span></span>, publisher: {   name: <span class="hljs-string"><span class="hljs-string">'SitePoint'</span></span>,   url: <span class="hljs-string"><span class="hljs-string">'https://www.sitepoint.com/'</span></span> } } );</code> </pre> <br>  In ES5 mussten Objekte mit Parametern analysiert werden, um den entsprechenden Parametern Standardwerte zuzuweisen, wenn diese Objekte nicht das haben, was sie ben√∂tigen: <br><br><pre> <code class="hljs powershell">// ES5,     <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prettyPrint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(param)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">param</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">param</span></span> || {}; var   pubTitle = param.title || <span class="hljs-string"><span class="hljs-string">'No title'</span></span>,   pubName = (param.publisher &amp;&amp; param.publisher.name) || <span class="hljs-string"><span class="hljs-string">'No publisher'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pubTitle + <span class="hljs-string"><span class="hljs-string">', '</span></span> + pubName; }</code> </pre> <br>  In ES6 k√∂nnen allen Parametern Standardwerte zugewiesen werden: <br><br><pre> <code class="hljs powershell">// ES6 -     <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prettyPrint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(param = {})</span></span></span></span> { ... }</code> </pre> <br>  Anschlie√üend k√∂nnen Sie mithilfe der Destrukturierung Werte aus dem Objekt extrahieren und gegebenenfalls Standardwerte zuweisen: <br><br><pre> <code class="hljs powershell">// ES6     <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prettyPrint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( {   title: pubTitle = 'No title',   publisher: { name: pubName = 'No publisher' } } = {} )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> `${pubTitle}, <span class="hljs-variable"><span class="hljs-variable">$</span></span>{pubName}`; }</code> </pre> <br>  Es ist erw√§hnenswert, dass ein solcher Code m√∂glicherweise schwieriger zu lesen ist als herk√∂mmlicher, obwohl dies eine Frage der pers√∂nlichen Vorlieben des Programmierers ist. <br><br><h2>  <font color="#3AC1EF">Analysieren von Objekten, die von Funktionen zur√ºckgegeben werden</font> </h2><br>  Funktionen k√∂nnen nur einen Wert zur√ºckgeben, aber dieser Wert kann ein Objekt mit Hunderten von Eigenschaften oder Methoden sein.  In ES5 mussten Sie zuerst das zur√ºckgegebene Objekt abrufen, und danach konnten Sie die Werte daraus extrahieren: <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// ES5 var obj = getObject(), one = obj.one, two = obj.two, three = obj.three;</span></span></code> </pre> <br>  Die Umstrukturierung vereinfacht diesen Prozess.  Jetzt k√∂nnen Sie dies alles tun, ohne das Objekt in einer separaten Variablen speichern und dann analysieren zu m√ºssen: <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// ES6 const { one, two, three } = getObject();</span></span></code> </pre> <br>  M√∂glicherweise haben Sie in Node.js etwas √Ñhnliches gesehen.  Wenn Sie beispielsweise nur die <code>readFile()</code> und <code>writeFile()</code> des Moduls <code>fs</code> ben√∂tigen, k√∂nnen Sie folgende Links zu diesen erhalten: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ES6 Node.js const { readFile, writeFile } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); readFile(<span class="hljs-string"><span class="hljs-string">'file.txt'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err || data); }); writeFile(<span class="hljs-string"><span class="hljs-string">'new.txt'</span></span>, <span class="hljs-string"><span class="hljs-string">'new content'</span></span>, err =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err || <span class="hljs-string"><span class="hljs-string">'file written'</span></span>); });</code> </pre> <br><h2>  <font color="#3AC1EF">Verbleibende Parametersyntax und Erweiterungsoperator ES2018 (ES9)</font> </h2><br>  = In ES2015 wurden die Syntax der verbleibenden Parameter und der Erweiterungsoperator (beide sehen aus wie drei Punkte, <code>‚Ä¶</code> ) nur bei der Arbeit mit Arrays verwendet.  In ES2018 k√∂nnen √§hnliche Funktionen zum Arbeiten mit Objekten verwendet werden: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myObject = <span class="hljs-comment"><span class="hljs-comment">{ a: 1, b: 2, c: 3 }</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-comment"><span class="hljs-comment">{ a, ...x }</span></span> = myObject; <span class="hljs-comment"><span class="hljs-comment">// a = 1 // x = { b: 2, c: 3 }</span></span></code> </pre> <br>  Ein √§hnlicher Ansatz kann verwendet werden, um bestimmte Werte an eine Funktion zu √ºbertragen: <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restParam</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ a, </span></span><span class="hljs-rest_arg"><span class="hljs-function"><span class="hljs-params"><span class="hljs-rest_arg">...x</span></span></span></span><span class="hljs-function"><span class="hljs-params"> })</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// a = 1 // x = { b: 2, c: 3 } } restParam({ a: 1, b: 2, c: 3 });</span></span></code> </pre> <br>  Bitte beachten Sie, dass Sie in solchen Situationen nur einen Ausdruck mit drei Punkten am Ende der Liste verwenden k√∂nnen.  Dar√ºber hinaus funktioniert dies bei Objekten, die in anderen Objekten verschachtelt sind, nicht. <br><br>  Der Erweiterungsoperator kann in Objekten verwendet werden: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj1 = <span class="hljs-comment"><span class="hljs-comment">{ a: 1, b: 2, c: 3 }</span></span>, obj2 = <span class="hljs-comment"><span class="hljs-comment">{ ...obj1, z: 26 }</span></span>; <span class="hljs-comment"><span class="hljs-comment">// obj2 is { a: 1, b: 2, c: 3, z: 26 }</span></span></code> </pre> <br>  Der Erweiterungsoperator kann zum Klonen von Objekten verwendet werden ( <code>obj2 = { ...obj1 };</code> ). Hierbei ist jedoch zu ber√ºcksichtigen, dass bei diesem Ansatz eine flache Kopie des Objekts ausgef√ºhrt wird.  Wenn die Eigenschaften der Objekte andere Objekte sind, verweist der Klon des Objekts auf dieselben verschachtelten Objekte. <br><br>  Die Syntax der verbleibenden Parameter und der Erweiterungsoperator werden noch nicht allgemein unterst√ºtzt.  Derzeit k√∂nnen sie ohne zus√§tzlichen Aufwand in Chrome- und Firefox-Browsern sowie bei der Entwicklung f√ºr die Node.js-Plattform Version 8.6 und h√∂her verwendet werden. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Objektliterale waren schon immer eine n√ºtzliche JavaScript-Funktion.  Die Innovationen, die seit dem ES2015-Standard in JavaScript erscheinen, bringen keine grundlegenden √Ñnderungen mit sich, sparen dem Programmierer jedoch Zeit und helfen, saubereren und pr√§ziseren Code zu schreiben. <br><br>  <b>Liebe Leser!</b>  Welche Methoden zum Erstellen von JS-Objekten verwenden Sie am h√§ufigsten? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414377/">https://habr.com/ru/post/de414377/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414367/index.html">Galoppieren in drei Jahren: Was kann interessant sein, um es im HashFlare-Blog noch einmal zu lesen?</a></li>
<li><a href="../de414369/index.html">Windows Fehlertoleranter Druckserver</a></li>
<li><a href="../de414371/index.html">Schulklasse und eine kleine Skizze von Social Engineering</a></li>
<li><a href="../de414373/index.html">Asynchrones / wartendes JavaScript-Design: St√§rken, Fallstricke und Verwendungsmuster</a></li>
<li><a href="../de414375/index.html">Befehle zum Arbeiten mit der JavaScript-Konsole in Browsern und zur Steigerung der Produktivit√§t des Programmierers</a></li>
<li><a href="../de414379/index.html">"Diejenigen, die bereit sind, Freiheit gegen Sicherheit auszutauschen, sind weder Freiheit noch Sicherheit wert" (Originalquelle)</a></li>
<li><a href="../de414381/index.html">Airwheel R8 E-Bike: Unterfahrer oder Re-Bike</a></li>
<li><a href="../de414383/index.html">Glasfaserkabel k√∂nnen auch als Seismographen eingesetzt werden</a></li>
<li><a href="../de414385/index.html">10 UX / UI-Tipps: Wie uns Bekleidungsetiketten und Dating-Anwendungen lehren, besser zu gestalten</a></li>
<li><a href="../de414387/index.html">Sam Altman, Pr√§sident, Y Combinator: Produktivit√§t</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>