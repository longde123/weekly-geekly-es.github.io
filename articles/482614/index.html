<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§õ üè¶ üë®‚Äçüíª ¬øUsar BSP en Doom es realmente un movimiento ingenioso? ‚öîÔ∏è üëèüèª üë®‚Äçüë©‚Äçüëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El pin√°culo de la tecnolog√≠a de la √©poca. 

 En 1993, id Software lanz√≥ Doom , un juego de disparos en primera persona que r√°pidamente se convirti√≥ en...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øUsar BSP en Doom es realmente un movimiento ingenioso?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482614/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/268/1a6/7cd/2681a67cd1d82d83879143c036a95ca4.jpg"></div><br>  <i>El pin√°culo de la tecnolog√≠a de la √©poca.</i> <br><br>  En 1993, id Software lanz√≥ <em>Doom</em> , un juego de disparos en primera persona que r√°pidamente se convirti√≥ en un fen√≥meno.  Hoy se cree que este es uno de los juegos que m√°s impacto ha tenido en la historia. <br><br>  Diez a√±os despu√©s del lanzamiento de <em>Doom</em> , en 2003, el periodista David Kouchner public√≥ un libro de id Software llamado <a rel="nofollow" href="https://www.amazon.com/dp/0812972155/%3Ftag%3Darstech20-20"><em>Masters of Doom</em></a> , que desde entonces se ha convertido en una descripci√≥n can√≥nica del proceso de creaci√≥n de <em>Doom</em> .  Hace unos a√±os le√≠ <em>Masters of Doom</em> y no recuerdo casi nada, pero una historia de un libro sobre el programador principal John Carmack se ha conservado en mi memoria.  Mi descripci√≥n no ser√° del todo precisa (ver m√°s abajo para m√°s detalles), pero en resumen, en la etapa inicial del desarrollo de <em>Doom</em> , Carmack se dio cuenta de que el renderizador 3D que escribi√≥ para el juego comenz√≥ a disminuir cuando se renderizaban ciertos niveles.  Esto era inaceptable, porque <em>Doom</em> tuvo que convertirse en un juego activo e incluso fren√©tico.  Al darse cuenta de que el problema del renderizador era tan fundamental que tendr√≠a que buscar un algoritmo de renderizado m√°s √≥ptimo, Carmack comenz√≥ a leer art√≠culos de investigaci√≥n.  Como resultado, implement√≥ una t√©cnica llamada partici√≥n de espacio binario (BSP), que nunca antes se hab√≠a utilizado en videojuegos, y por lo tanto aceler√≥ significativamente el motor <em>Doom</em> . <br><br>  Esta historia de c√≥mo Carmack aplic√≥ la investigaci√≥n cient√≠fica de vanguardia a los videojuegos siempre me ha impresionado.  En mi opini√≥n, fue gracias a esto que Carmack se convirti√≥ en una figura tan legendaria.  Merece ser conocido como un brillante programador arquet√≠pico de videojuegos por muchas razones, pero como el principal, siempre recuerdo el episodio con la lectura de art√≠culos cient√≠ficos y la partici√≥n binaria del espacio. <br><a name="habracut"></a><br>  Obviamente, esta historia es impresionante, porque el t√©rmino "partici√≥n binaria del espacio" parece ser algo complicado no solo para la implementaci√≥n, sino incluso para la comprensi√≥n.  Durante mucho tiempo supuse que Carmack dio un salto intelectual hacia adelante, pero como no sab√≠a qu√© es una partici√≥n binaria del espacio y qu√© tan nueva era esta t√©cnica cuando Carmack decidi√≥ usarla, no estaba completamente seguro.  ¬øQu√© tan ingeniosa fue la adici√≥n de una partici√≥n de espacio binario a <em>Doom</em> en una escala de Homer Simpson a Albert Einstein? <br><br>  Tambi√©n me preguntaba de d√≥nde ven√≠a el BSP y c√≥mo lleg√≥ la idea a Carmack.  Por lo tanto, esta publicaci√≥n estar√° dedicada no solo a John Carmack y <em>Doom</em> , sino tambi√©n a la historia de la estructura de datos del "√°rbol de partici√≥n de espacio binario" (o √°rbol BSP).  Result√≥ que el √°rbol BSP, como muchos otros aspectos de las ciencias computacionales, se origina en la investigaci√≥n realizada para los militares. <br><br>  S√≠, es cierto: E1M1, el primer nivel de <em>Doom</em> , apareci√≥ gracias a la Fuerza A√©rea de EE. UU. <br><br><h2>  Tarea VSD </h2><br>  El √°rbol BSP es una soluci√≥n a una de las tareas m√°s dif√≠ciles en gr√°ficos por computadora.  Para representar una escena tridimensional, el renderizador debe determinar qu√© es visible y qu√© no es visible desde el punto actual.  Esto no es particularmente dif√≠cil si tienes mucho tiempo, pero un motor de juego en tiempo real que se respete a s√≠ mismo deber√≠a determinar las partes visibles e invisibles del mundo al menos 30 veces por segundo. <br><br>  Esta tarea a menudo se denomina tarea de determinaci√≥n de superficie visible (VSD).  El programador Michael Abrash, que trabaj√≥ con Carmack en <em>Quake</em> (el pr√≥ximo juego de software de identificaci√≥n despu√©s de <em>Doom</em> ), escribi√≥ sobre la tarea VSD en su famoso libro <a href="http://www.jagregory.com/abrash-black-book/"><em>Graphics Programming Black Book</em></a> : <br><br><blockquote>  Quiero hablar sobre la tarea de gr√°ficos 3D m√°s dif√≠cil, en mi opini√≥n: determinar las superficies visibles (dibujando la superficie deseada en cada p√≠xel) y su pariente cercano: la tarea de eliminaci√≥n (lo m√°s r√°pido posible para lanzar pol√≠gonos invisibles para acelerar la determinaci√≥n de las superficies visibles).  En aras de la brevedad, denotar√© por la abreviatura VSD tanto la definici√≥n de superficies visibles como el recorte. <br><br>  ¬øPor qu√© considero VSD la tarea 3D m√°s dif√≠cil?  Aunque los problemas de rasterizaci√≥n, como el mapeo de texturas, tambi√©n son tareas sorprendentes e importantes, estas son tareas de una escala bastante finita, cuya soluci√≥n se desplaza a la aparici√≥n de aceleradores 3D en el equipo;  Adem√°s, solo se escalan cuando aumenta la resoluci√≥n de la pantalla, lo que es bastante soportable. <br><br>  En contraste, VSD es una tarea ilimitada, y ahora se utilizan docenas de soluciones para resolverlo.  A√∫n m√°s importante, el rendimiento ingenuo de VSD se escala directamente con la complejidad de la escena, que generalmente aumenta como una funci√≥n cuadrada o c√∫bica, por lo que r√°pidamente se convierte en el factor limitante para representar mundos realistas. </blockquote><br>  Abrash escribi√≥ sobre la complejidad del problema de VSD a finales de los 90, unos a√±os despu√©s de que <em>Doom</em> demostrara que la gente com√∫n quiere poder jugar juegos gr√°ficamente pesados ‚Äã‚Äãen las computadoras de su hogar.  A principios de los a√±os 90, cuando id Software reci√©n comenzaba a publicar juegos, ten√≠an que trabajar de manera efectiva en computadoras inapropiadas: las m√°quinas dom√©sticas fueron dise√±adas para trabajar con texto, hojas de c√°lculo y otras aplicaciones similares.  Para lograr este objetivo, la compa√±√≠a tuvo que abordar la ficci√≥n, especialmente en el caso de varios juegos 3D publicados por id Software antes de <em>Doom</em> .  En estos juegos, el dise√±o de todos los niveles estaba limitado de manera que simplificara la soluci√≥n del problema VSD. <br><br>  Por ejemplo, en <em>Wolfenstein 3D</em> , el juego que id Software lanz√≥ justo antes de <em>Doom</em> , cada nivel consist√≠a en paredes alineadas a lo largo de los ejes.  En otras palabras, en el universo Wolfenstein podr√≠a haber muros norte / sur o muros este / oeste, y no otros.  Adem√°s, los muros se pueden colocar a distancias fijas en la cuadr√≠cula: todos los corredores tienen un ancho de una celda de la cuadr√≠cula, o dos, etc., pero nunca 2.5 celdas.  Aunque significaba que el equipo de id Software pod√≠a crear niveles que se ve√≠an casi iguales, esta restricci√≥n facilit√≥ a Carmack escribir un procesador para <em>Wolfenstein</em> . <br><br>  <em>El</em> procesador de <em>Wolfenstein</em> resolvi√≥ el problema de VSD moviendo rayos (marcha de rayos) al mundo virtual desde la pantalla.  Por lo general, los renderizadores renderizados por rayos son renderizadores de emisi√≥n de rayos: a menudo son lentos porque resolver el problema VSD en raycaster requiere encontrar la primera intersecci√≥n entre el rayo y alg√∫n objeto en el mundo, lo que requiere muchos c√°lculos.  Pero como todas las paredes en <em>Wolfenstein</em> est√°n alineadas con una cuadr√≠cula, los √∫nicos lugares donde una viga puede cruzar la pared ser√°n las l√≠neas de la cuadr√≠cula.  Por lo tanto, es suficiente que el renderizador verifique cada uno de estos puntos de intersecci√≥n.  Si el renderizador comienza verificando el punto de intersecci√≥n m√°s cercano al punto de vista del jugador, luego verifica el segundo en proximidad, y as√≠ sucesivamente, y termina cuando encuentra el primer muro, entonces el problema VSD se resuelve de la manera m√°s trivial.  El rayo simplemente se movi√≥ hacia adelante desde cada p√≠xel hasta que se top√≥ con algo, lo cual es muy econ√≥mico en t√©rminos de velocidades de reloj del procesador.  Y como todas las paredes tienen la misma altura, es suficiente para que emitamos rayos para cada <em>columna de</em> p√≠xeles. <br><br>  Esta simplificaci√≥n del renderizado hizo que <em>Wolfenstein fuera</em> lo suficientemente r√°pido como para trabajar en PC dom√©sticas d√©biles de la √©poca cuando no hab√≠a tarjetas gr√°ficas especializadas.  Pero ese enfoque no funcionar√≠a en <em>Doom</em> , porque el equipo de identificaci√≥n decidi√≥ que en su nuevo juego habr√≠a elementos tan nuevos como paredes diagonales, escaleras y techos con diferentes alturas.  La marcha de rayos ya no era adecuada, por lo que Carmack escribi√≥ un tipo diferente de renderizador.  El renderizador <em>Wolfenstein</em> , donde se usaba el haz para cada columna de p√≠xeles, fue rechazado de la imagen, y se supon√≠a que el renderizador <em>Doom</em> era rechazado de los objetos.  Esto significaba que en lugar de atravesar los p√≠xeles de la pantalla y determinar su color, el renderizador de <em>Doom</em> ten√≠a que iterar sobre los objetos en la escena y proyectar cada uno de ellos en la pantalla. <br><br>  En tal procesador, una forma simple de resolver el problema de VSD es usar un z-buffer.  Cada vez que proyectamos un objeto en la pantalla, se realiza una verificaci√≥n para cada p√≠xel que queremos dibujar.  Si la parte del objeto a dibujar est√° m√°s cerca del jugador que el objeto ya dibujado en el p√≠xel, entonces podemos reescribir su informaci√≥n.  De lo contrario, debe dejar el p√≠xel sin cambios.  Este enfoque es simple, pero el z-buffer requiere mucha memoria, y el procesador a√∫n puede gastar un mont√≥n de relojes de procesador en proyectar geometr√≠a de nivel que el jugador no ver√°. <br><br>  A principios de la d√©cada de 1990, la soluci√≥n z-buffer ten√≠a un inconveniente m√°s: en las PC compatibles con IBM que usaban un sistema de adaptador de video llamado VGA, escribir en el buffer de cuadro de salida era una operaci√≥n costosa.  Por lo tanto, el tiempo dedicado a renderizar p√≠xeles, que luego simplemente se sobrescribir√°, redujo en gran medida el rendimiento del renderizador. <br><br>  Dado que escribir en el b√∫fer de cuadros era muy costoso, el renderizador ideal era comenzar dibujando los objetos m√°s cercanos al jugador, luego los objetos inmediatamente detr√°s de ellos, y as√≠ sucesivamente, hasta completar la escritura en cada p√≠xel de la pantalla.  En esta etapa, el renderizador deber√≠a haber entendido que era hora de detenerse, ahorrando as√≠ todo el tiempo que pod√≠a pasar explorando objetos distantes que el jugador no ve√≠a.  Pero ordenar objetos de escena de esta manera, desde el m√°s cercano al m√°s lejano, equivale a resolver el problema VSD.  La pregunta nuevamente surge ante nosotros: ¬øqu√© puede ver un jugador? <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HQYsFshbkYw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Al principio, Carmack intent√≥ resolver este problema confiando en el esquema de nivel de <em>Doom</em> .  Su renderizador comenz√≥ dibujando las paredes de la habitaci√≥n en la que se encuentra el jugador, y luego se verti√≥ en las habitaciones vecinas para dibujar paredes en estas habitaciones, que podr√≠an ser visibles desde la habitaci√≥n actual.  Si cada habitaci√≥n fuera convexa, esto resolver√≠a el problema de VSD.  Las salas no convexas podr√≠an dividirse en "sectores" convexos.  Puede ver c√≥mo esta t√©cnica de representaci√≥n podr√≠a haber parecido una fuerte desaceleraci√≥n en <a href="https://youtu.be/HQYsFshbkYw%3Ft%3D822">el video que se muestra arriba</a> , donde un usuario de YouTuber con el apodo Bisqwit demuestra su propio renderizador que funciona de acuerdo con el mismo algoritmo general.  Este algoritmo se utiliz√≥ con √©xito en el juego Duke Nukem 3D, lanzado tres a√±os despu√©s de <em>Doom</em> , cuando los procesadores se volvieron m√°s potentes.  Pero en 1993, en ese momento, el renderizador de <em>Doom que</em> usaba este algoritmo experiment√≥ problemas con niveles complejos.  Esto era especialmente obvio cuando los sectores se integraban entre s√≠, y esta era la √∫nica forma de crear, por ejemplo, escaleras circulares.  Las escaleras circulares requer√≠an m√∫ltiples descensos recursivos al sector ya dibujado, reduciendo dr√°sticamente la velocidad del motor. <br><br>  Casi al mismo tiempo, cuando el equipo de identificaci√≥n se dio cuenta de que el motor de <em>Doom</em> podr√≠a ser demasiado lento, se le pidi√≥ a id Software que transfiriera <em>Wolfenstein 3D</em> a Super Nintendo.  SNES era incluso menos potente que las PC compatibles con IBM de la √©poca, y result√≥ que el renderizador <em>Wolfenstein</em> con tecnolog√≠a de marcha de rayos, a pesar de su simplicidad, no funcionaba en equipos Super Nintendo con suficiente velocidad.  Por lo tanto, Carmack comenz√≥ a buscar un algoritmo mejor.  De hecho, fue para el puerto de Super Nintendo de <em>Wolfenstein</em> que Carmack primero explor√≥ e implement√≥ la partici√≥n de espacio binario.  En <em>Wolfenstein</em> fue bastante simple porque todas las paredes eran paralelas a los ejes;  <em>Doom lo hace</em> m√°s dif√≠cil.  Pero Carmack se dio cuenta de que los √°rboles BSP tambi√©n resolver√≠an problemas de velocidad en <em>Doom</em> . <br><br><h2>  Divisi√≥n de espacio binario </h2><br>  La partici√≥n del espacio binario simplifica la soluci√≥n al problema VSD al dividir previamente la escena 3D.  Por ahora, es suficiente que comprenda por qu√© la partici√≥n es √∫til: si dibuja una l√≠nea (que en realidad es un plano en 3D) a trav√©s de toda la escena, sabiendo con qu√© lado de la l√≠nea est√° el reproductor o la c√°mara, entonces tambi√©n sabremos que no hay nada el otro lado de la l√≠nea no podr√° obstruir objetos desde el lado de la l√≠nea donde se encuentra la c√°mara.  Si repite el proceso muchas veces, obtenemos una escena 3D, dividida en muchas secciones.  Esto no ser√° una mejora con respecto a la escena original, excepto que ahora sabemos m√°s sobre c√≥mo pueden superponerse diferentes partes de la escena. <br><br>  Los primeros en escribir sobre esta divisi√≥n de la escena 3D fueron los investigadores que intentaron averiguar para la Fuerza A√©rea de los EE. UU. Si los gr√°ficos por computadora son lo suficientemente progresivos para su uso en simuladores de vuelo.  Publicaron sus hallazgos en un informe de 1969 titulado "Investigaci√≥n sobre el uso de im√°genes generadas por computadora en la simulaci√≥n visual".  El informe concluy√≥ que los gr√°ficos por computadora se pueden usar para entrenar a los pilotos;  Al mismo tiempo, los investigadores advirtieron que la implementaci√≥n del sistema ser√≠a complicada por la tarea de VSD: <br><br><blockquote>  Una de las tareas m√°s importantes que deber√° resolverse al calcular im√°genes en tiempo real es la tarea prioritaria o las l√≠neas ocultas.  En nuestra percepci√≥n visual cotidiana del mundo que nos rodea, la naturaleza misma resuelve este problema con sencillez trivial;  La punta de un objeto opaco se superpone a todos los dem√°s puntos que se encuentran a lo largo de la misma l√≠nea de visi√≥n y est√°n m√°s lejos.  En el caso de una computadora, esta tarea es muy dif√≠cil.  La cantidad de c√≥mputo necesaria para determinar la prioridad, en el caso general, crece exponencialmente con la creciente complejidad del entorno, y pronto excede la carga computacional asociada con la b√∫squeda de im√°genes de objetos teniendo en cuenta la perspectiva. </blockquote><br>  Una soluci√≥n mencionada por estos investigadores, que seg√∫n dijeron fue utilizada previamente en un proyecto de la NASA, se basa en crear lo que llamar√© la "matriz de superposici√≥n".  Los investigadores se√±alan que un avi√≥n que divide una escena en dos partes puede usarse para resolver "cualquier conflicto de prioridades" entre objetos en lados opuestos del avi√≥n.  En el caso general, es posible que deba agregar estos planos a la escena expl√≠citamente, pero para una determinada estructura geom√©trica, puede confiar en las caras existentes de los objetos.  Los investigadores demuestran el siguiente ejemplo, donde <em>p1</em> , <em>p2</em> y <em>p3</em> son superficies divisorias.  Si el punto de vista de la c√°mara est√° en el lado frontal o "verdadero" de uno de estos planos, entonces <em>pi</em> es 1. La matriz muestra la relaci√≥n entre los tres objetos dependiendo de los tres planos de separaci√≥n y la ubicaci√≥n del punto de vista de la c√°mara; si el objeto <em>ai se</em> superpone al objeto <em>aj</em> , entonces El elemento <em>aij de la</em> matriz ser√° igual a 1. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d24/7b5/fda/d247b5fdab1c47b5772d3a3c922c1664.png"></div><br>  Los investigadores han propuesto implementar esta matriz en hardware y volver a calcularla en cada marco.  De hecho, la matriz debe actuar como un interruptor grande o una especie de b√∫fer z integrado.  Al renderizar el objeto actual, el video no se emite para partes del objeto cuando 1 est√° en la columna del objeto, pero se dibuja el objeto de fila correspondiente. <br><br>  Un inconveniente grave de este enfoque es que <em><sup>se</sup></em> necesita una matriz de tama√±o <em>n <sup>2</sup></em> para describir una escena con <em>n</em> objetos.  Por lo tanto, los investigadores decidieron verificar si es posible presentar la matriz de superposici√≥n en forma de una "lista de prioridades", que tendr√° un tama√±o de solo <em>n</em> y especificar el orden en que deben dibujarse los objetos.  Inmediatamente notaron que en ciertas escenas, por ejemplo, en la que se muestra arriba, es imposible completar el pedido (ya que hay un ciclo de superposici√≥n), por lo que dedicaron mucho tiempo a la definici√≥n matem√°tica de escenas "correctas" e "incorrectas".  Al final, llegaron a la conclusi√≥n de que al menos para las escenas "correctas" (y el dise√±ador de la escena puede evitar f√°cilmente los casos "incorrectos"), se puede generar una lista de prioridades.  Pero dejaron la generaci√≥n de la lista como un ejercicio para el lector.  Parece que la principal contribuci√≥n de este trabajo de 1969 es indicar que, al menos en <em>teor√≠a,</em> deber√≠a existir la posibilidad de utilizar planos divisorios para organizar los objetos en la escena. <br><br>  Y solo en un art√≠culo de 1980 titulado ‚ÄúSobre la generaci√≥n de superficies visibles por estructuras de √°rbol a priori‚Äù se demostr√≥ un algoritmo espec√≠fico para esto.  En este art√≠culo, escrito por Henry Fuchs, Zvi Kedem y Bruce Naylor, se describi√≥ por primera vez el √°rbol BSP.  Los autores dicen que su nueva estructura de datos es "una soluci√≥n, un enfoque alternativo, utilizado por primera vez hace diez a√±os, pero debido a algunas dificultades no tan generalizadas", por lo que responden a la decisi√≥n elegida en el trabajo de la Fuerza A√©rea de los Estados Unidos en 1969.  Despu√©s de construir un √°rbol BSP, puede usarse f√°cilmente para organizar objetos con prioridad en la escena. <br><br>  Fuchs, Kedem y Naylor proporcionaron una descripci√≥n bastante clara del funcionamiento del √°rbol BSP, pero intentar√© dar una descripci√≥n menos formal, pero breve. <br><br>  Comenzamos seleccionando un pol√≠gono en la escena, y hacemos que el plano en el que se encuentra el pol√≠gono sea un plano divisorio.  Este √∫nico pol√≠gono tambi√©n se convierte en el nodo ra√≠z del √°rbol.  Los pol√≠gonos restantes de la escena estar√°n en uno u otro lado del plano divisorio de la ra√≠z.  Los pol√≠gonos en el lado "frontal" o en el medio espacio "frontal" del plano aparecen en el sub√°rbol izquierdo del nodo ra√≠z, y los pol√≠gonos en el lado "posterior" o en el medio espacio "posterior" del plano aparecen en el sub√°rbol derecho.  Luego repetimos este proceso de forma recursiva, seleccionando pol√≠gonos de los sub√°rboles izquierdo y derecho como las nuevas superficies divisorias para sus propios medios espacios, que generan m√°s semiespacios y sub√°rboles.  El proceso finaliza cuando finalizan los pol√≠gonos. <br><br>  Digamos que queremos renderizar la geometr√≠a de la escena de atr√°s hacia adelante.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Esto se llama el "algoritmo del artista" porque significa que los pol√≠gonos m√°s alejados de la c√°mara se rellenar√°n con pol√≠gonos m√°s cercanos a la c√°mara, creando la representaci√≥n correcta). Para hacer esto, solo tenemos que rodear nuestro √°rbol BSP en orden; la decisi√≥n sobre si se debe dibujar el sub√°rbol izquierdo o derecho se basa en el lugar donde se encuentra el punto de vista de la c√°mara, en el medio espacio frontal o posterior en relaci√≥n con el plano divisorio asociado con este nodo. Es decir, en cada nodo del √°rbol, primero representamos todos los pol√≠gonos en el lado "lejano" del plano, luego el pol√≠gono en el plano de separaci√≥n y luego los pol√≠gonos en el lado "cercano" del plano. Los pol√≠gonos "cercano" y "lejano" se definen en relaci√≥n con el punto de vista de la c√°mara. Esto resuelve el problema de VSD porque, como aprendimos hace unos p√°rrafos,los pol√≠gonos en el lado lejano del plano de separaci√≥n no pueden solaparse con nada en el lado frontal.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El siguiente diagrama muestra la construcci√≥n y el recorrido de un √°rbol BSP que describe una escena 2D simple. </font><font style="vertical-align: inherit;">En 2D, se usan l√≠neas divisorias en lugar de dividir planos, pero la idea b√°sica sigue siendo la misma.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f72/00b/aac/f7200baac3a914eb6fe62ca131b1e3cc.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/564/e28/9bf/564e289bf6d44182b3db68c8ad7178c0.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/638/07a/f5a/63807af5af2f3bfa8c7ec73a81c36035.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una caracter√≠stica muy conveniente del √°rbol BSP que Fuchs, Kedem y Naylor enfatizan varias veces es que solo debe construirse una vez. </font><font style="vertical-align: inherit;">Esto parece sorprendente, pero se puede usar un √°rbol BSP para renderizar la escena independientemente del punto de vista de la c√°mara. </font><font style="vertical-align: inherit;">El √°rbol BSP permanece en uso hasta que se mueven los pol√≠gonos de la escena. </font><font style="vertical-align: inherit;">Es por eso que el √°rbol BSP es tan √∫til para la representaci√≥n en tiempo real: todo el trabajo complejo de construir un √°rbol se puede hacer por adelantado, y no en el momento de la representaci√≥n.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuchs, Kedem y Naylor informan que la investigaci√≥n adicional requiere la creaci√≥n de un "buen" √°rbol BSP. La calidad del √°rbol BSP depende de los pol√≠gonos que elija para definir los planos de separaci√≥n. Anteriormente, omit√≠ este punto, pero si usa un plano que se cruza con otros pol√≠gonos cuando se divide, entonces para que el algoritmo BSP funcione, debe dividir los pol√≠gonos cruzados en dos, de modo que una mitad pertenezca a un medio espacio y la otra al otro. Si esto sucede con frecuencia, entonces construir un √°rbol BSP aumenta significativamente el n√∫mero de pol√≠gonos en la escena.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bruce Naylor, uno de los autores de un art√≠culo de 1980, escribi√≥ m√°s tarde sobre este tema en su art√≠culo de 1993 Construyendo buenos √°rboles de partici√≥n. </font><font style="vertical-align: inherit;">Seg√∫n el colega de Carmack y cofundador de id Software, John Romero, este art√≠culo fue uno de los trabajos que Carmack ley√≥ cuando intent√≥ implementar √°rboles BSP en </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Årboles BSP en </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recuerde que en el primer borrador del renderizador de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">Carmack intent√≥ establecer el orden de renderizado para la geometr√≠a de nivel llenando el renderizador de la sala donde el jugador est√° en las habitaciones vecinas. Los √°rboles BSP eran una forma m√°s conveniente de determinar este orden, ya que evitaban el problema de que el procesador tuviera que visitar repetidamente una habitaci√≥n (o sector), desperdiciando los ciclos del procesador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Agregar √°rboles BSP a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " en la pr√°ctica significaba agregar un generador de √°rboles BSP al editor de niveles de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Despu√©s de completar la creaci√≥n del nivel </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se gener√≥ un √°rbol BSP a partir de la geometr√≠a de nivel. Seg√∫n Fabien Sanglar, el proceso de generaci√≥n podr√≠a tomar hasta ocho segundos para un nivel y 11 minutos para todos los niveles del primer </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . El proceso de generaci√≥n fue tan largo en parte debido al hecho de que el algoritmo de generaci√≥n Carmack BSP est√° tratando de encontrar un "buen" √°rbol BSP utilizando diversas heur√≠sticas. Un retraso de ocho segundos ser√≠a imperdonable durante el juego, pero despu√©s de la generaci√≥n preliminar parec√≠a bastante aceptable, dado el aumento en el rendimiento que los √°rboles BSP proporcionaron al renderizador. El √°rbol BSP generado de un nivel individual se guard√≥ como parte de los datos de nivel cargados en el juego cuando se lanz√≥. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carmack realiz√≥ un cambio importante en el algoritmo del √°rbol BSP descrito en un art√≠culo de 1980: despu√©s del lanzamiento de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y al leer el √°rbol BSP de nivel actual en la memoria, el renderizador usa este √°rbol para dibujar objetos no de adelante hacia atr√°s, sino de adelante hacia atr√°s. En un art√≠culo de 1980, Fuchs, Kedem y Naylor demostraron c√≥mo se puede utilizar un √°rbol BSP para implementar el algoritmo de un artista con renderizado continuo, pero se produce una gran cantidad de repintado en el algoritmo del artista, lo que podr√≠a ser costoso en las PC compatibles con IBM. Por lo tanto, el renderizador de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comienza con una geometr√≠a m√°s cercana al jugador, y luego dibuja el m√°s alejado. Tal orden inverso es f√°cil de implementar usando un √°rbol BSP, porque simplemente puede tomar una decisi√≥n de seguimiento en cada nodo del √°rbol. Para evitar que la geometr√≠a m√°s lejana se dibuje encima del cerrador, el renderizador de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usa un tipo de z-buffer impl√≠cito, que proporciona muchos de los beneficios de un z-buffer regular, mientras consume mucha menos memoria. Hay una matriz que rastrea la superposici√≥n en la dimensi√≥n horizontal y otras dos matrices que rastrean la superposici√≥n en la direcci√≥n vertical arriba y debajo de la pantalla. El renderizador de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> podr√≠a funcionar sin usar un verdadero z-buffer, porque </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , estrictamente hablando, no era un juego completamente tridimensional. Las estructuras de datos menos costosas funcionaron porque </font><font style="vertical-align: inherit;">ciertos elementos no eran posibles </font><font style="vertical-align: inherit;">en </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : la matriz de superposici√≥n horizontal funcionaba porque no hab√≠a paredes inclinadas, y las matrices de superposici√≥n vertical funcionaban porque no hab√≠a paredes en las que, por ejemplo, hab√≠a dos ubicadas uno encima de las otras ventanas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a74/23c/5de/a7423c5dead349917bd826ee3efa70b9.png"></div><br> <i><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom II</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tan complejo como su predecesor.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a7/82b/b4a/3a782bb4a5a2c4a44e5821c897239533.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero nadie se quej√≥ de la repetici√≥n de la sangre.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d0/0e4/443/3d00e4443a7e46c3418e11dac4eec839.png"></div><br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una nueva palabra en Quake Technologies La</font></font></em> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √∫nica tarea dif√≠cil que queda es c√≥mo integrar los personajes </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en </font><font style="vertical-align: inherit;">movimiento </font><font style="vertical-align: inherit;">en la geometr√≠a est√°tica de los niveles dibujados usando el √°rbol BSP. </font><font style="vertical-align: inherit;">Los enemigos en </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no pod√≠an ser parte del √°rbol BSP porque se estaban moviendo; </font><font style="vertical-align: inherit;">El √°rbol BSP solo funciona con geometr√≠a fija. </font><font style="vertical-align: inherit;">Por lo tanto, el renderizador de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primero dibuja la geometr√≠a est√°tica del nivel, rastreando (usando otra estructura de datos eficiente en memoria) los segmentos de la pantalla en la que se realiz√≥ el dibujo. Luego, atrae a los enemigos de atr√°s hacia adelante y los trunca a lo largo de los segmentos de la pantalla que los superponen. Este proceso no es tan √≥ptimo como el renderizado con un √°rbol BSP, pero dado que generalmente hay menos enemigos que la geometr√≠a, la velocidad no es un problema aqu√≠. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usar √°rboles BSP en </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fue una gran victoria. Obviamente, Carmack fue lo suficientemente ingenioso como para darse cuenta de que los √°rboles BSP ser√≠an la soluci√≥n ideal. ¬øPero fue esta decisi√≥n </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ingeniosa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En </font></font><a href="http://fabiensanglard.net/gebbdoom/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">su excelente libro sobre el motor del juego </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fabien Sanglar cita a John Romero, quien dijo que el art√≠culo de Bruce Naylor "Construyendo buenos √°rboles de partici√≥n" se refer√≠a principalmente al uso de √°rboles BSP para recortar las caras posteriores de los modelos 3D. Seg√∫n Romero, Carmack pens√≥ que el algoritmo podr√≠a seguir siendo √∫til para </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , por lo que lo implement√≥. Esto es bastante recomendable para Carmack porque implica que vio la utilidad de los √°rboles BSP en los videojuegos en tiempo real, incluso cuando otras personas todav√≠a usaban esta t√©cnica para representar escenas est√°ticas. La misma historia halagadora est√° en </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masters of Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Kouchner sugiri√≥ que Carmack leyera el art√≠culo de Naylor y se pregunt√≥: "¬øy si puede usar el √°rbol BSP para crear no solo una imagen 3D, sino un mundo virtual completo?" </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estos hallazgos ignoran la historia del √°rbol BSP. Cuando los investigadores de la Fuerza A√©rea de los Estados Unidos se dieron cuenta por primera vez de que dividir una escena podr√≠a ayudar a acelerar el renderizado, estaban interesados </font><em><font style="vertical-align: inherit;">en la</font></em><font style="vertical-align: inherit;"> aceleraci√≥n en </font><em><font style="vertical-align: inherit;">tiempo real</font></em><font style="vertical-align: inherit;"> del renderizado.</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, porque al final intentaron crear un simulador de vuelo. El ejemplo del simulador de vuelo se menciona nuevamente en un art√≠culo de 1980. Fuchs, Kedem y Naylor escriben que el √°rbol BSP puede ser √∫til en un simulador de vuelo que los pilotos usan para realizar m√∫ltiples aterrizajes en el mismo aeropuerto. Como la geometr√≠a del aeropuerto nunca cambia, un √°rbol BSP solo puede generarse una vez. Obviamente, estaban pensando en la simulaci√≥n en tiempo real. En la introducci√≥n del art√≠culo, incluso explican su investigaci√≥n probando la posibilidad de usar un sistema gr√°fico en tiempo real para crear im√°genes en no m√°s de 1/30 de segundo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es decir, Carmack no fue el primero en pensar en usar √°rboles BSP en la simulaci√≥n gr√°fica en tiempo real. Por supuesto, para predecir que los √°rboles BSP se pueden usar de esta manera, y para implementar esto, son cosas completamente diferentes. Pero incluso con la implementaci√≥n, Carmack podr√≠a tener m√°s informaci√≥n de fondo de lo que generalmente se piensa. El </font></font><a href="https://en.wikipedia.org/wiki/Binary_space_partitioning"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">art√≠culo de WSP sobre √°rboles BSP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sugiere que Carmack se refiri√≥ al art√≠culo de 1991 de Chen y Gordon, as√≠ como al libro de texto de 1990 </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Computer Graphics: Principles and Practice</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Aunque esta declaraci√≥n no est√° respaldada por una cita, puede ser cierta. Un art√≠culo de 1991 de Chen y Gordon describe el renderizado de adelante hacia atr√°s usando √°rboles BSP, que es esencialmente la misma soluci√≥n utilizada por </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, hasta la estructura de datos "z-buffer impl√≠cito", que no permite dibujar pol√≠gonos distantes encima de los vecinos. El art√≠culo proporciona una excelente visi√≥n general de los √°rboles BSP, as√≠ como un seudoc√≥digo para construir y mostrar un √°rbol. (Gracias a la maravillosa biblioteca de mi universidad, pude ver la edici√≥n de 1990). El libro de texto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Computer Graphics: Principles and Practice</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es un trabajo cl√°sico sobre gr√°ficos por computadora, por lo que Carmack tambi√©n podr√≠a tener uno.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b6f/134/2a9/b6f1342a90a1ce11fafca1f265f65fda.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nivel subsector E1M1: Hangar.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sea como fuere, Carmack se enfrent√≥ a una nueva tarea: "¬øC√≥mo puedo crear un juego de disparos en primera persona que se ejecute en una computadora con un procesador que ni siquiera es capaz de realizar operaciones de punto flotante?", Realiz√≥ su propia investigaci√≥n y demostr√≥ que los √°rboles BSP son Esta es una estructura de datos √∫til para videojuegos en tiempo real. Sigo pensando que este es un resultado impresionante, a pesar de que el √°rbol BSP fue inventado diez a√±os antes, y ha sido estudiado te√≥ricamente con suficiente detalle cuando Carmack ley√≥ sobre √©l. Quiz√°s el principal logro que debemos elogiar es el motor de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en su conjunto, que se ha convertido en un gran ejemplo de c√≥digo. Ya he hablado sobre esto una vez, pero repito que el libro de Fabien Sanglar sobre el motor del juego</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game Engine Black Book: DOOM</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) es una excelente descripci√≥n de todos los componentes reflexivos del motor del juego y su interacci√≥n. </font><font style="vertical-align: inherit;">No debemos olvidar que la tarea VSD fue solo una de las muchas tareas que Carmack tuvo que resolver para que el motor </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funcionara </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Y que fue capaz, adem√°s de todo, de leer sobre la compleja estructura de datos desconocida para la mayor√≠a de los programadores e implementarla. </font><font style="vertical-align: inherit;">Esto dice mucho sobre el nivel de su conocimiento t√©cnico y compromiso con el ideal.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/482614/">https://habr.com/ru/post/482614/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../482598/index.html">Fotos falsas del grupo Dyatlov</a></li>
<li><a href="../482604/index.html">5 personajes de la d√©cada de 1920 que, despu√©s de 100 a√±os, se elevaron a las nubes</a></li>
<li><a href="../482608/index.html">AMA con Habr # 15. A√±o nuevo y el lanzamiento m√°s corto! Chatear</a></li>
<li><a href="../482610/index.html">Inicie Transflective TFT Display en SSD1283A con STM32</a></li>
<li><a href="../482612/index.html">Conmovedor tablero de ingenier√≠a, a√±o nuevo y voluntarios</a></li>
<li><a href="../482616/index.html">Foreve Elon 2019/2020 (reuni√≥n en l√≠nea NY2020)</a></li>
<li><a href="../482620/index.html">Slurm: Habr, felices fiestas ...</a></li>
<li><a href="../482626/index.html">Monitoreo de aplicaciones con Logger.</a></li>
<li><a href="../482628/index.html">Mira "La peque√±a ara√±a verde del tiempo"</a></li>
<li><a href="../482634/index.html">Pero la esencia es algo, o minimizar el c√≥digo fuente es m√°s f√°cil de lo que parece.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>