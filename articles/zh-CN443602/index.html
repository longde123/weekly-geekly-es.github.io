<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆚 🍕 💚 什么是严格别名，为什么我们要关心？ 第二部分 🍈 📴 💳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="（或古怪的打字，含糊的行为和对齐方式，哦，天哪！） 

 朋友，在“ C ++开发人员”课程上启动新线程之前，剩下的时间很少。 现在是时候发布该材料第二部分的译文了，它讲述了双关语的输入。 

 什么是双关语？ 

 我们到了一个奇怪的地步，为什么我们可能根本需要假名？ 通常用于执行双关语打字，tk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>什么是严格别名，为什么我们要关心？ 第二部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/443602/">  <b><i>（或古怪的打字，含糊的行为和对齐方式，哦，天哪！）</i></b> <br><br> 朋友，在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ C ++开发人员”</a>课程上启动新线程之前，剩下的时间很少。 现在是时候发布该材料第二部分的译文了，它讲述了双关语的输入。 <br><br>  <b>什么是双关语？</b> <br><br> 我们到了一个奇怪的地步，为什么我们可能根本需要假名？ 通常用于执行双关语打字，tk。 经常使用的方法违反了严格的别名规则。 <br><br><img src="https://habrastorage.org/webt/dz/u-/cd/dzu-cdwp2tjct7bc-stnxfnptpe.png"><br><br> 有时我们想绕过类型系统并将对象解释为另一种类型。 将内存段重新解释为另一种类型称为类型<i>punning pun</i> 。 键入双关语对于需要访问对象的基本表示以查看，传输或操纵提供的数据的任务很有用。 我们可能会遇到使用双关语的典型领域：编译器，序列化，网络代码等。 <a name="habracut"></a><br> 传统上，这是通过获取对象的地址，将其强制转换为指向我们要解释的类型的指针，然后访问该值或使用别名来实现的。 例如： <br><br><pre><code class="bash hljs">int x = 1 ; //   C <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> *fp = (<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>*)&amp;x ; //   //  C++ <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> *fp = reinterpret_cast&lt;<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>*&gt;(&amp;x) ; //   <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( “%f\n”, *fp ) ;</code> </pre> <br> 如前所述，这是不可接受的别名，这将导致未定义的行为。 但是传统上，编译器并不使用严格的别名规则，而这种类型的代码通常只能工作，而且不幸的是，开发人员习惯于允许这种事情。 一种常见的替代双打类型方法是通过并集（union），该方法在C语言中有效，但会在C ++中导致未定义的行为（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">请参见示例</a> ）： <br><br><pre> <code class="bash hljs">union u1 { int n; <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> f; } ; union u1 u; uf = 1.0f; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"%d\n”, un ); // UB(undefined behaviour)  C++ “n is not the active member”</span></span></code> </pre> <br> 这在C ++中是不可接受的，并且一些人认为联合仅用于实现变量类型，并认为使用联合键入双关语是一种滥用。 <br><br>  <b>如何实施双关语？</b> <br><br> 在C和C ++中键入双关语的标准加持方法是memcpy。 这似乎有些复杂，但是优化程序需要识别双关语对memcpy的使用，对其进行优化并生成一个寄存器来记录移动。 例如，如果我们知道int64_t与double大小相同： <br><br><pre> <code class="bash hljs">static_assert( sizeof( double ) == sizeof( int64_t ) ); // C++17   </code> </pre> <br> 我们可以使用<code>memcpy</code> ： <br><br><pre> <code class="bash hljs">void func1( double d ) { std::int64_t n; std::memcpy(&amp;n, &amp;d, sizeof d); //…</code> </pre><br> 有了足够的优化水平，任何体面的现代编译器都会生成与前面提到的reinterpret_cast方法或join方法相同的代码，以得到双关语。 研究生成的代码，我们看到它仅使用mov寄存器（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">示例</a> ）。 <br><br>  <b>双关语类型和数组</b> <br><br> 但是，如果我们想将一个无符号char数组的双关实现为一系列无符号int，然后对每个无符号int值执行一个运算，该怎么办？ 我们可以使用memcpy将无符号的char数组转换为临时的非单int类型。 优化器仍然可以通过memcpy查看所有内容，并优化临时对象和副本，并直接使用基础数据（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">例如</a> ）： <br><br><pre> <code class="bash hljs">//  ,    int foo( unsigned int x ) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> x ; } // ,  len  sizeof(unsigned int) int bar( unsigned char *p, size_t len ) { int result = 0; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( size_t index = 0; index &lt; len; index += sizeof(unsigned int) ) { unsigned int ui = 0; std::memcpy( &amp;ui, &amp;p[index], sizeof(unsigned int) ); result += foo( ui ) ; } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> result; }</code> </pre><br> 在此示例中，我们采用<code>char*p</code> ，假设它指向几个<code>sizeof(unsigned int)</code>数据片段，将每个数据片段解释为<code>unsigned int</code> ，为pun的每个片段计算<code>foo()</code> ，将其求和，然后返回最终值。 <br><br> 循环主体的程序集显示，优化器将主体转换为对<code>unsigned char</code>基数组的直接访问，并将其作为<code>unsigned int</code>并将其直接添加到<code>eax</code> ： <br><br><pre> <code class="bash hljs">add eax, dword ptr [rdi + rcx]</code> </pre> <br> 相同的代码，但是使用<code>reinterpret_cast</code>实现双关语（违反严格的别名）： <br><br><pre> <code class="bash hljs">// ,  len  sizeof(unsigned int) int bar( unsigned char *p, size_t len ) { int result = 0; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( size_t index = 0; index &lt; len; index += sizeof(unsigned int) ) { unsigned int ui = *reinterpret_cast&lt;unsigned int*&gt;(&amp;p[index]); result += foo( ui ); } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> result; }</code> </pre> <br>  <b>C ++ 20和bit_cast</b> <br><br> 在C ++ 20中，我们有<code>bit_cast</code> ，它提供了一种简单而安全的解释方法，也可以在<code>constexpr</code>的上下文中使用。 <br><br> 以下是如何使用<code>bit_cast</code>解释<code>float</code>的无符号整数的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">示例</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">示例</a> ）： <br><br><pre> <code class="bash hljs">std::cout &lt;&lt; bit_cast&lt;<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>&gt;(0x447a0000) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span> ; //,  sizeof(<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>) == sizeof(unsigned int)</code> </pre> <br> 如果类型To和From的大小不同，则需要我们使用中间结构。 我们将使用一个结构，该结构包含一个字符数组，该数组的<code>sizeof(unsigned int)</code>为<code>sizeof(unsigned int)</code> （假定为4字节无符号int），作为From类型，而<code>unsigned int</code>作为To。 <br><br><pre> <code class="bash hljs">struct uint_chars { unsigned char arr[sizeof( unsigned int )] = {} ; //  sizeof( unsigned int ) == 4 }; //  len  4 int bar( unsigned char *p, size_t len ) { int result = 0; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( size_t index = 0; index &lt; len; index += sizeof(unsigned int) ) { uint_chars f; std::memcpy( f.arr, &amp;p[index], sizeof(unsigned int)); unsigned int result = bit_cast&lt;unsigned int&gt;(f); result += foo( result ); } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> result ; }</code> </pre> <br> 不幸的是，我们需要这种中间类型-这是当前的<code>bit_cast</code>限制。 <br><br>  <b>对齐方式</b> <br><br> 在前面的示例中，我们看到违反严格的别名规则会导致在优化过程中排除存储。 违反严格的混叠也可能导致违反对齐要求。  C标准和C ++都说对象要符合对齐要求，从而限制了对象可以放置（在内存中）并因此可以访问的位置。  <i>C11第6.2.8节“对象对齐状态”</i> ： <br><br> 完整类型的对象具有对齐要求，这些要求对可放置此类型对象的地址施加了限制。 对齐是实现定义的整数值，表示可以放置此对象的连续地址之间的字节数。 对象的类型对这种类型的每个对象都要求有对齐要求：可以使用<code>_Alignas</code>请求更严格的对齐方式。 <br><br>  <b>第1节[basic.align]中的C ++ 17项目标准</b> ： <br><br> 对象类型具有对齐要求（6.7.1，6.7.2），该要求对可放置此类型对象的地址施加了限制。 对齐是实现定义的整数值，表示可以放置给定对象的连续地址之间的字节数。 对象类型对这种类型的每个对象都要求对齐要求； 可以使用比对说明符（10.6.2）要求更严格的比对。 <br><br>  C99和C11都明确指出导致指针未对齐的转换是未定义的行为，第6.3.2.3节。  <i>指针</i>说： <br><blockquote> 指向对象或部分类型的指针可以转换为指向另一个对象或部分类型的指针。 如果生成的指针未针对指针类型正确对齐，则行为未定义。  ... <br></blockquote> 尽管C ++不太明显，但我认为第1款<code>[basic.align]</code>中的这一句话<code>[basic.align]</code>足够了： <br><blockquote>  ...对象的类型对这种类型的每个对象都要求对齐要求；  ... </blockquote>  <i><b>例子</b></i> <br><br> 因此，我们假设： <br><br><ul><li>  alignof（char）和alignof（int）分别为1和4 </li><li>  sizeof（int）是4 </li></ul><br> 因此，将大小为4的char数组解释为<code>int</code>违反严格的别名，如果数组的对齐方式为1或2个字节，也可能违反对齐要求。 <br><br><pre> <code class="bash hljs">char arr[4] = { 0x0F, 0x0, 0x0, 0x00 }; //        1  2  int x = *reinterpret_cast&lt;int*&gt;(arr); // Undefined behavior  </code> </pre> <br> 在某些情况下，这可能会导致性能降低或总线错误。 而使用alignas强制对int中的数组进行相同的对齐将防止对齐要求被破坏： <br><br><pre> <code class="bash hljs">alignas(alignof(int)) char arr[4] = { 0x0F, 0x0, 0x0, 0x00 }; int x = *reinterpret_cast&lt;int*&gt;(arr);</code> </pre> <br>  <i><b>原子性</b></i> <br><br> 对于不平衡访问的另一个意外惩罚是，它违反了某些架构的原子性。 如果x86中的其他线程未对齐，则原子存储可能不会显示为原子。 <br><br>  <b>捕获严格的混叠违规</b> <br><br> 我们没有很多好的工具来跟踪C ++中的严格别名。 我们拥有的工具将捕获某些违规情况以及某些不正确的加载和存储情况。 <br><br>  gcc使用<code>-fstrict-aliasing</code>和<code>-Wstrict-aliasing</code>标志可以捕获某些情况，尽管并非没有误报/麻烦。 例如，以下情况将在gcc中产生警告（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">example</a> ）： <br><br><pre> <code class="bash hljs">int a = 1; short j; <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> f = 1.f; //   ,   TIS ,         <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *(reinterpret_cast&lt;short*&gt;(&amp;a))); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *(reinterpret_cast&lt;int*&gt;(&amp;f)));</code> </pre> <br> 尽管他不会遇到这种额外的情况（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">例如</a> ）： <br><br><pre> <code class="bash hljs">int *p; p=&amp;a; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *(reinterpret_cast&lt;short*&gt;(p)));</code> </pre><br> 尽管<code>clang</code>解析了这些标志，但它似乎并未真正实现警告。 <br><br> 我们拥有的另一个工具是ASan，它可以捕获未对齐的记录和存储。 尽管它们并非直接违反严格的别名，但这是相当普遍的结果。 例如，以下情况将在使用<code>-fsanitize=address</code> clang进行汇编的过程中生成运行时错误 <br><br><pre> <code class="bash hljs">int *x = new int[2]; // 8 : [0,7]. int *u = (int*)((char*)x + 6); //     x    *u = 1; //    [6-9] <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, *u ); //    [6-9]</code> </pre> <br> 我推荐的最后一个工具是特定于C ++的，实际上，不仅是一种工具，而且是不允许C风格转换的编码实践， <code>gcc</code>和<code>clang</code>都将使用<code>-Wold-style-cast</code>对C <code>-Wold-style-cast</code>进行诊断。 <code>-Wold-style-cast</code> 。 这将强制所有未定义的双关语使用reinterpret_cast。 通常， <code>reinterpret_cast</code>应该是对代码进行更彻底分析的信标。 <br> 在代码库中搜索<code>reinterpret_cast</code>来执行审核也更加容易。 <br><br> 对于C，我们已经描述了所有工具，还拥有<code>tis-interpreter</code> （静态分析器），可以对程序的大量C语言子集进行详尽的分析，在上一个示例的C版本中，使用-fstrict-aliasing会跳过一种情况（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">示例</a> ） <br><br><pre> <code class="bash hljs">int a = 1; short j; <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> f = 1.0 ; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *((short*)&amp;a)); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *((int*)&amp;f)); int *p; p=&amp;a; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *((short*)p));</code> </pre><br>  TIS解释器可以拦截全部三个，下面的示例将TIS内核称为TIS解释器（为简洁起见对输出进行了编辑）： <br><br><pre> <code class="bash hljs">./bin/tis-kernel -sa example1.c ... example1.c:9:[sa] warning: The pointer (short *)(&amp; a) has <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> short *. It violates strict aliasing rules by accessing a cell with effective <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> int. ... example1.c:10:[sa] warning: The pointer (int *)(&amp; f) has <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> int *. It violates strict aliasing rules by accessing a cell with effective <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> <span class="hljs-built_in"><span class="hljs-built_in">float</span></span>. Callstack: main ... example1.c:15:[sa] warning: The pointer (short *)p has <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> short *. It violates strict aliasing rules by accessing a cell with effective <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> int.</code> </pre> <br> 最后是正在开发的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TySan</a> 。 该清理程序将类型检查信息添加到影子内存段，并检查访问以确定它们是否违反别名规则。 该工具可能应该能够跟踪所有混叠违规行为，但是在运行时可能会有很大的开销。 <br><br>  <b>结论</b> <br><br> 我们了解了C和C ++中的别名规则，这意味着编译器希望我们严格遵守这些规则，并接受不履行这些规则的后果。 我们已经了解了一些可以帮助我们识别假名滥用行为的工具。 我们已经看到，别名的通常用法是典型的双关语。 我们还学习了如何正确实施它。 <br><br> 优化器正在逐步改进基于类型的别名分析，并且已经破坏了一些基于严格别名冲突的代码。 我们可以期望优化会变得更好，并破坏更多的代码。 <br><br> 我们有标准的现成兼容方法来解释类型。 有时，对于调试版本，这些方法应该是免费的抽象。 我们有几种检测严重混叠违规的工具，但是对于C ++，它们仅捕获一小部分情况，对于使用tis解释器的C，我们可以跟踪大多数违规。 <br><br> 感谢那些对本文发表评论的人：JF Bastien，Christopher Di Bella，Pascal Quoc，Matt P. Dziubinski，Patrice Roy和Olafur Vaage <br> 当然，最后所有错误均归作者所有。 <br><br> 因此，相当大的材料的翻译工作已经结束，可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>阅读其第一部分。 传统上，我们邀请您参加<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">开放日</a> ，该日由Rambler＆Co- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Dmitry Shebordaev</a>的技术开发部门负责人于3月14日举行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><br></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN443602/">https://habr.com/ru/post/zh-CN443602/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN443590/index.html">数据科学：预测业务事件以改善服务</a></li>
<li><a href="../zh-CN443592/index.html">旧的FM接收器和电梯杂物产生的RFID前端标准ISO 11785</a></li>
<li><a href="../zh-CN443594/index.html">测试与架构的十字路口：尼尔·福特访谈</a></li>
<li><a href="../zh-CN443598/index.html">从各种CA大量撤消了TLS证书，这是错误地在63位RNG而非64位RNG上生成的</a></li>
<li><a href="../zh-CN443600/index.html">MWC 2019的最佳和最坏趋势</a></li>
<li><a href="../zh-CN443604/index.html">行动第一：OZON的Hackathon</a></li>
<li><a href="../zh-CN443606/index.html">Jenkins for Android使用Docker构建</a></li>
<li><a href="../zh-CN443608/index.html">Lazurite的智能家居/更新</a></li>
<li><a href="../zh-CN443612/index.html">我们使用旧的坏硬盘</a></li>
<li><a href="../zh-CN443614/index.html">YouTrack 2019.1：选择敏捷板，敏捷板上的可自定义卡字段等</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>