<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöæ ü§∏üèª üõåüèΩ io_submit: una alternativa a epoll de la que nunca has o√≠do hablar üóæ üçÅ üö≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente, la atenci√≥n del autor fue atra√≠da por un art√≠culo en LWN sobre una nueva interfaz de kernel para sondeo. Discute el nuevo mecanismo de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>io_submit: una alternativa a epoll de la que nunca has o√≠do hablar</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/439972/"><img src="https://habrastorage.org/webt/sq/pn/nd/sqpnnd88db_ax0ark-6wxrqkobc.jpeg"><br><br>  Recientemente, la atenci√≥n del autor fue atra√≠da por un art√≠culo en LWN sobre una nueva interfaz de kernel para sondeo.  Discute el nuevo mecanismo de sondeo en la API AIO de Linux (una interfaz para el manejo de archivos as√≠ncrono), que se agreg√≥ a la versi√≥n 4.18 del kernel.  La idea es bastante interesante: el autor del parche sugiere usar la API AIO de Linux para trabajar con la red. <br><br>  Pero espera un momento!  Despu√©s de todo, ¬°Linux AIO fue creado para trabajar con E / S as√≠ncronas de disco a disco!  Los archivos en el disco no son lo mismo que las conexiones de red.  ¬øEs posible usar la API AIO de Linux para redes? <br><br>  Resulta que s√≠, ¬°es posible!  Este art√≠culo explica c√≥mo usar las fortalezas de la API AIO de Linux para crear servidores de red m√°s r√°pidos y mejores. <br><br>  Pero comencemos explicando qu√© es Linux AIO. <br><a name="habracut"></a><br><h1>  Introducci√≥n a Linux AIO </h1><br>  Linux AIO proporciona E / S as√≠ncronas de disco a disco para el software del usuario. <br><br>  Hist√≥ricamente, en Linux, todas las operaciones de disco estaban bloqueadas.  Si llama a <code>open()</code> , <code>read()</code> , <code>write()</code> o <code>fsync()</code> , la secuencia se detiene hasta que los metadatos aparecen en la memoria cach√© del disco.  Esto generalmente no es un problema.  Si no tiene muchas operaciones de E / S y suficiente memoria, las llamadas al sistema llenar√°n gradualmente el cach√© y todo funcionar√° lo suficientemente r√°pido. <br><br>  El rendimiento de las operaciones de E / S disminuye cuando su n√∫mero es lo suficientemente grande, por ejemplo, en casos con bases de datos y servidores proxy.  Para tales aplicaciones, es inaceptable detener todo el proceso por el simple hecho de esperar una llamada al sistema <code>read()</code> . <br><br>  Para resolver este problema, las aplicaciones pueden usar tres m√©todos: <br><br><ol><li>  Use grupos de subprocesos y funciones de bloqueo de llamadas en subprocesos separados.  As√≠ es como funciona POSIX AIO en glibc (no lo confunda con Linux AIO).  Para obtener m√°s informaci√≥n, consulte la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n de IBM</a> .  As√≠ es como resolvimos el problema en Cloudflare: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">utilizamos el grupo de subprocesos</a> para llamar a <code>read()</code> y <code>open()</code> . <br></li><li>  Calienta el cach√© del disco con <code>posix_fadvise(2)</code> y espera lo mejor. <br></li><li>  Use Linux AIO junto con el sistema de archivos XFS, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">abriendo archivos con el indicador O_DIRECT</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">evitando problemas indocumentados</a> . <br></li></ol><br>  Sin embargo, ninguno de estos m√©todos es ideal.  Incluso Linux AIO, cuando se usa sin pensar, puede bloquearse en la llamada <code>io_submit()</code> .  Esto se mencion√≥ recientemente en otro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo sobre LWN</a> : <br><blockquote>  ‚ÄúLa interfaz de E / S as√≠ncrona de Linux tiene muchas cr√≠ticas y pocos partidarios, pero la mayor√≠a de las personas esperan al menos asincronismo.  De hecho, la operaci√≥n AIO puede bloquearse en el n√∫cleo por varias razones en situaciones en las que el hilo de llamada no puede permit√≠rselo ‚Äù. </blockquote>  Ahora que conocemos las debilidades de la API AIO de Linux, veamos sus puntos fuertes. <br><br><h2>  Un programa simple que usa Linux AIO </h2><br>  Para utilizar Linux AIO, primero debe <a href="">determinar las cinco llamadas necesarias del sistema</a> usted mismo: glibc no las proporciona. <br><br><ol><li>  Primero debe llamar a <code>io_setup()</code> para inicializar la estructura <code>aio_context</code> .  El n√∫cleo devolver√° un puntero opaco a la estructura. <br></li><li>  Despu√©s de eso, puede llamar a <code>io_submit()</code> para agregar el vector de "bloques de control de E / S" a la cola de procesamiento en forma de una estructura de estructura iocb. <br></li><li>  Ahora, finalmente, podemos llamar a <code>io_getevents()</code> y esperar una respuesta de este en forma de un vector de estructuras struct <code>io_event</code> , los resultados de cada uno de los bloques iocb. <br></li></ol><br>  Hay ocho comandos que puede usar en iocb.  Dos comandos para leer, dos para escribir, dos opciones de fsync y el comando POLL, que se agreg√≥ en la versi√≥n 4.18 del kernel (el octavo comando es NOOP): <br><br><pre> <code class="plaintext hljs">IOCB_CMD_PREAD = 0, IOCB_CMD_PWRITE = 1, IOCB_CMD_FSYNC = 2, IOCB_CMD_FDSYNC = 3, IOCB_CMD_POLL = 5,   /* from 4.18 */ IOCB_CMD_NOOP = 6, IOCB_CMD_PREADV = 7, IOCB_CMD_PWRITEV = 8,</code> </pre> <br>  <a href=""><code> iocb</code></a> , que se pasa a la funci√≥n <code>io_submit</code> , es bastante grande y est√° dise√±ada para funcionar con el disco.  Aqu√≠ est√° su versi√≥n simplificada: <br><br><pre> <code class="plaintext hljs">struct iocb { __u64 data;           /* user data */ ... __u16 aio_lio_opcode; /* see IOCB_CMD_ above */ ... __u32 aio_fildes;     /* file descriptor */ __u64 aio_buf;        /* pointer to buffer */ __u64 aio_nbytes;     /* buffer size */ ... }</code> </pre> <br>  La estructura completa <code>io_event</code> que devuelve <code>io_getevents</code> : <br><br><pre> <code class="plaintext hljs">struct io_event { __u64  data; /* user data */ __u64  obj; /* pointer to request iocb */ __s64  res; /* result code for this event */ __s64  res2; /* secondary result */ };</code> </pre><br>  <b>Un ejemplo</b>  Un programa simple que lee el archivo / etc / passwd usando la API AIO de Linux: <br><br><pre> <code class="plaintext hljs">fd = open("/etc/passwd", O_RDONLY); aio_context_t ctx = 0; r = io_setup(128, &amp;ctx); char buf[4096]; struct iocb cb = {.aio_fildes = fd,                 .aio_lio_opcode = IOCB_CMD_PREAD,                 .aio_buf = (uint64_t)buf,                 .aio_nbytes = sizeof(buf)}; struct iocb *list_of_iocb[1] = {&amp;cb}; r = io_submit(ctx, 1, list_of_iocb); struct io_event events[1] = {{0}}; r = io_getevents(ctx, 1, 1, events, NULL); bytes_read = events[0].res; printf("read %lld bytes from /etc/passwd\n", bytes_read);</code> </pre> <br>  Las fuentes completas est√°n, por supuesto, <a href="">disponibles en GitHub</a> .  Aqu√≠ est√° la salida de este programa: <br><br><pre> <code class="plaintext hljs">openat(AT_FDCWD, "/etc/passwd", O_RDONLY) io_setup(128, [0x7f4fd60ea000]) io_submit(0x7f4fd60ea000, 1, [{aio_lio_opcode=IOCB_CMD_PREAD, aio_fildes=3, aio_buf=0x7ffc5ff703d0, aio_nbytes=4096, aio_offset=0}]) io_getevents(0x7f4fd60ea000, 1, 1, [{data=0, obj=0x7ffc5ff70390, res=2494, res2=0}], NULL)</code> </pre> <br>  Todo sali√≥ bien, pero la lectura desde el disco no fue as√≠ncrona: la llamada io_submit se bloque√≥ e hizo todo el trabajo, la funci√≥n <code>io_getevents</code> ejecut√≥ al instante.  Podr√≠amos intentar leer de forma asincr√≥nica, pero esto requiere el indicador O_DIRECT, con el cual las operaciones de disco omiten el cach√©. <br><br>  Vamos a ilustrar mejor c√≥mo <code>io_submit</code> bloquea en los archivos normales.  Aqu√≠ hay un ejemplo similar que muestra la salida de strace como resultado de leer un bloque de 1 GB desde <code>/dev/zero</code> : <br><br><pre> <code class="plaintext hljs">io_submit(0x7fe1e800a000, 1, [{aio_lio_opcode=IOCB_CMD_PREAD, aio_fildes=3, aio_buf=0x7fe1a79f4000, aio_nbytes=1073741824, aio_offset=0}]) \   = 1 &lt;0.738380&gt; io_getevents(0x7fe1e800a000, 1, 1, [{data=0, obj=0x7fffb9588910, res=1073741824, res2=0}], NULL) \   = 1 &lt;0.000015&gt;</code> </pre> <br>  El n√∫cleo pas√≥ 738 ms en una llamada <code>io_submit</code> y solo 15 ns en <code>io_getevents</code> .  Se comporta de manera similar con las conexiones de red: todo el trabajo lo realiza <code>io_submit</code> . <br><br><img src="https://habrastorage.org/webt/e6/kw/kf/e6kwkfffjb-qvsfqgfdyl2ibmaq.jpeg"><br>  <a href="">Foto</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Helix84</a> CC / BY-SA / 3.0 <br><br><h2>  Linux AIO y red </h2><br>  La implementaci√≥n de <code>io_submit</code> bastante conservadora: si el descriptor de archivo pasado no se abri√≥ con el indicador O_DIRECT, entonces la funci√≥n simplemente bloquea y realiza la acci√≥n especificada.  En el caso de las conexiones de red, esto significa que: <br><br><ul><li>  para bloquear conexiones, IOCV_CMD_PREAD esperar√° un paquete de respuesta; <br></li><li>  para conexiones sin bloqueo, IOCB_CMD_PREAD devolver√° el c√≥digo -11 (EAGAIN). <br></li></ul><br>  La misma sem√°ntica tambi√©n se usa en la llamada regular del sistema <code>read()</code> , por lo que podemos decir que io_submit cuando se trabaja con conexiones de red no es m√°s inteligente que las buenas llamadas <code>read() / write()</code> . <br><br>  Es importante tener en cuenta que <code>iocb</code> solicitudes <code>iocb</code> ejecutadas secuencialmente por el n√∫cleo. <br><br>  A pesar de que Linux AIO no nos ayudar√° con operaciones asincr√≥nicas, se puede usar para combinar llamadas del sistema en lotes. <br><br>  Si el servidor web necesita enviar y recibir datos de cientos de conexiones de red, usar <code>io_submit</code> podr√≠a ser una gran idea, ya que evita cientos de llamadas de env√≠o y recepci√≥n.  Esto mejorar√° el rendimiento: cambiar del espacio de usuario al kernel y viceversa no es gratis, especialmente despu√©s de la introducci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">medidas para combatir a Spectre y Meltdown</a> . <br><br><table><tbody><tr><td></td><td align="center">  <b>Un b√∫fer</b> <br></td><td align="center">  <b>M√∫ltiples tampones</b> <br></td></tr><tr><td>  Un descriptor de archivo <br></td><td>  leer () <br></td><td>  readv () <br></td></tr><tr><td>  Descriptores de m√∫ltiples archivos <br></td><td>  io_submit + IOCB_CMD_PREAD <br></td><td>  io_submit + IOCB_CMD_PREADV <br></td></tr></tbody></table><br>  Para ilustrar la agrupaci√≥n de llamadas del sistema en paquetes usando <code>io_submit</code> escriba un peque√±o programa que env√≠e datos de una conexi√≥n TCP a otra.  En su forma m√°s simple (sin Linux AIO), se parece a esto: <br><br><pre> <code class="plaintext hljs">while True: d = sd1.read(4096) sd2.write(d)</code> </pre> <br>  Podemos expresar la misma funcionalidad a trav√©s de Linux AIO.  El c√≥digo en este caso ser√° as√≠: <br><br><pre> <code class="plaintext hljs">struct iocb cb[2] = {{.aio_fildes = sd2,                     .aio_lio_opcode = IOCB_CMD_PWRITE,                     .aio_buf = (uint64_t)&amp;buf[0],                     .aio_nbytes = 0},                    {.aio_fildes = sd1,                    .aio_lio_opcode = IOCB_CMD_PREAD,                    .aio_buf = (uint64_t)&amp;buf[0],                    .aio_nbytes = BUF_SZ}}; struct iocb *list_of_iocb[2] = {&amp;cb[0], &amp;cb[1]}; while(1) { r = io_submit(ctx, 2, list_of_iocb); struct io_event events[2] = {}; r = io_getevents(ctx, 2, 2, events, NULL); cb[0].aio_nbytes = events[1].res; }</code> </pre> <br>  Este c√≥digo agrega dos trabajos a <code>io_submit</code> : primero una solicitud de escritura a <code>sd2</code> , y luego una solicitud de lectura de sd1.  Despu√©s de leer, el c√≥digo corrige el tama√±o del b√∫fer de escritura y repite el ciclo desde el principio.  Hay un truco: la primera vez que se produce una escritura con un b√∫fer de tama√±o 0. Esto es necesario porque tenemos la capacidad de combinar escritura + lectura en una llamada <code>io_submit</code> (pero no lectura + escritura). <br><br>  ¬øEs este c√≥digo m√°s r√°pido que el normal <code>read()</code> / <code>write()</code> ?  A√∫n no  Ambas versiones usan dos llamadas al sistema: lectura + escritura y io_submit + io_getevents.  Pero, afortunadamente, el c√≥digo se puede mejorar. <br><br><h2>  Deshacerse de io_getevents </h2><br>  En tiempo de ejecuci√≥n <code>io_setup()</code> kernel asigna varias p√°ginas de memoria para el proceso.  As√≠ es como se ve este bloque de memoria en / proc // maps: <br><br><pre> <code class="plaintext hljs">marek:~$ cat /proc/`pidof -s aio_passwd`/maps ... 7f7db8f60000-7f7db8f63000 rw-s 00000000 00:12 2314562     /[aio] (deleted) ...</code> </pre> <br>  Al bloque de memoria [aio] (12 Kb en este caso) se le asign√≥ <code>io_setup</code> .  Se utiliza para el b√∫fer circular donde se almacenan los eventos.  En la mayor√≠a de los casos, no hay raz√≥n para llamar a <code>io_getevents</code> : los datos de finalizaci√≥n de eventos se pueden obtener del b√∫fer de anillo sin la necesidad de cambiar al modo kernel.  Aqu√≠ est√° la versi√≥n corregida del c√≥digo: <br><br><pre> <code class="plaintext hljs">int io_getevents(aio_context_t ctx, long min_nr, long max_nr,                struct io_event *events, struct timespec *timeout) {   int i = 0;   struct aio_ring *ring = (struct aio_ring*)ctx;   if (ring == NULL || ring-&gt;magic != AIO_RING_MAGIC) {       goto do_syscall;   }   while (i &lt; max_nr) {       unsigned head = ring-&gt;head;       if (head == ring-&gt;tail) {           /* There are no more completions */           break;       } else {           /* There is another completion to reap */           events[i] = ring-&gt;events[head];           read_barrier();           ring-&gt;head = (head + 1) % ring-&gt;nr;           i++;       }   }   if (i == 0 &amp;&amp; timeout != NULL &amp;&amp; timeout-&gt;tv_sec == 0 &amp;&amp; timeout-&gt;tv_nsec == 0) {       /* Requested non blocking operation. */       return 0;   }   if (i &amp;&amp; i &gt;= min_nr) {       return i;   } do_syscall:   return syscall(__NR_io_getevents, ctx, min_nr-i, max_nr-i, &amp;events[i], timeout); }</code> </pre> <br>  La versi√≥n completa del c√≥digo est√° disponible <a href="">en GitHub</a> .  La interfaz de este buffer de anillo est√° pobremente documentada; el autor adapt√≥ el c√≥digo del <a href="">proyecto axboe / fio</a> . <br><br>  Despu√©s de este cambio, nuestra versi√≥n del c√≥digo que usa Linux AIO requiere solo una llamada al sistema en un bucle, lo que lo hace un poco m√°s r√°pido que el c√≥digo original que usa lectura + escritura. <br><br><img src="https://habrastorage.org/webt/xq/er/7t/xqer7tve9zpg23gh2zfjjl_bb-i.jpeg"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Foto</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tren Fotos</a> CC / BY-SA / 2.0 <br><br><h2>  Alternativa Epoll </h2><br>  Con la adici√≥n de IOCB_CMD_POLL a la versi√≥n 4.18 del kernel, se hizo posible usar <code>io_submit</code> como un reemplazo para select / poll / epoll.  Por ejemplo, este c√≥digo esperar√° datos de una conexi√≥n de red: <br><br><pre> <code class="plaintext hljs">struct iocb cb = {.aio_fildes = sd,                 .aio_lio_opcode = IOCB_CMD_POLL,                 .aio_buf = POLLIN}; struct iocb *list_of_iocb[1] = {&amp;cb}; r = io_submit(ctx, 1, list_of_iocb); r = io_getevents(ctx, 1, 1, events, NULL);</code> </pre><br>  <a href="">C√≥digo completo</a>  Aqu√≠ est√° su salida de strace: <br><br><pre> <code class="plaintext hljs">io_submit(0x7fe44bddd000, 1, [{aio_lio_opcode=IOCB_CMD_POLL, aio_fildes=3}]) \   = 1 &lt;0.000015&gt; io_getevents(0x7fe44bddd000, 1, 1, [{data=0, obj=0x7ffef65c11a8, res=1, res2=0}], NULL) \   = 1 &lt;1.000377&gt;</code> </pre> <br>  Como puede ver, esta vez la asincron√≠a funcion√≥: io_submit se ejecut√≥ instant√°neamente y <code>io_getevents</code> bloque√≥ durante un segundo, esperando datos.  Esto se puede usar en lugar de la llamada al sistema <code>epoll_wait()</code> . <br><br>  Adem√°s, trabajar con <code>epoll</code> generalmente requiere el uso de las llamadas del sistema epoll_ctl.  Y los desarrolladores de aplicaciones intentan evitar llamadas frecuentes a esta funci√≥n: para comprender los motivos, solo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lea los</a> indicadores EPOLLONESHOT y EPOLLET <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el manual</a> .  Usando io_submit para consultar conexiones, puede evitar estas dificultades y llamadas adicionales al sistema.  Simplemente agregue las conexiones al vector iocb, llame a io_submit una vez y espere la ejecuci√≥n.  Todo es muy sencillo. <br><br><h2>  Resumen </h2><br>  En esta publicaci√≥n, cubrimos la API AIO de Linux.  Esta API se dise√±√≥ originalmente para funcionar con el disco, pero tambi√©n funciona con conexiones de red.  Sin embargo, a diferencia de las llamadas normales read () + write (), el uso de io_submit le permite agrupar las llamadas del sistema y as√≠ aumentar el rendimiento. <br><br>  A partir de la versi√≥n 4.18 del kernel, <code>io_submit  io_getevents</code> en el caso de las conexiones de red se pueden usar para eventos de la forma POLLIN y POLLOUT.  Esta es una alternativa a <code>epoll()</code> . <br><br>  Me imagino un servicio de red que usa solo <code>io_submit  io_getevents</code> lugar del conjunto est√°ndar de lectura, escritura, epoll_ctl y epoll_wait.  En este caso, agrupar llamadas del sistema en <code>io_submit</code> puede ofrecer una gran ventaja, tal servidor ser√≠a mucho m√°s r√°pido. <br><br>  Desafortunadamente, incluso despu√©s de las recientes mejoras en la API AIO de Linux, contin√∫an las discusiones sobre su utilidad.  Es bien sabido que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Linus lo odia</a> : <br><br><blockquote>  "AIO es un terrible ejemplo de dise√±o a la altura de las rodillas, donde la excusa principal es:" a otras personas menos talentosas se les ocurri√≥ esto, por lo que debemos cumplir con la compatibilidad para que los desarrolladores de bases de datos (que rara vez tengan buen gusto) puedan usarla ".  Pero AIO siempre ha sido muy, muy torcido ". </blockquote><br>  Se han hecho varios intentos para crear una mejor interfaz para agrupar llamadas y asincron√≠a, pero carec√≠an de una visi√≥n com√∫n.  Por ejemplo, la reciente <a href="">incorporaci√≥n de sendto (MSG_ZEROCOPY)</a> permite una transferencia de datos verdaderamente asincr√≥nica, pero no permite la agrupaci√≥n.  <code>io_submit</code> proporciona agrupaci√≥n, pero no asincron√≠a.  Peor a√∫n: actualmente hay tres formas de entregar eventos asincr√≥nicos en Linux: se√±ales, <code>io_getevents</code> y MSG_ERRQUEUE. <br><br>  En cualquier caso, es genial que haya nuevas formas de acelerar el trabajo de los servicios de red. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/439972/">https://habr.com/ru/post/439972/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../439962/index.html">Trabajamos con Atlassian Service Desk, aprovechamos al m√°ximo el complemento Riada Insight: un informe de la reuni√≥n del Grupo de usuarios de Atlassian</a></li>
<li><a href="../439964/index.html">Vulnerabilidad de Runc CVE-2019-5736 en un host</a></li>
<li><a href="../439966/index.html">Analizador simple para operaciones aritm√©ticas</a></li>
<li><a href="../439968/index.html">Espacio de Generaci√≥n y Espacio de Oportunidad</a></li>
<li><a href="../439970/index.html">Informe sobre problemas y accesibilidad de Internet en 2018-2019</a></li>
<li><a href="../439974/index.html">Transformaci√≥n √°gil personal: un viaje flexible hacia la productividad</a></li>
<li><a href="../439976/index.html">¬øNode.js siempre ser√° m√°s lento que Golang?</a></li>
<li><a href="../439978/index.html">Aprendizaje Docker, Parte 2: T√©rminos y conceptos</a></li>
<li><a href="../439980/index.html">Aprendizaje Docker, Parte 3: Archivos Dockerfile</a></li>
<li><a href="../439982/index.html">Tutorial de React, Parte 16: La cuarta fase de trabajar en una aplicaci√≥n TODO, Procesamiento de eventos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>