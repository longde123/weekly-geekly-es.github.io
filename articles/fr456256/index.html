<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👻 🔓 💪🏽 Guide d'architecture d'application Android 🙋🏼 💸 ⚜️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous présente la traduction gratuite du «Guide de l'architecture des applications» de JetPack . Je vous demande de laisser tous les ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guide d'architecture d'application Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456256/">  Bonjour, Habr!  Je vous présente la traduction gratuite du «Guide de l'architecture des applications» de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JetPack</a> .  Je vous demande de laisser tous les commentaires sur la traduction dans les commentaires, et ils seront corrigés.  De plus, les commentaires de ceux qui ont utilisé l'architecture présentée avec des recommandations pour son utilisation seront utiles à tous. <br><br>  Ce guide couvre les meilleures pratiques et l'architecture recommandée pour créer des applications robustes.  Cette page suppose une introduction de base à Android Framework.  Si vous êtes nouveau dans le développement d'applications Android, consultez nos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">guides de développement</a> pour commencer et en savoir plus sur les concepts mentionnés dans ce guide.  Si vous êtes intéressé par l'architecture des applications et souhaitez vous familiariser avec les matériaux de ce guide en termes de programmation sur Kotlin, consultez le cours Udacity, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Développement d'applications pour Android avec Kotlin»</a> . <br><br><h2>  Expérience utilisateur de l'application mobile </h2><br>  Dans la plupart des cas, les applications de bureau ont un point d'entrée unique à partir du bureau ou du lanceur, puis s'exécutent comme un processus monolithique unique.  Les applications Android ont une structure beaucoup plus complexe.  Une application Android typique contient plusieurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">composants d'application</a> , notamment des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">activités</a> , des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fragments</a> , des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">services</a> , des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fournisseurs de contenu</a> et des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">récepteurs de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">diffusion</a> . <br><br>  Vous déclarez tout ou partie de ces composants d'application dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">manifeste d'</a> application.  Android utilise ensuite ce fichier pour décider comment intégrer votre application dans l'interface utilisateur commune de l'appareil.  Étant donné qu'une application Android bien écrite contient plusieurs composants et que les utilisateurs interagissent souvent avec plusieurs applications dans un court laps de temps, les applications doivent s'adapter à différents types de flux de travail et de tâches pilotées par l'utilisateur. <br><a name="habracut"></a><br>  Par exemple, considérez ce qui se passe lorsque vous partagez une photo dans votre application de médias sociaux préférée: <br><br><ol><li>  L'application déclenche l'intention de la caméra.  Android lance une application appareil photo pour traiter la demande.  Pour le moment, l'utilisateur a quitté l'application pour les réseaux sociaux, et son expérience en tant qu'utilisateur est impeccable. </li><li>  Une application de caméra peut déclencher d'autres intentions, comme le lancement d'un sélecteur de fichiers, qui peut lancer une autre application. </li><li>  À la fin, l'utilisateur revient à l'application de réseau social et partage la photo. </li></ol><br>  À tout moment du processus, l'utilisateur peut être interrompu par un appel téléphonique ou une notification.  Après l'action associée à cette interruption, l'utilisateur s'attend à pouvoir revenir et reprendre ce processus de partage de photos.  Ce comportement de changement d'application est courant sur les appareils mobiles, votre application doit donc gérer correctement ces points (tâches). <br><br>  N'oubliez pas que les appareils mobiles sont également limités en ressources, donc à tout moment le système d'exploitation peut détruire certains processus d'application afin de libérer de l'espace pour de nouveaux. <br><br>  Compte tenu des conditions de cet environnement, les composants de votre application peuvent être lancés individuellement et non dans l'ordre, et le système d'exploitation ou l'utilisateur peut les détruire à tout moment.  Étant donné que ces événements ne sont pas sous votre contrôle, <b>vous ne devez pas stocker de données ou d'états dans vos composants d'application</b> et vos composants d'application ne doivent pas dépendre les uns des autres. <br><br><h2>  Principes architecturaux généraux </h2><br>  Si vous ne devez pas utiliser de composants d'application pour stocker des données et l'état de l'application, comment devez-vous développer votre application? <br><br><h3>  Répartition des responsabilités </h3><br>  Le principe le plus important à suivre est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le partage des responsabilités</a> .  Une erreur courante est lorsque vous écrivez tout votre code dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Activity</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fragment</a> .  Ce sont des classes d'interface utilisateur qui doivent contenir uniquement une logique traitant l'interaction de l'interface utilisateur et du système d'exploitation.  En partageant autant que possible la responsabilité dans ces classes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">(SRP)</a> , vous pouvez éviter bon nombre des problèmes associés au cycle de vie de l'application. <br><br><h3>  Contrôle de l'interface utilisateur à partir du modèle </h3><br>  Un autre principe important est que vous devez <b>contrôler votre interface utilisateur à partir d'un modèle</b> , de préférence à partir d'un modèle permanent.  Les modèles sont les composants qui sont responsables du traitement des données pour l'application.  Ils sont indépendants des objets <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">View</a> et des composants d'application, par conséquent, ils ne sont pas affectés par le cycle de vie de l'application et les problèmes associés. <br><br>  Un modèle permanent est idéal pour les raisons suivantes: <br><br><ul><li>  Vos utilisateurs ne perdront pas de données si le système d'exploitation Android détruit votre application pour libérer des ressources. </li><li>  Votre application continue de fonctionner lorsque la connexion réseau est instable ou indisponible. </li></ul><br>  En organisant la fondation de votre application en classes de modèle avec une responsabilité clairement définie pour la gestion des données, votre application devient plus testable et prise en charge. <br><br><h2>  Architecture d'application recommandée </h2><br>  Cette section montre comment structurer une application à l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">composants architecturaux</a> , en travaillant dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">scénario d'utilisation de bout en bout</a> . <br><br>  <i><b>Remarque</b></i>  <i>Il n'est pas possible d'avoir une façon d'écrire des applications qui fonctionne le mieux pour chaque scénario.</i>  <i>Cependant, l'architecture recommandée est un bon point de départ pour la plupart des situations et des workflows.</i>  <i>Si vous avez déjà un bon moyen d'écrire des applications Android qui répondent aux principes architecturaux généraux, vous ne devriez pas le changer.</i> <br><br>  Imaginez que nous créons une interface utilisateur qui affiche un profil utilisateur.  Nous utilisons une API privée et une API REST pour récupérer les données de profil. <br><br><h3>  Revue </h3><br>  Pour commencer, considérons le schéma d'interaction des modules de l'architecture de l'application finie: <br><br><img src="https://habrastorage.org/webt/lb/xq/cx/lbxqcxyjtoauqkif9hte7srpnm8.png"><br><br>  Veuillez noter que chaque composant dépend uniquement du composant un niveau en dessous.  Par exemple, l'activité et les fragments dépendent uniquement du modèle de vue.  Le référentiel est la seule classe qui dépend de nombreuses autres classes;  dans cet exemple, le stockage dépend d'un modèle de données persistant et d'une source de données interne distante. <br><br>  Ce modèle de conception crée une expérience utilisateur cohérente et agréable.  Que l'utilisateur revienne à l'application quelques minutes après sa fermeture ou quelques jours plus tard, il verra instantanément les informations utilisateur indiquant que l'application est enregistrée localement.  Si ces données sont obsolètes, le module de stockage d'application commence à mettre à jour les données en arrière-plan. <br><br><h3>  Créer une interface utilisateur </h3><br>  L'interface utilisateur se compose du fragment <code>UserProfileFragment</code> et du <code>user_profile_layout.xml</code> disposition <code>user_profile_layout.xml</code> correspondant. <br><br>  Pour gérer l'interface utilisateur, notre modèle de données doit contenir les éléments de données suivants: <br><br><ul><li>  <b>ID</b> utilisateur <b>:</b> ID utilisateur.  La meilleure solution consiste à transmettre ces informations au fragment à l'aide des arguments du fragment.  Si le système d'exploitation Android détruit notre processus, ces informations sont enregistrées, de sorte que l'identifiant sera disponible la prochaine fois que nous lancerons notre application. </li><li>  <b>Objet utilisateur:</b> une classe de données qui contient des informations utilisateur. </li></ul><br>  Nous utilisons un <code>UserProfileViewModel</code> basé sur un composant de l'architecture ViewModel pour stocker ces informations. <br><br>  <i><u>L'objet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ViewModel</a> fournit des données pour un composant d'interface utilisateur spécifique, tel qu'un fragment ou une activité, et contient une logique de traitement des données métier pour interagir avec le modèle.</u></i>  <i><u>Par exemple, le <b>ViewModel</b> peut appeler d'autres composants pour charger des données et peut transmettre des demandes d'utilisateurs pour des modifications de données.</u></i>  <i><u><b>ViewModel</b> ne connaît pas les composants de l'interface utilisateur, il n'est donc pas affecté par les modifications de configuration, telles que la recréation de l'activité lorsque le périphérique est tourné.</u></i> <br><br>  Nous avons maintenant identifié les fichiers suivants: <br><br><ul><li>  <code>user_profile.xml</code> : disposition d'interface utilisateur définie. </li><li>  <code>UserProfileFragment</code> : décrit un contrôleur d'interface utilisateur qui est responsable de l'affichage des informations à l'utilisateur. </li><li>  <code>UserProfileViewModel</code> : une classe chargée de préparer les données pour les afficher dans <code>UserProfileFragment</code> et répondre à l'interaction de l'utilisateur. </li></ul><br>  Les extraits de code suivants montrent le contenu initial de ces fichiers.  (Le fichier de mise en page est omis pour plus de simplicité.) <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserProfileViewModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ViewModel</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userId : String = TODO() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user : User = TODO() } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserProfileFragment</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fragment</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> viewModel: UserProfileViewModel <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> viewModels() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreateView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( inflater: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">LayoutInflater</span></span></span></span><span class="hljs-function"><span class="hljs-params">, container: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ViewGroup</span></span></span></span><span class="hljs-function"><span class="hljs-params">?, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">? )</span></span></span></span>: View { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inflater.inflate(R.layout.main_fragment, container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) } }</code> </pre> <br>  Maintenant que nous avons ces modules de code, comment les connecter?  Une fois le champ utilisateur défini dans la classe UserProfileViewModel, nous avons besoin d'un moyen d'informer l'interface utilisateur. <br><br>  <i><b>Remarque</b></i>  <i>SavedStateHandle permet au ViewModel d'accéder à l'état enregistré et aux arguments du fragment ou de l'action associé.</i> <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// UserProfileViewModel class UserProfileViewModel( savedStateHandle: SavedStateHandle ) : ViewModel() { val userId : String = savedStateHandle["uid"] ?: throw IllegalArgumentException("missing user id") val user : User = TODO() } // UserProfileFragment private val viewModel: UserProfileViewModel by viewModels( factoryProducer = { SavedStateVMFactory(this) } ... )</span></span></code> </pre> <br>  Nous devons maintenant informer notre Fragment lorsque l'objet utilisateur est reçu.  C'est là que le composant de l'architecture LiveData apparaît. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LiveData</a> est un détenteur de données observable.  D'autres composants de votre application peuvent suivre les modifications apportées aux objets à l'aide de ce support, sans créer de chemins de dépendance explicites et matériels entre eux.  Le composant LiveData prend également en compte l'état du cycle de vie des composants de votre application, tels que les activités, les fragments et les services, et inclut une logique de nettoyage pour éviter les fuites d'objets et la consommation excessive de mémoire. <br><br>  <i>Remarque</i>  <i>Si vous utilisez déjà des bibliothèques comme RxJava ou Agera, vous pouvez continuer à les utiliser à la place de LiveData.</i>  <i>Cependant, lorsque vous utilisez des bibliothèques et des approches similaires, assurez-vous de gérer correctement le cycle de vie de votre application.</i>  <i>En particulier, assurez-vous de suspendre vos flux de données lorsque le LifecycleOwner associé est arrêté et de détruire ces flux lorsque le LifecycleOwner associé a été détruit.</i>  <i>Vous pouvez également ajouter l'artefact android.arch.lifecycle: jet streams pour utiliser LiveData avec une autre bibliothèque de jet stream telle que RxJava2.</i> <br><br>  Pour inclure le composant LiveData dans notre application, nous changeons le type de champ dans <code>UserProfileViewModel</code> en LiveData.  <code>UserProfileFragment</code> désormais informé des mises à jour des données.  De plus, puisque ce champ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LiveData</a> prend en charge le cycle de vie, il efface automatiquement les liens lorsqu'ils ne sont plus nécessaires. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserProfileViewModel</span></span></span></span>( savedStateHandle: SavedStateHandle ) : ViewModel() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userId : String = savedStateHandle[<span class="hljs-string"><span class="hljs-string">"uid"</span></span>] ?: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"missing user id"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user : LiveData&lt;User&gt; = TODO() }</code> </pre> <br>  Maintenant, nous modifions <code>UserProfileFragment</code> pour observer les données dans le <code>ViewModel</code> et pour mettre à jour l'interface utilisateur en fonction des changements: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onViewCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onViewCreated(view, savedInstanceState) viewModel.user.observe(viewLifecycleOwner) { <span class="hljs-comment"><span class="hljs-comment">//  UI } }</span></span></code> </pre> <br>  Chaque fois que les données du profil utilisateur sont mises à jour, le rappel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">onChanged ()</a> est appelé et l'interface utilisateur est mise à jour. <br><br>  Si vous connaissez d'autres bibliothèques qui utilisent des rappels observables, vous avez peut-être réalisé que nous n'avons pas redéfini la méthode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">onStop ()</a> du fragment pour arrêter l'observation des données.  Cette étape est facultative pour LiveData car elle prend en charge le cycle de vie, ce qui signifie qu'elle n'appellera pas le rappel <code>onChanged()</code> si le fragment est dans un état inactif;  c'est-à-dire qu'il a reçu un appel à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">onStart ()</a> , mais n'a pas encore reçu <code>onStop()</code> ).  LiveData supprime également automatiquement l'observateur lors de l'appel de la méthode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">onDestroy ()</a> sur le fragment. <br><br>  Nous n'avons ajouté aucune logique pour gérer les modifications de configuration, telles que la rotation de l'écran de l'appareil par l'utilisateur.  <code>UserProfileViewModel</code> automatiquement restauré lorsque la configuration est modifiée, donc dès qu'un nouveau fragment est créé, il obtient la même instance de <code>ViewModel</code> et le rappel est appelé immédiatement à l'aide des données actuelles.  Étant donné que les objets <code>ViewModel</code> sont conçus pour survivre aux objets <code>View</code> correspondants qu'ils mettent à jour, vous ne devez pas inclure de références directes aux objets <code>View</code> dans votre implémentation ViewModel.  Pour plus d'informations sur la durée de vie du <code>ViewModel</code> correspond au cycle de vie des composants de l'interface utilisateur, voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ViewModel Life Cycle.</a> <br><br><h3>  Récupération de données </h3><br>  Maintenant que nous avons utilisé LiveData pour connecter <code>UserProfileViewModel</code> à <code>UserProfileFragment</code> , comment pouvons-nous obtenir les données de profil utilisateur? <br><br>  Dans cet exemple, nous supposons que notre backend fournit une API REST.  Nous utilisons la bibliothèque Retrofit pour accéder à notre backend, bien que vous puissiez utiliser une bibliothèque différente qui sert le même objectif. <br><br>  Voici notre définition d'un <code>Webservice</code> qui relie à notre backend: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Webservice</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@GET</span></span></span><span class="hljs-comment"> declares an HTTP GET request * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@Path</span></span></span><span class="hljs-comment">("user") annotation on the userId parameter marks it as a * replacement for the {user} placeholder in the </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@GET</span></span></span><span class="hljs-comment"> path */</span></span> <span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/users/{user}"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@Path(</span></span></span><span class="hljs-meta-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta"><span class="hljs-meta-string">"user"</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">)</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Call&lt;User&gt; }</code> </pre> <br>  Une première idée pour implémenter un <code>ViewModel</code> pourrait impliquer d'appeler <code>Webservice</code> pour récupérer les données et affecter ces données à notre objet <code>LiveData</code> .  Cette conception fonctionne, mais son utilisation rend notre application plus difficile à maintenir à mesure qu'elle grandit.  Cela donne trop de responsabilité à la classe <code>UserProfileViewModel</code> , qui viole le principe de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">séparation des intérêts</a> .  De plus, la portée du ViewModel est associée au cycle de vie de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">activité</a> ou du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fragment</a> , ce qui signifie que les données du <code>Webservice</code> perdues lorsque le cycle de vie de l'objet d'interface utilisateur associé se termine.  Ce comportement crée une expérience utilisateur indésirable. <br><br>  Au lieu de cela, notre <code>ViewModel</code> délègue le processus de récupération des données à un nouveau module de stockage. <br><br>  <u><i><b>Les</b> modules du <b>référentiel</b> gèrent les opérations de données.</i></u>  <u><i>Ils fournissent une API propre pour que le reste de l'application puisse facilement obtenir ces données.</i></u>  <u><i>Ils savent où obtenir les données et quels appels d'API effectuer lors de la mise à jour des données.</i></u>  <u><i>Vous pouvez considérer les référentiels comme des intermédiaires entre différentes sources de données, telles que les modèles persistants, les services Web et les caches.</i></u> <br><br>  Notre classe <code>UserRepository</code> , illustrée dans l'extrait de code suivant, utilise une instance de <code>WebService</code> pour récupérer les données utilisateur: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserRepository</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> webservice: Webservice = TODO() <span class="hljs-comment"><span class="hljs-comment">// ... fun getUser(userId: String): LiveData&lt;User&gt; { //    .    . val data = MutableLiveData&lt;User&gt;() webservice.getUser(userId).enqueue(object : Callback&lt;User&gt; { override fun onResponse(call: Call&lt;User&gt;, response: Response&lt;User&gt;) { data.value = response.body() } //     . override fun onFailure(call: Call&lt;User&gt;, t: Throwable) { TODO() } }) return data } }</span></span></code> </pre> <br>  Bien que le module de stockage semble inutile, il sert un objectif important: il extrait les sources de données du reste de l'application.  Maintenant, notre <code>UserProfileViewModel</code> ne sait pas comment récupérer des données, nous pouvons donc fournir des modèles de présentation avec des données obtenues à partir de plusieurs implémentations d'extraction de données différentes. <br><br>  <b>Remarque</b>  Nous avons raté le cas des erreurs de réseau pour plus de simplicité.  Pour une implémentation alternative qui expose les erreurs et l'état de téléchargement, voir l'annexe: divulgation de l'état du réseau. <br><br>  <b>Gestion des dépendances entre les composants</b> <br><br>  La classe <code>UserRepository</code> ci-dessus a besoin d'une instance de <code>Webservice</code> pour récupérer les données utilisateur.  Il pourrait simplement créer une instance, mais pour cela, il doit également connaître les dépendances de la classe <code>Webservice</code> .  De plus, <code>UserRepository</code> n'est probablement pas la seule classe à avoir besoin d'un service Web.  Cette situation nous oblige à dupliquer le code, car chaque classe qui a besoin d'un lien vers le <code>Webservice</code> doit savoir comment le créer et ses dépendances.  Si chaque classe crée un nouveau <code>WebService</code> , notre application peut devenir très gourmande en ressources. <br><br>  Pour résoudre ce problème, vous pouvez utiliser les modèles de conception suivants: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Injection de dépendance (DI)</a> .  L'injection de dépendances permet aux classes de définir leurs dépendances sans les créer.  Au moment de l'exécution, une autre classe est chargée de fournir ces dépendances.  Nous recommandons la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dagger 2</a> pour implémenter l'injection de dépendances dans les applications Android.  Dagger 2 crée automatiquement des objets, en contournant l'arborescence des dépendances et fournit des garanties de compilation pour les dépendances. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">(Emplacement du service) Localisateur de services</a> : le modèle de localisateur de services fournit un registre dans lequel les classes peuvent obtenir leurs dépendances au lieu de les créer. </li></ul><br>  L'implémentation d'un registre de services est plus facile que l'utilisation de DI, donc si vous débutez avec DI, utilisez plutôt le template: service location. <br><br>  Ces modèles vous permettent de faire évoluer votre code car ils fournissent des modèles clairs pour gérer les dépendances sans dupliquer ou compliquer le code.  De plus, ces modèles vous permettent de basculer rapidement entre les implémentations de test et de production d'échantillonnage de données. <br><br>  Notre exemple d'application utilise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dagger 2</a> pour gérer les dépendances de l'objet <code>Webservice</code> . <br><br><h3>  Connectez ViewModel et Storage </h3><br>  Maintenant, nous modifions notre <code>UserProfileViewModel</code> pour utiliser l'objet <code>UserRepository</code> : <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserProfileViewModel</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( savedStateHandle: SavedStateHandle, userRepository: UserRepository ) : ViewModel() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userId : String = savedStateHandle[<span class="hljs-string"><span class="hljs-string">"uid"</span></span>] ?: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"missing user id"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user : LiveData&lt;User&gt; = userRepository.getUser(userId) }</code> </pre> <br><h3>  Mise en cache </h3><br>  L'implémentation <code>UserRepository</code> résume l'invocation de l'objet <code>Webservice</code> , mais comme elle ne repose que sur une seule source de données, elle n'est pas très flexible. <br><br>  Le principal problème avec la mise en œuvre de <code>UserRepository</code> est qu'après avoir reçu des données de notre backend, ces données ne sont stockées nulle part.  Par conséquent, si l'utilisateur quitte <code>UserProfileFragment</code> puis y revient, notre application doit récupérer les données, même si elles n'ont pas changé. <br><br>  Cette conception n'est pas optimale pour les raisons suivantes: <br><br><ul><li>  Il dépense de précieuses ressources de trafic. </li><li>  Cela oblige l'utilisateur à attendre la fin d'une nouvelle demande. </li></ul><br>  Pour remédier à ces lacunes, nous ajoutons une nouvelle source de données à notre <code>UserRepository</code> , qui met en cache <code>User</code> objets <code>User</code> en mémoire: <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// Dagger,        . @Singleton class UserRepository @Inject constructor( private val webservice: Webservice, //    .    . private val userCache: UserCache ) { fun getUser(userId: String): LiveData&lt;User&gt; { val cached = userCache.get(userId) if (cached != null) { return cached } val data = MutableLiveData&lt;User&gt;() userCache.put(userId, data) //     ,  ,  . //      . webservice.getUser(userId).enqueue(object : Callback&lt;User&gt; { override fun onResponse(call: Call&lt;User&gt;, response: Response&lt;User&gt;) { data.value = response.body() } //     . override fun onFailure(call: Call&lt;User&gt;, t: Throwable) { TODO() } }) return data } }</span></span></code> </pre> <br><h3>  Données persistantes </h3><br>  En utilisant notre implémentation actuelle, si l'utilisateur fait pivoter l'appareil ou quitte et revient immédiatement à l'application, l'interface utilisateur existante devient immédiatement visible, car le magasin récupère les données de notre cache en mémoire. <br><br>  Cependant, que se passe-t-il si un utilisateur quitte l'application et revient quelques heures après la fin du processus sous Android OS?  En nous appuyant sur notre implémentation actuelle dans cette situation, nous devons à nouveau récupérer les données du réseau.  Ce processus de mise à niveau n'est pas seulement une mauvaise expérience utilisateur;  c'est aussi un gaspillage car il consomme de précieuses données mobiles. <br><br>  Vous pouvez résoudre ce problème en mettant en cache les demandes Web, mais cela crée un nouveau problème clé: que se passe-t-il si les mêmes données utilisateur sont affichées dans une demande d'un type différent, par exemple, lors de la réception d'une liste d'amis?  L'application affichera des données contradictoires, ce qui est au mieux déroutant.  Par exemple, notre application peut afficher deux versions différentes des données du même utilisateur si l'utilisateur a envoyé une demande de liste d'amis et une demande mono-utilisateur à des moments différents.  Notre application devrait comprendre comment combiner ces données contradictoires. <br><br>  La bonne façon de gérer cette situation est d'utiliser un modèle constant.  La bibliothèque de données permanentes (DB) de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pièce</a> vient à notre aide. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Room</a> est une bibliothèque de cartographie d'objets qui fournit un stockage de données local avec un code standard minimum.  Au moment de la compilation, il vérifie la conformité de chaque requête avec votre schéma de données, de sorte que les requêtes SQL qui ne fonctionnent pas entraînent des erreurs au moment de la compilation et non des blocages d'exécution.  Résumés de salle de certains détails de base de l'implémentation des tables et requêtes SQL brutes.  Il vous permet également d'observer les changements dans les données de base de données, y compris les collections et les demandes de connexion, exposant ces changements à l'aide d'objets LiveData.  Il définit même explicitement les contraintes d'exécution qui résolvent les problèmes de threads courants, tels que l'accès au stockage dans le thread principal. <br><br>  <i><b>Remarque</b></i>  <i>Si votre application utilise déjà une autre solution, telle que le mappage relationnel objet SQLite (ORM), vous n'avez pas besoin de remplacer la solution existante par Room.</i>  <i>Cependant, si vous écrivez une nouvelle application ou réorganisez une application existante, nous vous recommandons d'utiliser Room pour enregistrer vos données d'application.</i>  <i>Ainsi, vous pouvez profiter de l'abstraction de la bibliothèque et de la validation des requêtes.</i> <br><br>  Pour utiliser Room, nous devons définir notre disposition locale.  Tout d'abord, nous ajoutons l'annotation <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@Entity</a></code> à notre classe de modèle de données <code>User</code> et l'annotation <code>@PrimaryKey</code> dans le champ <code>id</code> la classe.  Ces annotations marquent l' <code>User</code> comme table dans notre base de données et <code>id</code> comme clé primaire de la table: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span></span>( <span class="hljs-meta"><span class="hljs-meta">@PrimaryKey</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: String, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String )</code> </pre> <br>  Ensuite, nous créons la classe de base de données en implémentant <code>RoomDatabase</code> pour notre application: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Database(entities = [User::class], version = 1)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserDatabase</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RoomDatabase</span></span></span></span>()</code> </pre> <br>  Notez que <code>UserDatabase</code> est abstrait.  La bibliothèque de salle fournit automatiquement une implémentation de cela.  Voir la documentation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Room</a> pour plus de détails. <br><br>  Nous avons maintenant besoin d'un moyen d'insérer des données utilisateur dans la base de données.  Pour cette tâche, nous créons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un objet d'accès aux données (DAO)</a> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Dao</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserDao</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Insert(onConflict = REPLACE)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-meta"><span class="hljs-meta">@Query(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SELECT * FROM user WHERE id = :userId"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(userId: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: LiveData&lt;User&gt; }</code> </pre> <br>  Notez que la méthode de <code>load</code> renvoie un objet de type LiveData.  La salle sait quand la base de données est modifiée et informe automatiquement tous les observateurs actifs des changements de données.  Puisque Room utilise <i>LiveData</i> , cette opération est efficace;  il met à jour les données uniquement s'il y a au moins un observateur actif. <br><br>  <i><b>Remarque: La</b> salle vérifie l'invalidation en fonction des modifications de la table, ce qui signifie qu'elle peut envoyer des notifications fausses positives.</i> <br><br>  Après avoir défini notre classe <code>UserDao</code> , nous référençons ensuite le DAO à partir de notre classe de base de données: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Database(entities = [User::class], version = 1)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserDatabase</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RoomDatabase</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">userDao</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: UserDao }</code> </pre> <br>  Nous pouvons maintenant modifier notre <code>UserRepository</code> d' <code>UserRepository</code> pour inclure la source de données de la salle: <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  Dagger,         . @Singleton class UserRepository @Inject constructor( private val webservice: Webservice, //    .    . private val executor: Executor, private val userDao: UserDao ) { fun getUser(userId: String): LiveData&lt;User&gt; { refreshUser(userId) //   LiveData    . return userDao.load(userId) } private fun refreshUser(userId: String) { //    . executor.execute { // ,      . val userExists = userDao.hasUser(FRESH_TIMEOUT) if (!userExists) { //  . val response = webservice.getUser(userId).execute() //    . //   .  LiveData  , //        . userDao.save(response.body()!!) } } } companion object { val FRESH_TIMEOUT = TimeUnit.DAYS.toMillis(1) } }</span></span></code> </pre> <br>  Veuillez noter que même si nous avons changé la source de données dans <code>UserRepository</code> , nous n'avons pas eu besoin de changer notre <code>UserProfileViewModel</code> ou <code>UserProfileFragment</code> .  Cette petite mise à jour démontre la flexibilité de notre architecture d'application.  Il est également idéal pour les tests car nous pouvons fournir un faux <code>UserRepository</code> et tester notre production <code>UserProfileViewModel</code> en même temps. <br><br>  Si les utilisateurs reviennent dans quelques jours, une application utilisant cette architecture est susceptible d'afficher des informations obsolètes jusqu'à ce que le référentiel reçoive des informations mises à jour.  Selon votre cas d'utilisation, vous pouvez ne pas afficher d'informations obsolètes.  Au lieu de cela, vous pouvez afficher <i>des</i> données d' <i>espace réservé</i> , qui affichent des valeurs fictives et indiquent que votre application télécharge et charge actuellement des informations à jour. <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La seule source de vérité.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En règle générale, différents points de terminaison de l'API REST renvoient les mêmes données. Par exemple, si notre backend a un autre point de terminaison qui renvoie une liste d'amis, le même objet utilisateur peut provenir de deux points de terminaison API différents, éventuellement même en utilisant différents niveaux de détail. Si nous </font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renvoyions la réponse de la demande </font></font><code>Webservice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">telle quelle, sans vérifier la cohérence, nos interfaces utilisateur pourraient afficher des informations confuses, car la version et le format des données du stockage dépendraient du dernier point de terminaison appelé. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour cette raison, notre implémentation </font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stocke les réponses des services Web dans une base de données. Les modifications apportées à la base de données déclenchent ensuite des rappels pour les objets </font><i><font style="vertical-align: inherit;">LiveData</font></i><font style="vertical-align: inherit;"> actifs</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En utilisant ce modèle, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la base de données est la seule source de vérité</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et d'autres parties de l'application y accèdent via la nôtre </font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Que vous utilisiez ou non un cache disque, nous recommandons que votre référentiel identifie la source de données comme la seule source de vérité pour le reste de votre application.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Afficher la progression de l'opération </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans certains cas d'utilisation, comme le pull-to-refresh, il est important que l'interface utilisateur montre à l'utilisateur qu'une opération réseau est en cours. </font><font style="vertical-align: inherit;">Il est recommandé de séparer l'action de l'interface utilisateur des données réelles, car les données peuvent être mises à jour pour diverses raisons. </font><font style="vertical-align: inherit;">Par exemple, si nous obtenons une liste d'amis, le même utilisateur peut être sélectionné à nouveau par programme, ce qui entraînera une mise à jour de LiveData. </font><font style="vertical-align: inherit;">Du point de vue de l'interface utilisateur, le fait d'avoir une requête en vol n'est qu'un autre point de données, similaire à n'importe quelle autre donnée dans l'objet lui-même </font></font><code>User</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous pouvons utiliser l'une des stratégies suivantes pour afficher l'état de mise à jour des données convenu dans l'interface utilisateur, indépendamment de l'origine de la demande de mise à jour des données: </font></font><br><br><ul><li>  <code>getUser ()</code> ,      <code>LiveData</code> .         .  ,   NetworkBoundResource   GitHub <a href="">android-Architecture-components</a> . </li><li>       <code>UserRepository</code> ,      .    ,              ,         ,   pull-to-refresh. </li></ul><br><h3>    </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la section sur la séparation des intérêts, nous avons mentionné que l'un des principaux avantages de suivre ce principe est la testabilité. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La liste suivante montre comment tester chaque module de code à partir de notre exemple étendu:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interface utilisateur et interaction</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : utilisez la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">boîte à outils de test de l'interface utilisateur Android</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">La meilleure façon de créer ce test est d'utiliser la bibliothèque </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espresso</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Vous pouvez créer un fragment et lui fournir une mise en page </font></font><code>UserProfileViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Étant donné que le fragment n'est associé qu'à </font></font><code>UserProfileViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la simulation </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(imitation) de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cette seule classe suffit pour tester complètement l'interface utilisateur de votre application.</font></font></li><li> <b>ViewModel:</b>     <code>UserProfileViewModel</code>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JUnit</a> .      , <code>UserRepository</code> . </li><li> <b>UserRepository:</b>     <code>UserRepository</code>    JUnit.    <code>Webservice</code>  <code>UserDao</code> .      : <br><br><ul><li>     -. </li><li>      . </li><li>     ,     . </li></ul><br></li><li>   <code>Webservice</code> ,  <code>UserDao</code>  ,             . </li><li> <b>UserDao:</b>   DAO    .       -   ,   .        ,  ,      ,        … <br><br> <i><b>:</b> Room     ,    DAO,   JSQL  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SupportSQLiteOpenHelper</a></b> .     ,      SQLite     SQLite   .</i> </li><li> <b>-:</b>         .   ,  -,      .  ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://github.com/square/ok">MockWebServer</a> ,          . </li><li> <b> :</b>     maven    .    <code>androidx.arch.core</code> :    JUnit: <br><br><ul><li> <code>InstantTaskExecutorRule:</code>            . </li><li> <code>CountingTaskExecutorRule:</code>         .        Espresso     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> . </li></ul><br></li></ul><br><h2>   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La programmation est un domaine créatif et la création d'applications Android ne fait pas exception. Il existe de nombreuses façons de résoudre le problème, qu'il s'agisse de transférer des données entre plusieurs actions ou fragments, de récupérer des données supprimées et de les stocker localement hors ligne, ou de nombreux autres scénarios courants rencontrés par des applications non triviales. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que les recommandations suivantes ne soient pas requises, notre expérience montre que leur implémentation rend votre base de code plus fiable, testable et prise en charge à long terme: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">évitez de désigner les points d'entrée de votre application - tels que les actions, les services et les récepteurs de diffusion - comme sources de données.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au lieu de cela, ils ont seulement besoin de se coordonner avec d'autres composants pour obtenir un sous-ensemble des données liées à ce point d'entrée. Chaque composant de l'application est assez éphémère, selon l'interaction de l'utilisateur avec son appareil et l'état général actuel du système. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Créez des lignes de responsabilité claires entre les différents modules de votre application.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Par exemple, ne distribuez pas de code qui télécharge des données du réseau vers plusieurs classes ou packages de votre base de code. De même, ne définissez pas plusieurs responsabilités non liées - telles que la mise en cache et la liaison de données - dans la même classe. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exposez le moins possible de chaque module.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Résistez à la tentation de créer une étiquette «juste un» qui révèle les détails d'une implémentation interne d'un module. Vous pouvez gagner du temps à court terme, mais vous encourrez alors une dette technique plusieurs fois à mesure que votre base de code se développera. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Réfléchissez à la façon de rendre chaque module testable de manière isolée.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Par exemple, avoir une API bien définie pour récupérer des données du réseau facilite le test d'un module qui stocke ces données dans une base de données locale. Si au contraire vous mélangez la logique de ces deux modules en un seul endroit ou distribuez votre code réseau à travers la base de code, le test devient beaucoup plus difficile - dans certains cas, même pas impossible. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Concentrez-vous sur le cœur unique de votre application pour vous démarquer des autres applications.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ne réinventez pas la roue en écrivant le même motif encore et encore. Au lieu de cela, concentrez votre temps et votre énergie sur ce qui rend votre application unique et laissez les composants de l'architecture Android et les autres bibliothèques recommandées faire face à un modèle répétitif. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conservez autant de données pertinentes et récentes que possible.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ainsi, les utilisateurs peuvent profiter des fonctionnalités de votre application, même si leur appareil est hors ligne. N'oubliez pas que tous vos utilisateurs n'utilisent pas une connexion haut débit constante. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Désignez une seule source de données comme seule véritable source.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chaque fois que votre application a besoin d'accéder à cette donnée, elle doit toujours provenir de cette seule source de vérité.</font></font><br><br><h3> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Addendum: divulgation de l'état du réseau</font></font></u> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la section ci-dessus de l'architecture d'application recommandée, nous avons ignoré les erreurs réseau et les états de démarrage pour simplifier les extraits de code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette section montre comment afficher l'état du réseau à l'aide de la classe Resource, qui encapsule à la fois les données et son état. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'extrait de code suivant fournit un exemple d'implémentation</font></font><code>Resource:</code> <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,         . sealed class Resource&lt;T&gt;( val data: T? = null, val message: String? = null ) { class Success&lt;T&gt;(data: T) : Resource&lt;T&gt;(data) class Loading&lt;T&gt;(data: T? = null) : Resource&lt;T&gt;(data) class Error&lt;T&gt;(message: String, data: T? = null) : Resource&lt;T&gt;(data, message) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étant donné que le téléchargement de données à partir du réseau lors de l'affichage d'une copie de ces données est une pratique courante, il est utile de créer une classe d'assistance qui peut être réutilisée à plusieurs endroits. Pour cet exemple, nous créons une classe avec le nom </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le diagramme suivant montre l'arbre de décision pour </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br><br><img src="https://habrastorage.org/webt/e1/wv/c9/e1wvc9un_w2t8jyi0kiky8wagw0.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il commence par observer la base de données de la ressource. Lorsqu'un enregistrement est téléchargé depuis la base de données pour la première fois, il </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vérifie si le résultat est suffisamment bon pour être envoyé ou s'il doit être récupéré sur le réseau. Veuillez noter que ces deux situations peuvent se produire simultanément, étant donné que vous souhaitez probablement afficher les données mises en cache lors de la mise à jour à partir du réseau.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si l'appel réseau réussit, il stocke la réponse dans la base de données et réinitialise le flux. En cas d' </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">échec </font><font style="vertical-align: inherit;">d'une demande de réseau </font><font style="vertical-align: inherit;">, il envoie l'échec directement. </font></font><br><br> <code><b>.</b>             .       ,       .</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gardez à l'esprit que compter sur une base de données pour envoyer des modifications implique l'utilisation d'effets secondaires associés, ce qui n'est pas très bon car le comportement indéfini de ces effets secondaires peut se produire si la base de données n'envoie pas les modifications car les données n'ont pas changé.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N'envoyez pas non plus les résultats reçus du réseau, car cela viole le principe d'une seule source de vérité. </font><font style="vertical-align: inherit;">Au final, il est possible que la base de données contienne des déclencheurs qui modifient les valeurs des données lors de l'opération de sauvegarde. </font><font style="vertical-align: inherit;">De même, n'envoyez pas «SUCCÈS» sans nouvelles données, car alors le client recevra la mauvaise version des données. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'extrait de code suivant montre l'API ouverte fournie par la classe </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour ses sous-classes:</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// ResultType:   . // RequestType:   API. abstract class NetworkBoundResource&lt;ResultType, RequestType&gt; { //      API   . @WorkerThread protected abstract fun saveCallResult(item: RequestType) //      ,  ,    //     . @MainThread protected abstract fun shouldFetch(data: ResultType?): Boolean //        . @MainThread protected abstract fun loadFromDb(): LiveData&lt;ResultType&gt; //     API. @MainThread protected abstract fun createCall(): LiveData&lt;ApiResponse&lt;RequestType&gt;&gt; // ,    .   //    ,    . protected open fun onFetchFailed() {} //   LiveData,  , //    . fun asLiveData(): LiveData&lt;ResultType&gt; = TODO() }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Faites attention aux détails importants suivants de la définition de classe: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il définit deux paramètres de type, </font></font><code>ResultType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>RequestType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puisque le type de données renvoyé par l'API peut ne pas correspondre au type de données utilisé localement.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il utilise une classe </font></font><code>ApiResponse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour les requêtes réseau. </font></font><code>ApiResponse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Est un simple wrapper pour une classe </font></font><code>Retrofit2.Call</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui convertit les réponses en instances </font></font><code>LiveData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'implémentation complète de la classe </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apparaît dans le cadre du projet </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub android-Architecture-components</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une fois créé, </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous pouvons l'utiliser pour écrire nos implémentations de disque et de réseau </font></font><code>User</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans la classe </font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  Dagger2,         . @Singleton class UserRepository @Inject constructor( private val webservice: Webservice, private val userDao: UserDao ) { fun getUser(userId: String): LiveData&lt;User&gt; { return object : NetworkBoundResource&lt;User, User&gt;() { override fun saveCallResult(item: User) { userDao.save(item) } override fun shouldFetch(data: User?): Boolean { return rateLimiter.canFetch(userId) &amp;&amp; (data == null || !isFresh(data)) } override fun loadFromDb(): LiveData&lt;User&gt; { return userDao.load(userId) } override fun createCall(): LiveData&lt;ApiResponse&lt;User&gt;&gt; { return webservice.getUser(userId) } }.asLiveData() } }</span></span></code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr456256/">https://habr.com/ru/post/fr456256/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr456240/index.html">Développement de chatbot (laravel + botman)</a></li>
<li><a href="../fr456242/index.html">Un peu plus sur le multitâche dans les microcontrôleurs</a></li>
<li><a href="../fr456246/index.html">Élément zéro</a></li>
<li><a href="../fr456248/index.html">Comment j'ai attrapé: avant les styles pour un élément de focus</a></li>
<li><a href="../fr456250/index.html">Localisation d'applications et prise en charge RTL. Signaler Yandex.Taxi</a></li>
<li><a href="../fr456258/index.html">Free as a wind et free as a beer traduction de «Free as in Freedom» en russe sous la licence GNU FDL 1.3</a></li>
<li><a href="../fr456260/index.html">Discussion sur l'économie équitable</a></li>
<li><a href="../fr456262/index.html">Radio définie par logiciel - comment ça marche? Partie 9</a></li>
<li><a href="../fr456264/index.html">Créez des fichiers binaires Android à l'aide de la source et d'Android NDK. Nous pompons l'utilitaire screencap</a></li>
<li><a href="../fr456266/index.html">Le condensé de matériaux intéressants pour le développeur mobile # 302 (du 10 au 16 juin)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>