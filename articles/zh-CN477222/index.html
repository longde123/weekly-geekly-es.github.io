<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛌🏾 🔬 🧝 公式和惰性组合器 👫 🗨️ 🌿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="公式库 
 在金融科技领域，我们经常需要验证是否满足简单的算术条件，例如，汇率是否大于预期值。 这些条件经常变化，我们需要发明一种自行车，以便添加新检查并实时执行现有检查。 想象一下，当某些货币对的汇率达到2：1的比例时，数千客户希望收到通知。 如果我们只能使条件静态，那将是非常简单的： 



d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>公式和惰性组合器</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477222/"><h3> 公式库 </h3><br> 在金融科技领域，我们经常需要验证是否满足简单的算术条件，例如，汇率是否大于预期值。 这些条件经常变化，我们需要发明一种自行车，以便添加新检查并实时执行现有检查。 想象一下，当某些货币对的汇率达到2：1的比例时，数千客户希望收到通知。 如果我们只能使条件静态，那将是非常简单的： <br><br><pre><code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">notify?</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> rate &gt; <span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">do:</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">notify?</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>, <span class="hljs-symbol"><span class="hljs-symbol">do:</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br> 我们允许客户动态添加此类支票。 因此，我们需要一种或多或少可靠的机制来检查刚刚添加的条件。 <br><a name="habracut"></a><br> 是的， <a href="https://hexdocs.pm/elixir/master/Code.html" rel="nofollow"><code>Code.eval_string/3</code></a>以某种方式可以工作，但是它在实际检查之前的每个该死的时间都会编译条件。 显然，这无缘无故浪费资源。 我们每秒接收和处理大约10,000门不同货币对的课程，这使情况更加复杂。 <br><br> 因此，我们提出了预编译的公式。 微小的<a href="https://hexdocs.pm/formulae/Formulae.html" rel="nofollow"><code>formulae</code></a>库为每个给定条件创建一个模块，并将用户输入的公式编译为代码-一次。 <br><br>  <b>NB</b>库应谨慎使用，因为模块名称以原子的形式存储，并且它们盲目无条件地创建客户端要检查的所有内容可能会导致对Erlang虚拟机的原子DoS攻击，执行时间或多或少。 我们使用的最大允许步长为<code>0.01</code> ，在最坏的情况下，该步长最多为20万个原子。 <br><br><h3> 懒惰组合器 </h3><br> 但是，本文的主要目的不是讨论预编译公式。 对于汇率分析的一些极端情况，我们需要计算相当长的列表的排列。 突然，Elixir标准库没有提供交钥匙解决方案。 好吧，我决定从Ruby（ <a href="https://ruby-doc.org/core/Array.html" rel="nofollow"><code>Array#combination</code></a>和表亲）复制组合签名。 不幸的是，对于长列表而言，这并非易事。 组合停滞在列表中的三十个元素的区域中，排列甚至更早。 <br><br> 好吧，预计已经在这里了； 所以我开始使用Stream玩懒惰的实现。 事实证明，这并不像我想的那么容易。 我想出了类似下面的代码 <br><br><pre> <code class="ruby hljs">list = ~w[abcde]a combinations = Stream.transform(Stream.with_index(list), <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>, fn {i1, idx1}, <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span> -&gt; {Stream.transform(Stream.with_index(list), <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>, fn {<span class="hljs-number"><span class="hljs-number">_</span></span>, idx2}, <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> idx2 &lt;= idx1 -&gt; {[], <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>} {i2, idx2}, <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span> -&gt; {Stream.transform(Stream.with_index(list), <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>, fn {<span class="hljs-number"><span class="hljs-number">_</span></span>, idx3}, <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> idx3 &lt;= idx2 -&gt; {[], <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>} {i3, idx3}, <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span> -&gt; {Stream.transform(Stream.with_index(list), <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>, fn {<span class="hljs-number"><span class="hljs-number">_</span></span>, idx4}, <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> idx4 &lt;= idx3 -&gt; {[], <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>} {i4, _idx4}, <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span> -&gt; {[[i1, i2, i3, i4]], <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>), <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>), <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>), <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)</code> </pre><br> 这有效，但仅适用于已知数量的组合。 好吧，这很容易克服：在这种情况下，我们有宏，对吗？ <br><br> 在上面的代码中，查看了三种不同的模式。 从中删除列表的成功分支。 快速弹出一个空列表。 并用索引转换流量。 看来我们可以尝试针对上述内容创建AST。 <br><br> 在使用<a href="https://hexdocs.pm/elixir/master/Kernel.SpecialForms.html%3F" rel="nofollow"><code>Kernel.SpecialForms.quote/2</code></a>时，这种情况很少见，只会使事情复杂化，因此我采取了阻力最小的方法：我们将雕刻好的老式裸AST。 <br><br> 我首先在代码中的控制台中调用<code>quote do:</code>并检查了结果。 是的，有模式。 好吧，走吧。 <br><br> 因此，您需要先创建一个通用框架。 <br><br><pre> <code class="ruby hljs">defmacrop mapper(from, to, fun), <span class="hljs-symbol"><span class="hljs-symbol">do:</span></span> quote(<span class="hljs-symbol"><span class="hljs-symbol">do:</span></span> Enum.map(Range.new(unquote(from), unquote(to)), unquote(fun))) @spec combinations(list <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: list(), count <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: non_neg_integer()) <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: {Stream.t(), <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>} defmacro combinations(l, n) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Enum.reduce(n..<span class="hljs-number"><span class="hljs-number">1</span></span>, {[mapper(<span class="hljs-number"><span class="hljs-number">1</span></span>, n, &amp;var/<span class="hljs-number"><span class="hljs-number">1</span></span>)], <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>}, fn i, body -&gt; stream_combination_transform_clause(i, l, body) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br> 现在，我们需要开始考虑的不是代码，而是AST，以了解重复的模板部分。 很好玩！ <br><br> 让我们从帮助程序宏开始以简化代码： <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">var</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span></span>, <span class="hljs-symbol"><span class="hljs-symbol">do:</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:</span><span class="hljs-string"><span class="hljs-symbol"><span class="hljs-string">"i_</span></span><span class="hljs-subst"><span class="hljs-symbol"><span class="hljs-string"><span class="hljs-subst">#{i}</span></span></span></span><span class="hljs-symbol"><span class="hljs-string">"</span></span></span></span>, [], Elixir} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">idx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span></span>, <span class="hljs-symbol"><span class="hljs-symbol">do:</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:</span><span class="hljs-string"><span class="hljs-symbol"><span class="hljs-string">"idx_</span></span><span class="hljs-subst"><span class="hljs-symbol"><span class="hljs-string"><span class="hljs-subst">#{i}</span></span></span></span><span class="hljs-symbol"><span class="hljs-string">"</span></span></span></span>, [], Elixir}</code> </pre><br>  AST内件从一般角度撕裂： <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sink_combination_clause</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> i &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:-&gt;</span></span>, [], [ [ {<span class="hljs-symbol"><span class="hljs-symbol">:when</span></span>, [], [ {​{<span class="hljs-symbol"><span class="hljs-symbol">:_</span></span>, [], Elixir}, idx(i)}, <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>, {<span class="hljs-symbol"><span class="hljs-symbol">:&lt;=</span></span>, [<span class="hljs-symbol"><span class="hljs-symbol">context:</span></span> Elixir, <span class="hljs-symbol"><span class="hljs-symbol">import:</span></span> Kernel], [idx(i), idx(i - <span class="hljs-number"><span class="hljs-number">1</span></span>)]} ]} ], {[], <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>} ]} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br> 所有内部片段在一起： <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sink_combination_clauses</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, body)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> [{<span class="hljs-symbol"><span class="hljs-symbol">:-&gt;</span></span>, [], [[{var(<span class="hljs-number"><span class="hljs-number">1</span></span>), idx(<span class="hljs-number"><span class="hljs-number">1</span></span>)}, <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>], body]}] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sink_combination_clauses</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, body)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> i &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Enum.reverse([ {<span class="hljs-symbol"><span class="hljs-symbol">:-&gt;</span></span>, [], [[{var(i), idx(i)}, <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>], body]} <span class="hljs-params"><span class="hljs-params">| Enum.map(2..i, &amp;sink_combination_clause/1) ]) </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">end</span></span></span></span></code> </pre><br> 最后，围绕着它的所有外包装。 <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stream_combination_transform_clause</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, l, body)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> clauses = sink_combination_clauses(i, body) {​{​{<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>., [], [{<span class="hljs-symbol"><span class="hljs-symbol">:__aliases__</span></span>, [<span class="hljs-symbol"><span class="hljs-symbol">alias:</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>], [<span class="hljs-symbol"><span class="hljs-symbol">:Stream</span></span>]}, <span class="hljs-symbol"><span class="hljs-symbol">:transform</span></span>]}, [], [ {​{<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>., [], [{<span class="hljs-symbol"><span class="hljs-symbol">:__aliases__</span></span>, [<span class="hljs-symbol"><span class="hljs-symbol">alias:</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>], [<span class="hljs-symbol"><span class="hljs-symbol">:Stream</span></span>]}, <span class="hljs-symbol"><span class="hljs-symbol">:with_index</span></span>]}, [], [l]}, <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>, {<span class="hljs-symbol"><span class="hljs-symbol">:fn</span></span>, [], clauses} ]}, <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br> 所有排列几乎相同地执行，唯一的变化是内部调用中的条件。 很简单，对吧？ 可以<a href="" rel="nofollow">在存储库中</a>查看所有代码。 <br><br><h3> 应用程式 </h3><br> 好，那么我们该如何使用这种美丽？ 好吧，像这样： <br><br><pre> <code class="ruby hljs">l = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c &lt;- <span class="hljs-string"><span class="hljs-string">?a</span></span>..<span class="hljs-string"><span class="hljs-string">?z</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">do:</span></span> &lt;&lt;c<span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span><span class="hljs-comment"><span class="hljs-comment"># letters list with {stream, :ok} &lt;- Formulae.Combinators.Stream.permutations(l, 12), do: stream |&gt; Stream.take_every(26) |&gt; Enum.take(2) #⇒ [["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l"], # ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "l", "w"]]</span></span></code> </pre><br> 现在，我们甚至可以直接从此流中馈送<a href="https://hexdocs.pm/flow/" rel="nofollow"><code>Flow</code></a>以并行化计算。 是的，它仍然是缓慢而悲伤的，但是幸运的是，该任务不是实时的，而是针对可以在夜间运行的分析，它将缓慢地浏览所有组合并在某个位置写下结果。 <br><br> 如果您对Elixir中的AST有疑问-问，我在上面吃了一只狗。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN477222/">https://habr.com/ru/post/zh-CN477222/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN477204/index.html">在营销中使用人工智能：让我们进入客户的视野</a></li>
<li><a href="../zh-CN477206/index.html">预测需求，CC负载，产品推荐和发现异常的时间序列</a></li>
<li><a href="../zh-CN477208/index.html">英特尔邀请参加OpenVINO黑客马拉松，奖池-18万卢布</a></li>
<li><a href="../zh-CN477210/index.html">我的哭泣Yaroslavna</a></li>
<li><a href="../zh-CN477214/index.html">Angular上的应用程序配置。 最佳实务</a></li>
<li><a href="../zh-CN477224/index.html">“消灭噪音”：您需要了解的有关噪声污染的信息</a></li>
<li><a href="../zh-CN477226/index.html">在简单与正确之间选择</a></li>
<li><a href="../zh-CN477228/index.html">Vue 3将变得更快</a></li>
<li><a href="../zh-CN477230/index.html">教育软件的历史：第一款个人计算机，教育游戏和学生软件</a></li>
<li><a href="../zh-CN477234/index.html">终结电线兄弟的老鼠</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>