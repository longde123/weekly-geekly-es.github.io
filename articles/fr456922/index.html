<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèæ ü•ü üë©üèø‚Äçüé§ Comment les processeurs sont con√ßus et fabriqu√©s: les bases de l'architecture informatique üë©‚Äçüëß üÜò üßëüèø‚Äçü§ù‚Äçüßëüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous percevons le processeur central comme le ¬´cerveau¬ª d'un ordinateur, mais qu'est-ce que cela signifie vraiment? Que se passe-t-il exactement √† l'i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment les processeurs sont con√ßus et fabriqu√©s: les bases de l'architecture informatique</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456922/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/772/582/2e1/7725822e1e2ef8975b16770b48a0e199.jpg" alt="image"></div><br>  Nous percevons le processeur central comme le ¬´cerveau¬ª d'un ordinateur, mais qu'est-ce que cela signifie vraiment?  Que se passe-t-il exactement √† l'int√©rieur des milliards de transistors qui font fonctionner un ordinateur?  Dans notre nouvelle mini-s√©rie de quatre articles, nous examinerons le processus de cr√©ation de l'architecture du mat√©riel informatique et parlerons des principes de son fonctionnement. <br><br>  Dans cette s√©rie, nous parlerons de l'architecture informatique, de la conception de cartes processeur, de la VLSI (int√©gration √† tr√®s grande √©chelle), de la fabrication de puces et des tendances futures dans le domaine de la technologie informatique.  Si vous vouliez comprendre les d√©tails des processeurs, il est pr√©f√©rable de commencer l'√©tude avec cette s√©rie d'articles. <br><br>  Nous commencerons par une explication de tr√®s haut niveau de ce que fait le processeur et de la fa√ßon dont les blocs de construction se connectent √† une structure fonctionnelle.  En particulier, nous prendrons en compte les c≈ìurs de processeur, la hi√©rarchie de la m√©moire, la pr√©diction de branche, etc.  Tout d'abord, nous devons donner une d√©finition simple de ce que fait le CPU.  L'explication la plus simple: le processeur suit un ensemble d'instructions pour effectuer une certaine op√©ration sur un grand nombre de donn√©es entrantes.  Par exemple, il peut √™tre en train de lire une valeur dans la m√©moire, puis de l'ajouter √† une autre valeur, et enfin d'enregistrer le r√©sultat en m√©moire √† une adresse diff√©rente.  Cela peut √™tre quelque chose de plus compliqu√©, par exemple, la division de deux nombres, si le r√©sultat du calcul pr√©c√©dent est sup√©rieur √† z√©ro. <br><br>  Les programmes, comme un syst√®me d'exploitation ou un jeu, sont eux-m√™mes des s√©quences d'instructions que le CPU doit ex√©cuter.  Ces instructions sont charg√©es √† partir de la m√©moire et ex√©cut√©es l'une apr√®s l'autre dans un simple processeur jusqu'√† la fin du programme.  Les d√©veloppeurs de logiciels √©crivent des programmes dans des langages de haut niveau, tels que C ++ ou Python, mais le processeur ne peut pas les comprendre.  Il ne comprend que les uns et les z√©ros, nous devons donc en quelque sorte repr√©senter le code dans ce format. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/095/9ea/109/0959ea1090226766b43f20c46c8ed6d1.png"></div><br>  Les programmes sont compil√©s dans un ensemble d'instructions de bas niveau appel√© <em>langage d'assemblage</em> , qui fait partie de l'architecture du jeu d'instructions (ISA).  Il s'agit d'un ensemble d'instructions que le CPU doit comprendre et ex√©cuter.  Certains des ISA les plus courants sont x86, MIPS, ARM, RISC-V et PowerPC.  De la m√™me mani√®re que la syntaxe pour √©crire une fonction en C ++ diff√®re de la fonction qui effectue la m√™me action en Python, chaque ISA a sa propre syntaxe diff√©rente. <br><br>  Ces normes ISA peuvent √™tre divis√©es en deux cat√©gories principales: de longueur fixe et variable.  ISA RISC-V utilise des instructions de longueur fixe, ce qui signifie qu'un nombre pr√©d√©termin√© de bits dans chaque instruction d√©termine le type de l'instruction.  En x86, tout est diff√©rent, il utilise des instructions de longueur variable.  Dans x86, les instructions peuvent √™tre encod√©es de diff√©rentes mani√®res avec diff√©rents nombres de bits pour diff√©rentes parties.  En raison de cette complexit√©, le d√©codeur d'instructions du processeur x86 est g√©n√©ralement la partie la plus complexe de l'ensemble du p√©riph√©rique. <br><br>  Les instructions de longueur fixe permettent un d√©codage simple en raison d'une structure constante, mais limitent le nombre total d'instructions pouvant √™tre prises en charge par ISA.  Alors que les versions populaires de l'architecture RISC-V contiennent environ 100 instructions et qu'elles sont toutes open source, l'architecture x86 est propri√©taire et personne ne sait combien d'instructions elle contient.  On pense g√©n√©ralement qu'il existe plusieurs milliers d'instructions x86, mais personne ne publie le nombre exact.  Malgr√© les diff√©rences entre les ISA, ils ont en fait tous les m√™mes fonctionnalit√©s de base. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acc/0a8/074/acc0a807407b41b94459d8202b0c6b4e.png"></div><br>  <i>Un exemple de quelques instructions RISC-V.</i>  <i>L'opcode de droite fait 7 bits et d√©termine le type d'instruction.</i>  <i>De plus, chaque instruction contient des bits qui d√©finissent les registres utilis√©s et les fonctions ex√©cut√©es.</i>  <i>Les instructions de l'assembleur sont donc divis√©es en code binaire afin que le processeur les comprenne.</i> <br><br>  Nous sommes maintenant pr√™ts √† allumer l'ordinateur et √† d√©marrer l'ex√©cution des programmes.  L'ex√©cution de l'instruction comporte plusieurs parties de base, qui sont divis√©es en plusieurs √©tapes du processeur. <br><br>  La premi√®re √©tape est le transfert des instructions de la m√©moire au processeur pour d√©marrer l'ex√©cution.  Dans la deuxi√®me √©tape, l'instruction est d√©cod√©e afin que le CPU puisse comprendre de quel type d'instruction il s'agit.  Il existe de nombreux types, notamment les instructions arithm√©tiques, les instructions de branchement et les instructions de m√©moire.  Une fois que la CPU a d√©couvert le type d'instruction qu'elle ex√©cute, les op√©randes de l'instruction sont extraits de la m√©moire ou des registres internes de la CPU.  Si vous souhaitez ajouter le nombre A et le nombre B, vous ne pouvez pas ajouter tant que vous ne connaissez pas les valeurs de A et B. La plupart des processeurs modernes sont 64 bits, c'est-√†-dire que la taille de chaque valeur de donn√©es est de 64 bits. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/105/5cd/f55/1055cdf5560f78a1bbe61b6acbfb4d4d.png"></div><br>  <i>64 bits est la largeur du registre du processeur, du canal de donn√©es et / ou de l'adresse m√©moire.</i>  <i>Pour les utilisateurs ordinaires, cela signifie la quantit√© d'informations qu'un ordinateur peut traiter √† la fois, et cela est mieux compris par rapport √† un parent d'architecture plus jeune - un processeur 32 bits.</i>  <i>L'architecture 64 bits peut traiter deux fois plus de bits d'informations √† la fois (64 bits contre 32).</i> <br><br>  Apr√®s avoir re√ßu les op√©randes pour l'instruction, le processeur les transf√®re √† l'√©tape d'ex√©cution, o√π l'op√©ration est effectu√©e sur les donn√©es entrantes.  Cela peut √™tre l'ajout de nombres, l'ex√©cution de manipulations logiques avec des nombres ou simplement la transmission de nombres sans les modifier.  Apr√®s avoir calcul√© le r√©sultat, un acc√®s √† la m√©moire peut √™tre n√©cessaire pour le stocker, ou le processeur peut simplement stocker la valeur dans l'un de ses registres internes.  Apr√®s avoir enregistr√© le r√©sultat, la CPU met √† jour l'√©tat des diff√©rents √©l√©ments et passe √† l'instruction suivante. <br><br>  Cette explication, bien s√ªr, est grandement simplifi√©e, et la plupart des processeurs modernes divisent ces plusieurs √©tapes en 20 ou m√™me plus petites √©tapes pour augmenter l'efficacit√©.  Cela signifie que bien que le processeur d√©marre et se termine avec plusieurs instructions √† chaque cycle, l'ex√©cution d'une instruction du d√©but √† la fin peut prendre 20 cycles ou plus.  Un tel mod√®le est g√©n√©ralement appel√© pipeline ("pipeline", g√©n√©ralement traduit en russe par "convoyeur"), car il faut du temps pour remplir le pipeline de liquide et terminer son passage, mais apr√®s le remplissage, le d√©bit (sortie de donn√©es) sera constant. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f4/94c/b7f/5f494cb7fea80ae36c741da698beb07c.png"></div><br>  <i>Un exemple de convoyeur √† 4 √©tages.</i>  <i>Les rectangles multicolores indiquent des instructions ind√©pendantes les unes des autres.</i> <br><br>  Le cycle complet de l'instruction est un processus tr√®s soigneusement coordonn√©, mais toutes les instructions ne peuvent pas √™tre ex√©cut√©es en m√™me temps.  Par exemple, l'ajout est tr√®s rapide et la division ou le chargement √† partir de la m√©moire peut prendre des milliers de cycles.  Au lieu d'arr√™ter l'int√©gralit√© du processeur jusqu'√† la fin d'une instruction lente, la plupart des processeurs modernes les ex√©cutent avec un changement dans l'ordre.  Autrement dit, ils d√©terminent laquelle des instructions est la plus avantageuse √† ex√©cuter pour le moment et tamponnent les autres instructions qui ne sont pas encore pr√™tes.  Si l'instruction en cours n'est pas encore pr√™te, le processeur peut avancer dans le code pour voir si quelque chose d'autre est pr√™t. <br><br>  En plus de s'ex√©cuter avec une s√©quence de changements, les processeurs modernes utilisent une technologie appel√©e <em>architecture superscalaire</em> .  Cela signifie qu'√† tout moment, le processeur ex√©cute simultan√©ment un grand nombre d'instructions √† chaque √©tape du pipeline.  Il peut √©galement s'attendre √† ce que des centaines d'autres d√©marrent leur ex√©cution, et afin de pouvoir ex√©cuter plusieurs instructions simultan√©ment √† l'int√©rieur des processeurs, il existe plusieurs copies de chaque √©tape du pipeline.  Si le processeur voit que deux instructions sont pr√™tes √† √™tre ex√©cut√©es et qu'il n'y a aucune d√©pendance entre elles, il n'attend pas qu'elles soient termin√©es s√©par√©ment, mais les ex√©cute simultan√©ment.  Une impl√©mentation populaire de cette architecture est appel√©e multithreading simultan√© (SMT) et est √©galement appel√©e Hyper-Threading.  Les processeurs Intel et AMD prennent d√©sormais en charge les SMT double face, tandis qu'IBM a d√©velopp√© des puces qui prennent en charge jusqu'√† huit SMT. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/279/f3d/7ff/279f3d7fffe891e166b1a4547223363c.png"></div><br>  Pour terminer cette ex√©cution soigneusement coordonn√©e, le processeur, en plus du noyau de base, poss√®de de nombreux √©l√©ments suppl√©mentaires.  Le processeur poss√®de des centaines de modules distincts, chacun ayant une fonction sp√©cifique, mais nous ne consid√©rerons que les bases.  Les plus importants et les plus rentables sont les caches et le pr√©dicteur des transitions.  Il y a d'autres structures suppl√©mentaires que nous ne consid√©rerons pas: r√©organiser les tampons, enregistrer les tables renomm√©es et les stations de sauvegarde. <br><br>  Le besoin de caches peut parfois pr√™ter √† confusion, car ils stockent des donn√©es, comme la RAM ou le SSD.  Mais les caches diff√®rent en termes de latence et de vitesse d'acc√®s.  M√™me si la m√©moire RAM est extr√™mement rapide, elle est beaucoup plus lente que ce dont le CPU a besoin.  Des centaines de cycles peuvent √™tre n√©cessaires pour r√©pondre avec le transfert de donn√©es RAM, et le processeur n'aura rien √† faire pour le moment.  Et s'il n'y a pas de donn√©es dans la RAM, cela peut prendre des dizaines de milliers de cycles pour y acc√©der depuis le SSD.  Sans caches, les processeurs s'arr√™teraient constamment. <br><br>  Les processeurs ont g√©n√©ralement trois niveaux de cache qui composent la soi-disant <em>hi√©rarchie de la m√©moire</em> .  Le cache L1 est le plus petit et le plus rapide, L2 est au milieu et L3 est le plus grand et le plus lent de tous les caches.  Au-dessus des caches de la hi√©rarchie se trouvent de petits registres qui stockent la seule valeur de donn√©es lors des calculs.  Par ordre de grandeur, ces registres sont les p√©riph√©riques de stockage les plus rapides du syst√®me.  Lorsque le compilateur convertit un programme de haut niveau en langage assembleur, il d√©termine la meilleure fa√ßon d'utiliser ces registres. <br><br>  Lorsque le CPU demande des donn√©es √† la m√©moire, il v√©rifie d'abord si ces donn√©es sont d√©j√† stock√©es dans le cache L1.  Si c'est le cas, vous pouvez y acc√©der en quelques cycles seulement.  S'ils ne sont pas l√†, le processeur v√©rifie L2, puis le cache L3.  Les caches sont impl√©ment√©s de telle mani√®re qu'en g√©n√©ral, ils sont transparents pour le noyau.  Le noyau demande simplement des donn√©es √† l'adresse m√©moire sp√©cifi√©e, et le niveau dans la hi√©rarchie auquel il existe y r√©pond.  Lors du passage √† des niveaux ult√©rieurs dans la hi√©rarchie de la m√©moire, la taille et les retards augmentent g√©n√©ralement de plusieurs ordres de grandeur.  En fin de compte, si le CPU ne trouve pas de donn√©es dans l'un des caches, il acc√®de √† la m√©moire principale (RAM). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36a/bfa/d08/36abfad0814a507d82b857f0de29b96e.png"></div><br>  Dans un processeur standard, chaque c≈ìur poss√®de deux caches L1: un pour les donn√©es et un pour les instructions.  Les caches L1 ont g√©n√©ralement une capacit√© totale d'environ 100 kilo-octets et la taille varie consid√©rablement en fonction de la g√©n√©ration de la puce et du processeur.  De plus, chaque c≈ìur poss√®de g√©n√©ralement son propre cache L2, bien que dans certaines architectures, il puisse √™tre commun √† deux c≈ìurs.  Les caches L2 mesurent g√©n√©ralement plusieurs centaines de kilo-octets.  Enfin, il existe un seul cache L3 commun √† tous les c≈ìurs, avec une taille de l'ordre de dizaines de m√©gaoctets. <br><br>  Lorsque le processeur ex√©cute le code, les instructions et les valeurs de donn√©es les plus fr√©quemment utilis√©es sont mises en cache.  Cela acc√©l√®re consid√©rablement l'ex√©cution, car le processeur n'a pas besoin d'aller constamment dans la m√©moire principale pour les donn√©es n√©cessaires.  Dans les deuxi√®me et troisi√®me parties de la s√©rie, nous parlerons davantage de la fa√ßon dont ces syst√®mes de m√©moire sont mis en ≈ìuvre. <br><br>  En plus des caches, l'un des blocs de construction les plus importants d'un processeur moderne est un <em>pr√©dicteur de transition</em> pr√©cis.  Les instructions de transition (branchement) sont similaires aux constructions if pour le processeur.  Un ensemble d'instructions est ex√©cut√© si la condition est vraie et l'autre si elle est fausse.  Par exemple, nous devons comparer deux nombres, et s'ils sont √©gaux, effectuer une fonction, et s'ils ne sont pas √©gaux, en effectuer une autre.  Ces instructions de branchement sont extr√™mement courantes et peuvent repr√©senter environ 20% de toutes les instructions d'un programme. <br><br>  √Ä premi√®re vue, il semble que ces instructions de branchement ne devraient pas poser de probl√®mes, mais leur bonne ex√©cution peut √™tre tr√®s difficile pour le processeur.  √Ä tout moment, le processeur peut √™tre en train d'ex√©cuter simultan√©ment dix ou vingt instructions, il est donc tr√®s important de savoir <em>quelles</em> instructions ex√©cuter.  Il peut falloir 5 cycles pour d√©terminer que l'instruction en cours est une transition et 10 autres cycles pour d√©terminer si la condition est vraie.  √Ä ce stade, le processeur peut d√©j√† commencer √† ex√©cuter des dizaines d'instructions suppl√©mentaires, sans m√™me savoir si ces instructions conviennent vraiment √† l'ex√©cution. <br><br>  Pour contourner ce probl√®me, tous les processeurs hautes performances modernes utilisent une technique appel√©e sp√©culation.  Cela signifie que le processeur garde une trace des instructions de branchement et se demande si la branche conditionnelle sera ex√©cut√©e ou non.  Si la pr√©diction est correcte, le processeur a d√©j√† commenc√© √† ex√©cuter les instructions suivantes, ce qui augmente les performances.  Si la pr√©diction est incorrecte, le processeur arr√™te l'ex√©cution, supprime toutes les instructions incorrectes qu'il a commenc√© √† ex√©cuter et red√©marre √† partir du point correct. <br><br>  Ces pr√©dicteurs de branche font partie des types les plus simples d'apprentissage automatique car le pr√©dicteur √©tudie le comportement des branches lors de l'ex√©cution.  S'il pr√©dit trop souvent incorrectement, il commence √† apprendre le bon comportement.  Des d√©cennies de recherche sur les techniques de pr√©diction de transition ont abouti √† une pr√©cision de pr√©diction de plus de 90% dans les processeurs modernes. <br><br>  Bien que l'anticipation offre une √©norme augmentation des performances, car le processeur peut ex√©cuter des instructions qui sont d√©j√† pr√™tes, au lieu d'attendre dans la file d'attente l'ex√©cution, il cr√©e √©galement des failles de s√©curit√©.  La c√©l√®bre attaque Spectre exploite des bogues pour pr√©voir et anticiper les transitions.  L'attaquant utilise du code sp√©cialement s√©lectionn√© pour forcer le processeur √† ex√©cuter le code de mani√®re proactive, ce qui entra√Æne une fuite de valeurs de la m√©moire.  Pour √©viter les fuites de donn√©es, il a fallu refaire la conception de certains aspects de l'anticipation, ce qui a entra√Æn√© une l√©g√®re baisse des performances. <br><br>  Au cours des derni√®res d√©cennies, l'architecture utilis√©e dans les processeurs modernes a parcouru un long chemin.  L'innovation et le d√©veloppement d'une structure bien pens√©e ont conduit √† une productivit√© accrue et √† une utilisation plus optimale du mat√©riel.  Cependant, les d√©veloppeurs des processeurs centraux gardent soigneusement les secrets de leurs technologies, nous ne pouvons donc pas savoir exactement ce qui se passe √† l'int√©rieur d'eux.  Cependant, les principes fondamentaux des processeurs sont standardis√©s pour toutes les architectures et mod√®les.  Intel peut ajouter ses ingr√©dients secrets pour augmenter la part des acc√®s au cache, et AMD peut ajouter un pr√©dicteur de transition am√©lior√©, mais les processeurs des deux soci√©t√©s effectuent la m√™me t√¢che. <br><br>  Dans ce premier aper√ßu et examen, nous avons couvert les bases du fonctionnement des processeurs.  Dans la partie suivante, nous vous expliquerons comment d√©velopper les composants qui composent les processeurs, parlerons des √©l√©ments logiques, des fr√©quences d'horloge, de la gestion de l'alimentation, des circuits, etc. <br><br><h5>  Lecture recommand√©e </h5><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'histoire du microprocesseur et de l'ordinateur personnel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Technologie d'affichage compar√©e: TN vs</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">VA vs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IPS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4GHz CPU Battle: AMD 2e g√©n√©ration Ryzen vs</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Intel 8e g√©n√©ration Core</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Qu'est-ce que la limitation thermique et comment la pr√©venir</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr456922/">https://habr.com/ru/post/fr456922/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr456904/index.html">Test de charge d'un projet Web - pas d'argent</a></li>
<li><a href="../fr456908/index.html">Comment Telegram vous fusionne avec Rostelecom</a></li>
<li><a href="../fr456910/index.html">Internet project security.txt - apprendre √† conna√Ætre un autre fichier bien connu</a></li>
<li><a href="../fr456912/index.html">Comment cr√©er des sites en 2019</a></li>
<li><a href="../fr456920/index.html">Sony Xperia 1 en Russie - prix et bonus de pr√©commande</a></li>
<li><a href="../fr456926/index.html">Comment nous faisons Sportmaster</a></li>
<li><a href="../fr456928/index.html">JMeter - Swiss Tester Knife (Partie 1)</a></li>
<li><a href="../fr456930/index.html">Amener l'IoT √† la masse: r√©sultats du premier hackathon IoT de GeekBrains et Rostelecom</a></li>
<li><a href="../fr456932/index.html">OpenGL ultramoderne. Partie 1</a></li>
<li><a href="../fr456936/index.html">Cartes anim√©es sur SwiftUI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>