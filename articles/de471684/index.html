<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîÖ ‚ÜòÔ∏è üòã Warum m√ºssen Sie Module f√ºr Nginx erstellen? üå± üêã üìû</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nginx ist ein Webserver, der Dutzende von Gesch√§ftsaufgaben l√∂st, flexibel konfiguriert, skaliert und auf fast allen Betriebssystemen und Plattformen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warum m√ºssen Sie Module f√ºr Nginx erstellen?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/471684/">  Nginx ist ein Webserver, der Dutzende von Gesch√§ftsaufgaben l√∂st, flexibel konfiguriert, skaliert und auf fast allen Betriebssystemen und Plattformen funktioniert.  Eine Liste der Funktionen, F√§higkeiten und Probleme, die sofort gel√∂st werden m√ºssen, kann in einer kleinen Brosch√ºre beschrieben werden.  Manchmal k√∂nnen einige Gesch√§ftsaufgaben jedoch nur durch die Entwicklung eigener Module f√ºr nginx gel√∂st werden.  Dies sind Module, die gesch√§ftsorientiert sind und eine Gesch√§ftslogik enthalten, und nicht nur eine verallgemeinerte Systeml√∂sung. <br><br><img src="https://habrastorage.org/webt/_g/qx/cl/_gqxcl-ni0gc2f2rsr7thf4tici.jpeg"><br><br>  Im Allgemeinen ist alles in Nginx Module, die einmal von jemandem geschrieben wurden.  Daher ist das Schreiben von Modulen unter nginx nicht nur m√∂glich, sondern auch notwendig.  Wann und warum dies notwendig ist und warum, wird <strong>Wassili Soshnikow</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">dedokOne</a> ) am Beispiel mehrerer F√§lle berichten. <br><br>  Lassen Sie uns √ºber die Gr√ºnde sprechen, die das Schreiben von Modulen in C f√∂rdern, √ºber die Architektur und den Kern von Nginx, die Anatomie von HTTP-Modulen, √ºber C-Module, NJS, Lua und nginx.conf.  Dies ist nicht nur f√ºr diejenigen wichtig, die sich unter Nginx entwickeln, sondern auch f√ºr diejenigen, die Nginx-Configs, Lua oder eine andere Sprache in Nginx verwenden. <br><br>  <em>Hinweis: Der Artikel basiert auf einem Bericht von Vasily Soshnikov.</em>  <em>Der Bericht wird st√§ndig aktualisiert und aktualisiert.</em>  <em>Die Informationen im Material sind recht technisch und um das Beste daraus zu machen, m√ºssen die Leser Erfahrung im Umgang mit Nginx-Code auf einem durchschnittlichen Niveau und dar√ºber haben.</em> <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/82CyWPpjNNY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Kurz √ºber Nginx </h2><br>  <strong>Alles, was Sie mit nginx verwenden, sind Module</strong> .  Jede Direktive in der Nginx-Konfiguration ist ein separates Modul, das von Kollegen aus der Nginx-Community sorgf√§ltig geschrieben wurde. <br><br>  <strong>Direktiven in nginx.conf sind auch Module</strong> , die ein bestimmtes Problem l√∂sen.  Daher sind in Nginx-Modulen alles.  add_header, proxy_pass, eine beliebige Direktive - dies sind Module oder Kombinationen von Modulen, die nach bestimmten Regeln arbeiten. <br><br>  <strong>Nginx ist ein Framework</strong> mit folgenden Funktionen: Netzwerk- und Datei-E / A, gemeinsamer Speicher, Konfiguration und Skripterstellung.  Dies ist eine riesige Schicht von Bibliotheken auf niedriger Ebene, auf denen Sie alles tun k√∂nnen, um mit den Netzwerklaufwerken zu arbeiten. <br><br>  <strong>Nginx ist schnell und stabil, aber komplex</strong> .  Sie sollten solchen Code schreiben, um diese Eigenschaften von Nginx nicht zu verlieren.  Instabiles Nginx in der Produktion sind unzufriedene Kunden, und alles, was daraus folgt. <br><br><h2>  Warum eigene Module erstellen? </h2><br>  <strong>Konvertieren Sie das HTTP-Protokoll in ein anderes Protokoll.</strong>  Dies ist der Hauptgrund, der h√§ufig zur Erstellung eines bestimmten Moduls motiviert. <br><br>  Beispielsweise konvertiert das memcached_pass-Modul HTTP in ein anderes Protokoll, und Sie k√∂nnen mit anderen externen Systemen arbeiten.  Mit dem Modul proxy_pass k√∂nnen Sie auch von HTTP (s) zu HTTP (s) konvertieren.  Ein weiteres gutes Beispiel ist fastcgi_pass. <br><br>  Dies sind alles Anweisungen des Formulars: "Gehen Sie zu so und so einem Backend, wo nicht HTTP (aber im Fall von proxy_pass HTTP)." <br><br>  <strong>Dynamisches Einf√ºgen von Inhalten: AdBlock-Bypass, Anzeigeneinf√ºgung.</strong>  Zum Beispiel haben wir ein Backend und es ist notwendig, den Inhalt zu √§ndern, der daraus stammt.  Zum Beispiel AdBlock, das den Anzeigeneinf√ºgungscode analysiert, und wir m√ºssen uns damit befassen - um ihn auf die eine oder andere Weise zu optimieren. <br><br>  Eine andere Sache, die Sie h√§ufig tun m√ºssen, um Inhalte einzubetten, ist das Problem mit dem HLS-Caching.  Wenn Parameter in HLS zwischengespeichert werden, k√∂nnen zwei Benutzer dieselbe Sitzung oder dieselben Parameter erhalten.  Von dort aus schneiden oder f√ºgen Sie einige Parameter hinzu, wenn Sie etwas verfolgen m√ºssen. <br><br>  <strong>Clickstream-Datenerfassung von Internet- / Mobilz√§hlern.</strong>  Ein beliebter Fall in meiner Praxis.  Meistens geschieht dies auf nginx, aber nicht auf access.log, sondern etwas intelligenter. <br><br>  <strong>Konvertieren aller Arten von Inhalten.</strong>  Mit dem rtmp-Modul f√ºr k√∂nnen Sie beispielsweise nicht nur mit rtmp, sondern auch mit HLS arbeiten.  Dieses Modul kann viel mit Videoinhalten tun. <br><br>  <strong>Allgemeiner Autorisierungspunkt: SEP oder Api Gateway.</strong>  Dies ist der Fall, wenn nginx als Teil der Infrastruktur arbeitet: Autorisiert, sammelt Metriken, sendet Daten an die √úberwachung und ClickStream.  Nginx fungiert hier als Infrastruktur-Hub - ein einziger Einstiegspunkt f√ºr Backends. <br><br>  <strong>Anreicherung von Anfragen f√ºr deren sp√§tere R√ºckverfolgung.</strong>  Moderne Systeme sind sehr komplex, mit verschiedenen Arten von Backends, die unterschiedliche Teams bilden.  In der Regel sind sie schwer zu deb√ºtieren, manchmal ist es sogar schwierig zu verstehen, woher die Anfrage kam und wohin sie ging.  Um das Debuggen zu vereinfachen, verwenden einige gro√üe Unternehmen eine knifflige Technik: Sie f√ºgen Anforderungen bestimmte Daten hinzu.  Der Benutzer wird sie nicht sehen, aber anhand dieser Daten ist es einfach, den Anforderungspfad innerhalb des Systems zu verfolgen.  Dies wird als <strong>Trace bezeichnet</strong> . <br><br>  <strong>S3-Proxy.</strong>  In diesem Jahr sehe ich oft Leute, die mit s3 √ºber s3 arbeiten.  Dies ist jedoch bei C-Modulen nicht erforderlich, da die Infrastruktur auch in Nginx ausreicht.  Um einige dieser Probleme zu l√∂sen, k√∂nnen Sie Lua verwenden. Auf NJS wird etwas gel√∂st.  Aber manchmal ist es notwendig, Module in C zu schreiben. <br><br><h2>  Wann ist die Zeit, Module zu erstellen? </h2><br>  Es gibt zwei Kriterien, um zu verstehen, dass die Zeit gekommen ist. <br><br>  <strong>Verallgemeinerung der Funktionalit√§t.</strong>  Wenn Sie verstehen, dass jemand anderes Ihr Produkt ben√∂tigt, tragen Sie es zu Open Source bei, erstellen allgemeine Funktionen, ver√∂ffentlichen es und lassen es verwenden. <br><br>  <strong>Gesch√§ftsprobleme l√∂sen.</strong>  Wenn ein Unternehmen solche Anforderungen stellt, die nur durch das Schreiben eines eigenen Moduls f√ºr nginx erf√ºllt werden k√∂nnen.  Beispiel: Dynamisches Einf√ºgen / √Ñndern von Inhalten, ClickStream-Sammlung kann auf Lua durchgef√ºhrt werden, funktioniert aber h√∂chstwahrscheinlich nicht normal. <br><br><h2>  Nginx-Architektur </h2><br>  Ich habe lange Zeit Nginx-Code geschrieben.  Neun meiner Module drehen sich in der Produktion, eines davon in Open Source und f√ºr viele in der Produktion.  Daher habe ich Erfahrung und Verst√§ndnis. <br><blockquote>  Nginx ist eine Nistpuppe, in der alles um den Kern herum aufgebaut ist. </blockquote>  Also verstehe ich Nginx. <br><blockquote>  Kern sind Wrapper √ºber Epoll. </blockquote>  Epoll ist eine Methode, mit der Sie asynchron mit allen Deskriptordateien arbeiten k√∂nnen, nicht nur mit Sockets, da ein Deskriptor nicht nur ein Socket ist. <br><br>  √úber dem Kern befinden sich Upstreams, HTTP und Scripting.  Mit Scripting meine ich nginx.conf, nicht NJS.  Neben Upstreams, HTTP und Scripting sind bereits HTTP-Module erstellt, √ºber die wir sprechen werden. <br><br><img src="https://habrastorage.org/webt/d7/b6/ff/d7b6ffhplgm4ddkbvncbfh4umym.jpeg"><br><br>  Ein klassisches Beispiel f√ºr Upstreams und HTTP sind Upstream-Server - Anweisungen innerhalb der Konfiguration.  Ein Beispiel f√ºr Module f√ºr HTTP ist add_header.  Ein Beispiel f√ºr die Skripterstellung ist die Konfigurationsdatei selbst.  Die Datei enth√§lt die Module, aus denen nginx besteht. Sie wird irgendwie interpretiert und erm√∂glicht es Ihnen, etwas als Administrator oder als Benutzer zu tun. <br><br>  Wir werden den Kern nicht betrachten und uns sehr kurz mit Upstreams befassen, da es sich um ein separates Universum innerhalb von Nginx handelt.  Die Geschichte √ºber sie verdient mehrere Artikel. <br><br><h2>  Anatomie von HTTP-Modulen </h2><br>  Auch wenn Sie keinen C-Code in nginx schreiben, sondern verwenden, beachten Sie die Hauptregel. <br><blockquote>  In Nginx gehorcht alles dem Muster der Verantwortungskette - COR. </blockquote>  Ich wei√ü nicht, wie ich das ins Russische √ºbersetzen soll, aber ich werde die Logik beschreiben.  Ihre Anfrage durchl√§uft eine Galaxie konfigurierter Kettenmodule, beginnend mit dem Standort.  Jedes dieser Module gibt ein Ergebnis zur√ºck.  Wenn das Ergebnis schlecht ist, wird die Kette unterbrochen. <br><br><img src="https://habrastorage.org/webt/ky/sf/zj/kysfzj-evntyaf8v8q53ygxgrr4.jpeg"><br><br>  Vergessen Sie beim Entwickeln von Modulen oder beim Verwenden einer Direktive in NJS und Lua nicht, dass Ihr Code die Ausf√ºhrung dieser Kette zum Absturz bringen kann. <br><br>  Die n√§chste Analogie zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chain of Responsibility</a> ist eine Zeile mit Bash-Code: <br><br><pre><code class="bash hljs">grep -RI pool nginx | awk -F<span class="hljs-string"><span class="hljs-string">":"</span></span> <span class="hljs-string"><span class="hljs-string">'{print $1}'</span></span> | sort -u | wc -l</code> </pre> <br>  Im Code ist alles ganz einfach: Wenn AWK in die Mitte der Zeile f√§llt, werden <code>sort</code> und die folgenden Befehle nicht ausgef√ºhrt.  Das Nginx-Modul funktioniert √§hnlich, aber die Wahrheit ist in Nginx und Sie k√∂nnen dies umgehen - starten Sie den Code neu.  Sie sollten jedoch darauf vorbereitet sein, abzust√ºrzen und auszuf√ºhren, genau wie Ihre Module, die Sie in der Konfiguration verwenden, aber nicht die Tatsache, dass dies so ist. <br><br><h3>  Arten von HTTP-Modulen </h3><br><blockquote>  HTTP und Nginx sind eine Reihe verschiedener PHASEN. </blockquote><br><ul><li>  <strong>Phasenbehandlung - PHASE-Handler</strong> . </li><li>  <strong>Filter - Body / Header-Filter</strong> .  Diese Filterung erfolgt entweder in Kopfzeilen oder in Anforderungsk√∂rpern. </li><li>  <strong>Proxies</strong> .  Typische Proxy-Module sind proxy_pass, fastcgi_pass, memcached_pass. </li><li>  <strong>Module f√ºr den spezifischen Lastausgleich - Lastausgleicher</strong> .  Dies ist die am wenigsten verdrehte Art von Modulen, sie werden nur wenig entwickelt.  Ein Beispiel ist das Ketama CHash-Modul, mit dem Sie konsistentes Hashing in Nginx durchf√ºhren k√∂nnen, um Anforderungen an Backends zu verteilen. </li></ul><br>  Ich werde √ºber jeden dieser Typen und ihren Zweck berichten. <br><br><h3>  Phasenhandler </h3><br>  Stellen Sie sich vor, wir haben mehrere Phasen, beginnend mit der Zugriffsphase.  In jeder Phase gibt es mehrere Module.  Beispielsweise ist die ACCESS-Phase in eine Verbindung, eine Anforderung an nginx und die √úberpr√ºfung der Benutzerberechtigung unterteilt.  Jedes Modul ist eine Zelle in der Kette.  Es kann unendlich viele solcher Module in Phase geben. <br><br><img src="https://habrastorage.org/webt/pn/6b/t9/pn6bt9m3khwxmsxgnqjvyzwfcb0.jpeg"><br><br>  Der letzte, letzte Handler ist die INHALTSphase, in der Inhalte auf Anfrage bereitgestellt werden. <br><blockquote>  Der Weg ist immer folgender: Anfrage - eine Kette von Handlern - Inhalt ausgeben. </blockquote>  Phasen, die Entwicklern von Modulen aus den <a href="https://github.com/nginx/nginx/blob/master/src/http/ngx_">NGINX-Quellen zur Verf√ºgung stehen</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { NGX_HTTP_POST_READ_PHASE = <span class="hljs-number"><span class="hljs-number">0</span></span>, NGX_HTTP_SERVER_REWRITE_PHASE, NGX_HTTP_FIND_CONFIG_PHASE, NGX_HTTP_REWRITE_PHASE, NGX_HTTP_POST_REWRITE_PHASE, NGX_HTTP_PREACCESS_PHASE, NGX_HTTP_ACESS_PHASE, NGX_HTTP_POST_ACESS_PHASE, NGX_HTTP_PRECONTENT_PHASE, NGX_HTTP_CONTENT_PHASE, NGX_HTTP_LOG_PHASE, } ngx_http_phases;</code> </pre> <br>  Phasen k√∂nnen √ºberschrieben werden, f√ºgen Sie Ihren eigenen Handler hinzu.  Nicht alle von ihnen werden im wirklichen Leben ben√∂tigt, wenn Sie nicht der Entwickler von Nginx Core sind.  Daher werde ich nicht √ºber jede Phase sprechen, sondern nur √ºber die wichtigsten, die ich verwendet habe. <br><br>  Das wichtigste ist <strong>ACCESS_PHASE.</strong>  Es ist besonders n√ºtzlich, Ihre Berechtigung zu nginx hinzuzuf√ºgen, um die Ausf√ºhrung der Anforderung in Bezug auf den Zugriff zu √ºberpr√ºfen. <br><br>  Die n√§chsten wichtigen Phasen, die ich oft ausnutze, sind die Phasen des Vorinhalts und des Inhalts.  <strong>Mit PRECONTENT_PHASE</strong> k√∂nnen <strong>Sie</strong> Metriken zu Inhalten erfassen, die als Antwort an den Client gesendet werden sollen.  <strong>Mit CONTENT_PHASE</strong> k√∂nnen <strong>Sie</strong> Ihren eigenen einzigartigen Inhalt basierend auf etwas generieren. <br><br>  Die letzte Phase, die ich oft benutze, ist die Protokollierungsphase <strong>LOG_PHASE.</strong>  Im √úbrigen funktioniert darin die Direktive ACCESS_LOG.  Die Protokollierungsphase weist die wildesten Einschr√§nkungen auf, die mich verr√ºckt machen: Sie k√∂nnen keine Unteranforderung verwenden und im Allgemeinen k√∂nnen Sie keine Anforderung verwenden.  Sie haben den Inhalt bereits dem Benutzer √ºberlassen, und Handler, Posthandler und Unteranforderungen werden nicht ausgef√ºhrt. <br><br>  Ich werde erkl√§ren, warum es nervt.  Angenommen, Sie m√∂chten Nginx und Kafka in der Protokollierungsphase √ºberqueren.  In dieser Phase ist bereits alles abgeschlossen: Es gibt eine berechnete Gr√∂√üe des Inhalts, des Status und aller Daten, aber Sie k√∂nnen keine Unteranforderung durchf√ºhren.  Sie arbeiten dort nicht.  Sie m√ºssen in der Protokollierungsphase auf nackte Sockets schreiben, um Daten an Kafka zu senden. <br><br><h3>  Body / Header-Filter </h3><br>  Es gibt zwei Arten von Filtern: K√∂rperfilter und Kopfzeilenfilter. <br><br>  Ein Beispiel f√ºr einen <strong>Body-Filter</strong> ist das gzip-Filtermodul.  Warum werden K√∂rperfilter ben√∂tigt?  Stellen Sie sich vor, Sie haben einen bestimmten proxy_pass und m√∂chten den Inhalt irgendwie transformieren oder analysieren.  In diesem Fall sollten Sie den Body-Filter verwenden. <br><br>  Es funktioniert so: Viele Brocken kommen zu Ihnen, Sie machen etwas mit ihnen, schauen sich den Inhalt an, aggregieren usw.  Der Filter weist jedoch auch erhebliche Einschr√§nkungen auf.  Wenn Sie beispielsweise den Text √§ndern m√∂chten, um den Antworttext einzuf√ºgen oder auszuschneiden, denken Sie daran, dass HTTP-Attribute, z. B. ein Inhaltsfeed, ersetzt werden.  Dies kann zu seltsamen Effekten f√ºhren, wenn Sie keine Einschr√§nkungen vorsehen und Ihren Code korrekt wiedergeben. <br><br>  Ein Beispiel f√ºr einen <strong>Header-Filter</strong> ist der add_header, den jeder verwendet hat.  Der Algorithmus funktioniert wie im Body-Filter.  F√ºr den Client wird eine Antwort vorbereitet, und mit dem Filter add_header k√∂nnen Sie dort etwas tun: Header hinzuf√ºgen, Header l√∂schen, Header ersetzen, Unteranforderung senden. <br><br>  √úbrigens k√∂nnen Sie im Body-Filter und im Header-Filter Unteranforderungen sogar interne Identifikationen an einen zus√§tzlichen Ort senden. <br><br><h3>  Proxy </h3><br>  Dies ist die komplexeste und umstrittenste Art von Modulen, mit denen Sie Anforderungen an externe Systeme weiterleiten k√∂nnen, z. B. <strong>HTTP in ein anderes Protokoll konvertieren k√∂nnen</strong> .  Beispiele: proxy_pass, redis_pass, tnt_pass. <br><br>  Proxy ist eine Schnittstelle, die von Nginx-Kernentwicklern vorgeschlagen wurde, um das Schreiben von Proxy-Modulen zu vereinfachen.  Wenn dies auf klassische Weise erfolgt, werden f√ºr einen solchen Proxy PHASES-Handler, Filter, Balancer ausgef√ºhrt.  Wenn sich das Protokoll, in das Sie HTTP konvertieren m√∂chten, jedoch irgendwie von den Klassikern unterscheidet, treten gro√üe Probleme auf.  Die von nginx bereitgestellte Proxy-API ist einfach nicht geeignet - Sie m√ºssen dieses Proxy-Modul von Grund auf neu erfinden. <br><br>  Ein gutes Beispiel f√ºr ein solches Modul ist postgres_pass.  Es erm√∂glicht nginx die Kommunikation mit PostgreSQL.  Das Modul verwendet die in nginx entwickelte Schnittstelle √ºberhaupt nicht - es hat einen eigenen Pfad. <br><blockquote>  Denken Sie an Proxy, aber schreiben Sie vorzugsweise nicht.  Um einen Proxy zu schreiben, m√ºssen Sie alle Nginx auswendig lernen - es ist sehr lang und schwierig. </blockquote><br><h3>  Load Balancer </h3><br>  Die Aufgabe von Load Balancern ist sehr einfach - im Round-Robin-Modus zu arbeiten.  Stellen Sie sich vor, Sie haben einen Upstream-Abschnitt, einige Server, Sie geben Gewichte und Ausgleichsmethoden an.  Dies ist ein typischer Load Balancer. <br><br>  Dieser Modus ist nicht immer geeignet.  Daher wurde das Ketama CHash-Modul entwickelt, bei dem es bedingt m√∂glich ist, eine konsistente Hash-Anfrage an einen Server zu erhalten.  Manchmal ist es bequem.  Nginx Lua bietet balancer_by_lua an.  Auf Lua k√∂nnen Sie generell jeden Balancer schreiben. <br><br><h2>  C-Module </h2><br>  Als n√§chstes kommt meine absolut subjektive Meinung zur Entwicklung von C-Modulen.  Zun√§chst - meine subjektiven Regeln. <br><br>  <strong>Das Modul beginnt mit den Anweisungen nginx.conf.</strong>  Auch wenn Sie ein C-Modul herstellen, das nur von Ihrem Unternehmen betrieben wird, denken Sie immer an Richtlinien.  Beginnen Sie mit dem Entwerfen des Moduls mit ihnen, da der Systemadministrator auf diese Weise mit ihm kommuniziert.  Dies ist wichtig - koordinieren Sie alle Nuancen mit ihm oder mit der Person, die Ihr C-Modul bedienen wird.  NGINX ist ein bekanntes Produkt. Seine Richtlinien befolgen bestimmte Gesetze, die Systemadministratoren kennen.  Denken Sie deshalb immer dar√ºber nach. <br><br>  <strong>Verwenden Sie den Nginx-Codestil.</strong>  Stellen Sie sich vor, Ihr Modul wird von einer anderen Person unterst√ºtzt.  Wenn er bereits mit Nginx und seinem Codestil vertraut ist, ist es f√ºr ihn viel einfacher, Ihren Code zu lesen und zu verstehen. <br><br>  K√ºrzlich hat mich ein guter Freund aus Deutschland gebeten, ihm bei der Behebung eines Fehlers in seinem Nginx-Code zu helfen.  Ich wei√ü nicht, f√ºr welchen Codestil er es geschrieben hat, aber ich konnte den Code nicht einmal normal lesen. <br><br>  <strong>Verwenden Sie den richtigen Speicherpool.</strong>  Denken Sie immer daran, auch wenn Sie viel Erfahrung mit Nginx haben.  Ein typischer Fehler eines unerfahrenen C-Modul-Entwicklers f√ºr Nginx besteht darin, den falschen Pool zu erhalten. <br><br>  Ein kleiner Hintergrund: Nginx verwendet im Allgemeinen die Ideologie schwacher Allokatoren.  Sie k√∂nnen dort malloc verwenden, aber nicht empfohlen.  Es hat seine eigenen Platten, seinen eigenen Speicherzuweiser, Sie m√ºssen es verwenden.  Dementsprechend hat jedes Objekt eine Verkn√ºpfung zu seinem Pool, und dieser Pool muss verwendet werden.  Ein typischer Anf√§ngerfehler besteht darin, eine Poolverbindung im Headerfilter zu verwenden, keine Poolanforderung.  Dies bedeutet, dass bei einer Keep-Alive-Verbindung der Pool anschwillt, bis nicht mehr gen√ºgend Speicher vorhanden ist oder andere Nebenwirkungen auftreten.  Daher ist es wichtig. <br><br>  Dar√ºber hinaus sind solche Fehler √§u√üerst schwer zu deb√ºtieren.  Valgrind ("syshniks" wird verstehen) funktioniert nicht mit der Plattenzuordnung - es wird ein seltsames Bild zeigen. <br><br>  <strong>Verwenden Sie keine blockierenden E / A.</strong>  Ein typischer Fehler derjenigen, die etwas Externes schneller anwenden m√∂chten, ist die Verwendung von blockierenden E / A und blockierenden Sockets.  Sie k√∂nnen dies in Nginx niemals tun - es gibt viele Prozesse darin, aber jeder Prozess verwendet einen Thread. <br><br>  Sie k√∂nnen Multithreading durchf√ºhren, dies macht es jedoch in der Regel nur noch schlimmer.  Wenn Sie in einer solchen Architektur blockierende E / A verwenden, warten alle auf dieses blockierende Teil. <br><br>  Ich werde entziffern, was ich oben gesagt habe. <br><br><h3>  Das Modul beginnt mit den Anweisungen nginx.conf </h3><blockquote>  Entscheiden Sie, in welchen Arrays Ihre Direktive gespeichert werden soll: Main, Server, HTTP, Location, Location if. </blockquote>  Versuchen Sie, den Standort zu vermeiden, wenn dies in der Regel zu einer sehr merkw√ºrdigen Verwendung der Nginx-Konfiguration f√ºhrt. <br><br>  Alle Direktiven in Nginx leben in unterschiedlichen Kontexten und in unterschiedlichen Bereichen.  Die Direktive add_header kann auf HTTP-Ebene, auf Standortebene und auf Standortebene arbeiten.  Dies wird normalerweise in der Dokumentation beschrieben. <br><blockquote>  Verstehen Sie, auf welchen Ebenen Ihre Direktive arbeiten kann und wo die Direktive ausgef√ºhrt wird: PHASE Handler, Body / Header-Filter. </blockquote>  Dies ist wichtig, da in nginx die Konfiguration eingefroren ist.  Wenn Sie add_header irgendwo dar√ºber schreiben, wird dieser Wert standardm√§√üig im unteren add_header gegl√§ttet, den Sie bereits an Ort und Stelle haben.  Dementsprechend f√ºgen Sie zwei √úberschriften hinzu.  Dies gilt f√ºr jede Richtlinie. <br><br>  Wenn Sie einen Host-Port angeben, dann umgekehrt - Socket-Pool.  Dies sollte einmal angezeigt werden. <br><br>  Im Allgemeinen w√ºrde ich jegliches Zusammenf√ºhren verbieten - Sie brauchen es einfach nicht.  Daher sollten Sie immer klar bestimmen, in welchen Nginx-Arrays aus der Konfiguration Ihre Direktive oder Gruppe von Direktiven lebt. <br><br>  Gutes Beispiel: <br><br><pre> <code class="cpp hljs">location /my_location/ { add_header ‚ÄúMy-Header‚Äù ‚Äúmy value‚Äù; }</code> </pre> <br>  Hier wird add_header einfach zum Speicherort hinzugef√ºgt.  Der gleiche add_header k√∂nnte sich irgendwo oben befinden und alles w√ºrde einfach verzerrt sein.  Dies ist ein dokumentiertes und verst√§ndliches Verhalten. <br><blockquote>  √úberlegen Sie, was die Umsetzung der Richtlinie behindern k√∂nnte. </blockquote>  Stellen Sie sich vor, Sie entwickeln einen K√∂rperfilter.  Wie oben erw√§hnt, ordnet nginx Ihr Modul nur einer gemeinsamen Kette zu, und Sie k√∂nnen nicht garantieren, dass das gzip-Modul beim Kompilieren nicht in die Kette vor Ihrem Body-Filter gelangt ist.  In diesem Fall werden die Daten f√ºr das gzip an Ihr Modul gesendet, wenn jemand das gzip-Modul einschaltet.  Dies droht, dass Sie mit dem Inhalt einfach nichts anfangen k√∂nnen.  Sie k√∂nnen es beispielsweise erneut gzipen, dies ist jedoch aus Sicht der CPU ein Spott. <br><br>  F√ºr alle Phasenabwickler gelten die gleichen Regeln - es gibt keine Garantie daf√ºr, wer vorher und wer danach angerufen wird.  Respektieren Sie daher denjenigen, der angerufen wird, und denken Sie daran, dass ein GZIP oder etwas anderes unerwartet zu Ihnen fliegen kann. <br><br><h3>  Nginx-Codestil </h3><br><blockquote>  Denken Sie beim Erstellen des Produkts daran, dass es von jemandem unterst√ºtzt wird.  Vergessen Sie nicht den Code-Stil Nginx. </blockquote>  Machen Sie sich vor dem Schreiben Ihres Nginx-Moduls mit der Quelle vertraut: der <a href="">einen</a> und der <a href="">zweiten</a> . <br><br>  Wenn Sie in Zukunft mit der Entwicklung von Nginx-Modulen beginnen, sind Sie sich der Nginx-Quellen bewusst.  Sie werden sie lieben, weil es <strong>keine Dokumentation gibt</strong> .  Sie lernen die Struktur des Nginx-Verzeichnisses gut kennen und lernen, Grep, m√∂glicherweise Sed, zu verwenden, wenn Sie einige Teile von Nginx auf Ihre Module √ºbertragen m√ºssen. <br><br><h3>  Speicherpool </h3><br>  Pools m√ºssen korrekt verwendet werden.  <strong>Zum Beispiel "r-&gt; Verbindung-&gt; Pool! = R-&gt; Pool".</strong>  In keinem Fall k√∂nnen Sie die Speicherpoolkonfiguration bei der Verarbeitung von Anforderungen verwenden. Sie schwillt an, bis nginx neu gestartet wird. <br><br>  Verstehen Sie die Lebensdauer des Objekts.  Angenommen, die Anforderungswiedergabe hat genau diese Pipeline-Lebensdauer.  In diesem Pool k√∂nnen Sie viele Dinge platzieren und Platz schaffen.  Verbindung kann theoretisch unbegrenzt leben - es ist besser, etwas wirklich Wichtiges darin zu platzieren. <br><br>  <strong>Versuchen Sie, keine externen Allokatoren zu verwenden, z. B. malloc / free</strong> .  Dies hat negative Auswirkungen auf die Speicherfragmentierung.  Wenn Sie mit gro√üen Datenmengen arbeiten und viel Malloc verwenden, verlangsamt sich dieser Nginx ziemlich gut. <br><br>  <strong>F√ºr Fans von Valgrind gibt es einen</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Hack</strong></a> , mit dem Sie Nginx-Pools mit Valgrind debuggen k√∂nnen.  Dies ist wichtig, wenn Sie viel C-Code auf nginx haben, da selbst ein erfahrener Entwickler in der Arbeit mit Speicher einen Fehler machen kann. <br><br><h3>  E / A blockieren </h3><blockquote>  Hier ist alles einfach - verwenden Sie keine blockierenden E / A. </blockquote>  Andernfalls gibt es zumindest Probleme mit Keep-Alive-Verbindungen, aber maximal funktioniert alles sehr lange. <br><br>  Ich kenne den Fall, dass eine Person Quora in Nginx im Blockierungsmodus verwendet hat (fragen Sie nicht warum).  Dies f√ºhrte dazu, dass Keep-Alive-Verbindungen ihre Aktivit√§ten aufgaben und st√§ndig eine Zeit√ºberschreitung aufwiesen.  Es ist besser, dies nicht zu tun - alles wird lange Zeit ineffizient funktionieren und Sie m√ºssen sofort eine Million Zeit√ºberschreitungen verdrehen, da Nginx bei vielen Dingen eine Zeit√ºberschreitung startet. <br><br>  Es gibt jedoch eine Alternative zu C-Modulen - NJS und Lua. <br><br><h2>  Wenn Sie keine C-Module entwickeln m√ºssen </h2><br>  Dieses Jahr hatte ich meine ersten Erfahrungen mit NJS, ich bekam einen subjektiven Eindruck davon und ich erkannte sogar, was dort fehlte, so dass alles in Ordnung war.  Ich m√∂chte auch √ºber meine Erfahrungen bei der Arbeit an Lua unter Nginx sprechen und dar√ºber hinaus die Probleme teilen, die in Lua vorhanden sind. <br><br><h3>  Lua / LuaJit Essentials </h3><br>  Nginx verwendet nicht Lua, sondern LuaJit.  Dies ist jedoch nicht Lua, da Lua bereits zwei Versionen weiterentwickelt hat und LuaJit irgendwo in der Vergangenheit feststeckt.  <strong>Der Autor entwickelt LuaJit praktisch nicht - er lebt oft in Gabeln.</strong>  Die aktuellste Gabel ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LuaJit2</a> .  Dies f√ºgt seltsame Situationen in derselben OpenResty hinzu. <br><br>  <strong>Garbage Collector braucht Aufmerksamkeit</strong> .  LuaJit kann dieses Problem nicht l√∂sen. √úberlegen Sie sich einfach einige Problemumgehungen.  Bei einer enormen Last, bei der auf dem Client eine Menge Keep-Alive-Garbage Collector mit Fehlern in der Tabelle und 500 Fehlern sichtbar ist. Es gibt viele M√∂glichkeiten, mit dem Garbage Collector in Lua umzugehen. Ich werde mich hier nicht auf diese konzentrieren.  Im Internet gibt es dazu viele Informationen. <br><br>  <strong>Die Implementierung von Zeichenfolgen f√ºhrt zu Leistungsproblemen</strong> .  Dies ist nur das B√∂se von LuaJit, und in Lua wurde es repariert.  Die Implementierung von Strings in LuaJit widerspricht einfach jeder Logik.  Linien werden auf wildeste Weise langsamer, was mit der internen Implementierung verbunden ist. <br><br>  <strong>Unf√§higkeit, viele vorgefertigte Bibliotheken zu verwenden</strong> .  Lua blockiert anf√§nglich, daher verwenden die meisten Bibliotheken auf Lua und LuaJit blockierende E / A.  Aufgrund der Tatsache, dass Nginx nicht blockiert, ist es unm√∂glich, vorgefertigte Bibliotheken in Nginx zu verwenden, die blockierende E / A verwenden.  Dies wird Nginx verlangsamen. <br><br>  Die Gr√ºnde f√ºr die Verwendung von LuaJit sind identisch mit den Gr√ºnden f√ºr die Verwendung von Modulen: <br><br><ul><li>  Prototyping komplexer Module; </li><li>  HMAC, SHA-Berechnungen f√ºr Berechtigungen; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Balancer</a> ; </li><li>  kleine Anwendungen: Header-Handler, Regeln f√ºr Weiterleitungen; </li><li>  Berechnungsvariablen f√ºr nginx.conf. </li></ul><br>  Wo ist es besser, LuaJit nicht zu verwenden? <br><blockquote>  Die Hauptregel: Verarbeiten Sie keinen gro√üen K√∂rper auf Lua - das funktioniert nicht. </blockquote>  <strong>Handler f√ºr Inhalte auf Lua funktionieren ebenfalls nicht</strong> .  Versuchen Sie, die Logik auf wenige <code>if</code> zu minimieren.  Ein einfacher Balancer wird funktionieren, aber eine Seitenleiste auf Lua wird sehr schlecht funktionieren. <br><br>  <strong>Shared Memory oder Garbage Collector werden kommen.</strong>  Verwenden Sie Shared Memory nicht mit Lua - Garbage Collector wird schnell und mit Sicherheit das gesamte Gehirn f√ºr die Produktion ausschalten. <br><br>  <strong>Verwenden Sie keine Coroutinen</strong> mit vielen Keep-Alive-Verbindungen.  Coroutinen erzeugen noch mehr M√ºll im LuaJit Garbage Collector, was schlecht ist. <br><br>  Wenn Sie LuaJit bereits verwenden, denken Sie daran: <br><br><ul><li>  √ºber die Speicher√ºberwachung; </li><li>  zur √úberwachung und Optimierung der Arbeit von Garbage Collector; </li><li>  dar√ºber, wie Garbage Collector funktioniert, wenn Sie eine komplizierte Anwendung f√ºr LuaJit geschrieben haben, weil Sie etwas Neues hinzuf√ºgen m√ºssen. </li></ul><br><h3>  Njs </h3><br>  Als ich bei NGINX Conf war, haben sie mich √ºberzeugt, dass es cool w√§re, keinen Code in C zu schreiben. Ich dachte, ich m√ºsste es versuchen, und das habe ich bekommen. <br><br>  <strong>Autorisierung</strong>  Es funktioniert, der Code ist einfach, es hat keinen Einfluss auf die Geschwindigkeit - alles ist gro√üartig.  Mein kleiner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prototyp, mit dem</a> ich angefangen habe, besteht aus 10 Codezeilen.  Aber diese 10 Zeilen autorisieren mit s3. <br><br>  <strong>Berechnen von Variablen f√ºr nginx.conf.</strong>  Viele Variablen k√∂nnen mit NJS berechnet werden.  In Nginx ist das cool.  Es gibt eine solche Funktion in Lua, aber es gibt einen Garbage Collector, also ist es nicht so cool. <br><br>  Allerdings ist nicht alles so gut.  Um wirklich coole Dinge auf NJS zu machen, vermisst er ein paar Dinge. <br><br>  <strong>Gemeinsamer Speicher</strong> .  Ich habe Shared Memory gepatcht. Dies ist meine eigene Gabel. Jetzt reicht es aus. <br><br>  <strong>Filter, die mehr Phasen unterst√ºtzen</strong> .  In NJS gibt es nur die Inhaltsphase und die Variablen, und der Header-Filter fehlt sehr.  Sie m√ºssen Kr√ºcken schreiben, um viele √úberschriften hinzuzuf√ºgen.  Es gibt nicht gen√ºgend K√∂rperfilter f√ºr komplexe Logik oder die Arbeit mit Inhalten. <br><br>  <strong>Informationen zur √úberwachung und Profilierung</strong> .  Ich wei√ü jetzt wie, aber ich musste die Quelle studieren.  Es gibt nicht gen√ºgend Informationen oder Tools zur richtigen Profilerstellung.  Wenn ja, ist es versteckt, wo es nicht zu finden ist.  Gleichzeitig gibt es nicht gen√ºgend Informationen dar√ºber, <strong>wo ich NJS verwenden kann</strong> und wo nicht? <br><br>  <strong>C-Module</strong> .  Ich hatte den Wunsch, NJS zu erweitern. <br><br><h2>  Nachwort </h2><br>  <strong>Warum eigene Module erstellen?</strong>  Allgemeine und gesch√§ftliche Probleme l√∂sen. <br><br>  <strong>Wann muss ich Module in C implementieren?</strong>  Wenn es keine anderen Optionen gibt.  Zum Beispiel eine hohe Last, das Einf√ºgen von Inhalten oder grundlegende Einsparungen bei der Hardware.  Dann muss dies garantiert in C erfolgen. In den meisten F√§llen ist Lua oder NJS geeignet.  Aber Sie m√ºssen immer vorausdenken. <br><br>  <strong>Und auf Lua?</strong>  Wenn Sie nicht in C schreiben k√∂nnen, m√ºssen Sie beispielsweise den Anforderungshauptteil nicht mit gro√üem RPS konvertieren.  Ihre Kundenzahl w√§chst, irgendwann werden Sie aufh√∂ren, damit umzugehen - denken Sie dar√ºber nach. <br><br>  <strong>NJS?</strong>  Wenn LuaJit die Nase voll hat von seinem Garbage Collector und seinen Strings.  Beispielsweise hat die Autorisierung viele Garbage-Objekte auf Lua generiert, dies war jedoch nicht kritisch.  Dies spiegelte sich jedoch in der √úberwachung und Bel√§stigung wider.  Jetzt erscheint es nicht mehr in meiner √úberwachung und alles ist gut geworden. <br><br><blockquote>  Bei HighLoad ++ 2019 wird Vasily Soshnikov das Thema Nginx-Module fortsetzen und mehr √ºber NJS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sprechen</a> , wobei der Vergleich mit LuaJit und C nicht zu vergessen ist. <br><br>  Sehen Sie sich die vollst√§ndige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Liste der</a> Berichte auf der Website an und sehen Sie sich am 7. und 8. November auf der gr√∂√üten Konferenz f√ºr Entwickler hoch belasteter Systeme.  Folgen Sie unseren neuen Ideen im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Newsletter</a> und im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telegrammkanal</a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471684/">https://habr.com/ru/post/de471684/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471666/index.html">Erleben Sie, wie iOS Developer mit einem Arbeitsvisum nach Deutschland zieht</a></li>
<li><a href="../de471668/index.html">Technische Analyse des checkm8-Exploits</a></li>
<li><a href="../de471670/index.html">Versuchen Sie Jetpack Compose im Kampf?</a></li>
<li><a href="../de471676/index.html">Telefonbetr√ºger. Die zweite Aktion, bei der ich zusammenbreche und zum n√§chsten Geldautomaten renne</a></li>
<li><a href="../de471678/index.html">Tragen Sie Dienstleistungen auf Anfrage</a></li>
<li><a href="../de471686/index.html">Wie AWS seine belastbaren Services zusammenstellt. Server- und Datenbankskalierung</a></li>
<li><a href="../de471688/index.html">Wie AWS seine belastbaren Services zusammenstellt. Netzwerkskalierung</a></li>
<li><a href="../de471700/index.html">Wie ich einen technologischen Stack mit einer Grundlage f√ºr die Zukunft gew√§hlt habe</a></li>
<li><a href="../de471702/index.html">Cyber-erweiterte Webanwendungen</a></li>
<li><a href="../de471704/index.html">Das Buch ‚ÄûEgoistische Mitochondrien. Wie man die Gesundheit erh√§lt und das Alter bewegt "</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>