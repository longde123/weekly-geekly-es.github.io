<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤲🏽 🚶 👨‍💼 Kami menulis proksi Reverse socks5 di PowerShell 🕵🏽 🔪 💃🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kisah penelitian dan pengembangan dalam 3 bagian. Bagian 2 - perkembangan. 
 Ada banyak beech - bahkan lebih banyak manfaat. 

 Pada bagian pertama ar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami menulis proksi Reverse socks5 di PowerShell</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453970/">  Kisah penelitian dan pengembangan dalam 3 bagian.  Bagian 2 - perkembangan. <br>  Ada banyak beech - bahkan lebih banyak manfaat. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pada bagian pertama</a> artikel, kami berkenalan dengan beberapa alat untuk mengatur terowongan terbalik, melihat kelebihan dan kekurangannya, mempelajari mekanisme multiplexer Yamux dan menjelaskan persyaratan dasar untuk modul powershell yang baru dibuat.  Sudah saatnya untuk mulai mengembangkan modul powershell klien untuk implementasi siap pakai dari terowongan terbalik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RSocksTun</a> . <br><br>  Pertama-tama, kita perlu memahami dalam mode apa modul kita akan berfungsi.  Jelas, untuk transfer data utama, kita perlu menggunakan mekanisme soket windows dan kemampuan .Net untuk streaming baca-tulis ke soket.  Tetapi, di sisi lain, karena  Karena modul kami harus melayani beberapa aliran yamux pada saat yang sama, maka semua operasi I / O tidak boleh sepenuhnya memblokir pelaksanaan program kami.  Ini menunjukkan kesimpulan bahwa modul kami harus menggunakan perangkat lunak multithreading dan melakukan operasi baca-tulis dengan server yamux, serta operasi baca-tulis ke server tujuan di aliran program yang berbeda.  Yah, tentu saja, perlu untuk menyediakan mekanisme interaksi antara aliran paralel kita.  Untungnya, PowerShell memberikan banyak peluang untuk meluncurkan dan mengelola aliran program. <br><a name="habracut"></a><br><h3>  Algoritma kerja umum </h3><br>  Jadi, algoritma umum klien kami harus seperti ini: <br><br><ul><li>  membuat koneksi SSL ke server; </li><li>  masuk dengan kata sandi sehingga server dapat membedakan kami dari petugas keamanan; </li><li>  tunggu paket yamux untuk menginstal aliran baru, secara berkala menanggapi permintaan server keepalive; </li><li>  mulai aliran program socksScript baru (jangan dikacaukan dengan aliran) segera setelah paket yamux tiba untuk menginstal aliran baru.  Di dalam socksScript, terapkan pekerjaan server socks5; </li><li>  pada saat kedatangan paket dengan data dari yamux - pahami dari header 12-byte yang mana dari aliran data dimaksudkan, serta ukurannya, baca data dari server yamux dan transfer data yang diterima ke aliran dengan nomor aliran yang sesuai; </li><li>  secara berkala memonitor ketersediaan data yang ditujukan untuk server yamux di setiap skrip kaus kaki yang sedang berjalan.  Jika ada data seperti itu, tambahkan header 12-byte yang sesuai dan kirimkan ke server yamux; </li><li>  pada saat kedatangan paket yamux untuk menutup aliran, mentransmisikan sinyal ke aliran yang sesuai untuk mengakhiri aliran dan memutuskan sambungan, dan setelah itu, selesaikan aliran itu sendiri; </li></ul><br>  Jadi, di klien kami perlu menerapkan setidaknya 3 aliran program: <br><br><ol><li>  yang utama, yang akan membangun koneksi, masuk ke server yamux, menerima data darinya, memproses tajuk yamux dan mengirim data mentah ke aliran program lain; </li><li>  stream dengan server kaus kaki.  Mungkin ada beberapa - satu untuk setiap aliran.  Mereka menerapkan fungsi socks5.  Alur ini akan berinteraksi dengan titik tujuan di jaringan internal; </li><li>  arus balik.  Ia menerima data dari stream kaus kaki, menambahkan header yamux kepada mereka dan mengirimkannya ke server yamux; </li></ol><br>  Dan, tentu saja, kita perlu menyediakan interaksi antara semua aliran ini. <br><br>  Kita tidak hanya perlu menyediakan interaksi seperti itu, tetapi juga untuk mendapatkan kenyamanan streaming input-output (mirip dengan soket).  Mekanisme yang paling tepat adalah menggunakan pipa perangkat lunak.  Di Windows, pipa terdaftar ketika setiap pipa memiliki namanya sendiri, dan anonim - setiap pipa diidentifikasi oleh penangannya.  Demi kerahasiaan, tentu saja, kami akan menggunakan pipa anonim.  (Lagi pula, kami tidak ingin modul kami dihitung menggunakan pipa terdaftar di sistem - kan?).  Dengan demikian, antara arus utama / balik dan kaus kaki-arus, interaksi akan melalui pipa anonim, mendukung aliran I / O asinkron  Antara arus utama dan arus balik, komunikasi akan berlangsung melalui mekanisme objek-bersama (variabel tersinkronisasi bersama) (lebih lanjut tentang apa variabel-variabel ini dan bagaimana hidup dengannya, Anda dapat membaca di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ). <br><br>  Informasi tentang menjalankan kaus kaki aliran harus disimpan dalam struktur data yang sesuai.  Saat membuat thread kaus kaki dalam struktur ini, kita harus menulis: <br><br><ul><li>  nomor sesi yamux: $ ymxstream; </li><li>  4 variabel untuk bekerja dengan pipa (saluran): $ cipipe, $ copipe, $ sipipe, $ sopipe.  Karena saluran anonim berfungsi dalam IN atau OUT, untuk setiap aliran kaus kaki kita memerlukan dua saluran anonim, yang masing-masing harus memiliki dua ujung (pipestream) (server dan klien); </li><li>  hasil dari panggilan ke aliran adalah $ AsyncJobResult; </li><li>  stream handler - $ Psobj.  Melalui itu kita akan menutup aliran dan melepaskan sumber daya; </li><li>  hasil pembacaan asinkron dari pipa anonim oleh reverse stream ($ readjob).  Variabel ini digunakan dalam aliran reverse yamuxScript untuk pembacaan asinkron dari pipa yang sesuai; </li><li>  buffer untuk membaca data untuk setiap aliran kaus kaki; </li></ul><br><h3>  Aliran utama </h3><br>  Jadi, dari sudut pandang pemrosesan data, pekerjaan program kami dibangun sebagai berikut: <br><br><ul><li>  sisi server (rsockstun - diimplementasikan pada Golang) memunculkan server ssl dan menunggu koneksi dari klien; </li><li>  ketika menerima koneksi dari klien, server memeriksa kata sandi, dan jika itu benar, membuat koneksi yamux, menaikkan port kaus kaki dan menunggu koneksi dari klien kaus kaki (rantai proxy, browser, dll.), secara berkala bertukar paket paket keepalive dengan pelanggan kami.  Jika kata sandi salah - pengalihan ke halaman yang kami tentukan saat menginstal server dilakukan (ini adalah halaman "legal" untuk administrator keamanan informasi yang waspada); </li><li>  ketika menerima koneksi dari klien kaus kaki, server mengirim paket yamux ke klien kami untuk membuat aliran baru (YMX SYN); </li></ul><br>  <b>Mendapatkan dan menganalisis tajuk Yamux</b> <br><br>  Modul kami pertama-tama membuat koneksi SSL ke server dan masuk dengan kata sandi: <br><br><pre><code class="plaintext hljs">$tcpConnection = New-Object System.Net.Sockets.TcpClient($server, $port) $tcpStream = New-Object System.Net.Security.SslStream($tcpConnection.GetStream(),$false,({$True} -as [Net.Security.RemoteCertificateValidationCallback])) $tcpStream.AuthenticateAsClient('127.0.0.1')</code> </pre> <br>  Kemudian, skrip menunggu header yamux 12-byte dan mem-parsingnya. <br>  Ada sedikit nuansa ... Seperti yang ditunjukkan oleh latihan, cukup baca 12 byte dari soket: <br><br><pre> <code class="plaintext hljs"> $num = $tcpStream.Read($tmpbuffer,0,12)</code> </pre> <br>  tidak cukup, karena operasi baca dapat diselesaikan setelah kedatangan hanya sebagian dari byte yang diperlukan.  Karena itu, kita perlu menunggu 12 byte dalam loop: <br><br><pre> <code class="plaintext hljs"> do { try { $num = $tcpStream.Read($tmpbuffer,0,12) } catch {} $tnum += $num $ymxbuffer += $tmpbuffer[0..($num-1)] }while ($tnum -lt 12 -and $tcpConnection.Connected)</code> </pre> <br>  Setelah loop selesai, kita harus menganalisis header 12-byte yang terkandung dalam variabel $ ymxbuffer untuk jenisnya dan mengatur flag sesuai dengan spesifikasi Yamux. <br><br>  Header Yamux dapat terdiri dari beberapa jenis: <br><br><ul><li>  ymx syn - instal aliran baru; </li><li>  penyelesaian aliran sirip ymx; </li><li>  data ymx - merepresentasikan informasi tentang data (ukuran apa dan untuk apa aliran itu dimaksudkan); </li><li>  ymx ping - pesan keepalive; </li><li>  ymx win update - konfirmasi transfer sebagian data; </li></ul><br>  Apa pun yang tidak sesuai dengan jenis header yamux yang terdaftar dianggap sebagai situasi luar biasa.  Ada 10 pengecualian seperti itu, dan kami percaya ada sesuatu yang salah di sini dan kami sedang menyelesaikan pekerjaan modul kami.  <s>(dan juga menghapus semua file kami, menghapus disk, mengubah nama belakang, membuat paspor baru, meninggalkan negara, dll sesuai daftar ...)</s> <br><br>  <b>Membuat utas kaus kaki baru</b> <br><br>  Setelah menerima paket yamux untuk membuat aliran baru, klien kami membuat dua pipa server anonim ($ sipipe, $ sopipe), untuk in / out, masing-masing, menciptakan pipa klien ($ cipipe, $ copipe) berdasarkan pada mereka: <br><br><pre> <code class="plaintext hljs">$sipipe = new-object System.IO.Pipes.AnonymousPipeServerStream(1) $sopipe = new-object System.IO.Pipes.AnonymousPipeServerStream(2,1) $sipipe_clHandle = $sipipe.GetClientHandleAsString() $sopipe_clHandle = $sopipe.GetClientHandleAsString() $cipipe = new-object System.IO.Pipes.AnonymousPipeClientStream(1,$sopipe_clHandle) $copipe = new-object System.IO.Pipes.AnonymousPipeClientStream(2,$sipipe_clHandle)</code> </pre> <br>  membuat runspace untuk aliran kaus kaki, menetapkan variabel bersama untuk berinteraksi dengan aliran ini (StopFlag), dan menjalankan scriptblock SocksScript, yang mengimplementasikan fungsionalitas server kaus kaki dalam aliran terpisah: <br><br><pre> <code class="plaintext hljs">$state = [PSCustomObject]@{"StreamID"=$ymxstream;"inputStream"=$cipipe;"outputStream"=$copipe} $PS = [PowerShell]::Create() $socksrunspace = [runspacefactory]::CreateRunspace() $socksrunspace.Open() $socksrunspace.SessionStateProxy.SetVariable("StopFlag",$StopFlag) $PS.Runspace = $socksrunspace $PS.AddScript($socksScript).AddArgument($state) | Out-Null [System.IAsyncResult]$AsyncJobResult = $null $StopFlag[$ymxstream] = 0 $AsyncJobResult = $PS.BeginInvoke()</code> </pre> <br>  Variabel yang dibuat ditulis ke struktur ArrayList khusus - analog dari Kamus dengan Python <br><br><pre> <code class="plaintext hljs">[System.Collections.ArrayList]$streams = @{}</code> </pre><br>  Penambahan terjadi melalui metode Tambahkan bawaan: <br><br><pre> <code class="plaintext hljs">$streams.add(@{ymxId=$ymxstream;cinputStream=$cipipe;sinputStream=$sipipe;coutputStream=$copipe;soutputStream=$sopipe;asyncobj=$AsyncJobResult;psobj=$PS;readjob=$null;readbuffer=$readbuffer}) | out-null</code> </pre> <br>  <b>Pemrosesan Data Yamux</b> <br><br>  Setelah menerima data yang ditujukan untuk aliran kaus kaki apa pun dari server yamux, kita harus menentukan jumlah aliran yamux (jumlah aliran kaus kaki yang menjadi tujuan data ini) dan jumlah byte data dari header yamux 12-byte: <br><br><pre> <code class="plaintext hljs">$ymxstream = [bitconverter]::ToInt32($buffer[7..4],0) $ymxcount = [bitconverter]::ToInt32($buffer[11..8],0)</code> </pre> <br>  Kemudian, dari aliran ArrayList, menggunakan bidang ymxId, kita mendapatkan handler dari server-pipa sesuai dengan aliran kaus kaki ini: <br><br><pre> <code class="plaintext hljs"> if ($streams.Count -gt 1){$streamind = $streams.ymxId.IndexOf($ymxstream)} else {$streamind = 0} $outStream = $streams[$streamind].soutputStream</code> </pre> <br>  Setelah itu, kita membaca data dari soket, mengingat bahwa kita perlu membaca sejumlah byte melalui loop: <br><br><pre> <code class="plaintext hljs"> $databuffer = $null $tnum = 0 do { if ($buffer.length -le ($ymxcount-$tnum)) { $num = $tcpStream.Read($buffer,0,$buffer.Length) }else { $num = $tcpStream.Read($buffer,0,($ymxcount-$tnum)) } $tnum += $num $databuffer += $buffer[0..($num-1)] }while ($tnum -lt $ymxcount -and $tcpConnection.Connected)</code> </pre> <br>  dan tulis data yang diterima ke pipa yang sesuai: <br><br><pre> <code class="plaintext hljs">$num = $tcpStream.Read($buffer,0,$ymxcount) $outStream.Write($buffer,0,$ymxcount)</code> </pre> <br><br>  <b>Yamux FIN Processing - End Stream</b> <br><br>  Ketika kami menerima paket dari server yamix yang memberi sinyal penutupan aliran, kami juga pertama-tama mendapatkan nomor aliran yamux dari header 12-byte: <br><br><pre> <code class="plaintext hljs"> $ymxstream = [bitconverter]::ToInt32($buffer[7..4],0)</code> </pre> <br>  kemudian, melalui variabel yang dibagikan (atau lebih tepatnya, array bendera, di mana indeksnya adalah nomor aliran yamux), kami memberi tanda agar kaus kaki menyelesaikan: <br><br><pre> <code class="plaintext hljs">if ($streams.Count -gt 1){$streamind = $streams.ymxId.IndexOf($ymxstream)} else {$streamind = 0} if ($StopFlag[$ymxstream] -eq 0){ write-host "stopflag is 0. Setting to 1" $StopFlag[$ymxstream] = 1 }</code> </pre> <br>  setelah mengatur bendera, sebelum membunuh aliran kaus kaki, Anda perlu menunggu sejumlah waktu agar aliran kaus kaki memproses bendera ini.  200 ms sudah cukup untuk ini: <br><br><pre> <code class="plaintext hljs">start-sleep -milliseconds 200 #wait for thread check flag</code> </pre><br>  kemudian tutup semua pipa yang terkait dengan aliran ini, tutup Runspace yang sesuai dan bunuh objek Powershell ke sumber daya gratis: <br><br><pre> <code class="plaintext hljs">$streams[$streamind].cinputStream.close() $streams[$streamind].coutputStream.close() $streams[$streamind].sinputStream.close() $streams[$streamind].soutputStream.close() $streams[$streamind].psobj.Runspace.close() $streams[$streamind].psobj.Dispose() $streams[$streamind].readbuffer.clear()</code> </pre> <br>  Setelah menutup aliran kaus kaki, kita perlu menghapus elemen yang sesuai dari aliran ArrayList: <br><br><pre> <code class="plaintext hljs">$streams.RemoveAt($streamind)</code> </pre> <br>  Dan pada akhirnya, kita perlu memaksa pengumpul sampah .Net untuk melepaskan sumber daya yang digunakan oleh utas.  Jika tidak, skrip kami akan mengkonsumsi sekitar 100-200 MB memori, yang dapat menarik perhatian pengguna yang berpengalaman dan korosif, tetapi kami tidak memerlukan ini: <br><br><pre> <code class="plaintext hljs">[System.GC]::Collect()#clear garbage to minimize memory usage</code> </pre> <br><h3>  Yamux Script - aliran balik </h3><br>  Seperti disebutkan di atas, data yang diterima dari aliran kaus kaki diproses oleh aliran yamuxScript terpisah, yang dimulai dari awal (setelah koneksi yang berhasil ke server).  Tugasnya adalah melakukan polling secara berkala pipa keluaran stream socks yang berlokasi di ArrayList $ stream: <br><pre> <code class="plaintext hljs">foreach ($stream in $state.streams){ ... }</code> </pre> <br>  dan jika ada data di dalamnya, kirimkan ke server yamux, setelah sebelumnya memberikan header yamux 12-byte yang sesuai yang berisi jumlah sesi yamux dan jumlah byte data: <br><br><pre> <code class="plaintext hljs"> if ($stream.readjob -eq $null){ $stream.readjob = $stream.sinputStream.ReadAsync($stream.readbuffer,0,1024) }elseif ( $stream.readjob.IsCompleted ){ #if read asyncjob completed - generate yamux header $outbuf = [byte[]](0x00,0x00,0x00,0x00)+ [bitconverter]::getbytes([int32]$stream.ymxId)[3..0]+ [bitconverter]::getbytes([int32]$stream.readjob.Result)[3..0] $state.tcpstream.Write($outbuf,0,12) #write raw data from socks thread to yamux $state.tcpstream.Write($stream.readbuffer,0,$stream.readjob.Result) $state.tcpstream.flush() #create new readasync job $stream.readjob = $stream.sinputStream.ReadAsync($stream.readbuffer,0,1024) }else{ #write-host "Not readed" }</code> </pre> <br>  YamuxScript juga memonitor flag yang diset pada array $ StopFlag yang dibagikan untuk setiap utas socksScript yang dieksekusi.  Bendera ini dapat diatur ke 2 jika server jauh yang socksScript bekerja dengan terputus.  Dalam situasi ini, informasi tersebut harus dilaporkan kepada klien kaus kaki.  Rangkaiannya adalah sebagai berikut: yamuxScript harus memberi tahu server yamux tentang pemutusan sehingga pada gilirannya memberi sinyal kepada klien kaus kaki. <br><br><pre> <code class="plaintext hljs">if ($StopFlag[$stream.ymxId] -eq 2){ $stream.ymxId | out-file -Append c:\work\log.txt $outbuf = [byte[]](0x00,0x01,0x00,0x04)+ [bitconverter]::getbytes([int32]$stream.ymxId)[3..0]+ [byte[]](0x00,0x00,0x00,0x00) $state.tcpstream.Write($outbuf,0,12) $state.tcpstream.flush() }</code> </pre> <br><h3>  Pembaruan jendela Yamux </h3><br>  Selain itu, yamuxScript harus memantau jumlah byte yang diterima dari server yamux dan secara berkala mengirim Pesan Pembaruan YMX.  Mekanisme di Yamux ini bertanggung jawab untuk memantau dan mengubah apa yang disebut ukuran jendela (mirip dengan protokol TCP) - jumlah byte data yang dapat dikirim tanpa pengakuan.  Secara default, ukuran jendela adalah 256 Kbytes.  Ini berarti bahwa ketika mengirim atau menerima file atau data yang lebih besar dari ukuran ini, kita perlu mengirim paket pembaruan windpw ke server yamux.  Untuk mengontrol jumlah data yang diterima dari server yamux, array khusus $ RcvBytes telah diperkenalkan, di mana arus utama dengan menambah nilai saat ini mencatat jumlah byte yang diterima dari server untuk setiap aliran.  Jika ambang batas yang ditetapkan terlampaui, yamuxScript harus mengirim paket ke server WinUpdate dan mengatur ulang penghitung: <br><br><pre> <code class="plaintext hljs"> if ($RcvBytes[$stream.ymxId] -ge 256144){ #out win update ymx packet with 256K size $outbuf = [byte[]](0x00,0x01,0x00,0x00)+ [bitconverter]::getbytes([int32]$stream.ymxId)[3..0]+ (0x00,0x04,0x00,0x00) $state.tcpstream.Write($outbuf,0,12) $RcvBytes[$stream.ymxId] = 0 }</code> </pre> <br><h3>  Streaming SocksScript </h3><br>  Sekarang mari kita pindah langsung ke socksScript itu sendiri. <br>  Ingat bahwa socksScript dipanggil secara asinkron: <br><br><pre> <code class="plaintext hljs">$state = [PSCustomObject]@{"StreamID"=$ymxstream;"inputStream"=$cipipe;"outputStream"=$copipe} $PS = [PowerShell]::Create() .... $AsyncJobResult = $PS.BeginInvoke()</code> </pre> <br>  dan pada saat panggilan, data berikut hadir dalam variabel $ state yang ditransfer ke aliran: <br><br><ul><li>  $ state.streamId - nomor sesi yamux; </li><li>  $ state.inputStream - baca pipa; </li><li>  $ state.oututStream - tulis pipa; </li></ul><br>  Data dalam pipa datang dalam bentuk mentah tanpa tajuk yamux, mis.  dalam bentuk di mana mereka berasal dari klien kaus kaki. <br><br>  Di dalam socksScript, pertama-tama, kita perlu menentukan versi kaus kaki dan memastikan bahwa itu adalah 5: <br><br><pre> <code class="plaintext hljs">$state.inputStream.Read($buffer,0,2) | Out-Null $socksVer=$buffer[0] if ($socksVer -eq 5){ ... }</code> </pre> <br>  Nah, maka kita melakukan persis seperti yang diterapkan dalam skrip Invoke-SocksProxy.  Satu-satunya perbedaan adalah bahwa alih-alih panggilan <br><br><pre> <code class="plaintext hljs">$AsyncJobResult.AsyncWaitHandle.WaitOne(); $AsyncJobResult2.AsyncWaitHandle.WaitOne();</code> </pre> <br>  Kita perlu memantau koneksi tcp dan flag termination yang sesuai dalam array $ StopFlag dalam mode siklik, jika tidak kita tidak akan dapat mengenali situasi akhir koneksi dari sisi klien kaus kaki dan server ymux: <br><br><pre> <code class="plaintext hljs">while ($StopFlag[$state.StreamID] -eq 0 -and $tmpServ.Connected ){ start-sleep -Milliseconds 50 }</code> </pre> <br>  Jika koneksi berakhir di sisi tcp dari server yang kita hubungkan, kita menetapkan flag ini menjadi 2, yang akan memaksa yamuxscript untuk mengenali ini dan mengirim paket FIN ymx yang sesuai ke server yamux: <br><br><pre> <code class="plaintext hljs">if ($tmpServ.Connected){ $tmpServ.close() }else{ $StopFlag[$state.StreamID] = 2 }</code> </pre> <br>  Kita juga harus mengatur tanda ini jika socksScript tidak dapat terhubung ke server tujuan: <br><br><pre> <code class="plaintext hljs">if($tmpServ.Connected){ ... } else{ $buffer[1]=4 $state.outputStream.Write($buffer,0,2) $StopFlag[$state.StreamID] = 2 }</code> </pre> <br><h3>  Kesimpulan ke bagian kedua </h3><br>  Selama penelitian pengkodean kami, kami dapat membuat klien PowerShell ke server RsocksTun kami dengan kemampuan: <br><br><ul><li>  Koneksi SSL </li><li>  otorisasi di server; </li><li>  bekerja dengan server yamux dengan dukungan untuk ping keepalive; </li><li>  mode operasi multi-utas; </li><li>  dukungan untuk mentransfer file besar; </li></ul><br>  Di luar artikel, ada implementasi fungsi menghubungkan melalui server proxy dan otorisasi di atasnya, serta mengubah skrip kami menjadi versi inline, yang dapat dijalankan dari baris perintah.  Itu akan berada di bagian ketiga. <br><br>  Itu saja untuk hari ini.  Seperti yang mereka katakan - berlangganan, seperti, tinggalkan komentar (terutama mengenai pemikiran Anda tentang peningkatan kode dan penambahan fungsionalitas). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453970/">https://habr.com/ru/post/id453970/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453958/index.html">Monorepositori: tolong</a></li>
<li><a href="../id453960/index.html">Global DevOps Bootcamp 2019 di Moskow</a></li>
<li><a href="../id453962/index.html">RxSwift dan Coroutines di Kotlin - pengembangan ponsel opsional dari AGIMA dan GeekBrains</a></li>
<li><a href="../id453964/index.html">OOP dalam bahasa R (bagian 1): kelas S3</a></li>
<li><a href="../id453968/index.html">Hapus praktik tinjauan kode beracun</a></li>
<li><a href="../id453972/index.html">Para arkeolog membuat kembali pin berusia dua ribu tahun menggunakan pencetakan dan pemindaian 3D</a></li>
<li><a href="../id453974/index.html">Persaingan sistem-ML pada materi linguistik. Bagaimana kita belajar mengisi kekosongan</a></li>
<li><a href="../id453976/index.html">Program pendidikan ekonomi untuk spesialis TI</a></li>
<li><a href="../id453978/index.html">Printer 3D konstruksi MIT mencetak bangunan dalam 14 jam</a></li>
<li><a href="../id453980/index.html">Mencetak label dan label harga untuk toko online .net</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>