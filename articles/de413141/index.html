<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè© üíáüèø üéÅ Klassifizieren Sie gro√üe Datenmengen in Apache Spark mithilfe beliebiger Modelle f√ºr maschinelles Lernen üë∏üèø üè≠ ü§Ωüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teil 2: L√∂sung 
 Hallo nochmal! Heute werde ich meine Geschichte dar√ºber fortsetzen, wie wir gro√üe Datenmengen in Apache Spark mithilfe beliebiger Mod...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Klassifizieren Sie gro√üe Datenmengen in Apache Spark mithilfe beliebiger Modelle f√ºr maschinelles Lernen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lanit/blog/413141/"><h2>  Teil 2: L√∂sung </h2><br>  Hallo nochmal!  Heute werde ich meine Geschichte dar√ºber fortsetzen, wie wir gro√üe Datenmengen in Apache Spark mithilfe beliebiger Modelle f√ºr maschinelles Lernen klassifizieren.  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Teil des Artikels haben</a> wir die Darstellung des Problems selbst sowie die Hauptprobleme untersucht, die bei der Organisation der Interaktion zwischen dem Cluster, in dem die Anfangsdaten gespeichert und verarbeitet werden, und dem externen Klassifizierungsdienst auftreten.  Im zweiten Teil werden wir eine der Optionen zur L√∂sung dieses Problems mithilfe des Reactive Streams-Ansatzes und seiner Implementierung mithilfe der akka-Streams-Bibliothek betrachten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6m/bg/fu/6mbgfuuatqlimwnapnl3tlrzn8q.png"></div><a name="habracut"></a><br><h3>  Konzept f√ºr reaktive Streams </h3><br>  Um die im ersten Teil beschriebenen Probleme zu l√∂sen, k√∂nnen Sie den Ansatz <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reactive Streams verwenden</a> .  Sie k√∂nnen damit den Prozess der √úbertragung von Datenstr√∂men zwischen Verarbeitungsstufen steuern, die mit unterschiedlichen Geschwindigkeiten und unabh√§ngig voneinander arbeiten, ohne dass eine Pufferung erforderlich ist.  Wenn eine der Verarbeitungsstufen langsamer als die vorherige ist, muss der schnelleren Stufe signalisiert werden, wie viele Eingabedaten derzeit verarbeitet werden k√∂nnen.  Diese Wechselwirkung nennt man Gegendruck.  Es besteht in der Tatsache, dass die schnelleren Stufen genau so viele Elemente verarbeiten, wie f√ºr die langsamere Stufe erforderlich sind, und nicht mehr, und dann Rechenressourcen freisetzen. <br><br>  Im Allgemeinen ist Reactive Streams eine Spezifikation f√ºr die Implementierung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Publisher-Subscriber-</a> Vorlage.  Diese Spezifikation definiert einen Satz von vier Schnittstellen (Publisher, Subscriber, Processor und Subscription) und einen Vertrag f√ºr deren Methoden. <br><br>  Betrachten wir diese Schnittstellen genauer: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscriber&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; s)</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscription s)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscription</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Processor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre> <br>  Das Publisher-Subscriber-Modell hat zwei Seiten: Senden und Empfangen.  Bei der Implementierung von Reactive Streams ist die Klasse, die die Publisher-Schnittstelle implementiert, f√ºr die Daten√ºbertragung und der Abonnent f√ºr den Empfang verantwortlich.  Um die Kommunikation zwischen ihnen herzustellen, muss der Abonnent durch Aufrufen seiner Abonnementmethode bei Publisher registriert sein.  Gem√§√ü der Spezifikation muss der Publisher nach der Registrierung eines Abonnenten seine Methoden in der folgenden Reihenfolge aufrufen: <br><br><ol><li>  onSubscribe.  Diese Methode wird unmittelbar nach der Registrierung des Abonnenten bei Publisher aufgerufen.  Als Parameter wird ein Abonnementobjekt an dieses √ºbergeben, √ºber das der Abonnent Daten vom Publisher anfordert.  Dieses Objekt sollte nur im Kontext dieses Abonnenten gespeichert und aufgerufen werden. </li><li>  Nachdem der Abonnent Daten von Publisher angefordert hat, indem er die Anforderungsmethode f√ºr das entsprechende Abonnementobjekt aufruft, kann Publisher die Methode Subscriber onNext aufrufen und das n√§chste Element √ºbergeben. </li><li>  Der Abonnent kann dann die Anforderungsmethode f√ºr das Abonnement regelm√§√üig aufrufen, aber der Publisher kann die onNext-Methode nicht mehr als die √ºber die Anforderungsmethode angeforderte Summe aufrufen. </li><li>  Wenn der Datenstrom endlich ist, muss Publisher nach dem √úbergeben aller Elemente durch die onNext-Methode die onComplete-Methode aufrufen. </li><li>  Wenn in Publisher ein Fehler aufgetreten ist und eine weitere Verarbeitung der Elemente nicht m√∂glich ist, sollte die onError-Methode aufgerufen werden </li><li>  Nach dem Aufrufen der Methoden onComplete oder onError sollte die weitere Interaktion des Publishers mit dem Abonnenten ausgeschlossen werden. </li></ol><br>  Methodenaufrufe k√∂nnen als Sendesignale zwischen Publisher und Subscriber betrachtet werden.  Der Abonnent signalisiert dem Publisher, wie viele Elemente verarbeitet werden k√∂nnen, und der Publisher signalisiert ihm wiederum, dass entweder das n√§chste Element vorhanden ist oder keine weiteren Elemente vorhanden sind oder ein Fehler aufgetreten ist. <br><br>  Um einen weiteren Einfluss von Publisher und Subscriber auf einander auszuschlie√üen, d√ºrfen Aufrufe aller Methoden, die Reactive Streams-Schnittstellen implementieren, nicht blockierend sein.  In diesem Fall ist die Interaktion zwischen ihnen vollst√§ndig asynchron. <br><br>  Weitere Details zur Spezifikation f√ºr Reactive Streams-Schnittstellen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Durch Verkn√ºpfen des urspr√ºnglichen und der resultierenden Iteratoren durch Konvertieren in Publisher bzw. Subscriber k√∂nnen wir die im vorherigen Teil des Artikels identifizierten Probleme l√∂sen.  Das Problem des Puffer√ºberlaufs zwischen den Stufen wird gel√∂st, indem eine bestimmte Anzahl von Elementen vom Abonnenten angefordert wird.  Das Problem des erfolgreichen oder erfolglosen Abschlusses wird gel√∂st, indem Signale √ºber die Methoden onComplete bzw. onError an den Abonnenten gesendet werden.  Der Publisher ist f√ºr das Senden dieser Signale verantwortlich. In unserem Fall muss gesteuert werden, wie viele HTTP-Anforderungen gesendet wurden und wie viele von ihnen Antworten erhalten haben.  Nachdem die letzte Antwort empfangen und alle darin enthaltenen Ergebnisse verarbeitet wurden, sollte ein onComplete-Signal gesendet werden.  Falls eine der Anforderungen fehlschl√§gt, sollte sie ein onError-Signal senden und das Senden weiterer Elemente an den Abonnenten beenden sowie Elemente vom urspr√ºnglichen Iterator subtrahieren. <br><br>  Der resultierende Iterator sollte als Abonnent implementiert werden.  In diesem Fall k√∂nnen wir nicht auf einen Puffer verzichten, in den Elemente geschrieben werden, wenn die onNext-Methode von der Subscriber-Schnittstelle aufgerufen und mit der hasNext- und der next-Methode von der Iterator-Schnittstelle subtrahiert wird.  Als Pufferimplementierung k√∂nnen Sie eine Blockierungswarteschlange verwenden, z. B. LinkedBlockedQueue. <br><br>  Ein aufmerksamer Leser wird sofort die Frage stellen: Warum befindet sich die Blockierungswarteschlange, da gem√§√ü der Reactive Streams-Spezifikation die Implementierung aller Methoden nicht blockierend sein sollte?  Aber hier ist alles in Ordnung: Da wir Publisher nach einer genau definierten Anzahl von Elementen fragen, wird die onNext-Methode nicht √∂fter aufgerufen, und die Warteschlange kann jederzeit ein neues Element hinzuf√ºgen, ohne es zu blockieren. <br><br>  Andererseits kann es zu einer Blockierung kommen, wenn die hasNext-Methode im Falle einer leeren Warteschlange aufgerufen wird.  Dies ist jedoch in Ordnung: Die hasNext-Methode ist nicht Bestandteil des Vertrags der Subscriber-Schnittstelle, sondern wird in der Iterator-Schnittstelle definiert, die, wie bereits erl√§utert, eine blockierende Datenstruktur darstellt.  Wenn wir die n√§chste Methode aufrufen, subtrahieren wir das n√§chste Element von der Warteschlange, und wenn seine Gr√∂√üe einen bestimmten Schwellenwert unterschreitet, m√ºssen wir den n√§chsten Teil der Elemente durch einen Aufruf der Anforderungsmethode anfordern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tz/xy/8t/tzxy8tn05km8fox0bkwk_zsxvcg.png" width="650"></div>  <i>Abbildung 7. Asynchrone Interaktion mit einem externen Dienst unter Verwendung des Reactive Streams-Ansatzes</i> <br><br>  In diesem Fall werden wir blockierende Anrufe nat√ºrlich nicht vollst√§ndig los.  Dies wird durch eine Nicht√ºbereinstimmung der Paradigmen zwischen reaktiven Streams, die eine vollst√§ndig asynchrone Interaktion voraussetzen, und einem Iterator verursacht, der beim Aufrufen der hasNext-Methode trueN oder false aufrufen muss.  Im Gegensatz zur synchronen Interaktion mit einem externen Dienst k√∂nnen Ausfallzeiten aufgrund von Sperren durch Erh√∂hen der Gesamtlast der Prozessorkerne erheblich reduziert werden. <br><br>  Es w√§re praktisch, wenn Apache Spark-Entwickler in zuk√ºnftigen Versionen ein Analogon der mapPartitions-Methode implementieren w√ºrden, die mit Publisher und Subscriber funktioniert.  Dies w√ºrde eine vollst√§ndig asynchrone Interaktion erm√∂glichen und somit die M√∂glichkeit des Blockierens von Threads ausschlie√üen. <br><br><h3>  Akka-Streams und Akka-http als Implementierung der Reactive Streams-Spezifikation </h3><br>  Derzeit gibt es bereits mehr als ein Dutzend Implementierungen der Reactive Streams-Spezifikation.  Eine solche Implementierung ist das Akka-Streams-Modul aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Akka-</a> Bibliothek.  In der Welt von JVM hat sich akka als eines der effektivsten Mittel zum Schreiben paralleler und verteilter Systeme etabliert.  Dies wird durch die Tatsache erreicht, dass das Grundprinzip, das in seiner Grundlage festgelegt ist, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Akteurmodell ist</a> , mit dem Sie wettbewerbsf√§hige Anwendungen ohne direkte Kontrolle √ºber Threads und deren Pools schreiben k√∂nnen. <br><br>  Es wurde viel Literatur √ºber die Umsetzung des Konzepts der Akteure in Akka geschrieben, daher werden wir hier nicht aufh√∂ren (die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offizielle Website von Akka</a> ist eine sehr gute Informationsquelle, ich empfehle auch die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Akka im Aktionsbuch</a> ).  Hier werden wir uns die technologische Seite der Implementierung im Rahmen der JVM genauer ansehen. <br><br>  Im Allgemeinen existieren Akteure nicht f√ºr sich, sondern bilden ein hierarchisches System.  Um ein Akteursystem zu erstellen, m√ºssen Sie Ressourcen daf√ºr zuweisen. Der erste Schritt bei der Arbeit mit akka besteht darin, eine Instanz des ActorSystem-Objekts zu erstellen.  Beim Start von ActorSystem wird ein separater Thread-Pool namens Dispatcher erstellt, in dem der gesamte in den Akteuren definierte Code ausgef√ºhrt wird.  In der Regel f√ºhrt ein einzelner Thread den Code mehrerer Akteure aus. Bei Bedarf k√∂nnen Sie jedoch einen separaten Dispatcher f√ºr eine bestimmte Gruppe von Akteuren konfigurieren (z. B. f√ºr Akteure, die direkt mit einer blockierenden API interagieren). <br><br>  Eine der h√§ufigsten Aufgaben, die mit Akteuren gel√∂st werden, ist die sequentielle Verarbeitung von Datenstr√∂men.  Zuvor war es daf√ºr erforderlich, Ketten von Akteuren manuell zu erstellen und sicherzustellen, dass keine Engp√§sse zwischen ihnen bestehen (wenn beispielsweise ein Akteur Nachrichten schneller als der n√§chste verarbeitet, kann es zu einem √úberlauf der Warteschlange f√ºr eingehende Nachrichten kommen, was zu einem OutOfMemoryError-Fehler f√ºhrt). <br><br>  Ab Version 2.4 wurde akka das Modul akka-streams hinzugef√ºgt, mit dem Sie den Datenverarbeitungsprozess deklarativ definieren und anschlie√üend die erforderlichen Akteure f√ºr seine Ausf√ºhrung erstellen k√∂nnen.  Akka-Streams implementiert auch das Prinzip des Gegendrucks, wodurch die M√∂glichkeit eines √úberlaufens der Warteschlange eingehender Nachrichten f√ºr alle an der Verarbeitung beteiligten Akteure ausgeschlossen wird. <br><br>  Die Hauptelemente zum Definieren des Datenflussverarbeitungsschemas in Akka-Streams sind Source, Flow und Sink.  Durch die Kombination erhalten wir ein ausf√ºhrbares Diagramm.  Um den Verarbeitungsprozess zu starten, wird ein Materializer verwendet, der Akteure erstellt, die gem√§√ü dem von uns definierten Diagramm (der Materializer-Schnittstelle und ihrer Implementierung ActorMaterializer) arbeiten. <br><br>  Betrachten wir die Phasen Quelle, Fluss und Senke genauer.  Quelle definiert die Datenquelle.  Akka-Streams unterst√ºtzt √ºber ein Dutzend verschiedene M√∂glichkeiten zum Erstellen von Quellen, einschlie√ülich eines Iterators: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> featuresSource: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">Array</span></span>[<span class="hljs-type"><span class="hljs-type">Float</span></span>], <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = <span class="hljs-type"><span class="hljs-type">Source</span></span>.fromIterator { () =&gt; featuresIterator }</code> </pre><br>  Die Quelle kann auch durch Konvertieren einer vorhandenen Quelle erhalten werden: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newSource: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = source.map(item =&gt; transform(item))</code> </pre> <br>  Wenn die Transformation eine nicht triviale Operation ist, kann sie als Flow-Entit√§t dargestellt werden.  Akka-Streams unterst√ºtzen viele verschiedene M√∂glichkeiten, um Flow zu erstellen.  Der einfachste Weg ist, aus einer Funktion zu erstellen: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someFlow: <span class="hljs-type"><span class="hljs-type">Flow</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = <span class="hljs-type"><span class="hljs-type">Flow</span></span>.fromFunction((x: <span class="hljs-type"><span class="hljs-type">String</span></span>) =&gt; x.length)</code> </pre> <br>  Durch die Kombination von Quelle und Fluss erhalten wir eine neue Quelle. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newSource: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = oldSource.via(someFlow)</code> </pre> <br>  Die Sp√ºle wird als letzte Stufe der Datenverarbeitung verwendet.  Wie im Fall von Source bietet akka-stream mehr als ein Dutzend verschiedene Sink-Optionen. Beispielsweise f√ºhrt Sink.foreach f√ºr jedes Element eine bestimmte Operation aus, Sink.seq sammelt alle Elemente in einer Sammlung usw. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> printSink: <span class="hljs-type"><span class="hljs-type">Sink</span></span>[<span class="hljs-type"><span class="hljs-type">Any</span></span>, <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Done</span></span>]] = <span class="hljs-type"><span class="hljs-type">Sink</span></span>.foreach(println)</code> </pre> <br>  Quelle, Durchfluss und Senke werden durch die Arten von Eingabe- und / oder Ausgabeelementen parametrisiert.  Dar√ºber hinaus kann jede Verarbeitungsstufe ein Ergebnis ihrer Arbeit haben.  Zu diesem Zweck werden Quelle, Durchfluss und Senke auch durch einen zus√§tzlichen Typ parametrisiert, der das Ergebnis der Operation bestimmt.  Dieser Typ wird als Typ des materialisierten Werts bezeichnet.  Wenn die Operation nicht das Vorhandensein eines zus√§tzlichen Ergebnisses ihrer Arbeit impliziert, z. B. wenn wir den Durchfluss durch eine Funktion definieren, wird der Typ NotUsed als materialisierter Wert verwendet. <br><br>  Durch die Kombination von Source, Flow und Sink erhalten wir RunnableGraph.  Es wird durch einen Typ parametrisiert, der den Werttyp bestimmt, der als Ergebnis der Ausf√ºhrung dieses Diagramms erhalten wird.  Bei Bedarf k√∂nnen Sie beim Kombinieren der Stufen angeben, welches der Stufen das Ergebnis des gesamten Operationsdiagramms sein soll.  Standardm√§√üig wird das Ergebnis der Quellstufe verwendet: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> graph: <span class="hljs-type"><span class="hljs-type">RunnableGraph</span></span>[<span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = someSource.to(<span class="hljs-type"><span class="hljs-type">Sink</span></span>.foreach(println))</code> </pre> <br>  Wenn jedoch das Ergebnis der Sink-Phase f√ºr uns wichtiger ist, m√ºssen wir dies ausdr√ºcklich angeben: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> graph: <span class="hljs-type"><span class="hljs-type">RunnableGraph</span></span>[<span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Done</span></span>]] = someSource.toMat(<span class="hljs-type"><span class="hljs-type">Sink</span></span>.foreach(println))(<span class="hljs-type"><span class="hljs-type">Keep</span></span>.right)</code> </pre><br>  Nachdem wir den Operationsgraphen definiert haben, m√ºssen wir ihn ausf√ºhren.  Dazu muss runnableGraph die run-Methode aufrufen.  Als Parameter verwendet diese Methode ein ActorMaterializer-Objekt (das sich auch in einem impliziten Bereich befinden kann), das f√ºr die Erstellung von Akteuren verantwortlich ist, die Operationen ausf√ºhren.  In der Regel wird ein ActorMaterializer unmittelbar nach der Erstellung eines ActorSystems erstellt, das an seinen Lebenszyklus angeh√§ngt ist, und verwendet es zum Erstellen von Akteuren.  Betrachten Sie ein Beispiel: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//   ActorSystem,       implicit val system = ActorSystem(‚Äúsystem name‚Äù) // ,       ActorSystem implicit val materializer = ActorMaterializer() //    ,       Sink val graph: RunnableGraph[Future[immutable.Seq[Int]]] = Source.fromIterator(() =&gt; (1 to 10).iterator).toMat(Sink.seq)(Keep.right) //   ,    implicit scope. val result: Future[immutable.Seq[Int]] = graph.run()</span></span></code> </pre><br>  Bei einfachen Kombinationen k√∂nnen Sie auf einen separaten RunnableGraph verzichten, aber einfach Source mit Sink verbinden und diese starten, indem Sie die runWith-Methode f√ºr Source aufrufen.  Diese Methode setzt auch voraus, dass ein ActorMaterializer-Objekt im impliziten Bereich vorhanden ist.  In diesem Fall wird au√üerdem der in Sink definierte materialisierte Wert verwendet.  Mit dem folgenden Code k√∂nnen wir beispielsweise Source in Publisher aus der Reactive Streams-Spezifikation konvertieren: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> source: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">Score</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = <span class="hljs-type"><span class="hljs-type">Source</span></span>.fromIterator(() =&gt; sourceIterator).map(item =&gt; transform(item)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> publisher: <span class="hljs-type"><span class="hljs-type">Publisher</span></span>[<span class="hljs-type"><span class="hljs-type">Score</span></span>] = source.runWith(<span class="hljs-type"><span class="hljs-type">Sink</span></span>.asPublisher(<span class="hljs-literal"><span class="hljs-literal">false</span></span>))</code> </pre><br>  Nun haben wir gezeigt, wie Sie Reactive Streams Publisher erhalten k√∂nnen, indem Sie eine Quelle aus dem Quelliterator erstellen und einige Transformationen an seinen Elementen durchf√ºhren.  Jetzt k√∂nnen wir es einem Abonnenten zuordnen, der dem resultierenden Iterator Daten liefert.  Es bleibt die letzte Frage zu pr√ºfen: Wie organisiert man die HTTP-Interaktion mit einem externen Dienst? <br><br>  Die Struktur von akka umfasst das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://doc.akka.io/docs/akka-">akka-http-</a> Modul, mit dem Sie die asynchrone, nicht blockierende Kommunikation √ºber HTTP organisieren k√∂nnen.  Dar√ºber hinaus basiert dieses Modul auf Akka-Streams, mit denen Sie die HTTP-Interaktion als zus√§tzlichen Schritt im Diagramm der Datenflussverarbeitungsvorg√§nge hinzuf√ºgen k√∂nnen. <br><br>  Um eine Verbindung zu externen Diensten herzustellen, bietet akka-http drei verschiedene Schnittstellen. <br><br><ol><li>  API auf Anforderungsebene - ist die einfachste Option f√ºr den Fall einzelner Anforderungen an einen beliebigen Computer.  Auf dieser Ebene werden HTTP-Verbindungen vollst√§ndig automatisch verwaltet, und bei jeder Anforderung muss die vollst√§ndige Adresse des Computers √ºbertragen werden, an den die Anforderung gesendet wird. </li><li>  Host-Level-API - geeignet, wenn wir wissen, auf welchen Port auf welchem ‚Äã‚ÄãComputer wir zugreifen werden.  In diesem Fall √ºbernimmt akka-http die Kontrolle √ºber den Pool von HTTP-Verbindungen. Bei Anforderungen reicht es aus, den relativen Pfad zur angeforderten Ressource anzugeben. </li><li>  API auf Verbindungsebene - Erm√∂glicht Ihnen die vollst√§ndige Kontrolle √ºber die Verwaltung von HTTP-Verbindungen, dh das √ñffnen, Schlie√üen und Verteilen von Anforderungen √ºber Verbindungen. </li></ol><br>  In unserem Fall ist uns die Adresse des Klassifizierungsdienstes im Voraus bekannt, daher ist es erforderlich, die HTTP-Interaktion nur mit diesem bestimmten Computer zu organisieren.  Daher ist die Host-Level-API f√ºr uns am besten geeignet.  Lassen Sie uns nun sehen, wie der Pool von HTTP-Verbindungen bei Verwendung erstellt wird: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> httpFlow: <span class="hljs-type"><span class="hljs-type">Flow</span></span>[(<span class="hljs-type"><span class="hljs-type">HttpRequest</span></span>,<span class="hljs-type"><span class="hljs-type">Id</span></span>), (<span class="hljs-type"><span class="hljs-type">Try</span></span>[<span class="hljs-type"><span class="hljs-type">HttpResponse</span></span>],<span class="hljs-type"><span class="hljs-type">Id</span></span>), <span class="hljs-type"><span class="hljs-type">Http</span></span>.<span class="hljs-type"><span class="hljs-type">HostConnectionPool</span></span>] = <span class="hljs-type"><span class="hljs-type">Http</span></span>().cachedHostConnectionPool[<span class="hljs-type"><span class="hljs-type">Id</span></span>](hostAddress, portNumber)</code> </pre><br>  Beim Aufruf von Http (). CachedHostConnectionPool [T] (hostAddress, portNumber) im ActorSystem, das sich in einem impliziten Bereich befindet, werden Ressourcen zugewiesen, um einen Verbindungspool zu erstellen, aber die Verbindungen selbst werden nicht hergestellt.  Als Ergebnis dieses Aufrufs wird Flow zur√ºckgegeben, der ein Paar einer HTTP-Anforderung und eines ID-Identifikationsobjekts als Eingabe empf√§ngt.  Das Identifikationsobjekt wird ben√∂tigt, um die Anforderung mit der entsprechenden Antwort abzugleichen, da der akka-http-HTTP-Aufruf eine asynchrone Operation ist und die Reihenfolge, in der die Antworten empfangen werden, nicht unbedingt der Reihenfolge entspricht, in der die Anforderungen gesendet werden.  Daher gibt Flow am Ausgang ein paar Ergebnisse der Abfrage und das entsprechende Identifikationsobjekt aus. <br><br>  Direkt werden HTTP-Verbindungen hergestellt, wenn ein Diagramm (einschlie√ülich dieses Flusses) gestartet (materialisiert) wird.  Akka-http ist so implementiert, dass innerhalb eines ActorSystems immer ein gemeinsamer Pool von HTTP-Verbindungen vorhanden ist, der von allen Materialisierungen verwendet wird, unabh√§ngig davon, wie oft die Diagramme mit httpFlow materialisiert wurden.  Auf diese Weise k√∂nnen Sie die Verwendung von Netzwerkressourcen besser steuern und eine √úberlastung vermeiden. <br><br>  Somit ist der Lebenszyklus des HTTP-Verbindungspools an das ActorSystem gebunden.  Wie bereits erw√§hnt, ist auch der Lebenszyklus des Thread-Pools damit verbunden, in dem die in den Akteuren definierten Operationen (oder in unserem Fall als die Stufen akka-Streams und akka-http definiert) ausgef√ºhrt werden.  Um maximale Effizienz zu erzielen, m√ºssen wir daher eine Instanz von ActorSystem innerhalb desselben JVM-Prozesses wiederverwenden. <br><br><h3>  Alles zusammen: Ein Beispiel f√ºr die Implementierung der Interaktion mit dem Klassifizierungsdienst </h3><br>  Jetzt k√∂nnen wir mit der Klassifizierung gro√üer Mengen verteilter Daten in Apache Spark mithilfe der asynchronen Interaktion mit externen Diensten fortfahren.  Das allgemeine Schema dieser Wechselwirkung wurde bereits in Abbildung 7 gezeigt. <br><br>  Angenommen, wir haben einen anf√§nglichen Datensatz [Features] definiert.  Wenn Sie die mapPartitions-Operation darauf anwenden, sollten Sie einen Datensatz erhalten, in dem jede ID aus dem Quellensatz mit einem bestimmten Wert versehen ist, der als Ergebnis der Klassifizierung erhalten wurde (Datensatz [Score]).  Um die asynchrone Verarbeitung auf Executoren zu organisieren, m√ºssen wir die Quelle und die resultierenden Iteratoren in Publisher bzw. Subscriber aus der Reactive Streams-Spezifikation umschlie√üen und miteinander verkn√ºpfen. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Features</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, vector: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Score</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, score: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">1</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">batchesRequestCount</span></span></span><span class="hljs-class"> </span></span>= config.getInt(‚ÄúscoreService. batchesRequestCount‚Äù)<span class="hljs-comment"><span class="hljs-comment">//(2) //... val scoreDs: Dataset[Score] = featuresDs.mapPartitions { fi: Iterator[Features] =&gt; val publisher: Publisher[Iterable[Score]] = createPublisher(fi) //(3) val iteratorSubscriber: Iterator[Score] = new IteratorSubscriber(batchesRequestCount) //(4) publisher.subscribe(batchesRequestCount) //(5) iteratorSubscriber //(6) }</span></span></code> </pre> <br>  Bei dieser Implementierung wird ber√ºcksichtigt, dass der Klassifizierungsdienst f√ºr einen Aufruf eine Gruppe von Merkmalsvektoren gleichzeitig verarbeiten kann. Daher ist das Klassifizierungsergebnis nach einem Aufruf auch sofort f√ºr die gesamte Gruppe verf√ºgbar.  Daher haben wir als Parametertyp f√ºr Publisher nicht nur Score, wie Sie vielleicht erwarten, sondern Iterable [Score].  Daher senden wir die Klassifizierungsergebnisse f√ºr diese Gruppe durch einen einzelnen Aufruf der onNext-Methode an den resultierenden Iterator (der auch ein Abonnent ist).  Dies ist viel effizienter als der Aufruf von onNext f√ºr jedes Element.  Jetzt werden wir diesen Code genauer analysieren. <br><br><ol><li>  Wir bestimmen die Struktur der Eingabe- und Ausgabedaten.  Als Eingabe haben wir eine Reihe von ID-Bezeichnern mit einem Merkmalsvektor, und als Ausgabe haben wir eine Reihe von Bezeichnern mit einem numerischen Wert, der als Ergebnis der Klassifizierung erhalten wird. </li><li>  Wir bestimmen die Anzahl der Gruppen, die der Abonnent gleichzeitig vom Publisher anfordert.  Da davon ausgegangen wird, dass diese Werte im Puffer liegen und warten, bis sie aus dem resultierenden Iterator gelesen werden, h√§ngt dieser Wert von der dem Executor zugewiesenen Speichermenge ab. </li><li>  Erstellen Sie Publisher aus dem Quelliterator.  Er ist f√ºr die Interaktion mit dem Klassifizierungsdienst verantwortlich.  Die Funktion createPublisher wird unten erl√§utert. </li><li>  Erstellen Sie einen Abonnenten, der der resultierende Iterator ist.  Der IteratorSubscriber-Klassencode ist ebenfalls unten angegeben. </li><li>  Abonnenten beim Publisher registrieren. </li><li>  Gibt IteratorSubscriber als Ergebnis der mapPartitions-Operation zur√ºck. </li></ol><br>  Betrachten Sie nun die Implementierung der Funktion createPublisher. <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ids</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] <span class="hljs-comment"><span class="hljs-comment">//(1) val batchSize = config.getInt("scoreService.batchSize") val parallelismLevel = config.getInt("scoreService.parallelismLevel") //(2) //... def createPublisher(fi: Iterator[Features]): Publisher[Iterable[Score]] = { import ActorSystemHolder._ //(3) Source .fromIterator(() =&gt; fi) //(4) .grouped(batchSize) //(5) .map { groupedFeatures: Seq[Features] =&gt; val request: (HttpRequest, Ids) = createHttpRequest(groupedFeatures) //(6) logger.debug(s"Sending request for the first id: ${request._2(0)}") request } .via(httpFlow) //(7) .flatMapMerge(parallelismLevel, { //(8) case (Success(response), ids) if response.status.isSuccess() =&gt; logger.debug(s"Processing successful result for the first id: ${ids(0)}") val resultSource: Source[Iterable[Score], _] = response.entity.dataBytes.reduce(_ ++ _).map { responseBytes =&gt; processSuccessfulResponse(responseBytes, ids) } //(9) resultScore case (Success(response), ids) =&gt; logger.warn( s"Failed result for the first id: ${ids(0)}, HTTP status: ${response.status}" ) response.discardEntityBytes() Source.failed( new IOException(s"Non-successful HTTP status: ${response.status}") ) //(10) case (Failure(ex), ids) =&gt; logger.warn(s"Failed result: an exception has occured", ex) Source.failed(ex) //(11) }) .runWith(Sink.asPublisher(false)) //(12) } def createHttpRequest(featuresSeq: Seq[Features]): (HttpRequest, ProfileIds) = { val requestBytes: Array[Byte] = featuresToMatrixBytes(featuresSeq) val ids: ProfileIds = extractIds(featuresSeq) val httpRequest = HttpRequest( method = HttpMethods.PUT, uri = "/score", entity = requestBytes ) httpRequest -&gt; ids }</span></span></code> </pre><br><ol><li>    -   ,   .         httpFlow,           . </li><li>     :     ,     (batchSize)        (parallelismLevel). </li><li>   implicit scope ActorSystem, ActorMaterializer  httpFlow.        Spark-.  ActorSystemHolder    . </li><li>     akka-streams   .     Source[Features]   . </li><li>            batchSize       . </li><li>     HttpRequest       .   HttpRequest      createHttpRequest.      createPublisher.      feature-,   ,      (            predict).       ,      HTTP-.      ,   HTTP-,    HTTP-, URI      . </li><li>        httpFlow. </li><li>     ,   .      flatMapMerge,        akka-http    Source[ByteString],      ,       .           .  parallelismLevel ,      (     ).      HTTP-:   ,  ,  ,   . </li><li>       :          .      akka    ByteString.    ,    ByteString    O(1),    ByteString        .       ,    ,         .                ,     . </li><li>       HTTP-     ,  Stream .         ,      discardEntityBytes    ,    ,  . </li><li>         .      akka-http    ,       . </li><li>       ,    Publisher,     .    ,    .  false   Sink.asPublisher ,   Publisher    Subscriber-. </li></ol><br>      ,    akka  ActorSystem,        .  ,        Spark ,          .   Spark    JVM , ,        ,     ActorSystem    ActorMatrializer  httpFlow. <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActorSystemHolder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> actorSystem: <span class="hljs-type"><span class="hljs-type">ActorSystem</span></span> = { <span class="hljs-comment"><span class="hljs-comment">//(1) val actorSystemName = s"score-service-client" logger.debug(s"Creating actor system $actorSystemName") val as = ActorSystem(actorSystemName) //(2) logger.debug("Adding shutdown hook for the actor system") scala.sys.addShutdownHook { //(3) logger.debug(s"Terminating actor system $actorSystemName") Await.result(as.terminate(), 30.seconds) //to Mars :) logger.debug(s"The actor system $actorSystemName has been terminated") } as } implicit lazy val materializer: ActorMaterializer = { //(4) logger.debug(s"Creating actor materializer for actor system ${actorSystem.name}") ActorMaterializer() } lazy val httpFlow: Flow[ (HttpRequest,ProfileIds), (Try[HttpResponse], ProfileIds), Http.HostConnectionPool] = { //(5) val httpFlowSettings = ConnectionPoolSettings(actorSystem) logger.debug(s"Creating http flow with settings $httpFlowSettings") Http().cachedHostConnectionPool[ProfileIds]( config.getString("scoreService.host"), config.getInt("scoreService.int"), settings = httpFlowSettings ) } }</span></span></code> </pre><br><ol><li>     ,   ,       ,     . </li><li>    ActorSystem   . </li><li>  ,     ,    ActorSystem,       terminate, ,   ,   ,     .      ,     JVM-. </li><li>    ActorMaterializer,      akka-streams,   ActorSystem. </li><li> ,   httpFlow     .      ,       HTTP-   ActorSystem. </li></ol><br>       Subscriber-    HTTP-. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[+</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span><span class="hljs-class">[+</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">item: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Done</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Failure</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">cause: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">1</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StreamErrorCompletionException</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">cause: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">cause</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">2</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IteratorSubscriber</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">requestSize: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Iterable</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">]] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterator</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//(3) private val buffer: BlockingQueue[QueueItem[Iterable[T]]] = new LinkedBlockingQueue[QueueItem[Iterable[T]]]() //(4) private var expecting: Int = 0 //(5) private val subscriptionPromise: Promise[Subscription] = Promise() private lazy val subscription: Subscription = Await.result(subscriptionPromise.future, 5.minutes) //(6) private var currentIterator: Iterator[T] = Iterator.empty //(7) private var isDone = false //(8) override def onSubscribe(s: Subscription): Unit = { subscriptionPromise.success(s) //(9) logger.trace("The iterator has been subscribed") } override def onNext(t: Iterable[T]): Unit = { logger.trace("Putting a next batch to the buffer") buffer.put(Item(t)) //(10) } override def onComplete(): Unit = { logger.debug("The stream has been succesfully completed") buffer.put(Done) //(11) } override def onError(t: Throwable): Unit = { logger.warn("The stream has been completed with error", t) buffer.put(Failure(t)) //(12) } override def hasNext: Boolean = { logger.trace("Asking hasNext") if (currentIterator.hasNext) { //(13) true } else if (isDone) { //(14) false } else { if (expecting &lt; requestSize) { requestNextBatches() //(15) } buffer.take() match { //(16) case Item(batch) =&gt; currentIterator = batch.iterator expecting -= 1 this.hasNext //(17) case Done =&gt; isDone = true false //(18) case Failure(exception) =&gt; throw new StreamErrorCompletionException(exception) //(19) } } } override def next(): T = { val out = currentIterator.next() logger.trace("The next element is {}", out) out //(20) } private def requestNextBatches(): Unit = { logger.debug(s"Requesting {} batches", requestSize) subscription.request(requestSize) expecting += requestSize //(21) } }</span></span></code> </pre><br>  IteratorSubscriber    Producer-Consumer.   ,    Subscriber,  Producer-,  ,   Iterator, ‚Äì Consumer-.      ,     .    Iterator       Apache Spark,    Subscriber ‚Äì  ,  ActorSystem. <br><br>      IteratorSubscriber  . <br><br><ol><li>          .          ,     Done,    ,  Throwable,    . </li><li>      ,        hasNext    . </li><li>  ,    ,        Publisher-. </li><li>    ,     .    LinkedBlockingQueue,      . ,         . </li><li>     ,    .     ,         ,       Publisher-.   ,    ,      Publisher-   .         hasNext  next ( requestNextBatches    hasNext),       ,       . </li><li>  subscriptionPromise  subscription     Subscription,    Publisher    onSubscribe. ,    Reactive Streams        Subscriber-  Publisher-     ,   ,   hasNext   ,  onSubscribe.      ,     subscription,          Publisher-.     lazy   subscription,    Promise. </li><li>       .          hasNext  next,     ,       . </li><li>     ,        ,  hasNext   false     .           hasNext,         . </li><li>    onSubscribe    Publisher-  Subscription    Promise,        subscription. </li><li> onNext  Publisher-,        .      . </li><li>       Publisher   onComplete,          Done. </li><li>    Publisher   onError.       . </li><li>    hasNext     ,      .      ,    true,       .     ,         . </li><li>        ,            false. </li><li>  ,   ,        requestSize,       Publisher.         ,    ,     ,   Publisher-    ,   HTTP-     . </li><li>        .  ,   ,      ,      .  ,       ,     (  ,    ,        subscription), ,     ,   ,      . </li><li>       ,           currentIterator.        ,          . ,       hasNext  ,         (    ,   ),        . </li><li>     ,    false        hasNext. ,     isDone,   ,     .   - ,   hasNext        ,         false.        ,       hasNext  ,    false      ,      .          ,      . </li><li>        ,    ,     ,     . </li><li>  next      .    ,        hasNext,    next        . </li><li>     Publisher-  ,       ,   subscription,       Publisher-.     requestSize.         . </li></ol><br>  ,       ,   ,   : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6m/bg/fu/6mbgfuuatqlimwnapnl3tlrzn8q.png"></div> <i> 8.       .</i> <br><br><h3>  :      </h3><br>      ,        ,      .     ,       HTTP ,      .         . <br><br>    ‚Äì         .    ,     ,       Hadoop ,      .  ,    ,       -       .     ,  ,   hdfs, ,          , ,       . <br><br>  ,         . ,   akka-http              ,         .   ,      -,       -       Apache Spark ,       ,  ,    -. <br><br> ,   ,         .   ,   ,        http-,          ,     . <br><br>          ,         .  ,        ,    .     ,   .  ,         . <br><br>                ,    . ,  ,    Hadoop    ,           ,     . <br><br>  ,  ,  Hadoop-    ,     ,         . <br><br>  ,  ,          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CleverDATA</a> .                      .  ,  ,     ,  ,    ,            .  ,            . <br><br><div class="spoiler"> <b class="spoiler_title">,      .</b> <div class="spoiler_text"><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java-Entwickler</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Systemingenieur</font></font></a> </li></ul><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413141/">https://habr.com/ru/post/de413141/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413129/index.html">25 Fehler ein Anf√§nger Programmierer</a></li>
<li><a href="../de413133/index.html">Beliebte Antimuster: Paginierung</a></li>
<li><a href="../de413135/index.html">Code-Review-Testzuweisung von Junior-React-Entwicklern</a></li>
<li><a href="../de413137/index.html">Klassifizieren Sie gro√üe Datenmengen in Apache Spark mithilfe beliebiger Modelle f√ºr maschinelles Lernen</a></li>
<li><a href="../de413139/index.html">Elektroautos: Die Revolution kommt</a></li>
<li><a href="../de413143/index.html">Bobby Urban Lite: Der neue Urban Backpack von XD Design</a></li>
<li><a href="../de413145/index.html">Analyst hilft Unternehmen, Geld zu verdienen</a></li>
<li><a href="../de413147/index.html">Ist es m√∂glich, Tibero anstelle von Oracle zu verwenden? Und ist es notwendig</a></li>
<li><a href="../de413149/index.html">Verteiltes Data Warehouse im Data Lake-Konzept: Wo soll ich anfangen?</a></li>
<li><a href="../de413151/index.html">Die NSA schlug einen Verschl√ºsselungsstandard f√ºr IoT-Ger√§te vor, der von ISO jedoch abgelehnt wurde</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>