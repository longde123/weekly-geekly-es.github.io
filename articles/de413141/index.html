<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏩 💇🏿 🎁 Klassifizieren Sie große Datenmengen in Apache Spark mithilfe beliebiger Modelle für maschinelles Lernen 👸🏿 🏭 🤽🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teil 2: Lösung 
 Hallo nochmal! Heute werde ich meine Geschichte darüber fortsetzen, wie wir große Datenmengen in Apache Spark mithilfe beliebiger Mod...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Klassifizieren Sie große Datenmengen in Apache Spark mithilfe beliebiger Modelle für maschinelles Lernen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lanit/blog/413141/"><h2>  Teil 2: Lösung </h2><br>  Hallo nochmal!  Heute werde ich meine Geschichte darüber fortsetzen, wie wir große Datenmengen in Apache Spark mithilfe beliebiger Modelle für maschinelles Lernen klassifizieren.  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Teil des Artikels haben</a> wir die Darstellung des Problems selbst sowie die Hauptprobleme untersucht, die bei der Organisation der Interaktion zwischen dem Cluster, in dem die Anfangsdaten gespeichert und verarbeitet werden, und dem externen Klassifizierungsdienst auftreten.  Im zweiten Teil werden wir eine der Optionen zur Lösung dieses Problems mithilfe des Reactive Streams-Ansatzes und seiner Implementierung mithilfe der akka-Streams-Bibliothek betrachten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6m/bg/fu/6mbgfuuatqlimwnapnl3tlrzn8q.png"></div><a name="habracut"></a><br><h3>  Konzept für reaktive Streams </h3><br>  Um die im ersten Teil beschriebenen Probleme zu lösen, können Sie den Ansatz <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reactive Streams verwenden</a> .  Sie können damit den Prozess der Übertragung von Datenströmen zwischen Verarbeitungsstufen steuern, die mit unterschiedlichen Geschwindigkeiten und unabhängig voneinander arbeiten, ohne dass eine Pufferung erforderlich ist.  Wenn eine der Verarbeitungsstufen langsamer als die vorherige ist, muss der schnelleren Stufe signalisiert werden, wie viele Eingabedaten derzeit verarbeitet werden können.  Diese Wechselwirkung nennt man Gegendruck.  Es besteht in der Tatsache, dass die schnelleren Stufen genau so viele Elemente verarbeiten, wie für die langsamere Stufe erforderlich sind, und nicht mehr, und dann Rechenressourcen freisetzen. <br><br>  Im Allgemeinen ist Reactive Streams eine Spezifikation für die Implementierung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Publisher-Subscriber-</a> Vorlage.  Diese Spezifikation definiert einen Satz von vier Schnittstellen (Publisher, Subscriber, Processor und Subscription) und einen Vertrag für deren Methoden. <br><br>  Betrachten wir diese Schnittstellen genauer: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscriber&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; s)</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscription s)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscription</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Processor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre> <br>  Das Publisher-Subscriber-Modell hat zwei Seiten: Senden und Empfangen.  Bei der Implementierung von Reactive Streams ist die Klasse, die die Publisher-Schnittstelle implementiert, für die Datenübertragung und der Abonnent für den Empfang verantwortlich.  Um die Kommunikation zwischen ihnen herzustellen, muss der Abonnent durch Aufrufen seiner Abonnementmethode bei Publisher registriert sein.  Gemäß der Spezifikation muss der Publisher nach der Registrierung eines Abonnenten seine Methoden in der folgenden Reihenfolge aufrufen: <br><br><ol><li>  onSubscribe.  Diese Methode wird unmittelbar nach der Registrierung des Abonnenten bei Publisher aufgerufen.  Als Parameter wird ein Abonnementobjekt an dieses übergeben, über das der Abonnent Daten vom Publisher anfordert.  Dieses Objekt sollte nur im Kontext dieses Abonnenten gespeichert und aufgerufen werden. </li><li>  Nachdem der Abonnent Daten von Publisher angefordert hat, indem er die Anforderungsmethode für das entsprechende Abonnementobjekt aufruft, kann Publisher die Methode Subscriber onNext aufrufen und das nächste Element übergeben. </li><li>  Der Abonnent kann dann die Anforderungsmethode für das Abonnement regelmäßig aufrufen, aber der Publisher kann die onNext-Methode nicht mehr als die über die Anforderungsmethode angeforderte Summe aufrufen. </li><li>  Wenn der Datenstrom endlich ist, muss Publisher nach dem Übergeben aller Elemente durch die onNext-Methode die onComplete-Methode aufrufen. </li><li>  Wenn in Publisher ein Fehler aufgetreten ist und eine weitere Verarbeitung der Elemente nicht möglich ist, sollte die onError-Methode aufgerufen werden </li><li>  Nach dem Aufrufen der Methoden onComplete oder onError sollte die weitere Interaktion des Publishers mit dem Abonnenten ausgeschlossen werden. </li></ol><br>  Methodenaufrufe können als Sendesignale zwischen Publisher und Subscriber betrachtet werden.  Der Abonnent signalisiert dem Publisher, wie viele Elemente verarbeitet werden können, und der Publisher signalisiert ihm wiederum, dass entweder das nächste Element vorhanden ist oder keine weiteren Elemente vorhanden sind oder ein Fehler aufgetreten ist. <br><br>  Um einen weiteren Einfluss von Publisher und Subscriber auf einander auszuschließen, dürfen Aufrufe aller Methoden, die Reactive Streams-Schnittstellen implementieren, nicht blockierend sein.  In diesem Fall ist die Interaktion zwischen ihnen vollständig asynchron. <br><br>  Weitere Details zur Spezifikation für Reactive Streams-Schnittstellen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Durch Verknüpfen des ursprünglichen und der resultierenden Iteratoren durch Konvertieren in Publisher bzw. Subscriber können wir die im vorherigen Teil des Artikels identifizierten Probleme lösen.  Das Problem des Pufferüberlaufs zwischen den Stufen wird gelöst, indem eine bestimmte Anzahl von Elementen vom Abonnenten angefordert wird.  Das Problem des erfolgreichen oder erfolglosen Abschlusses wird gelöst, indem Signale über die Methoden onComplete bzw. onError an den Abonnenten gesendet werden.  Der Publisher ist für das Senden dieser Signale verantwortlich. In unserem Fall muss gesteuert werden, wie viele HTTP-Anforderungen gesendet wurden und wie viele von ihnen Antworten erhalten haben.  Nachdem die letzte Antwort empfangen und alle darin enthaltenen Ergebnisse verarbeitet wurden, sollte ein onComplete-Signal gesendet werden.  Falls eine der Anforderungen fehlschlägt, sollte sie ein onError-Signal senden und das Senden weiterer Elemente an den Abonnenten beenden sowie Elemente vom ursprünglichen Iterator subtrahieren. <br><br>  Der resultierende Iterator sollte als Abonnent implementiert werden.  In diesem Fall können wir nicht auf einen Puffer verzichten, in den Elemente geschrieben werden, wenn die onNext-Methode von der Subscriber-Schnittstelle aufgerufen und mit der hasNext- und der next-Methode von der Iterator-Schnittstelle subtrahiert wird.  Als Pufferimplementierung können Sie eine Blockierungswarteschlange verwenden, z. B. LinkedBlockedQueue. <br><br>  Ein aufmerksamer Leser wird sofort die Frage stellen: Warum befindet sich die Blockierungswarteschlange, da gemäß der Reactive Streams-Spezifikation die Implementierung aller Methoden nicht blockierend sein sollte?  Aber hier ist alles in Ordnung: Da wir Publisher nach einer genau definierten Anzahl von Elementen fragen, wird die onNext-Methode nicht öfter aufgerufen, und die Warteschlange kann jederzeit ein neues Element hinzufügen, ohne es zu blockieren. <br><br>  Andererseits kann es zu einer Blockierung kommen, wenn die hasNext-Methode im Falle einer leeren Warteschlange aufgerufen wird.  Dies ist jedoch in Ordnung: Die hasNext-Methode ist nicht Bestandteil des Vertrags der Subscriber-Schnittstelle, sondern wird in der Iterator-Schnittstelle definiert, die, wie bereits erläutert, eine blockierende Datenstruktur darstellt.  Wenn wir die nächste Methode aufrufen, subtrahieren wir das nächste Element von der Warteschlange, und wenn seine Größe einen bestimmten Schwellenwert unterschreitet, müssen wir den nächsten Teil der Elemente durch einen Aufruf der Anforderungsmethode anfordern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tz/xy/8t/tzxy8tn05km8fox0bkwk_zsxvcg.png" width="650"></div>  <i>Abbildung 7. Asynchrone Interaktion mit einem externen Dienst unter Verwendung des Reactive Streams-Ansatzes</i> <br><br>  In diesem Fall werden wir blockierende Anrufe natürlich nicht vollständig los.  Dies wird durch eine Nichtübereinstimmung der Paradigmen zwischen reaktiven Streams, die eine vollständig asynchrone Interaktion voraussetzen, und einem Iterator verursacht, der beim Aufrufen der hasNext-Methode trueN oder false aufrufen muss.  Im Gegensatz zur synchronen Interaktion mit einem externen Dienst können Ausfallzeiten aufgrund von Sperren durch Erhöhen der Gesamtlast der Prozessorkerne erheblich reduziert werden. <br><br>  Es wäre praktisch, wenn Apache Spark-Entwickler in zukünftigen Versionen ein Analogon der mapPartitions-Methode implementieren würden, die mit Publisher und Subscriber funktioniert.  Dies würde eine vollständig asynchrone Interaktion ermöglichen und somit die Möglichkeit des Blockierens von Threads ausschließen. <br><br><h3>  Akka-Streams und Akka-http als Implementierung der Reactive Streams-Spezifikation </h3><br>  Derzeit gibt es bereits mehr als ein Dutzend Implementierungen der Reactive Streams-Spezifikation.  Eine solche Implementierung ist das Akka-Streams-Modul aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Akka-</a> Bibliothek.  In der Welt von JVM hat sich akka als eines der effektivsten Mittel zum Schreiben paralleler und verteilter Systeme etabliert.  Dies wird durch die Tatsache erreicht, dass das Grundprinzip, das in seiner Grundlage festgelegt ist, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Akteurmodell ist</a> , mit dem Sie wettbewerbsfähige Anwendungen ohne direkte Kontrolle über Threads und deren Pools schreiben können. <br><br>  Es wurde viel Literatur über die Umsetzung des Konzepts der Akteure in Akka geschrieben, daher werden wir hier nicht aufhören (die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offizielle Website von Akka</a> ist eine sehr gute Informationsquelle, ich empfehle auch die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Akka im Aktionsbuch</a> ).  Hier werden wir uns die technologische Seite der Implementierung im Rahmen der JVM genauer ansehen. <br><br>  Im Allgemeinen existieren Akteure nicht für sich, sondern bilden ein hierarchisches System.  Um ein Akteursystem zu erstellen, müssen Sie Ressourcen dafür zuweisen. Der erste Schritt bei der Arbeit mit akka besteht darin, eine Instanz des ActorSystem-Objekts zu erstellen.  Beim Start von ActorSystem wird ein separater Thread-Pool namens Dispatcher erstellt, in dem der gesamte in den Akteuren definierte Code ausgeführt wird.  In der Regel führt ein einzelner Thread den Code mehrerer Akteure aus. Bei Bedarf können Sie jedoch einen separaten Dispatcher für eine bestimmte Gruppe von Akteuren konfigurieren (z. B. für Akteure, die direkt mit einer blockierenden API interagieren). <br><br>  Eine der häufigsten Aufgaben, die mit Akteuren gelöst werden, ist die sequentielle Verarbeitung von Datenströmen.  Zuvor war es dafür erforderlich, Ketten von Akteuren manuell zu erstellen und sicherzustellen, dass keine Engpässe zwischen ihnen bestehen (wenn beispielsweise ein Akteur Nachrichten schneller als der nächste verarbeitet, kann es zu einem Überlauf der Warteschlange für eingehende Nachrichten kommen, was zu einem OutOfMemoryError-Fehler führt). <br><br>  Ab Version 2.4 wurde akka das Modul akka-streams hinzugefügt, mit dem Sie den Datenverarbeitungsprozess deklarativ definieren und anschließend die erforderlichen Akteure für seine Ausführung erstellen können.  Akka-Streams implementiert auch das Prinzip des Gegendrucks, wodurch die Möglichkeit eines Überlaufens der Warteschlange eingehender Nachrichten für alle an der Verarbeitung beteiligten Akteure ausgeschlossen wird. <br><br>  Die Hauptelemente zum Definieren des Datenflussverarbeitungsschemas in Akka-Streams sind Source, Flow und Sink.  Durch die Kombination erhalten wir ein ausführbares Diagramm.  Um den Verarbeitungsprozess zu starten, wird ein Materializer verwendet, der Akteure erstellt, die gemäß dem von uns definierten Diagramm (der Materializer-Schnittstelle und ihrer Implementierung ActorMaterializer) arbeiten. <br><br>  Betrachten wir die Phasen Quelle, Fluss und Senke genauer.  Quelle definiert die Datenquelle.  Akka-Streams unterstützt über ein Dutzend verschiedene Möglichkeiten zum Erstellen von Quellen, einschließlich eines Iterators: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> featuresSource: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">Array</span></span>[<span class="hljs-type"><span class="hljs-type">Float</span></span>], <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = <span class="hljs-type"><span class="hljs-type">Source</span></span>.fromIterator { () =&gt; featuresIterator }</code> </pre><br>  Die Quelle kann auch durch Konvertieren einer vorhandenen Quelle erhalten werden: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newSource: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = source.map(item =&gt; transform(item))</code> </pre> <br>  Wenn die Transformation eine nicht triviale Operation ist, kann sie als Flow-Entität dargestellt werden.  Akka-Streams unterstützen viele verschiedene Möglichkeiten, um Flow zu erstellen.  Der einfachste Weg ist, aus einer Funktion zu erstellen: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someFlow: <span class="hljs-type"><span class="hljs-type">Flow</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = <span class="hljs-type"><span class="hljs-type">Flow</span></span>.fromFunction((x: <span class="hljs-type"><span class="hljs-type">String</span></span>) =&gt; x.length)</code> </pre> <br>  Durch die Kombination von Quelle und Fluss erhalten wir eine neue Quelle. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newSource: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = oldSource.via(someFlow)</code> </pre> <br>  Die Spüle wird als letzte Stufe der Datenverarbeitung verwendet.  Wie im Fall von Source bietet akka-stream mehr als ein Dutzend verschiedene Sink-Optionen. Beispielsweise führt Sink.foreach für jedes Element eine bestimmte Operation aus, Sink.seq sammelt alle Elemente in einer Sammlung usw. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> printSink: <span class="hljs-type"><span class="hljs-type">Sink</span></span>[<span class="hljs-type"><span class="hljs-type">Any</span></span>, <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Done</span></span>]] = <span class="hljs-type"><span class="hljs-type">Sink</span></span>.foreach(println)</code> </pre> <br>  Quelle, Durchfluss und Senke werden durch die Arten von Eingabe- und / oder Ausgabeelementen parametrisiert.  Darüber hinaus kann jede Verarbeitungsstufe ein Ergebnis ihrer Arbeit haben.  Zu diesem Zweck werden Quelle, Durchfluss und Senke auch durch einen zusätzlichen Typ parametrisiert, der das Ergebnis der Operation bestimmt.  Dieser Typ wird als Typ des materialisierten Werts bezeichnet.  Wenn die Operation nicht das Vorhandensein eines zusätzlichen Ergebnisses ihrer Arbeit impliziert, z. B. wenn wir den Durchfluss durch eine Funktion definieren, wird der Typ NotUsed als materialisierter Wert verwendet. <br><br>  Durch die Kombination von Source, Flow und Sink erhalten wir RunnableGraph.  Es wird durch einen Typ parametrisiert, der den Werttyp bestimmt, der als Ergebnis der Ausführung dieses Diagramms erhalten wird.  Bei Bedarf können Sie beim Kombinieren der Stufen angeben, welches der Stufen das Ergebnis des gesamten Operationsdiagramms sein soll.  Standardmäßig wird das Ergebnis der Quellstufe verwendet: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> graph: <span class="hljs-type"><span class="hljs-type">RunnableGraph</span></span>[<span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = someSource.to(<span class="hljs-type"><span class="hljs-type">Sink</span></span>.foreach(println))</code> </pre> <br>  Wenn jedoch das Ergebnis der Sink-Phase für uns wichtiger ist, müssen wir dies ausdrücklich angeben: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> graph: <span class="hljs-type"><span class="hljs-type">RunnableGraph</span></span>[<span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Done</span></span>]] = someSource.toMat(<span class="hljs-type"><span class="hljs-type">Sink</span></span>.foreach(println))(<span class="hljs-type"><span class="hljs-type">Keep</span></span>.right)</code> </pre><br>  Nachdem wir den Operationsgraphen definiert haben, müssen wir ihn ausführen.  Dazu muss runnableGraph die run-Methode aufrufen.  Als Parameter verwendet diese Methode ein ActorMaterializer-Objekt (das sich auch in einem impliziten Bereich befinden kann), das für die Erstellung von Akteuren verantwortlich ist, die Operationen ausführen.  In der Regel wird ein ActorMaterializer unmittelbar nach der Erstellung eines ActorSystems erstellt, das an seinen Lebenszyklus angehängt ist, und verwendet es zum Erstellen von Akteuren.  Betrachten Sie ein Beispiel: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//   ActorSystem,       implicit val system = ActorSystem(“system name”) // ,       ActorSystem implicit val materializer = ActorMaterializer() //    ,       Sink val graph: RunnableGraph[Future[immutable.Seq[Int]]] = Source.fromIterator(() =&gt; (1 to 10).iterator).toMat(Sink.seq)(Keep.right) //   ,    implicit scope. val result: Future[immutable.Seq[Int]] = graph.run()</span></span></code> </pre><br>  Bei einfachen Kombinationen können Sie auf einen separaten RunnableGraph verzichten, aber einfach Source mit Sink verbinden und diese starten, indem Sie die runWith-Methode für Source aufrufen.  Diese Methode setzt auch voraus, dass ein ActorMaterializer-Objekt im impliziten Bereich vorhanden ist.  In diesem Fall wird außerdem der in Sink definierte materialisierte Wert verwendet.  Mit dem folgenden Code können wir beispielsweise Source in Publisher aus der Reactive Streams-Spezifikation konvertieren: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> source: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">Score</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = <span class="hljs-type"><span class="hljs-type">Source</span></span>.fromIterator(() =&gt; sourceIterator).map(item =&gt; transform(item)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> publisher: <span class="hljs-type"><span class="hljs-type">Publisher</span></span>[<span class="hljs-type"><span class="hljs-type">Score</span></span>] = source.runWith(<span class="hljs-type"><span class="hljs-type">Sink</span></span>.asPublisher(<span class="hljs-literal"><span class="hljs-literal">false</span></span>))</code> </pre><br>  Nun haben wir gezeigt, wie Sie Reactive Streams Publisher erhalten können, indem Sie eine Quelle aus dem Quelliterator erstellen und einige Transformationen an seinen Elementen durchführen.  Jetzt können wir es einem Abonnenten zuordnen, der dem resultierenden Iterator Daten liefert.  Es bleibt die letzte Frage zu prüfen: Wie organisiert man die HTTP-Interaktion mit einem externen Dienst? <br><br>  Die Struktur von akka umfasst das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://doc.akka.io/docs/akka-">akka-http-</a> Modul, mit dem Sie die asynchrone, nicht blockierende Kommunikation über HTTP organisieren können.  Darüber hinaus basiert dieses Modul auf Akka-Streams, mit denen Sie die HTTP-Interaktion als zusätzlichen Schritt im Diagramm der Datenflussverarbeitungsvorgänge hinzufügen können. <br><br>  Um eine Verbindung zu externen Diensten herzustellen, bietet akka-http drei verschiedene Schnittstellen. <br><br><ol><li>  API auf Anforderungsebene - ist die einfachste Option für den Fall einzelner Anforderungen an einen beliebigen Computer.  Auf dieser Ebene werden HTTP-Verbindungen vollständig automatisch verwaltet, und bei jeder Anforderung muss die vollständige Adresse des Computers übertragen werden, an den die Anforderung gesendet wird. </li><li>  Host-Level-API - geeignet, wenn wir wissen, auf welchen Port auf welchem ​​Computer wir zugreifen werden.  In diesem Fall übernimmt akka-http die Kontrolle über den Pool von HTTP-Verbindungen. Bei Anforderungen reicht es aus, den relativen Pfad zur angeforderten Ressource anzugeben. </li><li>  API auf Verbindungsebene - Ermöglicht Ihnen die vollständige Kontrolle über die Verwaltung von HTTP-Verbindungen, dh das Öffnen, Schließen und Verteilen von Anforderungen über Verbindungen. </li></ol><br>  In unserem Fall ist uns die Adresse des Klassifizierungsdienstes im Voraus bekannt, daher ist es erforderlich, die HTTP-Interaktion nur mit diesem bestimmten Computer zu organisieren.  Daher ist die Host-Level-API für uns am besten geeignet.  Lassen Sie uns nun sehen, wie der Pool von HTTP-Verbindungen bei Verwendung erstellt wird: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> httpFlow: <span class="hljs-type"><span class="hljs-type">Flow</span></span>[(<span class="hljs-type"><span class="hljs-type">HttpRequest</span></span>,<span class="hljs-type"><span class="hljs-type">Id</span></span>), (<span class="hljs-type"><span class="hljs-type">Try</span></span>[<span class="hljs-type"><span class="hljs-type">HttpResponse</span></span>],<span class="hljs-type"><span class="hljs-type">Id</span></span>), <span class="hljs-type"><span class="hljs-type">Http</span></span>.<span class="hljs-type"><span class="hljs-type">HostConnectionPool</span></span>] = <span class="hljs-type"><span class="hljs-type">Http</span></span>().cachedHostConnectionPool[<span class="hljs-type"><span class="hljs-type">Id</span></span>](hostAddress, portNumber)</code> </pre><br>  Beim Aufruf von Http (). CachedHostConnectionPool [T] (hostAddress, portNumber) im ActorSystem, das sich in einem impliziten Bereich befindet, werden Ressourcen zugewiesen, um einen Verbindungspool zu erstellen, aber die Verbindungen selbst werden nicht hergestellt.  Als Ergebnis dieses Aufrufs wird Flow zurückgegeben, der ein Paar einer HTTP-Anforderung und eines ID-Identifikationsobjekts als Eingabe empfängt.  Das Identifikationsobjekt wird benötigt, um die Anforderung mit der entsprechenden Antwort abzugleichen, da der akka-http-HTTP-Aufruf eine asynchrone Operation ist und die Reihenfolge, in der die Antworten empfangen werden, nicht unbedingt der Reihenfolge entspricht, in der die Anforderungen gesendet werden.  Daher gibt Flow am Ausgang ein paar Ergebnisse der Abfrage und das entsprechende Identifikationsobjekt aus. <br><br>  Direkt werden HTTP-Verbindungen hergestellt, wenn ein Diagramm (einschließlich dieses Flusses) gestartet (materialisiert) wird.  Akka-http ist so implementiert, dass innerhalb eines ActorSystems immer ein gemeinsamer Pool von HTTP-Verbindungen vorhanden ist, der von allen Materialisierungen verwendet wird, unabhängig davon, wie oft die Diagramme mit httpFlow materialisiert wurden.  Auf diese Weise können Sie die Verwendung von Netzwerkressourcen besser steuern und eine Überlastung vermeiden. <br><br>  Somit ist der Lebenszyklus des HTTP-Verbindungspools an das ActorSystem gebunden.  Wie bereits erwähnt, ist auch der Lebenszyklus des Thread-Pools damit verbunden, in dem die in den Akteuren definierten Operationen (oder in unserem Fall als die Stufen akka-Streams und akka-http definiert) ausgeführt werden.  Um maximale Effizienz zu erzielen, müssen wir daher eine Instanz von ActorSystem innerhalb desselben JVM-Prozesses wiederverwenden. <br><br><h3>  Alles zusammen: Ein Beispiel für die Implementierung der Interaktion mit dem Klassifizierungsdienst </h3><br>  Jetzt können wir mit der Klassifizierung großer Mengen verteilter Daten in Apache Spark mithilfe der asynchronen Interaktion mit externen Diensten fortfahren.  Das allgemeine Schema dieser Wechselwirkung wurde bereits in Abbildung 7 gezeigt. <br><br>  Angenommen, wir haben einen anfänglichen Datensatz [Features] definiert.  Wenn Sie die mapPartitions-Operation darauf anwenden, sollten Sie einen Datensatz erhalten, in dem jede ID aus dem Quellensatz mit einem bestimmten Wert versehen ist, der als Ergebnis der Klassifizierung erhalten wurde (Datensatz [Score]).  Um die asynchrone Verarbeitung auf Executoren zu organisieren, müssen wir die Quelle und die resultierenden Iteratoren in Publisher bzw. Subscriber aus der Reactive Streams-Spezifikation umschließen und miteinander verknüpfen. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Features</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, vector: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Score</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, score: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">1</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">batchesRequestCount</span></span></span><span class="hljs-class"> </span></span>= config.getInt(“scoreService. batchesRequestCount”)<span class="hljs-comment"><span class="hljs-comment">//(2) //... val scoreDs: Dataset[Score] = featuresDs.mapPartitions { fi: Iterator[Features] =&gt; val publisher: Publisher[Iterable[Score]] = createPublisher(fi) //(3) val iteratorSubscriber: Iterator[Score] = new IteratorSubscriber(batchesRequestCount) //(4) publisher.subscribe(batchesRequestCount) //(5) iteratorSubscriber //(6) }</span></span></code> </pre> <br>  Bei dieser Implementierung wird berücksichtigt, dass der Klassifizierungsdienst für einen Aufruf eine Gruppe von Merkmalsvektoren gleichzeitig verarbeiten kann. Daher ist das Klassifizierungsergebnis nach einem Aufruf auch sofort für die gesamte Gruppe verfügbar.  Daher haben wir als Parametertyp für Publisher nicht nur Score, wie Sie vielleicht erwarten, sondern Iterable [Score].  Daher senden wir die Klassifizierungsergebnisse für diese Gruppe durch einen einzelnen Aufruf der onNext-Methode an den resultierenden Iterator (der auch ein Abonnent ist).  Dies ist viel effizienter als der Aufruf von onNext für jedes Element.  Jetzt werden wir diesen Code genauer analysieren. <br><br><ol><li>  Wir bestimmen die Struktur der Eingabe- und Ausgabedaten.  Als Eingabe haben wir eine Reihe von ID-Bezeichnern mit einem Merkmalsvektor, und als Ausgabe haben wir eine Reihe von Bezeichnern mit einem numerischen Wert, der als Ergebnis der Klassifizierung erhalten wird. </li><li>  Wir bestimmen die Anzahl der Gruppen, die der Abonnent gleichzeitig vom Publisher anfordert.  Da davon ausgegangen wird, dass diese Werte im Puffer liegen und warten, bis sie aus dem resultierenden Iterator gelesen werden, hängt dieser Wert von der dem Executor zugewiesenen Speichermenge ab. </li><li>  Erstellen Sie Publisher aus dem Quelliterator.  Er ist für die Interaktion mit dem Klassifizierungsdienst verantwortlich.  Die Funktion createPublisher wird unten erläutert. </li><li>  Erstellen Sie einen Abonnenten, der der resultierende Iterator ist.  Der IteratorSubscriber-Klassencode ist ebenfalls unten angegeben. </li><li>  Abonnenten beim Publisher registrieren. </li><li>  Gibt IteratorSubscriber als Ergebnis der mapPartitions-Operation zurück. </li></ol><br>  Betrachten Sie nun die Implementierung der Funktion createPublisher. <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ids</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] <span class="hljs-comment"><span class="hljs-comment">//(1) val batchSize = config.getInt("scoreService.batchSize") val parallelismLevel = config.getInt("scoreService.parallelismLevel") //(2) //... def createPublisher(fi: Iterator[Features]): Publisher[Iterable[Score]] = { import ActorSystemHolder._ //(3) Source .fromIterator(() =&gt; fi) //(4) .grouped(batchSize) //(5) .map { groupedFeatures: Seq[Features] =&gt; val request: (HttpRequest, Ids) = createHttpRequest(groupedFeatures) //(6) logger.debug(s"Sending request for the first id: ${request._2(0)}") request } .via(httpFlow) //(7) .flatMapMerge(parallelismLevel, { //(8) case (Success(response), ids) if response.status.isSuccess() =&gt; logger.debug(s"Processing successful result for the first id: ${ids(0)}") val resultSource: Source[Iterable[Score], _] = response.entity.dataBytes.reduce(_ ++ _).map { responseBytes =&gt; processSuccessfulResponse(responseBytes, ids) } //(9) resultScore case (Success(response), ids) =&gt; logger.warn( s"Failed result for the first id: ${ids(0)}, HTTP status: ${response.status}" ) response.discardEntityBytes() Source.failed( new IOException(s"Non-successful HTTP status: ${response.status}") ) //(10) case (Failure(ex), ids) =&gt; logger.warn(s"Failed result: an exception has occured", ex) Source.failed(ex) //(11) }) .runWith(Sink.asPublisher(false)) //(12) } def createHttpRequest(featuresSeq: Seq[Features]): (HttpRequest, ProfileIds) = { val requestBytes: Array[Byte] = featuresToMatrixBytes(featuresSeq) val ids: ProfileIds = extractIds(featuresSeq) val httpRequest = HttpRequest( method = HttpMethods.PUT, uri = "/score", entity = requestBytes ) httpRequest -&gt; ids }</span></span></code> </pre><br><ol><li>    -   ,   .         httpFlow,           . </li><li>     :     ,     (batchSize)        (parallelismLevel). </li><li>   implicit scope ActorSystem, ActorMaterializer  httpFlow.        Spark-.  ActorSystemHolder    . </li><li>     akka-streams   .     Source[Features]   . </li><li>            batchSize       . </li><li>     HttpRequest       .   HttpRequest      createHttpRequest.      createPublisher.      feature-,   ,      (            predict).       ,      HTTP-.      ,   HTTP-,    HTTP-, URI      . </li><li>        httpFlow. </li><li>     ,   .      flatMapMerge,        akka-http    Source[ByteString],      ,       .           .  parallelismLevel ,      (     ).      HTTP-:   ,  ,  ,   . </li><li>       :          .      akka    ByteString.    ,    ByteString    O(1),    ByteString        .       ,    ,         .                ,     . </li><li>       HTTP-     ,  Stream .         ,      discardEntityBytes    ,    ,  . </li><li>         .      akka-http    ,       . </li><li>       ,    Publisher,     .    ,    .  false   Sink.asPublisher ,   Publisher    Subscriber-. </li></ol><br>      ,    akka  ActorSystem,        .  ,        Spark ,          .   Spark    JVM , ,        ,     ActorSystem    ActorMatrializer  httpFlow. <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActorSystemHolder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> actorSystem: <span class="hljs-type"><span class="hljs-type">ActorSystem</span></span> = { <span class="hljs-comment"><span class="hljs-comment">//(1) val actorSystemName = s"score-service-client" logger.debug(s"Creating actor system $actorSystemName") val as = ActorSystem(actorSystemName) //(2) logger.debug("Adding shutdown hook for the actor system") scala.sys.addShutdownHook { //(3) logger.debug(s"Terminating actor system $actorSystemName") Await.result(as.terminate(), 30.seconds) //to Mars :) logger.debug(s"The actor system $actorSystemName has been terminated") } as } implicit lazy val materializer: ActorMaterializer = { //(4) logger.debug(s"Creating actor materializer for actor system ${actorSystem.name}") ActorMaterializer() } lazy val httpFlow: Flow[ (HttpRequest,ProfileIds), (Try[HttpResponse], ProfileIds), Http.HostConnectionPool] = { //(5) val httpFlowSettings = ConnectionPoolSettings(actorSystem) logger.debug(s"Creating http flow with settings $httpFlowSettings") Http().cachedHostConnectionPool[ProfileIds]( config.getString("scoreService.host"), config.getInt("scoreService.int"), settings = httpFlowSettings ) } }</span></span></code> </pre><br><ol><li>     ,   ,       ,     . </li><li>    ActorSystem   . </li><li>  ,     ,    ActorSystem,       terminate, ,   ,   ,     .      ,     JVM-. </li><li>    ActorMaterializer,      akka-streams,   ActorSystem. </li><li> ,   httpFlow     .      ,       HTTP-   ActorSystem. </li></ol><br>       Subscriber-    HTTP-. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[+</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span><span class="hljs-class">[+</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">item: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Done</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Failure</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">cause: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">1</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StreamErrorCompletionException</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">cause: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">cause</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">2</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IteratorSubscriber</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">requestSize: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Iterable</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">]] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterator</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//(3) private val buffer: BlockingQueue[QueueItem[Iterable[T]]] = new LinkedBlockingQueue[QueueItem[Iterable[T]]]() //(4) private var expecting: Int = 0 //(5) private val subscriptionPromise: Promise[Subscription] = Promise() private lazy val subscription: Subscription = Await.result(subscriptionPromise.future, 5.minutes) //(6) private var currentIterator: Iterator[T] = Iterator.empty //(7) private var isDone = false //(8) override def onSubscribe(s: Subscription): Unit = { subscriptionPromise.success(s) //(9) logger.trace("The iterator has been subscribed") } override def onNext(t: Iterable[T]): Unit = { logger.trace("Putting a next batch to the buffer") buffer.put(Item(t)) //(10) } override def onComplete(): Unit = { logger.debug("The stream has been succesfully completed") buffer.put(Done) //(11) } override def onError(t: Throwable): Unit = { logger.warn("The stream has been completed with error", t) buffer.put(Failure(t)) //(12) } override def hasNext: Boolean = { logger.trace("Asking hasNext") if (currentIterator.hasNext) { //(13) true } else if (isDone) { //(14) false } else { if (expecting &lt; requestSize) { requestNextBatches() //(15) } buffer.take() match { //(16) case Item(batch) =&gt; currentIterator = batch.iterator expecting -= 1 this.hasNext //(17) case Done =&gt; isDone = true false //(18) case Failure(exception) =&gt; throw new StreamErrorCompletionException(exception) //(19) } } } override def next(): T = { val out = currentIterator.next() logger.trace("The next element is {}", out) out //(20) } private def requestNextBatches(): Unit = { logger.debug(s"Requesting {} batches", requestSize) subscription.request(requestSize) expecting += requestSize //(21) } }</span></span></code> </pre><br>  IteratorSubscriber    Producer-Consumer.   ,    Subscriber,  Producer-,  ,   Iterator, – Consumer-.      ,     .    Iterator       Apache Spark,    Subscriber –  ,  ActorSystem. <br><br>      IteratorSubscriber  . <br><br><ol><li>          .          ,     Done,    ,  Throwable,    . </li><li>      ,        hasNext    . </li><li>  ,    ,        Publisher-. </li><li>    ,     .    LinkedBlockingQueue,      . ,         . </li><li>     ,    .     ,         ,       Publisher-.   ,    ,      Publisher-   .         hasNext  next ( requestNextBatches    hasNext),       ,       . </li><li>  subscriptionPromise  subscription     Subscription,    Publisher    onSubscribe. ,    Reactive Streams        Subscriber-  Publisher-     ,   ,   hasNext   ,  onSubscribe.      ,     subscription,          Publisher-.     lazy   subscription,    Promise. </li><li>       .          hasNext  next,     ,       . </li><li>     ,        ,  hasNext   false     .           hasNext,         . </li><li>    onSubscribe    Publisher-  Subscription    Promise,        subscription. </li><li> onNext  Publisher-,        .      . </li><li>       Publisher   onComplete,          Done. </li><li>    Publisher   onError.       . </li><li>    hasNext     ,      .      ,    true,       .     ,         . </li><li>        ,            false. </li><li>  ,   ,        requestSize,       Publisher.         ,    ,     ,   Publisher-    ,   HTTP-     . </li><li>        .  ,   ,      ,      .  ,       ,     (  ,    ,        subscription), ,     ,   ,      . </li><li>       ,           currentIterator.        ,          . ,       hasNext  ,         (    ,   ),        . </li><li>     ,    false        hasNext. ,     isDone,   ,     .   - ,   hasNext        ,         false.        ,       hasNext  ,    false      ,      .          ,      . </li><li>        ,    ,     ,     . </li><li>  next      .    ,        hasNext,    next        . </li><li>     Publisher-  ,       ,   subscription,       Publisher-.     requestSize.         . </li></ol><br>  ,       ,   ,   : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6m/bg/fu/6mbgfuuatqlimwnapnl3tlrzn8q.png"></div> <i> 8.       .</i> <br><br><h3>  :      </h3><br>      ,        ,      .     ,       HTTP ,      .         . <br><br>    –         .    ,     ,       Hadoop ,      .  ,    ,       -       .     ,  ,   hdfs, ,          , ,       . <br><br>  ,         . ,   akka-http              ,         .   ,      -,       -       Apache Spark ,       ,  ,    -. <br><br> ,   ,         .   ,   ,        http-,          ,     . <br><br>          ,         .  ,        ,    .     ,   .  ,         . <br><br>                ,    . ,  ,    Hadoop    ,           ,     . <br><br>  ,  ,  Hadoop-    ,     ,         . <br><br>  ,  ,          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CleverDATA</a> .                      .  ,  ,     ,  ,    ,            .  ,            . <br><br><div class="spoiler"> <b class="spoiler_title">,      .</b> <div class="spoiler_text"><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java-Entwickler</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Systemingenieur</font></font></a> </li></ul><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413141/">https://habr.com/ru/post/de413141/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413129/index.html">25 Fehler ein Anfänger Programmierer</a></li>
<li><a href="../de413133/index.html">Beliebte Antimuster: Paginierung</a></li>
<li><a href="../de413135/index.html">Code-Review-Testzuweisung von Junior-React-Entwicklern</a></li>
<li><a href="../de413137/index.html">Klassifizieren Sie große Datenmengen in Apache Spark mithilfe beliebiger Modelle für maschinelles Lernen</a></li>
<li><a href="../de413139/index.html">Elektroautos: Die Revolution kommt</a></li>
<li><a href="../de413143/index.html">Bobby Urban Lite: Der neue Urban Backpack von XD Design</a></li>
<li><a href="../de413145/index.html">Analyst hilft Unternehmen, Geld zu verdienen</a></li>
<li><a href="../de413147/index.html">Ist es möglich, Tibero anstelle von Oracle zu verwenden? Und ist es notwendig</a></li>
<li><a href="../de413149/index.html">Verteiltes Data Warehouse im Data Lake-Konzept: Wo soll ich anfangen?</a></li>
<li><a href="../de413151/index.html">Die NSA schlug einen Verschlüsselungsstandard für IoT-Geräte vor, der von ISO jedoch abgelehnt wurde</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>