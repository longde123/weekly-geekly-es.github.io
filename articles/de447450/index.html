<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍💻 👩🏾‍🔧 👯 Mit Ghidra einen einfachen „Riss“ brechen - Teil 1 💘 ✋🏽 👐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Viele Leute wissen wahrscheinlich bereits aus erster Hand, was für ein Biest das ist - Ghidra ("Hydra") und was es aus erster Hand mit dem Programm zu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mit Ghidra einen einfachen „Riss“ brechen - Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447450/">  Viele Leute wissen wahrscheinlich bereits aus erster Hand, was für ein Biest das ist - <b>Ghidra</b> ("Hydra") und was es aus erster Hand mit dem Programm zu tun hat, obwohl dieses Tool erst kürzlich öffentlich zugänglich gemacht wurde - im März dieses Jahres.  Ich werde die Leser nicht mit einer Beschreibung von Hydra, seiner Funktionalität usw. belästigen.  Ich bin sicher, diejenigen, die sich mit dem Thema befassen, haben dies alles bereits selbst studiert, und diejenigen, die sich noch nicht mit dem Thema befassen, können dies jederzeit tun, da es jetzt einfach ist, detaillierte Informationen im Internet zu finden.  Übrigens, einer der Aspekte von Hydra (die Entwicklung von Plugins dafür) wurde bereits auf Habré behandelt (ausgezeichneter Artikel!). Ich werde nur die Hauptlinks geben: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Offizielle Seite auf der NSA-Website</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github-Projekt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erste Rezension im Hacker Magazine</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Großartiger YouTube-Kanal mit Parsing-Programmen in Ghidra</a> </li></ul><br>  Hydra ist also ein <em>kostenloser plattformübergreifender interaktiver Disassembler und Decompiler mit modularem Aufbau, der Unterstützung für fast alle Haupt-CPU-Architekturen und eine flexible grafische Oberfläche für die Arbeit mit disassembliertem Code, Speicher, wiederhergestelltem (dekompiliertem) Code, Debugging-Symbolen und vielem mehr bietet</em> . <br><br>  Versuchen wir etwas mit dieser Hydra zu brechen! <br><a name="habracut"></a><br><h2>  Schritt 1. Finden und studieren Sie den Riss </h2><br>  Als "Opfer" finden wir ein einfaches "Crackme" -Programm.  Ich bin gerade zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">crackmes.one gegangen</a> und habe bei der Suche den Schwierigkeitsgrad = 2-3 ("einfach" und "mittel"), die Ausgangssprache des Programms = "C / C ++" und die Plattform = "Multiplattform" angegeben, wie im folgenden Screenshot gezeigt: <br><br><img src="https://habrastorage.org/webt/oz/hh/4w/ozhh4w-nraygltspefvjnyrvpjk.png"><br><br>  Die Suche ergab 2 Ergebnisse (unten grün).  Der erste Riss stellte sich als 16-Bit heraus und startete nicht auf meinem Win10 64-Bit, aber der zweite ( <b>Level_2 von Seveb</b> ) kam auf.  Sie können es von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Link</a> herunterladen. <br><br>  Laden Sie den Riss herunter und entpacken Sie ihn.  Das auf der Website angegebene Passwort für das Archiv lautet <b>crackmes.de</b> .  Im Archiv finden wir zwei Verzeichnisse, die Linux und Windows entsprechen.  Auf meinem Computer gehe ich in das Windows-Verzeichnis und treffe darin die einzige "ausführbare Datei" - <b>level_2.exe</b> .  Lass uns rennen und sehen, was sie will: <br><br><img src="https://habrastorage.org/webt/qx/mu/yj/qxmuyjfvnatrgoggnmet17egii8.png"><br><br>  Es scheint wie ein Mist!  Beim Start zeigt das Programm nichts an.  Wir versuchen es erneut auszuführen und übergeben ihm eine beliebige Zeichenfolge als Parameter (wartet plötzlich auf einen Schlüssel?) - und wieder nichts ... Aber verzweifeln Sie nicht.  Nehmen wir an, wir müssen auch die Startparameter als Aufgabe herausfinden!  Es ist Zeit, unser "Schweizer Messer" - Hydra - aufzudecken. <br><br><h2>  Schritt 2. Erstellen eines Projekts in Hydra und vorläufige Analyse </h2><br>  Angenommen, Sie haben Hydra bereits installiert.  Wenn noch nicht, dann ist alles einfach. <br><br><div class="spoiler">  <b class="spoiler_title">Installieren Sie Ghidra</b> <div class="spoiler_text">  1) Installieren Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JDK</a> Version 11 oder höher (ich habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">12</a> ) <br><br>  2) Laden Sie Hydra herunter (zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier</a> ) und installieren Sie es (zum Zeitpunkt des Schreibens ist die neueste Version von Hydra 9.0.2, ich habe 9.0.1). <br></div></div><br>  Wir starten Hydra und erstellen im geöffneten Projektmanager sofort ein neues Projekt.  Ich gab ihm den Namen <b>crackme3</b> (d. H. Crackme- und crackme2-Projekte wurden bereits für mich erstellt).  Ein Projekt ist in der Tat ein Verzeichnis von Dateien. Sie können ihm beliebige Dateien zum Studieren hinzufügen (exe, dll usw.).  Wir werden sofort unsere level_2.exe hinzufügen ( <b>Datei | Importieren</b> oder nur die <b>I-</b> Taste): <br><br><img src="https://habrastorage.org/webt/sb/gl/_e/sbgl_e0acdolgbxtvjnuohiscua.png"><br><br>  Wir sehen, dass Hydra vor dem Import unseren experimentellen Quacksalber als 32-Bit-PE (tragbare ausführbare Datei) für das Win32-Betriebssystem und die x86-Plattform identifiziert hat.  Nach dem Import warten wir auf noch mehr Informationen: <br><br><img src="https://habrastorage.org/webt/zb/v0/ga/zbv0gatojwqtmbdejhe6zclenac.png"><br><br>  Hier könnte uns zusätzlich zu der oben erwähnten Bittiefe noch die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Endianness-Reihenfolge</a> interessiert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sein</a> , die in unserem Fall <b>Little</b> (von niedrigem zu hohem Byte) ist, was für die Intel 86. Plattform zu erwarten war. <br><br>  Mit einer vorläufigen Analyse sind wir fertig. <br><br><h2>  Schritt 3. Führen Sie eine automatische Analyse durch </h2><br>  Zeit für eine vollautomatische Analyse des Programms in Hydra.  Dies erfolgt durch Doppelklick auf die entsprechende Datei (level_2.exe).  Hydra ist modular aufgebaut und bietet alle grundlegenden Funktionen mit einem Plug-In-System, das unabhängig hinzugefügt / deaktiviert oder entwickelt werden kann.  Das gleiche gilt für die Analyse - jedes Plugin ist für die Art der Analyse verantwortlich.  Daher sehen wir uns zunächst mit diesem Fenster konfrontiert, in dem Sie die gewünschten Analysetypen auswählen können: <br><br><div class="spoiler">  <b class="spoiler_title">Fenster "Analyseeinstellungen"</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/p2/aw/sa/p2awsa9slwl8tkbjo0mtcbkgnh8.png"></div></div><br>  Für unsere Zwecke ist es sinnvoll, die Standardeinstellungen beizubehalten und die Analyse auszuführen.  Die Analyse selbst wird ziemlich schnell durchgeführt (ich habe ungefähr 7 Sekunden gebraucht), obwohl Benutzer in den Foren sich darüber beschweren, dass Hydra bei großen Projekten an Geschwindigkeit gegenüber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://ru.wikipedia.org/wiki/IDA&amp;usg=ALkJrh">IDA Pro</a> verliert.  Dies mag zutreffen, aber für kleine Dateien ist dieser Unterschied nicht signifikant. <br><br>  Damit ist die Analyse abgeschlossen.  Die Ergebnisse werden im Code-Browser-Fenster angezeigt: <br><br><img src="https://habrastorage.org/webt/lh/dy/e5/lhdye5faqmse8w2evahggln5bge.png"><br><br>  Dieses Fenster ist das Hauptfenster für die Arbeit in Hydra, daher sollten Sie es genauer studieren. <br><br><div class="spoiler">  <b class="spoiler_title">Übersicht über die Code-Browser-Oberfläche</b> <div class="spoiler_text">  Die Standardeinstellungen der Benutzeroberfläche teilen das Fenster in drei Teile. <br><br>  Im <b>zentralen Teil</b> befindet sich das Hauptfenster - eine Auflistung des Disassemblers, die seinen "Brüdern" in IDA, OllyDbg usw. mehr oder weniger ähnlich ist.  Standardmäßig lauten die Spalten in dieser Liste (von links nach rechts): Speicheradresse, Opcode des Befehls, ASM-Befehl, Parameter des ASM-Befehls, Querverweis (falls zutreffend).  Natürlich kann die Anzeige durch Klicken auf die Schaltfläche in Form einer Mauer in der Symbolleiste dieses Fensters geändert werden.  Um ehrlich zu sein, habe ich noch nie eine so flexible Konfiguration der Ausgabe des Disassemblers gesehen, sie ist äußerst praktisch. <br><br>  Im <b>linken Teil des</b> 3-Panels: <br><br><ol><li>  Abschnitte des Programms (klicken Sie mit der Maus, um durch Abschnitte zu navigieren) </li><li>  Zeichenbaum (Importe, Exporte, Funktionen, Überschriften usw.) </li><li>  Geben Sie den Baum der verwendeten Variablen ein </li></ol><br>  Für uns ist das nützlichste Fenster hier ein Symbolbaum, mit dem Sie beispielsweise eine Funktion anhand ihres Namens schnell finden und zur entsprechenden Adresse wechseln können. <br><br>  Auf der <b>rechten Seite finden Sie</b> eine Auflistung des dekompilierten Codes (in unserem Fall in C). <br><br>  Zusätzlich zu den Standardfenstern können Sie im Menü <b>Fenster</b> Dutzende anderer Fenster und Anzeigen an einer beliebigen Stelle im Browser auswählen und platzieren.  Der Einfachheit halber habe ich in der Mitte ein Byte-Fenster und ein Fenster mit einem Funktionsdiagramm sowie rechts Zeichenfolgenvariablen (Zeichenfolgen) und eine Funktionstabelle (Funktionen) hinzugefügt.  Diese Fenster sind jetzt in separaten Registerkarten verfügbar.  Außerdem können alle Fenster abgenommen und "schwebend" gemacht werden, wobei sie nach eigenem Ermessen platziert und in der Größe geändert werden - dies ist meiner Meinung nach auch eine sehr durchdachte Lösung. <br></div></div><br><h2>  Schritt 4. Erlernen des Programmalgorithmus - main () -Funktion </h2><br>  Kommen wir zu einer direkten Analyse unserer Crack-Programme.  In den meisten Fällen sollten Sie zunächst nach dem Einstiegspunkt des Programms suchen, d. H.  Die Hauptfunktion, die beim Start aufgerufen wird.  Da wir wissen, dass unser Crack in C / C ++ geschrieben wurde, vermuten wir, dass der Name der Hauptfunktion <b>main ()</b> oder so ähnlich sein wird :) Es wird gesagt und getan.  Geben Sie "main" in den Filter des <b>Symbolbaums (</b> im linken Bereich) ein und sehen Sie sich die Funktion <b>_main ()</b> im Abschnitt " <b>Funktionen</b> " an.  Gehen Sie mit einem Mausklick dorthin. <br><br><h3>  Übersicht über die main () - Funktion und Umbenennen von obskuren Funktionen </h3><br>  In der Disassembler-Liste wird sofort der entsprechende Codeabschnitt angezeigt, und rechts sehen wir den dekompilierten C-Code dieser Funktion.  Ein weiteres praktisches Merkmal von Hydra ist die Synchronisation der Auswahl: Wenn eine Maus einen Bereich von ASM-Befehlen auswählt, wird der entsprechende Codeabschnitt im Dekompiler hervorgehoben und umgekehrt.  Wenn das Fenster zur Speicheranzeige geöffnet ist, wird die Zuordnung außerdem mit dem Speicher synchronisiert.  Wie sie sagen, ist alles Geniale einfach! <br><br>  Ich stelle sofort ein wichtiges Merkmal der Arbeit in Hydra fest (im Gegensatz beispielsweise zur Arbeit in IDA).  <em>Die Arbeit in Hydra konzentriert sich hauptsächlich auf die Analyse von dekompiliertem Code</em> .  Aus diesem Grund haben die Entwickler von Hydra (wir erinnern uns - wir sprechen über Spione der NSA :)) der Qualität der Dekompilierung und der Bequemlichkeit der Arbeit mit Code große Aufmerksamkeit geschenkt.  Insbesondere können Sie einfach Funktionen, Variablen und Speicherbereiche definieren, indem Sie einfach in den Code doppelklicken.  Außerdem kann jede Variable und Funktion sofort umbenannt werden, was sehr praktisch ist, da die Standardnamen keine Bedeutung haben und verwirrend sein können.  Wie Sie später sehen werden, werden wir diesen Mechanismus häufig verwenden. <br><br>  Hier ist also die <b>main ()</b> -Funktion, die Hydra wie folgt „seziert“ hat: <br><br><div class="spoiler">  <b class="spoiler_title">Listing main ()</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __cdecl _main(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _Argc,<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **_Argv,<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **_Env) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> bVar1; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iVar2; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *_Dest; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> sVar3; FILE *_File; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **ppcVar4; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> local_18; ___main(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_Argc == <span class="hljs-number"><span class="hljs-number">3</span></span>) { bVar1 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; _Dest = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)_text(<span class="hljs-number"><span class="hljs-number">0x100</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>); local_18 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (local_18 &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bVar1) { _text(_Dest,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0x100</span></span>); _text(_Dest,_Argv[local_18],<span class="hljs-number"><span class="hljs-number">0x100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } sVar3 = _text(_Argv[local_18]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((sVar3 == <span class="hljs-number"><span class="hljs-number">2</span></span>) &amp;&amp; (((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*_Argv[local_18] &amp; <span class="hljs-number"><span class="hljs-number">0x7fffffff</span></span>U) == <span class="hljs-number"><span class="hljs-number">0x2d</span></span>)) &amp;&amp; (((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)_Argv[local_18][<span class="hljs-number"><span class="hljs-number">1</span></span>] &amp; <span class="hljs-number"><span class="hljs-number">0x7fffffff</span></span>U) == <span class="hljs-number"><span class="hljs-number">0x66</span></span>)) { bVar1 = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } local_18 = local_18 + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((bVar1) &amp;&amp; (*_Dest != <span class="hljs-number"><span class="hljs-number">0</span></span>)) { _File = _text(_Dest,<span class="hljs-string"><span class="hljs-string">"rb"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_File == (FILE *)<span class="hljs-number"><span class="hljs-number">0x0</span></span>) { _text(<span class="hljs-string"><span class="hljs-string">"Failed to open file"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } ppcVar4 = _construct_key(_File); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ppcVar4 == (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>) { _text(<span class="hljs-string"><span class="hljs-string">"Nope."</span></span>); _free_key((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _text(<span class="hljs-string"><span class="hljs-string">"%s%s%s%s\n"</span></span>,*ppcVar4 + <span class="hljs-number"><span class="hljs-number">0x10d</span></span>,*ppcVar4 + <span class="hljs-number"><span class="hljs-number">0x219</span></span>,*ppcVar4 + <span class="hljs-number"><span class="hljs-number">0x325</span></span>,*ppcVar4 + <span class="hljs-number"><span class="hljs-number">0x431</span></span>); _free_key(ppcVar4); } _text(_File); } _text(_Dest); iVar2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { iVar2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iVar2; }</code> </pre> <br></div></div><br>  Es scheint, dass alles normal erscheint - Definitionen von Variablen, Standard-C-Typen, Bedingungen, Schleifen, Funktionsaufrufe.  Bei näherer Betrachtung des Codes stellen wir jedoch fest, dass die Namen einiger Funktionen aus irgendeinem Grund nicht definiert und durch die <b>Pseudofunktion _text ()</b> (im Dekompilerfenster - <b>.text ()</b> ) ersetzt wurden.  Beginnen wir mit der Definition dieser Funktionen. <br><br>  Doppelklicken Sie auf den Hauptteil des ersten Anrufs <br><br><pre> <code class="cpp hljs"> _Dest = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)_text(<span class="hljs-number"><span class="hljs-number">0x100</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Wir sehen, dass dies nur eine Wrapper-Funktion um die Standardfunktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">calloc ()</a> ist, mit der Speicher für Daten zugewiesen wird.  <b>Benennen</b> wir diese Funktion <b>einfach</b> in <b>calloc2 () um</b> .  Setzen Sie den Cursor auf den Funktionsheader, rufen Sie das Kontextmenü auf, wählen Sie <b>Funktion umbenennen</b> (Hotkey - <b>L</b> ) und geben Sie einen neuen Namen in das folgende Feld ein: <br><br><img src="https://habrastorage.org/webt/nz/q1/3z/nzq13zx8ddn0vsbvni8mkpencyc.png"><br><br>  Wir sehen, dass die Funktion sofort umbenannt wurde.  Wir kehren zum <b>Hauptteil () zurück</b> (die Schaltfläche <b>Zurück</b> in der Symbolleiste oder <b>Alt + &lt;-</b> ) und sehen, dass hier anstelle des mysteriösen <b>_text () calloc2 ()</b> bereits steht.  Großartig! <br><br>  Wir machen dasselbe mit allen anderen Wrapper-Funktionen: Wir gehen nacheinander auf ihre Definitionen ein, schauen uns an, was sie tun, benennen sie um (ich habe Index 2 zu den Standardnamen von C-Funktionen hinzugefügt) und kehren zur Hauptfunktion zurück. <br><br><h3>  Wir verstehen den Funktionscode main () </h3><br>  Okay, wir haben einige seltsame Funktionen herausgefunden.  Wir beginnen den Code der Hauptfunktion zu studieren.  Wenn wir Variablendeklarationen überspringen, sehen wir, dass die Funktion den Wert der Variablen iVar2, der Null ist (ein Zeichen für den Erfolg der Funktion), nur zurückgibt, wenn die durch die Zeichenfolge angegebene Bedingung erfüllt ist <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_Argc == <span class="hljs-number"><span class="hljs-number">3</span></span>) { ... }</code> </pre><br>  <b>_Argc</b> ist die Anzahl der Befehlszeilenparameter (Argumente), die an <b>main () übergeben werden</b> .  Das heißt, unser Programm "frisst" 2 Argumente (das erste Argument, an das wir uns erinnern, ist immer der Pfad zur ausführbaren Datei). <br><br>  OK, lass uns weitermachen.  Hier erstellen wir einen C-String ( <b>char-</b> Array) mit 256 Zeichen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *_Dest; _Dest = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)calloc2(<span class="hljs-number"><span class="hljs-number">0x100</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  new char[256]  C++</span></span></code> </pre><br>  Als nächstes haben wir eine Schleife von 3 Iterationen.  Darin prüfen wir zunächst, ob das Flag <b>bVar1 gesetzt ist,</b> und kopieren in diesem <b>Fall</b> das folgende Befehlszeilenargument (Zeichenfolge) nach <b>_Dest</b> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*    .  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bVar1) { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> memset2(_Dest,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0x100</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*    _Dest    */</span></span> strncpy2(_Dest,_Argv[i],<span class="hljs-number"><span class="hljs-number">0x100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } ... }</code> </pre><br>  Dieses Flag wird gesetzt, wenn das folgende Argument analysiert wird: <br><br><pre> <code class="cpp hljs">n_strlen = strlen2(_Argv[i]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((n_strlen == <span class="hljs-number"><span class="hljs-number">2</span></span>) &amp;&amp; (((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*_Argv[i] &amp; <span class="hljs-number"><span class="hljs-number">0x7fffffff</span></span>U) == <span class="hljs-number"><span class="hljs-number">0x2d</span></span>)) &amp;&amp; (((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)_Argv[i][<span class="hljs-number"><span class="hljs-number">1</span></span>] &amp; <span class="hljs-number"><span class="hljs-number">0x7fffffff</span></span>U) == <span class="hljs-number"><span class="hljs-number">0x66</span></span>)) { bVar1 = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br>  Die erste Zeile berechnet die Länge dieses Arguments.  Ferner prüft die Bedingung, ob die Länge des Arguments 2, das vorletzte Zeichen == "-" und das letzte Zeichen == "f" sein muss.  Beachten Sie, wie der Dekompiler die Extraktion von Zeichen aus der Zeichenfolge mithilfe einer Bytemaske "übersetzt" hat. <br><blockquote>  Dezimalwerte von Zahlen und gleichzeitig die entsprechenden ASCII-Zeichen können ausspioniert werden, indem der Cursor über das entsprechende hexadezimale Literal gehalten wird.  Die ASCII-Zuordnung funktioniert nicht immer (?). Ich empfehle daher, die ASCII-Tabelle im Internet zu betrachten.  Sie können Skalare auch direkt in Hydra von einem beliebigen Zahlensystem in ein anderes konvertieren (über das Kontextmenü -&gt; <b>Konvertieren</b> ). In diesem Fall wird diese Nummer überall im ausgewählten Zahlensystem angezeigt (im Disassembler und im Dekompiler).  aber ich persönlich ziehe es vor, hexes im code zu lassen, um die arbeit zu harmonisieren, weil  Speicheradressen, Offsets usw.  Hexen sind überall gesetzt. <br></blockquote>  Nach der Schleife kommt dieser Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((bVar1) &amp;&amp; (*_Dest != <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">/*    1) "-f"  2)  -         */</span></span> _File = fopen2(_Dest,<span class="hljs-string"><span class="hljs-string">"rb"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_File == (FILE *)<span class="hljs-number"><span class="hljs-number">0x0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*  1    */</span></span> perror2(<span class="hljs-string"><span class="hljs-string">"Failed to open file"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } ... }</code> </pre><br>  Hier habe ich sofort Kommentare hinzugefügt.  Wir überprüfen die Gültigkeit der Argumente ("-f path_to_file") und öffnen die entsprechende Datei (das 2. übergebene Argument, das wir nach _Dest kopiert haben).  Die Datei wird im Binärformat gelesen, wie durch den Parameter "rb" der Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fopen () angegeben</a> .  Wenn der Lesevorgang fehlschlägt (z. B. ist die Datei nicht verfügbar), wird im stderror-Stream eine Fehlermeldung angezeigt und das Programm wird mit Code 1 beendet. <br><br>  Weiter ist das interessanteste: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* !!!     !!! */</span></span> ppcVar3 = _construct_key(_File); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ppcVar3 == (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*    ,  "Nope" */</span></span> puts2(<span class="hljs-string"><span class="hljs-string">"Nope."</span></span>); _free_key((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*    -      */</span></span> printf2(<span class="hljs-string"><span class="hljs-string">"%s%s%s%s\n"</span></span>,*ppcVar3 + <span class="hljs-number"><span class="hljs-number">0x10d</span></span>,*ppcVar3 + <span class="hljs-number"><span class="hljs-number">0x219</span></span>,*ppcVar3 + <span class="hljs-number"><span class="hljs-number">0x325</span></span>,*ppcVar3 + <span class="hljs-number"><span class="hljs-number">0x431</span></span>); _free_key(ppcVar3); } fclose2(_File);</code> </pre><br>  Der offene Dateideskriptor ( <b>_File</b> ) wird an die Funktion <b>_construct_key () übergeben</b> , die offensichtlich die Überprüfung des gesuchten Schlüssels durchführt.  Diese Funktion gibt ein zweidimensionales Byte-Array ( <b>char **</b> ) zurück, das in der Variablen <b>ppcVar3</b> gespeichert ist.  Wenn das Array leer ist, wird das prägnante "Nope" auf der Konsole angezeigt (dh unserer Meinung nach "Nope!") Und der Speicher wird freigegeben.  Andernfalls (wenn das Array nicht leer ist) wird der scheinbar korrekte Schlüssel angezeigt und der Speicher wird ebenfalls freigegeben.  Am Ende der Funktion wird der Dateideskriptor geschlossen, der Speicher freigegeben und der Wert von <b>iVar2 zurückgegeben</b> . <br><br>  Jetzt haben wir erkannt, dass wir Folgendes brauchen: <br><br>  <i>1) Erstellen Sie eine Binärdatei mit dem richtigen Schlüssel.</i> <i><br></i>  <i>2) Übergeben Sie den Pfad im Riss nach dem Argument "-f".</i> <br><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweiten Teil des Artikels werden</a> wir die Funktion <b>_construct_key ()</b> analysieren, die, wie wir herausgefunden haben, für die Überprüfung des gewünschten Schlüssels in der Datei verantwortlich ist. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447450/">https://habr.com/ru/post/de447450/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447438/index.html">Unittest und abstrakte Tests</a></li>
<li><a href="../de447440/index.html">RBKmoney Zahlungen unter der Haube - die Logik der Zahlungsplattform</a></li>
<li><a href="../de447442/index.html">Einführung in den Shell-Operator: Vereinfachung der Bediener für Kubernetes</a></li>
<li><a href="../de447446/index.html">IBM Workshops: Frühling-Sommer 2019 - Künstliche Intelligenz, Cloud-Entwicklung, Chat-Bots, Blockchain und andere Technologien</a></li>
<li><a href="../de447448/index.html">Intelligenz Evolution: Der Anfang</a></li>
<li><a href="../de447452/index.html">Supply Chain Security: "Wenn ich ein Nationalstaat wäre ..."</a></li>
<li><a href="../de447454/index.html">FPGA-Sieben-Segment-Anzeigesteuerung</a></li>
<li><a href="../de447456/index.html">Wie genau sagt Yandex den Niederschlag im Winter voraus? Wir analysieren die Genauigkeit von Predictive Services</a></li>
<li><a href="../de447458/index.html">Wie neue Wörter im modernen Englisch entstehen</a></li>
<li><a href="../de447460/index.html">Hacken Sie Ihren XiaoMi Staubsauger</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>