<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè® üçñ ü§∂üèΩ Erstellen eines Controllers f√ºr ein Smart Home üÜé üå± üòÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir machen einen Controller f√ºr ein Smart Home und nicht nur. 

 In einem fr√ºheren Artikel habe ich die Entwicklung des gesamten Systems beschrieben. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen eines Controllers f√ºr ein Smart Home</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462259/">  Wir machen einen Controller f√ºr ein Smart Home und nicht nur. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">In einem fr√ºheren Artikel habe</a> ich die Entwicklung des gesamten Systems beschrieben.  In diesem Artikel werde ich die Entwicklung eines Controllers beschreiben, der f√ºr die Abfrage von Sensoren und E / A-Modulen verantwortlich ist.  "Warum das Rad neu erfinden?"  - Du fragst.  Erstens ist es interessant, und zweitens gibt es seltsamerweise keine OpenSource-L√∂sung f√ºr einen solchen Controller, der sowohl Software als auch Hardware abdeckt.  Der Artikel richtet sich an Personen, die sich mit Elektronik und Embedded Linux-Entwicklung auskennen. <br><br>  Die Herstellung eines Controllers ist so kompliziert - Sie m√ºssen eine Karte erstellen, Software schreiben und den Fall drucken.  Aber in Wirklichkeit ist alles etwas komplizierter, das hat es mir gebracht, aber Sie haben im Prinzip Recht: <br><a name="habracut"></a><br>  1. Controller-Hardware <br><br>  - Wahl der CPU-Karte f√ºr den Controller <br>  - Wahl des IO-Controllers <br>  - Wahl der Stromversorgung <br>  - Blockschaltbild der Steuerung <br>  - Entwicklung eines Crossboards f√ºr die Steuerung <br>  - Entwicklung von Karten f√ºr RS-485-Module <br>  - Herstellung von Brettern <br><br>  2. Software f√ºr die Steuerung <br><br>  - Wahl des Build-Systems f√ºr Linux-Kernel und Rootfs <br>  - Partitionsstruktur der SD-Karte <br>  - Auswahl des Bootloaders und Laden der erforderlichen Rootfs <br>  - √Ñnderungen im Ger√§tebaum <br>  - die Wahl eines Systems zum Einzug von gehandelten Belastungen <br>  - Schreiben eines Build-Systems <br>  - Schreiben eines Kommunikationskerns <br>  - Schreiben eines mqtt-Gateways (diskrete / analoge Controller-Punkte -&gt; mqtt-Themen) <br>  - Schreiben eines Google-Parsers und Erstellen einer JSON-Konfigurationsdatei f√ºr das Gateway <br>  - Schreiben eines Punktmonitors f√ºr den Zugriff auf Controller-Punkte <br>  - schreibgesch√ºtztes Dateisystem einbinden <br><br>  3. Controller-Geh√§use <br><br>  - Was sollte sein, Anschl√ºsse, K√ºhlung, Sitze f√ºr eine Platine, Hypotheken f√ºr Clips f√ºr Klammern an einer Dinrake. <br>  - Design und Druck <br><br>  Ein paar Worte zur Hardware. <br><br>  Wahrscheinlich nehmen nur die Verzweifeltesten jetzt einen separaten Prozessor, Speicher, Flash, Leistungsregler, ein paar weitere hundert Komponenten und beginnen, alles zusammen zu formen.  Der Rest nutzt die Fr√ºchte der Arbeit anderer Leute, es ist schneller und einfacher.  Sie m√ºssen nur einen Browser √∂ffnen und "Single Board Computer" schreiben und den Rest des Tages damit verbringen, den richtigen auszuw√§hlen.  Ich brauchte viele serielle Schnittstellen und es ist w√ºnschenswert, dass die Platine -40 ¬∞ C bis + 85 ¬∞ C unterst√ºtzt, daher fiel die Wahl auf BeagleBone Black (BBB).  Auch bei BBB sind alle Peripherieger√§te in Schritten von 2,54 mit zwei PBD-Anschl√ºssen mit 46 Pins verbunden, was f√ºr das Prototyping und die Entwicklung einer Cross-Board praktisch ist.  Eine Kreuzplatine wird ben√∂tigt, um alle Komponenten auf einer Platine zu kombinieren. F√ºr mich handelt es sich um eine CPU-Platine, ein Netzteil, einen E / A-Controller und RS485-Kanalplatinen.  Au√üerdem muss die Kreuzplatine am Geh√§use befestigt werden, und es befinden sich Anschl√ºsse f√ºr die Stromversorgung und das RS485-Kabel. <br><br><img src="https://habrastorage.org/webt/oy/jo/6j/oyjo6jzy2qtidg-9ehm5zmtnqtg.jpeg"><br><br>  Also haben wir die CPU-Karte herausgefunden. Als n√§chstes m√ºssen wir entscheiden, ob ein E / A-Controller (Input / Output) auf der Cross-Board installiert werden muss oder nicht.  Ich habe es auf die Tafel gelegt und es noch nicht erfolgreich benutzt.  Das einzige, was er tut, ist, den Start der BBB nach dem Einschalten um 1s zu verschieben und die Reset-Taste zu dr√ºcken. <br><br>  Das Netzteil f√ºr den Controller habe ich mit dem vorgefertigten MeanWell NSD10-12S5 genommen. Die Entwicklung f√ºr ein einzelnes Ger√§t ist ein bedeutungsloses Unterfangen. Ich habe es nur f√ºr den Verbrauch abgeholt und das wars.  Achten Sie nicht auf das LCD, es befindet sich auf der Platine, aber ich habe keine Unterst√ºtzung implementiert. <br><br><img src="https://habrastorage.org/webt/uu/ub/hx/uuubhxrvgg7imxkdmtk6rjsojtu.jpeg"><br><br><img src="https://habrastorage.org/webt/hd/wn/l2/hdwnl2uo05wm6isu1pudumcx8zk.jpeg"><br><br>  Ein paar Worte zu RS485-Kanalkarten. <br><br>  Auf der Kreuzplatine befinden sich 4 serielle BBB-Schnittstellen.  Dort k√∂nnen Sie jede Art von Kanal platzieren, RS485, CAN, ZigBee-Modul ... <br><br>  Ich brauchte RS485-Kan√§le, also habe ich nur diese gemacht, sie sind mit automatischer Empfangs- / Sendesteuerung und mit galvanischer Trennung.  Warum nicht die Transceiver-Steuerung mit BBB verwenden, da TI den Strobe f√ºr RS485 im seriellen Ger√§tetreiber offiziell nicht mehr unterst√ºtzt?  Sie k√∂nnen einen Patch f√ºr den Treiber finden, Sie k√∂nnen ihn selbst hinzuf√ºgen, aber warum?  Nachdem Sie den Kanal selbstsperrend gemacht haben, k√∂nnen Sie ihn auf ein beliebiges Board setzen, z. B. auf RaspberyPi, wo es noch nie eine solche Unterst√ºtzung gegeben hat. Wenn ja, korrigieren Sie mich.  Der Blitz f√ºr den rs485-Treiber ist auf attiny10 konfiguriert, billig und fr√∂hlich. <br><br>  Wir kehren zur Software zur√ºck. <br><br>  Ausw√§hlen eines Build-Systems f√ºr den Linux-Kernel und rootfs. <br><br>  Es gibt verschiedene Systeme dieser Art, die beliebtesten sind Yocto und BuildRoot.  Wenn Sie ein gro√ües Projekt entwickeln m√ºssen, viel Zeit haben und Rezepte schreiben m√∂chten, ist Yocto Ihre Wahl.  Mit Hilfe von BuildRoot k√∂nnen Sie alles sammeln, was Sie zum einfachen Starten des Boards ben√∂tigen. Das ist sehr, sehr einfach, weil  Ich mache ein System auf Beaglebone Black (im Folgenden BBB) dann: <br><br><ol><li>  Lesen Sie, was hier geschrieben steht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">habr.com/en/post/448638</a> </li><li>  sauber machen </li><li>  mache beaglebone_defconfig </li><li>  machen </li></ol><br>  Das ist alles.  Jetzt befindet sich alles, was Sie zum Ausf√ºhren des Boards ben√∂tigen, im Ordner / buildroot / output / images. <br><br>  Alles sieht sehr einfach und nicht interessant aus, so dass Sie etwas komplizierter machen k√∂nnen: <br><br><ol><li>  Integrieren Sie buildroot in Ihr Build-System, laden Sie es mit einem Skript herunter, denken Sie daran, ein stabiles Tag zu verwenden, und nehmen Sie nicht die letzte Entwicklung vor </li><li>  Schreiben Sie Ihre defconfig und werfen Sie das Skript in den Ordner / buildroot / configs, bevor Sie buildroot zusammenstellen. Vergessen Sie nicht, dass alle defconfigs mit * _defconfig enden m√ºssen, sonst sieht buildroot es nicht </li><li>  Kopieren Sie Ihre post-build.sh nach board / beaglebone / post-build.sh </li><li>  Bereiten Sie ein Skript vor, das n1, n2 und n3 f√ºr Sie erledigt </li></ol><br>  Infolgedessen generiert buildroot zImage und rootfs.tar <br><br>  Auswahl der Partitionsstruktur der SD-Karte: <br><br>  Ich denke, es ist nicht notwendig, viel Aufmerksamkeit darauf zu richten. <br>  Ich habe 4 Abschnitte BOOT / ROOT_1 / ROOT_2 / DATA gemacht. <br>  Der BOOT-Abschnitt enth√§lt alles, was Sie zum Bootstrapping ben√∂tigen: MLO, barebox.bin, barebox.env, am335x -boneblack.dtb, zImage, boot.txt. <br><br>  ROOT_1 und ROOT_2 enthalten rootfs, deren Auswahl in die Datei boot.txt geschrieben ist (siehe unten).  Alle diese Partitionen werden schreibgesch√ºtzt gemountet, um Abst√ºrze des Dateisystems beim Ausschalten zu vermeiden.  DATA enth√§lt Designkonfigurationen, bei deren √Ñnderung der Code nicht neu erstellt werden muss. <br><br>  Eine solche Struktur von Partitionen wird es in Zukunft einfacher machen, eine Software-Update-Komponente zu schreiben.  Diese Komponente √ºberschreibt einen der Abschnitte ROOT_1 / ROOT_2, der derzeit nicht verwendet wird, und √§ndert dann einfach die Datei boot.txt, wenn Sie den Kernel nicht √§ndern m√ºssen. <br><br>  Bootloader ausw√§hlen. <br><br>  Ich hatte viele Experimente mit Bootloadern f√ºr BBB.  Zuerst habe ich wie alle anderen den U-Boot verwendet, den BuildRoot generiert.  Aber es hat mir nicht gefallen, vielleicht ist das nat√ºrlich eine Gewohnheit, aber es schien mir, dass es zu viel war, es ist sehr schwer und schwer zu konfigurieren.  Dann dachte ich, dass es keine schlechte Idee w√§re, das System schnell in 2-3 Sekunden zu starten und den X-Loader abzulegen, damit er den Kernel l√§dt. Es gelang mir, aber es gab wieder ein Konfigurationsproblem und die Startzeit f√ºr mich nicht kritisch (das System auf systemd startet langsam von selbst, selbst wenn Sie alles l√∂schen, was nicht ben√∂tigt wird). <br><br>  Am Ende habe ich mich f√ºr Barebox entschieden, die Einfachheit hat mir sehr gut gefallen und die Website enth√§lt die gesamte Dokumentation (www.barebox.org). <br><br>  Um beispielsweise rootfs von der ersten oder zweiten Partition zu laden, m√ºssen Sie nur: <br><br>  1. Erstellen Sie im Boot-Bereich die Datei boot.txt, die eine Variable vom Typ "export BOOT_NUM = X" exportiert. <br><br>  2. Erstellen Sie zwei Skripte / env / boot / sdb1 / env / boot / sdb2, in denen die Startoptionen beschrieben werden, zum Beispiel: <br><br><pre><code class="plaintext hljs">echo "botting with mmcblk0p2 as rootfs..." global.bootm.image=/boot/zImage global.bootm.oftree=/boot/am335x-boneblack.dtb global.linux.bootargs.console="console=ttyO0,115200" global.linux.bootargs.debug="earlyprintk ignore_loglevel" global.linux.bootargs.base="root=/dev/mmcblk0p2 ro rootfstype=ext4 rootwait"</code> </pre> <br>  3. Erstellen Sie ein Skript / env / boot / sd, in dem Sie je nach BOOT_NUM das Skript sdb1 oder sdb2 starten <br><br>  4. Setzen Sie die Variable boot.default <br><br><pre> <code class="plaintext hljs">nv boot.default=sd saveenv</code> </pre> <br>  5. Wenn Sie BOOT_NUM in boot.txt weiter √§ndern, werden wir rootfs von der ersten oder zweiten Partition laden, die in Zukunft f√ºr Software-Updates verwendet werden k√∂nnen. <br><br>  √Ñnderungen am Ger√§tebaum. <br><br>  Da ich MODBUS RTU √ºber RS485 f√ºr die Kommunikation mit den Modulen verwende, musste ich fast alle seriellen Schnittstellen aktivieren, die auf der BBB vorhanden sind.  Dazu m√ºssen Sie sie im Ger√§tebaum wieder aktivieren, weil  Standardm√§√üig sind die meisten von ihnen deaktiviert. <br><br>  Es w√§re richtig, Ihren Patch f√ºr die Datei am335x -bone-common.dtsi aus dem Buildrut-Paket zu erstellen und jedes Mal vor dem Zusammenstellen anzuwenden, aber die Faulheit hat gewonnen und ich habe einfach alle ben√∂tigten Dateien herausgezogen, alles, was ich brauchte, ge√§ndert und mit meinen H√§nden aufgebaut. <br><br>  Weil  Dies wird einmal gemacht, es ist m√∂glich und so: <br><br>  1. Erstellen Sie einen Ordner mit den f√ºr die Montage erforderlichen Dateien: <br><br><pre> <code class="plaintext hljs">am335x-bone-common.dtsi am335x-boneblack-common.dtsi am335x-boneblack.dts am33xx-clocks.dtsi am33xx.dtsi am33xx.h gpio.h omap.h tps65217.dtsi</code> </pre> <br>  2. In der Datei am335x -bone-common.dtsi m√ºssen Sie die Pins korrekt konfigurieren und die Port-Treiber deaktivieren: <br><br><pre> <code class="plaintext hljs">uart1_pins: pinmux_uart1_pins { pinctrl-single,pins = &lt; AM33XX_IOPAD(0x980, PIN_INPUT_PULLUP | MUX_MODE0) AM33XX_IOPAD(0x984, PIN_OUTPUT_PULLDOWN | MUX_MODE0) &gt;; }; uart2_pins: pinmux_uart2_pins { pinctrl-single,pins = &lt; AM33XX_IOPAD(0x950, PIN_INPUT_PULLUP | MUX_MODE1) AM33XX_IOPAD(0x954, PIN_OUTPUT_PULLDOWN | MUX_MODE1) &gt;; }; uart4_pins: pinmux_uart4_pins { pinctrl-single,pins = &lt; AM33XX_IOPAD(0x870, PIN_INPUT_PULLUP | MUX_MODE6) AM33XX_IOPAD(0x874, PIN_OUTPUT_PULLDOWN | MUX_MODE6) &gt;; }; uart5_pins: pinmux_uart5_pins { pinctrl-single,pins = &lt; AM33XX_IOPAD(0x8C4, PIN_INPUT_PULLUP | MUX_MODE4) AM33XX_IOPAD(0x8C0, PIN_OUTPUT_PULLDOWN | MUX_MODE4) &gt;; }; &amp;uart1 { pinctrl-names = "default"; pinctrl-0 = &lt;&amp;uart1_pins&gt;; status = "okay"; }; &amp;uart2 { pinctrl-names = "default"; pinctrl-0 = &lt;&amp;uart2_pins&gt;; status = "okay"; }; &amp;uart4 { pinctrl-names = "default"; pinctrl-0 = &lt;&amp;uart4_pins&gt;; status = "okay"; }; &amp;uart5 { pinctrl-names = "default"; pinctrl-0 = &lt;&amp;uart5_pins&gt;; status = "okay"; };</code> </pre><br>  3. Als n√§chstes ein wenig Magie, und die fertige Datei am335x -boneblack.dtb befindet sich im selben Verzeichnis: <br><br><pre> <code class="plaintext hljs">a. sudo apt-get install device-tree-compiler</code> </pre> <br>  b.  F√ºhren Sie den Pr√§prozessor aus: <br><br><pre> <code class="plaintext hljs">cpp -Wp,-MD,am335x-boneblack.dtb.d.pre.tmp -nostdinc -Iinclude -Isrc -Itestcase-data -undef -D__DTS__ -x assembler-with-cpp -o am335x-boneblack.dtb.dts.tmp am335x-boneblack.dts</code> </pre> <br>  c.  F√ºhren Sie den Compiler selbst aus: <br><br><pre> <code class="plaintext hljs">dtc -O dtb -o am335x-boneblack.dtb -b 0 -i src -d am335x-boneblack.dtb.d.dtc.tmp am335x-boneblack.dtb.dts.tmp</code> </pre> <br>  4. Am335x-Boneblack.dtb sollte auf der Boot-Partition neben dem Kernel abgelegt werden. F√ºgen Sie im Startskript f√ºr Barebox die folgende Zeile hinzu: " <code>global.bootm.oftree=/boot/am335x-boneblack.dtb</code> " <br><br>  Auswahl eines Systems zum Einzug von gehandelten Belastungen. <br><br>  Wie Sie wissen, gibt es keine Systeme ohne Fehler sowie die Analyse eines Multithread-Systems ohne Spuren.  Es ist sehr praktisch, wenn diese Traces nicht einfach in der Konsole angezeigt werden, sondern mit etwas speziell daf√ºr erstelltem gesammelt werden, damit sie nach Prozessen sortiert, Filter angewendet usw. werden k√∂nnen.  Und ich kenne nur ein gutes System, das sowohl unter Host als auch unter Ziel einfach aufzubauen ist.  Dies ist DLT. Wenn Sie noch nie davon geh√∂rt haben, spielt es keine Rolle. Alle Wissensl√ºcken k√∂nnen leicht durch Lesen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">at.projects.genivi.org/wiki/display/PROJ/Diagnostic+Log+and+Trace geschlossen werden</a> . <br>  Dieses System besteht aus dlt-daemon und dlt-viewer.  Wie der Name schon sagt, wird dlt-daemon auf dem Ziel und dlt-viewer auf dem Host ausgef√ºhrt.  Zu all dem, zu Ihrer Bin√§rdatei, von der wir Spuren sammeln m√∂chten, m√ºssen Sie die dlt lib verkn√ºpfen. <br><br><img src="https://habrastorage.org/webt/oi/go/b-/oigob-peuxj5pdvmkdr0vzu5wkc.png"><br><br>  Im Allgemeinen ist alles praktisch, wie man Spuren sammelt und analysiert, empfehle ich. <br><br>  Ein Build-System schreiben. <br><br>  Warum ein Build-System schreiben, weil Sie alles aus den Repositorys herunterladen, mit Ihren H√§nden erstellen und auf der Grundlage dieses Rootfs und Schleiers erstellen k√∂nnen, funktioniert der Controller.  Aber einen solchen Trick in einem Monat zu wiederholen, wird schwieriger sein, und in zwei - das ist im Allgemeinen unm√∂glich.  Auch hier m√ºssen Sie sich daran erinnern, was, wo Sie platzieren, was Sie bauen und wie Sie beginnen sollen.  Nachdem Sie zun√§chst viel Zeit aufgewendet haben, speichern Sie diese sp√§ter und erhalten die M√∂glichkeit, bequem unter Host und Ziel zu erstellen.  Das Build-System besteht aus einer Reihe von Skripten, die den Host zun√§chst auf den Build vorbereiten und Komponenten von Drittanbietern wie Buildroot, Mosquitto und DLT-Daemon aus ihren Repositorys herunterladen, erstellen und an ihren Speicherorten ablegen.  Und dann k√∂nnen Sie den Build Ihres Projekts starten.  Wenn der Build unter dem Host nicht schwierig ist, m√ºssen Sie immer am Build unter dem Ziel basteln, und es w√§re besser, wenn das Skript dies tut. <br><br>  Buildroot kann so konfiguriert werden, dass es ein Post-Build-Skript aufruft, nachdem es rootfs gebildet hat, das in buildroot / output / target liegt.  Dies gibt Ihnen eine gro√üartige Gelegenheit, alles, was Sie brauchen, dort abzulegen.  Und dann enth√§lt das Dateisystem-Image bereits alles, was Sie zum Starten Ihres Systems ben√∂tigen. <br><br>  Das Rezept ist ungef√§hr so: <br><br><ol><li>  Sie m√ºssen Ihre Bin√§rdateien irgendwo in buildroot / output / target kopieren, z. B. in / opt / bin </li><li>  Wenn es Konfigurationen gibt, machen Sie dasselbe mit ihnen, nur in / opt / etc. </li><li>  Kopieren Sie Bin√§rdateien von Drittanbietern. F√ºr mich sind es Moskito, DLT-Daemon, deren Bibliotheken und Konfigurationen </li><li>  Um das System selbst beim Laden des Controllers zu starten, m√ºssen Sie Ihre systemd-Dienste kopieren. Es ist besser, sie in Ihrem Ziel zu kombinieren und wieder zu aktivieren, indem Sie einen Symlink f√ºr mehrere Benutzer erstellen. </li><li>  Kopieren Sie die ge√§nderte fstab (warum, ich werde es Ihnen sp√§ter sagen) </li></ol><br>  Danach m√ºssen Sie nur noch buildroot / output / images / rootfs.tar in den gew√ºnschten Bereich der SD-Karte entpacken und die Stromversorgung einschalten. <br><br><pre> <code class="plaintext hljs">build git repo: https://github.com/azhigaylo/build</code> </pre> <br>  Schreiben eines Kommunikationskerns. <br><br>  Das Konzept ist so alt wie der Modbus selbst. <br><br>  Jedes E / A-Ger√§t in einem Modbus-Netzwerk verf√ºgt √ºber (16-Bit-) Register zum Lesen, Lesen / Schreiben, in denen Daten gespeichert sind und √ºber die diese Ger√§te gesteuert werden.  Die Steuerung verf√ºgt wiederum √ºber Arrays aus diskreten (Status und Bytewert) und analogen Punkten (Status und Gleitkommawert), in denen der Status aller Parameter gespeichert wird. <br><br>  Die Aufgabe des Kommunikationskerns ist also einfach: Sammeln Sie Daten von E / A-Ger√§ten mithilfe des Modbus-Protokolls, ordnen Sie sie Controller-Punkten zu und gew√§hren Sie der oberen Ebene Zugriff auf diese Punkte.  Und wenn Sie etwas verwalten m√ºssen, ist alles in die andere Richtung - das logische Ger√§t (dazu sp√§ter mehr) muss den Controller-Punkt abonniert haben, und das Schreiben in diesen Punkt initiiert die √úbersetzung dieses Parameters in das physische Wasserausgabeger√§t. <br><br><img src="https://habrastorage.org/webt/1v/zb/x4/1vzbx4smmroaleak2dy4jol9gno.jpeg"><br><br>  Um die Daten irgendwie zu strukturieren und mit Ger√§ten zu arbeiten, k√∂nnen Sie das Konzept eines logischen Ger√§ts einf√ºhren, das den Status eines physischen Ger√§ts in Ihrer Software anzeigt. <br><br>  Ich habe auch beschlossen, die logischen Ger√§te in zwei Gruppen zu unterteilen: <br><br><ol><li>  Standard (Widder-Module mit diskreter Ein- / Ausgabe), f√ºr die die Anzahl der Modbus-Register mit Daten im Voraus bekannt ist, und es reicht aus, nur die Controller-Punkte zu bestimmen, an denen diese Daten gespeichert werden sollen. </li><li>  Benutzerger√§te, f√ºr sie ist es notwendig, die Zuordnung von Modbus-Registern zu Controller-Punkten unabh√§ngig zu beschreiben. </li></ol><br>  Aus all diesen Gr√ºnden ist es logisch, eine Art Konfigurator f√ºr den Controller zu haben, egal ob es sich nur um eine JSON-Konfiguration oder ein selbst geschriebenes Tool handelt, das eine bin√§re Konfiguration generiert.  Ich habe die zweite Option, weil es Ideen gab, einen Kommunikationskern so zu schreiben, dass er nicht nur auf dem Linux-Board, sondern auch auf Arduin mit FreeRtos problemlos ausgef√ºhrt werden kann, wodurch die PAL-Ebene in der Software ge√§ndert wird. <br><br>  Im Konfigurator f√ºr jedes Ger√§t m√ºssen Sie die Controller-Portnummer rs485, die Ger√§teadresse und den Controller-Punkt festlegen, an dem der Kommunikationsstatus mit dem Ger√§t angezeigt wird. Au√üerdem werden f√ºr jedes Standardger√§t die Kan√§le beschrieben und f√ºr ein Benutzerger√§t die Register den Punkten zugeordnet. <br><br><img src="https://habrastorage.org/webt/p7/gh/cu/p7ghcubristizrus5hzq_zlfo5i.jpeg"><br><br><img src="https://habrastorage.org/webt/xr/go/nk/xrgonkcogvsn-6j2vjktiiryrlw.jpeg"><br><br>  Eine solche Konfigurationsdatei, die alle erforderlichen Daten zum Aufbau des Modbus-Netzwerks enth√§lt, erm√∂glicht es Ihnen, den Quellcode f√ºr das Projekt nicht zu √§ndern, wenn Sie Eingabe- / Ausgabeger√§te hinzuf√ºgen / entfernen / √§ndern m√ºssen. Es reicht aus, die Parameter im Konfigurator zu √§ndern und sie in der Konfigurationsdatei zu speichern. <br><br>  Beim Start analysiert der Kommunikationskern die Konfiguration und erstellt auf seiner Basis Listen logischer Ger√§te f√ºr jeden rs485-Port des Controllers. Anschlie√üend werden Threads an jedem Port erstellt und eine zyklische Abfrage physischer Ger√§te beginnt. <br><br><pre> <code class="plaintext hljs">core git repo: https://github.com/azhigaylo/homebrain_core</code> </pre> <br>  Mqtt-Gateway schreiben. <br><br>  Tats√§chlich sind Ihre diskreten und analogen Controller-Punkte mit einer propriet√§ren Schnittstelle f√ºr den Zugriff auf sie f√ºr niemanden von Interesse.  Es gibt also nur einen Ausweg - mqtt.  Ich denke, ich werde nicht √ºbertreiben, wenn ich sage, dass dies derzeit das am h√§ufigsten verwendete Protokoll f√ºr den Austausch kleiner Nachrichten ist. Au√üerdem ist es sehr einfach und verst√§ndlich zu verwenden.  Als ich also Daten vom Controller √ºbertragen musste, dachte ich nicht lange dar√ºber nach, was ich verwenden sollte. <br><br><img src="https://habrastorage.org/webt/o_/sf/w0/o_sfw0yj5i-ptu7ohxdqdvnmw68.jpeg"><br><br>  Weil  Ich habe viele Parameter, dann gab es immer Verwirrungen in der Gateway-Konfigurationsdatei, in der die Zuordnung von Controller-Punkten zu mqtt-Gateway-Themen registriert wurde.  Google half der Tabelle und schrieb einen CSV-Parser dieser Tabelle in die JSON-Konfigurationsdatei f√ºr das Gateway. <br><br><img src="https://habrastorage.org/webt/b-/wt/zm/b-wtzmutugygf-_8mj5odnnrguw.jpeg"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gateway Git Repo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Parser Git Repo</a> <br><br>  Schreibpunktmonitor. <br><br>  Manchmal ist es sehr n√ºtzlich zu sehen, was mit den Controller-Punkten passiert. Dazu habe ich eine kleine Anwendung geschrieben, die direkt mit dem Kommunikationskern verbunden ist und den Status von diskreten und analogen Punkten liest.  Ich bin ziemlich eng mit der Benutzeroberfl√§che, also konnte ich die Anwendung irgendwie in QML werfen. Es hat mit einem Knarren funktioniert. Sie k√∂nnen den Punkt z√§hlen, Sie k√∂nnen ihn schreiben, aber ich brauche nicht mehr. <br><br><pre> <code class="plaintext hljs">pointmonitor git repo: https://github.com/azhigaylo/pointmonitor</code> </pre> <br>  Mounten Sie das schreibgesch√ºtzte Dateisystem. <br><br>  Normalerweise achten nur wenige Leute darauf, und selbst in Produktionsprojekten finden Sie Ger√§te, auf denen die Partition mit rootfs beschreibbar ist.  Dies f√ºhrt fr√ºher oder sp√§ter zum Absturz eines der stabilsten Dateisysteme.  Weil  Da der Controller jederzeit ausgeschaltet werden kann, ist dies nur eine Frage der Zeit / des Falls.  Um diese Wahrscheinlichkeit zu minimieren, m√ºssen Sie ein wenig an fstab basteln und es vor dem Erstellen des rootfs-Images wie oben beschrieben dort ablegen.  In fstab m√ºssen Sie erstens das Dateisystem schreibgesch√ºtzt bereitstellen, und zweitens kann alles, was sich √§ndern kann, in tmpfs abgebildet werden. <br><br>  Mein fstab ist das, es kann f√ºr Sie unterschiedlich sein: <br><br><pre> <code class="plaintext hljs">/dev/root / auto ro 0 1 tmpfs /tmp tmpfs nodev,nosuid,size=50M 0 0 tmpfs /srv tmpfs nodev,size=50M 0 0 tmpfs /var/log tmpfs defaults,noatime,size=50M 0 0 tmpfs /var/tmp tmpfs defaults,noatime,size=50M 0 0 tmpfs /var/run tmpfs defaults,noatime,size=50M 0 0 tmpfs /var/lib tmpfs defaults,noatime,size=10M 0 0</code> </pre> <br>  Steuerk√∂rper <br><br>  Ein 3D-Drucker ist seit langem in den Masthead-Abschnitten f√ºr jeden kollektiven Landwirt enthalten. Leider habe ich ihn nicht, aber er ist in Arbeit.  In letzter Zeit ist die Aufregung anderer Mitarbeiter f√ºr ihn verschwunden. Ich benutze dies, wenn ich alles drucke, was ich brauche und was nicht. Sie k√∂nnen davon √ºberzeugt sein, indem Sie meinen vorherigen Beitrag lesen. <br><br>  Wir zeichnen in FreeCAD, wir generieren den Gcode in Cura und wir erhalten einen Fall, ohne zu vergessen, Sitze f√ºr das Board, Ausschnitte f√ºr Steckverbinder und K√ºhlung und Hypotheken f√ºr Clips auf einer Din-Schiene zu machen. <br><br><img src="https://habrastorage.org/webt/7m/yc/y6/7mycy6gz9axqfvspdk_cmyz5oc8.jpeg"><br><br><img src="https://habrastorage.org/webt/j5/i3/dv/j5i3dvtfcb8wkpn1t0uphq7d9lg.jpeg"><br><br>  Nun, das ist alles, jetzt haben wir eine Karte, Software auf einer SD-Karte und eine H√ºlle.  Wir nehmen eine Datei (ich mache keine Witze) und verbinden alles miteinander, schlie√üen die Stromversorgung, RS485-Kabel an und alles beginnt zu funktionieren.  Und du hast gesagt, schwierig, schwierig ... </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462259/">https://habr.com/ru/post/de462259/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462243/index.html">Verbessern der Magento-Front-End-Leistung mit ReactJS</a></li>
<li><a href="../de462245/index.html">Auto Git Bisect als Beispiel f√ºr den Linux-Kernel</a></li>
<li><a href="../de462251/index.html">Ist der Inkognito-Modus im Browser eine Fiktion?</a></li>
<li><a href="../de462253/index.html">Die ersten Experimente am Streaming-Protokoll am Beispiel der CPU- und Prozessorkommunikation im Redd FPGA</a></li>
<li><a href="../de462257/index.html">Kafka auf Kubernetes - ist das gut?</a></li>
<li><a href="../de462263/index.html">Pedal auf den Boden: Erstellen Sie einen weiteren Fu√ümanipulator f√ºr den PC</a></li>
<li><a href="../de462265/index.html">Python und W√ºrfel</a></li>
<li><a href="../de462267/index.html">Lernen Sie den PVS-Studio Static Analyzer f√ºr Java kennen</a></li>
<li><a href="../de462269/index.html">John Romero to Doom: 80er Jahre Game Dev</a></li>
<li><a href="../de462271/index.html">Sperrcode in iOS: Wie Apple von Verteidigung zu Verteidigung zur Bewachung einer einzelnen Grenze wechselte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>