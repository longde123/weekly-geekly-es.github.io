<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👧‍👧 🤘🏻 🏠 Analyser Async / Await en JavaScript avec des exemples 👧🏽 👩🏾‍💼 💲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'auteur de l'article analyse Async / Await en JavaScript à l'aide d'exemples. En général, Async / Await est un moyen pratique d'écrire du code asynch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyser Async / Await en JavaScript avec des exemples</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skillbox/blog/458950/"><img src="https://habrastorage.org/getpro/habr/post_images/2c8/f4a/252/2c8f4a252d33ee663665fd7df02b45ed.jpg"><br><br>  L'auteur de l'article analyse Async / Await en JavaScript à l'aide d'exemples.  En général, Async / Await est un moyen pratique d'écrire du code asynchrone.  Avant cette opportunité, un code similaire a été écrit à l'aide de rappels et de promesses.  L'auteur de l'article original révèle les avantages d'Async / Await en examinant divers exemples. <br><a name="habracut"></a><br><blockquote>  <b>Nous vous rappelons:</b> <i>pour tous les lecteurs de «Habr» - une remise de 10 000 roubles lors de l'inscription à un cours Skillbox en utilisant le code promo «Habr».</i> <br><br>  <b>Skillbox recommande:</b> Le cours de formation en ligne pour les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">développeurs Java</a> . </blockquote><br><h3>  Rappel </h3><br>  Le rappel est une fonction dont l'appel est retardé indéfiniment.  Auparavant, les rappels étaient utilisés dans les parties du code où le résultat ne pouvait pas être obtenu immédiatement. <br><br>  Voici un exemple de lecture asynchrone d'un fichier sur Node.js: <br><br><pre><code class="javascript hljs">fs.readFile(__filename, <span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>, (err, data) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); });</code> </pre> <br>  Des problèmes surviennent lorsque vous devez effectuer plusieurs opérations asynchrones à la fois.  Imaginons ce scénario: une demande est faite à la base de données utilisateurs Arfat, vous devez lire son champ profile_img_url et télécharger une image depuis le serveur someserver.com. <br>  Après le téléchargement, convertissez l'image dans un autre format, par exemple, de PNG en JPEG.  Si la conversion a réussi, un e-mail est envoyé au courrier de l'utilisateur.  De plus, des informations sur l'événement sont entrées dans le fichier transformations.log avec la date. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad5/c3f/e3b/ad5c3fe3bf0f7a68a4d3444614c3133e.png"><br><br>  Il convient de prêter attention à l'imposition de rappels et d'un grand nombre}) dans la dernière partie du code.  Cela s'appelle un enfer de rappel ou une pyramide de malheur. <br><br>  Les inconvénients de cette méthode sont évidents: <br><br><ul><li>  Ce code est difficile à lire. </li><li>  Il est également difficile d'en traiter les erreurs, ce qui entraîne souvent une détérioration de la qualité du code. </li></ul><br>  Afin de résoudre ce problème, des promesses ont été ajoutées à JavaScript.  Ils vous permettent de remplacer l'imbrication profonde des rappels par le mot .then. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e1/503/0ad/9e15030ad0dbb431a63d9f98ec228111.png"><br><br>  Le point positif des promesses était qu'avec elles le code est beaucoup mieux lu, de haut en bas, et non de gauche à droite.  Néanmoins, les promesses ont aussi leurs problèmes: <br><br><ul><li>  Besoin d'ajouter une grande quantité de .puis. </li><li>  Au lieu de try / catch, .catch est utilisé pour gérer toutes les erreurs. </li><li>  Travailler avec plusieurs promesses dans un cycle est loin d'être toujours pratique; dans certains cas, elles compliquent le code. </li></ul><br>  Voici une tâche qui montrera la signification du dernier paragraphe. <br><br>  Supposons qu'il existe une boucle for qui imprime une séquence de nombres de 0 à 10 avec un intervalle aléatoire (0 - n secondes).  En utilisant des promesses, vous devez modifier ce cycle afin que les nombres soient affichés dans la séquence de 0 à 10. Donc, si la sortie zéro prend 6 secondes et les unités prennent 2 secondes, zéro doit d'abord être sorti, puis le compte à rebours de sortie de l'unité commence. <br><br>  Et bien sûr, pour résoudre ce problème, nous n'utilisons pas Async / Await ou .sort.  Un exemple de solution se trouve à la fin. <br><br><h3>  Fonctions asynchrones </h3><br>  L'ajout de fonctions asynchrones à ES2017 (ES8) a simplifié la tâche de travailler avec des promesses.  Je note que les fonctions asynchrones fonctionnent en plus des promesses.  Ces fonctions ne représentent pas des concepts qualitativement différents.  Les fonctions asynchrones ont été conçues comme une alternative au code qui utilise des promesses. <br><br>  Async / Await permet d'organiser le travail avec du code asynchrone dans un style synchrone. <br><br>  Ainsi, la connaissance des promesses facilite la compréhension des principes d'Async / Await. <br><br>  <b>Syntaxe</b> <br><br>  Dans une situation typique, il se compose de deux mots clés: async et wait.  Le premier mot rend la fonction asynchrone.  Ces fonctions permettent d'attendre.  Dans tous les autres cas, l'utilisation de cette fonction entraînera une erreur. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// With function declaration async function myFn() { // await ... } // With arrow function const myFn = async () =&gt; { // await ... } function myFn() { // await fn(); (Syntax Error since no async) }</span></span></code> </pre><br>  Async est inséré au tout début de la déclaration de fonction, et dans le cas de la fonction flèche, entre le signe "=" et les crochets. <br><br>  Ces fonctions peuvent être placées dans un objet en tant que méthodes ou utilisées dans une déclaration de classe. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// As an object's method const obj = { async getName() { return fetch('https://www.example.com'); } } // In a class class Obj { async getResource() { return fetch('https://www.example.com'); } }</span></span></code> </pre> <br>  NB!  Il convient de rappeler que les constructeurs de classes et les getters / setters ne peuvent pas être asynchrones. <br><br>  <b>Sémantique et règles d'exécution</b> <br><br>  Les fonctions asynchrones sont fondamentalement similaires aux fonctions JS standard, mais il existe des exceptions. <br><br>  Ainsi, les fonctions asynchrones renvoient toujours des promesses: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'hello'</span></span>; } fn().then(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log) <span class="hljs-comment"><span class="hljs-comment">// hello</span></span></code> </pre> <br>  En particulier, fn renvoie la chaîne hello.  Eh bien, comme il s'agit d'une fonction asynchrone, la valeur de la chaîne est enveloppée dans une promesse utilisant le constructeur. <br><br>  Voici une conception alternative sans Async: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>); } fn().then(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log); <span class="hljs-comment"><span class="hljs-comment">// hello</span></span></code> </pre> <br>  Dans ce cas, le retour de la promesse se fait "manuellement".  Une fonction asynchrone s'enveloppe toujours dans une nouvelle promesse. <br><br>  Dans le cas où la valeur de retour est une primitive, la fonction asynchrone renvoie une valeur en l'enveloppant dans une promesse.  Dans le cas où la valeur de retour est l'objet de la promesse, sa solution est retournée dans la nouvelle promesse. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>) p <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>; <span class="hljs-comment"><span class="hljs-comment">// true Promise.resolve(p) === p; // true</span></span></code> </pre><br>  Mais que se passe-t-il si une erreur se produit à l'intérieur de la fonction asynchrone? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>); } foo().catch(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log);</code> </pre> <br>  S'il n'est pas traité, foo () renverra une promesse avec un redject.  Dans cette situation, au lieu de Promise.resolve, Promise.reject renverra contenant une erreur. <br><br>  Les fonctions asynchrones en sortie donnent toujours des promesses, indépendamment de ce qui est retourné. <br><br>  Les fonctions asynchrones sont suspendues à chaque attente. <br><br>  Attendre affecte les expressions.  Ainsi, si l'expression est une promesse, la fonction asynchrone est suspendue jusqu'à l'exécution de la promesse.  Dans le cas où l'expression n'est pas une promesse, elle est convertie en promesse via Promise.resolve puis arrêtée. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// utility function to cause delay // and get random value const delayAndGetRandom = (ms) =&gt; { return new Promise(resolve =&gt; setTimeout( () =&gt; { const val = Math.trunc(Math.random() * 100); resolve(val); }, ms )); }; async function fn() { const a = await 9; const b = await delayAndGetRandom(1000); const c = await 5; await delayAndGetRandom(1000); return a + b * c; } // Execute fn fn().then(console.log);</span></span></code> </pre> <br>  Voici une description du fonctionnement de la fonction fn. <br><br><ul><li>  Après l'avoir appelé, la première ligne est convertie de const a = attendre 9;  dans const a = attendre Promise.resolve (9);. </li><li>  Après avoir utilisé Await, l'exécution de la fonction est suspendue jusqu'à ce qu'elle reçoive sa valeur (dans la situation actuelle, elle est 9). </li><li>  delayAndGetRandom (1000) suspend l'exécution de la fonction fn jusqu'à ce qu'elle se termine (après 1 seconde).  En fait, cela arrête la fonction fn pendant 1 seconde. </li><li>  delayAndGetRandom (1000) via la résolution renvoie une valeur aléatoire, qui est ensuite affectée à la variable b. </li><li>  Eh bien, le cas de la variable c est similaire au cas de la variable a.  Après cela, tout s'arrête pendant une seconde, mais maintenant delayAndGetRandom (1000) ne renvoie rien, car cela n'est pas obligatoire. </li><li>  En conséquence, les valeurs sont calculées par la formule a + b * c.  Le résultat est encapsulé dans une promesse à l'aide de Promise.resolve et renvoyé par la fonction. </li></ul><br>  Ces pauses peuvent ressembler à des générateurs dans ES6, mais il y a des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">raisons à cela</a> . <br><br><h3>  Nous résolvons le problème </h3><br>  Eh bien, regardons maintenant la solution au problème mentionné ci-dessus. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/40b/ec5/c45/40bec5c4564dfabbe1810db3d4a60c2d.png"><br><br>  La fonction finishMyTask utilise Await pour attendre les résultats d'opérations telles que queryDatabase, sendEmail, logTaskInFile et autres.  Si nous comparons cette décision avec l'endroit où les promesses ont été utilisées, les similitudes deviendront apparentes.  Néanmoins, la version avec Async / Await simplifie considérablement toutes les difficultés syntaxiques.  Dans ce cas, il n'y a pas beaucoup de rappels et de chaînes comme .then / .catch. <br><br>  Voici une solution avec la sortie des nombres, il y a deux options. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wait = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i, ms</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(i), ms)); <span class="hljs-comment"><span class="hljs-comment">// Implementation One (Using for-loop) const printNumbers = () =&gt; new Promise((resolve) =&gt; { let pr = Promise.resolve(0); for (let i = 1; i &lt;= 10; i += 1) { pr = pr.then((val) =&gt; { console.log(val); return wait(i, Math.random() * 1000); }); } resolve(pr); }); // Implementation Two (Using Recursion) const printNumbersRecursive = () =&gt; { return Promise.resolve(0).then(function processNextPromise(i) { if (i === 10) { return undefined; } return wait(i, Math.random() * 1000).then((val) =&gt; { console.log(val); return processNextPromise(i + 1); }); }); };</span></span></code> </pre> <br>  Et voici une solution utilisant des fonctions asynchrones. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printNumbersUsingAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> wait(i, <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); } }</code> </pre> <br>  <b>Gestion des erreurs</b> <br><br>  Les erreurs non traitées sont enveloppées dans des promesses rejetées.  Cependant, dans les fonctions asynchrones, vous pouvez utiliser la construction try / catch pour effectuer une gestion des erreurs synchrone. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canRejectOrReturn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// wait one second await new Promise(res =&gt; setTimeout(res, 1000)); // Reject with ~50% probability if (Math.random() &gt; 0.5) { throw new Error('Sorry, number too big.') } return 'perfect number'; }</span></span></code> </pre> <br>  canRejectOrReturn () est une fonction asynchrone qui réussit («nombre parfait») ou échoue avec une erreur («Désolé, nombre trop grand»). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> canRejectOrReturn(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'error caught'</span></span>; } }</code> </pre> <br>  Étant donné que canRejectOrReturn devrait s'exécuter dans l'exemple ci-dessus, sa propre terminaison infructueuse entraînera l'exécution du bloc catch.  Par conséquent, la fonction foo se terminera soit avec undefined (lorsque rien n'est retourné dans le bloc try) soit avec une erreur interceptée.  En conséquence, cette fonction n'échouera pas, car try / catch gérera la fonction foo elle-même. <br><br>  Voici un autre exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> canRejectOrReturn(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'error caught'</span></span>; } }</code> </pre> <br>  Il convient de prêter attention au fait que dans l'exemple de foo, canRejectOrReturn est retourné.  Foo dans ce cas se termine par un nombre parfait ou renvoie une erreur Error ("Désolé, nombre trop grand").  Le bloc catch ne sera jamais exécuté. <br><br>  Le problème est que foo renvoie la promesse passée de canRejectOrReturn.  Par conséquent, la solution de la fonction foo devient la solution de canRejectOrReturn.  Dans ce cas, le code ne comprendra que deux lignes: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = canRejectOrReturn(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> promise; }</code> </pre> <br>  Mais que se passe-t-il si vous utilisez attendre et revenir ensemble: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> canRejectOrReturn(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'error caught'</span></span>; } }</code> </pre> <br>  Dans le code ci-dessus, foo réussit avec un nombre parfait et une erreur interceptée.  Il n'y aura pas d'échecs.  Mais foo se terminera par canRejectOrReturn, et non par undefined.  Assurons-nous de cela en supprimant la ligne de retour en attente canRejectOrReturn (): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> canRejectOrReturn(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-comment"><span class="hljs-comment">// …</span></span></code> </pre> <br><h3>  Erreurs et pièges courants </h3><br>  Dans certains cas, l'utilisation d'Async / Await peut entraîner des erreurs. <br><br>  <b>Oublié attendre</b> <br><br>  Cela se produit assez souvent - avant la promesse, le mot-clé wait est oublié: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { canRejectOrReturn(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'caught'</span></span>; } }</code> </pre> <br>  Dans le code, comme vous pouvez le voir, il n'y a ni attente ni retour.  Par conséquent, foo sort toujours avec undefined sans délai de 1 seconde.  Mais la promesse sera tenue.  S'il donne une erreur ou un redject, alors UnhandledPromiseRejectionWarning sera appelé. <br><br>  <b>Fonctions asynchrones dans les rappels</b> <br><br>  Les fonctions asynchrones sont souvent utilisées dans .map ou .filter comme rappels.  Un exemple est la fonction fetchPublicReposCount (username), qui renvoie le nombre de référentiels ouverts sur GitHub.  Disons qu'il y a trois utilisateurs dont nous avons besoin de mesures.  Voici le code de cette tâche: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">'https://api.github.com/users'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Utility fn to fetch repo counts const fetchPublicReposCount = async (username) =&gt; { const response = await fetch(`${url}/${username}`); const json = await response.json(); return json['public_repos']; }</span></span></code> </pre> <br>  Nous avons besoin de comptes ArfatSalman, octocat, norvig.  Dans ce cas, exécutez: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = [ <span class="hljs-string"><span class="hljs-string">'ArfatSalman'</span></span>, <span class="hljs-string"><span class="hljs-string">'octocat'</span></span>, <span class="hljs-string"><span class="hljs-string">'norvig'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counts = users.map(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> username =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchPublicReposCount(username); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; });</code> </pre> <br>  Vous devez faire attention à Attendre dans le rappel .map.  Ici, compte est un tableau de promesses, eh bien .map est un rappel anonyme pour chaque utilisateur spécifié. <br><br>  <b>Utilisation excessivement cohérente de l'attente</b> <br><br>  Prenez le code suivant comme exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchAllCounts</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counts = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; users.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> username = users[i]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchPublicReposCount(username); counts.push(count); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counts; }</code> </pre> <br>  Ici, le numéro de dépôt est placé dans la variable de comptage, puis ce nombre est ajouté au tableau des comptages.  Le problème avec le code est que jusqu'à ce que les premières données utilisateur arrivent du serveur, tous les utilisateurs suivants seront en mode veille.  Ainsi, en un seul instant, un seul utilisateur est traité. <br><br>  Si, par exemple, il faut environ 300 ms pour traiter un utilisateur, alors pour tous les utilisateurs, c'est déjà une seconde, le temps passé linéairement dépend du nombre d'utilisateurs.  Mais puisque l'obtention du nombre de dépôts ne dépend pas les uns des autres, les processus peuvent être parallélisés.  Cela nécessite de travailler avec .map et Promise.all: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchAllCounts</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promises = users.map(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> username =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchPublicReposCount(username); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(promises); }</code> </pre> <br>  Promise.all à l'entrée reçoit un tableau de promesses avec le retour de la promesse.  La dernière après la fin de toutes les promesses dans le tableau ou au premier redject est terminée.  Il peut arriver que tous ne démarrent pas en même temps - afin d'assurer un lancement simultané, vous pouvez utiliser p-map. <br><br><h3>  Conclusion </h3><br>  Les fonctionnalités asynchrones deviennent de plus en plus importantes pour le développement.  Eh bien, pour une utilisation adaptative des fonctions asynchrones, il vaut la peine d'utiliser des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow noopener noreferrer">itérateurs</a> asynchrones.  Le développeur JavaScript doit être bien familiarisé avec cela. <br><br><blockquote>  <b>Skillbox recommande:</b> <br><br><ul><li>  Cours pratique <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Mobile Developer PRO"</a> . </li><li>  Cours en ligne appliqué <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Data Analyst in Python"</a> . </li><li>  Cours pratique de deux ans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Je suis un développeur Web PRO»</a> . </li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458950/">https://habr.com/ru/post/fr458950/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458936/index.html">"Il est plus facile de répondre que de garder le silence" - une grande interview avec le père de la mémoire transactionnelle, Maurice Herlichi</a></li>
<li><a href="../fr458938/index.html">C ++ 20 est intégré, C ++ 23 est démarré. Résultats de la réunion à Cologne</a></li>
<li><a href="../fr458940/index.html">Comment nous avons implémenté les tests agiles</a></li>
<li><a href="../fr458944/index.html">L'embauche d'un employé commence par ... le respect. Nous allons interviewer l'ingénieur</a></li>
<li><a href="../fr458948/index.html">Habr Weekly # 8 / Yandex Sorcerers, un livre sur Prince of Persia, YouTube contre les pirates, le laser «cœur» du Pentagone</a></li>
<li><a href="../fr458952/index.html">Réglage des paramètres PostgreSQL pour optimiser les performances</a></li>
<li><a href="../fr458954/index.html">Quels types de détection sont utiles en vidéosurveillance. Mécanismes et fonctions</a></li>
<li><a href="../fr458956/index.html">Apprentissage automatique vs approche analytique</a></li>
<li><a href="../fr458960/index.html">Quête d'entreprise</a></li>
<li><a href="../fr458962/index.html">Convertissez l'image en son - qu'entendez-vous?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>