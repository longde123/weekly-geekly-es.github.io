<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤® ğŸ“˜ ğŸ‘©ğŸ¿â€ğŸ’¼ Hampir semua yang Anda ingin tahu tentang floating point di ARM, tetapi takut untuk bertanya â†”ï¸ ğŸ¤ğŸ¼ âš—ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Pada artikel ini saya ingin berbicara tentang pekerjaan floating point untuk prosesor dengan arsitektur ARM. Saya pikir artikel ini akan b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hampir semua yang Anda ingin tahu tentang floating point di ARM, tetapi takut untuk bertanya</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/embox/blog/418295/"><img src="https://habrastorage.org/webt/uz/l3/0w/uzl30wgy6ecwi5eg7gmrtrdbzd4.jpeg" align="right" width="320">  Halo, Habr!  Pada artikel ini saya ingin berbicara tentang pekerjaan floating point untuk prosesor dengan arsitektur ARM.  Saya pikir artikel ini akan berguna terutama bagi mereka yang port OS mereka ke arsitektur ARM dan pada saat yang sama mereka membutuhkan dukungan untuk perangkat keras floating point (yang kami lakukan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Embox</a> , yang sebelumnya menggunakan implementasi perangkat lunak operasi floating point). <br><br>  Jadi mari kita mulai. <br><a name="habracut"></a><br><h2>  Bendera kompiler </h2><br>  Untuk mendukung floating point, Anda harus memberikan flag yang benar ke compiler.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Googling</a> cepat kami mengarah pada gagasan bahwa dua opsi sangat penting: -mfloat-abi dan -mfpu.  Opsi -mfloat-abi menetapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ABI</a> untuk operasi floating point dan dapat memiliki salah satu dari tiga nilai: 'soft', 'softfp' dan 'hard'.  Opsi 'lunak', seperti namanya, memberi tahu kompiler untuk menggunakan panggilan fungsi bawaan untuk memprogram titik mengambang (opsi ini digunakan sebelumnya).  Dua 'softfp' dan 'hard' yang tersisa akan dipertimbangkan sedikit kemudian, setelah mempertimbangkan opsi -mfpu. <br><br><h2>  Bendera -Mfpu dan versi VFP </h2><br>  Opsi -mfpu, seperti yang tertulis dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi online gcc</a> , memungkinkan Anda menentukan jenis perangkat keras dan dapat mengambil opsi berikut: <br><blockquote>  'otomatis', 'vfpv2', 'vfpv3', 'vfpv3-fp16', 'vfpv3-d16', 'vfpv3-d16-fp16', 'vfpv3xd', 'vfpv3xd-fp16', 'neon-vfpv', 'neon-vfp3' -fp16 ',' vfpv4 ',' vfpv4-d16 ',' fpv4-sp-d16 ',' neon-vfpv4 ',' fpv5-d16 ',' fpv5-sp-d16 ',' fp-armv8 ',' neon -fp-armv8 'dan' crypto-neon-fp-armv8 '.  Dan 'neon' sama dengan 'neon-vfpv3', dan 'vfp' adalah 'vfpv2'. </blockquote>  Kompiler saya (arm-none-eabi-gcc (15: 5.4.1 + svn241155-1) 5.4.1 20160919) menghasilkan daftar yang sedikit berbeda, tetapi ini tidak mengubah esensinya.  Bagaimanapun, kita perlu memahami bagaimana flag ini atau itu mempengaruhi kompiler, dan tentu saja, flag mana yang harus digunakan kapan. <br><br>  Saya mulai memahami platform berdasarkan pada prosesor IMX6, tetapi kami akan menundanya untuk sementara waktu, karena neon coprocessor memiliki fitur yang akan saya bahas nanti, dan kami akan mulai dengan case yang lebih sederhana - dari platform <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">integrator / cp</a> , <br>  Saya tidak memiliki papan itu sendiri, jadi debugging dilakukan pada emulator qemu.  Dalam qemu, platform Interator / cp didasarkan pada prosesor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ARM926EJ-S</a> , yang pada gilirannya mendukung coprocessor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">VFP9-S</a> .  Coprocessor ini mematuhi Vector Floating-point Architecture versi 2 (VFPv2).  Oleh karena itu, Anda perlu mengatur -mfpu = vfpv2, tetapi opsi ini tidak ada dalam daftar opsi dari kompiler saya.  Di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Internet,</a> saya bertemu opsi kompilasi dengan flag -mcpu = arm926ej-s -mfpu = vfpv3-d16, memasangnya, dan semuanya dikompilasi untuk saya.  Ketika saya mulai, saya menerima <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengecualian instruksi yang tidak ditentukan</a> , yang dapat diprediksi, karena coprocessor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dimatikan</a> . <br><br>  Untuk mengaktifkan coprocessor, Anda perlu mengatur bit EN [30] dalam register <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FPEXC</a> .  Ini dilakukan dengan menggunakan perintah VMSR. <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Enable FPU extensions */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"VMSR FPEXC, %0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"r"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &lt;&lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">30</span></span></span></span><span class="hljs-function"><span class="hljs-params">);</span></span></span></span></code> </pre> <br>  Sebenarnya, perintah VMSR diproses oleh coprocessor dan melempar pengecualian jika coprocessor tidak dihidupkan, tetapi mengakses register <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini tidak menyebabkannya</a> .  Benar, tidak seperti yang lain, akses ke register ini hanya dimungkinkan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mode istimewa</a> . <br><br>  Setelah coprocessor diizinkan bekerja, tes kami untuk fungsi matematika mulai berlalu.  Tetapi ketika saya mengaktifkan optimasi (-O2), pengecualian instruksi yang tidak disebutkan sebelumnya dinaikkan.  Dan itu muncul pada instruksi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">vmov</a> yang dipanggil dalam kode sebelumnya, tetapi dieksekusi dengan sukses (tanpa kecuali).  Akhirnya, saya menemukan pada akhir halaman kalimat "Instruksi yang menyalin konstanta langsung tersedia di VFPv3" (yaitu, operasi dengan konstanta didukung mulai dari VFPv3).  Dan saya memutuskan untuk memeriksa versi mana yang dirilis di emulator saya.  Versi ini dicatat dalam register <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FPSID</a> .  Dari dokumentasi itu berikut bahwa nilai register harus 0x41011090.  Ini sesuai dengan 1 di bidang arsitektur [19..16] yaitu VFPv2.  Sebenarnya, setelah mencetak di startup, saya dapat ini <br><br><pre> <code class="hljs pgsql"> unit: initializing embox.arch.arm.fpu.vfp9_s: VPF <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>: Hardware FP support Implementer = <span class="hljs-number"><span class="hljs-number">0x41</span></span> (ARM) Subarch: VFPv2 Part number = <span class="hljs-number"><span class="hljs-number">0x10</span></span> Variant = <span class="hljs-number"><span class="hljs-number">0x09</span></span> Revision = <span class="hljs-number"><span class="hljs-number">0x00</span></span></code> </pre> <br>  Setelah dengan hati-hati membaca bahwa 'vfp' adalah alias 'vfpv2', saya menetapkan flag yang benar, itu berfungsi.  Kembali ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman di</a> mana saya melihat kombinasi flag -mcpu = arm926ej-s -mfpu = vfpv3-d16, saya perhatikan bahwa saya tidak cukup berhati-hati, karena -mfloat-abi = soft muncul di daftar flag.  Artinya, tidak ada dukungan perangkat keras dalam hal ini.  Lebih tepatnya, -mfpu hanya penting jika nilai selain 'lunak' disetel ke -mfloat-abi. <br><br><h2>  Assembler </h2><br>  Saatnya berbicara tentang assembler.  Setelah semua, saya perlu membuat dukungan runtime, dan, misalnya, kompiler, tentu saja, tidak tahu tentang pengalihan konteks. <br><br><h3>  Daftar </h3><br>  Mari kita mulai dengan deskripsi register.  VFP memungkinkan Anda untuk melakukan operasi dengan angka floating-point 32-bit (s0..s31) dan 64-bit (d0..d15) .Korespondensi antara register ini ditunjukkan pada gambar di bawah ini. <br><br><img src="https://habrastorage.org/webt/jr/lo/w0/jrlow0oljuvwjd0y5bb-qkxlyh4.png"><br><br>  Q0-Q15 adalah register 128-bit dari versi lama untuk bekerja dengan SIMD, lebih lanjut tentangnya nanti. <br><br><h3>  Sistem komando </h3><br>  Tentu saja, paling sering pekerjaan dengan register VFP harus diberikan kepada kompiler, tetapi setidaknya Anda harus menulis konteks switch secara manual.  Jika Anda sudah memiliki pemahaman perkiraan tentang sintaksis instruksi assembler untuk bekerja dengan register tujuan umum, berurusan dengan instruksi baru seharusnya tidak sulit.  Paling sering, awalan "v" hanya ditambahkan. <br><br><pre> <code class="hljs powershell">vmov d0, r0, r1 /*  r0  r1, ..  d0 <span class="hljs-number"><span class="hljs-number">64</span></span> ,   r0<span class="hljs-literal"><span class="hljs-literal">-1</span></span>  <span class="hljs-number"><span class="hljs-number">32</span></span> */ vmov r0, r1, d0 vadd d0, d1, d2 vldr d0, r0 vstm r0!, {d0<span class="hljs-literal"><span class="hljs-literal">-d15</span></span>} vldm r0!, {d0<span class="hljs-literal"><span class="hljs-literal">-d15</span></span>}</code> </pre> <br>  Dan sebagainya.  Daftar lengkap perintah dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web ARM</a> . <br><br>  Dan tentu saja, jangan lupa tentang versi VFP sehingga tidak ada situasi seperti yang dijelaskan di atas. <br><br><h2>  Tandai -mfloat-abi 'softfp' dan 'hard' </h2><br>  Kembali ke -mfloat-abi.  Jika Anda membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasinya</a> , kita akan melihat: <br><blockquote>  'softfp' memungkinkan pembuatan kode menggunakan instruksi floating-point perangkat keras, tetapi masih menggunakan konvensi pemanggilan soft-float.  'hard' memungkinkan pembuatan instruksi floating-point dan menggunakan konvensi pemanggilan khusus FPU. </blockquote>  Artinya, kita berbicara tentang meneruskan argumen ke suatu fungsi.  Tapi setidaknya tidak jelas bagi saya apa perbedaan antara konvensi panggilan â€œsoft-floatâ€ dan â€œFPU-specificâ€.  Dengan asumsi bahwa hard case menggunakan register floating point, dan case softfp menggunakan register integer, saya menemukan konfirmasi pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wiki debian</a> .  Dan meskipun ini adalah untuk NEON coprocessors, tetapi itu tidak masalah.  Hal lain yang menarik adalah bahwa dengan opsi softfp, kompiler dapat, tetapi tidak diharuskan untuk menggunakan dukungan perangkat keras: <br><blockquote>  â€œCompiler dapat membuat pilihan cerdas tentang kapan dan apakah ia menghasilkan instruksi FPU yang ditiru atau nyata tergantung pada tipe FPU yang dipilih (-mfpu =)â€œ </blockquote>  Untuk kejelasan yang lebih baik, saya memutuskan untuk bereksperimen, dan sangat terkejut, karena dengan optimasi -O0 dimatikan, perbedaannya sangat kecil dan tidak berlaku untuk tempat-tempat di mana floating point sebenarnya digunakan.  Menebak bahwa kompiler hanya mendorong semua yang ada di stack, daripada menggunakan register, saya menyalakan optimasi -O2 dan sekali lagi terkejut, karena dengan optimasi kompiler mulai menggunakan register floating point hardware untuk opsi hard dan sotffp, dan perbedaannya adalah bagaimana dan dalam kasus -O0 itu sangat tidak signifikan.  Sebagai hasilnya, untuk saya sendiri, saya menjelaskan ini dengan fakta bahwa kompiler menyelesaikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah yang</a> terkait dengan fakta bahwa jika Anda menyalin data antara register titik mengambang dan bilangan bulat, kinerja akan turun secara signifikan.  Dan kompiler, ketika mengoptimalkan, mulai menggunakan semua sumber daya yang tersedia. <br><br>  Ketika ditanya flag mana yang menggunakan 'softfp' atau 'hard', saya menjawab sendiri sebagai berikut: di mana ada bagian yang sudah dikompilasi dengan flag 'softfp', Anda harus menggunakan 'hard'.  Jika ada, maka Anda perlu menggunakan 'softfp'. <br><br><h2>  Sakelar konteks </h2><br>  Karena Embox mendukung multitasking preemptive, untuk bekerja dengan benar dalam runtime, tentu saja, implementasi pengalihan konteks diperlukan.  Untuk ini, perlu menyimpan register coprocessor.  Ada beberapa nuansa.  Pertama: ternyata <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perintah operasi stack untuk floating point (vstm / vldm) tidak mendukung semua mode</a> .  Kedua: operasi ini tidak mendukung kerja dengan lebih dari enam belas register 64-bit.  Jika Anda perlu memuat / menyimpan lebih banyak register sekaligus, Anda perlu menggunakan dua instruksi. <br><br>  Saya akan memberikan satu lagi optimasi kecil.  Bahkan, menyimpan dan mengembalikan 256 byte register VFP setiap kali tidak diperlukan sama sekali (register tujuan umum hanya menempati 64 byte, sehingga perbedaannya signifikan).  Optimalisasi yang jelas akan melakukan operasi ini hanya jika proses menggunakan register ini pada prinsipnya. <br><br>  Seperti yang telah saya sebutkan, ketika coprocessor VFP dimatikan, upaya untuk mengeksekusi instruksi yang sesuai akan menghasilkan pengecualian "Undefined Instruction".  Dalam penangan pengecualian ini, Anda perlu memeriksa apa yang disebabkan oleh pengecualian, dan jika itu adalah masalah menggunakan coprocessor VPF, maka proses ditandai sebagai menggunakan coprocessor VFP. <br><br>  Sebagai hasilnya, save / restore konteks yang sudah ditulis ditambah dengan makro <br><br><pre> <code class="hljs tex">#define ARM_FPU_CONTEXT_SAVE_INC(tmp, stack) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vmrs tmp, FPEXC ; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>stmia stack!, {tmp}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ands tmp, tmp, #1&lt;&lt;30; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>beq fpu_out_save_inc; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vstmia stack!, {d0-d15}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>fpu_out_save_inc: #define ARM_FPU_CONTEXT_LOAD_INC(tmp, stack) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ldmia stack!, {tmp}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vmsr FPEXC, tmp; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ands tmp, tmp, #1&lt;&lt;30; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>beq fpu_out_load_inc; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vldmia stack!, {d0-d15}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>fpu_out_load_inc:</code> </pre> <br>  Untuk memeriksa kebenaran dari operasi switching konteks dalam kondisi floating-point, kami menulis tes di mana kami mengalikan dalam satu utas dalam satu lingkaran dan membaginya dalam yang lain, kemudian membandingkan hasilnya. <br><br><pre> <code class="cpp hljs">EMBOX_TEST_SUITE(<span class="hljs-string"><span class="hljs-string">"FPU context consistency test. Must be compiled with -02"</span></span>); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TICK_COUNT 10 static float res_out[2][TICK_COUNT]; static void *fpu_context_thr1_hnd(void *arg) { float res = 1.0f; int i; for (i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; TICK_COUNT; ) { res_out[0][i] = res; if (i == 0 || res_out[1][i - 1] &gt; 0) { i++; } if (res &gt; 0.000001f) { res /= 1.01f; } sleep(0); } return NULL; } static void *fpu_context_thr2_hnd(void *arg) { float res = 1.0f; int i = 0; for (i = 0; i &lt; TICK_COUNT; ) { res_out[1][i] = res; if (res_out[0][i] != 0) { i++; } if (res &lt; 1000000.f) { res *= 1.01f; } sleep(0); } return NULL; } TEST_CASE("Test FPU context consistency") { pthread_t threads[2]; pthread_t tid = 0; int status; status = pthread_create(&amp;threads[0], NULL, fpu_context_thr1_hnd, &amp;tid); if (status != 0) { test_assert(0); } status = pthread_create(&amp;threads[1], NULL, fpu_context_thr2_hnd, &amp;tid); if (status != 0) { test_assert(0); } pthread_join(threads[0], (void**)&amp;status); pthread_join(threads[1], (void**)&amp;status); test_assert(res_out[0][0] != 0 &amp;&amp; res_out[1][0] != 0); for (int i = 1; i &lt; TICK_COUNT; i++) { test_assert(res_out[0][i] &lt; res_out[0][i - 1]); test_assert(res_out[1][i] &gt; res_out[1][i - 1]); } }</span></span></span></span></code> </pre> <br>  Tes berhasil lulus ketika optimasi dimatikan, jadi kami menunjukkan dalam deskripsi tes bahwa itu harus dikompilasi dengan optimasi, EMBOX_TEST_SUITE ("Tes konsistensi konteks FPU. Harus dikompilasi dengan -02");  Meskipun kita tahu bahwa tes tidak harus bergantung pada ini. <br><br><h2>  Prosesor NEON dan SIMD </h2><br>  Inilah saatnya untuk menceritakan mengapa saya menunda cerita tentang imx6.  Faktanya adalah bahwa itu didasarkan pada inti Cortex-A9 dan mengandung lebih banyak NEON coprocessor (https://developer.arm.com/technologies/neon).  NEON tidak hanya VFPv3, tetapi juga coprocessor SIMD.  VFP dan NEON menggunakan register yang sama.  VFP menggunakan register 32-bit dan 64-bit untuk operasi, dan NEON menggunakan register 64-bit dan 128-bit, yang terakhir hanya ditunjuk Q0-Q16.  Selain nilai integer dan angka floating-point, NEON juga dapat bekerja dengan cincin polinomial modulo 2 tingkat 16 atau 8. <br><br>  Mode vfp untuk NEON hampir tidak berbeda dari coprocessor vfp9-s yang dibongkar.  Tentu saja, lebih baik untuk menentukan opsi vfpv3 atau vfpv3-d32 untuk -mfpu untuk optimasi yang lebih baik, karena memiliki 32 register 64-bit.  Dan untuk mengaktifkan coprocessor, Anda harus memberikan akses ke coprocessor c10 dan c11.  ini dilakukan dengan menggunakan perintah <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Allow access to c10 &amp; c11 coprocessors */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mrc p15, 0, %0, c1, c0, 2"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=r"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (val) :)</span></span></span></span>; val |= <span class="hljs-number"><span class="hljs-number">0xf</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mcr p15, 0, %0, c1, c0, 2"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"r"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (val))</span></span></span></span>;</code> </pre> <br>  tetapi tidak ada perbedaan mendasar lainnya. <br><br>  Hal lain jika Anda menentukan -mfpu = neon, dalam hal ini kompiler dapat menggunakan instruksi SIMD. <br><br><h2>  Menggunakan SIMD dalam C </h2><br>  Untuk &lt;&lt; mendaftar &gt;&gt; nilai secara manual dengan mendaftar, Anda dapat memasukkan "arm_neon.h" dan menggunakan tipe data yang sesuai: <br>  float32x4_t untuk empat float 32-bit dalam satu register, uint8x8_t untuk delapan bilangan bulat 8-bit dan seterusnya.  Untuk mengakses nilai tunggal, kami menyebutnya sebagai array, tambahan, perkalian, penugasan, dll.  adapun variabel biasa, misalnya: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32x4_t</span></span> a = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}, b = {<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">uint32x4_t</span></span> c = a * b; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(â€œResult=[%d, %d, %d, %d]\nâ€, c[<span class="hljs-number"><span class="hljs-number">0</span></span>], c[<span class="hljs-number"><span class="hljs-number">1</span></span>], c[<span class="hljs-number"><span class="hljs-number">2</span></span>], c[<span class="hljs-number"><span class="hljs-number">3</span></span>]);</code> </pre> <br>  Tentu saja, menggunakan vektorisasi otomatis lebih mudah.  Untuk vektorisasi otomatis, tambahkan flag -ftree-vectorize ke GCC. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">simd_test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a[LEN], b[LEN], c[LEN]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; LEN; i++) { a[i] = i; b[i] = LEN - i; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; LEN; i++) { c[i] = a[i] + b[i]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; LEN; i++) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"c[i] = %d\n"</span></span>, c[i]); } }</code> </pre> <br>  Loop tambahan menghasilkan kode berikut: <br><br><pre> <code class="hljs delphi"><span class="hljs-number"><span class="hljs-number">600059</span></span>a0: f4610adf vld1.<span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-comment"><span class="hljs-comment">{d16-d17}</span></span>, [r1 :<span class="hljs-number"><span class="hljs-number">64</span></span>] <span class="hljs-number"><span class="hljs-number">600059</span></span>a4: e2833010 add r3, r3, <span class="hljs-string"><span class="hljs-string">#16</span></span> <span class="hljs-number"><span class="hljs-number">600059</span></span>a8: e28d0a03 add r0, sp, <span class="hljs-string"><span class="hljs-string">#12288</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span>x3000 <span class="hljs-number"><span class="hljs-number">600059</span></span>ac: e2811010 add r1, r1, <span class="hljs-string"><span class="hljs-string">#16</span></span> <span class="hljs-number"><span class="hljs-number">600059</span></span>b0: f4622adf vld1.<span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-comment"><span class="hljs-comment">{d18-d19}</span></span>, [r2 :<span class="hljs-number"><span class="hljs-number">64</span></span>] <span class="hljs-number"><span class="hljs-number">600059</span></span>b4: e2822010 add r2, r2, <span class="hljs-string"><span class="hljs-string">#16</span></span> <span class="hljs-number"><span class="hljs-number">600059</span></span>b8: f26008e2 vadd.i32 q8, q8, q9 <span class="hljs-number"><span class="hljs-number">600059</span></span>bc: ed430b04 vstr d16, [r3, #-<span class="hljs-number"><span class="hljs-number">16</span></span>] <span class="hljs-number"><span class="hljs-number">600059</span></span>c0: ed431b02 vstr d17, [r3, #-<span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-number"><span class="hljs-number">600059</span></span>c4: e1530000 cmp r3, r0 <span class="hljs-number"><span class="hljs-number">600059</span></span>c8: <span class="hljs-number"><span class="hljs-number">1</span></span>afffff4 bne <span class="hljs-number"><span class="hljs-number">600059</span></span>a0 &lt;foo+<span class="hljs-number"><span class="hljs-number">0</span></span>x58&gt; <span class="hljs-number"><span class="hljs-number">600059</span></span>cc: e28d5dbf add r5, sp, <span class="hljs-string"><span class="hljs-string">#12224</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span>x2fc0 <span class="hljs-number"><span class="hljs-number">600059</span></span>d0: e2444004 sub r4, r4, <span class="hljs-string"><span class="hljs-string">#4</span></span> <span class="hljs-number"><span class="hljs-number">600059</span></span>d4: e285503c add r5, r5, <span class="hljs-string"><span class="hljs-string">#60</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span>x3c</code> </pre> <br>  Setelah melakukan tes untuk kode paralel, kami menemukan bahwa penambahan sederhana dalam satu lingkaran, asalkan variabel independen, memberikan akselerasi sebanyak 7 kali.  Selain itu, kami memutuskan untuk melihat seberapa besar paralelisasi mempengaruhi tugas nyata, mengambil MESA3d dengan emulasi perangkat lunaknya dan mengukur jumlah fps dengan bendera yang berbeda, kami mendapat keuntungan 2 frame per detik (15 vs 13), yaitu akselerasi sekitar 15-20% . <br><br>  Saya akan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memberikan contoh percepatan lainnya menggunakan perintah NEON</a> , bukan milik kami, tetapi dari ARM. <br><br>  Memori penyalinan hingga 50 persen lebih cepat dari biasanya.  Contoh nyata ada di assembler. <br><br>  Siklus penyalinan normal: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">WordCopy</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">LDR</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r3</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[r1]</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">STR</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r3</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[r0]</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SUBS</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r2</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">r2</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">BGE</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">WordCopy</span></span></code> </pre> <br>  loop dengan perintah dan register neon: <br><br><pre> <code class="hljs erlang-repl">NEONCopyPLD PLD [r1, #<span class="hljs-number"><span class="hljs-number">0</span></span>xC0] VLDM r1!,{d0-d7} VSTM r0!,{d0-d7} SUBS r2,r2,#<span class="hljs-number"><span class="hljs-number">0</span></span>x40 BGE NEONCopyPLD</code> </pre> <br>  Jelas bahwa penyalinan dengan 64 byte lebih cepat dari 4 byte, dan penyalinan seperti itu akan memberikan peningkatan 10%, tetapi 40% sisanya tampaknya memberikan pekerjaan coprocessor. <br><br><h2>  Cortex-m </h2><br>  Bekerja dengan FPU di Cortex-M tidak jauh berbeda dari yang dijelaskan di atas.  Sebagai contoh, ini adalah bagaimana makro di atas terlihat untuk menyimpan konteks fpu-shny <br><br><pre> <code class="hljs tex">#define ARM_FPU_CONTEXT_SAVE_INC(tmp, stack) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ldr tmp, =CPACR; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ldr tmp, [tmp]; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>tst tmp, #0xF00000; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>beq fpu_out_save_inc; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vstmia stack!, {s0-s31}; fpu_out_save_inc:</code> </pre> <br>  Juga, perintah vstmia hanya menggunakan register s0-s31 dan register kontrol diakses secara berbeda.  Oleh karena itu, saya tidak akan menjelaskan terlalu banyak, saya hanya akan menjelaskan perbedaan.  Jadi, kami membuat dukungan untuk STM32F7discovery dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cortex-m7</a> untuk itu, masing-masing, kita perlu mengatur flag -mfpu = fpv5-sp-d16.  Harap dicatat bahwa dalam versi seluler, Anda perlu melihat lebih dekat pada versi coprocessor, karena korteks-m yang sama mungkin memiliki opsi berbeda.  Jadi, jika opsi Anda bukan dengan presisi ganda, tetapi dengan tunggal, maka mungkin tidak ada register D0-D16, seperti yang kita miliki di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">stm32f4discovery</a> , itulah mengapa varian dengan register S0-S31 digunakan.  Untuk pengontrol ini kami menggunakan -mfpu = fpv4-sp-d16. <br><br>  Perbedaan utama adalah akses ke register kontrol pengendali, mereka terletak langsung di ruang alamat inti utama, dan untuk berbagai jenis mereka berbeda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">korteks-m4</a> untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">korteks-m7</a> . <br><br><h2>  Kesimpulan </h2><br>  Pada ini saya akan mengakhiri cerita pendek saya tentang floating point untuk ARM.  Saya perhatikan bahwa mikrokontroler modern sangat kuat dan cocok tidak hanya untuk kontrol, tetapi juga untuk memproses sinyal atau berbagai jenis informasi multimedia.  Agar dapat menggunakan semua kekuatan ini secara efektif, Anda perlu memahami cara kerjanya.  Saya harap artikel ini membantu memecahkan masalah ini sedikit lebih baik. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418295/">https://habr.com/ru/post/id418295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418285/index.html">Ahli iklim telah menunjukkan bagaimana manusia mempengaruhi variasi musiman dalam suhu atmosfer</a></li>
<li><a href="../id418287/index.html">Daftar periksa wajib untuk pengembangan desain UX aplikasi seluler</a></li>
<li><a href="../id418289/index.html">Bagaimana Solusi TI Membantu Mengatur Harga Dinamis Dalam Toko</a></li>
<li><a href="../id418291/index.html">DEFCON 19. Konferensi "Curi semuanya, bunuh semua orang, menyebabkan kehancuran finansial total" Jason E. Street</a></li>
<li><a href="../id418293/index.html">Pengujian Antarmuka Web Otomatis di Virto Commerce</a></li>
<li><a href="../id418297/index.html">Ulasan smartphone Neffos N1</a></li>
<li><a href="../id418301/index.html">Konfrontasi hebat Mars pada 2018: cara mengamati dan apa yang diharapkan</a></li>
<li><a href="../id418303/index.html">Vanessa-Automation - alat untuk menguji solusi aplikasi pada platform 1C: Enterprise</a></li>
<li><a href="../id418305/index.html">Berapa banyak objek yang dipancarkan Python saat menjalankan skrip?</a></li>
<li><a href="../id418307/index.html">Alat Pembelajaran Mesin Apple</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>