<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐎 👩‍🍳 👇🏽 Utilisation de ressources externes dans Unity3D 🔲 🖋️ 👨🏼‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Présentation 
 Bonjour chers lecteurs, nous allons parler aujourd'hui de travailler avec des ressources externes dans l'environnement Unity 3d. 

 Par...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Utilisation de ressources externes dans Unity3D</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433366/"><h2>  Présentation </h2><br>  Bonjour chers lecteurs, nous allons parler aujourd'hui de travailler avec des ressources externes dans l'environnement Unity 3d. <br><br>  Par tradition, pour commencer, nous déterminerons ce que c'est et pourquoi nous en avons besoin.  Alors, quelles sont exactement ces ressources externes.  Dans le cadre du développement de jeux, ces ressources peuvent être tout ce qui est nécessaire au fonctionnement de l'application et ne doivent pas être stockées dans la version finale du projet.  Les ressources externes peuvent être situées à la fois sur le disque dur de l'ordinateur de l'utilisateur et sur un serveur Web externe.  Dans le cas général, ces ressources sont tout fichier ou ensemble de données que nous chargeons dans notre application déjà en cours d'exécution.  S'exprimant dans le cadre d'Unity 3d, alors ils peuvent être: <br><br><ul><li>  Fichier texte </li><li>  Fichier de texture </li><li>  Fichier audio </li><li>  Tableau d'octets </li><li>  AssetBundle (archive avec les actifs du projet Unity 3d) </li></ul><br>  Ci-dessous, nous examinerons plus en détail les mécanismes intégrés pour travailler avec ces ressources qui sont présents dans Unity 3d, ainsi que pour écrire des gestionnaires simples pour interagir avec le serveur Web et charger des ressources dans l'application. <br><br>  <b>Remarque</b> : le <i>reste de cet article utilise du code utilisant C # 7+ et est conçu pour le compilateur Roslyn utilisé dans Unity3d dans les versions 2018.3+.</i> <br><a name="habracut"></a><br><h2>  Caractéristiques de Unity 3D </h2><br>  Avant Unity 2017, un mécanisme (à l'exclusion de l'auto-description) était utilisé pour travailler avec les données du serveur et les ressources externes, qui étaient incluses dans le moteur - il s'agit de la classe WWW.  Cette classe a permis l'utilisation de diverses commandes http (get, post, put, etc.) sous forme synchrone ou asynchrone (via Coroutine).  Le travail avec cette classe était assez simple et direct. <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadFromServer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> www = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WWW(url); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> www; Debug.Log(www.text); }</code> </pre> <br>  De même, vous pouvez obtenir non seulement des données texte, mais également d'autres: <br><br><ul><li>  Tableau d'octets - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.bytes</a> </li><li>  Texture - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.texture</a> </li><li>  Audio - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.GetAudioClip</a> () </li><li>  Atout - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.assetBundle</a> </li></ul><br>  Cependant, à partir de la version 2017, Unity dispose d'un nouveau système de serveur introduit par la classe <b>UnityWebRequest</b> , qui se trouve dans l'espace de noms Networking.  Jusqu'à Unity 2018, il existait avec <b>WWW</b> , mais dans la dernière version du moteur <b>WWW</b> , il n'était plus recommandé, et à l'avenir, il sera complètement supprimé.  Par conséquent, nous nous concentrerons davantage sur <b>UnityWebRequest</b> (ci-après UWR). <br><br>  Travailler avec UWR dans son ensemble est similaire à WWW dans son cœur, mais il existe des différences, qui seront discutées plus tard.  Voici un exemple similaire de chargement de texte. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadFromServer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UnityWebRequest(url); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.SendWebRequest(); Debug.Log(request.downloadHandler.text); request.Dispose(); }</code> </pre><br>  Les principaux changements que le nouveau système UWR a introduits (en plus de changer le principe de travailler à l'intérieur) sont la possibilité d'affecter des gestionnaires pour télécharger et télécharger des données depuis le serveur lui-même, plus de détails peuvent être lus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Par défaut, ce sont les classes <b>UploadHandler</b> et <b>DownloadHandler</b> .  Unity lui-même fournit un ensemble d'extensions de ces classes pour travailler avec diverses données, telles que l'audio, les textures, les actifs, etc.  Envisageons de travailler avec eux plus en détail. <br><br><h2>  Travailler avec des ressources </h2><br><h3>  Texte </h3><br>  Travailler avec du texte est l'une des options les plus simples.  La méthode de téléchargement a déjà été décrite ci-dessus.  Nous le réécrivons un peu en utilisant la création d'une requête http Get directe. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadTextFromServer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, Action&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; response</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = UnityWebRequest.Get(url); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.SendWebRequest(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!request.isHttpError &amp;&amp; !request.isNetworkError) { response(uwr.downloadHandler.text); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogErrorFormat(<span class="hljs-string"><span class="hljs-string">"error request [{0}, {1}]"</span></span>, url, request.error); response(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); } request.Dispose(); }</code> </pre><br>  Comme vous pouvez le voir dans le code, le <b>DownloadHandler</b> par défaut est utilisé ici.  La propriété text est un getter qui convertit un tableau d'octets en texte codé UTF8.  L'utilisation principale du chargement de texte à partir du serveur est de recevoir un fichier json (représentation sérialisée des données sous forme de texte).  Vous pouvez obtenir ces données à l'aide de la classe Unity <b>JsonUtility</b> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = JsonUtility.FromJson&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); <span class="hljs-comment"><span class="hljs-comment">// T  ,    .</span></span></code> </pre><br><h3>  Audio </h3><br>  Pour travailler avec l'audio, vous devez utiliser la méthode spéciale de création de la demande <b>UnityWebRequestMultimedia.GetAudioClip</b> , et pour obtenir la représentation des données sous la forme nécessaire pour travailler dans Unity, vous devez utiliser <b>DownloadHandlerAudioClip</b> .  De plus, lors de la création d'une demande, vous devez spécifier le type de données audio représenté par l'énumération <b>AudioType</b> , qui définit le format (wav, aiff, oggvorbis, etc.). <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadAudioFromServer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, AudioType audioType, Action&lt;AudioClip&gt; response</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = UnityWebRequestMultimedia.GetAudioClip(url, audioType); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.SendWebRequest(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!request.isHttpError &amp;&amp; !request.isNetworkError) { response(DownloadHandlerAudioClip.GetContent(request)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogErrorFormat(<span class="hljs-string"><span class="hljs-string">"error request [{0}, {1}]"</span></span>, url, request.error); response(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); } request.Dispose(); }</code> </pre><br><h3>  La texture </h3><br>  Le téléchargement des textures est similaire à celui des fichiers audio.  La demande est créée à l'aide de <b>UnityWebRequestTexture.GetTexture</b> .  Pour obtenir les données sous la forme nécessaire pour Unity, <b>DownloadHandlerTexture est</b> utilisé. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadTextureFromServer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, Action&lt;Texture2D&gt; response</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = UnityWebRequestTexture.GetTexture(url); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.SendWebRequest(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!request.isHttpError &amp;&amp; !request.isNetworkError) { response(DownloadHandlerTexture.GetContent(request)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogErrorFormat(<span class="hljs-string"><span class="hljs-string">"error request [{0}, {1}]"</span></span>, url, request.error); response(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); } request.Dispose(); }</code> </pre><br><h3>  Ensemble d'actifs </h3><br>  Comme mentionné précédemment, le bundle est, en fait, une archive avec des ressources Unity qui peuvent être utilisées dans un jeu déjà en cours d'exécution.  Ces ressources peuvent être n'importe quel actif du projet, y compris des scènes.  L'exception concerne les scripts C #, ils ne peuvent pas être transmis.  Pour charger le <b>AssetBundle</b> , une requête est utilisée qui est créée à l'aide de <b>UnityWebRequestAssetBundle.GetAssetBundle.</b>  <b>DownloadHandlerAssetBundle est</b> utilisé pour obtenir des données sous la forme nécessaire pour Unity. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadBundleFromServer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, Action&lt;AssetBundle&gt; response</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = UnityWebRequestAssetBundle.GetAssetBundle(url); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.SendWebRequest(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!request.isHttpError &amp;&amp; !request.isNetworkError) { response(DownloadHandlerAssetBundle.GetContent(request)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogErrorFormat(<span class="hljs-string"><span class="hljs-string">"error request [{0}, {1}]"</span></span>, url, request.error); response(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); } request.Dispose(); }</code> </pre><br><h2>  Les principaux problèmes et solutions lors de l'utilisation d'un serveur Web et de données externes </h2><br>  Des méthodes simples d'interaction entre une application et un serveur en termes de chargement de différentes ressources ont été décrites ci-dessus.  Cependant, dans la pratique, les choses sont beaucoup plus compliquées.  Considérez les principaux problèmes qui accompagnent les développeurs et insistez sur les moyens de les résoudre. <br><br><h3>  Pas assez d'espace libre </h3><br>  L'un des premiers problèmes lors du téléchargement de données à partir du serveur est un éventuel manque d'espace libre sur l'appareil.  Il arrive souvent que l'utilisateur utilise de vieux appareils pour les jeux (en particulier sur Android), ainsi que la taille des fichiers téléchargés lui-même peut être assez grande (bonjour PC).  Dans tous les cas, cette situation doit être correctement traitée et le joueur doit être informé à l'avance qu'il n'y a pas assez d'espace et combien.  Comment faire  La première chose que vous devez savoir est la taille du fichier téléchargé, cela se fait au moyen de la demande <b>UnityWebRequest.Head ()</b> .  Voici le code pour obtenir la taille. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetConntentLength</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, Action&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; response</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = UnityWebRequest.Head(url); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.SendWebRequest(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!request.isHttpError &amp;&amp; !request.isNetworkError) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contentLength = request.GetResponseHeader(<span class="hljs-string"><span class="hljs-string">"Content-Length"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.TryParse(contentLength, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> returnValue)) { response(returnValue); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { response(<span class="hljs-number"><span class="hljs-number">-1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogErrorFormat(<span class="hljs-string"><span class="hljs-string">"error request [{0}, {1}]"</span></span>, url, request.error); response(<span class="hljs-number"><span class="hljs-number">-1</span></span>); } }</code> </pre><br>  Il est important de noter une chose ici, pour que la requête fonctionne correctement, le serveur doit être en mesure de renvoyer la taille du contenu, sinon (comme, en fait, pour afficher la progression), la mauvaise valeur sera retournée. <br><br>  Après avoir obtenu la taille des données téléchargées, nous pouvons les comparer avec la taille de l'espace disque libre.  Pour obtenir ce dernier, j'utilise le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plugin gratuit du Asset Store</a> . <br><br>  <b>Remarque</b> : <i>vous pouvez utiliser la classe <b>Cache</b> dans Unity3d, elle peut afficher l'espace de cache libre et utilisé.</i>  <i>Cependant, il convient de considérer le fait que ces données sont relatives.</i>  <i>Ils sont calculés en fonction de la taille du cache lui-même, par défaut, il est de 4 Go.</i>  <i>Si l'utilisateur a plus d'espace libre que la taille du cache, il n'y aura pas de problème, mais si ce n'est pas le cas, les valeurs peuvent prendre des valeurs incorrectes par rapport à la situation réelle.</i> <br><br><h3>  Vérification de l'accès Internet </h3><br>  Très souvent, avant de télécharger quoi que ce soit à partir du serveur, il est nécessaire de gérer la situation de manque d'accès à Internet.  Il existe plusieurs façons de procéder: du ping d'une adresse à une demande GET sur google.ru.  Cependant, à mon avis, le résultat le plus correct et le plus rapide et le plus stable consiste à télécharger à partir de votre propre serveur (le même à partir duquel les fichiers seront téléchargés) un petit fichier.  La procédure à suivre est décrite ci-dessus dans la section sur l'utilisation du texte. <br>  En plus de vérifier le fait d'avoir accès à Internet, il est également nécessaire de déterminer son type (mobile ou WiFi), car il est peu probable qu'un joueur veuille télécharger plusieurs centaines de mégaoctets sur le trafic mobile.  Cela peut être fait via la propriété <b>Application.internetReachability</b> . <br><br><h3>  Mise en cache </h3><br>  Le suivant, et l'un des problèmes les plus importants, est la mise en cache des fichiers téléchargés.  À quoi sert cette mise en cache? <br><br><ol><li>  Économisez du trafic (ne téléchargez pas les données déjà téléchargées) </li><li>  Assurer le travail en l'absence d'Internet (vous pouvez afficher les données du cache). </li></ol><br>  Qu'est-ce qui doit être mis en cache?  La réponse à cette question est tout, tous les fichiers que vous téléchargez doivent être mis en cache.  Comment faire, considérez ci-dessous et commencez avec des fichiers texte simples. <br>  Malheureusement, Unity n'a pas de mécanisme intégré pour la mise en cache du texte, ainsi que des textures et des fichiers audio.  Par conséquent, pour ces ressources, il est nécessaire d'écrire votre système, ou de ne pas écrire, selon les besoins du projet.  Dans le cas le plus simple, nous écrivons simplement le fichier dans le cache et, en l'absence d'Internet, nous en prenons le fichier.  Dans une version légèrement plus complexe (je l'utilise dans des projets), nous envoyons une requête au serveur, qui retourne json indiquant les versions des fichiers qui sont stockés sur le serveur.  Vous pouvez écrire et lire des fichiers à partir du cache à l'aide de la classe C # de la classe <b>File</b> ou de toute autre manière pratique et acceptée par votre équipe. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CacheText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cacheFilePath = Path.Combine(<span class="hljs-string"><span class="hljs-string">"CachePath"</span></span>, <span class="hljs-string"><span class="hljs-string">"{0}.text"</span></span>.Fmt(fileName)); File.WriteAllText(cacheFilePath, data); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CacheTexture</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] data</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cacheFilePath = Path.Combine(<span class="hljs-string"><span class="hljs-string">"CachePath"</span></span>, <span class="hljs-string"><span class="hljs-string">"{0}.texture"</span></span>.Fmt(fileName)); File.WriteAllBytes(cacheFilePath, data); }</code> </pre><br>  De même, obtenir des données du cache. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTextFromCache</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cacheFilePath = Path.Combine(Utils.Path.Cache, <span class="hljs-string"><span class="hljs-string">"{0}.text"</span></span>.Fmt(fileName)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File.Exists(cacheFilePath)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> File.ReadAllText(cacheFilePath); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Texture2D </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTextureFromCache</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cacheFilePath = Path.Combine(Utils.Path.Cache, <span class="hljs-string"><span class="hljs-string">"{0}.texture"</span></span>.Fmt(fileName)); Texture2D texture = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File.Exists(cacheFilePath)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = File.ReadAllBytes(cacheFilePath); texture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); texture.LoadImage(data, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> texture; }</code> </pre><br>  <b>Remarque</b> : <i>pourquoi le même UWR avec une URL du fichier de formulaire: // n'est pas utilisé pour charger les textures.</i>  <i>Pour le moment, il y a des problèmes avec cela, le fichier ne se charge tout simplement pas, j'ai donc dû trouver une solution de contournement.</i> <br><br>  <b>Remarque</b> : <i>Je n'utilise pas le chargement direct d'AudioClip dans les projets, je stocke toutes ces données dans AssetBundle.</i>  <i>Cependant, si nécessaire, cela peut facilement être fait en utilisant les fonctions de la classe AudioClip GetData et SetData.</i> <i><br></i> <br>  Les ressources simples d'Unity pour <b>AssetBundle</b> , Unity dispose d'un mécanisme de mise en cache intégré.  Examinons-le plus en détail. <br><br>  Fondamentalement, ce mécanisme peut utiliser deux approches: <br><br><ol><li>  Utilisation du CRC et du numéro de version </li><li>  Utilisation des valeurs de hachage </li></ol><br>  En principe, vous pouvez utiliser n'importe lequel d'entre eux, mais j'ai décidé moi-même que Hash est le plus acceptable, car j'ai mon propre système de version et il prend en compte non seulement la version <b>AssetBundle</b> , mais aussi la version de l'application, car souvent le bundle peut ne pas être compatible avec la version, présenté en magasin. <br><br>  Alors, comment se fait la mise en cache: <br><br><ol><li>  Nous demandons un fichier de bundle au serveur manifeste (ce fichier est créé automatiquement lors de sa création et contient une description des actifs qu'il contient, ainsi que le hachage, le crc, la taille, etc.).  Le fichier a le même nom que le bundle plus l'extension .manifest. </li><li>  Obtenez la valeur hash128 du manifeste </li><li>  Nous créons une demande au serveur pour obtenir un AssetBundle, où en plus de l'URL, spécifiez la valeur de hachage128 reçue </li></ol><br><div class="spoiler">  <b class="spoiler_title">Code pour l'algorithme décrit ci-dessus:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadAssetBundleFromServerWithCache</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, Action&lt;AssetBundle&gt; response</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,    while (!Caching.ready) { yield return null; } //     var request = UnityWebRequest.Get(url + ".manifest"); yield return request.SendWebRequest(); if (!request.isHttpError &amp;&amp; !request.isNetworkError) { Hash128 hash = default; // hash var hashRow = request.downloadHandler.text.ToString().Split("\n".ToCharArray())[5]; hash = Hash128.Parse(hashRow.Split(':')[1].Trim()); if (hash.isValid == true) { request.Dispose(); request = UnityWebRequestAssetBundle.GetAssetBundle(url, hash, 0); yield return request.SendWebRequest(); if (!request.isHttpError &amp;&amp; !request.isNetworkError) { response(DownloadHandlerAssetBundle.GetContent(request)); } else { response(null); } } else { response(null); } } else { response(null); } request.Dispose(); }</span></span></code> </pre><br></div></div><br>  Dans l'exemple ci-dessus, Unity, lors de l'interrogation du serveur, cherche d'abord à voir s'il y a un fichier dans le cache avec la valeur de hachage 128 spécifiée, si c'est le cas, il sera renvoyé; sinon, le fichier mis à jour sera téléchargé.  Pour gérer tous les fichiers de cache dans Unity, il existe une classe de <b>mise en cache</b> , avec laquelle nous pouvons savoir s'il y a un fichier dans le cache, obtenir toutes les versions mises en cache, ainsi que supprimer les versions inutiles ou les effacer complètement. <br><br>  <b>Remarque</b> : <i>pourquoi une telle façon étrange d'obtenir des valeurs de hachage?</i>  <i>Cela est dû au fait que l'obtention de hachage128 de la manière décrite dans la documentation nécessite le chargement de l'ensemble complet, puis la réception de l'actif <b>AssetBundleManifest</b> de celui-ci et de là déjà des valeurs de hachage.</i>  <i>L'inconvénient de cette approche est que l'ensemble du AssetBundle oscille, mais nous avons juste besoin qu'il ne le soit pas.</i>  <i>Par conséquent, nous téléchargeons d'abord uniquement le fichier manifeste depuis le serveur, prenons hash128 de celui-ci, et seulement ensuite, si nécessaire, téléchargeons le fichier de bundle, et la valeur hash128 doit être extraite via l'interprétation des lignes.</i> <br><br><h3>  Travailler avec des ressources en mode éditeur </h3><br>  Le dernier problème, ou plutôt la question du débogage et de la commodité du développement, est de travailler avec des ressources téléchargeables en mode éditeur, s'il n'y a pas de problèmes avec les fichiers normaux, alors les choses ne sont pas si simples avec les bundles.  Bien sûr, vous pouvez construire leur build à chaque fois, le télécharger sur le serveur et lancer l'application dans l'éditeur Unity et regarder comment tout fonctionne, mais même cette description ressemble à une "béquille".  Quelque chose doit être fait avec cela et pour cela la classe <b>AssetDatabase</b> nous aidera. <br><br>  Afin d'unifier le travail avec les bundles, j'ai créé un wrapper spécial: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AssetBundleWrapper</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> AssetBundle _assetBundle; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AssetBundleWrapper</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">AssetBundle assetBundle</span></span></span><span class="hljs-function">)</span></span> { _assetBundle = assetBundle; } }</code> </pre><br>  Maintenant, nous devons ajouter deux modes de travail avec les actifs, selon que nous sommes dans l'éditeur ou dans la build.  Pour la construction, nous utilisons des wrappers sur les fonctions de la classe <b>AssetBundle</b> , et pour l'éditeur, nous utilisons la classe <b>AssetDatabase</b> mentionnée ci-dessus. <br><br><div class="spoiler">  <b class="spoiler_title">Ainsi, nous obtenons le code suivant:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AssetBundleWrapper</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> UNITY_EDITOR private readonly List&lt;string&gt; _assets; public AssetBundleWrapper(string url) { var uri = new Uri(url); var bundleName = Path.GetFileNameWithoutExtension(uri.LocalPath); _assets = new List&lt;string&gt;(AssetDatabase.GetAssetPathsFromAssetBundle(bundleName)); } public T LoadAsset&lt;T&gt;(string name) where T : UnityEngine.Object { var assetPath = _assets.Find(item =&gt; { var assetName = Path.GetFileNameWithoutExtension(item); return string.CompareOrdinal(name, assetName) == 0; }); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!string.IsNullOrEmpty(assetPath)) { return AssetDatabase.LoadAssetAtPath&lt;T&gt;(assetPath); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { return default; } } public T[] LoadAssets&lt;T&gt;() where T : UnityEngine.Object { var returnedValues = new List&lt;T&gt;(); foreach(var assetPath in _assets) { returnedValues.Add(AssetDatabase.LoadAssetAtPath&lt;T&gt;(assetPath)); } return returnedValues.ToArray(); } public void LoadAssetAsync&lt;T&gt;(string name, Action&lt;T&gt; result) where T : UnityEngine.Object { result(LoadAsset&lt;T&gt;(name)); } public void LoadAssetsAsync&lt;T&gt;(Action&lt;T[]&gt; result) where T : UnityEngine.Object { result(LoadAssets&lt;T&gt;()); } public string[] GetAllScenePaths() { return _assets.ToArray(); } public void Unload(bool includeAllLoadedAssets = false) { _assets.Clear(); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> private readonly AssetBundle _assetBundle; public AssetBundleWrapper(AssetBundle assetBundle) { _assetBundle = assetBundle; } public T LoadAsset&lt;T&gt;(string name) where T : UnityEngine.Object { return _assetBundle.LoadAsset&lt;T&gt;(name); } public T[] LoadAssets&lt;T&gt;() where T : UnityEngine.Object { return _assetBundle.LoadAllAssets&lt;T&gt;(); } public void LoadAssetAsync&lt;T&gt;(string name, Action&lt;T&gt; result) where T : UnityEngine.Object { var request = _assetBundle.LoadAssetAsync&lt;T&gt;(name); TaskManager.Task.Create(request) .Subscribe(() =&gt; { result(request.asset as T); Unload(false); }) .Start(); } public void LoadAssetsAsync&lt;T&gt;(Action&lt;T[]&gt; result) where T : UnityEngine.Object { var request = _assetBundle.LoadAllAssetsAsync&lt;T&gt;(); TaskManager.Task.Create(request) .Subscribe(() =&gt; { var assets = new T[request.allAssets.Length]; for (var i = 0; i &lt; request.allAssets.Length; i++) { assets[i] = request.allAssets[i] as T; } result(assets); Unload(false); }) .Start(); } public string[] GetAllScenePaths() { return _assetBundle.GetAllScenePaths(); } public void Unload(bool includeAllLoadedAssets = false) { _assetBundle.Unload(includeAllLoadedAssets); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre><br></div></div><br>  <b>Remarque</b> : le code utilise la classe <b>TaskManager</b> , il sera discuté ci-dessous, en bref, c'est un wrapper pour travailler avec <b>Coroutine</b> . <br><br>  En plus de ce qui précède, il est également utile pendant le développement de regarder ce que nous avons téléchargé et ce qui est actuellement dans le cache.  À cette fin, vous pouvez profiter de la possibilité de définir votre propre dossier, qui sera utilisé pour la mise en cache (vous pouvez également écrire du texte téléchargé et d'autres fichiers dans le même dossier): <br><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> UNITY_EDITOR var path = Path.Combine(Directory.GetParent(Application.dataPath).FullName, "_EditorCache"); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> var path = Path.Combine(Application.persistentDataPath, "_AppCache"); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> Caching.currentCacheForWriting = Caching.AddCache(path);</span></span></code> </pre><br><h2>  Nous écrivons un gestionnaire de requêtes réseau ou travaillons avec un serveur web </h2><br>  Ci-dessus, nous avons examiné les principaux aspects du travail avec des ressources externes dans Unity, maintenant je voudrais m'attarder sur la mise en œuvre de l'API, qui généralise et unifie tout ce qui précède.  Et d'abord, attardons-nous sur le gestionnaire de requêtes réseau. <br><br>  <b>Remarque</b> : <i>ci-après, nous utilisons le wrapper sur <b>Coroutine</b> sous la forme de la classe <b>TaskManager</b> .</i>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">J'ai écrit sur ce wrapper dans un autre article</a> .</i> <br><br>  Obtenons la classe correspondante: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Network</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> NetworkTypeEnum { None, Mobile, WiFi } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> NetworkTypeEnum NetworkType; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> TaskManager _taskManager = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskManager(); }</code> </pre><br>  Le champ statique <b>NetworkType</b> est requis pour que l'application reçoive des informations sur le type de connexion Internet.  En principe, cette valeur peut être stockée n'importe où, j'ai décidé que c'était la place dans la classe <b>Network</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Ajoutez la fonction de base d'envoi d'une requête au serveur:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WebRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">UnityWebRequest request, Action&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; progress, Action&lt;UnityWebRequest&gt; response</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!Caching.ready) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (progress != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { request.SendWebRequest(); _currentRequests.Add(request); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!request.isDone) { progress(request.downloadProgress); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } progress(<span class="hljs-number"><span class="hljs-number">1f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.SendWebRequest(); } response(request); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_currentRequests.Contains(request)) { _currentRequests.Remove(request); } request.Dispose(); }</code> </pre><br></div></div><br>  Comme vous pouvez le voir dans le code, la méthode de traitement de l'achèvement d'une demande a été modifiée par rapport au code des sections précédentes.  Il s'agit de montrer la progression du chargement des données.  De plus, toutes les demandes envoyées sont stockées dans une liste afin que, si nécessaire, elles puissent être annulées. <br><br><div class="spoiler">  <b class="spoiler_title">Ajoutez une fonction de création de requête basée sur un lien pour AssetBundle:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WebRequestBundle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, Hash128 hash, Action&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; progress, Action&lt;UnityWebRequest&gt; response</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = UnityWebRequestAssetBundle.GetAssetBundle(url, hash, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WebRequest(request, progress, response); }</code> </pre><br></div></div><br>  De même, des fonctions sont créées pour la texture, l'audio, le texte, le tableau d'octets. <br><br>  Vous devez maintenant vous assurer que le serveur envoie des données via la commande Post.  Souvent, vous devez transmettre quelque chose au serveur et, en fonction de quoi exactement, obtenir une réponse.  Ajoutez les fonctions appropriées. <br><br><div class="spoiler">  <b class="spoiler_title">Envoi de données sous la forme d'un ensemble de valeurs-clés:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WebRequestPost</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, Dictionary&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; formFields, Action&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; progress, Action&lt;UnityWebRequest&gt; response</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = UnityWebRequest.Post(url, formFields); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WebRequest(request, progress, response); }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Envoi de données au format json:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WebRequestPost</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data, Action&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; progress, Action&lt;UnityWebRequest&gt; response</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UnityWebRequest(url, UnityWebRequest.kHttpVerbPOST) { uploadHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UploadHandlerRaw(Encoding.UTF8.GetBytes(data)), downloadHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DownloadHandlerBuffer() }; request.uploadHandler.contentType = <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WebRequest(request, progress, response); }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Nous allons maintenant ajouter des méthodes publiques avec lesquelles nous chargerons des données, en particulier AssetBundle</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Request</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, Hash128 hash, Action&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; progress, Action&lt;AssetBundle&gt; response, TaskManager.TaskPriorityEnum priority = TaskManager.TaskPriorityEnum.Default</span></span></span><span class="hljs-function">)</span></span> { _taskManager.AddTask(WebRequestBundle(url, hash, progress, (uwr) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!uwr.isHttpError &amp;&amp; !uwr.isNetworkError) { response(DownloadHandlerAssetBundle.GetContent(uwr)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarningFormat(<span class="hljs-string"><span class="hljs-string">"[Netowrk]: error request [{0}]"</span></span>, uwr.error); response(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); } }), priority); }</code> </pre><br></div></div><br>  De même, des méthodes sont ajoutées pour la texture, le fichier audio, le texte, etc. <br><br><div class="spoiler">  <b class="spoiler_title">Et enfin, nous ajoutons la fonction d'obtention de la taille du fichier téléchargé et la fonction de nettoyage pour arrêter toutes les requêtes créées.</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Request</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, Action&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; response, TaskManager.TaskPriorityEnum priority = TaskManager.TaskPriorityEnum.Default</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = UnityWebRequest.Head(url); _taskManager.AddTask(WebRequest(request, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, uwr =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contentLength = uwr.GetResponseHeader(<span class="hljs-string"><span class="hljs-string">"Content-Length"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.TryParse(contentLength, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> returnValue)) { response(returnValue); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { response(<span class="hljs-number"><span class="hljs-number">-1</span></span>); } }), priority); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _taskManager.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _currentRequests) { request.Abort(); request.Dispose(); } _currentRequests.Clear(); }</code> </pre><br></div></div><br>  À ce sujet, notre gestionnaire pour travailler avec les demandes de réseau est terminé.  Si nécessaire, chaque sous-système du jeu qui nécessite de travailler avec le serveur peut créer ses propres instances de la classe. <br><br><h2>  Écrire un gestionnaire de chargement de ressources externes </h2><br>  En plus de la classe décrite ci-dessus, pour travailler pleinement avec des données externes, nous avons besoin d'un gestionnaire distinct qui non seulement téléchargera les données, mais informera également l'application du début du chargement, de l'achèvement, de la progression, du manque d'espace libre et traitera également les problèmes de mise en cache. <br><br><div class="spoiler">  <b class="spoiler_title">Nous commençons la classe correspondante, qui dans mon cas est un singleton</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExternalResourceManager</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ResourceEnumType { Text, Texture, AssetBundle } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Network _network = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Network(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExternalResourceManager</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> UNITY_EDITOR var path = Path.Combine(Directory.GetParent(Application.dataPath).FullName, "_EditorCache"); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> var path = Path.Combine(Application.persistentDataPath, "_AppCache"); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!System.IO.Directory.Exists(path)) { System.IO.Directory.CreateDirectory(path); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> UNITY_IOS UnityEngine.iOS.Device.SetNoBackupFlag(path); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> } Caching.currentCacheForWriting = Caching.AddCache(path); } }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme vous pouvez le voir, le concepteur définit le dossier pour la mise en cache, selon que nous soyons dans l'éditeur ou non. </font><font style="vertical-align: inherit;">De plus, nous avons configuré un champ privé pour une instance de la classe Network, que nous avons décrite précédemment. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons maintenant ajouter des fonctions auxiliaires pour travailler avec le cache, ainsi que pour déterminer la taille du fichier téléchargé et vérifier l'espace libre pour celui-ci. </font><font style="vertical-align: inherit;">Plus loin et plus bas, le code est donné sur un exemple de travail avec AssetBundle, pour le reste des ressources tout se fait par analogie.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code de fonction d'assistance</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearAssetBundleCache</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fileName = GetFileNameFromUrl(url); Caching.ClearAllCachedVersions(fileName); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearAllRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _network.Clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AssetBundleIsCached</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, Action&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; result</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> manifestFileUrl = <span class="hljs-string"><span class="hljs-string">"{0}.manifest"</span></span>.Fmt(url); _network.Request(manifestFileUrl, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> manifest) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(manifest) ? <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> : GetHashFromManifest(manifest); result(Caching.IsVersionCached(url, hash)); } , TaskManager.TaskPriorityEnum.RunOutQueue); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckFreeSpace</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, Action&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; result</span></span></span><span class="hljs-function">)</span></span> { GetSize(url, lengthInMb =&gt; { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> UNITY_EDITOR_WIN var logicalDrive = Path.GetPathRoot(Utils.Path.Cache); var availableSpace = SimpleDiskUtils.DiskUtils.CheckAvailableSpace(logicalDrive); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> UNITY_EDITOR_OSX var availableSpace = SimpleDiskUtils.DiskUtils.CheckAvailableSpace(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> UNITY_IOS var availableSpace = SimpleDiskUtils.DiskUtils.CheckAvailableSpace(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> UNITY_ANDROID var availableSpace = SimpleDiskUtils.DiskUtils.CheckAvailableSpace(true); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> result(availableSpace &gt; lengthInMb, lengthInMb); }); } public void GetSize(string url, Action&lt;float&gt; result) { _network.Request(url, length =&gt; result(length / 1048576f)); } private string GetFileNameFromUrl(string url) { var uri = new Uri(url); var fileName = Path.GetFileNameWithoutExtension(uri.LocalPath); return fileName; } private Hash128 GetHashFromManifest(string manifest) { var hashRow = manifest.Split("\n".ToCharArray())[5]; var hash = Hash128.Parse(hashRow.Split(':')[1].Trim()); return hash; }</span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutons maintenant des fonctions de chargement de données en utilisant l'exemple AssetBundle.</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAssetBundle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, Action start, Action&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; progress, Action stop, Action&lt;AssetBundleWrapper&gt; result, TaskManager.TaskPriorityEnum taskPriority = TaskManager.TaskPriorityEnum.Default</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> DONT_USE_SERVER_IN_EDITOR start?.Invoke(); result(new AssetBundleWrapper(url)); stop?.Invoke(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> void loadAssetBundle(Hash128 bundleHash) { start?.Invoke(); _network.Request(url, bundleHash, progress, (AssetBundle value) =&gt; { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(value != null) { _externalResourcesStorage.SetCachedHash(url, bundleHash); } result(new AssetBundleWrapper(value)); stop?.Invoke(); }, taskPriority); }; var manifestFileUrl = "{0}.manifest".Fmt(url); _network.Request(manifestFileUrl, null, (string manifest) =&gt; { var hash = string.IsNullOrEmpty(manifest) ? default : GetHashFromManifest(manifest); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!hash.isValid || hash == default) { hash = _externalResourcesStorage.GetCachedHash(url); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!hash.isValid || hash == default) { result(new AssetBundleWrapper(null)); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { loadAssetBundle(hash); } } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (Caching.IsVersionCached(url, hash)) { loadAssetBundle(hash); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { CheckFreeSpace(url, (spaceAvailable, length) =&gt; { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (spaceAvailable) { loadAssetBundle(hash); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { result(new AssetBundleWrapper(null)); NotEnoughDiskSpace.Call(); } }); } } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alors, que se passe-t-il dans cette fonction: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La directive de précompilation DONT_USE_SERVER_IN_EDITOR est utilisée pour désactiver le chargement réel des bundles depuis le serveur. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La première étape consiste à faire une demande au serveur pour obtenir le fichier manifeste du bundle </font></font></li><li>    -    ,    ,   -   ( <b>_externalResourcesStorage</b> )  ,  ,               (  ,     ),  ,   null  </li><li>     ,     Caching      ,       ,         (   ) </li><li>  ,     ,      ,   ,             -       (   ).   ,              (     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> ) </li></ul><br> <b></b> : <i>     -.    ,   ,   ,   -          ,         ,    </i> . <br><br>       /       : GetJson, GetTexture, GetText, GetAudio  .. <br><br><div class="spoiler"> <b class="spoiler_title">    ,     .    ,      , -   .</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPack</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Dictionary&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, ResourceEnumType&gt; urls, Action start, Action&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; progress, Action stop, Action&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; result</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> commonProgress = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)urls.Count; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentProgress = <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completeCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">progressHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { currentProgress += <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; progress?.Invoke(currentProgress / commonProgress); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">completeHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { completeCounter++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (completeCounter == urls.Count) { stop?.Invoke(); } }; start?.Invoke(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> url <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> urls.Keys) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resourceType = urls[url]; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (resourceType) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ResourceEnumType.Text: { GetText(url, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, progressHandler, completeHandler, (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, isCached) =&gt; { result(url, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, isCached); }); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ResourceEnumType.Texture: { GetTexture(url, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, progressHandler, completeHandler, (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, isCached) =&gt; { result(url, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, isCached); }); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ResourceEnumType.AssetBundle: { GetAssetBundle(url, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, progressHandler, completeHandler, (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) =&gt; { result(url, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, il vaut la peine de comprendre la particularité du </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskManager</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui est utilisé dans le gestionnaire de requêtes réseau, par défaut, il fonctionne, effectuant toutes les tâches à tour de rôle. Par conséquent, le téléchargement des fichiers se fera en conséquence. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remarque</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : pour ceux qui n'aiment pas </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coroutine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tout peut être facilement traduit en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / wait</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais dans ce cas, dans l'article, j'ai décidé d'utiliser une option plus compréhensible pour les débutants (comme il me semble).</font></font><br><br><h2>  Conclusion </h2><br>                .       ,        .        ,       (    f2p ),     ,        , ,       ,         . <br><br> <b>,   </b> : <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">assetstore.unity.com/packages/tools/simple-disk-utils-59382</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">habr.com/post/352296</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">habr.com/post/282524</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr433366/">https://habr.com/ru/post/fr433366/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr433356/index.html">Les attaquants ont appris à contourner l'authentification à deux facteurs Yahoo Mail et Gmail</a></li>
<li><a href="../fr433358/index.html">Connaissance des tests en Python. Partie 1</a></li>
<li><a href="../fr433360/index.html">Les scientifiques ont essayé de prédire quand les avions électriques deviendront réalité</a></li>
<li><a href="../fr433362/index.html">9 principes de beauté, de simplicité et de soins en UX</a></li>
<li><a href="../fr433364/index.html">LDraw + Unity. Comment j'ai généré Lego</a></li>
<li><a href="../fr433368/index.html">Comment appliquer la pensée épicerie au monde: un exemple de sweat-shirt</a></li>
<li><a href="../fr433370/index.html">Théorie du sharding</a></li>
<li><a href="../fr433372/index.html">Vélo de voiture</a></li>
<li><a href="../fr433374/index.html">Toute la vérité sur RTOS. Article # 26. Canaux: services auxiliaires et structures de données</a></li>
<li><a href="../fr433376/index.html">Cours MIT "Sécurité des systèmes informatiques". Conférence 21: Suivi des données, partie 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>