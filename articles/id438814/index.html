<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¿â€ğŸ¤â€ğŸ‘©ğŸ¼ ğŸ†‘ ğŸ’£ Pandangan sadar pada Helm 2: "Itulah apa itu ..." ğŸ‘©ğŸ½â€ğŸ“ ğŸ˜ ğŸšŸ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seperti solusi lainnya, Helm - manajer paket untuk Kubernetes - memiliki pro, kontra, dan cakupan, jadi ketika menggunakannya, Anda harus mengevaluasi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pandangan sadar pada Helm 2: "Itulah apa itu ..."</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/438814/">  Seperti solusi lainnya, Helm - manajer paket untuk Kubernetes - memiliki pro, kontra, dan cakupan, jadi ketika menggunakannya, Anda harus mengevaluasi harapan Anda dengan benar ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ix/5j/fm/ix5jfmapr_v4yignapctr-x7_jc.jpeg"></div><br>  Kami menggunakan Helm di gudang alat bergulir kontinu.  Pada saat penulisan, ada <b>lebih dari seribu aplikasi</b> dalam kelompok kami dan sekitar 4000 instalasi aplikasi ini dalam berbagai variasi.  Secara berkala kami mengalami masalah, tetapi secara umum kami puas dengan solusinya, kami tidak memiliki downtime dan kehilangan data. <br><br>  Motif utama untuk menulis artikel ini adalah untuk memberikan <b>penilaian obyektif terhadap</b> masalah utama Helm 2 kepada pengguna tanpa kesimpulan pasti, serta keinginan untuk berbagi pengalaman dan solusi kami. <a name="habracut"></a><br><br><h2>  [BUG] Setelah diluncurkan, status sumber daya rilis di cluster tidak sesuai dengan bagan Helm yang dijelaskan </h2><br>  Saat bekerja, Helm tidak memperhitungkan status sumber daya rilis di cluster.  Saat menginstal ulang, hasilnya hanya ditentukan oleh konfigurasi saat ini dan yang disimpan.  Dengan demikian, keadaan sumber daya di cluster dan registri Helm berbeda, dan Helm tidak memperhitungkannya. <br><br>  Pertimbangkan bagaimana masalah ini memanifestasikan dirinya: <br><br><ol><li>  Templat sumber daya pada bagan sesuai dengan negara X. </li><li>  Pengguna menginstal grafik (Tiller menyimpan status sumber daya X). </li><li>  Selanjutnya, pengguna secara manual mengubah sumber daya dalam klaster (status berubah dari X ke Y). </li><li>  Tanpa membuat perubahan, itu melakukan <code>helm upgrade</code> ... Dan sumber daya masih dalam kondisi Y, meskipun pengguna mengharapkan X. </li></ol><br>  Dan itu belum semuanya.  Pada titik tertentu, pengguna mengubah templat sumber daya pada bagan (status W baru) - maka kami memiliki dua skenario setelah <code>helm upgrade</code> : <br><br><ul><li>  Aplikasi patch XW sedang jatuh. </li><li>  Setelah menerapkan tambalan, sumber daya masuk ke status Z, yang tidak sesuai dengan yang diinginkan. </li></ul><br>  Untuk menghindari masalah seperti itu, diusulkan untuk mengatur pekerjaan dengan rilis sebagai berikut: <b>tidak ada yang harus mengubah sumber daya secara manual</b> , Helm adalah satu-satunya alat untuk bekerja dengan sumber daya rilis.  Idealnya, perubahan grafik diversi dalam repositori Git dan diterapkan <b>secara eksklusif</b> dalam CD. <br><br>  Jika opsi ini tidak cocok, maka Anda dapat <b>memantau sinkronisasi status sumber daya</b> rilis.  Sinkronisasi manual mungkin terlihat seperti ini: <br><br><ol><li>  Kami mencari tahu status sumber daya rilis melalui <code>helm get</code> . </li><li>  Cari tahu status sumber daya di Kubernetes via <code>kubectl get</code> . </li><li>  Jika sumber dayanya berbeda, maka kami menyinkronkan Helm dengan Kubernetes: <br><ol><li>  Buat cabang terpisah. </li><li>  Memperbarui manifes grafik.  Template harus cocok dengan status sumber daya di Kubernetes. </li><li>  Kami melakukan penyebaran.  Kami menyinkronkan status dalam registri dan klaster Helm. </li><li>  Setelah itu, cabang dapat dihapus dan melanjutkan pekerjaan rutin. </li></ol></li></ol><br>  Saat menerapkan tambalan menggunakan <code>kubectl apply</code> , apa yang disebut <b>penggabungan 3-arah</b> dieksekusi, mis.  keadaan sebenarnya dari sumber daya yang diperbarui diperhitungkan.  Anda dapat melihat kode algoritme di <a href="">sini</a> , dan membacanya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Pada saat penulisan, pengembang Helm sedang mencari cara untuk menerapkan 3-cara-penggabungan di Helm 3. Dengan Helm 2, hal-hal tidak begitu cerah: penggabungan 3 arah tidak direncanakan untuk diterapkan, tetapi ada PR untuk memperbaiki cara sumber daya dibuat - Anda dapat mengetahui detail atau bahkan berpartisipasi sebagai bagian dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah yang relevan</a> . <br><br><h2>  [BUG] Kesalahan: tidak ada SUMBER DAYA dengan nama NAMA ditemukan </h2><br>  Masalahnya memanifestasikan dirinya jika <b>sumber daya baru</b> berhasil dibuat ketika peluncuran diulang, dan peluncuran itu sendiri akhirnya gagal.  <b>Sumber daya baru</b> berarti <b>sumber daya</b> yang tidak ada dalam pemasangan bagan terakhir. <br><br>  Jika peluncuran gagal, rilis disimpan dalam registri bertanda <b>GAGAL</b> , dan selama instalasi Helm bergantung pada keadaan rilis <b>DEPLOYED</b> terbaru, yang dalam hal ini tidak tahu apa-apa tentang sumber daya baru.  Akibatnya, Helm mencoba menciptakan kembali sumber daya ini dan gagal dengan kesalahan "tidak ada SUMBER DAYA dengan nama yang ditemukan NAME" (kesalahan mengatakan sebaliknya, tetapi ini masalahnya).  Bagian dari masalahnya adalah bahwa Helm tidak memperhitungkan status sumber daya rilis di cluster saat membuat patch, seperti yang dijelaskan di bagian sebelumnya. <br><br>  Untuk saat ini, satu-satunya solusi adalah menghapus sumber daya baru secara manual. <br><br>  Untuk menghindari keadaan seperti itu, dimungkinkan untuk secara otomatis menghapus sumber daya baru yang dibuat dalam pemutakhiran / kembalikan saat ini jika perintah akhirnya gagal.  Setelah diskusi panjang dengan pengembang di Helm, untuk perintah upgrade / rollback, opsi <code>--cleanup-on-fail</code> ditambahkan, yang mengaktifkan pembersihan otomatis ketika peluncuran gagal.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PR</a> kami sedang dalam diskusi, mencari solusi terbaik. <br><br>  Dimulai dengan Helm versi 2.13, opsi <code>--atomic</code> muncul di perintah <code>helm install/upgrade</code> , yang mengaktifkan pembersihan dan kembalikan selama instalasi gagal (untuk lebih jelasnya, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PR</a> ). <br><br><h2>  [BUG] Kesalahan: menonton ditutup sebelum Hingga batas waktu habis </h2><br>  Masalahnya dapat terjadi ketika kait Helm dieksekusi terlalu lama (misalnya, selama migrasi) - meskipun batas waktu <code>helm install/upgrade</code> ditentukan dan <code>spec.activeDeadlineSeconds</code> Pekerjaan yang sesuai tidak dilampaui. <br><br>  Kesalahan ini dihasilkan oleh server API Kubernetes sambil menunggu pekerjaan hook selesai.  Helm tidak menangani kesalahan ini dan langsung macet - alih-alih mencoba kembali permintaan tunggu. <br><br>  Sebagai solusi, Anda dapat meningkatkan batas waktu di api-server: <code>--min-request-timeout=xxx</code> dalam file <code>/etc/kubernetes/manifests/kube-apiserver.yaml</code> . <br><br><h2>  [BUG] Kesalahan: UPGRADE GAGAL: â€œfooâ€ tidak memiliki rilis yang digunakan </h2><br>  Jika rilis pertama melalui <code>helm install</code> gagal, <code>helm upgrade</code> berikutnya akan menghasilkan kesalahan yang sama. <br><br>  Tampaknya solusinya cukup sederhana: Anda harus secara manual melakukan <code>helm delete --purge</code> setelah instalasi pertama gagal, tetapi tindakan manual ini merusak otomatisasi CI / CD.  Agar tidak mengganggu pelaksanaan perintah manual, Anda dapat menggunakan fitur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">werf</a> untuk menjalankan.  Saat menggunakan werf, rilis yang bermasalah akan secara otomatis diciptakan kembali setelah instalasi ulang. <br><br>  Selain itu, dimulai dengan versi Helm 2.13, di perintah <code>helm install</code> dan <code>helm upgrade --install</code> instalasi <code>helm upgrade --install</code> cukup tentukan opsi <code>--atomic</code> dan setelah instalasi yang gagal rilis akan secara otomatis dihapus (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PR untuk</a> rinciannya). <br><br><h2>  Autorollback </h2><br>  Helm tidak memiliki opsi <code>--autorollback</code> , yang, ketika <code>--autorollback</code> , akan mengingat revisi yang berhasil saat ini (akan turun jika revisi terakhir tidak berhasil) dan, setelah upaya penyebaran yang tidak berhasil, akan mundur ke revisi yang disimpan. <br><br>  Karena sangat penting bagi produk untuk bekerja tanpa gangguan, maka perlu dicari solusinya, peluncuran harus dapat diprediksi.  Untuk meminimalkan kemungkinan downtime produk, <b>pendekatan dengan beberapa kontur</b> (misalnya, staging, qa, dan produksi) sering digunakan, yang terdiri dari peluncuran berurutan ke kontur.  Dengan pendekatan ini, sebagian besar masalah diperbaiki sebelum diluncurkan ke yang produktif dan bersamaan dengan autorolback memungkinkan Anda untuk mencapai hasil yang baik. <br><br>  Untuk mengatur autorollback, Anda dapat menggunakan plugin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">helm-monitor</a> , yang memungkinkan Anda untuk mengikat rollback ke metrik dari Prometheus.  Artikel bagus yang menggambarkan pendekatan ini tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Untuk beberapa proyek kami, pendekatan yang cukup sederhana digunakan: <br><br><ol><li>  Sebelum penyebaran, kami mengingat revisi saat ini (kami percaya bahwa dalam situasi normal, jika rilis ada, maka itu harus dalam keadaan TERGANTUNG): <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> _RELEASE_NAME=myrelease <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> _LAST_DEPLOYED_RELEASE=$(helm list -adr | \ grep <span class="hljs-variable"><span class="hljs-variable">$_RELEASE_NAME</span></span> | grep DEPLOYED | head -n2 | awk <span class="hljs-string"><span class="hljs-string">'{print $2}'</span></span>)</code> </pre> </li><li>  Jalankan instal atau tingkatkan: <br><br><pre> <code class="bash hljs">helm install/upgrade ... || <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> _DEPLOY_FAILED=1</code> </pre> </li><li>  Kami memeriksa status penggunaan dan melakukan rollback ke status tersimpan: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$_DEPLOY_FAILED</span></span></span><span class="hljs-string">"</span></span> == <span class="hljs-string"><span class="hljs-string">"1"</span></span> ] &amp;&amp; [ <span class="hljs-string"><span class="hljs-string">"x</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$_LAST_DEPLOYED_RELEASE</span></span></span><span class="hljs-string">"</span></span> != <span class="hljs-string"><span class="hljs-string">"x"</span></span> ] ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> helm rollback <span class="hljs-variable"><span class="hljs-variable">$_RELEASE_NAME</span></span> <span class="hljs-variable"><span class="hljs-variable">$_LAST_DEPLOYED_RELEASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> </li><li>  Kami mengakhiri pipa dengan kesalahan jika penyebaran tidak berhasil: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$_DEPLOY_FAILED</span></span></span><span class="hljs-string">"</span></span> == <span class="hljs-string"><span class="hljs-string">"1"</span></span> ] ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 1 ; <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> </li></ol><br>  Sekali lagi, dimulai dengan Helm versi 2.13, saat memanggil <code>helm upgrade</code> cukup untuk menentukan opsi <code>--atomic</code> dan setelah kegagalan instalasi rollback akan dilakukan secara otomatis (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PR untuk</a> detailnya). <br><br><h2>  Menunggu ketersediaan sumber daya rilis dan umpan balik pada saat peluncuran </h2><br>  Seperti yang direncanakan, Helm harus memantau pelaksanaan tes <code>--wait</code> dan readiness yang sesuai saat menggunakan opsi <code>--wait</code> : <br><br><pre> <code class="bash hljs">--<span class="hljs-built_in"><span class="hljs-built_in">wait</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>, will <span class="hljs-built_in"><span class="hljs-built_in">wait</span></span> until all Pods, PVCs, Services, and minimum number of Pods of a Deployment are <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a ready state before marking the release as successful. It will <span class="hljs-built_in"><span class="hljs-built_in">wait</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> as long as --timeout</code> </pre> <br>  Fungsi ini tidak berfungsi dengan baik sekarang: tidak semua sumber daya dan tidak semua versi API didukung.  Dan proses penantian yang diumumkan itu sendiri tidak memuaskan kebutuhan kita. <br><br>  Seperti <code>kubectl wait</code> , tidak ada umpan balik cepat dan tidak ada cara untuk mengatur perilaku ini.  Jika peluncuran gagal, maka kita akan mengetahuinya <b>hanya setelah batas waktu</b> .  Dalam hal instalasi yang bermasalah, perlu untuk menyelesaikan proses peluncuran sedini mungkin, membalikkan pipa CI / CD, memutar kembali rilis ke versi yang berfungsi dan melanjutkan ke debugging. <br><br>  Jika rilis yang bermasalah dibatalkan, dan Helm tidak mengembalikan informasi apa pun selama proses peluncuran, lalu tentang apa yang debug?  Dalam hal <code>kubectl wait</code> Anda dapat mengatur proses terpisah untuk menampilkan log, yang akan memerlukan nama sumber rilis.  Cara mengatur solusi yang sederhana dan berfungsi tidak segera jelas.  Dan selain log pod, informasi yang berguna dapat dimuat dalam proses peluncuran, acara sumber daya ... <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Utilitas</a> CI / CD <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">werf</a> kami dapat menggunakan grafik Helm dan memantau ketersediaan sumber daya, serta menampilkan informasi yang terkait dengan peluncuran.  Semua data digabungkan menjadi satu aliran dan dikeluarkan ke log. <br><br>  Logika ini dibuat dalam solusi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kubedog</a> terpisah.  Dengan menggunakan utilitas, Anda dapat berlangganan ke sumber daya dan menerima acara dan log, serta mempelajari tentang peluncuran gagal pada waktu yang tepat.  Yaitu  sebagai solusi, setelah memanggil <code>helm install/upgrade</code> tanpa opsi <code>--wait</code> , <code>--wait</code> dapat menghubungi kubedog untuk setiap sumber daya rilis. <br><br>  Kami bertujuan untuk membuat alat yang akan memberikan semua informasi yang diperlukan untuk debugging dalam output pipa CI / CD.  Baca lebih lanjut tentang utilitas di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel terbaru kami</a> . <br><br>  Mungkin di Helm 3 suatu hari nanti solusi serupa akan muncul, tetapi sejauh ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah</a> kami dalam keadaan ditangguhkan. <br><br><h2>  Keamanan saat menggunakan helm init secara default </h2><br>  Secara default, ketika perintah <code>helm init</code> dijalankan, komponen server dipasang di cluster dengan hak istimewa yang mirip dengan superuser, yang dapat menyebabkan konsekuensi yang tidak diinginkan ketika diakses oleh pihak ketiga. <br><br>  Untuk memastikan keamanan cluster, perlu untuk membatasi kemampuan Tiller, serta menjaga koneksi - keamanan jaringan di mana komunikasi antara komponen Helm berlangsung. <br><br>  Yang pertama dapat dicapai melalui penggunaan mekanisme Kubernetes RBAC standar, yang akan membatasi tindakan anakan, dan yang kedua - dengan menetapkan SSL.  Baca lebih lanjut di dokumentasi Helm: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengamankan Instalasi Helm Anda</a> . <br><br>  <i>Diyakini bahwa kehadiran komponen server - Tiller - adalah <b>kesalahan arsitektur yang serius</b> , secara harfiah sumber daya asing dengan hak pengguna super di ekosistem Kubernetes.</i>  <i>Sebagian, kami setuju: implementasinya tidak sempurna, tetapi <b>mari kita lihat dari sisi lain</b> .</i>  <i>Jika Anda mengganggu proses penyebaran dan membunuh klien Helm, sistem tidak akan tetap dalam keadaan tidak terdefinisi, mis.</i>  <i>Anakan akan membawa status rilis ke valid.</i>  <i>Perlu juga dipahami bahwa terlepas dari kenyataan bahwa Tiller ditinggalkan di Helm 3, fungsi-fungsi ini entah bagaimana akan dilakukan oleh pengontrol CRD.</i> <br><br><h2>  Templat Martian Go </h2><br>  Go-templates memiliki ambang masuk yang besar, tetapi teknologi ini tidak memiliki batasan pada kemampuan dan masalah dengan KERING.  Prinsip-prinsip dasar, sintaksis, fungsi dan operator dibahas dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya</a> di seri Helm. <br><br><h2>  Kurangnya rahasia di luar kotak </h2><br>  Sangat mudah untuk menyimpan dan memelihara kode aplikasi, infrastruktur, dan template peluncuran ketika mereka berada di satu tempat.  Dan rahasia tidak terkecuali. <br><br>  Helm tidak mendukung rahasia di luar kotak, namun plugin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">helm-rahasia</a> tersedia, yang pada dasarnya merupakan lapisan antara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sops</a> , manajer rahasia Mozilla, dan Helm. <br><br>  Ketika bekerja dengan rahasia, kami menggunakan solusi kami sendiri yang diimplementasikan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">werf</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi rahasia</a> ).  Fitur: <br><br><ul><li>  Kemudahan implementasi. </li><li>  Menjaga rahasia dalam file, bukan hanya di YAML.  Nyaman saat menyimpan sertifikat, kunci. </li><li>  Regenerasi rahasia dengan kunci baru. </li><li>  Peluncuran tanpa kunci rahasia (saat menggunakan werf).  Mungkin bermanfaat untuk kasus-kasus ketika pengembang tidak memiliki kunci rahasia ini, tetapi ada kebutuhan untuk meluncurkan penyebaran pada tes atau sirkuit lokal. </li></ul><br><h2>  Kesimpulan </h2><br>  Helm 2 diposisikan sebagai produk yang stabil, tetapi pada saat yang sama ada banyak bug yang menggantung di limbo (beberapa dari mereka bertahan selama beberapa tahun!).  Alih-alih solusi, atau setidaknya tambalan, semua upaya dicurahkan untuk mengembangkan Helm 3. <br><br>  Terlepas dari kenyataan bahwa MR dan masalah dapat bertahan selama berbulan-bulan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berikut adalah contoh</a> bagaimana kami menambahkan <code>before-hook-creation policy</code> kait sebelumnya untuk kait selama beberapa bulan), Anda masih dapat berpartisipasi dalam pengembangan proyek.  Setiap Kamis, demonstrasi setengah jam dari para pengembang Helm berlangsung, di mana Anda dapat mempelajari tentang prioritas dan arah tim saat ini, mengajukan pertanyaan dan memaksakan praktik terbaik Anda sendiri.  Tentang mete dan saluran komunikasi lainnya ditulis secara rinci di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Apakah menggunakan Helm atau tidak, itu terserah Anda, tentu saja.  Hari ini kami sendiri berpegang teguh pada posisi yang, meskipun ada kekurangan, Helm adalah solusi yang dapat diterima untuk penempatan dan berguna bagi seluruh masyarakat untuk berpartisipasi dalam pengembangannya. <br><br><h2>  PS </h2><br>  Baca juga di blog kami: <br><br><ul><li>  â€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Membuat paket untuk Kubernetes dengan Helm: struktur bagan dan templating</a> â€; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengantar praktis untuk manajer paket untuk Kubernetes - Helm</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Package Manager untuk Kubernetes - Helm: Past, Present, Future</a> "; </li><li>  â€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berlatihlah dengan dapp.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2. Menyebarkan gambar Docker di Kubernetes dengan Helm</a> . " </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438814/">https://habr.com/ru/post/id438814/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438804/index.html">Menunggu semua orang di CocoaHeads Meetup berikutnya</a></li>
<li><a href="../id438806/index.html">Masalah terjemahan sastra</a></li>
<li><a href="../id438808/index.html">ModelMapper: pulang pergi</a></li>
<li><a href="../id438810/index.html">HTTP / 3: dari root ke ujung</a></li>
<li><a href="../id438812/index.html">Kualitas kode front-end HH</a></li>
<li><a href="../id438818/index.html">UDB. Apa ini Bagian 5. Datapath. Hal-hal kecil yang bermanfaat</a></li>
<li><a href="../id438820/index.html">Manajemen pengetahuan: dokumen apa yang dibutuhkan dan apa yang harus diperbaiki di dalamnya</a></li>
<li><a href="../id438824/index.html">Kursus Singkat Manajemen Jarak Jauh</a></li>
<li><a href="../id438826/index.html">Kencangkan bahasa Inggris untuk wawancara - metodologi dan biaya tenaga kerja</a></li>
<li><a href="../id438828/index.html">Lazarus - menulis komponen untuk animasi sprite</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>