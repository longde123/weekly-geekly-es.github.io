<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úçüèø üë®üèΩ‚Äçüé® üèë Comenzamos a estudiar microcontroladores usando el ejemplo de STM32F030f4p6 ü§æüèæ üàöÔ∏è ‚ú¥Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="0. Antes de leer el art√≠culo 
 Este art√≠culo tiene los siguientes objetivos: 



1. mostrar c√≥mo trabajar espec√≠ficamente con este tablero; 
2. muestr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comenzamos a estudiar microcontroladores usando el ejemplo de STM32F030f4p6</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437234/"><img src="https://habrastorage.org/webt/ex/dh/0-/exdh0-6tdd7sj-4usxbip9chsz0.jpeg"><br><br><h1>  0. Antes de leer el art√≠culo </h1><br>  Este art√≠culo tiene los siguientes objetivos: <br><br><ol><li>  mostrar c√≥mo trabajar espec√≠ficamente con este tablero; </li><li>  muestra el enfoque mediante el cual puede escribir un programa LED parpadeante, bas√°ndose √∫nicamente en la documentaci√≥n y la l√≥gica; </li><li>  presentar el material en un lenguaje que sea comprensible para una persona que no est√© familiarizada con los microcontroladores. </li></ol><br>  El c√≥digo resultar√° minimalista en t√©rminos de uso de archivos adicionales: no incluiremos un solo archivo, excepto aquellos que son necesarios para construir un firmware vac√≠o pero v√°lido.  Es decir  basado en el c√≥digo de firmware, que funciona, pero no hace nada √∫til. <br><a name="habracut"></a><br>  Necesitaremos la siguiente documentaci√≥n: <br><br><ol><li>  Hoja de datos STM32F030x4 (uso el documento de enero de 2017 DocID024849 Rev 3); </li><li>  RM0360 Manual de referencia STM32F030x4 / x6 / x8 / xC (uso el documento de abril de 2017 DocID025023 Rev 4); </li><li>  placa de circuito </li></ol><br>  Puede descargar estos documentos desde la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nube</a> . <br>  El temporizador en el art√≠culo <i>no</i> ser√° considerado y <i>no</i> estar√° involucrado en el c√≥digo. <br>  El programador ST-LINK <i>no</i> fue utilizado.  Para trabajar con la placa, se utiliz√≥ un adaptador USB-COM (RS232 basado en PL2303HX), que emula un puerto COM. <br><br><div class="spoiler">  <b class="spoiler_title">Adaptador de foto</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/wp/em/u8/wpemu8n1juvbuipavxu-mzfa2eq.jpeg"></div></div><br>  Todo se recopil√≥ en una m√°quina virtual Windows XP Professional 2002 SP3 que se ejecuta a trav√©s de VirtualBox versi√≥n 5.2.22r126460 en un host Windows X. <br><br><h1>  1. Instalaci√≥n del controlador para el adaptador USB-COM </h1><br>  Windows no es de ayuda, descargue desde el sitio oficial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Prolific</a> (el primer enlace a la solicitud "controlador prol√≠fico" en Google) controlador USB a UART / Serial / Printer <b>PL2303 Controlador de Windows</b> (necesita el <i>controlador est√°ndar</i> )  O puedes descargar desde mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nube</a> . <br><br>  Instale el controlador, reinicie y vea el nuevo puerto COM. <br><br><div class="spoiler">  <b class="spoiler_title">Captura de pantalla con el nombre del instalador y el nuevo puerto COM</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/tq/tt/dh/tqttdhvov6eiov75df-pqcycz0s.png"></div></div><br>  La configuraci√≥n del puerto dej√≥ el est√°ndar.  Puede cambiar el n√∫mero de puerto COM a su discreci√≥n.  En mi experiencia, solo una vez en mi vida he visto un programa ver solo los primeros 4 puertos COM, si no me equivoco, era alg√∫n tipo de terminal Bluetooth en Windows. <br><br><div class="spoiler">  <b class="spoiler_title">Configuraciones de puerto COM</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ak/ad/ep/akadepan2w3tldshsr6sys69jo4.png"><br></div></div><br><h1>  2. Llenado de firmware dentro y fuera del tablero </h1><br><h2>  2.0 Utilidad de descarga para trabajar con la placa </h2><br>  Descargamos la utilidad <b>FLASHER-STM32</b> del sitio web de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">STM</a> (en la descripci√≥n se llama STM32 Flash loader demostrador (UM0462)), tendr√° que registrarse para esto, pero no da miedo; al final, soltaremos el archivo zip con el instalador;  Siguiente-&gt; Siguiente-&gt; Siguiente ... y todo est√° instalado.  Para mayor comodidad, creo un acceso directo a esta aplicaci√≥n en la carpeta de trabajo. <br><br><div class="spoiler">  <b class="spoiler_title">Aqu√≠ est√° la utilidad (captura de pantalla del sitio)</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/oa/4a/xz/oa4axzxm4eljcbpzubyspqghcbe.png"><br></div></div><br>  De manera predeterminada, la ruta a la utilidad <i>C: Archivos de programa \ STMicroelectronics \ Software \ Flash Loader Demo \ STMFlashLoader Demo.exe</i> . <br><br><h2>  2.1 matiz de arranque </h2><br>  Hay un puente BOOT en el tablero. <br><br><ul><li>  Cuando el puente est√° <b>cerrado</b> , el microcontrolador cargar√° las instrucciones de su memoria (es decir, un programa escrito por un programador). </li><li>  Cuando el puente est√° <b>abierto</b> , el microcontrolador recibir√° informaci√≥n sobre las l√≠neas RX y TX, es decir.  Ser√° flasheado desde el puerto COM (desde el adaptador en mi caso). </li></ul><br><h2>  2.2 Configurar la utilidad </h2><br><img src="https://habrastorage.org/webt/pu/oc/h3/puoch3mqjkqfryjvcnxfg9zeycq.png"><br><br>  Ejecute esta aplicaci√≥n, en realidad es la m√°s simple (contiene un m√≠nimo de configuraciones).  En la primera ventana, seleccione: <br><br><ol><li>  interfaz (tengo COM-3); </li><li>  la velocidad con la cual la computadora y el microcontrolador se comunicar√°n (en mi humilde opini√≥n, valor normal 9600); </li><li>  el n√∫mero de bits de datos (por alguna raz√≥n, esta ventana no est√° disponible para m√≠, pero hasta ahora esto no es importante); </li><li>  paridad (no tengo paridad, es decir, ninguna); </li><li>  echo (tengo apagado); </li><li>  tiempo de espera (tengo 10 segundos). </li></ol><br>  Haga clic en Siguiente, y si todo est√° en orden, veremos una luz verde y "El objetivo es legible";  Si vemos una luz roja, la computadora no podr√≠a conectarse. <br><br><div class="spoiler">  <b class="spoiler_title">El objetivo es legible si el microcontrolador se detecta con √©xito</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/gd/9y/hw/gd9yhwnpu15asiupizayeozvsfo.png"><br></div></div><br>  El orden de los pasos que siempre ayudan: <br><br><ol><li>  En primer lugar, debe verificar si el puente BOOT en el tablero est√° cerrado. </li><li>  En segundo lugar, en cualquier caso, apague el microcontrolador y preferiblemente las l√≠neas TX y RX que vienen del adaptador a la placa (no puede desconectar la tierra). </li><li>  En tercer lugar, en el programa, presione Volver al final, es decir  a la primera p√°gina, o incluso cerrarla y reiniciarla (en general, a veces se congela).  Es importante comenzar siempre desde la primera p√°gina antes de cada conexi√≥n a la placa a trav√©s de este programa. </li><li>  Cuarto, recoja los cables del adaptador a la placa e intente conectarse nuevamente en el programa (¬°aseg√∫rese desde la primera p√°gina!). </li></ol><br>  Si todo lo dem√°s falla, puede intentar apagar todo, reiniciar la computadora e intentar volver a conectarse a la placa. <br><br>  Porque  Trabajo a trav√©s de una m√°quina virtual, tengo que volver a conectar el adaptador USB-COM varias veces para que la m√°quina virtual lo detecte y la m√°quina host no tenga tiempo para instalar controladores da√±ados. <br><br>  Otra opci√≥n que encontr√© trabajando mientras escrib√≠a este art√≠culo es presionar un bot√≥n en el tablero en lugar de tirar constantemente de los cables.  Sin embargo, deber√° cerrar y abrir el puente BOOT en cualquier caso.  Esta opci√≥n funciona porque el bot√≥n se coloca al pie del restablecimiento <abbr title="RESET EXTERNO">NRST</abbr> externo. <br><br>  En la siguiente ventana, seleccione el dispositivo de destino.  Por cierto, a veces aqu√≠ puede ver (tal vez un error) el dispositivo izquierdo en general, por ejemplo, en lugar de STM32, vea STM8: en alg√∫n lugar hubo alg√∫n tipo de falla, el procedimiento de tratamiento se describe anteriormente.  Por lo tanto, en este paso no puede apresurarse a hacer clic en Siguiente, pero siempre preste atenci√≥n al hecho de que el dispositivo deseado est√° seleccionado en Target. <br><br><div class="spoiler">  <b class="spoiler_title">Selecci√≥n de dispositivo de destino</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/zz/p8/83/zzp88341ayrb95ymtn1bf3-elvq.png"><br></div></div><br>  ¬øC√≥mo determinar qu√© dispositivo tenemos?  - miramos el chip y reescribimos todo lo que est√° escrito en √©l.  Abrimos la <i>hoja</i> de <i>datos</i> en nuestro chip, la secci√≥n <i>Informaci√≥n de pedido</i> describe qu√© carta es responsable de qu√©.  En mi caso es: <br><br><img src="https://habrastorage.org/webt/pa/kn/ga/pakngat6l5tahlk-y75nledccuy.png"><img src="https://habrastorage.org/webt/f0/fb/jk/f0fbjkrbe8a-g5uqbjdovxzr_fc.png"><br><br><div class="spoiler">  <b class="spoiler_title">Selecciono mi chip (16K) en Target y sigo adelante.</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/qs/u4/v2/qsu4v2uhtvft1sj1uhp2bnount4.png"><br></div></div><br>  Se ofrece una opci√≥n de 4 acciones con un chip: <br><br><ol><li>  borrar memoria (completa o seleccionar un √°rea espec√≠fica); </li><li>  escribir firmware en el dispositivo; </li><li>  leer el firmware del dispositivo; </li><li>  activar / desactivar la protecci√≥n contra escritura o lectura. </li></ol><br><h2>  2.3 Leer firmware de la placa </h2><br>  Cuando conect√© la placa por primera vez, decid√≠ mantener el firmware original, una especie de respaldo; lo haremos ahora.  Ser√° necesario indicar d√≥nde guardar este firmware y qu√© p√°ginas de memoria guardar, tambi√©n se propone utilizar un formato de archivo <i>hexadecimal</i> , <i>bin</i> o <i>s19</i> para <i>elegir</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Seleccione p√°ginas de memoria para leer</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/b_/vs/yq/b_vsyqyslqo1sib02nymmymvy_m.png"><br></div></div><br>  Si solo carga el firmware en la placa o lee el firmware desde la placa, entonces no hay diferencia entre estos formatos de archivo.  La siguiente es una p√°gina de progreso, en la que a veces el proceso se congela en un 99% durante mucho tiempo (no necesariamente 99), pero despu√©s de unos segundos supuestamente se completa con √©xito; de hecho, despu√©s de eso, la placa no dio el comportamiento que corresponder√≠a al firmware cargado.  En pocas palabras, debe volver a conectar todo y volver a llenar el firmware, no hay nada cr√≠tico al respecto. <br><br>  El archivo de firmware se guard√≥ y, en el futuro, se puede cargar en la placa. <br><br>  Sin embargo, si la protecci√≥n contra lectura est√° instalada, el firmware no se puede leer. <br><br><div class="spoiler">  <b class="spoiler_title">Ventana de progreso</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/nb/ta/rs/nbtarsmjtb1-ylmcxaesykldlv0.png"><br></div></div><br><h2>  2.4 Destellando el tablero </h2><br>  Ahora complete el archivo de firmware, cuya escritura del c√≥digo fuente se proporciona a continuaci√≥n.  Mirando hacia el futuro, dir√© que subiremos archivos <i>bin</i> y <i>hexadecimales</i> , porque  el entorno de desarrollo los emitir√°.  Las configuraciones adicionales para <i>s19</i> y archivos <i>hexadecimales</i> son id√©nticas;  a diferencia de ellos, en el archivo <i>bin</i> , puede seleccionar la direcci√≥n desde la que se grabar√° el firmware, de forma predeterminada en la utilidad es 8000000 (adecuado para nosotros). <br><br><div class="spoiler">  <b class="spoiler_title">Preparando para grabar</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/1k/u8/cf/1ku8cfxnzt_bjob1szyix3u2xpw.png"><br></div></div><br>  Antes de grabar, puede borrar la memoria flash del microcontrolador eligiendo una de tres opciones: <br><br><ul><li>  Borre las p√°ginas necesarias (borre las secciones de memoria necesarias); </li><li>  Sin borrado (sin purificaci√≥n); </li><li>  Borrado global (limpieza completa). </li></ul><br>  De hecho, la limpieza es el proceso de escribir ceros en la memoria. <br><br>  Todav√≠a hay bytes opcionales, pero hasta ahora no puedes tocarlos.  Haga clic en Siguiente, espere a que se complete el proceso y listo. <br><br>  En caso de que desee grabar mi firmware, puede encontrarlo en la nube, el archivo <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">blink.bin</a></i> .  Al usar este firmware, el LED incorporado que parpadea desde el pie PA4 deber√≠a parpadear. <br><br><h1>  3. Redacci√≥n de c√≥digos </h1><br><h2>  3.0 Instalaci√≥n del entorno de desarrollo CooCox CoIDE </h2><br>  Puede descargar el IDE desde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SoftPedia.com</a> , anteriormente era posible descargarlo desde el sitio web de STM y desde el sitio del propio IDE, pero como el IDE ya no era compatible, se ha vuelto imposible.  No hay nada cr√≠tico en que el IDE ya no sea compatible, no, porque  para escribir c√≥digo, lo principal es el compilador.  Descargu√© ambas versiones, pero uso la versi√≥n 1.7.8. <br>  El primer lanzamiento del entorno est√° bien descrito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> , Siguiente-&gt; Siguiente-&gt; Siguiente ... y nada complicado.  Solo agregar√© que primero es mejor crear un proyecto y luego todo lo dem√°s. <br><br>  Y, sin embargo, si perdi√≥ la pesta√±a Repositorio, puede encontrarla en el men√∫ <i>Ver -&gt; Repositorio</i> . <br>  Puede descargar herramientas (compilador) para el entorno <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> o pedirle a Google "herramientas gnu para armar";  Descargu√© una opci√≥n que tiene sha1.exe al final. <br><br><h2>  3.1 Marco fuente </h2><br>  Entonces, el proyecto ha sido creado, el chip ha sido seleccionado, ahora agregaremos el conjunto m√≠nimo de fuentes al proyecto, sin el cual no podr√° vivir en absoluto. <br><br><div class="spoiler">  <b class="spoiler_title">As√≠ es como deber√≠a verse el proyecto cuando se acaba de crear, es decir</b>  <b class="spoiler_title">solo est√° el archivo main.c principal y nada m√°s</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/db/rf/qh/dbrfqhef0pg7j3perjtzm3b3okc.png"><br></div></div><br>  <b>Seleccione CMSIS BOOT</b> y el entorno <b>seleccionar√°</b> autom√°ticamente <b>M0 Cmsis Core</b> , porque  las dependencias requieren esto. <br><br><div class="spoiler">  <b class="spoiler_title">Ahora tenemos el conjunto m√≠nimo de fuentes</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fk/u8/qt/fku8qtl8uhcttxq_xswbovf-10c.png"><br></div></div><br>  Ensamble el proyecto (icono de construcci√≥n o tecla F7).  Por razones desconocidas para m√≠, el archivo hexadecimal no se recopil√≥ (hay una advertencia en la consola);  Reinstal√© el IDE y el compilador varias veces, volv√≠ a crear el proyecto, pero por alguna raz√≥n ese resultado en la m√°quina virtual;  en otra computadora (no virtual, pero real) todo es uno a uno y la salida funciona de forma hexadecimal.  Afortunadamente, hay bin. <br><br><div class="spoiler">  <b class="spoiler_title">El proyecto fue ensamblado exitosamente</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ap/zn/ct/apznctscxqdbgullp11rzqxtyj4.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Le aconsejo que preste atenci√≥n al tama√±o del archivo, se puede ver al final de la salida en la consola, o puede verlo por medios est√°ndar (aqu√≠, por cierto, puede ver que el hex est√° vac√≠o);</b>  <b class="spoiler_title">Al mismo tiempo, esta captura de pantalla muestra que los archivos de firmware est√°n en la carpeta del proyecto, luego Debug / bin /</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ho/ue/wd/houewdyn-cyjvmn-js5sbah-yru.png"><br></div></div><br>  Aunque el c√≥digo no hace nada, lo subo al tablero para asegurarme de que pueda cargarlo (lo cual, por ejemplo, la utilidad no lo rechaza).  Aconsejo al lector que haga esto.  Si no funciona, int√©ntalo una y otra vez y escribe comentarios. <br><br><h2>  3.2 Algoritmo de dedo </h2><br>  Para comenzar, bosquejamos un algoritmo de c√≥mo, desde un punto de vista humano, el microcontrolador parpadear√° un LED.  Y para esto un peque√±o razonamiento. <br><br>  Cada equipo funciona debido a la energ√≠a almacenada, por ejemplo, algunos motores pueden funcionar con diferentes tipos de combustible, pero para esto el motor debe ajustarse al tipo de combustible con el que vamos a alimentarlo.  Del mismo modo, el microcontrolador debe ajustarse (sintonizarse) para la fuente de energ√≠a; este ser√° el <i>primer bloque del</i> algoritmo. <br>  Razonamos m√°s.  La computadora de escritorio tiene un monitor, parlantes, teclado, mouse ... y puede ver que algunos dispositivos nos brindan informaci√≥n, y con la ayuda de otros le brindamos informaci√≥n a la computadora, pero todos est√°n conectados a una caja com√∫n a todos ellos (la unidad del sistema).  Puede adivinar que el microcontrolador puede recibir y proporcionar informaci√≥n, lo que significa que sus patas pueden recibir una se√±al o emitir una se√±al; este ser√° el <i>siguiente bloque del</i> algoritmo. <br><br>  Luego, el microcontrolador debe encender el LED, esperar un momento, apagar el LED, esperar un momento y encenderlo, esperar, apagar ... <br><br>  Como resultado, el algoritmo se ver√° as√≠ <br><br><img src="https://habrastorage.org/webt/h1/m4/oo/h1m4oou5txdafrybbwobj69vahm.png" height="361" width="192"><br><br>  El prop√≥sito de este diagrama de flujo es mostrar claramente lo que hace el algoritmo;  En primer lugar, el esquema est√° escrito para usted, por lo que todos son libres de escribirlo / dibujarlo como quieran (para s√≠ mismos).  Creo que el esquema debe ser tan simple, legible e intuitivo como sea posible, para tener un alto nivel de abstracci√≥n. <br><br>  De acuerdo con este algoritmo, escribiremos c√≥digo. <br><br><h2>  3.3 Trabajando con documentaci√≥n </h2><br>  Recomiendo leer esta parte del art√≠culo con el archivo abierto <i>stm32f0xx.h</i> , que se encuentra en la carpeta <i>cmsis_boot</i> de nuestro proyecto, y la documentaci√≥n abierta. <br><br><h3>  3.3.1 Seleccionar una fuente de reloj </h3><br>  Primero, debe proporcionar energ√≠a al microcontrolador.  El microcontrolador recibe 5 voltios del adaptador (medido con un mult√≠metro), pero surge la pregunta de "a qu√© frecuencia funciona el microcontrolador", porque se sabe que la electr√≥nica funciona a diferentes frecuencias.  Primero, abra la <i>hoja de datos</i> , en el contenido puede ver dos secciones que son relevantes en significado: <i>administraci√≥n de energ√≠a</i> , <i>relojes y arranque</i> .  El primero es sobre los modos de voltaje y baja potencia.  La segunda secci√≥n esconde lo que nos interesa en este momento.  Ya en la primera oraci√≥n dice "el oscilador interno RC de 8 MHz se selecciona como reloj predeterminado de la CPU al reiniciar", lo que significa que, <i>despu√©s de reiniciar el MC, la cadena interna de RC de 8 MHz</i> se selecciona como la <i>fuente principal del reloj</i> . <br>  Luego viene un esquema de √°rbol de reloj incomprensible, que consideraremos un poco m√°s adelante. <br><a name="Clock_tree"></a><br><br><div class="spoiler">  <b class="spoiler_title">√Årbol de reloj</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/sg/nl/ul/sgnlul1krp_mdiqntf5it8a0eni.png"></div></div><br>  Hablando estrictamente, puede confiar en la frase "por defecto despu√©s de restablecer el MK ..." y leer esta parte del art√≠culo en diagonal. <br><br>  Ahora debe distraerse con la placa y buscar el LED interno.  S√© que los diodos en los circuitos se denotan por <i>D1</i> , <i>D2</i> ..., es decir  <i>D == diodo</i> , en mi placa cerca de la resistencia <i>R7</i> est√° el diodo <i>D1</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Foto del tablero</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ma/ze/ke/mazekeve26x9-imexuqb2k1knb8.png" width="462" height="330"><br></div></div><br>  Quiz√°s, despu√©s de haber examinado cuidadosamente la placa, puede rastrear a qu√© pata est√° conectado el diodo, pero pasar√© a la placa de circuito.  Desafortunadamente, los elementos de la placa no coinciden exactamente con los elementos del circuito en su ubicaci√≥n;  pero me alegro de haber encontrado ese esquema en Internet (de lo contrario, no pude encontrar nada durante mucho tiempo). <br><br><img src="https://habrastorage.org/webt/id/gz/tw/idgztwbtwraskhguvq-9alkrp18.png"><br><br>  En el diagrama vemos que el c√°todo del diodo est√° conectado a tierra a trav√©s del puente <i>J2</i> , y el √°nodo est√° conectado al pin <i>PA4 a</i> trav√©s de una resistencia.  <i>PA4</i> significa la cuarta salida del puerto <i>A</i> , lo que significa que para encender y apagar el LED, ser√° necesario suministrar voltaje a la salida de <i>PA4</i> . <br><br>  A continuaci√≥n, debe determinar c√≥mo aplicar voltaje a esta salida.  Esto no fue intuitivo para m√≠ en absoluto, y durante mucho tiempo revis√© la documentaci√≥n a lo largo y ancho hasta que encontr√© el <b>diagrama de Bloques</b> en la secci√≥n <i>Descripci√≥n</i> al comienzo de la hoja de datos.  Y en √©l vi la preciada pista <i>PA [15: 0] &lt;=&gt; puerto GPIO A &lt;=&gt; decodificador AHB &lt;=&gt; Matriz de bus &lt;=&gt; Cortex-M0</i> , es decir  El puerto <i>A</i> es un puerto de E / S de prop√≥sito general y est√° conectado al bus <abbr title="Bus avanzado de alto rendimiento"><i>AHB</i></abbr> . <br><br><div class="spoiler">  <b class="spoiler_title">Diagrama de bloques</b> <div class="spoiler_text">  (Se puede hacer clic en la imagen) <br> <a href=""><img src="https://habrastorage.org/webt/_e/hf/d0/_ehfd0kdf5v87xxud5yj4abp3xu.png"></a> <br></div></div><br>  Observo que en electr√≥nica es habitual dividir las salidas del microcontrolador en puertos, y generalmente el puerto tiene 16 salidas.  El diagrama muestra que los puertos <i>A</i> , <i>B</i> y <i>C</i> tienen solo 16, pero los puertos <i>D</i> y <i>F</i> tienen menos (menos de 16 pines pueden ser, m√°s - no). <br><br>  Volvamos al esquema del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√°rbol</a> del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">reloj</a> y encontremos la salida firmada por <i>AHB</i> .  Averiguaremos con qu√© frecuencia funciona esta salida.  Para el <i>AHB est√°</i> la se√±al <i>HCLK</i> , que sale del divisor <i>HPRE</i> .  Este divisor recibe la se√±al <abbr title="CIERRE DEL SISTEMA"><i>SYSCLK</i></abbr> del interruptor <abbr title="Sistema de reloj de bruja"><i>SW</i></abbr> .  ¬øCu√°l de las se√±ales en la entrada de <i>SW</i> se usar√° cuando <i>SYSCLK</i> se <i>configura mediante programaci√≥n</i> ? Luego lo configuraremos en el c√≥digo.  La elecci√≥n se ofrece: <br><br><ol><li>  <i><abbr title="Alta velocidad interna">HSI</abbr></i> : una se√±al de un generador interno de alta frecuencia, es producida por un resonador de cuarzo de 8 MHz, que solde antes de trabajar con esta placa; </li><li>  <i><abbr title="Fase de bloqueo de bucle CLocK">PLLCLK</abbr></i> - se√±al del multiplicador de frecuencia <i>PLLMUL</i> ; </li><li>  <i><abbr title="Alta velocidad externa">HSE</abbr></i> - se√±al de un generador externo de alta frecuencia. </li></ol><br>  Cualquier opci√≥n es adecuada para nuestra tarea, sugiero elegir la m√°s simple y asequible: <i>HSI</i> . <br><br>  Entraremos en el <i>Manual de referencia</i> y abriremos la secci√≥n <i>7 Restablecimiento y control del reloj (RCC)</i> , espec√≠ficamente <i>7.2.6 Selecci√≥n del reloj del sistema</i> , donde una vez m√°s nos encontramos con una redacci√≥n similar que se encuentra en la hoja de datos: "despu√©s de un restablecimiento del sistema, el oscilador <i>HSI</i> se selecciona como sistema reloj "- es decir  ni siquiera tenemos que hacer nada, MK comenzar√° con <i>HSI</i> . <br><br>  Para asegurarme de que MK realmente funcione desde esta fuente, escribir√© esto expl√≠citamente en el programa;  Despl√°cese a los registros responsables de restablecer y marcar (secci√≥n <i>7.4 Registros RCC</i> ).  El primer registro descrito en la documentaci√≥n es el <b>registro de control del reloj (RCC_CR)</b> ;  A continuaci√≥n se muestra una descripci√≥n de los bits, que es responsable de qu√©. <br><br><div class="spoiler">  <b class="spoiler_title">Registro de control del reloj</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/qq/i4/ll/qqi4llshdqrtgidy2_x-hxx9yhe.png"><br></div></div><br>  Estamos interesados ‚Äã‚Äãen el <i>bit</i> cero <i>HSION</i> , que es responsable de encender el resonador ( <i>0</i> - apagado, <i>1</i> - encendido). <br><br>  Por lo tanto, ser√° necesario escribir uno en el registro <i>RCC_CR</i> .  (cero bit es uno, o 2 <sup>0</sup> = 1). <br><br>  Ahora encontramos en el archivo <i>stm32f0xx.h</i> la definici√≥n de <b>RCC</b> ( <i>#define RCC</i> ). <br><br><div class="spoiler">  <b class="spoiler_title">RCC-&gt; RC</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/vn/ej/0x/vnej0xmqlqnrgeprbgyjo9cpjt8.png"><br></div></div><br>  Como puede ver, esta es la estructura ubicada en <i>RCC_BASE</i> ;  direcci√≥n <i>0x40021000</i> , si expande todas las <i>definiciones</i> , la misma direcci√≥n se puede ver en el <i>Manual de referencia</i> en la secci√≥n <i>2.2.2 Mapa de memoria y direcciones de l√≠mite de registro</i> y en la hoja de datos en la secci√≥n <i>5</i> <i>Mapa</i> <i>de memoria</i> (√°rea <i>AHB</i> ). <br><br>  Para escribir una unidad para habilitar <i>HSI</i> en el registro <i>CR de</i> bloque <i>RCC</i> , necesita una l√≠nea de c√≥digo <br><br><pre><code class="plaintext hljs">RCC-&gt;CR |= 0x1;</code> </pre> <br><h3>  3.3.2 Ajuste de las piernas </h3><br>  Enviar una se√±al a la pata del microcontrolador para encender el LED y detener la se√±al para que el LED se apague son acciones simples y, por lo tanto, esto se refiere a las funciones <i><abbr title="Entradas / salidas de uso general">GPIO</abbr></i> (puertos de entrada-salida de prop√≥sito general). <br><br>  Por defecto, las patas MK no est√°n conectadas, es decir  El resultado es la incertidumbre.  Es necesario conectar un puerto, cuya pata alimentar√° el LED.  Anteriormente, determinamos que los puertos <i>GPIO</i> est√°n conectados al bus <i>AHB</i> : debe conectar este bus.  Continuando con la secci√≥n <i>7.4 Registros RCC</i> ( <i>registros de</i> control de control y restablecimiento), encontramos la secci√≥n <i>7.4.6 Registro de habilitaci√≥n de reloj perif√©rico AHB</i> ( <b>RCC_AHBENR</b> , <i>registro de habilitaci√≥n de reloj de</i> bus <i>AHB</i> ).  Anteriormente, determin√© que mi LED est√° conectado a la pata <i>PA4</i> ; en consecuencia, necesito escribir una unidad en el bit 17 del registro para conectar el puerto <i>A.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Registro de habilitaci√≥n de reloj perif√©rico AHB</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/u7/s5/vs/u7s5vsoduvggexg9chpopozlzdw.png"><br></div></div><br>  En consecuencia, el c√≥digo debe ser <br><br><pre> <code class="plaintext hljs">RCC-&gt;AHBENR |= (1 &lt;&lt; 17);</code> </pre> <br>  o, que es lo mismo <br><br><pre> <code class="plaintext hljs">RCC-&gt;AHBENR |= 0x20000;</code> </pre> <br>  ya sea usando el archivo <i>#define</i> <i>stm32f0xx.h</i> write <br><br><pre> <code class="plaintext hljs">RCC-&gt;AHBENR |= RCC_AHBENR_GPIOAEN;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">RCC-&gt; AHBENR</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/19/ex/ke/19exkey4g-yyfkz4pmvrrgilnlk.png"><br></div></div><br>  Hemos alimentado el puerto <i>A</i> , ahora debemos informarle a MK que <i>PA4</i> funcionar√° en la <i>salida</i> : leeremos la secci√≥n <i>8 E / S de prop√≥sito general (GPIO)</i> ;  la introducci√≥n de la secci√≥n ya dice "Cada puerto de E / S de prop√≥sito general tiene cuatro registros de configuraci√≥n de 32 bits ( <b>GPIOx_MODER</b> , <b>GPIOx_OTYPER</b> , <b>GPIOx_OSPEEDR</b> y <b>GPIOx_PUPDR</b> ), dos registros de datos de 32 bits ( <b>GPIOx_IDR</b> y <b>GPIOx_ODR</b> ) ..." - <i>para cada GPIO Hay 4 registros de sintonizaci√≥n y 2 registros de datos en el puerto</i> : esto es lo que necesitamos (configurar el puerto <i>A</i> , o m√°s bien la salida <i>PA4</i> , y peri√≥dicamente enviarle <i>0</i> y <i>1</i> ).  Para una mejor comprensi√≥n (teor√≠a) de lo que est√° sucediendo, puede leer esta secci√≥n, pero me desplazo hacia la secci√≥n <i>8.4 Registros GPIO</i> y configuro el puerto de acuerdo con las descripciones. <br><br><ol><li>  <b>modo</b> puerto - salir.  De acuerdo con la documentaci√≥n, es necesario escribir <i>01</i> en el √°rea correspondiente ( <i>MODER4</i> ) del registro correspondiente ( <i>GPIOA_MODER</i> ), es decir  bits <i>9</i> y <i>8</i> : en el noveno bit debe ser cero, en la octava unidad: <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;MODER |= (1 &lt;&lt; 8); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;MODER |= 0x100; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;MODER |= GPIO_MODER_MODER4_0;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Registro de modo de puerto GPIO</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/tv/xf/vt/tvxfvtoiw91rguuz-rtmgcrk8fo.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">GPIOA-&gt; MODER</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/co/df/x5/codfx50xu4hopklififyeecpiqu.png"><br></div></div><br></li><li>  <b>tipo de</b> salida.  Honestamente, todav√≠a no he descubierto completamente los circuitos de este caso (lo entender√©, volver√© a leer los foros nuevamente, etc.), pero estudiar otros recursos sobre la configuraci√≥n de la salida MK, as√≠ como la l√≥gica y la intuici√≥n, sugiere que deber√≠a haber un <b>impulso -pull</b> y luego debe ser <i>pull-up</i> .  En cualquier caso, el c√≥digo est√° escrito, todo funciona y no se quema nada.  Existe un riesgo real de quemarse si selecciona el tipo de <b>drenaje abierto</b> y cortocircuita esta salida con otro dispositivo, como  Esta es una salida abierta y no est√° protegida por nada.  Adem√°s, tenemos una resistencia limitadora de corriente frente al diodo; ciertamente no arder√° aqu√≠. <br><br>  Siguiendo la documentaci√≥n, es necesario escribir cero en el cuarto bit;  la documentaci√≥n tambi√©n establece que despu√©s del reinicio habr√° cero. <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;OTYPER &amp;= ~(1 &lt;&lt; 4); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;OTYPER &amp;= ~0x10; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;OTYPER &amp;= ~GPIO_OTYPER_OT_4;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Registro de tipo de salida de puerto GPIO</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ii/3k/ch/ii3kcht4jvsbnd7yybouiilgmhk.png"><br></div></div><br></li><li>  <b>velocidad de</b> salida.  En nuestro caso, no importa, pero en aras de la fidelidad escribir√© aqu√≠ cero. <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;OSPEEDR &amp;= ~(1 &lt;&lt; 8); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;OSPEEDR &amp;= ~0x100; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;OSPEEDR &amp;= ~GPIO_OSPEEDER_OSPEEDR4_0;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Registro de velocidad de salida del puerto GPIO</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/47/xg/fr/47xgfrtfqdl5ai0eztsrqej1i1k.png"><br></div></div><br></li><li>  <b>Un ascensor</b> .  Porque  la salida alimentar√° el LED, debe subirlo a la potencia, es decir  <b>pull-up</b> <br><br>  Es necesario apretar el cuarto pin del puerto <i>A</i> ;  la documentaci√≥n dice que para esto es necesario escribir cero y uno en <i>9</i> y <i>8</i> bits, respectivamente. <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;PUPDR |= (1 &lt;&lt; 8); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;PUPDR |= 0x100; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;PUPDR |= GPIO_PUPDR_PUPDR4_0;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Registro desplegable / desplegable de puertos GPIO</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/pg/pa/zk/pgpazkwfltwme4jy0wwrhp9imqi.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">GPIOA-&gt; PUPDR</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/bo/ee/na/boeenaff6fxjiemjuiky9ukhb6w.png"><br></div></div><br></li></ol><br><h3>  3.3.3 LED encendido / apagado y retraso </h3><br>  Anteriormente le√≠mos que cada puerto tiene registros, incluidos los registros de datos <i><abbr title="Registro de datos de entrada">IDR</abbr></i> y <i><abbr title="Registro de datos de salida">ODR</abbr></i> , registros de datos de entrada y salida, respectivamente.  Ceros l√≥gicos y unos en el tramo MK: ¬øson estos datos?  - S√≠, datos.  Los datos pueden provenir del exterior del microcontrolador ( <i>entrada</i> ) y salir del microcontrolador e ir a otro dispositivo ( <i>salida</i> ).  La unidad en la pata MK es la presencia de un nivel de alto voltaje, es decir  Si lleva uno a la salida, habr√° voltaje, y este LED puede alimentar nuestro LED.  La salida de una unidad a la pata del microcontrolador es algo m√°s que escribir esta unidad en el registro de salida <i>ODR</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Registro de datos de salida del puerto GPIO</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/or/vw/el/orvwel6seyhwvx6pbxdcow6ufpm.png"><br></div></div><br>  De acuerdo con la documentaci√≥n, vemos que para cada puerto ( <i>A</i> , <i>B</i> , <i>C</i> , <i>D</i> , <i>F</i> ) hay un registro de 32 bits, sin embargo.  el puerto no puede tener m√°s de 16 pines, entonces solo se usan los primeros 16 bits del registro.  Cada bit corresponde a un n√∫mero de puerto (pin).  Para generar una unidad en el tramo <i>PA4</i> , es necesario escribir una unidad en el cuarto bit, para generar un cero: escriba un cero en el cuarto bit, es decir  eliminar el voltaje de la salida. <br><br><img src="https://habrastorage.org/webt/pr/0n/pr/pr0npr4jplwjahmcflj_nlksq5i.png" width="400" height="156"><br><br><div class="spoiler">  <b class="spoiler_title">GPIOA-&gt; ODR</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/hs/yy/v4/hsyyv4z5u2kf6fkqqe5wk9t6ti4.png"><br></div></div><br>  El c√≥digo para encender el LED se ver√° as√≠ <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR |= (1 &lt;&lt; 4); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR |= 0x10; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR |= GPIO_ODR_4;</code> </pre> <br>  C√≥digo para apagar el LED <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR &amp;= ~(1 &lt;&lt; 4); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR &amp;= ~0x10; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR &amp;= ~GPIO_ODR_4;</code> </pre> <br>  Pero si escribe la l√≠nea para apagar el LED despu√©s de la l√≠nea para encender, el LED no parpadear√° (si est√° interesado en lo que sucede, puede intentarlo; nada arder√°, esto ya se ha discutido anteriormente), entonces debe retrasarlo.  Los temporizadores se usan para retrasar, pero los temporizadores son dignos de un art√≠culo separado (debido a la complejidad), por lo que haremos un retraso de muleta: impulsaremos el ciclo inactivo.  Hay un punto: <b>si la optimizaci√≥n del compilador est√° habilitada</b> , el <b>compilador cortar√°</b> nuestro ciclo de inactividad y no habr√° demora.  Aseg√∫rese de que la optimizaci√≥n no est√© habilitada.  Para hacer esto, vayamos a la configuraci√≥n del proyecto (haga clic derecho en el nombre del proyecto en el √°rbol del proyecto) y verifique la l√≠nea <i>Compilar cadena de control</i> en la pesta√±a <i>Compilar</i> : debe tener el argumento <i>-O0</i> ("aproximadamente cero" significa que la optimizaci√≥n est√° desactivada).  Si recolect√≥ todo de acuerdo con mis instrucciones, lo m√°s probable es que tambi√©n tenga <i>-O0</i> , porque  fue por defecto y no toqu√© nada aqu√≠.  Los argumentos <i>-O1 -O2 -O3</i> significan que la optimizaci√≥n del nivel correspondiente est√° habilitada. <br><br><div class="spoiler">  <b class="spoiler_title">Comprobaci√≥n de optimizaci√≥n del compilador</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/vc/ps/pu/vcpspuz5xfupw1pa5n-e5at9_nm.png"><br></div></div><br>  Un ciclo inactivo se puede escribir as√≠: <br><br><pre> <code class="plaintext hljs">int t = 4000000; while(t &gt; 0) t--;</code> </pre><br>  No configur√© el valor de <i>t</i> como tal, razon√© as√≠: si el microcontrolador funciona a 8MHz, entonces ejecutar√° aproximadamente 8,000,000 de instrucciones en un segundo, si exageras profundamente, entonces por medio segundo de retraso necesitar√°s ejecutar el ciclo 4,000,000 de veces. <br>  El ciclo de inactividad deber√° ejecutarse despu√©s de encender el LED, y despu√©s de apagarlo, y todo esto junto. <br><br><h3>  3.4 Escribir c√≥digo y ejecutar </h3><br>  Vamos a juntar todas las l√≠neas de c√≥digo que escribimos antes.  Tambi√©n debe incluir el archivo de encabezado <i>stm32f0xx.h</i> , como  confiamos en √©l y tomamos de √©l definiciones de estructuras, direcciones y valores.  El resultado deber√≠a ser: <br><br><pre> <code class="plaintext hljs">#include "stm32f0xx.h" int main(void) { int t; //  '' RCC-&gt;CR |= 0x1; //   HSI RCC-&gt;AHBENR |= RCC_AHBENR_GPIOAEN; //   A GPIOA-&gt;MODER |= GPIO_MODER_MODER4_0; // PA4   GPIOA-&gt;OTYPER &amp;= ~GPIO_OTYPER_OT_4; //  push-pull  PA4 GPIOA-&gt;OSPEEDR &amp;= ~GPIO_OSPEEDER_OSPEEDR4_0; //    PA4 GPIOA-&gt;PUPDR |= GPIO_PUPDR_PUPDR4_0; //  pull-up  PA4 while(1) { GPIOA-&gt;ODR |= GPIO_ODR_4; //    PA4 t = 4000000; while(t &gt; 0) t--; //  GPIOA-&gt;ODR &amp;= ~GPIO_ODR_4; //    PA4 t = 4000000; while(t &gt; 0) t--; //  } }</code> </pre><br>  Haga clic en Reconstruir y complete el c√≥digo en el tablero a trav√©s de la utilidad. <br><br><img src="https://habrastorage.org/webt/fo/rr/1d/forr1d6ruw6sohn7eyomgs4yb_g.png"><br><br>  Para que la placa inicie un nuevo firmware, no olvide cerrar el puente BOOT y reiniciar (RESET). <br><br><h1>  4. Conclusi√≥n </h1><br>  El c√≥digo est√° escrito, todo funciona.  Fuerzas gastadas sin medida.  Me alegra que, en base a la documentaci√≥n, result√≥ escribir c√≥digo de trabajo, en gran parte debido al hecho de que STM tiene documentaci√≥n de alta calidad. <br><br>  Los planes son escribir un art√≠culo sobre c√≥mo ensamblar todo a mano, sin un IDE, a trav√©s de la consola, <i>verdadera vieja escuela</i> , idealmente para que todo esto se pueda hacer desde Linux.  Ahora estoy trabajando en PWM y ADC (tambi√©n en este foro). Tambi√©n escribir√© un art√≠culo sobre ellos. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437234/">https://habr.com/ru/post/437234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437224/index.html">Traducci√≥n de plantillas Dust a JSX</a></li>
<li><a href="../437226/index.html">Kelvin Point Shadow</a></li>
<li><a href="../437228/index.html">Bitcoin, como moneda, conducir√° a una crisis econ√≥mica.</a></li>
<li><a href="../437230/index.html">Una publicidad en l√≠nea tan diferente. Tres ejes vs. AI, Ad Tech y DOOH</a></li>
<li><a href="../437232/index.html">Psto bueno</a></li>
<li><a href="../437236/index.html">ESET: an√°lisis de nuevos componentes de Zebrocy</a></li>
<li><a href="../437238/index.html">Lanzamiento de Orange Pi 3: una mini PC completa de $ 30 en Linux</a></li>
<li><a href="../437240/index.html">C√≥mo integrar Zimbra Collaboration Suite con Active Directory</a></li>
<li><a href="../437242/index.html">Dominio del gerente de producto. Solicitudes de funciones</a></li>
<li><a href="../437244/index.html">Google ense√±a a los usuarios a reconocer correos electr√≥nicos de phishing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>