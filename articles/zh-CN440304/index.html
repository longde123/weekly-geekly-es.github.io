<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>➡️ 👀 👩🏻‍🎓 来自x86系统中的外部设备的中断。 第3部分。使用coreboot示例在芯片组中配置中断路由 ⬆️ 🧦 🤰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我们继续考虑在x86系统中配置来自外部设备的中断。 
 在第1部分（ 中断控制器的发展 ）中，我们研究了中断控制器的理论基础和通用术语；在第2部分（ Linux内核启动选项 ）中，我们研究了操作系统在实践中如何在控制器之间做出选择。 在这一部分中，我们将研究BIOS如何为芯片组中的中断控制器配置IR...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>来自x86系统中的外部设备的中断。 第3部分。使用coreboot示例在芯片组中配置中断路由</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440304/">我们继续考虑在x86系统中配置来自外部设备的中断。 <br> 在第1部分（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">中断控制器的发展</a> ）中，我们研究了中断控制器的理论基础和通用术语；在第2部分（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Linux内核启动选项</a> ）中，我们研究了操作系统在实践中如何在控制器之间做出选择。 在这一部分中，我们将研究BIOS如何为芯片组中的中断控制器配置IRQ路由。 <br><br> 没有现代的BIOS开发公司（AwardBIOS / AMIBIOS / Insyde）公开其程序的源代码。 但幸运的是，有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Coreboot</a> ，一个用免费软件替换专有BIOS的项目。 在他的代码中，我们将看到如何配置芯片组中的中断路由。 <br><br><img src="https://habrastorage.org/webt/mx/vi/wu/mxviwuisp5rglec_kgsk872hmy8.png"><br><br><a name="habracut"></a><br><h2> 理论 </h2><br> 首先，刷新并补充我们的理论知识。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1部分中，</a>我们为PIC和APIC的情况确定了一条通用的中断路径。 <br><br>  <b>图片：</b> <br><br><img src="https://habrastorage.org/webt/u_/jr/u9/u_jru9pemdeda2xvvbqihvgtp3y.png"><br><br>  <b>APIC：</b> <br><br><img src="https://habrastorage.org/webt/mc/ra/hj/mcrahjn-owk9qrcmyiixcmhomcq.png"><br><br> 在这些图中，抽象地显示了PCI设备→PIR映射；实际上，它有些复杂。 实际上，每个PCI设备都有4条中断线（INTA＃，INTB＃，INTC＃，INTD＃）。 每个PCI设备最多可以具有8个功能，并且每个功能已经具有一个INTx＃中断。 设备的每个功能将拉入INTx＃的哪一行是固定在硬件中，还是由设备的配置决定。 <br><br><img src="https://habrastorage.org/webt/dk/ny/gh/dknyghwfo8gktn5l_lmmqb5awz0.png"><br><br> 本质上，功能是单独的逻辑块。 例如，在一个PCI设备中，可能具有Smbus控制器功能，SATA控制器功能，LPC桥功能。 在操作系统方面，每个功能都是具有自己的PCI Config配置空间的单独设备。 <br><br> 在PCI设备中最简单（也是最常见）的情况下，只有一个功能，该中断通过INTA＃线进行。 但是一般来说，该设备甚至可能具有4个以上的功能（如我们之前在8个功能中所述），然后其中一些功能必须植入到一条INTx＃线路上（PCI中断可以划分该线路）。 同样，对于芯片组中包含的PCI设备，通过写入特殊寄存器，通常可以指示哪些功能使用哪些INTx＃行（以及是否完全使用它们）。 <br><br> 系统化我们的知识，我们表示通过INTx＃→PIRQy→IRQz从任何PCI功能中断的路径（路由），其中： <br><br><ul><li>  INTx＃-该功能将使用的PCI设备的INT＃行（INTA＃，INTB＃，INTC＃，INTD＃） </li><li>  PIRQy-连接INTx＃线的PIR的PIRQ线（PIRQA，PIRQB等） </li><li>  IRQz-中断控制器（APIC / PIC）上的IRQ线（0、1、2 ...），它连接到PIRQy线 </li></ul><br><h3> 为什么不能仅在INTA＃→PIRQA，INTB＃→PIRQB等地方连接？ </h3><br> 为什么要费心设置路由呢？ 假设我们决定不打扰，并将所有PCI设备的所有中断线传送到同一PIRQ线。 这么说吧： <br><br><ul><li>  INTA号→PIRQA </li><li>  INTB编号→PIRQB </li><li> 国际标准编号→PIRQC </li><li>  INTD＃→PIRQD </li></ul><br> 如上所述，最常见的情况是PCI设备具有一种功能，并且其中断连接到INTA＃线路（因为为什么设备开发人员应该以不同的方式启动它？）。 因此，如果我们突然决定像我们写的那样开始所有线路，那么来自设备的几乎所有中断都将被划分为PIRQA线路。 假设她在IRQ16结束比赛。 然后，每当处理器被告知IRQ16线上发生了中断时，它都必须询问连接到IRQ16线（PIRQA）的所有设备的驱动程序是否有中断。 如果有很多这样的设备，这自然不会加速系统对中断的响应。 在这种情况下，PIRQB-PIRQD线路将大部分处于空闲状态。 为了清楚起见，该图说明了该问题： <br><br><img src="https://habrastorage.org/webt/cz/dv/bf/czdvbfsnymw5xyyqujavawdcv_m.png"><br><br> 但是一切都可以像这样完成： <br><br><img src="https://habrastorage.org/webt/dk/3e/x6/dk3ex67xjmm_9h0q3miq2djqnti.png"><br><br> 图片有点令人困惑，但关键是我们仅将INTx＃线与PIRQy连接到循环（PIRQA，PIRQB，PIRQC，PIRQD，PIRQA，PIRQB，PIRQC，PIRQD，PIRQA，PIRQB，PIRQC，PIRQD等）。 ..） <br><br> 应该注意的是，这里不仅要考虑到在每条PIRQ线上都装载了相同数量的PCI功能。 毕竟，有些功能很少会产生中断，而有些则是永久性的（例如，以太网控制器）。 在这种情况下，即使为具有这种功能的中断分配单独的PIRQ线路也可以证明是合理的。 <br><br> 基于上述内容，BIOS开发人员除其他任务外，还要确保PIRQ线路均匀加载中断。 <br><br><h3>  BIOS到底应该做什么？ </h3><br> 我们在图中进行系统化： <br><br><img src="https://habrastorage.org/webt/pm/rq/xg/pmrqxgkdu0nkjz6yb44vdn79a8q.png"><br><br><ul><li>  <b>1）指出PCI设备的每个功能都拉到INTx＃的哪一行</b> <br> 对于外部PCI设备，不执行此项目，但是对于芯片组中包含的PCI设备的功能，则可能是正确的。 </li><li>  <b>2）为每个PCI设备配置INTx＃→PIRQy映射</b> <br> 值得注意的是，可以有四个以上的标准PIRQy信号（PIRQA，PIRQB，PIRQC，PIRQD）。 例如8：PIRQA-PIRQH。 </li></ul><br>  PIRQy信号在所选中断控制器（APIC / PIC）的IRQz线上传输。 由于我们希望支持所有可能的加载方法（请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2部分</a> ），因此我们需要填写两个映射： <br><br><ul><li>  <b>3a）填写映射PIRQy→IRQz1进行通信PIR→I / O APIC</b> <br> 但是通常这不是必需的，因为PIRQy线路固定在APIC线路上。 常见的解决方案是PIRQA→IRQ16，PIRQB→IRQ17，...最简单的解决方案，因为 通过将PIRQy线路放置在≥16的控制器线路上，您不必担心与ISA设备不可分割的中断发生冲突。 </li><li>  <b>3b）填写映射PIRQy→IRQz2进行通信PIR→PIC</b> <br> 如果我们使用通过PIC控制器的路由，则必须提供此信息。 没有像APIC这样的明确解决方案，因为对于PIC，应该意识到与ISA设备不可分割的中断发生冲突的可能性。 </li></ul><br> 最后第四项是帮助OS确定中断路由所必需的。 设备本身通常不使用这些寄存器。 <br><br><ul><li>  <b>4）填写每个PCI功能的中断线/中断引脚寄存器</b> <br> 通常，中断引脚寄存器是自动填充的，并且通常是只读的，因此填充很可能只需要填写中断线寄存器即可。 如果我们使用通过PIC控制器的路由而没有为操作系统提供任何有关路由中断的表，则必须提供这一点（再次参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2部分</a> ）。 如果提供了表，并且此映射与路由表（$ PIR / ACPI）一致，则操作系统通常会将其保留。 </li></ul><br> 应该注意的是，我们尚未触及$ PIR / MPtable / ACPI表，并在将控制权转移给系统加载程序之前考虑如何根据路由中断配置芯片组寄存器。 中断表是另一篇文章的主题（可能是将来的主题）。 <br><br> 因此，研究了理论基础，最后我们开始实践！ <br><br><h2> 练习 </h2><br> 作为本系列文章的示例，我使用一个定制板，该板带有Intel Haswell i7处理器和LynxPoint-LP芯片组。 在此板上，我与SeaBIOS一起启动了coreboot。  Coreboot提供了特定于硬件的初始化，而SeaBIOS有效负载提供了用于操作系统的BIOS接口。 在本文中，我将不介绍配置coreboot的过程，而只是尝试通过示例说明应在芯片组中进行哪种BIOS设置以路由来自外部设备的IRQ中断。 <br><br> 由于coreboot项目正在积极开发中，因此本文始终是最新的，因此我们将使用最新的固定版本<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.9</a> （2018年12月20日发行）的示例来考虑代码。 <br><br> 最接近我的主板是带有Panther版本的Google Beltino。 该主板的主文件夹为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ src \ mainboard \ google \ Beltino”</a>文件夹。 所有设置都集中在此处，以及该板专用的代码。 <br><br> 因此，让我们开始整理配置以上各项的位置： <br><br><h4>  1）指出PCI设备的每个功能都拉到INTx＃的哪一行 </h4><br> 此信息通过DxxIP寄存器（设备xx中断引脚寄存器（IP））在rcba_config结构的<a href="">“ src / mainboard / google / beltino / romstage.c”</a>文件中定义。 该寄存器指示每个器件功能的哪个引脚INTx＃（A / B / C / D）输出中断。 <br><br> 可能的选项（请参见文件<a href="">“ src / southbridge / intel / lynxpoint / pch.h”</a> ）： <br><br><pre><code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0</span></span>h = No interrupt <span class="hljs-number"><span class="hljs-number">1</span></span>h = INTA# <span class="hljs-number"><span class="hljs-number">2</span></span>h = INTB# <span class="hljs-number"><span class="hljs-number">3</span></span>h = INTC# <span class="hljs-number"><span class="hljs-number">4</span></span>h = INTD#</code> </pre> <br> 假设多个功能使用相同的引脚。 <br><br> 假定功能可能不会将该引脚用于中断（无中断）。 <br> 正如我们在本文开头所看到的一样。 <br><br> 完整代码负责我们指定的商品： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Device interrupt pin register (board specific) */</span></span> RCBA_SET_REG_32(D31IP, (INTC &lt;&lt; D31IP_TTIP) | (NOINT &lt;&lt; D31IP_SIP2) | (INTB &lt;&lt; D31IP_SMIP) | (INTA &lt;&lt; D31IP_SIP)), RCBA_SET_REG_32(D29IP, (INTA &lt;&lt; D29IP_E1P)), RCBA_SET_REG_32(D28IP, (INTA &lt;&lt; D28IP_P1IP) | (INTC &lt;&lt; D28IP_P3IP) | (INTB &lt;&lt; D28IP_P4IP)), RCBA_SET_REG_32(D27IP, (INTA &lt;&lt; D27IP_ZIP)), RCBA_SET_REG_32(D26IP, (INTA &lt;&lt; D26IP_E2P)), RCBA_SET_REG_32(D22IP, (NOINT &lt;&lt; D22IP_MEI1IP)), RCBA_SET_REG_32(D20IP, (INTA &lt;&lt; D20IP_XHCI)),</code> </pre> <br> 为了更好地理解，请考虑以下示例： <br><br>  <b>范例1：</b> <br><br> 设备0x1d（十进制29）具有一项功能（EHCI控制器）。 <br><br> 在这种情况下，请将中断分配给INTA＃。 <br><br>  00：1d.0-INTA＃ <br><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D29IP, (INTA &lt;&lt; D29IP_E1P)),</code> </pre> <br>  <b>范例2：</b> <br> 设备0x1f（十进制31）具有热传感器控制器（00：1f.6），SATA控制器2（00：1f.2），SMBus控制器（00：1f.3），SATA控制器1（00：1f） .2）。 我们只想使用SMBus控制器，SATA控制器1和热传感器控制器。 <br><br>  00：1f.2-INTA＃（SATA控制器1） <br>  00：1f.3-INTB＃（SMBus控制器） <br>  00：1f.2-无中断（未使用SATA控制器2） <br>  00：1f.6-INTC＃（热传感器控制器） <br><br> 对于此配置，您应该编写： <br><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D31IP, (INTC &lt;&lt; D31IP_TTIP) | (NOINT &lt;&lt; D31IP_SIP2) | (INTB &lt;&lt; D31IP_SMIP) | (INTA &lt;&lt; D31IP_SIP)),</code> </pre> <br>  <b>范例3：</b> <br><br> 在一个设备中，我们需要的功能数量超过4个。在0x1c设备中，每个功能都负责PCI Express端口。 为了使端口0-5正常工作，并使中断在各行之间平均分配，您可以配置以下命令： <br><br>  00：1c.0-INTA＃（PCI Express端口0） <br>  00.1c.1-INTB＃（PCI Express端口1） <br>  00.1c.2-INTC＃（PCI Express端口2） <br>  00.1c.3-INTD＃（PCI Express端口3） <br>  00.1c.4-INTA＃（PCI Express端口4） <br>  00.1c.5-INTB＃（PCI Express端口5） <br>  00.1c.6-无中断（未使用端口） <br>  00.1c.7-无中断（未使用端口） <br><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D28IP, (INTA &lt;&lt; D28IP_P1IP) | (INTB &lt;&lt; D28IP_P2IP) | (INTC &lt;&lt; D28IP_P3IP) | (INTD &lt;&lt; D28IP_P4IP) | (INTA &lt;&lt; D28IP_P5IP) | (INTB &lt;&lt; D28IP_P6IP) | (NOINT &lt;&lt; D28IP_P7IP) | (NOINT &lt;&lt; D28IP_P8IP)),</code> </pre> <br><h4>  2）为每个PCI设备配置INTx＃→PIRQy映射 </h4><br> 此信息也在文件<a href="">“ src \ mainboard \ google \ Beltino \ romstage.c”中定义</a> <br> 在rcba_config结构中，但已经通过DxxIR（设备xx中断路由寄存器）寄存器。 <br><br> 该寄存器中的信息显示每条INTx＃中断线连接到哪条PIRQx线（A / B / C / D / E / F / G / H）。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Device interrupt route registers */</span></span> RCBA_SET_REG_32(D31IR, DIR_ROUTE(PIRQG, PIRQC, PIRQB, PIRQA)),<span class="hljs-comment"><span class="hljs-comment">/* LPC */</span></span> RCBA_SET_REG_32(D29IR, DIR_ROUTE(PIRQD, PIRQD, PIRQD, PIRQD)),<span class="hljs-comment"><span class="hljs-comment">/* EHCI */</span></span> RCBA_SET_REG_32(D28IR, DIR_ROUTE(PIRQA, PIRQB, PIRQC, PIRQD)),<span class="hljs-comment"><span class="hljs-comment">/* PCIE */</span></span> RCBA_SET_REG_32(D27IR, DIR_ROUTE(PIRQG, PIRQG, PIRQG, PIRQG)),<span class="hljs-comment"><span class="hljs-comment">/* HDA */</span></span> RCBA_SET_REG_32(D22IR, DIR_ROUTE(PIRQA, PIRQA, PIRQA, PIRQA)),<span class="hljs-comment"><span class="hljs-comment">/* ME */</span></span> RCBA_SET_REG_32(D21IR, DIR_ROUTE(PIRQE, PIRQF, PIRQF, PIRQF)),<span class="hljs-comment"><span class="hljs-comment">/* SIO */</span></span> RCBA_SET_REG_32(D20IR, DIR_ROUTE(PIRQC, PIRQC, PIRQC, PIRQC)),<span class="hljs-comment"><span class="hljs-comment">/* XHCI */</span></span> RCBA_SET_REG_32(D23IR, DIR_ROUTE(PIRQH, PIRQH, PIRQH, PIRQH)),<span class="hljs-comment"><span class="hljs-comment">/* SDIO */</span></span></code> </pre> <br>  <b>范例1：</b> <br><br> 正如我们已经发现的，0x1c设备（十进制中的28个）是PCIe端口。 <br><br> 我们建立“直接”连接： <br><br><ul><li>  INTA号→PIRQA </li><li>  INTB编号→PIRQB </li><li> 国际标准编号→PIRQC </li><li>  INTD＃→PIRQD </li></ul><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D28IR, DIR_ROUTE(PIRQA, PIRQB, PIRQC, PIRQD))</code> </pre> <br>  <b>范例2：</b> <br><br> 设备0x1d（十进制29）-INTA＃上的一个功能（EHCI控制器），未使用其他行。 <br><br> 将INTA＃线连接到PIRQD： <br><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D29IR, DIR_ROUTE(PIRQD, PIRQD, PIRQD, PIRQD))</code> </pre> <br> 在这种情况下，只有第一个PIRQD记录（对于INTA＃）才有意义，其余的则没有意义。 <br><br><h4>  3a）填写映射PIRQy→IRQz1（PIR→APIC） </h4><br> 正如我们已经说过的，映射通常在这里是固定的，这种情况也不例外。 <br><br><ul><li>  PIRQA→IRQ16 </li><li>  PIRQB→IRQ17 </li><li>  ... </li><li>  PIRQH→IRQ23 </li></ul><br><h4>  3b）填写映射PIRQy→IRQz2（PIR→PIC） </h4><br> 在coreboot中，用于填充这些寄存器的内容在主板文件夹“ src \ mainboard \ google \ Beltino \”中的<a href="">devicetree.cb</a>文件中定义。 <br><br>  devicetree.cb（用于在Linux内核中以类似概念进行通信的名称devicetree，“ cb”是coreboot的缩写）是一个特殊文件，反映了该主板的配置：使用了哪个处理器，芯片组，其中包括哪些设备，关闭等 此外，可以在此文件中指定芯片组配置的特殊信息。 这只是我们需要的情况： <br><br><pre> <code class="python hljs">register <span class="hljs-string"><span class="hljs-string">"pirqa_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x8b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqb_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x8a"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqc_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x8b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqd_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x8b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqe_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqf_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqg_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqh_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span></code> </pre> <br> 这些行指定映射PIRQy→IRQz2。 在代码中，在解析devicetree.cb文件之后，它们被转换为“ config-&gt; pirqX_routing”变量。 <br><br> 变量“ config-&gt; pirqa_routing = 0x8b”将意味着PIRQA连接到PIC控制器的IRIC11中断线（0x0b = 11），但是，较高的位（即0x80）表示不执行中断路由。 老实说，以我的经验，这是一个错误，默认情况下，值得打开PIC路由，如果必要，将该位设置为1，操作系统本身将能够切换到I / O APIC。 <br><br> 也就是说，在这种情况下，编写以下内容会更正确： <br><br><pre> <code class="python hljs">register <span class="hljs-string"><span class="hljs-string">"pirqa_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqb_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0a"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqc_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqd_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqe_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span> <span class="hljs-comment"><span class="hljs-comment"># not used register "pirqf_routing" = "0x80" # not used register "pirqg_routing" = "0x80" # not used register "pirqh_routing" = "0x80" # not used</span></span></code> </pre><br> 我们没有启用最后4个中断，因为  IRQ0中断始终在系统计时器下使用，并且显然不可用（请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">常规IBM-PC兼容中断信息</a> ）。 <br><br> 但是，如果我们仔细观察第2点，我们会发现某些PCI设备使用PIRQE-PIRQH线路，因此断开它们的连接是断开设备的正确方法。 <br><br> 所以最好这样写： <br><pre> <code class="python hljs">register <span class="hljs-string"><span class="hljs-string">"pirqa_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x03"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqb_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x04"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqc_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x05"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqd_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x06"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqe_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0a"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqf_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqg_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0e"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqh_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0f"</span></span></code> </pre> <br><br> 相应寄存器的实际填充发生在函数pch_pirq_init中的文件<a href="">src \ southbridge \ intel \ lynxpoint \ lpc.c</a>中。 <br><br> 负责寄存器填充的代码段： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Get the chip configuration */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">config_t</span></span> *config = dev-&gt;chip_info; pci_write_config8(dev, PIRQA_ROUT, config-&gt;pirqa_routing); pci_write_config8(dev, PIRQB_ROUT, config-&gt;pirqb_routing); pci_write_config8(dev, PIRQC_ROUT, config-&gt;pirqc_routing); pci_write_config8(dev, PIRQD_ROUT, config-&gt;pirqd_routing); pci_write_config8(dev, PIRQE_ROUT, config-&gt;pirqe_routing); pci_write_config8(dev, PIRQF_ROUT, config-&gt;pirqf_routing); pci_write_config8(dev, PIRQG_ROUT, config-&gt;pirqg_routing); pci_write_config8(dev, PIRQH_ROUT, config-&gt;pirqh_routing);</code> </pre> <br> 寄存器地址常量在同一<a href="">pch.h</a>文件中描述 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQA_ROUT 0x60 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQB_ROUT 0x61 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQC_ROUT 0x62 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQD_ROUT 0x63 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQE_ROUT 0x68 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQF_ROUT 0x69 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQG_ROUT 0x6A #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQH_ROUT 0x6B</span></span></code> </pre> <br> 将此芯片组的映射PIRQy→IRQz2写入PIRQy_ROUT寄存器中的LPC PCI设备（地址00：1f.0）。 应该注意的是，通常不允许每个PIC使用全部15条IRQz2线路，而只允许使用一部分（例如3、4、5、6、7、9、10、11、12、14、15）。 这些寄存器的描述应包含有关哪些IRQ可用于将PIRQ线中的中断分配给它们的信息。 因此，仅当在线IRQ3，IRQ4，IRQ5，IRQ6，IRQ10，IRQ11，IRQ14，IRQ15上的PIRQ分配可用时，我们上面提出的映射才有可能。 但是，如果我们仔细查看pch_pirq_init函数之前的注释，我们将看到它是： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* PIRQ[n]_ROUT[3:0] - PIRQ Routing Control * 0x00 - 0000 = Reserved * 0x01 - 0001 = Reserved * 0x02 - 0010 = Reserved * 0x03 - 0011 = IRQ3 * 0x04 - 0100 = IRQ4 * 0x05 - 0101 = IRQ5 * 0x06 - 0110 = IRQ6 * 0x07 - 0111 = IRQ7 * 0x08 - 1000 = Reserved * 0x09 - 1001 = IRQ9 * 0x0A - 1010 = IRQ10 * 0x0B - 1011 = IRQ11 * 0x0C - 1100 = IRQ12 * 0x0D - 1101 = Reserved * 0x0E - 1110 = IRQ14 * 0x0F - 1111 = IRQ15 * PIRQ[n]_ROUT[7] - PIRQ Routing Control * 0x80 - The PIRQ is not routed. */</span></span></code> </pre> <br><h4>  4）填写每个PCI功能的中断线/中断引脚寄存器 </h4><br> 在PCI配置空间（每个PCI均具有符合标准的功能），我们有2个感兴趣的寄存器： <br><br><ul><li>  3Ch：中断线-您需要在其中写入IRQz2号（0到15之间的数字），该中断号是使用PIC控制器时函数最终提取的中断号 </li><li>  3Dh：中断引脚-显示功能使用哪一行INTx＃（A / B / C / D） </li></ul><br> 让我们从最后一个开始。 中断引脚寄存器将根据我们在第1段中所做的芯片组设置（DxxIP寄存器）自动填充，并且为只读。 <br><br> 因此，剩下的就是为每个PCI功能的IRQz2中断填充中断线寄存器。 <br><br> 了解映射PIRQy→IRQz2（项目3b）以及映射INTx＃→PIRQy（项目2）后，您可以轻松地为每个函数填写中断线寄存器，知道它使用哪个INTx＃中断（项目1）。 <br><br> 在coreboot中，中断行寄存器也填充在pch_pirq_init函数的<a href="">src \ southbridge \ intel \ lynxpoint \ lpc.c文件</a>中： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Eric Biederman once said we should let the OS do this. * I am not so sure anymore he was right. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (irq_dev = all_devices; irq_dev; irq_dev = irq_dev-&gt;next) { u8 int_pin=<span class="hljs-number"><span class="hljs-number">0</span></span>, int_line=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!irq_dev-&gt;enabled || irq_dev-&gt;path.type != DEVICE_PATH_PCI) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; int_pin = pci_read_config8(irq_dev, PCI_INTERRUPT_PIN); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (int_pin) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* INTA# */</span></span> int_line = config-&gt;pirqa_routing; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* INTB# */</span></span> int_line = config-&gt;pirqb_routing; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* INTC# */</span></span> int_line = config-&gt;pirqc_routing; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* INTD# */</span></span> int_line = config-&gt;pirqd_routing; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!int_line) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; pci_write_config8(irq_dev, PCI_INTERRUPT_LINE, int_line); }</code> </pre> <br> 出于某种原因，此代码暗示在任何情况下映射都是INTA＃→PIRQA，INTB＃→PIRQB，INTC＃→PIRQC，INTD＃→PIRQD。 尽管实际上我们发现它可能有所不同（请参见第2段）。 <br><br> 通常，“ Eric Biederman曾经说过”，我们将其复制到任何地方： <br><br><pre> <code class="bash hljs">$ grep <span class="hljs-string"><span class="hljs-string">"Eric Biederman once said"</span></span> -r src/ src/southbridge/intel/fsp_bd82x6x/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this. src/southbridge/intel/i82801gx/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this. src/southbridge/intel/i82801ix/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this. src/southbridge/intel/lynxpoint/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this. src/southbridge/intel/sch/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this.</code> </pre> <br> 通常，coreboot并不真正在乎旧版中断支持。 对此错误感到惊讶不值得。 加载现代操作系统时，这不会打扰您，但是如果您突然需要使用“ acpi = off nolapic”选项加载Linux，则几乎无法做到这一点。 <br><br><h2> 结论 </h2><br> 总之，我们将重复芯片组中用于路由PCI中断所需的典型信息： <br><br><ol><li> 指示每个PCI功能拉哪条INTx＃行 </li><li> 为每个PCI设备配置INTx＃→PIRQy映射 </li><li> 填充映射PIRQy→IRQz1（PIR→APIC）和映射PIRQy→IRQz2（PIR→PIC） </li><li> 填写每个PCI功能的PCI配置空间的中断线/中断引脚寄存器。 </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN440304/">https://habr.com/ru/post/zh-CN440304/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN440294/index.html">Raspberry Pi上的MIDI路由器</a></li>
<li><a href="../zh-CN440296/index.html">6工业物联网的应用</a></li>
<li><a href="../zh-CN440298/index.html">Libgdx上的情人节申请</a></li>
<li><a href="../zh-CN440300/index.html">10个控制台命令可帮助像PRO一样辩论JavaScript代码</a></li>
<li><a href="../zh-CN440302/index.html">CRM-成功成本，错误成本，拥有成本</a></li>
<li><a href="../zh-CN440306/index.html">高负载系统中的数据库扩展</a></li>
<li><a href="../zh-CN440308/index.html">分而治之，或慢慢写-快速阅读</a></li>
<li><a href="../zh-CN440310/index.html">如何教机器理解发票并从中提取数据</a></li>
<li><a href="../zh-CN440312/index.html">Hackquest2018。结果与写作。 第4-7天</a></li>
<li><a href="../zh-CN440314/index.html">JDK 12发行候选：Shenandoah，G1，JMH，Arm64。 Swing中的错误会反击</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>