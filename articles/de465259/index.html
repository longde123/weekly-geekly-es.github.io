<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí¨ üÜó üíáüèª ValueTask <TResult> - warum, warum und wie? üë©üèº‚Äçüîß ‚úçüèº üìµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vorwort zur √úbersetzung 


 Im Gegensatz zu wissenschaftlichen Artikeln ist es schwierig, Artikel dieser Art "nahe am Text" zu √ºbersetzen, und es muss...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ValueTask <TResult> - warum, warum und wie?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/465259/"><h3 id="predislovie-k-perevodu">  <em>Vorwort zur √úbersetzung</em> </h3><br><p>  <em>Im Gegensatz zu wissenschaftlichen Artikeln ist es schwierig, Artikel dieser Art "nahe am Text" zu √ºbersetzen, und es muss eine ziemlich starke Anpassung vorgenommen werden.</em>  <em>Aus diesem Grund entschuldige ich mich f√ºr einige Freiheiten meinerseits beim Umgang mit dem Text des Originalartikels.</em>  <em>Ich leite nur ein Ziel: die √úbersetzung verst√§ndlich zu machen, auch wenn sie stellenweise stark vom Originalartikel abweicht.</em>  <em>Ich w√§re dankbar f√ºr konstruktive Kritik und Korrekturen / Erg√§nzungen der √úbersetzung.</em> </p><br><h2 id="vvedenie">  Einf√ºhrung </h2><br><p> Der <code>System.Threading.Tasks</code> Namespace und die <code>Task</code> Klasse wurden erstmals in .NET Framework 4 eingef√ºhrt. Seitdem sind dieser Typ und seine abgeleitete Klasse <code>Task&lt;TResult&gt;</code> fest in der Programmierpraxis in .NET <code>Task&lt;TResult&gt;</code> und zu Schl√ºsselaspekten des asynchronen Modells geworden. implementiert in C # 5 mit seiner <code>async/await</code> .  In diesem Artikel werde ich auf die neuen Typen von <code>ValueTask/ValueTask&lt;TResult&gt;</code> , die eingef√ºhrt wurden, um die Leistung von asynchronem Code zu verbessern, wenn der Speicheraufwand eine Schl√ºsselrolle spielt. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/f4/7b/3c/f47b3cblzfyn77xgh1odpwfgy5i.jpeg"></a> </p><a name="habracut"></a><br><h2 id="task">  Aufgabe </h2><br><p>  <code>Task</code> dient mehreren Zwecken, aber der Hauptzweck ist "Versprechen" - ein Objekt, das die F√§higkeit darstellt, auf den Abschluss einer Operation zu warten.  Sie starten den Vorgang und erhalten <code>Task</code> .  Diese <code>Task</code> wird abgeschlossen, wenn der Vorgang selbst abgeschlossen ist.  In diesem Fall gibt es drei M√∂glichkeiten: </p><br><ol><li>  Der Vorgang wird synchron im Initiator-Thread abgeschlossen.  <em>Zum Beispiel beim Zugriff auf Daten, die sich bereits im Puffer befinden</em> . </li><li>  Die Operation wird asynchron ausgef√ºhrt, kann jedoch abgeschlossen <em>werden, wenn der</em> Initiator die <code>Task</code> empf√§ngt.  <em>Zum Beispiel, wenn Sie schnell auf Daten zugreifen, die noch nicht gepuffert wurden</em> </li><li>  Die Operation wird asynchron ausgef√ºhrt und endet, <em>nachdem der</em> Initiator die <code>Task</code> empfangen hat <code>Task</code> <em>Ein Beispiel ist der Empfang von Daten √ºber ein Netzwerk</em> . </li></ol><br><p>  Um das Ergebnis eines asynchronen Aufrufs zu erhalten, kann der Client entweder den aufrufenden Thread blockieren, w√§hrend er auf den Abschluss wartet, was h√§ufig der Idee der Asynchronit√§t widerspricht, oder eine R√ºckrufmethode bereitstellen, die nach Abschluss des asynchronen Vorgangs ausgef√ºhrt wird.  Das R√ºckrufmodell in .NET 4 wurde explizit unter Verwendung der <code>ContinueWith</code> Methode eines Objekts der <code>Task</code> Klasse dargestellt, das einen Delegaten erhielt, der nach Abschluss der asynchronen Operation aufgerufen wurde. </p><br><pre> <code class="plaintext hljs">SomeOperationAsync().ContinueWith(task =&gt; { try { TResult result = task.Result; UseResult(result); } catch (Exception e) { HandleException(e); } });</code> </pre> <br><p>  Mit .NET Frmaework 4.5 und C # 5 wurde das Abrufen des Ergebnisses einer asynchronen Operation vereinfacht, indem die Schl√ºsselw√∂rter <code>async/await</code> und der dahinter stehende Mechanismus eingef√ºhrt wurden.  Dieser Mechanismus, der generierte Code, kann alle oben genannten F√§lle optimieren und die Fertigstellung trotz des Pfades, auf dem sie erreicht wurde, korrekt handhaben. </p><br><pre> <code class="plaintext hljs">TResult result = await SomeOperationAsync(); UseResult(result);</code> </pre> <br><p>  Die <code>Task</code> Klasse ist sehr flexibel und bietet mehrere Vorteile.  Beispielsweise k√∂nnen Sie ein Objekt dieser Klasse mehrmals "erwarten". Sie k√∂nnen das Ergebnis von einer beliebigen Anzahl von Verbrauchern wettbewerbsf√§hig erwarten.  Instanzen einer Klasse k√∂nnen f√ºr eine beliebige Anzahl nachfolgender Aufrufe in einem W√∂rterbuch gespeichert werden, mit dem Ziel, in Zukunft zu "warten".  In den beschriebenen Szenarien k√∂nnen Sie <code>Task</code> Objekte als eine Art Cache mit Ergebnissen betrachten, die asynchron erhalten werden.  Dar√ºber hinaus bietet <code>Task</code> die M√∂glichkeit, den wartenden Thread zu blockieren, bis der Vorgang abgeschlossen ist, wenn das Skript dies erfordert.  Es gibt auch die sogenannten.  Kombinatoren f√ºr verschiedene Strategien zum Warten auf den Abschluss von Aufgabens√§tzen, z. B. "Task.WhenAny" - asynchrones Warten auf den Abschluss der ersten von vielen Aufgaben. </p><br><p>  Der h√§ufigste Anwendungsfall besteht jedoch darin, einfach eine asynchrone Operation zu starten und dann auf das Ergebnis ihrer Ausf√ºhrung zu warten.  Solch ein einfacher Fall, der durchaus √ºblich ist, erfordert nicht die oben genannte Flexibilit√§t: </p><br><pre> <code class="plaintext hljs">TResult result = await SomeOperationAsync(); UseResult(result);</code> </pre> <br><p>  Dies ist sehr √§hnlich zu dem, wie wir synchronen Code schreiben (z. B. <code>TResult result = SomeOperation();</code> ).  Diese Option wird nat√ºrlich in <code>async/await</code> . </p><br><p>  Dar√ºber hinaus weist der <code>Task</code> trotz aller Vorz√ºge einen potenziellen Fehler auf.  <code>Task</code> ist eine Klasse. Dies bedeutet, dass jede Operation, die eine Instanz einer Task erstellt, ein Objekt auf dem Heap zuweist.  Je mehr Objekte wir erstellen, desto mehr Arbeit wird vom GC ben√∂tigt und desto mehr Ressourcen werden f√ºr die Arbeit des Garbage Collector aufgewendet, Ressourcen, die f√ºr andere Zwecke verwendet werden k√∂nnten.  Dies wird zu einem klaren Problem f√ºr den Code, in dem einerseits h√§ufig Taskinstanzen erstellt werden und andererseits die Anforderungen an Durchsatz und Leistung erh√∂ht werden. </p><br><p>  Die Laufzeit- und Hauptbibliotheken k√∂nnen diesen Effekt in vielen Situationen abschw√§chen.  Wenn Sie beispielsweise eine Methode wie die folgende schreiben: </p><br><pre> <code class="plaintext hljs">public async Task WriteAsync(byte value) { if (_bufferedCount == _buffer.Length) { await FlushAsync(); } _buffer[_bufferedCount++] = value; }</code> </pre> <br><p>  und meistens ist gen√ºgend Speicherplatz im Puffer vorhanden, die Operation wird synchron beendet.  Wenn ja, dann hat die zur√ºckgegebene Aufgabe nichts Besonderes, es gibt keinen R√ºckgabewert und der Vorgang ist bereits abgeschlossen.  Mit anderen Worten, wir haben es mit <code>Task</code> tun, dem √Ñquivalent einer synchronen <code>void</code> Operation.  In solchen Situationen <code>Task.ComletedTask</code> die Laufzeit das <code>Task</code> Objekt einfach zwischen und verwendet es jedes Mal als Ergebnis f√ºr jede <code>async Task</code> - eine Methode, die synchron beendet wird ( <code>Task.ComletedTask</code> ).  Ein weiteres Beispiel: Nehmen wir an, Sie schreiben: </p><br><pre> <code class="plaintext hljs">public async Task&lt;bool&gt; MoveNextAsync() { if (_bufferedCount == 0) { await FillBuffer(); } return _bufferedCount &gt; 0; }</code> </pre> <br><p>  Nehmen wir auf die gleiche Weise an, dass sich in den meisten F√§llen einige Daten im Puffer befinden.  Die Methode √ºberpr√ºft <code>_bufferedCount</code> , <code>_bufferedCount</code> , dass die Variable gr√∂√üer als Null ist, und gibt <code>true</code> .  Nur wenn zum Zeitpunkt der √úberpr√ºfung die Daten nicht gepuffert waren, ist eine asynchrone Operation erforderlich.  Wie dem auch sei, es gibt nur zwei m√∂gliche logische Ergebnisse ( <code>true</code> und <code>false</code> ) und nur zwei m√∂gliche R√ºckgabezust√§nde √ºber <code>Task&lt;bool&gt;</code> .  Basierend auf der synchronen Fertigstellung oder asynchron, jedoch vor dem Beenden der Methode, speichert die Laufzeit zwei Instanzen von <code>Task&lt;bool&gt;</code> (eine f√ºr <code>true</code> und eine f√ºr <code>false</code> ) zwischen und gibt die gew√ºnschte zur√ºck, wobei zus√§tzliche Zuordnungen vermieden werden.  Die einzige Option, wenn Sie ein neues <code>Task&lt;bool&gt;</code> -Objekt erstellen m√ºssen, ist ein Fall von asynchroner Ausf√ºhrung, der nach der "R√ºckkehr" endet.  In diesem Fall muss die Methode ein neues <code>Task&lt;bool&gt;</code> -Objekt erstellen, weil  Zum Zeitpunkt des Beendens des Verfahrens ist das Ergebnis des Abschlusses der Operation noch nicht bekannt.  Das zur√ºckgegebene Objekt muss eindeutig sein, weil  Es wird letztendlich das Ergebnis der asynchronen Operation speichern. </p><br><p>  Es gibt andere Beispiele f√ºr √§hnliches Caching aus der Laufzeit.  Eine solche Strategie ist jedoch nicht √ºberall anwendbar.  Zum Beispiel die Methode: </p><br><pre> <code class="plaintext hljs">public async Task&lt;int&gt; ReadNextByteAsync() { if (_bufferedCount == 0) { await FillBuffer(); } if (_bufferedCount == 0) { return -1; } _bufferedCount--; return _buffer[_position++]; }</code> </pre> <br><p>  endet auch oft synchron.  Im Gegensatz zum vorherigen Beispiel gibt diese Methode jedoch ein ganzzahliges Ergebnis mit ungef√§hr vier Milliarden m√∂glichen Werten zur√ºck.  Zum Zwischenspeichern von <code>Task&lt;int&gt;</code> w√§ren in dieser Situation Hunderte von Gigabyte Speicher erforderlich.  Die Umgebung unterst√ºtzt hier auch einen kleinen Cache f√ºr <code>Task&lt;int&gt;</code> f√ºr mehrere kleine Werte.  Wenn der Vorgang beispielsweise synchron abgeschlossen wird (Daten sind im Puffer vorhanden), mit einem Ergebnis von 4, wird der Cache verwendet.  Wenn das Ergebnis jedoch synchron ist, ist der Abschluss 42, und ein neues <code>Task&lt;int&gt;</code> -Objekt wird erstellt, √§hnlich wie beim Aufrufen von <code>Task.FromResult(42)</code> . </p><br><p>  Viele Bibliotheksimplementierungen versuchen, diese Situationen durch die Unterst√ºtzung ihrer eigenen Caches zu entsch√§rfen.  Ein Beispiel ist die √úberlastung von <code>MemoryStream.ReadAsync</code> .  Dieser in .NET Framework 4.5 eingef√ºhrte Vorgang endet immer synchron, weil  es ist nur eine Lesung aus dem Ged√§chtnis.  <code>ReadAsync</code> gibt eine <code>Task&lt;int&gt;</code> wobei das ganzzahlige Ergebnis die Anzahl der gelesenen Bytes darstellt.  Sehr oft tritt im Code eine Situation auf, wenn <code>ReadAsync</code> in einer Schleife verwendet wird.  Dar√ºber hinaus, wenn die folgenden Symptome auftreten: </p><br><ul><li>  Die Anzahl der angeforderten Bytes √§ndert sich f√ºr die meisten Iterationen der Schleife nicht. </li><li>  In den meisten Iterationen kann <code>ReadAsync</code> die angeforderte Anzahl von Bytes lesen. </li></ul><br><p>  Das hei√üt, bei wiederholten Aufrufen wird <code>ReadAsync</code> synchron ausgef√ºhrt und gibt ein <code>Task&lt;int&gt;</code> -Objekt mit demselben Ergebnis von Iteration zu Iteration zur√ºck.  Es ist logisch, dass <code>MemoryStream</code> die zuletzt erfolgreich abgeschlossene Aufgabe zwischenspeichert und bei allen nachfolgenden Aufrufen eine Instanz aus dem Cache zur√ºckgibt, wenn das neue Ergebnis mit dem vorherigen √ºbereinstimmt.  Wenn das Ergebnis nicht √ºbereinstimmt, wird <code>Task.FromResult</code> verwendet, um eine neue Instanz zu erstellen, die wiederum vor der R√ºckkehr zwischengespeichert wird. </p><br><p>  Es gibt jedoch viele F√§lle, in denen eine Operation gezwungen ist, neue <code>Task&lt;TResult&gt;</code> -Objekte zu erstellen, selbst wenn sie synchron abgeschlossen ist. </p><br><h2 id="valuetasktresult-i-sinhronnoe-zavershenie">  ValueTask &lt;TResult&gt; und synchroner Abschluss </h2><br><p>  All dies diente letztendlich als Motivation f√ºr die Einf√ºhrung eines neuen <code>ValueTask&lt;TResult&gt;</code> in .NET Core 2.0.  <code>System.Threading.Tasks.Extensions</code> wurde dieser Typ √ºber das Nuget-Paket <code>System.Threading.Tasks.Extensions</code> in anderen .NET-Versionen verf√ºgbar gemacht. </p><br><p>  <code>ValueTask&lt;TResult&gt;</code> wurde in .NET Core 2.0 als Struktur eingef√ºhrt, die <code>TResult</code> oder <code>Task&lt;TResult&gt;</code> .  Dies bedeutet, dass Objekte dieses Typs von der <code>async</code> Methode zur√ºckgegeben werden k√∂nnen.  Das erste Plus aus der Einf√ºhrung dieses Typs ist sofort sichtbar: Wenn die Methode erfolgreich und synchron abgeschlossen wurde, muss auf dem Heap nichts erstellt werden, gerade genug, um eine Instanz von <code>ValueTask&lt;TResult&gt;</code> mit dem Ergebniswert zu erstellen.  Nur wenn die Methode asynchron beendet wird, m√ºssen wir eine <code>Task&lt;TResult&gt;</code> erstellen.  In diesem Fall wird <code>ValueTask&lt;TResult&gt;</code> als Wrapper f√ºr <code>Task&lt;TResult&gt;</code> .  Die Entscheidung, <code>ValueTask&lt;TResult&gt;</code> Lage zu <code>ValueTask&lt;TResult&gt;</code> , <code>Task&lt;TResult&gt;</code> zu aggregieren, wurde zur Optimierung getroffen: Im Erfolgsfall und im <code>Task&lt;TResult&gt;</code> erstellt die asynchrone Methode <code>Task&lt;TResult&gt;</code> . Aus Sicht der Speicheroptimierung ist es besser, das Objekt <code>Task&lt;TResult&gt;</code> zu aggregieren <code>Task&lt;TResult&gt;</code> als zus√§tzliche Felder in der <code>ValueTask&lt;TResult&gt;</code> f√ºr verschiedene Abschlussf√§lle <code>ValueTask&lt;TResult&gt;</code> (z. B. um eine Ausnahme zu speichern). </p><br><p>  Vor diesem Hintergrund ist das Zwischenspeichern in Methoden wie dem oben genannten <code>MemoryStream.ReadAsync</code> nicht mehr erforderlich, sondern kann wie folgt implementiert werden: </p><br><pre> <code class="plaintext hljs">public override ValueTask&lt;int&gt; ReadAsync(byte[] buffer, int offset, int count) { try { int bytesRead = Read(buffer, offset, count); return new ValueTask&lt;int&gt;(bytesRead); } catch (Exception e) { return new ValueTask&lt;int&gt;(Task.FromException&lt;int&gt;(e)); } }</code> </pre> <br><h2 id="valuetasklttresultgt-i-asinhronnoe-zavershenie">  ValueTask &lt;TResult&gt; und asynchrone Beendigung </h2><br><p>  Die F√§higkeit, asynchrone Methoden zu schreiben, f√ºr die keine zus√§tzlichen Speicherzuweisungen f√ºr das Ergebnis erforderlich sind, mit synchroner Vervollst√§ndigung, ist wirklich ein gro√ües Plus.  Wie oben erw√§hnt, war dies das Hauptziel f√ºr die Einf√ºhrung des neuen <code>ValueTask&lt;TResult&gt;</code> in .NET Core 2.0.  Alle neuen Methoden, die voraussichtlich auf den "hei√üen Stra√üen" verwendet werden, verwenden jetzt <code>ValueTask&lt;TResult&gt;</code> anstelle von <code>Task&lt;TResult&gt;</code> als R√ºckgabetyp.  Beispielsweise gibt eine neue √úberladung der <code>ReadAsync</code> Methode f√ºr <code>Stream</code> in .NET Core 2.1 (bei der <code>Memory&lt;byte&gt;</code> anstelle von <code>byte[]</code> als Parameter verwendet wird) eine Instanz von <code>ValueTask&lt;int&gt;</code> .  Dadurch konnte die Anzahl der Zuweisungen beim Arbeiten mit Streams erheblich reduziert werden (sehr oft wird die <code>ReadAsync</code> Methode synchron beendet, wie im Beispiel mit <code>MemoryStream</code> ). </p><br><p>  Bei der Entwicklung von Diensten mit hoher Bandbreite, bei denen eine asynchrone Beendigung nicht ungew√∂hnlich ist, m√ºssen wir jedoch unser Bestes tun, um zus√§tzliche Zuweisungen zu vermeiden. </p><br><p>  Wie bereits erw√§hnt, muss im asynchronen <code>async/await</code> Modell jede Operation, die asynchron ausgef√ºhrt wird, ein eindeutiges Objekt zur√ºckgeben, um auf den Abschluss zu warten.  Einzigartig, weil  Es dient als Kanal f√ºr die Durchf√ºhrung von R√ºckrufen.  Beachten Sie jedoch, dass diese Konstruktion nichts dar√ºber aussagt, ob das zur√ºckgegebene <em>Warteobjekt</em> nach Abschluss der asynchronen Operation <em>wiederverwendet</em> werden <em>kann</em> .  Wenn ein Objekt wiederverwendet werden kann, kann die API einen Pool f√ºr diese Art von Objekten verwalten.  In diesem Fall kann dieser Pool jedoch keinen gleichzeitigen Zugriff unterst√ºtzen. Ein Objekt aus dem Pool wechselt vom Status "Abgeschlossen" in den Status "Nicht abgeschlossen" und umgekehrt. </p><br><p>  Um die M√∂glichkeit der Arbeit mit solchen Pools zu unterst√ºtzen, wurde .NET Core 2.1 die Schnittstelle <code>IValueTaskSource&lt;TResult&gt;</code> hinzugef√ºgt und die Struktur <code>ValueTask&lt;TResult&gt;</code> erweitert: Jetzt k√∂nnen Objekte dieses Typs nicht nur Objekte vom <code>Task&lt;TResult&gt;</code> <code>TResult</code> oder <code>Task&lt;TResult&gt;</code> , sondern auch Instanzen von <code>IValueTaskSource&lt;TResult&gt;</code> .  Die neue Schnittstelle bietet grundlegende Funktionen, mit denen <code>ValueTask&lt;TResult&gt;</code> -Objekte mit <code>IValueTaskSource&lt;TResult&gt;</code> auf dieselbe Weise wie mit <code>Task&lt;TResult&gt;</code> : </p><br><pre> <code class="plaintext hljs">public interface IValueTaskSource&lt;out TResult&gt; { ValueTaskSourceStatus GetStatus(short token); void OnCompleted( Action&lt;object&gt; continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags); TResult GetResult(short token); }</code> </pre> <br><p>  <code>GetStatus</code> f√ºr die Verwendung in der <code>ValueTask&lt;TResult&gt;.IsCompleted/IsCompletedSuccessfully</code> k√∂nnen Sie feststellen, ob der Vorgang abgeschlossen wurde oder nicht (erfolgreich oder nicht).  <code>OnCompleted</code> in <code>ValueTask&lt;TResult&gt;</code> , um einen R√ºckruf auszul√∂sen.  <code>GetResult</code> verwendet, um das Ergebnis <code>GetResult</code> oder eine Ausnahme <code>GetResult</code> . </p><br><p>  Es ist unwahrscheinlich, dass sich die meisten Entwickler jemals mit der <code>IValueTaskSource&lt;TResult&gt;</code> -Schnittstelle befassen m√ºssen, weil  Wenn asynchrone Methoden zur√ºckgegeben werden, wird sie hinter der <code>ValueTask&lt;TResult&gt;</code> .  Die Schnittstelle selbst ist in erster Linie f√ºr diejenigen gedacht, die Hochleistungs-APIs entwickeln und unn√∂tige Arbeit mit einem Haufen vermeiden m√∂chten. </p><br><p>  In .NET Core 2.1 gibt es mehrere Beispiele f√ºr diese Art von API.  Die bekannteste davon sind die neuen √úberladungen der Methoden <code>Socket.ReceiveAsync</code> und <code>Socket.SendAsync</code> .  Z.B: </p><br><pre> <code class="plaintext hljs">public ValueTask&lt;int&gt; ReceiveAsync( Memory&lt;byte&gt; buffer, SocketFlags socketFlags, CancellationToken cancellationToken = default);</code> </pre> <br><p>  Objekte vom Typ <code>ValueTask&lt;int&gt;</code> werden als R√ºckgabewert verwendet. <br>  Wenn die Methode synchron beendet wird, gibt sie eine <code>ValueTask&lt;int&gt;</code> mit dem entsprechenden Wert zur√ºck: </p><br><pre> <code class="plaintext hljs">int result = ‚Ä¶; return new ValueTask&lt;int&gt;(result);</code> </pre> <br><p>  Wenn der Vorgang asynchron abgeschlossen wird, wird ein zwischengespeichertes Objekt verwendet, das die Schnittstelle <code>IValueTaskSource&lt;TResult&gt;</code> implementiert: </p><br><pre> <code class="plaintext hljs">IValueTaskSource&lt;int&gt; vts = ‚Ä¶; return new ValueTask&lt;int&gt;(vts);</code> </pre> <br><p>  Die <code>Socket</code> Implementierung unterst√ºtzt ein zwischengespeichertes Objekt zum Empfangen und eines zum Senden von Daten, sofern jedes von ihnen ohne Konkurrenz verwendet wird (nein, zum Beispiel das Senden von Wettbewerbsdaten).  Diese Strategie reduziert die Menge des zugewiesenen zus√§tzlichen Speichers, selbst bei asynchroner Ausf√ºhrung. <br>  Die beschriebene Optimierung von <code>Socket</code> in .NET Core 2.1 hatte positive Auswirkungen auf die Leistung von <code>NetworkStream</code> .  Seine √úberladung ist die <code>ReadAsync</code> Methode der <code>Stream</code> Klasse: </p><br><pre> <code class="plaintext hljs">public virtual ValueTask&lt;int&gt; ReadAsync( Memory&lt;byte&gt; buffer, CancellationToken cancellationToken);</code> </pre> <br><p>  delegiert die Arbeit einfach an die <code>Socket.ReceiveAsync</code> Methode.  Durch Erh√∂hen der Effizienz der Socket-Methode im Hinblick auf die Arbeit mit dem Speicher wird die Effizienz der <code>NetworkStream</code> Methode erh√∂ht. </p><br><h2 id="non-generic-valuetask">  Nicht generische ValueTask </h2><br><p>  Zuvor habe ich mehrmals festgestellt, dass das urspr√ºngliche Ziel von <code>ValueTask&lt;T&gt;</code> in .NET Core 2.0 darin bestand, F√§lle des synchronen Abschlusses von Methoden mit einem "nicht leeren" Ergebnis zu optimieren.  Dies bedeutet, dass keine nicht typisierte <code>ValueTask</code> : Bei synchroner Fertigstellung verwenden Methoden einen Singleton √ºber die <code>Task.CompletedTask</code> Eigenschaft, und die Laufzeit f√ºr <code>async Task</code> Methoden wird ebenfalls implizit empfangen. </p><br><p>  Mit dem Aufkommen der M√∂glichkeit, unn√∂tige Zuweisungen zu vermeiden, und mit der asynchronen Ausf√ºhrung wurde die Notwendigkeit einer nicht typisierten <code>ValueTask</code> wieder relevant.  Aus diesem Grund haben wir in .NET Core 2.1 nicht <code>ValueTask</code> und <code>IValueTaskSource</code> .  Sie sind Analoga der entsprechenden generischen Typen und werden auf die gleiche Weise verwendet, jedoch f√ºr Methoden mit einer leeren ( <code>void</code> ) R√ºckgabe. </p><br><h2 id="realizaciya-ivaluetasksource--ivaluetasksourcelttgt">  Implementieren Sie IValueTaskSource / IValueTaskSource &lt;T&gt; </h2><br><p>  Die meisten Entwickler m√ºssen diese Schnittstellen nicht implementieren.  Und ihre Umsetzung ist keine leichte Aufgabe.  Wenn Sie entscheiden, dass Sie sie selbst implementieren m√ºssen, gibt es in .NET Core 2.1 mehrere Implementierungen, die als Beispiele dienen k√∂nnen: </p><br><ul><li>  <a href="">AwaitableSocketAsyncEventArgs</a> </li><li>  <a href="">AsyncOperation &lt;Tresult&gt;</a> </li><li>  <a href="">DefaultPipeReader</a> </li></ul><br><p>  Um diese Aufgaben zu vereinfachen (Implementierungen von <code>IValueTaskSource / IValueTaskSource&lt;T&gt;</code> ), planen wir, den Typ <code>ManualResetValueTaskSourceCore&lt;TResult&gt;</code> in .NET Core 3.0 <code>ManualResetValueTaskSourceCore&lt;TResult&gt;</code> .  Diese Struktur kapselt die gesamte erforderliche Logik.  Die Instanz <code>ManualResetValueTaskSourceCore&lt;TResult&gt;</code> kann in einem anderen Objekt verwendet werden, das <code>IValueTaskSource&lt;TResult&gt;</code> und / oder <code>IValueTaskSource</code> , und den gr√∂√üten Teil der Arbeit an dieses Objekt delegieren.  Weitere Informationen hierzu finden Sie unter ttps: //github.com/dotnet/corefx/issues/32664. </p><br><h2 id="pravilnaya-model-ispolzovaniya-valuetasks">  Das richtige Modell f√ºr die Verwendung von ValueTasks </h2><br><p>  Selbst eine fl√ºchtige Pr√ºfung <code>ValueTask</code> dass <code>ValueTask</code> und <code>ValueTask&lt;TResult&gt;</code> eingeschr√§nkter sind als <code>Task</code> und <code>Task&lt;TResult&gt;</code> .  Dies ist normal und sogar w√ºnschenswert, da das Hauptziel darin besteht, auf den Abschluss der asynchronen Ausf√ºhrung zu warten. </p><br><p>  Insbesondere ergeben sich erhebliche Einschr√§nkungen aufgrund der Tatsache, dass <code>ValueTask</code> und <code>ValueTask&lt;TResult&gt;</code> wiederverwendbare Objekte aggregieren k√∂nnen.  Im Allgemeinen sollten die folgenden Operationen * <code>ValueTask</code> <em>ausgef√ºhrt werden, wenn</em> <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> * verwendet wird <em>(</em> lassen Sie mich durch "Never" * umformulieren): </p><br><ul><li>  <strong>Verwenden Sie niemals dasselbe <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> -Objekt wiederholt</strong> </li></ul><br><p>  <em>Motivation: Die</em> Instanzen <code>Task</code> und <code>Task&lt;TResult&gt;</code> niemals vom <code>Task&lt;TResult&gt;</code> "abgeschlossen" in den Status "unvollst√§ndig". Sie k√∂nnen sie verwenden, um so oft auf das Ergebnis zu warten, wie wir m√∂chten. Nach Abschluss erhalten wir immer das gleiche Ergebnis.  Im Gegenteil, da <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> , k√∂nnen sie als Wrapper f√ºr wiederverwendete Objekte fungieren, was bedeutet, dass sich ihr Status √§ndern kann, weil  Der Status wiederverwendeter Objekte √§ndert sich per Definition - um von "abgeschlossen" zu "unvollst√§ndig" und umgekehrt zu wechseln. </p><br><ul><li>  <strong><code>ValueTask</code> niemals <code>ValueTask</code> / <code>ValueTask&amp;lt;TResult&amp;gt;</code></strong>  <strong>im Wettbewerbsmodus.</strong> </li></ul><br><p>  <em>Motivation: Ein</em> verpacktes Objekt erwartet, dass es jeweils nur mit einem R√ºckruf von einem einzelnen Verbraucher funktioniert, und der Versuch, mit dem erwarteten Wettbewerb zu konkurrieren, kann leicht zu Rennbedingungen und subtilen Programmierfehlern f√ºhren.  Wettbewerbserwartungen, dies ist eine der oben beschriebenen Optionen f√ºr <strong>mehrere Erwartungen</strong> .  Beachten Sie, dass <code>Task</code> / <code>Task&lt;TResult&gt;</code> eine beliebige Anzahl von Wettbewerbserwartungen zul√§sst. </p><br><ul><li>  <strong>Verwenden <code>.GetAwaiter().GetResult()</code> niemals <code>.GetAwaiter().GetResult()</code> bis der Vorgang abgeschlossen ist</strong> . </li></ul><br><p>  <em>Motivation:</em> Implementierungen von <code>IValueTaskSource</code> / <code>IValueTaskSource&lt;TResult&gt;</code> sollten das Sperren erst nach Abschluss des Vorgangs unterst√ºtzen.  Das Blockieren f√ºhrt in der Tat zu einer Rennbedingung. Es ist unwahrscheinlich, dass dies das erwartete Verhalten des Verbrauchers ist.  Mit <code>Task</code> / <code>Task&lt;TResult&gt;</code> k√∂nnen Sie dies tun und so den aufrufenden Thread blockieren, bis der Vorgang abgeschlossen ist. </p><br><p>  Was aber, wenn Sie dennoch eine der oben beschriebenen Operationen ausf√ºhren m√ºssen und die aufgerufene Methode Instanzen von <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> ?  In solchen F√§llen stellt <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> die Methode <code>.AsTask()</code> .  Wenn Sie diese Methode aufrufen, erhalten Sie eine Instanz von <code>Task</code> / <code>Task&lt;TResult&gt;</code> , mit der Sie bereits die erforderliche Operation ausf√ºhren k√∂nnen.  Die Wiederverwendung des urspr√ºnglichen Objekts nach dem Aufruf von <code>.AsTask()</code> ist <em>nicht zul√§ssig</em> . </p><br><p> <strong>  </strong> : <em>    <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code>  ,   ( <code>await</code> )   (,    <code>.ConfigureAwait(false)</code> ),   <code>.AsTask()</code> ,        <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> .</em> </p><br><pre> <code class="plaintext hljs">// Given this ValueTask&lt;int&gt;-returning method‚Ä¶ public ValueTask&lt;int&gt; SomeValueTaskReturningMethodAsync(); ‚Ä¶ // GOOD int result = await SomeValueTaskReturningMethodAsync(); // GOOD int result = await SomeValueTaskReturningMethodAsync().ConfigureAwait(false); // GOOD Task&lt;int&gt; t = SomeValueTaskReturningMethodAsync().AsTask(); // WARNING ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); ... // storing the instance into a local makes it much more likely it'll be misused, // but it could still be ok // BAD: awaits multiple times ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); int result = await vt; int result2 = await vt; // BAD: awaits concurrently (and, by definition then, multiple times) ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); Task.Run(async () =&gt; await vt); Task.Run(async () =&gt; await vt); // BAD: uses GetAwaiter().GetResult() when it's not known to be done ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); int result = vt.GetAwaiter().GetResult();</code> </pre> <br><p>    , "",  ,       (    ,      ). </p><br><p>   <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code>  ,       .  ,  <code>IsCompleted</code>  <code>true</code> ,    (   ,  ),    ‚Äî <code>false</code> ,  <code>IsCompletedSuccessfully</code>  <code>true</code>     .   " " ,   , ,    ,    ,    .            <code>await</code> / <code>.AsTask()</code>     <code>.Result</code> .  ,   <code>SocketsHttpHandler</code>  .NET Core 2.1,     <code>.ReadAsync</code> ,   <code>ValueTask&lt;int&gt;</code> .    ,       , ,  .      ,         ..   .  Weil    ,     , ,  ,    : </p><br><pre> <code class="plaintext hljs">int bytesRead; { ValueTask&lt;int&gt; readTask = _connection.ReadAsync(buffer); if (readTask.IsCompletedSuccessfully) { bytesRead = readTask.Result; } else { using (_connection.RegisterCancellation()) { bytesRead = await readTask; } } }</code> </pre> <br><p>    , .. <code>ValueTask&lt;int&gt;</code> ,     <code>.Result</code> ,    <code>await</code> ,     . </p><br><h2 id="dolzhny-li-vse-novye-asinhronnye-api-vozvraschat-valuetask--valuetasklttresultgt">      API  ValueTask / ValueTask&lt;TResult&gt;? </h2><br><p>  ,  .      <code>Task</code> / <code>ValueTask&lt;TResult&gt;</code> . </p><br><p>    ,   <code>Task</code> / <code>Task&lt;TResult&gt;</code>     .   ,       ""  / ,    <code>Task</code> / <code>Task&lt;TResult&gt;</code> . ,  ,      <code>ValueTask&lt;TResult&gt;</code>  <code>Task&lt;TResult&gt;</code> : ,   ,  <code>await</code>     <code>Task&lt;TResult&gt;</code>   <code>ValueTask&lt;TResult&gt;</code> .  ,       (,  API  <code>Task</code>  <code>Task&lt;bool&gt;</code> ), ,    ,   <code>Task</code> ( <code>Task&lt;bool&gt;</code> ).  , <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code>    .  ,    async-,              <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> ,       . </p><br><p>     , <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code>   , : </p><br><ol><li>  ,    API    , </li><li>  API        ,  </li><li>   ,      ,         ,    . </li></ol><br><p>  ,     <code>abstract</code> / <code>virtual</code>  ,    ,           /  ? </p><br><h2 id="chto-dalshe">  Was weiter? </h2><br><p>    .NET,     API,  <code>Task</code> / <code>Task&lt;TResult&gt;</code> . ,  ,     API c <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> ,     .         <code>IAsyncEnumerator&lt;T&gt;</code> ,      .NET Core 3.0.  <code>IEnumerator&lt;T&gt;</code>   <code>MoveNext</code> ,    .   ‚Äî <code>IAsyncEnumerator&lt;T&gt;</code>   <code>MoveNextAsync</code> .      ,        <code>Task&lt;bool&gt;</code> ,        ,    .  ,       ,       ,      (        ),   ,   ,         <code>await foreach</code> -,  ,      <code>MoveNextAsync</code> ,  <code>ValueTask&lt;bool&gt;</code> .         , ,   ,     " " ,         . ,  C#      ,           . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465259/">https://habr.com/ru/post/de465259/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465247/index.html">Winkelig Grundlegendes zu @Input, @Output und EventEmitter</a></li>
<li><a href="../de465249/index.html">Vortrag von Richard Stallman am Moskauer Polytechnikum. August 2019</a></li>
<li><a href="../de465251/index.html">Der Sommer ist fast vorbei. Es sind fast keine Daten durchgesickert</a></li>
<li><a href="../de465255/index.html">Implementierung des WCF-Verbindungspools f√ºr .Net Core mithilfe von HttpClientFactory</a></li>
<li><a href="../de465257/index.html">"Vorsicht, FAS!": McDonald's Tricks, g√∂ttliches D√∂ner, falsches Clooney und etwas Stra√üenmagie</a></li>
<li><a href="../de465261/index.html">Die magische Kraft von Makros oder wie man einem AVR-Assembler-Programmierer das Leben leichter macht</a></li>
<li><a href="../de465263/index.html">Sperren in PostgreSQL: 3. Sperrt andere Objekte</a></li>
<li><a href="../de465267/index.html">TypeScript Ausdruck Magie</a></li>
<li><a href="../de465269/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 26. DNS und DHCP</a></li>
<li><a href="../de465271/index.html">Hacker stehlen und waschen Geld durch Lieferservice und Hotelreservierung.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>