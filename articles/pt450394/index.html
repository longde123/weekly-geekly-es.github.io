<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛄 📕 🧕🏻 Investigação de um arquivo desconhecido ⚔️ 🤹🏼 👪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Realocação. Nova cidade. Procura de emprego. Mesmo para um profissional de TI, isso pode levar muito tempo. Uma série de entrevistas, que, em geral, s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Investigação de um arquivo desconhecido</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450394/">  Realocação.  Nova cidade.  Procura de emprego.  Mesmo para um profissional de TI, isso pode levar muito tempo.  Uma série de entrevistas, que, em geral, são muito semelhantes entre si.  E como normalmente acontece quando você já encontra um emprego, depois de um tempo, um escritório interessante é anunciado. <br><br>  Era difícil entender o que ela estava fazendo especificamente, no entanto, sua área de interesse era o estudo de software de outras pessoas.  Parece intrigante, embora quando você percebe que esse não parece um fornecedor que libera software para segurança cibernética, você pára por um segundo e começa a coçar os nabos. <br><br><img src="https://lh3.googleusercontent.com/Wm2cSc19nc9XsapzlEW-eGMZBZCEgSbZFCSj6hdNNlkqCa40ksCXrYv8ual-VfYF3rcn5OoM9X2OwIJY07u_dD5Lo_7mzZU4D7rQuu164GIDE2_IjBu_J1dIMsjD4uDgyep3yipN"><br><a name="habracut"></a><br>  Resumindo: eles descartaram o arquivo e se ofereceram para examiná-lo como uma tarefa de teste e tentar calcular uma certa assinatura com base nos dados de entrada apresentados.  Vale a pena notar que eu tinha muito pouca experiência em tais atividades e, provavelmente, é por isso que na primeira iteração da solução eu só tinha algumas horas - então a motivação para fazer isso não deu em nada.  E sim, claro, a primeira coisa que tentei executá-lo no telefone / emulador - esse aplicativo é inválido. <br><br>  <b>O que temos: um</b> arquivo com a extensão <b>".apk"</b> .  Coloquei a tarefa por baixo do spoiler para que não fosse indexada pelos mecanismos de busca: e se os caras não gostarem, eu coloco a solução no Habr? <br><br><div class="spoiler">  <b class="spoiler_title">Tarefa em si</b> <div class="spoiler_text">  O APK contém funcionalidade para gerar assinaturas para uma matriz associativa. <br>  Tente obter uma assinatura para o seguinte conjunto de dados: <br><br><pre><code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"user"</span></span> : <span class="hljs-string"><span class="hljs-string">"LeetD3vM4st3R"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"__s33cr$$tV4lu3__"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"hash"</span></span>: <span class="hljs-string"><span class="hljs-string">"34765983265937875692356935636464"</span></span> }</code> </pre> <br></div></div><br><h2>  Arregaçar as mangas </h2><br>  Diz-se que o arquivo contém a funcionalidade de assinar uma matriz associativa.  Pela extensão do arquivo, entendemos imediatamente que estamos lidando com um aplicativo escrito para Android.  Primeiro, descompactamos o arquivo.  De fato, este é um arquivo ZIP comum, e qualquer arquivador irá lidar com ele de ânimo leve.  Usei o utilitário apktool e, como se viu, ignorou acidentalmente alguns ancinhos.  Sim, acontece (geralmente o oposto, sim?).  O feitiço é bem simples: <br><br><pre> <code class="bash hljs">apktool d task.zip</code> </pre> <br>  Acontece que o código e os recursos no arquivo apk também são armazenados compactados em binários separados e será necessário outro software para extraí-los.  O apktool retirou implicitamente os bytes da classe, os recursos e decompôs tudo em uma hierarquia de arquivos natural.  Você pode prosseguir. <br><br><pre> <code class="bash hljs">├── AndroidManifest.xml ├── apktool.yml ├── lib │   └── arm64-v8a ├── original │   ├── AndroidManifest.xml │   └── META-INF ├── res │   ├── anim │   ├── color │   ├── drawable │   ├── layout │   ├── layout-watch-v20 │   ├── mipmap-anydpi-v26 │   ├── values │   └── values-af ├── smali │   ├── android │   ├── butterknife │   ├── com │   ├── net │   └── org └── unknown   └── org</code> </pre> <br>  Vemos uma hierarquia semelhante (deixou sua versão simplificada) e estamos tentando descobrir por onde começar.  Vale a pena notar que, no entanto, uma vez eu escrevi alguns aplicativos pequenos para Android, portanto, a essência de parte dos diretórios e, em geral, os princípios dos aplicativos para dispositivos Android, são aproximadamente claros para mim. <br><br>  Para começar, decido apenas "percorrer" os arquivos.  Abro o AndroidManifest.xml e começo a ler de forma significativa.  Minha atenção é atraída por um atributo estranho <br><br><pre> <code class="xml hljs">android:supportsRtl="true"</code> </pre> <br>  Acontece que ele é responsável pelo suporte a idiomas com a letra "da direita para a esquerda" no aplicativo.  Começamos a nos esforçar.  Não é bom <br><br>  Além disso, meu olhar se apega à pasta desconhecida.  Abaixo dele, há uma hierarquia no formato: <b>org.apache.commons.codec.language.bm</b> e um grande número de arquivos de texto com conteúdo obscuro.  Pesquise no Google o nome completo do pacote e o que está armazenado aqui, algo relacionado ao algoritmo de busca por palavras foneticamente semelhantes ao dado.  Francamente, aqui comecei a me esforçar mais.  Tendo vasculhado um pouco os diretórios, encontrei o código em si e a diversão começou.  Fui recebido não pelo código de código Java habitual, com o qual consegui brincar, mas por outra coisa.  Muito parecido, mas diferente. <br><br>  Como se viu, o Android tem sua própria máquina virtual - Dalvik.  E, como toda máquina virtual respeitada, ela tem seu próprio bytecode.  Parece que na primeira tentativa de resolver esse problema, foi com essa triste nota que anunciei o intervalo, fiz uma reverência, abaixei a cortina e joguei tudo por 4 meses até que minha curiosidade me acabasse completamente. <br><br><h2>  Arregace as mangas [2] </h2><br>  "Mas não é possível que tudo fique mais fácil?"  - Essa é a pergunta que me fiz quando iniciei a tarefa pela segunda vez.  Comecei a pesquisar na internet um descompilador de smali para Java.  Vi apenas que é impossível realizar esse processo sem ambiguidade.  Franzindo a testa um pouco, ele foi ao Github e colocou algumas frases-chave na linha de pesquisa.  O primeiro veio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">smali2java</a> . <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> gradle build java -jar smali2java.jar ..</code> </pre> <br>  Erros  Vejo um enorme rastreamento de pilha e erros em várias páginas do terminal.  Depois de ler um pouco sobre a essência do conteúdo (e restringir as emoções pelo tamanho do rastreamento da pilha), acho que essa ferramenta funciona com base em uma certa gramática descrita e o código de código que ela conheceu claramente não corresponde a ela.  Abro o bytecode smali e vejo anotações, métodos sintéticos e outras construções estranhas nele.  Não havia tal coisa no bytecode Java!  Quanto tempo?  Excluir! <br><br><div class="spoiler">  <b class="spoiler_title">Mais detalhes</b> <div class="spoiler_text">  A máquina virtual Dalvik (assim como a JVM), como se viu, não está ciente da existência de conceitos como classes internas / externas (leia classes aninhadas), e o compilador gera os chamados métodos "sintéticos" para fornecer acesso da classe aninhada para campos externos, por exemplo. <br><br><h4>  Como exemplo: </h4><br>  Se a classe externa (OuterClass) tiver um campo <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OuterClass</span></span></span><span class="hljs-class"> </span></span>{ List a; ... }</code> </pre> <br>  Para que a classe privada possa acessar o campo da classe externa, o compilador gerará implicitamente o seguinte método: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> synthetic java.util.<span class="hljs-function"><span class="hljs-function">List </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OuterClass p1)</span></span></span><span class="hljs-function"> </span></span>{ p1 = p1.a; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p1; }</code> </pre> <br>  Além disso, devido a essa cozinha de “compartimento do motor”, o trabalho de alguns outros mecanismos que a linguagem fornece é alcançado. <br><br>  Você pode começar a estudar essa questão em mais detalhes a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">partir daqui</a> . </div></div><br>  Não ajuda  Ele até jura por um código de código aparentemente não suspeito.  Abro o código-fonte do descompilador, leio e vejo algo muito estranho: mesmo programadores hindus (com todo o respeito) não teriam escrito isso.  Um pensamento surge: não é realmente o código gerado.  Rejeito a ideia por cerca de 30 minutos, tentando entender qual é o erro.  COMPLICADO.  Abro o Github novamente - e realmente, um analisador de gramática.  E aqui está o próprio gerador.  Pondo tudo de lado e tentando se aproximar do outro lado. <br><br>  <i>Vale a pena notar que, um pouco mais tarde, ainda tentei mudar a gramática e, em alguns lugares, até o próprio bytecode para que o descompilador ainda pudesse digeri-lo.</i>  <i>Mas mesmo quando o bytecode se tornou válido em termos de gramática do descompilador, o programa simplesmente não retornou nada para mim.</i>  <i>Código aberto ...</i> <br><br>  Folheio o bytecode e tropeço em constantes desconhecidas para mim.  No Google, encontro o mesmo no livro sobre aplicativos reversos para Android.  Lembro que esse é apenas o ID atribuído pelo pré-processador do compilador, atribuído aos recursos do aplicativo Android (a constante de tempo de gravação de código é R. *).  Na próxima meia hora - hora, examinarei brevemente quais registros são responsáveis ​​por quê, em que ordem os argumentos são passados ​​e, em geral, nos aprofundamos na sintaxe. <br><br><h2>  Como é isso? </h2><br><img src="https://lh4.googleusercontent.com/6vy-LnmhLmjl2TnDiAoA632c026jlrPG7zFlclZNXJRdpethXv_iFjRtzwyvQWrqkd1LUKixzHfzXAyDj4c28JAzqVYTmP9uqJTmUYgjJd8Yx5pEDkd0cad34bNg9LYDf3r2jFVj" width="350" height="496" align="left">  Encontrei o layout da janela principal do aplicativo e, a partir dele, já entendi o que estava acontecendo no aplicativo: na tela principal (Activity) existe um RecyclerView (condicionalmente, um View que pode reutilizar objetos da interface do usuário que não são exibidos atualmente para utilização da memória) com campos de entrada pares chave / valor, alguns botões responsáveis ​​por adicionar um novo par chave / valor a um determinado contêiner abstrato e um botão que gera uma assinatura (assinatura) para esse contêiner. <br><br>  Observando as anotações e observando uma certa quantidade de código suspeitamente semelhante à gerada, começo a pesquisar no Google.  O projeto usa a biblioteca ButterKnife, que permite o uso de anotações para <b>aumentar</b> automaticamente os elementos da interface do usuário <b>() -&gt; bind ()</b> .  Se houver anotações na classe, o processador de anotação ButterKnife implicitamente cria outra classe de fichários no formato <b>&lt;original_class&gt; __ViewBinding</b> , que faz todo o trabalho sujo por baixo do capô.  Na verdade, obtive todas essas informações em apenas um arquivo MainActivity depois de recriar manualmente a semelhança da fonte Java.  Depois de meia hora, percebi que as anotações dessa biblioteca também podem definir um retorno de chamada nas ações dos botões e encontrei as principais funções que eram realmente responsáveis ​​por adicionar um par de chave / valor ao contêiner e gerar uma assinatura. <br><br>  <i>É claro que, durante o estudo, eu tive que entrar nas "miudezas" de várias bibliotecas e plugins, porque mesmo belos landos com cookies não cobrem todos os casos de uso e detalhes, o que para qualquer "inversor", eu acho, é uma prática comum.</i> <br><br><h2>  Preguiça é amigo de um programador </h2><br>  Depois de passar mais algum tempo na segunda fonte, fiquei completamente cansado e percebi que não era possível cozinhar mingau.  Estou subindo no Github novamente e desta vez estou olhando mais de perto.  Acho o projeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Smali2PsuedoJava</a> - um decompilador em "código pseudo-Java".  Mesmo que esse utilitário, pelo menos alguma coisa possa levar a uma aparência humana, então para mim o autor é uma caneca de sua cerveja favorita (bem, ou pelo menos coloque um asterisco no Github, para iniciantes). <br><br>  E realmente funciona!  Efeito no rosto: <br><br><img src="https://lh6.googleusercontent.com/4yxBPy1Wt7_J7uLey66rp_qHwomfvAW_B1C6g3CsrS0DR73J_U42t4JgobNaGIUXVstTEVIaHriawFfRVZL4IqUEObjCL8RdLUv5VCGKiv_jeAxBclaXZlsMvmFUzFuuuuxfshw7"><br><br><h2>  Conheça Cipher.so </h2><br>  Um pouco mais tarde, estudando o pseudo-código Java do projeto e comparando-o incrivelmente com o bytecode smali, encontro uma biblioteca estranha no código - Cipher.so.  Pesquisando no Google, descobri que é a criptografia de um conjunto de valores de tempo de compilação dentro do arquivo APK.  Isso geralmente é necessário quando o aplicativo usa constantes do formulário: endereços IP, credenciais para um banco de dados externo, tokens para autorização etc.  - o que pode ser obtido com a ajuda da engenharia reversa do aplicativo.  É verdade que o autor escreve claramente que esse projeto é abandonado, dizem eles, desaparece.  Isso está ficando interessante. <br><br>  Essa biblioteca fornece acesso aos valores por meio da biblioteca Java, onde o método específico é a chave de seu interesse.  Isso apenas alimenta meu interesse e começo a subir mais fundo. <br><br>  Em resumo, o que o Cipher.so faz e como funciona: <br><br><ul><li>  no arquivo Gradle do nosso projeto, as chaves e os valores correspondentes são registrados <br></li><li>  todos os valores-chave serão compactados automaticamente em uma biblioteca dinâmica separada (.so), que será gerada no momento da compilação.  Sim - sim, SERÁ gerado. <br></li><li>  essas chaves podem ser obtidas dos métodos Java gerados pelo Cipher.so <br></li><li>  depois de criar o APK, os nomes das chaves são divididos em hash pelo MD5 (para maior segurança, é claro) <br></li></ul><br>  Tendo encontrado a biblioteca dinâmica de que preciso na pasta de arquivamento, prossigo para selecioná-la.  Para começar, como um reverso experiente (não), tento começar com um simples - decido olhar para a seção com constantes e para linhas interessantes em um binário semelhante a ELF.  Infelizmente, os usuários do mac prontamente ausentes estão faltando e, antes do início, dizemos o querido: <br><br><pre> <code class="bash hljs">brew install binuitls</code> </pre> <br>  E não se esqueça de escrever o caminho para <b>/ usr / local</b> no PATH, porque o <i>brew o</i> protege de tudo de maneira gentil ... <br><br><pre> <code class="bash hljs">greadelf -p .rodata lib/arm64-v8a/libcipher-lib.so | head -n 15</code> </pre> <br>  Limitamos a saída às 15 primeiras linhas; caso contrário, isso pode causar choque para um engenheiro despreparado. <br><br><img src="https://lh6.googleusercontent.com/-ka6awAjaQ6zTDJ4sogEHaqBEG2QL3il5HTS1M-HchKGBg4hK5qe__lAtEKtcL7CT0i_lhqtiEZYYRsnTpLmbc10hdpVTMcAeRP0bGJE87jUBvtkncNMJ3s5YtjgGXk0duZeHIrY"><br><br>  Nos endereços inferiores, notamos linhas suspeitas.  Como descobri, estudando as fontes do Cipher.so, as chaves e os valores são colocados no <b>std :: map</b> usual <b>:</b> isso fornece pouca informação, mas sabemos que no binar junto com as senhas criptografadas também existem chaves ofuscadas. <br><br>  Como é a criptografia de valores?  Estudando a fonte, descobri que a criptografia ocorre usando o AES - o sistema de criptografia simétrica padrão.  Portanto, se houver valores criptografados, a chave deve estar próxima ... Depois de estudá-la por um tempo, deparei-me com um problema no mesmo projeto com o provocativo título <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">“Armazenamento inseguro de chaves: segredos são muito fáceis de recuperar”</a> .  De fato, descobri que a chave está armazenada de forma clara no binar e encontrei o algoritmo de descriptografia.  No exemplo, a chave estava no endereço zero e, embora eu entenda que o compilador possa colocá-lo em outro lugar na seção .rodata do arquivo binário, decidi que essa unidade suspeita no endereço zero é a chave. <br><br>  <b>Tentativa 1: procuro</b> decifrar os valores e acredito que a chave de criptografia é a mesma.  O erro  O OpenSSL sugere que algo não está certo.  Depois de ler as fontes de Cipher.so um pouco, entendo que, se o usuário não especificar uma chave durante a montagem, a chave padrão será usada - <i>Cipher.so@DEFAULT</i> . <br><br>  <b>Tentativa 2:</b> Erro novamente.  Hmm ... É realmente redefinido por esta constante?  É muito simples cometer um erro: código confuso escrito em Gradle, com formatação "sumida".  Eu verifico novamente.  Tudo parece ser assim. <br><br>  Em vez das chaves estão os hashes MD5, e então tento tentar a sorte e abrir um serviço com tabelas arco-íris.  Voila - uma das chaves é a palavra "senha".  Não há segundo.  Dá-nos, é claro, não muito.  Ambas as chaves estão nos endereços 240 e 2a2, respectivamente.  Em princípio, é fácil reconhecê-los imediatamente - 32 caracteres (MD5). <br><br>  Eu verifiquei tudo de novo e tentei descriptografar com todas as outras linhas (que estão nos endereços inferiores) como uma chave para descriptografia - tudo é em vão. <br>  Portanto, há outra chave secreta, o algoritmo de ações parece estar correto.  Jogo essa tarefa de lado e tento não me enterrar. <br><br>  Tendo vasculhado um pouco o algoritmo de assinatura do contêiner, ainda vejo chamadas para a biblioteca e código Cipher.so que também usam as funções criptográficas da biblioteca Java. <br><br><h2>  Um enigma (que eu nunca resolvi) </h2><br>  Na função responsável pela criptografia, no início há uma verificação de chaves no contêiner. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] a(java/util/Map p1) { v0 = p1.size() v1 = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v0 != <span class="hljs-number"><span class="hljs-number">0</span></span>) goto :cond_0 p1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[v1]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p1; :cond_0 v0 = <span class="hljs-string"><span class="hljs-string">"user"</span></span>; v0 = p1.containsKey(v0) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v0 == <span class="hljs-number"><span class="hljs-number">0</span></span>) goto :cond_1 p1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[v1]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p1; ...</code> </pre><br>  Literalmente: se houver uma chave "usuário", esse contêiner não será assinado (uma assinatura zero será retornada).  Um sentimento estranho: parece que o problema está resolvido, mas parece de alguma forma simples.  Então, por que inventar todo o resto?  Desviar-se?  Então, por que não estudei esse código fluentemente antes?  Hmm ... <br><br>  Não, não é verdade.  Especifiquei a resposta de um determinado usuário em um messenger azul, cujos contatos me foram fornecidos ao atribuir a tarefa.  Cavando mais.  Talvez a chave / valor de entrada definido de alguma forma seja alterado à medida que é adicionado ao contêiner?  Eu li o código com cuidado. <br><br>  Observe que o descompilador removeu anotações do código smali.  E se ele removeu algo importante?  Eu verifico os arquivos principais - ao que parece, nada significativo.  Tudo importante está no lugar, mas o significado não está perdido.  Verifico as funções de retorno de chamada responsáveis ​​por escrever um par de chave / valor do TextBox condicional para contêineres internos.  Não encontrei nada de criminoso. <br><br>  Tornei-me o mais cético possível sobre cada linha de código - não posso mais confiar em ninguém. <br><br>  Solução simples # 2: notei que o procedimento de assinatura começa verificando a presença de algum valor (substring na cadeia de caracteres) na assinatura do certificado com o qual o aplicativo foi assinado. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@OnClick</span></span> <span class="hljs-comment"><span class="hljs-comment">//   protected void huvot324yo873yvo837yvo() { String signature = "no data"; boolean result = some_packages.isKeyInSignature(this); if result { Map map = new HashMap(); ...</span></span></code> </pre> <br>  O significado em si, é claro, está criptografado naquele binário infeliz.  E, na verdade, se esse valor não estiver na assinatura, o algoritmo não assinará nada, mas simplesmente retornará a string "no data", como a assinatura ... Novamente, somos escolhidos para Cipher ... <br><br><h2>  Luta final de descriptografia de chaves </h2><br>  Para entender a escala da tragédia, fiquei confuso assim: <br><br>  Fiz um despejo hexagonal desta seção e espiei as duas primeiras linhas, cujas suspeitas não desapareceram desde o início. <br><br><img src="https://lh4.googleusercontent.com/J4lmChj6kk0lWWy23D8QngSgnJlNfd-xDP1XyBnw1wyQ_U1NBRLYyx2BFZ4y9D1HXEjcSeCKVvZC3xgVCpx-VSV0bIHD5dcmsfdaX4jrmH-uRFsRMc9VJrqpUEMDEEaijeSTPRbk"><br><br>  Se você prestar atenção, o caractere que separa as linhas aqui é '0x00'.  Também é comumente usado pela biblioteca C padrão, em funções de string.  Por isso não é menos interessante, que tipo de caractere de espaço está no meio da primeira linha?  Em seguida, tentativas malucas começam, onde está a chave: <br><br><ul><li>  primeira linha inteira <br></li><li>  primeira linha antes do espaço <br></li><li>  primeira linha do espaço até o fim <br></li><li>  ... <br></li></ul><br>  O grau de paranóia já pode ser estimado.  Quando você não entende o quão difícil e astuta a tarefa deve ser, começa a dirigir.  E, no entanto, não é isso.  Então, o pensamento veio à minha mente: “O algoritmo funciona corretamente devido a problemas na minha máquina?”.  Em geral, a sequência de ações é lógica e não levantou questões, mas a pergunta é: os comandos na minha máquina fazem o que é necessário?  Então o que você acha? <br><br>  Depois de verificar todas as etapas manualmente, verificou-se que <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"some_base64_input"</span></span> | openssl base64 -d</code> </pre> <br>  em alguns argumentos de entrada, ele repentinamente retorna uma string vazia.  Hmm. <br><br>  Substituindo-o pelo primeiro decodificador base64 na máquina e classificando os candidatos principais, uma chave adequada foi encontrada imediatamente e as chaves foram descriptografadas de acordo. <br><br><h2>  Recuperando assinaturas de um certificado </h2><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isKeyInSignature</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(android.content.Context p1)</span></span></span><span class="hljs-function"> </span></span>{ v0 = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> TRY_0{ v1 = p1.getPackageManager() p0 = p1.getPackageName() v2 = <span class="hljs-number"><span class="hljs-number">0x40</span></span>; <span class="hljs-comment"><span class="hljs-comment">// GET_SIGNATURES PackageInfo p0 = v1.getPackageInfo(p0, v2) android.content.pm.Signature[] p0 = p0.signatures; // Order are not guaranteed v1 = p0.length; v2 = 0x0; :goto_0 if (v2 &gt;= v1) goto :cond_1 v3 = p0[v2]; String v3 = v3.toCharsString() String v4 = net.idik.lib.cipher.so.CipherClient.a() v3 = v3.contains(v4) }TRY_0 catch TRY_0 (android/content/pm/PackageManager$NameNotFoundException) goto :catch_0; if (v3 == 0) goto :cond_0 p1 = 0x1; return p1; :cond_0 v2 = v2 + 0x1; goto :goto_0 :catch_0 p0 = Thrown Exception p1.printStackTrace() :cond_1 return v0; }</span></span></code> </pre> <br>  É assim que o pseudocódigo gerado se parece com minhas edições menores.  Confunde algumas coisas: <br><br><ul><li>  pouco conhecimento de criptografia e a "cozinha" dos certificados do dispositivo <br></li><li>  de acordo com a documentação, esse método não garante a ordem dos certificados na coleção retornada e, portanto, não seria possível fazer um loop na mesma ordem - e se o aplicativo fosse assinado com mais de um certificado? <br></li><li>  falta de conhecimento sobre como extrair o certificado do APK, já que não está claro o que o Android Runtime faz neste caso <br></li></ul><br>  Eu tive que me aprofundar em todos esses problemas e o resultado foi o seguinte: <br><br><ul><li>  o próprio certificado está no diretório <i>original / META-INF / CERT.RSA</i> <i><br></i> <br>  neste diretório, existe apenas um arquivo com esta extensão - o que significa que o aplicativo é assinado com apenas um certificado <br></li><li>  No site sobre engenharia de pesquisa de aplicativos Android, foi encontrada uma lista que pode extrair a assinatura necessária como o Android.  Segundo o autor, pelo menos. <br></li></ul><br>  Ao executar esse código, posso descobrir a assinatura e, na realidade, a chave que precisamos é uma substring.  Vá em frente.  A Solução Simples # 2 está sendo varrida. <br><br>  De fato, a chave está no certificado, resta apenas entender o que vem a seguir, porque se tivermos a chave de "usuário", todos receberemos uma assinatura zero e, como aprendemos acima, esta é a resposta errada. <br><br><h2>  Escreva a documentação com cuidado! </h2><br>  Pesquisas adicionais sobre o fato de os dados inseridos nos campos de texto serem alterados são descartadas por falta de evidência.  A paranóia rola com vigor renovado: talvez o código que retirou a assinatura do certificado esteja incorreto ou seja uma implementação de código para versões antigas do Android?  Abro a documentação novamente e vejo o seguinte: ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://developer.android.com/reference/android/content/pm/Signature.html#toChars ()</a> ): <br><br><img src="https://lh5.googleusercontent.com/1TZ3rj6hzTEWw5YHEl1EWnANjsiqpzGR-tTrXP_Nc6jt42ANPf1QW-fmP-mh7Y2MhgMcZF0Z8CpskzT_ge65C0YCcryiWjjpG0UuPeqkUCsde1qcQgm5NbeqFj4KO3QkdtvHM3v2"><br><br>  <b>Nota: a</b> função codifica a assinatura como texto ASCII.  A saída que recebi acima foi uma representação hexadecimal dos dados.  Essa API me pareceu estranha, mas se você acredita na documentação, acontece que fiquei paralisada novamente e a chave criptografada não é uma substring da assinatura.  Depois de ficar pensando um pouco no código por um tempo, não aguentei mais e abri o código-fonte para esta classe.  <a href="">https://android.googlesource.com/platform/frameworks/base/+/e639da7/core/java/android/content/pm/Signature.java</a> <br><br>  A resposta não demorou a chegar.  E, na verdade, no próprio código - uma pintura a óleo: o formato de saída é uma sequência hexadecimal comum.  E agora pense: ou eu não entendo alguma coisa ou a documentação está escrita "ligeiramente" incorretamente.  Tendo repreendido de maneira alguma, comecei a trabalhar novamente. <br><br><h2>  Sumário </h2><br>  As seguintes n horas se passaram: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verificar a correção do trabalho no código com o RecyclerView e verificar seu comportamento através do código-fonte desde </font><font style="vertical-align: inherit;">Novamente, nem todos os pontos são abordados em detalhes no dock e mesmo no Stackoverflow</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descompilação manual do fragmento de código responsável por assinar a coleção no Java compilado. </font><font style="vertical-align: inherit;">Eu assumi a suposição de que ainda perdi algo e a primeira chave no contêiner ("usuário") foi eliminada implicitamente da coleção. </font><font style="vertical-align: inherit;">Decidi definir o restante dos dados no código.</font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em geral, esse código se recusou a assinar até os argumentos restantes (além disso, ao trabalhar com criptografia, esses argumentos me jogaram implicitamente à distância). </font></font><br><br>  Não.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acabou que você não pode assinar esta entrada. Infelizmente, não poderei aprovar este trabalho e descobrir se realmente é assim. Que pena. Por um tempo, ocupou meus pensamentos, mas me tranquilizei de ter feito tudo o que pude. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na verdade, passei muito tempo nessa tarefa e, ao mesmo tempo, na restauração de lacunas de conhecimento. Foi realmente útil. Você pode rastrear todo o caminho e prestar atenção em como eu me apeguei a partes absolutamente não-decisórias. Talvez isso ajude alguém a entender como os iniciantes resolvem problemas desse tipo, porque geralmente lemos “histórias de sucesso”, onde todas as etapas são lógicas, consistentes e levam ao resultado certo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se alguém quiser tentar aprofundar um pouco mais essa tarefa ou fazer uma pergunta - escreva-me no mensageiro azul </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arturbrsg</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fique atento.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt450394/">https://habr.com/ru/post/pt450394/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt450374/index.html">Placa de expansão RAM para Apple IIgs</a></li>
<li><a href="../pt450376/index.html">Como o Yandex.Taxi procura carros quando não estão</a></li>
<li><a href="../pt450378/index.html">GitLab 11.10</a></li>
<li><a href="../pt450384/index.html">A história de um pequeno estudo de código legado</a></li>
<li><a href="../pt450386/index.html">Interfaces como tipos de dados abstratos no Go</a></li>
<li><a href="../pt450396/index.html">Como melhorar o seu inglês escrito: dicas práticas e ferramentas úteis</a></li>
<li><a href="../pt450398/index.html">Os venenos mais destemidos</a></li>
<li><a href="../pt450410/index.html">Terraformer - Infraestrutura para codificar</a></li>
<li><a href="../pt450416/index.html">Como os provedores de VPN de shareware vendem seus dados</a></li>
<li><a href="../pt450418/index.html">A arte de criar modelos 3D orgânicos: Shaders subdérmicos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>