<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÆ üëåüèø üöà Analisador inteligente para um n√∫mero escrito em palavras üïü üë©üèΩ‚Äçüî¨ üßôüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√≥logo 


 Boa tarde, queridos leitores. Neste artigo, falarei sobre como analisar um n√∫mero escrito em palavras em russo. 


 Inteligente, esse anal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analisador inteligente para um n√∫mero escrito em palavras</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453642/"><img src="https://habrastorage.org/webt/x_/al/d2/x_ald2dbs-mrb8gyk1v9z7fzk9w.png"><br><br><h1>  Pr√≥logo </h1><br><p>  Boa tarde, queridos leitores.  Neste artigo, falarei sobre como analisar um n√∫mero escrito em palavras em russo. </p><br><p>  Inteligente, esse analisador permite extrair n√∫meros do texto com erros cometidos como resultado de entrada incorreta ou como resultado do reconhecimento √≥ptico de texto de uma imagem (OCR). </p><br><p>  Para os pregui√ßosos: <br>  Link para o projeto github: <a href="">link</a> . </p><br><a name="habracut"></a><br><h1>  Do algoritmo ao resultado </h1><br><p>  Esta se√ß√£o ir√° descrever os algoritmos usados.  Cuidado, muitas cartas! </p><br><h2>  Declara√ß√£o do problema </h2><br><p> No trabalho, preciso reconhecer o texto de um documento impresso fotografado com uma c√¢mera de smartphone / tablet.  Devido ao contrato de n√£o divulga√ß√£o, n√£o posso dar um exemplo de fotografia, mas o ponto √© que o documento possui uma tabela na qual determinados indicadores s√£o escritos em n√∫meros e em palavras, e esses dados devem ser lidos.  A an√°lise de texto em palavras √© necess√°ria como uma ferramenta de valida√ß√£o adicional para garantir que o n√∫mero seja reconhecido corretamente.  Mas, como voc√™ sabe, o OCR n√£o garante reconhecimento preciso de texto.  Por exemplo, o n√∫mero vinte, escrito em palavras, pode ser reconhecido como "dvupat" ou mesmo como "dvupat".  √â necess√°rio levar isso em conta e extrair a quantidade m√°xima de informa√ß√µes, avaliando a magnitude do poss√≠vel erro. </p><br><p>  <b>Nota</b>  Para reconhecimento de texto, eu uso o tesseract 4. Para o .NET, n√£o existe um pacote NuGet pronto para a quarta vers√£o, ent√£o criei um do ramo principal do projeto, que pode ser √∫til: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Genesis.Tesseract4</a> . </p><br><br><h2>  Algoritmo b√°sico de an√°lise de n√∫meros </h2><br><p>  Vamos come√ßar com um simples, ou seja, com um algoritmo de reconhecimento de texto escrito em palavras, at√© o momento sem erros.  Se voc√™ estiver interessado em an√°lise inteligente, pule esta se√ß√£o. </p><br><p>  Eu n√£o sou particularmente bom em pesquisar no Google, por isso n√£o encontrei imediatamente um algoritmo pronto para resolver esse problema.  No entanto, isso √© ainda melhor, porque  um algoritmo inventado por n√≥s mesmos oferece mais espa√ßo para codifica√ß√£o.  E a tarefa em si acabou sendo interessante. </p><br><p>  Ent√£o, vamos pegar um n√∫mero pequeno, por exemplo, "cento e vinte e tr√™s".  Consiste em tr√™s palavras ( <i>tokens</i> ), cada uma das quais corresponde a um n√∫mero, todos esses n√∫meros s√£o resumidos: </p><br> <code>"  " =  +  +  = 100 + 20 + 3 = 123</code> <br> <br><p>  At√© agora, tudo √© simples, mas aprofundamos, por exemplo, o n√∫mero "duzentos e doze mil cento e cinco". </p><br> <code>"    " = ( + ) √ó  + ( + ) = 212 * 1.000 + 105 = 212.105.</code> <br> <br><p>  Como voc√™ pode ver, quando existem milhares no n√∫mero (al√©m de milh√µes e outros graus de mil), o n√∫mero √© dividido em partes que consistem em um pequeno n√∫mero local, no exemplo acima - 212, e um fator (1000).  Pode haver v√°rios desses fragmentos, mas todos eles v√£o na ordem decrescente do multiplicador, por exemplo, mil ou mil n√£o podem seguir mil.  Isso tamb√©m se aplica a partes de um n√∫mero pequeno, uma vez que centenas n√£o podem seguir centenas e dezenas de dezenas, portanto a entrada "cento e quinhentos" est√° incorreta.  Chamaremos uma caracter√≠stica que relaciona dois tokens do mesmo tipo de <i>n√≠vel</i> , por exemplo, os "cem" e "trezentos" tokens t√™m um n√≠vel, e √© maior que o "cinquenta" token. </p><br><p>  A partir dessas considera√ß√µes, nasce a id√©ia de um algoritmo.  Vamos escrever todos os tokens poss√≠veis ( <i>amostras</i> ), cada um dos quais atribuiremos um n√∫mero, bem como dois par√¢metros - o n√≠vel e o sinal do multiplicador. </p><br><div class="scrollable-table"><table><tbody><tr><th>  Token </th><th>  N√∫mero </th><th>  N√≠vel </th><th>  Multiplicador? </th></tr><tr><td>  zero <br></td><td>  0 0 <br></td><td>  1 <br></td><td>  n√£o <br></td></tr><tr><td>  √∫nico / √∫nico <br></td><td>  1 <br></td><td>  1 <br></td><td>  n√£o <br></td></tr><tr><td>  dois / dois <br></td><td>  2 <br></td><td>  1 <br></td><td>  n√£o <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  1 <br></td><td>  n√£o <br></td></tr><tr><td>  dezenove <br></td><td>  19 <br></td><td>  1 <br></td><td>  n√£o <br></td></tr><tr><td>  vinte <br></td><td>  20 <br></td><td>  2 <br></td><td>  n√£o <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  2 <br></td><td>  n√£o <br></td></tr><tr><td>  noventa <br></td><td>  90 <br></td><td>  2 <br></td><td>  n√£o <br></td></tr><tr><td>  cem <br></td><td>  100 <br></td><td>  3 <br></td><td>  n√£o <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  3 <br></td><td>  n√£o <br></td></tr><tr><td>  novecentos <br></td><td>  900 <br></td><td>  3 <br></td><td>  n√£o <br></td></tr><tr><td>  mil / mil / mil <br></td><td>  1.000 <br></td><td>  4 <br></td><td>  sim <br></td></tr><tr><td>  milh√£o / milh√£o / milh√£o <br></td><td>  1.000.000 <br></td><td>  5 <br></td><td>  sim <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  ... <br></td><td>  sim <br></td></tr><tr><td>  quadrilh√£o / quadrilh√£o / quadrilh√£o <br></td><td>  1.000.000.000.000.000 <br></td><td>  8 <br></td><td>  sim <br></td></tr></tbody></table></div><br><p>  De fato, voc√™ pode adicionar outros tokens a esta tabela, inclusive para idiomas estrangeiros, mas n√£o se esque√ßa de que em alguns pa√≠ses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√© usado um sistema de nomea√ß√£o</a> longo, e n√£o curto. </p><br><p>  Agora vamos para a an√°lise.  Obteremos quatro quantidades: </p><br><ol><li>  <i>N√≠vel global</i> (globalLevel).  Indica o n√≠vel do √∫ltimo multiplicador.  Inicialmente indefinido e necess√°rio para o controle.  Se encontrarmos um token multiplicador cujo n√≠vel √© maior ou igual ao global, isso √© um erro. </li><li>  <i>Valor global</i> (globalValue).  O somador total, em que o resultado √© o resultado da multiplica√ß√£o do n√∫mero e fator local. </li><li>  <i>N√≠vel local</i> (localLevel).  Indica qual o n√≠vel do √∫ltimo token.  Inicialmente indefinido, funciona de maneira semelhante ao n√≠vel global, mas √© redefinido ap√≥s a descoberta do multiplicador. </li><li>  <i>Valor local</i> (localValue)  Um somador de tokens n√£o multiplicador, ou seja,  n√∫meros at√© 999. </li></ol><br><p>  O algoritmo √© o seguinte: </p><br><ol><li>  Divida a string em tokens usando o "\ s +" regular. </li><li>  Tomamos o pr√≥ximo token, obtemos informa√ß√µes sobre ele a partir da amostra. </li><li>  Se for um multiplicador: <br><ul><li>  Se o n√≠vel global estiver definido, garantiremos que seja maior ou igual ao n√≠vel do token.  Caso contr√°rio, isso √© um erro; o n√∫mero est√° incorreto. </li><li>  Defina o n√≠vel global para o n√≠vel do token atual. </li><li>  Multiplique o valor do token pelo valor local e adicione o resultado ao valor global. </li><li>  Limpamos o valor e o n√≠vel local. </li></ul></li><li>  Se este n√£o for um multiplicador: <br><ul><li>  Se o n√≠vel local estiver definido, garantiremos que seja maior ou igual ao n√≠vel do token.  Caso contr√°rio, isso √© um erro; o n√∫mero est√° incorreto. </li><li>  Defina o n√≠vel local para o n√≠vel do token atual. </li><li>  Adicione o valor do token ao valor local. </li></ul></li><li>  Retornamos o resultado como a soma dos valores globais e locais. </li></ol><br><p>  Um exemplo de trabalho para o n√∫mero "dois milh√µes duzentos e doze mil cento e oitenta e cinco". </p><br><div class="scrollable-table"><table><tbody><tr><th>  Token <br></th><th>  globalLevel <br></th><th>  globalValue <br></th><th>  localLevel <br></th><th>  localValue <br></th></tr><tr><td></td><td>  - <br></td><td>  - <br></td><td>  - <br></td><td>  - <br></td></tr><tr><td>  dois <br></td><td>  - <br></td><td>  - <br></td><td>  1 <br></td><td>  2 <br></td></tr><tr><td>  milh√µes <br></td><td>  5 <br></td><td>  2.000.000 <br></td><td>  - <br></td><td>  - <br></td></tr><tr><td>  duzentos <br></td><td>  5 <br></td><td>  2.000.000 <br></td><td>  3 <br></td><td>  200 <br></td></tr><tr><td>  doze <br></td><td>  5 <br></td><td>  2.000.000 <br></td><td>  1 <br></td><td>  212 <br></td></tr><tr><td>  mil <br></td><td>  4 <br></td><td>  2.212.000 <br></td><td>  - <br></td><td>  - <br></td></tr><tr><td>  cem <br></td><td>  4 <br></td><td>  2.212.000 <br></td><td>  3 <br></td><td>  100 <br></td></tr><tr><td>  oitenta <br></td><td>  4 <br></td><td>  2.212.000 <br></td><td>  2 <br></td><td>  180 <br></td></tr><tr><td>  cinco <br></td><td>  4 <br></td><td>  2.212.000 <br></td><td>  1 <br></td><td>  185 <br></td></tr></tbody></table></div><p>  O resultado ser√° 2.212.185. </p><br><h2>  An√°lise inteligente </h2><br><p>  Esse algoritmo pode ser usado para implementar outras compara√ß√µes, e n√£o apenas para analisar n√∫meros, por esse motivo, tentarei descrev√™-lo com mais detalhes. </p><br><p>  Com a an√°lise do n√∫mero escrito corretamente, descobri.  Agora, vamos pensar em quais erros podem ocorrer se o n√∫mero obtido como resultado do OCR for gravado incorretamente.  N√£o considero outras op√ß√µes, mas voc√™ pode modificar o algoritmo para uma tarefa espec√≠fica. </p><br><p>  Eu identifiquei tr√™s tipos de erros que encontrei no processo de trabalho: </p><br><ol><li>  Substitua os caracteres por outros com um estilo semelhante.  Por exemplo, a letra "c" √© por algum motivo substitu√≠da por "p" e "n" por "e" e vice-versa.  Ao usar a terceira vers√£o do tesseract, √© poss√≠vel substituir a letra ‚Äúo‚Äù por zero.  Esses erros, de imediato, s√£o os mais comuns e requerem ajuste para uma biblioteca de reconhecimento espec√≠fica.  Portanto, os princ√≠pios de trabalho das vers√µes 3 e 4 do tesseract t√™m diferen√ßas importantes, portanto os erros ser√£o diferentes. <br></li><li>  Mesclagem de token.  As palavras podem se fundir (ainda n√£o encontraram o oposto).  Em combina√ß√£o com o primeiro erro, gera frases demon√≠acas como "duplo".  Vamos tentar demonizar esses monstros tamb√©m. <br></li><li>  Ru√≠do - caracteres e frases deixados no texto.  Infelizmente, h√° pouco que pode ser feito no momento, mas h√° uma perspectiva ao coletar estat√≠sticas suficientemente significativas. <br></li></ol><br><p>  Ao mesmo tempo, o algoritmo de an√°lise descrito acima quase n√£o muda, a principal diferen√ßa est√° na quebra da string em tokens. </p><br><p>  Mas vamos come√ßar coletando algumas estat√≠sticas sobre o uso de letras em tokens.  Das 33 letras do idioma russo, apenas 20 s√£o usadas ao escrever n√∫meros inteiros n√£o negativos, vamos cham√°-los de <i>boas letras</i> : </p><br> <code></code> <br> <br><p>  Os 13 restantes, respectivamente, ser√£o chamados de <i>letras ruins</i> .  O tamanho m√°ximo do token √© de 12 caracteres (13 ao contar at√© quatrilh√µes).  Substrings maiores que esse valor devem ser divididos. </p><br><p>  Para comparar strings e tokens, decidi usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o algoritmo Wagner-Fisher</a> , embora o chamasse de nome de Levenshtein no c√≥digo.  Como n√£o preciso de uma instru√ß√£o editorial, implementei uma vers√£o do algoritmo compat√≠vel com a mem√≥ria.  Devo admitir que a implementa√ß√£o desse algoritmo acabou sendo uma tarefa mais dif√≠cil do que o pr√≥prio analisador. </p><br><p>  Um pequeno programa educacional: a dist√¢ncia de Levenshtein √© um caso especial do algoritmo Wagner-Fisher, quando o custo de inser√ß√£o, exclus√£o e substitui√ß√£o de caracteres √© est√°tico.  Isso n√£o √© assim em nossa tarefa.  Obviamente, se encontrarmos uma letra ruim em uma substring, ela precisar√° ser substitu√≠da por uma boa letra, mas substituir uma boa por uma ruim √© extremamente indesej√°vel.  De um modo geral, √© imposs√≠vel, mas a situa√ß√£o depende da tarefa espec√≠fica. </p><br><p>  Para descrever o custo de inser√ß√£o, exclus√£o e substitui√ß√£o de caracteres, criei uma tabela como esta: um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link para uma tabela com pesos</a> .  Embora seja preenchido com o m√©todo dos tr√™s P (sexo, dedo, teto), mas se voc√™ o preencher com dados baseados em estat√≠sticas de OCR, poder√° melhorar significativamente a qualidade do reconhecimento de n√∫meros.  O c√≥digo da biblioteca cont√©m o arquivo de recurso NumeralLevenshteinData.txt, no qual voc√™ pode inserir dados de uma tabela semelhante usando Ctrl + A, Ctrl + C e Ctrl + V. </p><br><p>  Se um caractere que n√£o seja de tabela for encontrado no texto, por exemplo, zero, o custo de inseri-lo ser√° igual ao valor m√°ximo da tabela e o custo de exclus√£o e substitui√ß√£o ser√° igual ao m√≠nimo, portanto, o algoritmo substituir√° zero pela letra "o" e, se voc√™ usar a terceira vers√£o do tesseract , fa√ßa sentido adicionar zero √† tabela e escrever o pre√ßo m√≠nimo para substitu√≠-lo pela letra "o". </p><br><p>  Ent√£o, preparamos os dados para o algoritmo Wagner-Fisher, vamos fazer altera√ß√µes no algoritmo para dividir a string em tokens.  Para fazer isso, passaremos por uma an√°lise adicional de cada token, mas antes disso expandiremos as informa√ß√µes sobre o token com as seguintes caracter√≠sticas: </p><br><ul><li>  <i>N√≠vel de erro</i> .  Um n√∫mero real de 0 (sem erro) a 1 (o token est√° incorreto), o que significa qu√£o bem o token foi comparado com a amostra. <br></li><li>  <i>Um sinal de uso de um token</i> .  Ao analisar uma sequ√™ncia com detritos intercalados, parte dos tokens ser√° descartada, pois esse atributo n√£o ser√° definido.  Nesse caso, o valor total do erro ser√° considerado como a m√©dia aritm√©tica dos erros dos tokens usados. <br></li></ul><br><p>  Algoritmo de an√°lise de token: </p><br><ol><li>  Estamos tentando encontrar o token na tabela como est√°.  Se encontrarmos - tudo est√° bem, devolva-o. </li><li>  Caso contr√°rio, fa√ßa uma lista de op√ß√µes poss√≠veis: </li><li><p>  Estamos tentando combinar o token com a amostra usando o algoritmo Wagner-Fisher.  Esta op√ß√£o consiste em um token (amostra mapeada) e seu erro √© igual √† melhor dist√¢ncia dividida pelo comprimento da amostra. </p><br>  <b>Exemplo: o</b> token "zero" √© comparado com a amostra "zero", enquanto a dist√¢ncia √© 0,5, porque  o custo de substituir a letra incorreta ‚Äúy‚Äù por um bom ‚Äúo‚Äù √© 0,5.  O erro total para este token ser√° 0,5 / 4 = 0,125. <br></li><li><p>  Se a substring for grande o suficiente (eu tenho 6 caracteres), tentaremos dividi-lo em duas partes de pelo menos 3 caracteres em cada.  Para uma sequ√™ncia de 6 caracteres, haver√° uma √∫nica divis√£o: 3 + 3 caracteres.  Para uma sequ√™ncia de 7 caracteres - j√° existem duas op√ß√µes, 3 + 4 e 4 + 3, etc.  Para cada uma das op√ß√µes, chamamos a mesma fun√ß√£o de an√°lise de token recursivamente, inserimos as op√ß√µes recebidas na lista. </p><br><p>  Para n√£o morrer em recurs√£o, determinamos o n√≠vel m√°ximo de falha.  Al√©m disso, as op√ß√µes obtidas como resultado da divis√£o s√£o artificialmente degradadas por uma certa quantidade (op√ß√£o, por padr√£o 0,1), para que a op√ß√£o de compara√ß√£o direta seja mais valiosa.  Eu tive que adicionar essa opera√ß√£o, porque  subetapas do tipo "duplo" foram divididas com sucesso em tokens "dois" e "cinco" e n√£o foram reduzidas a "vinte".  Infelizmente, esses s√£o os recursos do idioma russo. </p><br><p>  <b>Exemplo: o</b> token "duplo" tem uma compara√ß√£o direta com a amostra "vinte", erro 0,25.  Al√©m disso, a melhor op√ß√£o para dividir √© "dois" + "cinco" com um custo de 0,25 (substituindo "a" por "i"), artificialmente piorado para 0,35, como resultado do qual o token "vinte" √© preferido. </p><br></li><li>  Ap√≥s compilar todas as op√ß√µes, selecionamos a melhor pela quantidade m√≠nima de erros dos tokens participantes.  O resultado √© retornado. </li></ol><br><p>  Al√©m disso, a verifica√ß√£o do token √© introduzida no algoritmo principal de gera√ß√£o de n√∫mero, para que o erro n√£o exceda um determinado valor (op√ß√£o, padr√£o 0,67).  Com isso, filtramos o lixo em potencial, embora n√£o com muito sucesso. </p><br><h2>  O algoritmo em poucas palavras para aqueles que estavam com pregui√ßa de ler o texto acima </h2><br><p>  Dividimos a sequ√™ncia de entrada que representa o n√∫mero em palavras em substrings usando a regularidade \ s +, depois tentamos combinar cada substring com tokens de amostra ou dividi-lo em substrings menores, escolhendo os melhores resultados.  Como resultado, obtemos um conjunto de tokens pelos quais geramos um n√∫mero e o valor do erro √© considerado a m√©dia aritm√©tica dos erros entre os tokens usados ‚Äã‚Äãna gera√ß√£o. </p><br><h2>  Aprimorando um algoritmo para uma tarefa espec√≠fica </h2><br><p>  Na minha tarefa, os n√∫meros n√£o s√£o negativos e s√£o relativamente pequenos, portanto, excluirei tokens desnecess√°rios do "milh√£o" e superior.  Para o teste, queridos leitores, ao contr√°rio, adicionei tokens de jarg√£o adicionais, que permitiam analisar seq√º√™ncias de caracteres como ‚Äúcinco pe√ßas‚Äù, ‚Äúcortar duzentas‚Äù e at√© ‚Äútr√™s stolniks e duas pe√ßas de ouro‚Äù.  √â engra√ßado, mas nem sequer exigiu altera√ß√µes no algoritmo. </p><br><h2>  Melhoria adicional </h2><br><p>  O algoritmo existente possui falhas: </p><br><ol><li>  <b>Controle de caso.</b>  As cadeias "dois mil" e "dois mil" ser√£o reconhecidas com erro zero como 2000. Na minha tarefa, o controle de caso n√£o √© necess√°rio, √© at√© prejudicial, mas se voc√™ precisar dessa fun√ß√£o, isso ser√° resolvido com a introdu√ß√£o de um sinalizador adicional no token, respons√°vel pelo caso do pr√≥ximo token . <br></li><li>  <b>N√∫meros negativos.</b>  Um token negativo adicional √© introduzido com processamento especial.  Nada complicado, mas n√£o esque√ßa que a letra ‚Äúy‚Äù √© ruim e n√£o ocorre nos n√∫meros; voc√™ precisar√° alterar suas caracter√≠sticas de peso ou torcer para que n√£o mude durante o processo de OCR. <br></li><li>  <b>N√∫meros fracion√°rios.</b>  Isso √© resolvido substituindo o tipo longo por um duplo e introduzindo s√≠mbolos de "d√©cimos", "cent√©simos", etc. ... N√£o se esque√ßa de revisar a escala das letras. <br></li><li>  <b>Reconhecimento de n√∫meros inseridos pelos usu√°rios.</b>  Porque  Ao digitar texto manualmente, geralmente cometemos erros relacionados √† reedi√ß√£o do siVMolov, voc√™ deve adicionar esta opera√ß√£o ao algoritmo Wagner-Fisher. <br></li><li>  <b>Suporte para outros idiomas.</b>  Introduzimos novos tokens, expandimos a tabela de pesos. <br></li><li>  <b>Manuseio de lixo.</b>  Em alguns documentos, os dados s√£o impressos, a qualidade da imagem pode ser ruim, a c√©lula pode estar muito vazia.  Nesse caso, o lixo que precisa ser limpo de alguma forma entra na linha.  O melhor que posso oferecer no momento √© pr√©-processar o documento antes do OCR.  Remover as linhas da tabela e preench√™-las com uma cor pr√≥xima √† cor do espa√ßo livre da c√©lula me ajudou muito.  Isso n√£o resolveu todos os problemas, mas melhorou a qualidade do reconhecimento de texto de documentos em que a tabela apresentava curvaturas devido a ferimentos no documento ou a um fot√≥grafo distorcido.  Idealmente, voc√™ deve girar a pr√≥pria c√©lula e reconhec√™-la separadamente, se voc√™, √© claro, tem uma mesa. <br></li></ol><br><h1>  Ent√£o, qual √© o resultado final? </h1><br><p>  O projeto possui um exemplo de aplicativo de console em execu√ß√£o no arquivo samples.txt com exemplos para o analisador.  Aqui est√° uma captura de tela dos resultados: </p><br><img src="https://habrastorage.org/webt/fq/ed/ac/fqedacgduf7tewa8tvg-tn6zv3s.png"><br><br><p>  Encarrego-o de avaliar o resultado, mas quanto a mim, n√£o √© ruim.  O erro para exemplos de reconhecimento real n√£o excede 0,25, embora eu ainda n√£o tenha executado todo o conjunto de documentos dispon√≠veis, provavelmente nem tudo ser√° t√£o f√°cil l√°. </p><br><p>  Quanto √† √∫ltima se√ß√£o, eu sempre me perguntava o quanto isso √© "dofiga".  Al√©m disso, o programa deu uma resposta adequada ao quanto √© preciso levar (n√£o uso, mas ainda assim) e at√© mesmo determinou com precis√£o o significado da antiga palavra russa "escurid√£o".  E sim, a conclus√£o n√£o incluiu mais uma medida que a educa√ß√£o n√£o permitiu acrescentar, mas o programa acredita que √© igual a mil =) </p><br><h1>  Algumas palavras sobre a biblioteca </h1><br><p>  Inicialmente, meus planos n√£o inclu√≠am a cria√ß√£o de uma biblioteca, decidi projet√°-la exclusivamente para um Habr.  Tentei colocar o c√≥digo em ordem, mas se voc√™ o usar, fa√ßa um garfo ou uma c√≥pia, como  provavelmente voc√™ n√£o precisar√° de jarg√µes e outros tokens inclu√≠dos nos exemplos. </p><br><p>  A pr√≥pria biblioteca √© escrita no .NET Standart 2.0 e C # 7.x, e os algoritmos s√£o facilmente traduzidos para outros idiomas. </p><br><p>  No caso de uma poss√≠vel expans√£o da biblioteca, adicionarei a composi√ß√£o dos componentes importantes do analisador de n√∫meros em palavras (espa√ßo de nome Genesis.CV.NumberUtils): </p><br><ul><li>  RussianNumber.cs - analisador diretamente </li><li>  RussianNumber.Data.cs - arquivo com descri√ß√£o de tokens </li><li>  RussianNumber.ToString.cs - n√∫mero para conversor de texto em palavras </li><li>  RussianNumberParserOptions.cs - op√ß√µes de analisador </li><li>  NumeralLevenshtein.cs - implementa√ß√£o do algoritmo Wagner-Fisher </li><li>  NumeralLevenshteinData.txt - recurso, dados de pondera√ß√£o de letras </li></ul><br><p>  Uso: </p><br><ul><li>  RussianNumber.ToString (valor) - converte um n√∫mero em texto </li><li>  RussianNumber.Parse (valor, [op√ß√µes]) - converte texto em n√∫mero </li></ul><br><h1>  Conclus√£o </h1><br><p>  Eu realmente espero que o artigo n√£o pare√ßa chato para voc√™, apesar da abund√¢ncia de texto.  Recentemente, criei v√°rios t√≥picos relacionados √† vis√£o computacional, sobre os quais h√° algo a dizer, ent√£o gostaria de saber uma opini√£o sobre esse formato de artigo.  O que vale a pena adicionar ou, inversamente, remover?  O que √© mais interessante para voc√™, leitores, os pr√≥prios algoritmos ou os fragmentos de c√≥digo? </p><br><p>  Voc√™ gosta do artigo?  Confira os outros: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classe JavaScript Suporte √† serializa√ß√£o de JavaScript</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Preenchendo modelos de texto com dados baseados em modelo.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Implementa√ß√£o .NET usando fun√ß√µes din√¢micas de bytecode (IL)</a> <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt453642/">https://habr.com/ru/post/pt453642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt453618/index.html">Como trabalhamos com id√©ias e como nasceu a LANBIX</a></li>
<li><a href="../pt453622/index.html">Programador de chips G-Shield: escrevendo certificados digitais para chips na fase de produ√ß√£o</a></li>
<li><a href="../pt453626/index.html">Aventuras em um fluxo separado. Relat√≥rio Yandex</a></li>
<li><a href="../pt453628/index.html">Quanto voc√™ pagar√° em 20 anos?</a></li>
<li><a href="../pt453634/index.html">Escola de An√°lise de Sistemas do Banco Alfa</a></li>
<li><a href="../pt453644/index.html">Entrevista - 10 perguntas sobre Swift. Parte 3</a></li>
<li><a href="../pt453646/index.html">Normaliza√ß√£o de dados em banco de dados distribu√≠do, microsservi√ßos e ERP</a></li>
<li><a href="../pt453650/index.html">N√∫cleo de software da infraestrutura cibern√©tica a bordo do ca√ßa unificado F-35</a></li>
<li><a href="../pt453652/index.html">LogRock: testando atrav√©s do log</a></li>
<li><a href="../pt453656/index.html">Web est√°tica: de volta ao b√°sico?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>