<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👃🏽 👩🏿‍🤝‍👨🏾 🌧️ HolyJS 2019：SEMrush的汇报（第2部分） 🈺 👂🏿 ☄️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="这是5月24日至25日在圣彼得堡举行的HolyJS会议摊位上的任务分析的第二部分。 对于较大的上下文，建议您首先阅读本材料的第一部分 。 如果倒计时表达式已经完成，则欢迎进行下一步。 

 与第一个任务中的晦涩难懂不同，后两个任务已经暗示了正常应用程序在生活中的适用性。 JavaScript仍在快速...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>HolyJS 2019：SEMrush的汇报（第2部分）</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/semrush/blog/453466/"><img src="https://habrastorage.org/webt/lu/af/0g/luaf0gd14raqav4knnokeboltkk.jpeg"><br><br> 这是5月24日至25日在圣彼得堡举行的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HolyJS</a>会议摊位上的任务分析的第二部分。 对于较大的上下文，建议您首先阅读本材料的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一部分</a> 。 如果<i>倒计时表达式</i>已经完成，则欢迎进行下一步。 <br><a name="habracut"></a><br> 与第一个任务中的晦涩难懂不同，后两个任务已经暗示了正常应用程序在生活中的适用性。  JavaScript仍在快速发展，针对所建议问题的解决方案突出了该语言的一些新功能。 <br><br><h2> 任务2〜完成 </h2><br> 假定代码将响应三个请求而执行并向控制台输出答案，然后“完成”。 但是出了点问题。纠正情况。 <br><br><pre><code class="javascript hljs">;(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iter = { [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.iterator]: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fs = [<span class="hljs-string"><span class="hljs-string">'/1'</span></span>, <span class="hljs-string"><span class="hljs-string">'/2'</span></span>, <span class="hljs-string"><span class="hljs-string">'/3'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> req <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fs) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetch(req); } } }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> iter) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'done'</span></span>); })();</code> </pre> <br><h4> 研究问题 </h4><br> 我们这里有什么？ 这是一个<i>可迭代的</i> <i>iter</i>对象，它具有通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">generator函数</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i>定义</i></a> <i>的众所周知的</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i>Symbol.iterator</i></a>符号。 在函数主体中声明了数组<i>fs</i> ，该数组的元素依次属于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i>fetch</i></a>函数以发送请求，并且每个函数调用的结果通过<i>yield</i>返回。  <i>提取</i>功能发送什么请求？  <i>fs</i>数组的所有元素都是到数字分别为1、2和3的资源的相对路径。 因此，完整的URL将通过将<i>location.origin</i>与下一个数字连接而获得，例如： <br><br> <code>GET https://www.example.com/1 <br></code> <br> 接下来，我们要通过<i>for-of</i>迭代<i>iter</i>对象，以便依次执行每个请求以及结果的输出-毕竟-打印“ done”。 但这不起作用！ 问题在于， <i>获取</i>是异步的，它返回一个承诺，而不是响应。 因此，在控制台中，我们将看到以下内容： <br><br> <code>Promise {pending} <br> Promise {pending} <br> Promise {pending} <br> done <br></code> <br> 实际上，任务归结为解决这些相同的承诺。 <br><br><h4> 我们有异步/等待 </h4><br> 首先想到的可能是与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i>Promise.all</i></a>一起玩：将其赋予我们<i>可迭代的</i>对象， <i>然后</i>将对控制台<i>的</i>输出“完成”。 但是他不会为我们提供顺序执行请求（条件要求）的方法，而只是将它们全部发送出去，并在一般解决方案之前等待最后一个答案。 <br><br> 最简单的解决方案是在<i>for-of</i>正文中等待下一个promise的解析，然后再输出到控制台： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> iter) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> res); }</code> </pre><br> 为了<i>等待</i>工作并在最后显示“完成”，必须通过<i>async</i>使主要功能异步： <br><br><pre> <code class="javascript hljs">;(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iter = { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> iter) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> res); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'done'</span></span>); })();</code> </pre><br> 在这种情况下，问题已经解决（几乎）： <br><br> <code>GET 1st <br> Response 1st <br> GET 2nd <br> Response 2nd <br> GET 3rd <br> Response 3rd <br> done <br></code> <br><h4> 异步迭代器和生成器 </h4><br> 我们将使主函数保持异步状态，但是在<i>等待状态</i>下，此任务比在<i>for-of</i>正文中占有更优雅的位置：这是通过<a href=""><i>for-await-of</i></a>使用异步迭代，即： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> iter) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res); }</code> </pre><br> 一切都会正常！ 但是，如果您转向有关异步迭代的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">该<i>提案</i></a>的描述，那么有趣的是： <br><br><blockquote> 我们介绍了for-of迭代语句的一种变体，它在异步可迭代对象上进行迭代。 异步for-of语句仅在异步函数和异步生成器函数中允许 </blockquote><br> 也就是说，我们的对象不仅应该是<i>可迭代的</i> ，而且还<i>应该</i>通过新<i>的著名</i>符号<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i>Symbol.asyncIterator</i></a>以及在我们的情况下已经是异步生成器函数来<i>“ asyncIterable”</i> ： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iter = { [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.asyncIterator]: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fs = [<span class="hljs-string"><span class="hljs-string">'/1'</span></span>, <span class="hljs-string"><span class="hljs-string">'/2'</span></span>, <span class="hljs-string"><span class="hljs-string">'/3'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> req <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fs) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetch(req); } } };</code> </pre><br> 然后如何在常规迭代器和生成器上工作？ 是的，只是隐式地喜欢这种语言。 这种<i>等待是</i>很棘手的：如果对象仅是<i>可迭代的</i> ，则当异步<i>迭代</i>时，它<i>会</i>通过将<i>Promise中</i>的元素（如有必要）包装为带有解析度的期望而将对象“转换”为<i>asyncIterable</i> 。 他<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Axel Rauschmayer</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的一篇文章中</a>更详细地讲了话。 <br><br> 可能通过<i>Symbol.asyncIterator</i>仍然会更正确，因为我们通过<i>for-await-of</i>显式地为异步迭代创建了<i>asyncIterable</i>对象，同时如有必要，还为<i>for</i>留下了用常规迭代器补充对象的机会。 如果您想在一篇有关JavaScript异步迭代的文章中读到有用且足够的内容，那么<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里就是</a> ！ <br><br> 异步论坛仍处于草稿中，但现代浏览器（Edge除外）和10.x版的Node.js已支持它。 如果这使某人感到困扰，您总是可以为一连串的承诺（例如，针对<i>可迭代的</i>对象）编写自己的小型多义人： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> chain = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">promises, callback</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">it</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = it.next(); i.done ? resolve() : i.value.then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> { callback(res); next(it); }); }(promises[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.iterator]()) ); ;(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iter = { <span class="hljs-comment"><span class="hljs-comment">/* iterable */</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> chain(iter, <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'done'</span></span>); })();</code> </pre><br> 通过这种方式，我们弄清楚了依次发送请求和处理响应。 但是在这个问题上，还有另一个小而烦人的问题... <br><br><h4> 正念测试 </h4><br> 所有这些异步让我们如此疯狂，以至于经常发生的事情，我们忽略了一个小细节。 这些请求是由我们的脚本发送的吗？ 让我们看一下<i>网络</i> ： <br><br> <code>GET https://www.example.com/0 <br> GET https://www.example.com/1 <br> GET https://www.example.com/2 <br></code> <br> 但是我们的数字是1、2、3。 为什么这样 只是在任务的源代码中，迭代还有另一个问题，在这里： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fs = [<span class="hljs-string"><span class="hljs-string">'/1'</span></span>, <span class="hljs-string"><span class="hljs-string">'/2'</span></span>, <span class="hljs-string"><span class="hljs-string">'/3'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> req <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fs) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetch(req); }</code> </pre><br> 这里使用了<i>for-in</i> ，而不是数组值绕过其枚举属性：这些是0到2元素的索引<i>。fetch</i>函数仍然将它们引向字符串，尽管之前没有斜杠（这不再是<i>path</i> ），但它相对解析当前页面的URL。 修复比注意到容易得多。 两种选择： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fs = [<span class="hljs-string"><span class="hljs-string">'/1'</span></span>, <span class="hljs-string"><span class="hljs-string">'/2'</span></span>, <span class="hljs-string"><span class="hljs-string">'/3'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> req <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> fs) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetch(req); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fs = [<span class="hljs-string"><span class="hljs-string">'/1'</span></span>, <span class="hljs-string"><span class="hljs-string">'/2'</span></span>, <span class="hljs-string"><span class="hljs-string">'/3'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> req <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fs) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetch(fs[req]); }</code> </pre><br> 在第一个中，我们使用相同的<i>for-of</i>来遍历数组的值，第二个中-通过索引访问数组元素。 <br><br><h4> 动机 </h4><br> 我们考虑了3个解决方案：1）通过<i>for-for</i>主体<i>中的await</i> ，2）通过<i>for-await-of，</i>以及3）通过我们的polyfile（递归函数， <i>管道</i>管道等）。 很好奇的是，这些选择将会议参加者平均分配，并且没有发现明显的偏爱。 在大型项目中，对于此类实际任务，通常使用反应式库（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RxJS</a> ），但是值得记住具有异步性质的语言的现代本机功能。 <br><br> 大约一半的参与者没有注意到资源列表中的迭代错误，这也是一个有趣的发现。 着眼于一个非平凡但显而易见的问题，我们可以轻松地跳过这个看似微不足道的问题，但可能会带来严重的后果。 <br><br><h2> 问题3〜因子19 </h2><br>  2019年的记录有多少次！  （从2019年起析构）数字19是否会出现？ 连同答案一起，提供一个JavaScript解决方案。 <br><br><h4> 研究问题 </h4><br> 表面上是问题：我们需要一个非常大的记录才能在其中找到子字符串“ 19”的所有出现次数。 解决数字上的问题后，我们很快就遇到了<i>Infinity</i> （170之后），却一无所获。 此外，用于表示数字的格式<i>float64</i>只能保证15-17个字符的准确性，我们不仅需要获取完整的数字，还要获得准确的数字记录。 因此，主要困难是确定用于大量累积的结构。 <br><br><h4> 大整数 </h4><br> 如果您遵循该语言的创新，则可以轻松解决此任务：可以使用新类型<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i>BigInt</i> （第3阶段）</a>代替类型<i>数字，</i>该类型允许您使用任意精度数字。 使用经典的递归函数通过<i>String.prototype.split</i>计算阶乘和查找匹配项<i>，第</i>一个解决方案如下所示： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fn = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>n ? n * fn(n - <span class="hljs-number"><span class="hljs-number">1</span></span>n) : <span class="hljs-number"><span class="hljs-number">1</span></span>n; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn(<span class="hljs-number"><span class="hljs-number">2019</span></span>n).toString().split(<span class="hljs-string"><span class="hljs-string">'19'</span></span>).length - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 50</span></span></code> </pre><br> 但是，在堆栈上进行2000次函数调用可能已经<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">很危险了</a> 。 即使将解决方案引入<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">尾递归</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i>尾调用优化</i></a>仍仅支持Safari。 通过运算周期或<i>Array.prototype.reduce</i>可以解决这里的阶乘问题： <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log([...Array(<span class="hljs-number"><span class="hljs-number">2019</span></span>)].reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p, _, i</span></span></span><span class="hljs-function">) =&gt;</span></span> p * BigInt(i + <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>n).toString().match(<span class="hljs-regexp"><span class="hljs-regexp">/19/g</span></span>).length); <span class="hljs-comment"><span class="hljs-comment">// 50</span></span></code> </pre><br> 这似乎是一个疯狂的漫长过程。 但是这种印象是欺骗性的。 如果您估计，那么我们只需要花费2000多倍就可以了。 在镀铬的i5-4590 3.30GHz上，该问题平均在4-5ms（！）之内解决。 <br><br> 用于查找字符串中具有计算结果的匹配项的另一个选项是通过带有全局搜索标记<i>/ 19 / g的</i>正则表达式来查找<i>String.prototype.match</i> 。 <br><br><h4> 大算术 </h4><br> 但是，如果我们还没有<i>BigInt</i> （还有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">库</a> ）呢？ 在这种情况下，您可以自己执行长算法。 要解决该问题，仅执行大乘小（我们将数字乘以1到2019）就足够了。 例如，我们可以在行中保存大量和乘法结果： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @param {string} big * @param {number} int * @returns {string} */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mult = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">big, int</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = <span class="hljs-string"><span class="hljs-string">''</span></span>, carry = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = big.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; i -= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> prod = big[i] * int + carry; res = prod % <span class="hljs-number"><span class="hljs-number">10</span></span> + res; carry = prod / <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">carry || </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span></span><span class="hljs-function">) + </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">; } </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">console</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[...</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2019</span></span></span></span></span><span class="hljs-function">)].</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reduce</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p, _, i</span></span></span><span class="hljs-function">) =&gt;</span></span> mult(p, i + <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-string"><span class="hljs-string">'1'</span></span>).match(<span class="hljs-regexp"><span class="hljs-regexp">/19/g</span></span>).length); <span class="hljs-comment"><span class="hljs-comment">// 50</span></span></code> </pre><br> 在这里，我们就像在学校教过的那样，简单地将行末尾的行与列的末尾相乘。 但是该解决方案已经需要约170ms。 <br><br> 通过一次处理一个数字记录中的多个数字，我们可以在某种程度上改进算法。 为此，我们修改函数并同时转到数组，以免每次都弄乱行： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @param {Array&lt;number&gt;} big * @param {number} int * @param {number} digits * @returns {Array&lt;number&gt;} */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mult = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">big, int, digits = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = [], carry = <span class="hljs-number"><span class="hljs-number">0</span></span>, div = <span class="hljs-number"><span class="hljs-number">10</span></span> ** digits; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = big.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || carry; i -= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> prod = (i &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : big[i] * int) + carry; res.push(prod % div); carry = prod / div | <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.reverse(); }</code> </pre><br> 在这里，大数由一个数组表示，其每个元素都使用<i>number</i>存储有关<i>数字</i>记录中<i>数字</i>位数的信息。 例如，数字2016201720182019的<i>数字</i> = 3将表示为： <br><br> <code>'2|016|201|720|182|019' =&gt; [2,16,201,720,182,19] <br></code> <br> 在联接之前转换为行时，您需要记住前导零。 在计算时， <i>factor</i>函数使用字符串同时使用指定的数字处理数量的<i>mult</i>函数以字符串形式返回计算的阶乘： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> factor = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n, digits = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> [...Array(n)].reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p, _, i</span></span></span><span class="hljs-function">) =&gt;</span></span> mult(p, i + <span class="hljs-number"><span class="hljs-number">1</span></span>, digits), [<span class="hljs-number"><span class="hljs-number">1</span></span>]) .map(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'0'</span></span>.repeat(digits - el.length) + el) .join(<span class="hljs-string"><span class="hljs-string">''</span></span>) .replace(<span class="hljs-regexp"><span class="hljs-regexp">/^0+/</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(factor(<span class="hljs-number"><span class="hljs-number">2019</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>).match(<span class="hljs-regexp"><span class="hljs-regexp">/19/g</span></span>).length); <span class="hljs-comment"><span class="hljs-comment">// 50</span></span></code> </pre><br> 通过数组实现的“膝长”实现比通过字符串实现的更快，并且在<i>digits</i> = 1的情况下，它平均可以在90ms内计算出答案， <i>digits</i> = 3在35ms内， <i>位数</i> = 6在20ms内即可。 但是，请记住，增加位数会导致“在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i>幕后</i></a> ”将<i>数字</i>乘以<i>数字</i>可能超出安全<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i>MAX_SAFE_INTEGER的情况</i></a> 。 你可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a>玩。 我们可以为此任务负担的最大<i>位数</i>是多少？ <br><br> 结果已经非常具有指示性， <i>BigInt</i>确实非常快： <br><br><img src="https://habrastorage.org/webt/qq/wb/-j/qqwb-jhmypgogtk94bg-pqnrxhy.png"><br><br><h4> 动机 </h4><br>  2/3的与会人员在解决方案中使用了新的<i>BigInt</i>类型是很酷的（有人承认这是第一次体验）。 其余三分之一的解决方案包含它们自己对字符串或数组的长算术实现。 大多数实现的功能都将大数乘以大数，而对于一个解决方案来说，乘以“小” <i>数</i>足以花更少的时间就足够了。 好的任务，您已经在项目中<i>使用BigInt</i>吗？ <br><br><h2> 致谢 </h2><br> 会议的这两天充满了讨论和学习新知识。 我要感谢计划委员会下次难忘的会议，并感谢所有与会人员的独特联系和良好的心情。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN453466/">https://habr.com/ru/post/zh-CN453466/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN453454/index.html">软件无线电-它如何工作？ 第5部分</a></li>
<li><a href="../zh-CN453456/index.html">本地化如何在Netflix中工作-翻译</a></li>
<li><a href="../zh-CN453458/index.html">Svelte 3.0中的真实反应式编程</a></li>
<li><a href="../zh-CN453460/index.html">当厌倦了虚拟</a></li>
<li><a href="../zh-CN453464/index.html">量子未来（续）</a></li>
<li><a href="../zh-CN453468/index.html">Java Web应用程序的演变</a></li>
<li><a href="../zh-CN453470/index.html">您分布的巨石正在您身后</a></li>
<li><a href="../zh-CN453472/index.html">能量监测器PZEM004T和ESP8266的自行车，带有人员监测功能</a></li>
<li><a href="../zh-CN453474/index.html">使用Arduino和Node.js从放大器通过遥控器控制计算机</a></li>
<li><a href="../zh-CN453478/index.html">我们研究了Starlink卫星Ilona Mask的健康状况</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>