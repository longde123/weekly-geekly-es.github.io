<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öìÔ∏è üë©üèª‚ÄçüöÄ üíáüèª Handbuch zum Implementieren von automatisch erneuerbaren Abonnements in iOS-Anwendungen üíç üëèüèΩ üó®Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! Mein Name ist Denis, ich entwickle Apphud , einen Dienst zur Analyse von automatisch erneuerbaren Abonnements in iOS-Anwendungen. 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Handbuch zum Implementieren von automatisch erneuerbaren Abonnements in iOS-Anwendungen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/apphud/blog/456602/"><p><img src="https://habrastorage.org/webt/qy/ut/ez/qyutezbsfdccsr1yrml6revzsbm.png" alt="Bild"></p><br><p>  Hallo allerseits!  Mein Name ist Denis, ich entwickle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apphud</a> , einen Dienst zur Analyse von automatisch erneuerbaren Abonnements in iOS-Anwendungen. </p><br><p>  In diesem Artikel werde ich Ihnen erkl√§ren, wie Sie automatisch erneuerbare Abonnements in iOS 12 und iOS 13 konfigurieren, implementieren und validieren. Als Bonus werde ich Sie √ºber subtile Punkte und Fallstricke informieren, die nicht alle Entwickler ber√ºcksichtigen. <a name="habracut"></a></p><br><h2 id="nastroyka-podpisok-v-app-store-connect">  Richten Sie Abonnements im App Store Connect ein </h2><br><p>  Wenn Sie bereits eine Bundle-ID und eine Anwendung erstellt haben, k√∂nnen Sie diese Schritte √ºberspringen.  Wenn Sie zum ersten Mal eine Anwendung erstellen, gehen Sie wie folgt vor: </p><br><p>  Sie m√ºssen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Apple Developer Portal</a> <em>eine explizite Bundle-ID (App-ID)</em> erstellen.  <em>Wechseln Sie bei</em> ge√∂ffneter Seite <em>Zertifikate, Kennungen und Profile</em> zur Registerkarte Kennungen.  Im Juni 2019 aktualisierte Apple schlie√ülich das Layout des Portals gem√§√ü ASC (kurz f√ºr App Store Connect). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fad/ba4/609/fadba4609e2e25bf48f1f9149cf81332.png" alt="Neues Design f√ºr das Apple Entwicklerportal im Jahr 2019"><br>  <em>Neues Design f√ºr das Apple Developer Portal im Jahr 2019</em> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/cbb/84c/1ea/cbb84c1eac492c0c10e18aa373272c49.png"></p><br><p> Die explizite Bundle-ID wird normalerweise im Dom√§nenstil ( <code>com.apphud.subscriptionstest</code> ) angegeben.  Im Abschnitt Funktionen werden Sie feststellen, dass das H√§kchen neben <em>In-App-K√§ufe</em> bereits aktiviert ist.  <em>Wechseln Sie</em> nach dem Erstellen der <em>Bundle-ID</em> ( <em>App-ID</em> ) zum App Store Connect. </p><br><h3 id="testovye-polzovateli-sandbox-users">  Benutzer testen (Sandbox-Benutzer) </h3><br><p>  Um zuk√ºnftige Eink√§ufe zu testen, m√ºssen Sie einen Testbenutzer erstellen.  Wechseln Sie dazu auf der Registerkarte <em>Benutzer und Zugriff</em> zu ASC <em>und</em> dann zu <em>Sandbox-Testern.</em> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6b9/15b/25d/6b915b25d4b0ee1374756d84c04d64a4.png" alt="Benutzer-Sandbox-Erstellungsformular"><br>  <em>Benutzer-Sandbox-Erstellungsformular</em> </p><br><blockquote>  Wenn Sie einen Tester erstellen, k√∂nnen Sie nicht vorhandene Daten angeben. Vergessen Sie vor allem nicht die E-Mail-Adresse und das Passwort! </blockquote><p>  Ich werde am Ende des Artikels dar√ºber sprechen, wie Sie Eink√§ufe mit Testanmeldeinformationen testen k√∂nnen. </p><br><p>  Ein weiterer wichtiger Schritt ist die Einrichtung von Vertr√§gen und Bankdaten im Abschnitt ‚Äû <em>Vereinbarungen, Steuern und Bankgesch√§fte</em> ‚Äú.  Wenn Sie keine Vereinbarung f√ºr kostenpflichtige Antr√§ge haben, k√∂nnen Sie automatisch erneuerbare Abonnements nicht testen! </p><br><p>  Danach k√∂nnen Sie im App Store Connect eine neue Anwendung erstellen.  Geben Sie einen eindeutigen Namen an und w√§hlen Sie Ihre <em>Bundle-ID</em> als Paket- <em>ID aus</em> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2b9/15d/251/2b915d25116265c73951ebe326ca672f.png" alt="Die Paket-ID ist Ihre Bundle-ID"><br>  <em>Die Paket-ID ist Ihre Bundle-ID</em> </p><br><p>  Wechseln Sie unmittelbar nach dem Erstellen der Anwendung zur Registerkarte <em>Funktionen.</em> </p><br><blockquote>  Wenn Sie die Anwendung bereits erstellt haben, k√∂nnen Sie von hier aus weiterlesen. </blockquote><p>  Das Erstellen eines Abonnements mit automatischer Verl√§ngerung besteht aus mehreren Schritten: </p><br><p>  <strong>1. Erstellen Sie eine Abonnement-ID und eine <em>Abonnementgruppe</em> .</strong>  Eine Abonnementgruppe ist eine Sammlung von Abonnements mit unterschiedlichen Zeitr√§umen und Preisen, die jedoch dieselbe Funktionalit√§t in der Anwendung √∂ffnen.  Au√üerdem k√∂nnen Sie in der Abonnementgruppe den kostenlosen Testzeitraum nur einmal aktivieren, und nur eines der Abonnements kann aktiv sein.  Wenn Ihre Anwendung zwei verschiedene Abonnements gleichzeitig haben soll, m√ºssen Sie zwei Gruppen von Abonnements erstellen. </p><br><p>  <strong>2. Geben Sie die Abonnementdaten ein: Dauer, Anzeigename im App Store (nicht zu verwechseln mit dem Namen) und Beschreibung.</strong>  Wenn Sie der Gruppe das erste Abonnement hinzuf√ºgen, m√ºssen Sie den Anzeigenamen der Abonnementgruppe angeben.  Denken Sie daran, Ihre √Ñnderungen h√§ufiger zu speichern. ASC kann jederzeit einfrieren und nicht mehr reagieren. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/62b/639/230/62b6392305ee8cd98000ba60aa408eb8.png" alt="Abonnementseite"><br>  <em>Abonnement-Bildschirm</em> </p><br><p>  <strong>3. Den Abonnementpreis ausf√ºllen.</strong>  Es gibt zwei Phasen: Preiserstellung und Sonderangebote.  Geben Sie den realen Preis in einer beliebigen W√§hrung an. Er wird automatisch f√ºr alle anderen L√§nder neu berechnet.  Einf√ºhrungsangebote: Hier k√∂nnen Sie Benutzern eine kostenlose Testphase oder Prepaid-Rabatte anbieten.  Im Jahr 2019 wurden im App Store Werbeaktionen ver√∂ffentlicht, mit denen Sie Benutzern, die sich abgemeldet haben und die Sie zur√ºckgeben m√∂chten, Sonderrabatte gew√§hren k√∂nnen. </p><br><h3 id="generaciya-sekretnogo-obschego-klyucha-shared-secret-key">  Gemeinsame Generierung geheimer Schl√ºssel </h3><br><p>  Auf der Seite mit einer Liste aller von Ihnen erstellten Abonnements sehen Sie den <em>freigegebenen Schl√ºssel f√ºr die Anwendungsschaltfl√§che</em> .  Dies ist eine spezielle Zeile, die zum √úberpr√ºfen einer Pr√ºfung in einer iOS-Anwendung ben√∂tigt wird.  Wir m√ºssen die Pr√ºfung validieren, um den Status des Abonnements zu ermitteln. </p><br><p>  Es gibt zwei Arten von gemeinsam genutzten Schl√ºsseln: einen eindeutigen Schl√ºssel f√ºr Ihre Anwendung oder einen einzelnen Schl√ºssel f√ºr Ihr Konto.  Wichtig: Erstellen Sie den Schl√ºssel in keinem Fall neu, wenn Sie die Anwendung bereits im App Store haben. Andernfalls k√∂nnen Benutzer die Pr√ºfung nicht validieren und Ihre Anwendung funktioniert nicht mehr wie erwartet. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/644/ce1/5d1/644ce15d1961d54f5f6cc1cf15b7dda0.png" alt="In diesem Beispiel werden drei Abonnementgruppen und drei Jahresabonnements behandelt."><br>  <em>In diesem Beispiel werden drei Abonnementgruppen und drei Jahresabonnements erstellt.</em> </p><br><p>  Kopieren Sie die ID aller Ihrer Abonnements und den freigegebenen Schl√ºssel. Dies ist sp√§ter im Code hilfreich. </p><br><h2 id="programmnaya-chast">  Software-Teil </h2><br><p>  Kommen wir zum praktischen Teil.  Was braucht es, um einen kompletten Einkaufsmanager zu machen?  Zumindest sollte Folgendes implementiert werden: </p><br><ol><li><p>  Kasse </p><br></li><li><p>  √úberpr√ºfen Sie den Abonnementstatus </p><br></li><li><p>  √úberpr√ºfen Sie das Update </p><br></li><li><p>  Transaktionswiederherstellung (nicht zu verwechseln mit der Aktualisierung eines Schecks!) </p><br></li></ol><br><h3 id="oformlenie-pokupok">  Kasse </h3><br><p>  Der gesamte Kaufprozess kann in zwei Phasen unterteilt werden: Empfang von Produkten ( <code>SKProduct</code> Klasse) und Initialisierung des Kaufprozesses ( <code>SKPayment</code> Klasse).  Zun√§chst m√ºssen wir den Delegaten des <code>SKPaymentTransactionObserver</code> Protokolls angeben. </p><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// Starts products loading and sets transaction observer delegate @objc func startWith(arrayOfIds : Set&lt;String&gt;!, sharedSecret : String){ SKPaymentQueue.default().add(self) self.sharedSecret = sharedSecret self.productIds = arrayOfIds loadProducts() } private func loadProducts(){ let request = SKProductsRequest.init(productIdentifiers: productIds) request.delegate = self request.start() } public func productsRequest(_ request: SKProductsRequest, didReceive response: SKProductsResponse) { products = response.products DispatchQueue.main.async { NotificationCenter.default.post(name: IAP_PRODUCTS_DID_LOAD_NOTIFICATION, object: nil) } } func request(_ request: SKRequest, didFailWithError error: Error){ print("error: \(error.localizedDescription)") }</span></span></code> </pre> <br><p>  Die Benachrichtigung <code>IAP_PRODUCTS_DID_LOAD_NOTIFICATION</code> zum Aktualisieren der Benutzeroberfl√§che in einer Anwendung verwendet. </p><br><p>  Als n√§chstes schreiben wir eine Methode, um den Kauf zu initialisieren: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">purchaseProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(product : SKProduct, success: @escaping SuccessBlock, failure: @escaping FailureBlock)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.canMakePayments() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().transactions.last?.transactionState != .purchasing <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.successBlock = success <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.failureBlock = failure <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> payment = <span class="hljs-type"><span class="hljs-type">SKPayment</span></span>(product: product) <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().add(payment) }</code> </pre> <br><p>  Der <code>SKPaymentTransactionObserver</code> Delegat sieht folgenderma√üen aus: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IAPManager</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SKPaymentTransactionObserver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">paymentQueue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction])</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> transaction <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> transactions { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (transaction.transactionState) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .purchased: <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().finishTransaction(transaction) notifyIsPurchased(transaction: transaction) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .failed: <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().finishTransaction(transaction) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"purchase error : \(transaction.error?.localizedDescription ?? "</span></span><span class="hljs-string"><span class="hljs-string">")"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.failureBlock?(transaction.error) cleanUp() <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .restored: <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().finishTransaction(transaction) notifyIsPurchased(transaction: transaction) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .deferred, .purchasing: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">notifyIsPurchased</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(transaction: SKPaymentTransaction)</span></span></span></span> { refreshSubscriptionsStatus(callback: { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.successBlock?() <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cleanUp() }) { (error) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-comment"><span class="hljs-comment">// couldn't verify receipt self.failureBlock?(error) self.cleanUp() } } func cleanUp(){ self.successBlock = nil self.failureBlock = nil } }</span></span></code> </pre> <br><p>  Nach erfolgreichem Abonnement wird die Delegatmethode aufgerufen, bei der die Transaktion den Status " <code>purchased</code> . </p><br><p>  Aber wie kann man das Ablaufdatum eines Abonnements bestimmen?  Stellen Sie dazu eine separate Anfrage an Apple. </p><br><h3 id="proverka-statusa-podpiski">  √úberpr√ºfen Sie den Abonnementstatus </h3><br><p>  Die Pr√ºfung wird mit der POST-Anforderung <code>verifyReceipt</code> an Apple validiert. Wir senden die verschl√ºsselte Pr√ºfung als base64-codierte Zeichenfolge als Parameter und erhalten in der Antwort dieselbe Pr√ºfung im JSON-Format.  In dem Array <code>latest_receipt_info</code> der Schl√ºssel <code>latest_receipt_info</code> alle Transaktionen aus jedem Zeitraum jedes Abonnements auf, einschlie√ülich der Testzeitr√§ume.  Wir k√∂nnen nur die Antwort analysieren und das aktuelle Verfallsdatum f√ºr jedes Produkt ermitteln. </p><br><blockquote>  Auf der WWDC 2017 wurde die M√∂glichkeit hinzugef√ºgt, nur aktuelle Schecks f√ºr jedes Abonnement mit dem Schl√ºssel zum <code>exclude-old-transactions</code> in der <code>verifyReceipt</code> Anforderung zu erhalten. </blockquote><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refreshSubscriptionsStatus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(callback : @escaping SuccessBlock, failure : @escaping FailureBlock)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// save blocks for further use self.refreshSubscriptionSuccessBlock = callback self.refreshSubscriptionFailureBlock = failure guard let receiptUrl = Bundle.main.appStoreReceiptURL else { refreshReceipt() // do not call block yet return } #if DEBUG let urlString = "https://sandbox.itunes.apple.com/verifyReceipt" #else let urlString = "https://buy.itunes.apple.com/verifyReceipt" #endif let receiptData = try? Data(contentsOf: receiptUrl).base64EncodedString() let requestData = ["receipt-data" : receiptData ?? "", "password" : self.sharedSecret, "exclude-old-transactions" : true] as [String : Any] var request = URLRequest(url: URL(string: urlString)!) request.httpMethod = "POST" request.setValue("Application/json", forHTTPHeaderField: "Content-Type") let httpBody = try? JSONSerialization.data(withJSONObject: requestData, options: []) request.httpBody = httpBody URLSession.shared.dataTask(with: request) { (data, response, error) in DispatchQueue.main.async { if data != nil { if let json = try? JSONSerialization.jsonObject(with: data!, options: .allowFragments){ self.parseReceipt(json as! Dictionary&lt;String, Any&gt;) return } } else { print("error validating receipt: \(error?.localizedDescription ?? "")") } self.refreshSubscriptionFailureBlock?(error) self.cleanUpRefeshReceiptBlocks() } }.resume() }</span></span></code> </pre> <br><p>  Zu Beginn der Methode sehen Sie, dass eine Pr√ºfung auf das Vorhandensein einer lokalen Kopie der Pr√ºfung vorliegt.  Eine lokale Pr√ºfung ist m√∂glicherweise nicht vorhanden, wenn die Anwendung beispielsweise √ºber iTunes installiert wurde.  Wenn keine Pr√ºfung erfolgt, k√∂nnen wir die Anforderung <code>verifyReceipt</code> nicht ausf√ºhren.  Wir m√ºssen zuerst die aktuelle lokale Pr√ºfung abrufen und dann erneut versuchen, sie zu validieren.  Die Aktualisierung der Pr√ºfung erfolgt mit der Klasse <code>SKReceiptRefreshRequest</code> : </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refreshReceipt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">SKReceiptRefreshRequest</span></span>(receiptProperties: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) request.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> request.start() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestDidFinish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request: SKRequest)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// call refresh subscriptions method again with same blocks if request is SKReceiptRefreshRequest { refreshSubscriptionsStatus(callback: self.successBlock ?? {}, failure: self.failureBlock ?? {_ in}) } } func request(_ request: SKRequest, didFailWithError error: Error){ if request is SKReceiptRefreshRequest { self.refreshSubscriptionFailureBlock?(error) self.cleanUpRefeshReceiptBlocks() } print("error: \(error.localizedDescription)") }</span></span></code> </pre> <br><p>  <strong>Check Update ist</strong> in der Funktion <code>refreshReceipt()</code> implementiert.  Wenn die Pr√ºfung erfolgreich aktualisiert wurde, wird die Delegatenmethode <code>requestDidFinish(_ request : SKRequest)</code> aufgerufen, die die <code>refreshSubscriptionsStatus</code> Methode <code>refreshSubscriptionsStatus</code> . </p><br><p>  Wie wird das Parsen von Kaufinformationen implementiert?  Wir erhalten ein JSON-Objekt zur√ºck, in dem sich ein verschachteltes Array von Transaktionen befindet (mit dem Schl√ºssel " <code>latest_receipt_info</code> ).  Wir gehen das Array durch, ermitteln das Ablaufdatum mit dem Schl√ºssel <code>expires_date</code> und speichern es, wenn dieses Datum noch nicht eingetroffen ist. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseReceipt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> json : Dictionary&lt;String, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// It's the most simple way to get latest expiration date. Consider this code as for learning purposes. Do not use current code in production apps. guard let receipts_array = json["latest_receipt_info"] as? [Dictionary&lt;String, Any&gt;] else { self.refreshSubscriptionFailureBlock?(nil) self.cleanUpRefeshReceiptBlocks() return } for receipt in receipts_array { let productID = receipt["product_id"] as! String let formatter = DateFormatter() formatter.dateFormat = "yyyy-MM-dd HH:mm:ss VV" if let date = formatter.date(from: receipt["expires_date"] as! String) { if date &gt; Date() { // do not save expired date to user defaults to avoid overwriting with expired date UserDefaults.standard.set(date, forKey: productID) } } } self.refreshSubscriptionSuccessBlock?() self.cleanUpRefeshReceiptBlocks() }</span></span></code> </pre> <br><p>  Ich habe ein einfaches Beispiel gegeben, wie das aktuelle Ablaufdatum eines Abonnements extrahiert wird.  Es gibt keine Fehlerbehandlung und zum Beispiel keine √úberpr√ºfung der R√ºckgabe eines Kaufs ( <em>Stornierungsdatum wird</em> hinzugef√ºgt). </p><br><p>  Um festzustellen, ob ein Abonnement aktiv ist oder nicht, vergleichen Sie einfach das aktuelle Datum mit dem Datum aus den <em>Benutzerstandards</em> nach Produktschl√ºssel.  Wenn es nicht vorhanden ist oder unter dem aktuellen Datum liegt, gilt das Abonnement als inaktiv. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expirationDateFor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> identifier : String)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Date?</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">UserDefaults</span></span>.standard.object(forKey: identifier) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">Date</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> subscriptionDate = <span class="hljs-type"><span class="hljs-type">IAPManager</span></span>.shared.expirationDateFor(<span class="hljs-string"><span class="hljs-string">"YOUR_PRODUCT_ID"</span></span>) ?? <span class="hljs-type"><span class="hljs-type">Date</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isActive = subscriptionDate &gt; <span class="hljs-type"><span class="hljs-type">Date</span></span>()</code> </pre> <br><p>  Die Transaktionswiederherstellung erfolgt in einer einzelnen Zeile <code>SKPaymentQueue.default().restoreCompletedTransactions()</code> .  Diese Funktion stellt alle abgeschlossenen Transaktionen wieder her, indem die Delegatenmethode <code>func paymentQueue(**_** queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction])</code> . </p><br><h3 id="chem-otlichaetsya-obnovlenie-cheka-ot-vosstanovleniya-tranzakciy">  Was ist der Unterschied zwischen der Aktualisierung eines Schecks aus der Transaktionswiederherstellung? </h3><br><p>  Beide Methoden helfen bei der Wiederherstellung Ihrer Kaufdaten.  Aber was sind ihre Unterschiede?  Es gibt einen wunderbaren Tisch mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wwdc Video</a> : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c21/520/f53/c21520f531f3df7a185296f33bfa8f2b.png" alt="Differenztabelle mit zwei m√∂glichen zum gleichen Stellen von Einkl√∂sen bei WWDC"><br>  <em>Differenztabelle mit zwei M√∂glichkeiten zum Wiederherstellen von Eink√§ufen bei WWDC</em> </p><br><p>  In den meisten F√§llen m√ºssen Sie nur <code>SKReceiptRefreshRequest()</code> , da wir nur an einem Scheck f√ºr die sp√§tere Berechnung des Ablaufdatums interessiert sind. </p><br><p>  Bei automatisch erneuerbaren Abonnements sind die Transaktionen selbst f√ºr uns nicht von Interesse. Daher reicht es aus, nur ein Scheck-Update zu verwenden.  Es gibt jedoch F√§lle, in denen Sie die Transaktionswiederherstellungsmethode verwenden m√ºssen: Wenn Ihre Anwendung beim Kauf Inhalte herunterl√§dt (von Apple gehostete Inhalte) oder wenn Sie weiterhin Versionen unter iOS 7 unterst√ºtzen. </p><br><h3 id="testirovanie-pokupok-sandbox-testing">  Einkaufstests (Sandbox-Tests) </h3><br><p>  Zuvor mussten Sie sich zum Testen von Eink√§ufen im App Store in den Einstellungen Ihres iPhones anmelden.  Dies war sehr unpraktisch (zum Beispiel wurde die gesamte Apple Music Library gel√∂scht).  Dies muss jetzt jedoch nicht mehr durchgef√ºhrt werden: Das Sandbox-Konto ist jetzt getrennt vom Hauptkonto vorhanden. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/846/b0d/1d5/846b0d1d5a265e9a3f38ebeaa1bd61ef.jpg"></p><br><p>  Der Kaufprozess ist im Vergleich zu echten Eink√§ufen im App Store √§hnlich, aber es gibt einige Punkte: </p><br><ul><li><p>  Sie m√ºssen das Anmeldekennwort immer √ºber das Systemfenster eingeben.  K√§ufe mit Touch ID / Face ID werden weiterhin nicht unterst√ºtzt. </p><br></li><li><p>  Wenn das System bei korrekter Eingabe von Login und Passwort immer wieder nach dem Login-Passwort fragt, <em>klicken Sie auf "Abbrechen"</em> , minimieren Sie die Anwendung und versuchen Sie es erneut.  Es sieht nach Unsinn aus, aber es funktioniert f√ºr viele.  Aber manchmal geht der Vorgang nach der zweiten Passworteingabe weiter. </p><br></li><li><p>  Sie k√∂nnen den Abmeldevorgang in keiner Weise testen. </p><br></li><li><p>  Die Dauer der Abonnementlaufzeiten ist viel k√ºrzer als real.  Und sie werden nicht mehr als 6 Mal am Tag aktualisiert. </p><br></li></ul><br><div class="scrollable-table"><table><thead><tr><th>  Tats√§chliche Dauer </th><th>  Testdauer </th></tr></thead><tbody><tr><td>  1 Woche </td><td>  3 Minuten </td></tr><tr><td>  1 Monat </td><td>  5 Minuten </td></tr><tr><td>  2 Monate </td><td>  10 Minuten </td></tr><tr><td>  3 Monate </td><td>  15 Minuten </td></tr><tr><td>  6 Monate </td><td>  30 Minuten </td></tr><tr><td>  1 Jahr </td><td>  1 Stunde </td></tr></tbody></table></div><br><h3 id="chto-novogo-v-storekit-v-ios-13">  Was ist neu in StoreKit in iOS 13? </h3><br><p>  Von der neuen - nur die <code>SKStorefront</code> Klasse, die Informationen dar√ºber enth√§lt, in welchem ‚Äã‚ÄãLand der Benutzer im App Store registriert ist.  Dies kann f√ºr Entwickler n√ºtzlich sein, die unterschiedliche Abonnements f√ºr unterschiedliche L√§nder verwenden.  Bisher wurden alle nach Geolokalisierung oder Region des Ger√§ts √ºberpr√ºft. Dies ergab jedoch kein genaues Ergebnis.  Jetzt ist es sehr einfach, das Land im App Store <code>SKPaymentQueue.default().storefront?.countryCode</code> : <code>SKPaymentQueue.default().storefront?.countryCode</code> .  Ein Methodendelegierter wurde ebenfalls hinzugef√ºgt, wenn sich das Land im App Store w√§hrend des Kaufvorgangs ge√§ndert hat.  In diesem Fall k√∂nnen Sie den Kaufvorgang selbst fortsetzen oder abbrechen. </p><br><h2 id="podvodnye-kamni-pri-rabote-s-podpiskami">  Fallstricke bei der Arbeit mit Abonnements </h2><br><ul><li>  Das √úberpr√ºfen eines Schecks direkt von einem Ger√§t aus wird von Apple nicht empfohlen.  Sie haben mehrmals <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf der WWDC dar√ºber gesprochen</a> (ab 5:50 Uhr), und dies ist in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation angegeben</a> .  Dies ist unsicher, da ein Angreifer Daten mithilfe eines Man-in-the-Middle-Angriffs abfangen kann.  Die korrekte Methode zum √úberpr√ºfen von √úberpr√ºfungen ist die lokale √úberpr√ºfung entweder √ºber Ihren Server. </li><li>  Beim √úberpr√ºfen des Ablaufdatums ist ein Problem aufgetreten.  Wenn Sie Ihren Server nicht verwenden, kann die Systemzeit auf dem Ger√§t auf eine √§ltere ge√§ndert werden. Unser Code f√ºhrt dann zu einem falschen Ergebnis. Das Abonnement wird als aktiv betrachtet.  Wenn dies nicht zu Ihnen passt, k√∂nnen Sie jeden Dienst verwenden, der die genaue Weltzeit ausgibt. </li><li>  M√∂glicherweise haben nicht alle Benutzer eine kostenlose Testversion.  Der Benutzer kann die Anwendung nach einiger Zeit neu installieren, und die Anwendung zeigt an, dass die Testversion wie gewohnt verf√ºgbar ist.  Es ist korrekt, die Pr√ºfung zu aktualisieren, zu validieren und in JSON die Verf√ºgbarkeit der Testversion f√ºr diesen Benutzer zu √ºberpr√ºfen.  Viele nicht. </li><li>  Wenn der Benutzer eine R√ºckerstattung beantragt hat, wird das <code>cancellation_date</code> zum Abonnement-JSON hinzugef√ºgt, das <code>expires_date</code> bleibt jedoch unver√§ndert.  Daher ist es wichtig, immer zu pr√ºfen, ob das Feld " <code>cancellation_date</code> ist, das dem <code>expires_date</code> vorgezogen <code>expires_date</code> . </li><li>  Es lohnt sich nicht, die Pr√ºfung bei jedem Start der Anwendung zu aktualisieren, da dies zum einen sinnlos ist und zum anderen dem Benutzer h√∂chstwahrscheinlich ein Kennworteingabefenster von Apple ID angezeigt wird.  Es lohnt sich, den Scheck zu aktualisieren, wenn der Benutzer selbst auf die Schaltfl√§che "Einkauf wiederherstellen" geklickt hat. </li><li>  Wie kann festgestellt werden, an welchen Punkten es sich lohnt, einen Scheck zu validieren, um das aktuelle Ablaufdatum eines Abonnements zu erhalten?  Sie k√∂nnen den Scheck bei jedem Start oder nur am Ende des Abonnements validieren.  Wenn Sie den Scheck jedoch erst am Ende des Abonnements √ºberpr√ºfen, kann der Benutzer, der die R√ºckerstattung ausgestellt hat, Ihren Antrag bis zum Ende des Zeitraums kostenlos verwenden. </li></ul><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Ich hoffe, dieser Artikel wird Ihnen n√ºtzlich sein.  Ich habe versucht, nicht nur den Code hinzuzuf√ºgen, sondern auch die subtilen Punkte in der Entwicklung zu erkl√§ren.  Der vollst√§ndige Klassencode kann hier heruntergeladen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> .  Diese Klasse ist sehr n√ºtzlich, um unerfahrene Entwickler und diejenigen kennenzulernen, die mehr dar√ºber erfahren m√∂chten, wie alles funktioniert.  F√ºr Live-Anwendungen wird empfohlen, seri√∂sere L√∂sungen zu verwenden, z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SwiftyStoreKit</a> . </p><br><blockquote>  M√∂chten Sie in 10 Minuten Abonnements in Ihrer iOS-App implementieren?  Integrieren Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apphud</a> und: <br><ul><li>  Kaufen Sie nur mit einer Methode ein. </li><li>  Verfolgen Sie automatisch den Status des Abonnements jedes Benutzers. </li><li>  Abonnementangebote einfach integrieren </li><li>  Senden Sie Abonnementereignisse an Amplitude, Mixpanel, Slack und Telegram unter Ber√ºcksichtigung der lokalen W√§hrung des Benutzers. </li><li>  Verringern Sie die Abwanderungsrate in Anwendungen und geben Sie nicht abonnierte Benutzer zur√ºck. </li></ul><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456602/">https://habr.com/ru/post/de456602/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456584/index.html"># ITX5 wird eine Gruppe von JAVA-Entwicklern versammeln</a></li>
<li><a href="../de456592/index.html">Kognitive Verzerrungen in der Entwicklung der "Zeiten" der englischen Sprache oder Wer uns st√∂rt, werden uns helfen</a></li>
<li><a href="../de456594/index.html">2 Minuten mit Webpack-Baumsch√ºtteln und Reexport</a></li>
<li><a href="../de456596/index.html">Microbiota. Wie funktioniert das Testen?</a></li>
<li><a href="../de456600/index.html">Nginx-Rezepte: LDAP-Autorisierung mit Captcha</a></li>
<li><a href="../de456604/index.html">Wie wir einen gro√üen Online-Shop automatisierten und anfingen, Produkte automatisch abzugleichen</a></li>
<li><a href="../de456606/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 464 (04/04/2019 - 06/10/2019)</a></li>
<li><a href="../de456608/index.html">Southbridge in Tscheljabinsk und Bitrix in Kubernetes</a></li>
<li><a href="../de456610/index.html">Nicht dr√ºcken und nicht genehmigen</a></li>
<li><a href="../de456612/index.html">Eine von Hunderten M√∂glichkeiten, mehrere Produktionsprojekte auf einem Server zu ver√∂ffentlichen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>