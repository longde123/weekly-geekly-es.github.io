<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚓️ 👩🏻‍🚀 💇🏻 Handbuch zum Implementieren von automatisch erneuerbaren Abonnements in iOS-Anwendungen 💍 👏🏽 🗨️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! Mein Name ist Denis, ich entwickle Apphud , einen Dienst zur Analyse von automatisch erneuerbaren Abonnements in iOS-Anwendungen. 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Handbuch zum Implementieren von automatisch erneuerbaren Abonnements in iOS-Anwendungen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/apphud/blog/456602/"><p><img src="https://habrastorage.org/webt/qy/ut/ez/qyutezbsfdccsr1yrml6revzsbm.png" alt="Bild"></p><br><p>  Hallo allerseits!  Mein Name ist Denis, ich entwickle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apphud</a> , einen Dienst zur Analyse von automatisch erneuerbaren Abonnements in iOS-Anwendungen. </p><br><p>  In diesem Artikel werde ich Ihnen erklären, wie Sie automatisch erneuerbare Abonnements in iOS 12 und iOS 13 konfigurieren, implementieren und validieren. Als Bonus werde ich Sie über subtile Punkte und Fallstricke informieren, die nicht alle Entwickler berücksichtigen. <a name="habracut"></a></p><br><h2 id="nastroyka-podpisok-v-app-store-connect">  Richten Sie Abonnements im App Store Connect ein </h2><br><p>  Wenn Sie bereits eine Bundle-ID und eine Anwendung erstellt haben, können Sie diese Schritte überspringen.  Wenn Sie zum ersten Mal eine Anwendung erstellen, gehen Sie wie folgt vor: </p><br><p>  Sie müssen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Apple Developer Portal</a> <em>eine explizite Bundle-ID (App-ID)</em> erstellen.  <em>Wechseln Sie bei</em> geöffneter Seite <em>Zertifikate, Kennungen und Profile</em> zur Registerkarte Kennungen.  Im Juni 2019 aktualisierte Apple schließlich das Layout des Portals gemäß ASC (kurz für App Store Connect). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fad/ba4/609/fadba4609e2e25bf48f1f9149cf81332.png" alt="Neues Design für das Apple Entwicklerportal im Jahr 2019"><br>  <em>Neues Design für das Apple Developer Portal im Jahr 2019</em> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/cbb/84c/1ea/cbb84c1eac492c0c10e18aa373272c49.png"></p><br><p> Die explizite Bundle-ID wird normalerweise im Domänenstil ( <code>com.apphud.subscriptionstest</code> ) angegeben.  Im Abschnitt Funktionen werden Sie feststellen, dass das Häkchen neben <em>In-App-Käufe</em> bereits aktiviert ist.  <em>Wechseln Sie</em> nach dem Erstellen der <em>Bundle-ID</em> ( <em>App-ID</em> ) zum App Store Connect. </p><br><h3 id="testovye-polzovateli-sandbox-users">  Benutzer testen (Sandbox-Benutzer) </h3><br><p>  Um zukünftige Einkäufe zu testen, müssen Sie einen Testbenutzer erstellen.  Wechseln Sie dazu auf der Registerkarte <em>Benutzer und Zugriff</em> zu ASC <em>und</em> dann zu <em>Sandbox-Testern.</em> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6b9/15b/25d/6b915b25d4b0ee1374756d84c04d64a4.png" alt="Benutzer-Sandbox-Erstellungsformular"><br>  <em>Benutzer-Sandbox-Erstellungsformular</em> </p><br><blockquote>  Wenn Sie einen Tester erstellen, können Sie nicht vorhandene Daten angeben. Vergessen Sie vor allem nicht die E-Mail-Adresse und das Passwort! </blockquote><p>  Ich werde am Ende des Artikels darüber sprechen, wie Sie Einkäufe mit Testanmeldeinformationen testen können. </p><br><p>  Ein weiterer wichtiger Schritt ist die Einrichtung von Verträgen und Bankdaten im Abschnitt „ <em>Vereinbarungen, Steuern und Bankgeschäfte</em> “.  Wenn Sie keine Vereinbarung für kostenpflichtige Anträge haben, können Sie automatisch erneuerbare Abonnements nicht testen! </p><br><p>  Danach können Sie im App Store Connect eine neue Anwendung erstellen.  Geben Sie einen eindeutigen Namen an und wählen Sie Ihre <em>Bundle-ID</em> als Paket- <em>ID aus</em> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2b9/15d/251/2b915d25116265c73951ebe326ca672f.png" alt="Die Paket-ID ist Ihre Bundle-ID"><br>  <em>Die Paket-ID ist Ihre Bundle-ID</em> </p><br><p>  Wechseln Sie unmittelbar nach dem Erstellen der Anwendung zur Registerkarte <em>Funktionen.</em> </p><br><blockquote>  Wenn Sie die Anwendung bereits erstellt haben, können Sie von hier aus weiterlesen. </blockquote><p>  Das Erstellen eines Abonnements mit automatischer Verlängerung besteht aus mehreren Schritten: </p><br><p>  <strong>1. Erstellen Sie eine Abonnement-ID und eine <em>Abonnementgruppe</em> .</strong>  Eine Abonnementgruppe ist eine Sammlung von Abonnements mit unterschiedlichen Zeiträumen und Preisen, die jedoch dieselbe Funktionalität in der Anwendung öffnen.  Außerdem können Sie in der Abonnementgruppe den kostenlosen Testzeitraum nur einmal aktivieren, und nur eines der Abonnements kann aktiv sein.  Wenn Ihre Anwendung zwei verschiedene Abonnements gleichzeitig haben soll, müssen Sie zwei Gruppen von Abonnements erstellen. </p><br><p>  <strong>2. Geben Sie die Abonnementdaten ein: Dauer, Anzeigename im App Store (nicht zu verwechseln mit dem Namen) und Beschreibung.</strong>  Wenn Sie der Gruppe das erste Abonnement hinzufügen, müssen Sie den Anzeigenamen der Abonnementgruppe angeben.  Denken Sie daran, Ihre Änderungen häufiger zu speichern. ASC kann jederzeit einfrieren und nicht mehr reagieren. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/62b/639/230/62b6392305ee8cd98000ba60aa408eb8.png" alt="Abonnementseite"><br>  <em>Abonnement-Bildschirm</em> </p><br><p>  <strong>3. Den Abonnementpreis ausfüllen.</strong>  Es gibt zwei Phasen: Preiserstellung und Sonderangebote.  Geben Sie den realen Preis in einer beliebigen Währung an. Er wird automatisch für alle anderen Länder neu berechnet.  Einführungsangebote: Hier können Sie Benutzern eine kostenlose Testphase oder Prepaid-Rabatte anbieten.  Im Jahr 2019 wurden im App Store Werbeaktionen veröffentlicht, mit denen Sie Benutzern, die sich abgemeldet haben und die Sie zurückgeben möchten, Sonderrabatte gewähren können. </p><br><h3 id="generaciya-sekretnogo-obschego-klyucha-shared-secret-key">  Gemeinsame Generierung geheimer Schlüssel </h3><br><p>  Auf der Seite mit einer Liste aller von Ihnen erstellten Abonnements sehen Sie den <em>freigegebenen Schlüssel für die Anwendungsschaltfläche</em> .  Dies ist eine spezielle Zeile, die zum Überprüfen einer Prüfung in einer iOS-Anwendung benötigt wird.  Wir müssen die Prüfung validieren, um den Status des Abonnements zu ermitteln. </p><br><p>  Es gibt zwei Arten von gemeinsam genutzten Schlüsseln: einen eindeutigen Schlüssel für Ihre Anwendung oder einen einzelnen Schlüssel für Ihr Konto.  Wichtig: Erstellen Sie den Schlüssel in keinem Fall neu, wenn Sie die Anwendung bereits im App Store haben. Andernfalls können Benutzer die Prüfung nicht validieren und Ihre Anwendung funktioniert nicht mehr wie erwartet. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/644/ce1/5d1/644ce15d1961d54f5f6cc1cf15b7dda0.png" alt="In diesem Beispiel werden drei Abonnementgruppen und drei Jahresabonnements behandelt."><br>  <em>In diesem Beispiel werden drei Abonnementgruppen und drei Jahresabonnements erstellt.</em> </p><br><p>  Kopieren Sie die ID aller Ihrer Abonnements und den freigegebenen Schlüssel. Dies ist später im Code hilfreich. </p><br><h2 id="programmnaya-chast">  Software-Teil </h2><br><p>  Kommen wir zum praktischen Teil.  Was braucht es, um einen kompletten Einkaufsmanager zu machen?  Zumindest sollte Folgendes implementiert werden: </p><br><ol><li><p>  Kasse </p><br></li><li><p>  Überprüfen Sie den Abonnementstatus </p><br></li><li><p>  Überprüfen Sie das Update </p><br></li><li><p>  Transaktionswiederherstellung (nicht zu verwechseln mit der Aktualisierung eines Schecks!) </p><br></li></ol><br><h3 id="oformlenie-pokupok">  Kasse </h3><br><p>  Der gesamte Kaufprozess kann in zwei Phasen unterteilt werden: Empfang von Produkten ( <code>SKProduct</code> Klasse) und Initialisierung des Kaufprozesses ( <code>SKPayment</code> Klasse).  Zunächst müssen wir den Delegaten des <code>SKPaymentTransactionObserver</code> Protokolls angeben. </p><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// Starts products loading and sets transaction observer delegate @objc func startWith(arrayOfIds : Set&lt;String&gt;!, sharedSecret : String){ SKPaymentQueue.default().add(self) self.sharedSecret = sharedSecret self.productIds = arrayOfIds loadProducts() } private func loadProducts(){ let request = SKProductsRequest.init(productIdentifiers: productIds) request.delegate = self request.start() } public func productsRequest(_ request: SKProductsRequest, didReceive response: SKProductsResponse) { products = response.products DispatchQueue.main.async { NotificationCenter.default.post(name: IAP_PRODUCTS_DID_LOAD_NOTIFICATION, object: nil) } } func request(_ request: SKRequest, didFailWithError error: Error){ print("error: \(error.localizedDescription)") }</span></span></code> </pre> <br><p>  Die Benachrichtigung <code>IAP_PRODUCTS_DID_LOAD_NOTIFICATION</code> zum Aktualisieren der Benutzeroberfläche in einer Anwendung verwendet. </p><br><p>  Als nächstes schreiben wir eine Methode, um den Kauf zu initialisieren: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">purchaseProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(product : SKProduct, success: @escaping SuccessBlock, failure: @escaping FailureBlock)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.canMakePayments() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().transactions.last?.transactionState != .purchasing <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.successBlock = success <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.failureBlock = failure <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> payment = <span class="hljs-type"><span class="hljs-type">SKPayment</span></span>(product: product) <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().add(payment) }</code> </pre> <br><p>  Der <code>SKPaymentTransactionObserver</code> Delegat sieht folgendermaßen aus: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IAPManager</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SKPaymentTransactionObserver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">paymentQueue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction])</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> transaction <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> transactions { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (transaction.transactionState) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .purchased: <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().finishTransaction(transaction) notifyIsPurchased(transaction: transaction) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .failed: <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().finishTransaction(transaction) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"purchase error : \(transaction.error?.localizedDescription ?? "</span></span><span class="hljs-string"><span class="hljs-string">")"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.failureBlock?(transaction.error) cleanUp() <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .restored: <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().finishTransaction(transaction) notifyIsPurchased(transaction: transaction) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .deferred, .purchasing: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">notifyIsPurchased</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(transaction: SKPaymentTransaction)</span></span></span></span> { refreshSubscriptionsStatus(callback: { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.successBlock?() <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cleanUp() }) { (error) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-comment"><span class="hljs-comment">// couldn't verify receipt self.failureBlock?(error) self.cleanUp() } } func cleanUp(){ self.successBlock = nil self.failureBlock = nil } }</span></span></code> </pre> <br><p>  Nach erfolgreichem Abonnement wird die Delegatmethode aufgerufen, bei der die Transaktion den Status " <code>purchased</code> . </p><br><p>  Aber wie kann man das Ablaufdatum eines Abonnements bestimmen?  Stellen Sie dazu eine separate Anfrage an Apple. </p><br><h3 id="proverka-statusa-podpiski">  Überprüfen Sie den Abonnementstatus </h3><br><p>  Die Prüfung wird mit der POST-Anforderung <code>verifyReceipt</code> an Apple validiert. Wir senden die verschlüsselte Prüfung als base64-codierte Zeichenfolge als Parameter und erhalten in der Antwort dieselbe Prüfung im JSON-Format.  In dem Array <code>latest_receipt_info</code> der Schlüssel <code>latest_receipt_info</code> alle Transaktionen aus jedem Zeitraum jedes Abonnements auf, einschließlich der Testzeiträume.  Wir können nur die Antwort analysieren und das aktuelle Verfallsdatum für jedes Produkt ermitteln. </p><br><blockquote>  Auf der WWDC 2017 wurde die Möglichkeit hinzugefügt, nur aktuelle Schecks für jedes Abonnement mit dem Schlüssel zum <code>exclude-old-transactions</code> in der <code>verifyReceipt</code> Anforderung zu erhalten. </blockquote><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refreshSubscriptionsStatus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(callback : @escaping SuccessBlock, failure : @escaping FailureBlock)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// save blocks for further use self.refreshSubscriptionSuccessBlock = callback self.refreshSubscriptionFailureBlock = failure guard let receiptUrl = Bundle.main.appStoreReceiptURL else { refreshReceipt() // do not call block yet return } #if DEBUG let urlString = "https://sandbox.itunes.apple.com/verifyReceipt" #else let urlString = "https://buy.itunes.apple.com/verifyReceipt" #endif let receiptData = try? Data(contentsOf: receiptUrl).base64EncodedString() let requestData = ["receipt-data" : receiptData ?? "", "password" : self.sharedSecret, "exclude-old-transactions" : true] as [String : Any] var request = URLRequest(url: URL(string: urlString)!) request.httpMethod = "POST" request.setValue("Application/json", forHTTPHeaderField: "Content-Type") let httpBody = try? JSONSerialization.data(withJSONObject: requestData, options: []) request.httpBody = httpBody URLSession.shared.dataTask(with: request) { (data, response, error) in DispatchQueue.main.async { if data != nil { if let json = try? JSONSerialization.jsonObject(with: data!, options: .allowFragments){ self.parseReceipt(json as! Dictionary&lt;String, Any&gt;) return } } else { print("error validating receipt: \(error?.localizedDescription ?? "")") } self.refreshSubscriptionFailureBlock?(error) self.cleanUpRefeshReceiptBlocks() } }.resume() }</span></span></code> </pre> <br><p>  Zu Beginn der Methode sehen Sie, dass eine Prüfung auf das Vorhandensein einer lokalen Kopie der Prüfung vorliegt.  Eine lokale Prüfung ist möglicherweise nicht vorhanden, wenn die Anwendung beispielsweise über iTunes installiert wurde.  Wenn keine Prüfung erfolgt, können wir die Anforderung <code>verifyReceipt</code> nicht ausführen.  Wir müssen zuerst die aktuelle lokale Prüfung abrufen und dann erneut versuchen, sie zu validieren.  Die Aktualisierung der Prüfung erfolgt mit der Klasse <code>SKReceiptRefreshRequest</code> : </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refreshReceipt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">SKReceiptRefreshRequest</span></span>(receiptProperties: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) request.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> request.start() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestDidFinish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request: SKRequest)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// call refresh subscriptions method again with same blocks if request is SKReceiptRefreshRequest { refreshSubscriptionsStatus(callback: self.successBlock ?? {}, failure: self.failureBlock ?? {_ in}) } } func request(_ request: SKRequest, didFailWithError error: Error){ if request is SKReceiptRefreshRequest { self.refreshSubscriptionFailureBlock?(error) self.cleanUpRefeshReceiptBlocks() } print("error: \(error.localizedDescription)") }</span></span></code> </pre> <br><p>  <strong>Check Update ist</strong> in der Funktion <code>refreshReceipt()</code> implementiert.  Wenn die Prüfung erfolgreich aktualisiert wurde, wird die Delegatenmethode <code>requestDidFinish(_ request : SKRequest)</code> aufgerufen, die die <code>refreshSubscriptionsStatus</code> Methode <code>refreshSubscriptionsStatus</code> . </p><br><p>  Wie wird das Parsen von Kaufinformationen implementiert?  Wir erhalten ein JSON-Objekt zurück, in dem sich ein verschachteltes Array von Transaktionen befindet (mit dem Schlüssel " <code>latest_receipt_info</code> ).  Wir gehen das Array durch, ermitteln das Ablaufdatum mit dem Schlüssel <code>expires_date</code> und speichern es, wenn dieses Datum noch nicht eingetroffen ist. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseReceipt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> json : Dictionary&lt;String, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// It's the most simple way to get latest expiration date. Consider this code as for learning purposes. Do not use current code in production apps. guard let receipts_array = json["latest_receipt_info"] as? [Dictionary&lt;String, Any&gt;] else { self.refreshSubscriptionFailureBlock?(nil) self.cleanUpRefeshReceiptBlocks() return } for receipt in receipts_array { let productID = receipt["product_id"] as! String let formatter = DateFormatter() formatter.dateFormat = "yyyy-MM-dd HH:mm:ss VV" if let date = formatter.date(from: receipt["expires_date"] as! String) { if date &gt; Date() { // do not save expired date to user defaults to avoid overwriting with expired date UserDefaults.standard.set(date, forKey: productID) } } } self.refreshSubscriptionSuccessBlock?() self.cleanUpRefeshReceiptBlocks() }</span></span></code> </pre> <br><p>  Ich habe ein einfaches Beispiel gegeben, wie das aktuelle Ablaufdatum eines Abonnements extrahiert wird.  Es gibt keine Fehlerbehandlung und zum Beispiel keine Überprüfung der Rückgabe eines Kaufs ( <em>Stornierungsdatum wird</em> hinzugefügt). </p><br><p>  Um festzustellen, ob ein Abonnement aktiv ist oder nicht, vergleichen Sie einfach das aktuelle Datum mit dem Datum aus den <em>Benutzerstandards</em> nach Produktschlüssel.  Wenn es nicht vorhanden ist oder unter dem aktuellen Datum liegt, gilt das Abonnement als inaktiv. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expirationDateFor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> identifier : String)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Date?</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">UserDefaults</span></span>.standard.object(forKey: identifier) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">Date</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> subscriptionDate = <span class="hljs-type"><span class="hljs-type">IAPManager</span></span>.shared.expirationDateFor(<span class="hljs-string"><span class="hljs-string">"YOUR_PRODUCT_ID"</span></span>) ?? <span class="hljs-type"><span class="hljs-type">Date</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isActive = subscriptionDate &gt; <span class="hljs-type"><span class="hljs-type">Date</span></span>()</code> </pre> <br><p>  Die Transaktionswiederherstellung erfolgt in einer einzelnen Zeile <code>SKPaymentQueue.default().restoreCompletedTransactions()</code> .  Diese Funktion stellt alle abgeschlossenen Transaktionen wieder her, indem die Delegatenmethode <code>func paymentQueue(**_** queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction])</code> . </p><br><h3 id="chem-otlichaetsya-obnovlenie-cheka-ot-vosstanovleniya-tranzakciy">  Was ist der Unterschied zwischen der Aktualisierung eines Schecks aus der Transaktionswiederherstellung? </h3><br><p>  Beide Methoden helfen bei der Wiederherstellung Ihrer Kaufdaten.  Aber was sind ihre Unterschiede?  Es gibt einen wunderbaren Tisch mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wwdc Video</a> : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c21/520/f53/c21520f531f3df7a185296f33bfa8f2b.png" alt="Differenztabelle mit zwei möglichen zum gleichen Stellen von Einklösen bei WWDC"><br>  <em>Differenztabelle mit zwei Möglichkeiten zum Wiederherstellen von Einkäufen bei WWDC</em> </p><br><p>  In den meisten Fällen müssen Sie nur <code>SKReceiptRefreshRequest()</code> , da wir nur an einem Scheck für die spätere Berechnung des Ablaufdatums interessiert sind. </p><br><p>  Bei automatisch erneuerbaren Abonnements sind die Transaktionen selbst für uns nicht von Interesse. Daher reicht es aus, nur ein Scheck-Update zu verwenden.  Es gibt jedoch Fälle, in denen Sie die Transaktionswiederherstellungsmethode verwenden müssen: Wenn Ihre Anwendung beim Kauf Inhalte herunterlädt (von Apple gehostete Inhalte) oder wenn Sie weiterhin Versionen unter iOS 7 unterstützen. </p><br><h3 id="testirovanie-pokupok-sandbox-testing">  Einkaufstests (Sandbox-Tests) </h3><br><p>  Zuvor mussten Sie sich zum Testen von Einkäufen im App Store in den Einstellungen Ihres iPhones anmelden.  Dies war sehr unpraktisch (zum Beispiel wurde die gesamte Apple Music Library gelöscht).  Dies muss jetzt jedoch nicht mehr durchgeführt werden: Das Sandbox-Konto ist jetzt getrennt vom Hauptkonto vorhanden. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/846/b0d/1d5/846b0d1d5a265e9a3f38ebeaa1bd61ef.jpg"></p><br><p>  Der Kaufprozess ist im Vergleich zu echten Einkäufen im App Store ähnlich, aber es gibt einige Punkte: </p><br><ul><li><p>  Sie müssen das Anmeldekennwort immer über das Systemfenster eingeben.  Käufe mit Touch ID / Face ID werden weiterhin nicht unterstützt. </p><br></li><li><p>  Wenn das System bei korrekter Eingabe von Login und Passwort immer wieder nach dem Login-Passwort fragt, <em>klicken Sie auf "Abbrechen"</em> , minimieren Sie die Anwendung und versuchen Sie es erneut.  Es sieht nach Unsinn aus, aber es funktioniert für viele.  Aber manchmal geht der Vorgang nach der zweiten Passworteingabe weiter. </p><br></li><li><p>  Sie können den Abmeldevorgang in keiner Weise testen. </p><br></li><li><p>  Die Dauer der Abonnementlaufzeiten ist viel kürzer als real.  Und sie werden nicht mehr als 6 Mal am Tag aktualisiert. </p><br></li></ul><br><div class="scrollable-table"><table><thead><tr><th>  Tatsächliche Dauer </th><th>  Testdauer </th></tr></thead><tbody><tr><td>  1 Woche </td><td>  3 Minuten </td></tr><tr><td>  1 Monat </td><td>  5 Minuten </td></tr><tr><td>  2 Monate </td><td>  10 Minuten </td></tr><tr><td>  3 Monate </td><td>  15 Minuten </td></tr><tr><td>  6 Monate </td><td>  30 Minuten </td></tr><tr><td>  1 Jahr </td><td>  1 Stunde </td></tr></tbody></table></div><br><h3 id="chto-novogo-v-storekit-v-ios-13">  Was ist neu in StoreKit in iOS 13? </h3><br><p>  Von der neuen - nur die <code>SKStorefront</code> Klasse, die Informationen darüber enthält, in welchem ​​Land der Benutzer im App Store registriert ist.  Dies kann für Entwickler nützlich sein, die unterschiedliche Abonnements für unterschiedliche Länder verwenden.  Bisher wurden alle nach Geolokalisierung oder Region des Geräts überprüft. Dies ergab jedoch kein genaues Ergebnis.  Jetzt ist es sehr einfach, das Land im App Store <code>SKPaymentQueue.default().storefront?.countryCode</code> : <code>SKPaymentQueue.default().storefront?.countryCode</code> .  Ein Methodendelegierter wurde ebenfalls hinzugefügt, wenn sich das Land im App Store während des Kaufvorgangs geändert hat.  In diesem Fall können Sie den Kaufvorgang selbst fortsetzen oder abbrechen. </p><br><h2 id="podvodnye-kamni-pri-rabote-s-podpiskami">  Fallstricke bei der Arbeit mit Abonnements </h2><br><ul><li>  Das Überprüfen eines Schecks direkt von einem Gerät aus wird von Apple nicht empfohlen.  Sie haben mehrmals <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf der WWDC darüber gesprochen</a> (ab 5:50 Uhr), und dies ist in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation angegeben</a> .  Dies ist unsicher, da ein Angreifer Daten mithilfe eines Man-in-the-Middle-Angriffs abfangen kann.  Die korrekte Methode zum Überprüfen von Überprüfungen ist die lokale Überprüfung entweder über Ihren Server. </li><li>  Beim Überprüfen des Ablaufdatums ist ein Problem aufgetreten.  Wenn Sie Ihren Server nicht verwenden, kann die Systemzeit auf dem Gerät auf eine ältere geändert werden. Unser Code führt dann zu einem falschen Ergebnis. Das Abonnement wird als aktiv betrachtet.  Wenn dies nicht zu Ihnen passt, können Sie jeden Dienst verwenden, der die genaue Weltzeit ausgibt. </li><li>  Möglicherweise haben nicht alle Benutzer eine kostenlose Testversion.  Der Benutzer kann die Anwendung nach einiger Zeit neu installieren, und die Anwendung zeigt an, dass die Testversion wie gewohnt verfügbar ist.  Es ist korrekt, die Prüfung zu aktualisieren, zu validieren und in JSON die Verfügbarkeit der Testversion für diesen Benutzer zu überprüfen.  Viele nicht. </li><li>  Wenn der Benutzer eine Rückerstattung beantragt hat, wird das <code>cancellation_date</code> zum Abonnement-JSON hinzugefügt, das <code>expires_date</code> bleibt jedoch unverändert.  Daher ist es wichtig, immer zu prüfen, ob das Feld " <code>cancellation_date</code> ist, das dem <code>expires_date</code> vorgezogen <code>expires_date</code> . </li><li>  Es lohnt sich nicht, die Prüfung bei jedem Start der Anwendung zu aktualisieren, da dies zum einen sinnlos ist und zum anderen dem Benutzer höchstwahrscheinlich ein Kennworteingabefenster von Apple ID angezeigt wird.  Es lohnt sich, den Scheck zu aktualisieren, wenn der Benutzer selbst auf die Schaltfläche "Einkauf wiederherstellen" geklickt hat. </li><li>  Wie kann festgestellt werden, an welchen Punkten es sich lohnt, einen Scheck zu validieren, um das aktuelle Ablaufdatum eines Abonnements zu erhalten?  Sie können den Scheck bei jedem Start oder nur am Ende des Abonnements validieren.  Wenn Sie den Scheck jedoch erst am Ende des Abonnements überprüfen, kann der Benutzer, der die Rückerstattung ausgestellt hat, Ihren Antrag bis zum Ende des Zeitraums kostenlos verwenden. </li></ul><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Ich hoffe, dieser Artikel wird Ihnen nützlich sein.  Ich habe versucht, nicht nur den Code hinzuzufügen, sondern auch die subtilen Punkte in der Entwicklung zu erklären.  Der vollständige Klassencode kann hier heruntergeladen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> .  Diese Klasse ist sehr nützlich, um unerfahrene Entwickler und diejenigen kennenzulernen, die mehr darüber erfahren möchten, wie alles funktioniert.  Für Live-Anwendungen wird empfohlen, seriösere Lösungen zu verwenden, z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SwiftyStoreKit</a> . </p><br><blockquote>  Möchten Sie in 10 Minuten Abonnements in Ihrer iOS-App implementieren?  Integrieren Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apphud</a> und: <br><ul><li>  Kaufen Sie nur mit einer Methode ein. </li><li>  Verfolgen Sie automatisch den Status des Abonnements jedes Benutzers. </li><li>  Abonnementangebote einfach integrieren </li><li>  Senden Sie Abonnementereignisse an Amplitude, Mixpanel, Slack und Telegram unter Berücksichtigung der lokalen Währung des Benutzers. </li><li>  Verringern Sie die Abwanderungsrate in Anwendungen und geben Sie nicht abonnierte Benutzer zurück. </li></ul><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456602/">https://habr.com/ru/post/de456602/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456584/index.html"># ITX5 wird eine Gruppe von JAVA-Entwicklern versammeln</a></li>
<li><a href="../de456592/index.html">Kognitive Verzerrungen in der Entwicklung der "Zeiten" der englischen Sprache oder Wer uns stört, werden uns helfen</a></li>
<li><a href="../de456594/index.html">2 Minuten mit Webpack-Baumschütteln und Reexport</a></li>
<li><a href="../de456596/index.html">Microbiota. Wie funktioniert das Testen?</a></li>
<li><a href="../de456600/index.html">Nginx-Rezepte: LDAP-Autorisierung mit Captcha</a></li>
<li><a href="../de456604/index.html">Wie wir einen großen Online-Shop automatisierten und anfingen, Produkte automatisch abzugleichen</a></li>
<li><a href="../de456606/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 464 (04/04/2019 - 06/10/2019)</a></li>
<li><a href="../de456608/index.html">Southbridge in Tscheljabinsk und Bitrix in Kubernetes</a></li>
<li><a href="../de456610/index.html">Nicht drücken und nicht genehmigen</a></li>
<li><a href="../de456612/index.html">Eine von Hunderten Möglichkeiten, mehrere Produktionsprojekte auf einem Server zu veröffentlichen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>