<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍💼 🛤️ 🎼 Tudo o que você precisa saber sobre o coletor de lixo em Python 👰🏽 🤦🏻 🏖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Geralmente, você não precisa se preocupar com o coletor de lixo e trabalhar com memória ao escrever código Python. Assim que os objetos não são mais n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tudo o que você precisa saber sobre o coletor de lixo em Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417215/">  Geralmente, você não precisa se preocupar com o coletor de lixo e trabalhar com memória ao escrever código Python.  Assim que os objetos não são mais necessários, o Python libera automaticamente a memória deles.  Apesar disso, entender como o GC funciona ajudará você a escrever um código melhor. <br><br><h4>  Gerenciador de memória </h4><br>  Diferentemente de outras linguagens populares, o Python não libera toda a memória de volta para o sistema operacional assim que ele exclui um objeto.  Em vez disso, ele usa um gerenciador de memória adicional projetado para objetos pequenos (cujo tamanho é menor que 512 bytes).  Para trabalhar com esses objetos, ele aloca grandes blocos de memória, nos quais muitos objetos pequenos serão armazenados no futuro. <br><br>  Assim que um dos objetos pequenos é excluído - a memória de baixo dele não vai para o sistema operacional, o Python o deixa para novos objetos do mesmo tamanho.  Se não houver objetos restantes em um dos blocos de memória alocados, o Python poderá liberá-lo para o sistema operacional.  Normalmente, os blocos são liberados quando o script cria muitos objetos temporários. <br><a name="habracut"></a><br>  Portanto, se um processo Python de longa duração começar a consumir mais memória ao longo do tempo, isso não significa que o seu código tenha um problema de vazamento de memória.  Se você quiser saber mais sobre o gerenciador de memória no Python, leia sobre isso no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">meu outro artigo</a> . <br><br><h4>  Algoritmos de Coleta de Lixo </h4><br>  O interpretador python padrão (CPython) usa dois algoritmos ao mesmo tempo, contagem de referência e coletor de lixo geracional (doravante GC), mais conhecido como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">módulo gc</a> padrão do Python. <br><br>  O algoritmo de contagem de links é muito simples e eficiente, mas tem uma grande desvantagem.  Ele não sabe como definir referências circulares.  É por isso que em python há um coletor adicional chamado GC geracional que monitora objetos com possíveis referências circulares. <br><br>  No Python, o algoritmo de contagem de referência é fundamental e não pode ser desativado, enquanto o GC é opcional e pode ser desativado. <br><br><h4>  Algoritmo de contagem de links </h4><br>  O algoritmo de contagem de links é uma das técnicas mais fáceis de coleta de lixo.  Os objetos são excluídos assim que não são mais referenciados. <br><br>  No Python, as variáveis ​​não armazenam valores, mas atuam como referências a objetos.  Ou seja, quando você atribui um valor a uma nova variável, primeiro um objeto com esse valor é criado e somente então a variável começa a se referir a ele.  Várias variáveis ​​podem fazer referência a um único objeto. <br><br>  Cada objeto no Python contém um campo adicional (contador de referência), que armazena o número de links para ele.  Assim que alguém se refere a um objeto, esse campo é incrementado em um.  Se, por algum motivo, o link desaparecer, esse campo será reduzido em um. <br><br>  Exemplos quando o número de links aumenta: <br><br><ul><li>  operador de atribuição </li><li>  passando argumentos </li><li>  insira um novo objeto na planilha (o número de links para o objeto aumenta) </li><li>  uma construção do formulário foo = bar (foo começa a se referir ao mesmo objeto que bar) </li></ul><br>  Assim que o contador de referência para um objeto específico atingir zero, o intérprete inicia o processo de destruição do objeto.  Se o objeto remoto contiver links para outros objetos, esses links também serão excluídos.  Assim, a remoção de um objeto pode implicar a remoção de outros. <br><br>  Por exemplo, se uma lista for excluída, a contagem de referência em todos os seus elementos será reduzida em um.  Se todos os objetos da lista não forem usados ​​em nenhum outro lugar, eles também serão excluídos. <br><br>  Variáveis ​​declaradas fora de funções, classes e blocos são chamadas globais.  Normalmente, o ciclo de vida dessas variáveis ​​é igual à vida do processo Python.  Portanto, o número de referências a objetos referenciados por variáveis ​​globais nunca cai para zero. <br><br>  Variáveis ​​declaradas dentro de um bloco (função, classe) têm visibilidade local (ou seja, são visíveis apenas dentro do bloco).  Assim que o intérprete python sai do bloco, ele destrói todos os links criados pelas variáveis ​​locais dentro dele. <br><br>  Você sempre pode verificar o número de links usando a função <code>sys.getrefcount</code> . <br><br>  Exemplo de um contador de links: <br><br><pre> <code class="python hljs">foo = [] <span class="hljs-comment"><span class="hljs-comment"># 2 ,    foo    getrefcount print(sys.getrefcount(foo)) def bar(a): # 4  #  foo,   (a), getrefcount       print(sys.getrefcount(a)) bar(foo) # 2 ,      print(sys.getrefcount(foo))</span></span></code> </pre><br>  O principal motivo pelo qual o intérprete padrão (CPython) usa um contador de referência é histórico.  Atualmente, há muito debate sobre essa abordagem.  Algumas pessoas acreditam que um coletor de lixo pode ser muito mais eficiente sem um algoritmo de contagem de links.  Esse algoritmo tem muitos problemas, como links circulares, threads de bloqueio e sobrecarga adicional para memória e CPU. <br><br>  A principal vantagem desse algoritmo é que os objetos são excluídos imediatamente assim que não são necessários. <br><br><h4>  Coletor de lixo opcional </h4><br>  Por que precisamos de um algoritmo adicional quando já temos contagem de referência? <br><br>  Infelizmente, o algoritmo clássico de contagem de links tem uma grande desvantagem - ele não sabe como encontrar links circulares.  Os loopbacks ocorrem quando um ou mais objetos fazem referência um ao outro. <br><br>  Dois exemplos: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/46f/9b6/6ae/46f9b66aed851bb88c4c430a892e5670.svg" alt="imagem"><br><br>  Como você pode ver, o primeiro objeto se refere a si mesmo, enquanto o <code>object1</code> e o <code>object2</code> referem um ao outro.  Para esses objetos, a contagem de referência será sempre 1. <br><br>  Demonstração do Python: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gc <span class="hljs-comment"><span class="hljs-comment">#  ctypes        class PyObject(ctypes.Structure): _fields_ = [("refcnt", ctypes.c_long)] gc.disable() #   GC lst = [] lst.append(lst) #    lst lst_address = id(lst) #   lst del lst object_1 = {} object_2 = {} object_1['obj2'] = object_2 object_2['obj1'] = object_1 obj_address = id(object_1) #   del object_1, object_2 #          # gc.collect() #    print(PyObject.from_address(obj_address).refcnt) print(PyObject.from_address(lst_address).refcnt)</span></span></code> </pre><br>  No exemplo acima, a instrução del remove referências aos nossos objetos (não aos objetos em si).  Depois que o Python executa uma instrução del, esses objetos ficam inacessíveis a partir do código Python.  No entanto, com o módulo gc desativado, eles ainda permanecerão na memória, pois  eles tinham referências circulares e seu contador ainda é um.  Você pode explorar visualmente esses relacionamentos usando a biblioteca <code>objgraph</code> . <br><br>  Para corrigir esse problema, um algoritmo adicional conhecido como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">módulo gc</a> foi adicionado no Python 1.5.  A única tarefa é a remoção de objetos cíclicos aos quais não há mais acesso do código. <br><br>  Os loopbacks podem ocorrer apenas em objetos "contêiner".  I.e.  em objetos que podem armazenar outros objetos, como listas, dicionários, classes e tuplas.  O GC não controla tipos simples e imutáveis, exceto as tuplas.  Algumas tuplas e dicionários também são excluídos da lista de rastreamento quando determinadas condições são atendidas.  Com todos os outros objetos, o algoritmo de contagem de referência é garantido. <br><br><h4>  Quando o GC é acionado </h4><br>  Diferentemente do algoritmo de contagem de referência, o GC cíclico não funciona em tempo real e é executado periodicamente.  Cada execução do coletor cria micro-pausas no código; portanto, o CPython (intérprete padrão) usa várias heurísticas para determinar a frequência do coletor de lixo. <br><br>  O coletor de lixo cíclico divide todos os objetos em 3 gerações (gerações).  Novos objetos caem na primeira geração.  Se a nova instalação sobreviver ao processo de coleta de lixo, ela será movida para a próxima geração.  Quanto maior a geração, menos frequentemente ela é verificada quanto a lixo.  Como os novos objetos geralmente têm uma vida útil muito curta (são temporários), faz sentido entrevistá-los com mais frequência do que aqueles que já passaram por vários estágios da coleta de lixo. <br><br>  Cada geração possui um contador especial e um limite de resposta, ao atingir o qual o processo de coleta de lixo é acionado.  Cada contador armazena o número de alocações menos o número de desalocações em uma determinada geração.  Assim que qualquer objeto contêiner é criado no Python, ele verifica esses contadores.  Se as condições funcionarem, o processo de coleta de lixo será iniciado. <br><br>  Se várias ou mais gerações ultrapassaram o limite de uma vez, a geração mais antiga é selecionada.  Isso se deve ao fato de que as gerações mais antigas também examinam todas as anteriores.  Para reduzir o número de pausas na coleta de lixo para objetos de vida longa, a geração mais antiga possui <a href="">um conjunto adicional de condições</a> . <br><br>  Os limites padrão para gerações são definidos como <code>700, 10  10</code> respectivamente, mas você sempre pode alterá-los usando as <code>gc.get_threshold  gc.set_threshold</code> . <br><br><h4>  Algoritmo de pesquisa de loop </h4><br>  Uma descrição completa do algoritmo de busca de loop exigirá um artigo separado.  Em resumo, o GC itera sobre cada objeto das gerações selecionadas e remove temporariamente todos os links de um único objeto (todos os links aos quais esse objeto se refere).  Após uma passagem completa, todos os objetos com uma contagem de links menor que dois são considerados inacessíveis do python e podem ser excluídos. <br><br>  Para uma compreensão mais profunda, recomendo a leitura (a nota do tradutor: material em inglês) da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">descrição original do algoritmo de Neil Schemenauer</a> e da função de <code>collect</code> das <a href="">fontes</a> do <a href="">CPython</a> .  Uma descrição do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Quora</a> e uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">publicação sobre o coletor de lixo</a> também podem ser úteis. <br><br>  Vale ressaltar que o problema com os destruidores descrito na descrição original do algoritmo foi corrigido desde o Python 3.4 (mais detalhes no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PEP 442</a> ). <br><br><h4>  Dicas de otimização </h4><br>  Os loops geralmente ocorrem em tarefas da vida real; eles podem ser encontrados em problemas com gráficos, listas vinculadas ou em estruturas de dados em que você precisa acompanhar as relações entre os objetos.  Se o seu programa tiver uma carga alta e exigir atrasos, se possível, é melhor evitar os loops. <br><br>  Nos locais em que você usa conscientemente links circulares, pode usar links "fracos".  Links fracos são implementados no módulo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">weakref</a> e, diferentemente dos links regulares, não afetam o contador de links de forma alguma.  Se o objeto com referências fracas acabar sendo excluído, <code>None</code> retornado. <br><br>  Em alguns casos, é útil desativar a compilação automática pelo módulo gc e chamá-lo manualmente.  Para fazer isso, basta chamar <code>gc.disable()</code> e depois chamar <code>gc.collect()</code> manualmente. <br><br><h4>  Como encontrar e depurar links circulares </h4><br>  Os loops de depuração podem ser dolorosos, especialmente se o seu código usar muitos módulos de terceiros. <br><br>  O módulo gc fornece funções auxiliares que podem ajudar na depuração.  Se os parâmetros do GC estiverem definidos para o sinalizador <code>DEBUG_SAVEALL</code> , todos os objetos inacessíveis serão adicionados à lista <code>gc.garbage</code> . <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gc gc.set_debug(gc.DEBUG_SAVEALL) print(gc.get_count()) lst = [] lst.append(lst) list_id = id(lst) <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> lst gc.collect() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gc.garbage: print(item) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> list_id == id(item)</code> </pre><br>  Depois de identificar o problema, ele pode ser visualizado usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">objgraph</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3d8/355/be9/3d8355be99fea997cae6aff7fd7fb6b2.svg" alt="imagem"><br><br><h5>  Conclusão </h5><br>  O principal processo de coleta de lixo é realizado por um algoritmo de contagem de links, que é muito simples e não possui configurações.  Um algoritmo adicional é usado apenas para pesquisar e excluir objetos com referências circulares. <br><br>  Você não deve se envolver na otimização prematura do código do coletor de lixo; na prática, problemas com a coleta de lixo são bastante raros. <br><br>  PS: Eu sou o autor deste artigo, você pode fazer qualquer pergunta. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt417215/">https://habr.com/ru/post/pt417215/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt417201/index.html">Alexey Zinoviev sobre BigData + ML em jug.msk.ru</a></li>
<li><a href="../pt417203/index.html">Quebrar a pilha no STM8</a></li>
<li><a href="../pt417207/index.html">Contexto: trens-bala Hyperloop</a></li>
<li><a href="../pt417209/index.html">Redes neurais do zero. Resumo dos cursos e artigos em russo, gratuitos e sem registro</a></li>
<li><a href="../pt417211/index.html">Tabela para aprender o básico de circuitos elétricos. Porque não</a></li>
<li><a href="../pt417219/index.html">Esqueça o Burger King! Há um vazamento de documentos é muito mais perigoso</a></li>
<li><a href="../pt417221/index.html">3DTouch - Escalas no iPhone: Introdução</a></li>
<li><a href="../pt417223/index.html">Redes Neurais Capsulares</a></li>
<li><a href="../pt417225/index.html">Teorema de Boshernitsan</a></li>
<li><a href="../pt417227/index.html">O que aconteceu com o paradoxo de Fermi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>