<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüíº üõ§Ô∏è üéº Tudo o que voc√™ precisa saber sobre o coletor de lixo em Python üë∞üèΩ ü§¶üèª üèñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Geralmente, voc√™ n√£o precisa se preocupar com o coletor de lixo e trabalhar com mem√≥ria ao escrever c√≥digo Python. Assim que os objetos n√£o s√£o mais n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tudo o que voc√™ precisa saber sobre o coletor de lixo em Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417215/">  Geralmente, voc√™ n√£o precisa se preocupar com o coletor de lixo e trabalhar com mem√≥ria ao escrever c√≥digo Python.  Assim que os objetos n√£o s√£o mais necess√°rios, o Python libera automaticamente a mem√≥ria deles.  Apesar disso, entender como o GC funciona ajudar√° voc√™ a escrever um c√≥digo melhor. <br><br><h4>  Gerenciador de mem√≥ria </h4><br>  Diferentemente de outras linguagens populares, o Python n√£o libera toda a mem√≥ria de volta para o sistema operacional assim que ele exclui um objeto.  Em vez disso, ele usa um gerenciador de mem√≥ria adicional projetado para objetos pequenos (cujo tamanho √© menor que 512 bytes).  Para trabalhar com esses objetos, ele aloca grandes blocos de mem√≥ria, nos quais muitos objetos pequenos ser√£o armazenados no futuro. <br><br>  Assim que um dos objetos pequenos √© exclu√≠do - a mem√≥ria de baixo dele n√£o vai para o sistema operacional, o Python o deixa para novos objetos do mesmo tamanho.  Se n√£o houver objetos restantes em um dos blocos de mem√≥ria alocados, o Python poder√° liber√°-lo para o sistema operacional.  Normalmente, os blocos s√£o liberados quando o script cria muitos objetos tempor√°rios. <br><a name="habracut"></a><br>  Portanto, se um processo Python de longa dura√ß√£o come√ßar a consumir mais mem√≥ria ao longo do tempo, isso n√£o significa que o seu c√≥digo tenha um problema de vazamento de mem√≥ria.  Se voc√™ quiser saber mais sobre o gerenciador de mem√≥ria no Python, leia sobre isso no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">meu outro artigo</a> . <br><br><h4>  Algoritmos de Coleta de Lixo </h4><br>  O interpretador python padr√£o (CPython) usa dois algoritmos ao mesmo tempo, contagem de refer√™ncia e coletor de lixo geracional (doravante GC), mais conhecido como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">m√≥dulo gc</a> padr√£o do Python. <br><br>  O algoritmo de contagem de links √© muito simples e eficiente, mas tem uma grande desvantagem.  Ele n√£o sabe como definir refer√™ncias circulares.  √â por isso que em python h√° um coletor adicional chamado GC geracional que monitora objetos com poss√≠veis refer√™ncias circulares. <br><br>  No Python, o algoritmo de contagem de refer√™ncia √© fundamental e n√£o pode ser desativado, enquanto o GC √© opcional e pode ser desativado. <br><br><h4>  Algoritmo de contagem de links </h4><br>  O algoritmo de contagem de links √© uma das t√©cnicas mais f√°ceis de coleta de lixo.  Os objetos s√£o exclu√≠dos assim que n√£o s√£o mais referenciados. <br><br>  No Python, as vari√°veis ‚Äã‚Äãn√£o armazenam valores, mas atuam como refer√™ncias a objetos.  Ou seja, quando voc√™ atribui um valor a uma nova vari√°vel, primeiro um objeto com esse valor √© criado e somente ent√£o a vari√°vel come√ßa a se referir a ele.  V√°rias vari√°veis ‚Äã‚Äãpodem fazer refer√™ncia a um √∫nico objeto. <br><br>  Cada objeto no Python cont√©m um campo adicional (contador de refer√™ncia), que armazena o n√∫mero de links para ele.  Assim que algu√©m se refere a um objeto, esse campo √© incrementado em um.  Se, por algum motivo, o link desaparecer, esse campo ser√° reduzido em um. <br><br>  Exemplos quando o n√∫mero de links aumenta: <br><br><ul><li>  operador de atribui√ß√£o </li><li>  passando argumentos </li><li>  insira um novo objeto na planilha (o n√∫mero de links para o objeto aumenta) </li><li>  uma constru√ß√£o do formul√°rio foo = bar (foo come√ßa a se referir ao mesmo objeto que bar) </li></ul><br>  Assim que o contador de refer√™ncia para um objeto espec√≠fico atingir zero, o int√©rprete inicia o processo de destrui√ß√£o do objeto.  Se o objeto remoto contiver links para outros objetos, esses links tamb√©m ser√£o exclu√≠dos.  Assim, a remo√ß√£o de um objeto pode implicar a remo√ß√£o de outros. <br><br>  Por exemplo, se uma lista for exclu√≠da, a contagem de refer√™ncia em todos os seus elementos ser√° reduzida em um.  Se todos os objetos da lista n√£o forem usados ‚Äã‚Äãem nenhum outro lugar, eles tamb√©m ser√£o exclu√≠dos. <br><br>  Vari√°veis ‚Äã‚Äãdeclaradas fora de fun√ß√µes, classes e blocos s√£o chamadas globais.  Normalmente, o ciclo de vida dessas vari√°veis ‚Äã‚Äã√© igual √† vida do processo Python.  Portanto, o n√∫mero de refer√™ncias a objetos referenciados por vari√°veis ‚Äã‚Äãglobais nunca cai para zero. <br><br>  Vari√°veis ‚Äã‚Äãdeclaradas dentro de um bloco (fun√ß√£o, classe) t√™m visibilidade local (ou seja, s√£o vis√≠veis apenas dentro do bloco).  Assim que o int√©rprete python sai do bloco, ele destr√≥i todos os links criados pelas vari√°veis ‚Äã‚Äãlocais dentro dele. <br><br>  Voc√™ sempre pode verificar o n√∫mero de links usando a fun√ß√£o <code>sys.getrefcount</code> . <br><br>  Exemplo de um contador de links: <br><br><pre> <code class="python hljs">foo = [] <span class="hljs-comment"><span class="hljs-comment"># 2 ,    foo    getrefcount print(sys.getrefcount(foo)) def bar(a): # 4  #  foo,   (a), getrefcount       print(sys.getrefcount(a)) bar(foo) # 2 ,      print(sys.getrefcount(foo))</span></span></code> </pre><br>  O principal motivo pelo qual o int√©rprete padr√£o (CPython) usa um contador de refer√™ncia √© hist√≥rico.  Atualmente, h√° muito debate sobre essa abordagem.  Algumas pessoas acreditam que um coletor de lixo pode ser muito mais eficiente sem um algoritmo de contagem de links.  Esse algoritmo tem muitos problemas, como links circulares, threads de bloqueio e sobrecarga adicional para mem√≥ria e CPU. <br><br>  A principal vantagem desse algoritmo √© que os objetos s√£o exclu√≠dos imediatamente assim que n√£o s√£o necess√°rios. <br><br><h4>  Coletor de lixo opcional </h4><br>  Por que precisamos de um algoritmo adicional quando j√° temos contagem de refer√™ncia? <br><br>  Infelizmente, o algoritmo cl√°ssico de contagem de links tem uma grande desvantagem - ele n√£o sabe como encontrar links circulares.  Os loopbacks ocorrem quando um ou mais objetos fazem refer√™ncia um ao outro. <br><br>  Dois exemplos: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/46f/9b6/6ae/46f9b66aed851bb88c4c430a892e5670.svg" alt="imagem"><br><br>  Como voc√™ pode ver, o primeiro objeto se refere a si mesmo, enquanto o <code>object1</code> e o <code>object2</code> referem um ao outro.  Para esses objetos, a contagem de refer√™ncia ser√° sempre 1. <br><br>  Demonstra√ß√£o do Python: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gc <span class="hljs-comment"><span class="hljs-comment">#  ctypes        class PyObject(ctypes.Structure): _fields_ = [("refcnt", ctypes.c_long)] gc.disable() #   GC lst = [] lst.append(lst) #    lst lst_address = id(lst) #   lst del lst object_1 = {} object_2 = {} object_1['obj2'] = object_2 object_2['obj1'] = object_1 obj_address = id(object_1) #   del object_1, object_2 #          # gc.collect() #    print(PyObject.from_address(obj_address).refcnt) print(PyObject.from_address(lst_address).refcnt)</span></span></code> </pre><br>  No exemplo acima, a instru√ß√£o del remove refer√™ncias aos nossos objetos (n√£o aos objetos em si).  Depois que o Python executa uma instru√ß√£o del, esses objetos ficam inacess√≠veis a partir do c√≥digo Python.  No entanto, com o m√≥dulo gc desativado, eles ainda permanecer√£o na mem√≥ria, pois  eles tinham refer√™ncias circulares e seu contador ainda √© um.  Voc√™ pode explorar visualmente esses relacionamentos usando a biblioteca <code>objgraph</code> . <br><br>  Para corrigir esse problema, um algoritmo adicional conhecido como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">m√≥dulo gc</a> foi adicionado no Python 1.5.  A √∫nica tarefa √© a remo√ß√£o de objetos c√≠clicos aos quais n√£o h√° mais acesso do c√≥digo. <br><br>  Os loopbacks podem ocorrer apenas em objetos "cont√™iner".  I.e.  em objetos que podem armazenar outros objetos, como listas, dicion√°rios, classes e tuplas.  O GC n√£o controla tipos simples e imut√°veis, exceto as tuplas.  Algumas tuplas e dicion√°rios tamb√©m s√£o exclu√≠dos da lista de rastreamento quando determinadas condi√ß√µes s√£o atendidas.  Com todos os outros objetos, o algoritmo de contagem de refer√™ncia √© garantido. <br><br><h4>  Quando o GC √© acionado </h4><br>  Diferentemente do algoritmo de contagem de refer√™ncia, o GC c√≠clico n√£o funciona em tempo real e √© executado periodicamente.  Cada execu√ß√£o do coletor cria micro-pausas no c√≥digo; portanto, o CPython (int√©rprete padr√£o) usa v√°rias heur√≠sticas para determinar a frequ√™ncia do coletor de lixo. <br><br>  O coletor de lixo c√≠clico divide todos os objetos em 3 gera√ß√µes (gera√ß√µes).  Novos objetos caem na primeira gera√ß√£o.  Se a nova instala√ß√£o sobreviver ao processo de coleta de lixo, ela ser√° movida para a pr√≥xima gera√ß√£o.  Quanto maior a gera√ß√£o, menos frequentemente ela √© verificada quanto a lixo.  Como os novos objetos geralmente t√™m uma vida √∫til muito curta (s√£o tempor√°rios), faz sentido entrevist√°-los com mais frequ√™ncia do que aqueles que j√° passaram por v√°rios est√°gios da coleta de lixo. <br><br>  Cada gera√ß√£o possui um contador especial e um limite de resposta, ao atingir o qual o processo de coleta de lixo √© acionado.  Cada contador armazena o n√∫mero de aloca√ß√µes menos o n√∫mero de desaloca√ß√µes em uma determinada gera√ß√£o.  Assim que qualquer objeto cont√™iner √© criado no Python, ele verifica esses contadores.  Se as condi√ß√µes funcionarem, o processo de coleta de lixo ser√° iniciado. <br><br>  Se v√°rias ou mais gera√ß√µes ultrapassaram o limite de uma vez, a gera√ß√£o mais antiga √© selecionada.  Isso se deve ao fato de que as gera√ß√µes mais antigas tamb√©m examinam todas as anteriores.  Para reduzir o n√∫mero de pausas na coleta de lixo para objetos de vida longa, a gera√ß√£o mais antiga possui <a href="">um conjunto adicional de condi√ß√µes</a> . <br><br>  Os limites padr√£o para gera√ß√µes s√£o definidos como <code>700, 10  10</code> respectivamente, mas voc√™ sempre pode alter√°-los usando as <code>gc.get_threshold  gc.set_threshold</code> . <br><br><h4>  Algoritmo de pesquisa de loop </h4><br>  Uma descri√ß√£o completa do algoritmo de busca de loop exigir√° um artigo separado.  Em resumo, o GC itera sobre cada objeto das gera√ß√µes selecionadas e remove temporariamente todos os links de um √∫nico objeto (todos os links aos quais esse objeto se refere).  Ap√≥s uma passagem completa, todos os objetos com uma contagem de links menor que dois s√£o considerados inacess√≠veis do python e podem ser exclu√≠dos. <br><br>  Para uma compreens√£o mais profunda, recomendo a leitura (a nota do tradutor: material em ingl√™s) da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">descri√ß√£o original do algoritmo de Neil Schemenauer</a> e da fun√ß√£o de <code>collect</code> das <a href="">fontes</a> do <a href="">CPython</a> .  Uma descri√ß√£o do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Quora</a> e uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">publica√ß√£o sobre o coletor de lixo</a> tamb√©m podem ser √∫teis. <br><br>  Vale ressaltar que o problema com os destruidores descrito na descri√ß√£o original do algoritmo foi corrigido desde o Python 3.4 (mais detalhes no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PEP 442</a> ). <br><br><h4>  Dicas de otimiza√ß√£o </h4><br>  Os loops geralmente ocorrem em tarefas da vida real; eles podem ser encontrados em problemas com gr√°ficos, listas vinculadas ou em estruturas de dados em que voc√™ precisa acompanhar as rela√ß√µes entre os objetos.  Se o seu programa tiver uma carga alta e exigir atrasos, se poss√≠vel, √© melhor evitar os loops. <br><br>  Nos locais em que voc√™ usa conscientemente links circulares, pode usar links "fracos".  Links fracos s√£o implementados no m√≥dulo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">weakref</a> e, diferentemente dos links regulares, n√£o afetam o contador de links de forma alguma.  Se o objeto com refer√™ncias fracas acabar sendo exclu√≠do, <code>None</code> retornado. <br><br>  Em alguns casos, √© √∫til desativar a compila√ß√£o autom√°tica pelo m√≥dulo gc e cham√°-lo manualmente.  Para fazer isso, basta chamar <code>gc.disable()</code> e depois chamar <code>gc.collect()</code> manualmente. <br><br><h4>  Como encontrar e depurar links circulares </h4><br>  Os loops de depura√ß√£o podem ser dolorosos, especialmente se o seu c√≥digo usar muitos m√≥dulos de terceiros. <br><br>  O m√≥dulo gc fornece fun√ß√µes auxiliares que podem ajudar na depura√ß√£o.  Se os par√¢metros do GC estiverem definidos para o sinalizador <code>DEBUG_SAVEALL</code> , todos os objetos inacess√≠veis ser√£o adicionados √† lista <code>gc.garbage</code> . <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gc gc.set_debug(gc.DEBUG_SAVEALL) print(gc.get_count()) lst = [] lst.append(lst) list_id = id(lst) <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> lst gc.collect() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gc.garbage: print(item) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> list_id == id(item)</code> </pre><br>  Depois de identificar o problema, ele pode ser visualizado usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">objgraph</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3d8/355/be9/3d8355be99fea997cae6aff7fd7fb6b2.svg" alt="imagem"><br><br><h5>  Conclus√£o </h5><br>  O principal processo de coleta de lixo √© realizado por um algoritmo de contagem de links, que √© muito simples e n√£o possui configura√ß√µes.  Um algoritmo adicional √© usado apenas para pesquisar e excluir objetos com refer√™ncias circulares. <br><br>  Voc√™ n√£o deve se envolver na otimiza√ß√£o prematura do c√≥digo do coletor de lixo; na pr√°tica, problemas com a coleta de lixo s√£o bastante raros. <br><br>  PS: Eu sou o autor deste artigo, voc√™ pode fazer qualquer pergunta. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt417215/">https://habr.com/ru/post/pt417215/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt417201/index.html">Alexey Zinoviev sobre BigData + ML em jug.msk.ru</a></li>
<li><a href="../pt417203/index.html">Quebrar a pilha no STM8</a></li>
<li><a href="../pt417207/index.html">Contexto: trens-bala Hyperloop</a></li>
<li><a href="../pt417209/index.html">Redes neurais do zero. Resumo dos cursos e artigos em russo, gratuitos e sem registro</a></li>
<li><a href="../pt417211/index.html">Tabela para aprender o b√°sico de circuitos el√©tricos. Porque n√£o</a></li>
<li><a href="../pt417219/index.html">Esque√ßa o Burger King! H√° um vazamento de documentos √© muito mais perigoso</a></li>
<li><a href="../pt417221/index.html">3DTouch - Escalas no iPhone: Introdu√ß√£o</a></li>
<li><a href="../pt417223/index.html">Redes Neurais Capsulares</a></li>
<li><a href="../pt417225/index.html">Teorema de Boshernitsan</a></li>
<li><a href="../pt417227/index.html">O que aconteceu com o paradoxo de Fermi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>