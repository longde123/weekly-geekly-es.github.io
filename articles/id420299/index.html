<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘µğŸ» ğŸŒ¹ ğŸ“– Contoh favorit saya tentang pemrograman fungsional di Kotlin ğŸ‘©ğŸ¼ â° âŒ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salah satu fitur hebat Kotlin adalah mendukung pemrograman fungsional. Mari kita lihat dan bahas beberapa fungsi sederhana namun ekspresif yang dituli...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Contoh favorit saya tentang pemrograman fungsional di Kotlin</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420299/"><p>  Salah satu fitur hebat Kotlin adalah mendukung pemrograman fungsional.  Mari kita lihat dan bahas beberapa fungsi sederhana namun ekspresif yang ditulis dalam Kotlin. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1f2/8bd/347/1f28bd3472067f00fb324fb500176cb0.png" alt="Contoh favorit saya tentang pemrograman fungsional di Kotlin"></p><a name="habracut"></a><br><h3 id="rabota-s-kollekciyami">  Bekerja dengan koleksi </h3><br><p> Kotlin mendukung pekerjaan yang mudah dengan koleksi.  Ada banyak fitur berbeda.  Misalkan kita membuat beberapa sistem untuk universitas.  Kita perlu menemukan siswa terbaik yang berhak mendapatkan beasiswa.  Kami memiliki model <code>Student</code> berikut: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Student</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> surname: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> passing: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> averageGrade: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span> )</code> </pre> <br><p>  Sekarang kita dapat memanggil fungsi berikut untuk mendapatkan daftar sepuluh siswa terbaik yang memenuhi semua kriteria: </p><br><pre> <code class="hljs pgsql">students.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span> { it.<span class="hljs-keyword"><span class="hljs-keyword">passing</span></span> &amp;&amp; it.averageGrade &gt; <span class="hljs-number"><span class="hljs-number">4.0</span></span> } // <span class="hljs-number"><span class="hljs-number">1</span></span> .sortedBy { it.averageGrade } // <span class="hljs-number"><span class="hljs-number">2</span></span> .take(<span class="hljs-number"><span class="hljs-number">10</span></span>) // <span class="hljs-number"><span class="hljs-number">3</span></span> .sortedWith(compareBy({ it.surname }, { it.name })) // <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre><br><ul><li>  Kami hanya menyisakan siswa yang telah lulus ujian, skor rata-rata lebih dari 4.0. </li><li>  Urutkan berdasarkan skor rata-rata. </li><li>  Kami meninggalkan sepuluh siswa pertama. </li><li>  Urutkan berdasarkan abjad.  Pembanding pertama membandingkan nama belakang, dan jika mereka sama, maka itu membandingkan nama-nama. </li></ul><br><p>  Bagaimana jika, alih-alih urutan abjad, kita perlu mempertahankan urutan asli siswa?  Kita dapat melakukan ini menggunakan indeks: </p><br><pre> <code class="hljs erlang-repl">students.filter { it.passing &amp;&amp; it.averageGrade &gt; <span class="hljs-number"><span class="hljs-number">4.0</span></span> } .withIndex() // <span class="hljs-number"><span class="hljs-number">1</span></span> .sortedBy { (i, s) -&gt; s.averageGrade } // <span class="hljs-number"><span class="hljs-number">2</span></span> .take(<span class="hljs-number"><span class="hljs-number">10</span></span>) .sortedBy { (i, s) -&gt; i } // <span class="hljs-number"><span class="hljs-number">3</span></span> .map { (i, s) -&gt; s } // <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br><ul><li>  Ikatkan indeks iterasi saat ini untuk setiap elemen. </li><li>  Urutkan berdasarkan skor rata-rata dan tinggalkan sepuluh siswa pertama. </li><li>  Sortir lagi, tetapi sekarang dengan indeks. </li><li>  Kami menghapus indeks dan hanya menyisakan siswa. </li></ul><br><p>  Contoh ini menunjukkan betapa sederhana dan intuitifnya pekerjaan dengan koleksi di Kotlin. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/288/6f3/3a6/2886f33a698851f73a1e3003367e5f56.jpg" alt="Bekerja dengan koleksi di Kotlin"></p><br><h3 id="supermnozhestvo-buleanhttpsruwikipediaorgwikid091d183d0bbd0b5d0b0d0bd">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SuperSet (Boolean)</a> </h3><br><p>  Jika Anda belajar aljabar di universitas, Anda mungkin ingat apa itu superset.  Untuk set apa pun, supersetnya adalah himpunan semua himpunan bagiannya, termasuk himpunan asli itu sendiri dan himpunan kosong.  Misalnya, jika kita memiliki set berikut: </p><br><p>  {1,2,3} </p><br><p>  Itulah supersetnya: </p><br><p>  {{}, {1}, {2}, {3}, {1,2}, {1,3}, {2,3}, {1,2,3}} </p><br><p>  Dalam aljabar, fungsi seperti itu sangat berguna.  Bagaimana kita menerapkannya? </p><br><p>  Jika Anda ingin menantang diri sendiri, berhentilah membaca sekarang dan cobalah untuk menyelesaikan masalah ini sendiri. </p><br><p>  Mari kita mulai analisis kita dengan pengamatan sederhana.  Jika kita mengambil beberapa elemen dari himpunan (misalnya, 1), maka super-set akan memiliki jumlah set yang sama dengan elemen ini ({1}, {1,2}, {1,3}, {1,2,3}) dan tanpanya ({}, {2}, {3}, {2,3}). </p><br><p>  Perhatikan bahwa set kedua adalah set super ({2,3}), dan set pertama adalah set super ({2,3}) dengan elemen tambahan kami (1) untuk setiap set.  Dengan demikian, kita dapat menghitung superset dengan mengambil elemen pertama, menghitung superset untuk yang lainnya dan mengembalikan jumlah hasil dan hasilnya dengan menambahkan elemen pertama ke setiap set: </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">powerset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">set</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Set</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: Set&lt;Set&lt;T&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> first = <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.first() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> powersetOfRest = powerset(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.drop(<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> powersetOfRest.map { it + first } + powersetOfRest }</code> </pre> <br><p>  Tetapi metode ini tidak akan berhasil.  Masalahnya adalah set kosong: <code>first</code> akan melempar kesalahan ketika set kosong.  Di sini definisi superset datang untuk menyelamatkan - superset dari set kosong adalah set kosong: powerset ({}) = {{}}.  Seperti apa algoritma yang dikoreksi: </p><br><pre> <code class="hljs pgsql">fun &lt;T&gt; powerset(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;T&gt;): <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;T&gt;&gt; = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.isEmpty()) <span class="hljs-keyword"><span class="hljs-keyword">setOf</span></span>(emptySet()) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { val powersetOfRest = powerset(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">drop</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)) powersetOfRest + powersetOfRest.map { it + <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.first() } }</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/aea/150/ee3/aea150ee316f7800b56220e8dbd10b5f.png" alt="Meme rekursi"></p><br><p>  Mari kita lihat cara kerjanya.  Misalkan kita perlu menghitung powerset ({1,2,3}).  Algoritme akan bertindak sebagai berikut: </p><br><p>  powerset ({1,2,3}) = powerset ({2,3}) + powerset ({2,3}). map {it + 1} </p><br><p>  powerset ({2,3}) = powerset ({3}) + powerset ({3}). map {it + 2} </p><br><p>  powerset ({3}) = powerset ({}) + powerset ({}). map {it + 3} </p><br><p>  powerset ({}) = {{}} </p><br><p>  powerset ({3}) = {{}, {3}} </p><br><p>  powerset ({2,3}) = {{}, {3}} + {{2}, {2, 3}} = {{}, {2}, {3}, {2, 3}} </p><br><p>  powerset ({1,2,3}) = {{}, {2}, {3}, {2, 3}} + {{1}, {1, 2}, {1, 3}, {1, 2, 3}} = {{}, {1}, {2}, {3}, {1,2}, {1,3}, {2,3}, {1,2,3}} </p><br><p>  Tetapi kita dapat meningkatkan fungsi kita lebih jauh.  Mari kita gunakan fungsi let untuk membuat notasi lebih pendek dan lebih kompak: </p><br><pre> <code class="hljs pgsql">fun &lt;T&gt; powerset(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;T&gt;): <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;T&gt;&gt; = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.isEmpty()) <span class="hljs-keyword"><span class="hljs-keyword">setOf</span></span>(emptySet()) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> powerset(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">drop</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)) .let { it+ it.map { it + <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.first() }</code> </pre> <br><p>  Kita juga dapat mendefinisikan fungsi ini sebagai fungsi ekstensi untuk <code>Collection</code> , sehingga kita dapat menggunakan fungsi ini seolah-olah itu adalah metode <code>Set</code> ( <code>setOf(1,2,3).powerset()</code> alih-alih <code>powerset(setOf(1,2,3))</code> ): </p><br><pre> <code class="hljs pgsql">fun &lt;T&gt; Collection&lt;T&gt;.powerset(): <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;T&gt;&gt; = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isEmpty()) <span class="hljs-keyword"><span class="hljs-keyword">setOf</span></span>(emptySet()) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) .powerset() .let { it+ it.map { it + first() }</code> </pre> <br><p>  Kami juga dapat mengurangi efek negatif dari rekursi yang dibuat.  Dalam implementasi di atas, keadaan superset tumbuh dengan setiap iterasi (dengan setiap panggilan rekursif), karena keadaan iterasi sebelumnya harus disimpan dalam memori. </p><br><p>  Sebagai gantinya, kita bisa menggunakan <code>tailrec</code> fungsi loop atau <code>tailrec</code> .  Kami akan menggunakan opsi kedua untuk menjaga keterbacaan fungsi.  Pengubah <code>tailrec</code> hanya memungkinkan satu panggilan rekursif di baris fungsi terakhir yang dijalankan.  Inilah cara kami dapat mengubah fungsi kami untuk menggunakannya secara lebih efisien: </p><br><pre> <code class="hljs pgsql">fun &lt;T&gt; Collection&lt;T&gt;.powerset(): <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;T&gt;&gt; = powerset(this, <span class="hljs-keyword"><span class="hljs-keyword">setOf</span></span>(emptySet())) private tailrec fun &lt;T&gt; powerset(left: Collection&lt;T&gt;, acc: <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;T&gt;&gt;): <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;T&gt;&gt; = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left.isEmpty()) acc <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> powerset(left.<span class="hljs-keyword"><span class="hljs-keyword">drop</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>), acc + acc.map { it + left.first() })</code> </pre> <br><p>  Implementasi ini adalah bagian dari perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">KotlinDiscreteMathToolkit</a> , yang mendefinisikan banyak fungsi lain yang digunakan dalam matematika diskrit. </p><br><h3 id="bystraya-sortirovka-quicksorthttpsruwikipediaorgwikid091d18bd181d182d180d0b0d18f_d181d0bed180d182d0b8d180d0bed0b2d0bad0b0">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Quicksort</a> </h3><br><p>  Saatnya untuk contoh paling menarik.  Anda akan melihat bagaimana masalah yang rumit dapat disederhanakan dan dibuat dapat dibaca menggunakan alat pemrograman gaya dan fungsional. </p><br><p>  Kami menerapkan algoritma pengurutan cepat.  Algoritma ini sederhana: kami memilih beberapa elemen (pivot ( <em>bilah</em> Rusia)) dan mendistribusikan semua elemen lainnya ke dalam dua daftar: daftar dengan elemen lebih besar dari bilah dan lebih kecil.  Kemudian kami secara rekursif menyortir subarrays ini.  Akhirnya, kami menggabungkan daftar elemen yang lebih kecil, bar, dan daftar yang diurutkan dari elemen yang lebih besar.  Untuk menyederhanakan, ambil elemen pertama sebagai bilah.  Berikut ini adalah implementasi lengkapnya: </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T : Comparable&lt;T&gt;</span></span></span><span class="hljs-function">&gt; List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quickSort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;T&gt; = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(size &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pivot = first() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (smaller, greater) = drop(<span class="hljs-number"><span class="hljs-number">1</span></span>).partition { it &lt;= pivot} smaller.quickSort() + pivot + greater.quickSort() } <span class="hljs-comment"><span class="hljs-comment">// Usage listOf(2,5,1).quickSort() // [1,2,5]</span></span></code> </pre> <br><p>  Terlihat cantik, bukan?  Inilah keindahan pemrograman fungsional. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/272/390/e2b/272390e2bd0960c5c5c9bf1dd42fa5e9.jpg" alt="Pemrograman fungsional"></p><br><p>  Masalah pertama dengan fungsi seperti itu adalah waktu pelaksanaannya.  Dia benar-benar tidak dioptimalkan.  Tapi itu pendek dan mudah dibaca. </p><br><p>  Jika Anda membutuhkan fungsi yang dioptimalkan, Anda dapat menggunakan fungsi dari perpustakaan Java standar.  Ini didasarkan pada berbagai algoritma tergantung pada kondisi tertentu, dan ditulis secara asli.  Ini harus jauh lebih efisien.  Tapi seberapa tepatnya?  Mari kita bandingkan dua fungsi ini.  Mari kita mengurutkan beberapa array berbeda dengan elemen acak dan membandingkan runtime: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r = Random() listOf(<span class="hljs-number"><span class="hljs-number">100_000</span></span>, <span class="hljs-number"><span class="hljs-number">1_000_000</span></span>, <span class="hljs-number"><span class="hljs-number">10_000_000</span></span>) .asSequence() .map { (<span class="hljs-number"><span class="hljs-number">1</span></span>..it).map { r.nextInt(<span class="hljs-number"><span class="hljs-number">1000000000</span></span>) } } .forEach { list: List&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt; -&gt; println(<span class="hljs-string"><span class="hljs-string">"Java stdlib sorting of </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${list.size}</span></span></span><span class="hljs-string"> elements took </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${measureTimeMillis { list.sorted() }</span></span></span><span class="hljs-string">}"</span></span>) println(<span class="hljs-string"><span class="hljs-string">"quickSort sorting of </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${list.size}</span></span></span><span class="hljs-string"> elements took </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${measureTimeMillis { list.quickSort() }</span></span></span><span class="hljs-string">}"</span></span>) }</code> </pre> <br><p>  Inilah hasil yang kami dapatkan: </p><br><p>  Pengurutan stdlib Java dari 100.000 elemen mengambil 83 <br>  penyortiran quickSort dari 100.000 elemen mengambil 163 <br>  Pengurutan stdlib Java dari 1.000.000 elemen mengambil 558 <br>  penyortiran quickSort dari 1.000.000 elemen membutuhkan 859 <br>  Pengurutan stdlib Java dari 10.000.000 elemen mengambil 6182 <br>  penyortiran quickSort dari 10.000.000 elemen membutuhkan 1.2133 </p><br><p>  Seperti yang Anda lihat, fungsi <code>quickSort</code> hampir 2 kali lebih lambat.  Bahkan untuk daftar besar.  Dalam kasus normal, perbedaannya biasanya dari 0,1 ms ke 0,2 ms.  Ini menjelaskan mengapa dalam beberapa kasus kita dapat menggunakan fungsi yang sedikit kurang dioptimalkan, tetapi mudah dibaca dan sederhana. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420299/">https://habr.com/ru/post/id420299/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420289/index.html">Bagaimana kami memasukkan tabel ke dalam layar smartphone dan menyatukannya sebagai bagian dari sistem desain</a></li>
<li><a href="../id420291/index.html">Spectre dan Meltdown bukan lagi serangan paling berbahaya pada CPU Intel. Laporan Peneliti Kerentanan Foreshadow</a></li>
<li><a href="../id420293/index.html">33 server dua unit dengan 13 TB RAM dan penyimpanan terdistribusi 0,6 PT - mengapa ini minimum untuk UBA proaktif</a></li>
<li><a href="../id420295/index.html">NeoQUEST-2018: Sepatu Boot yang telah lama ditunggu-tunggu, penelitian sains, dan tamu dari Nizhny Novgorod</a></li>
<li><a href="../id420297/index.html">Petunjuk langkah demi langkah untuk mendapatkan kembali akses ke Linux Amazon EC2 saat kehilangan file pem</a></li>
<li><a href="../id420301/index.html">Perdana Menteri India Narendra Modi: kami akan mengirim bendera negara itu ke luar angkasa bersama Gaganyan pada tahun 2022</a></li>
<li><a href="../id420303/index.html">Muat penyeimbangan saat mem-parsing situs dan menghubungkan sumber daya cloud tambahan</a></li>
<li><a href="../id420305/index.html">Bagaimana cara menulis program di persimpangan pengembangan dan algoritme seluler? Kompetisi dan cerita Yandex</a></li>
<li><a href="../id420307/index.html">5 Trik CSS Yang Harus Anda Ketahui</a></li>
<li><a href="../id420311/index.html">Bagaimana intuisi kita menipu kita tentang pemanasan global</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>