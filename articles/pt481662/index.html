<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üà∏ ‚úçüèΩ ‚õ∏Ô∏è Tentando novas ferramentas para criar e automatizar a implanta√ß√£o no Kubernetes üêøÔ∏è ‚òÅÔ∏è üíÜüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Oi Recentemente, muitas ferramentas interessantes de automa√ß√£o foram lan√ßadas para criar imagens do Docker e implantar no Kubernetes. Nesse sentido, d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tentando novas ferramentas para criar e automatizar a implanta√ß√£o no Kubernetes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481662/"><p><img src="https://habrastorage.org/webt/fu/wy/ia/fuwyia7huxrflvry8lzz2dbl2tw.png"></p><br><p>  Oi  Recentemente, muitas ferramentas interessantes de automa√ß√£o foram lan√ßadas para criar imagens do Docker e implantar no Kubernetes.  Nesse sentido, decidi brincar com o gitlab, como estudar suas capacidades e, √© claro, configurar o pipeline. </p><br><p>  A inspira√ß√£o para este trabalho foi o site <a href="https://kubernetes.io/" rel="nofollow">kubernetes.io</a> , que √© gerado automaticamente a partir dos <a href="http://github.com/kubernetes/website" rel="nofollow">c√≥digos-fonte</a> e, para cada pool enviado, o rob√¥ gera automaticamente uma vers√£o de visualiza√ß√£o do site com suas altera√ß√µes e fornece um link para visualiza√ß√£o. </p><br><p>  Tentei criar um processo semelhante do zero, mas totalmente baseado no Gitlab CI e nas ferramentas gratuitas que costumava usar para implantar aplicativos no Kubernetes.  Hoje finalmente vou lhe contar mais sobre eles. </p><br><p>  O artigo considerar√° ferramentas como: <br>  <strong>Hugo</strong> , <strong>qbec</strong> , <strong>kaniko</strong> , <strong>git-crypt</strong> e <strong>GitLab CI</strong> com a cria√ß√£o de ambientes din√¢micos. </p><a name="habracut"></a><br><hr><br><h1 id="coderzhanie">  Conte√∫do </h1><br><ol><li>  <a href="https://habr.com/ru/post/481662/"><strong>Apresentando Hugo</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Preparando o Dockerfile</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Familiaridade com Kaniko</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Apresentando qbec</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Tentando o Gitlab-runner com o Kubernetes-executor</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Implanta√ß√£o de gr√°ficos Helm com qbec</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Apresentando o git-crypt</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Criar uma imagem da caixa de ferramentas</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Nosso primeiro pipeline e montagem de imagens por tags</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Automa√ß√£o de implanta√ß√£o</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Artefatos e push build in master</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Ambientes din√¢micos</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Analisar aplicativos</strong></a> </li></ol><br><hr><br><h1 id="1-znakomstvo-s-hugoanchorhugoanchor">  1. Apresentando Hugo <a name="hugo"></a></h1><br><p>  Como exemplo do nosso projeto, tentaremos criar um site para publicar a documenta√ß√£o criada no Hugo.  Hugo √© um gerador de conte√∫do est√°tico. </p><br><p>  Para aqueles que n√£o est√£o familiarizados com geradores est√°ticos, vou falar um pouco mais sobre eles.  Diferente dos mecanismos regulares de sites de banco de dados e de alguns mecanismos php que, quando solicitados pelo usu√°rio, geram p√°ginas dinamicamente, os geradores est√°ticos s√£o organizados de maneira um pouco diferente.  Eles permitem que voc√™ pegue a fonte, como regra, √© um conjunto de arquivos na marca√ß√£o Markdown e nos modelos de tema e os compile em um site totalmente acabado. </p><br><p>  Ou seja, na sa√≠da, voc√™ obter√° uma estrutura de diret√≥rios e um conjunto de arquivos html gerados que podem ser simplesmente enviados para qualquer hospedagem barata e obter um site de trabalho. </p><br><p>  Hugo pode ser instalado localmente e test√°-lo: </p><br><p>  Inicializamos o novo site: </p><br><pre><code class="bash hljs">hugo new site docs.example.org</code> </pre> <br><p>  E ao mesmo tempo o reposit√≥rio git: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> docs.example.org git init</code> </pre> <br><p>  At√© agora, nosso site √© primitivo e, para que algo apare√ßa primeiro, precisamos conectar um tema, um tema - √© apenas um conjunto de modelos e regras predefinidas pelas quais nosso site √© gerado. </p><br><p>  Como t√≥pico, usaremos o <a href="https://themes.gohugo.io/hugo-theme-learn/" rel="nofollow"><strong>Learn</strong></a> , que, na minha opini√£o, √© o mais adequado para um site com documenta√ß√£o. </p><br><p>  Gostaria de prestar aten√ß√£o especial ao fato de que n√£o precisamos salvar arquivos de tema no reposit√≥rio do nosso projeto. Em vez disso, podemos simplesmente conect√°-lo usando o <strong>submodule git</strong> : </p><br><pre> <code class="bash hljs">git submodule add https://github.com/matcornic/hugo-theme-learn themes/learn</code> </pre> <br><p>  Assim, apenas os arquivos diretamente relacionados ao nosso projeto estar√£o em nosso reposit√≥rio, e o t√≥pico conectado permanecer√° na forma de um link para um reposit√≥rio espec√≠fico e ser√° confirmado, ou seja, sempre poder√° ser extra√≠do da fonte original e n√£o ter medo de altera√ß√µes incompat√≠veis. </p><br><p>  Corrija a configura√ß√£o <strong>config.toml</strong> : </p><br><pre> <code class="plaintext hljs">baseURL = "http://docs.example.org/" languageCode = "en-us" title = "My Docs Site" theme = "learn"</code> </pre> <br><p>  J√° nesta fase, voc√™ pode executar: </p><br><pre> <code class="bash hljs">hugo server</code> </pre> <br><p>  E em <a href="http://localhost:1313/" rel="nofollow">http: // localhost: 1313 /</a> verifique nosso site rec√©m-criado, todas as altera√ß√µes feitas no diret√≥rio s√£o atualizadas automaticamente e a p√°gina aberta no navegador √© muito conveniente! </p><br><p>  Vamos tentar criar uma p√°gina de rosto em <strong>content / _index.md</strong> : </p><br><pre> <code class="markdown hljs"><span class="hljs-section"><span class="hljs-section"># My docs site ## Welcome to the docs! You will be very smart :-)</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Captura de tela da p√°gina rec√©m-criada</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/gb/yx/nv/gbyxnvagfs6bks4iqbwcrrovumu.png"></p></div></div><br><p>  Para gerar um site, basta executar: </p><br><pre> <code class="bash hljs">hugo</code> </pre> <br><p>  O conte√∫do do diret√≥rio <strong>p√∫blico /</strong> ser√° o seu site. <br>  Sim, a prop√≥sito, vamos adicion√°-lo imediatamente ao <strong>.gitignore</strong> : </p><br><pre> <code class="plaintext hljs">echo /public &gt; .gitignore</code> </pre> <br><p>  N√£o se esque√ßa de confirmar nossas altera√ß√µes: </p><br><pre> <code class="plaintext hljs">git add . git commit -m "New site created"</code> </pre> <br><hr><br><h1 id="2-podgotovka-dockerfileanchordockerfileanchor">  2. Preparando o Dockerfile <a name="dockerfile"></a></h1><br><p>  Est√° na hora de determinar a estrutura do nosso reposit√≥rio.  Normalmente eu uso algo como: </p><br><pre> <code class="plaintext hljs">. ‚îú‚îÄ‚îÄ deploy ‚îÇ ‚îú‚îÄ‚îÄ app1 ‚îÇ ‚îî‚îÄ‚îÄ app2 ‚îî‚îÄ‚îÄ dockerfiles ‚îú‚îÄ‚îÄ image1 ‚îî‚îÄ‚îÄ image2</code> </pre> <br><ul><li>  <strong>dockerfiles /</strong> - cont√©m diret√≥rios com Dockerfiles e tudo o que voc√™ precisa para criar nossas imagens do docker. </li><li>  <strong>deploy /</strong> - cont√©m diret√≥rios para implantar nossos aplicativos no Kubernetes </li></ul><br><p>  Assim, criaremos nosso primeiro Dockerfile ao longo do caminho <strong>dockerfiles / website / Dockerfile</strong> </p><br><pre> <code class="bash hljs">FROM alpine:3.11 as builder ARG HUGO_VERSION=0.62.0 RUN wget -O- https://github.com/gohugoio/hugo/releases/download/v<span class="hljs-variable"><span class="hljs-variable">${HUGO_VERSION}</span></span>/hugo_<span class="hljs-variable"><span class="hljs-variable">${HUGO_VERSION}</span></span>_linux-64bit.tar.gz | tar -xz -C /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin ADD . /src RUN hugo -s /src FROM alpine:3.11 RUN apk add --no-cache darkhttpd COPY --from=builder /src/public /var/www ENTRYPOINT [ <span class="hljs-string"><span class="hljs-string">"/usr/bin/darkhttpd"</span></span> ] CMD [ <span class="hljs-string"><span class="hljs-string">"/var/www"</span></span> ]</code> </pre> <br><p>  Como voc√™ pode ver, o Dockerfile cont√©m dois FROMs, esse recurso √© chamado <a href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="nofollow"><strong>de compila√ß√£o em v√°rios est√°gios</strong></a> e permite excluir tudo o que √© desnecess√°rio da imagem final do Docker. <br>  Assim, a imagem final conter√° apenas <strong>darkhttpd</strong> (um servidor HTTP leve) e <strong>p√∫blico /</strong> - o conte√∫do do nosso site gerado estaticamente. </p><br><p>  N√£o se esque√ßa de confirmar nossas altera√ß√µes: </p><br><pre> <code class="plaintext hljs">git add dockerfiles/website git commit -m "Add Dockerfile for website"</code> </pre> <br><hr><br><h1 id="3-znakomstvo-s-kanikoanchorkanikoanchor">  3. Familiaridade com Kaniko <a name="kaniko"></a></h1><br><p>  Como coletor de imagens do docker, decidi usar o <strong><a href="https://github.com/GoogleContainerTools/kaniko" rel="nofollow">kaniko</a></strong> , pois ele n√£o requer que um daemon do docker funcione, e o pr√≥prio conjunto pode ser executado em qualquer m√°quina e armazenar o cache diretamente no registro, eliminando a necessidade de um armazenamento persistente completo . </p><br><p>  Para criar a imagem, basta iniciar o cont√™iner com o <strong>executor kaniko</strong> e passar o contexto de compila√ß√£o atual para ele, voc√™ pode fazer isso localmente, via docker: </p><br><pre> <code class="bash hljs">docker run -ti --rm \ -v <span class="hljs-variable"><span class="hljs-variable">$PWD</span></span>:/workspace \ -v ~/.docker/config.json:/kaniko/.docker/config.json:ro \ gcr.io/kaniko-project/executor:v0.15.0 \ --cache \ --dockerfile=dockerfiles/website/Dockerfile \ --destination=registry.gitlab.com/kvaps/docs.example.org/website:v0.0.1</code> </pre> <br><p>  Onde <strong>registry.gitlab.com/kvaps/docs.example.org/website</strong> √© o nome da sua imagem do docker, ap√≥s a montagem, ela ser√° automaticamente enviada ao registro do docker. </p><br><p>  O par√¢metro <strong>--cache</strong> permite que voc√™ <strong>armazene</strong> em cache as camadas no registro do docker, para o exemplo fornecido elas ser√£o salvas em <strong>registry.gitlab.com/kvaps/docs.example.org/website/cache</strong> , mas voc√™ pode especificar outro caminho usando o par√¢metro <strong>--cache- repo</strong> . </p><br><div class="spoiler">  <b class="spoiler_title">Captura de tela docker-registry</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/0-/31/qx/0-31qxfta2gk7-colutf2l_qtmm.png"></p></div></div><br><hr><br><h1 id="4-znakomstvo-s-qbecanchorqbecanchor">  4. Familiaridade com o qbec <a name="qbec"></a></h1><br><p>  <a href="https://qbec.io/" rel="nofollow">O Qbec</a> √© uma ferramenta de implanta√ß√£o que permite descrever declarativamente o manifesto do seu aplicativo e implant√°-lo no Kubernetes.  O uso do Jsonnet como sintaxe principal permite simplificar bastante a descri√ß√£o das diferen√ßas para v√°rios ambientes e tamb√©m elimina quase completamente a repetibilidade do c√≥digo. </p><br><p>  Isso pode ser especialmente verdadeiro nos casos em que voc√™ precisa implantar um aplicativo em v√°rios clusters com par√¢metros diferentes e deseja descrev√™-los declarativamente no Git. </p><br><p>  O Qbec tamb√©m permite renderizar gr√°ficos do Helm passando os par√¢metros necess√°rios e, posteriormente, operando-os, bem como manifestos regulares, incluindo v√°rias muta√ß√µes que podem ser aplicadas a eles, e isso, por sua vez, elimina a necessidade de usar o ChartMuseum.  Ou seja, voc√™ pode armazenar e renderizar gr√°ficos diretamente do git, onde eles est√£o. </p><br><p>  Como eu disse antes, armazenaremos todas as implanta√ß√µes no diret√≥rio <strong>deploy /</strong> : </p><br><pre> <code class="bash hljs">mkdir deploy <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> deploy</code> </pre> <br><p>  Vamos inicializar nossa primeira aplica√ß√£o: </p><br><pre> <code class="bash hljs">qbec init website <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> website</code> </pre> <br><p>  Agora a estrutura do nosso aplicativo fica assim: </p><br><pre> <code class="plaintext hljs">. ‚îú‚îÄ‚îÄ components ‚îú‚îÄ‚îÄ environments ‚îÇ  ‚îú‚îÄ‚îÄ base.libsonnet ‚îÇ  ‚îî‚îÄ‚îÄ default.libsonnet ‚îú‚îÄ‚îÄ params.libsonnet ‚îî‚îÄ‚îÄ qbec.yaml</code> </pre> <br><p>  veja o arquivo <strong>qbec.yaml</strong> : </p><br><pre> <code class="plaintext hljs">apiVersion: qbec.io/v1alpha1 kind: App metadata: name: website spec: environments: default: defaultNamespace: docs server: https://kubernetes.example.org:8443 vars: {}</code> </pre> <br><p>  Aqui estamos interessados ‚Äã‚Äãprincipalmente em <strong>spec.environments</strong> , o qbec j√° criou um ambiente padr√£o para n√≥s e pegou o endere√ßo do servidor, bem como o namespace do nosso kubeconfig atual. <br>  Agora, ao implantar no ambiente <strong>padr√£o</strong> , o qbec sempre implantar√° apenas no cluster Kubernetes especificado e no espa√ßo de nomes especificado, ou seja, voc√™ n√£o precisar√° mais alternar entre contextos e espa√ßos de nome para executar uma implanta√ß√£o. <br>  Se necess√°rio, voc√™ sempre pode atualizar as configura√ß√µes neste arquivo. </p><br><p>  Todos os seus ambientes s√£o descritos em <strong>qbec.yaml</strong> e no arquivo <strong>params.libsonnet</strong> , onde diz onde voc√™ precisa obter par√¢metros para eles. </p><br><p>  Em seguida, vemos dois diret√≥rios: </p><br><ul><li>  <strong>componentes /</strong> - todos os manifestos para nossa aplica√ß√£o ser√£o armazenados aqui, eles podem ser descritos em jsonnet e em arquivos yaml comuns </li><li>  <strong>ambientes /</strong> - aqui descreveremos todas as vari√°veis ‚Äã‚Äã(par√¢metros) para nossos ambientes. </li></ul><br><p>  Por padr√£o, temos dois arquivos: </p><br><ul><li>  <strong>ambientes / base.libsonnet</strong> - conter√° par√¢metros gerais para todos os ambientes </li><li>  <strong>environment / default.libsonnet</strong> - cont√©m par√¢metros substitu√≠dos pelo ambiente <strong>padr√£o</strong> </li></ul><br><p>  Vamos abrir <strong>environment / base.libsonnet</strong> e adicionar os par√¢metros para o nosso primeiro componente l√°: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">components</span></span>: { <span class="hljs-attr"><span class="hljs-attr">website</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'example-docs'</span></span>, <span class="hljs-attr"><span class="hljs-attr">image</span></span>: <span class="hljs-string"><span class="hljs-string">'registry.gitlab.com/kvaps/docs.example.org/website:v0.0.1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">replicas</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">containerPort</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-attr"><span class="hljs-attr">servicePort</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-attr"><span class="hljs-attr">nodeSelector</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">tolerations</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">ingressClass</span></span>: <span class="hljs-string"><span class="hljs-string">'nginx'</span></span>, <span class="hljs-attr"><span class="hljs-attr">domain</span></span>: <span class="hljs-string"><span class="hljs-string">'docs.example.org'</span></span>, }, }, }</code> </pre> <br><p>  Tamb√©m criaremos nosso primeiro componente <strong>components / website.jsonnet</strong> : </p><br><pre> <code class="javascript hljs">local env = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: std.extVar(<span class="hljs-string"><span class="hljs-string">'qbec.io/env'</span></span>), <span class="hljs-attr"><span class="hljs-attr">namespace</span></span>: std.extVar(<span class="hljs-string"><span class="hljs-string">'qbec.io/defaultNs'</span></span>), }; local p = <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'../params.libsonnet'</span></span>; local params = p.components.website; [ { <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: <span class="hljs-string"><span class="hljs-string">'apps/v1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'Deployment'</span></span>, <span class="hljs-attr"><span class="hljs-attr">metadata</span></span>: { <span class="hljs-attr"><span class="hljs-attr">labels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name }, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">spec</span></span>: { <span class="hljs-attr"><span class="hljs-attr">replicas</span></span>: params.replicas, <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: { <span class="hljs-attr"><span class="hljs-attr">matchLabels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name, }, }, <span class="hljs-attr"><span class="hljs-attr">template</span></span>: { <span class="hljs-attr"><span class="hljs-attr">metadata</span></span>: { <span class="hljs-attr"><span class="hljs-attr">labels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name }, }, <span class="hljs-attr"><span class="hljs-attr">spec</span></span>: { <span class="hljs-attr"><span class="hljs-attr">containers</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'darkhttpd'</span></span>, <span class="hljs-attr"><span class="hljs-attr">image</span></span>: params.image, <span class="hljs-attr"><span class="hljs-attr">ports</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">containerPort</span></span>: params.containerPort, }, ], }, ], <span class="hljs-attr"><span class="hljs-attr">nodeSelector</span></span>: params.nodeSelector, <span class="hljs-attr"><span class="hljs-attr">tolerations</span></span>: params.tolerations, <span class="hljs-attr"><span class="hljs-attr">imagePullSecrets</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'regsecret'</span></span> }], }, }, }, }, { <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: <span class="hljs-string"><span class="hljs-string">'v1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'Service'</span></span>, <span class="hljs-attr"><span class="hljs-attr">metadata</span></span>: { <span class="hljs-attr"><span class="hljs-attr">labels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name }, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">spec</span></span>: { <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">ports</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">port</span></span>: params.servicePort, <span class="hljs-attr"><span class="hljs-attr">targetPort</span></span>: params.containerPort, }, ], }, }, { <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: <span class="hljs-string"><span class="hljs-string">'extensions/v1beta1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'Ingress'</span></span>, <span class="hljs-attr"><span class="hljs-attr">metadata</span></span>: { <span class="hljs-attr"><span class="hljs-attr">annotations</span></span>: { <span class="hljs-string"><span class="hljs-string">'kubernetes.io/ingress.class'</span></span>: params.ingressClass, }, <span class="hljs-attr"><span class="hljs-attr">labels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name }, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">spec</span></span>: { <span class="hljs-attr"><span class="hljs-attr">rules</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">host</span></span>: params.domain, <span class="hljs-attr"><span class="hljs-attr">http</span></span>: { <span class="hljs-attr"><span class="hljs-attr">paths</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">backend</span></span>: { <span class="hljs-attr"><span class="hljs-attr">serviceName</span></span>: params.name, <span class="hljs-attr"><span class="hljs-attr">servicePort</span></span>: params.servicePort, }, }, ], }, }, ], }, }, ]</code> </pre> <br><p>  Neste arquivo, descrevemos imediatamente tr√™s entidades do Kubernetes, s√£o elas: <strong>Implanta√ß√£o</strong> , <strong>Servi√ßo</strong> e <strong>Ingress</strong> .  Se desejado, poder√≠amos carreg√°-los em componentes diferentes, mas, neste est√°gio, um √© suficiente para n√≥s. </p><br><p>  A sintaxe do <strong>jsonnet √©</strong> muito semelhante ao json regular, em princ√≠pio o json regular j√° √© v√°lido jsonnet, portanto, a princ√≠pio, pode ser mais f√°cil usar servi√ßos online como o <strong>yaml2json</strong> para converter o yaml normal em json ou, se seus componentes n√£o contiverem vari√°veis, ent√£o eles podem ser descritos na forma de yaml comum. </p><br><blockquote>  Ao trabalhar com o <strong>jsonnet, eu</strong> recomendo instalar um plugin para o seu editor <br><br>  Por exemplo, para o vim, existe um <strong>plug-in vim-jsonnet</strong> que ativa o destaque de sintaxe e executa automaticamente o <strong>jsonnet fmt</strong> cada vez que √© salvo (ele requer a instala√ß√£o do jsonnet). </blockquote><p>  Tudo est√° pronto, agora podemos iniciar a implanta√ß√£o: </p><br><p>  Para ver o que aconteceu, faremos: </p><br><pre> <code class="bash hljs">qbec show default</code> </pre> <br><p>  Na sa√≠da, voc√™ ver√° manifestos yaml renderizados que ser√£o aplicados ao cluster padr√£o. </p><br><p>  Ok, agora aplique: </p><br><pre> <code class="bash hljs">qbec apply default</code> </pre> <br><p>  Na sa√≠da, voc√™ sempre ver√° o que ser√° feito no seu cluster, o qbec solicitar√° que voc√™ aceite as altera√ß√µes, digitando <strong>y,</strong> voc√™ poder√° confirmar suas inten√ß√µes. </p><br><p>  Feito, agora nosso aplicativo est√° ancorado! </p><br><p>  Se voc√™ fizer altera√ß√µes, sempre poder√°: </p><br><pre> <code class="bash hljs">qbec diff default</code> </pre> <br><p>  para ver como essas altera√ß√µes afetar√£o a implanta√ß√£o atual </p><br><p>  N√£o se esque√ßa de confirmar nossas altera√ß√µes: </p><br><pre> <code class="plaintext hljs">cd ../.. git add deploy/website git commit -m "Add deploy for website"</code> </pre> <br><hr><br><h1 id="5-probuem-gitlab-runner-s-kubernetes-executoranchorgitlab-runneranchor">  5. Tentando o Gitlab-runner com o Kubernetes-executor <a name="gitlab-runner"></a></h1><br><p>  At√© recentemente, eu usava apenas o habitual <strong>gitlab-runner</strong> em uma m√°quina pr√©-preparada (cont√™iner LXC) com um shell ou docker-executor.  Inicialmente, t√≠nhamos v√°rios desses corredores definidos globalmente em nosso hitlab.  Eles coletaram imagens do docker para todos os projetos. </p><br><p>  Mas, como a pr√°tica demonstrou, essa op√ß√£o n√£o √© a mais ideal, tanto em termos de praticidade quanto em termos de seguran√ßa.  √â muito melhor e ideologicamente mais correto ter corredores separados implantados para cada projeto e at√© para cada ambiente. </p><br><p>  Felizmente, isso n√£o √© um problema, pois agora vamos implantar o <strong>gitlab-runner</strong> diretamente como parte do nosso projeto diretamente no Kubernetes. </p><br><p>  O Gitlab fornece um gr√°fico de leme pronto para implantar o gitlab-runner no Kubernetes.  Portanto, tudo o que voc√™ precisa fazer √© descobrir o <strong>token de registro</strong> do nosso projeto em <strong>Configura√ß√µes -&gt; CI / CD -&gt; Corredores</strong> e passar o comando: </p><br><pre> <code class="bash hljs">helm repo add gitlab https://charts.gitlab.io helm install gitlab-runner \ --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> gitlabUrl=https://gitlab.com \ --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> runnerRegistrationToken=yga8y-jdCusVDn_t4Wxc \ --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> rbac.create=<span class="hljs-literal"><span class="hljs-literal">true</span></span> \ gitlab/gitlab-runner</code> </pre> <br><p>  Onde: </p><br><ul><li>  <strong><a href="https://gitlab.com/" rel="nofollow">https://gitlab.com</a></strong> √© o endere√ßo do seu servidor Gitlab. </li><li>  <strong>yga8y-jdCusVDn_t4Wxc</strong> - token de registro para seu projeto. </li><li>  <strong>rbac.create = true</strong> - <strong>concede</strong> ao corredor o n√∫mero necess√°rio de privil√©gios para poder criar pods para executar nossas tarefas usando o kubernetes-executor. </li></ul><br><p>  Se tudo for feito corretamente, voc√™ dever√° ver o corredor registrado na se√ß√£o <strong>Corredores</strong> , nas configura√ß√µes do seu projeto. </p><br><div class="spoiler">  <b class="spoiler_title">Captura de tela do corredor adicionado</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/at/lx/g_/atlxg_u6rjn4n0pkcpn8--2gare.png"></p></div></div><br><p>  Isso √© simples?  - sim, t√£o simples!  N√£o h√° mais problemas com o registro manual de corredores, a partir de agora os corredores ser√£o criados e destru√≠dos automaticamente. </p><br><hr><br><h1 id="6-deploy-helm-chartov-s-qbecanchorqbec-helmanchor">  6. Implanta√ß√£o de gr√°ficos Helm com QBEC <a name="qbec-helm"></a></h1><br><p>  Como decidimos considerar o <strong>gitlab-runner</strong> parte do nosso projeto, √© hora de descrev√™-lo em nosso reposit√≥rio Git. </p><br><p>  Poder√≠amos descrev√™-lo como um componente separado do <strong>site</strong> , mas no futuro planejamos implantar c√≥pias diferentes do <strong>site com</strong> muita frequ√™ncia, diferentemente do <strong>gitlab-runner</strong> , que ser√° implantado apenas uma vez para cada cluster do Kubernetes.  Ent√£o, vamos inicializar um aplicativo separado para ele: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> deploy qbec init gitlab-runner <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> gitlab-runner</code> </pre> <br><p>  Desta vez, n√£o descreveremos as entidades do Kubernetes manualmente, mas faremos um gr√°fico Helm pronto.  Uma das vantagens do qbec √© a capacidade de renderizar gr√°ficos Helm diretamente do reposit√≥rio Git. </p><br><p>  Vamos conect√°-lo usando o subm√≥dulo git: </p><br><pre> <code class="bash hljs">git submodule add https://gitlab.com/gitlab-org/charts/gitlab-runner vendor/gitlab-runner</code> </pre> <br><p>  Agora, o diret√≥rio <strong>vendor / gitlab-runner</strong> cont√©m nosso reposit√≥rio com um gr√°fico para o gitlab-runner. </p><br><blockquote>  Da mesma forma, voc√™ pode conectar outros reposit√≥rios, por exemplo, todo o reposit√≥rio aos gr√°ficos oficiais <strong><a href="https://github.com/helm/charts" rel="nofollow">https://github.com/helm/charts</a></strong> </blockquote><p>  Vamos descrever o <strong>componente components / gitlab-runner.jsonnet</strong> : </p><br><pre> <code class="javascript hljs">local env = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: std.extVar(<span class="hljs-string"><span class="hljs-string">'qbec.io/env'</span></span>), <span class="hljs-attr"><span class="hljs-attr">namespace</span></span>: std.extVar(<span class="hljs-string"><span class="hljs-string">'qbec.io/defaultNs'</span></span>), }; local p = <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'../params.libsonnet'</span></span>; local params = p.components.gitlabRunner; std.native(<span class="hljs-string"><span class="hljs-string">'expandHelmTemplate'</span></span>)( <span class="hljs-string"><span class="hljs-string">'../vendor/gitlab-runner'</span></span>, params.values, { <span class="hljs-attr"><span class="hljs-attr">nameTemplate</span></span>: params.name, <span class="hljs-attr"><span class="hljs-attr">namespace</span></span>: env.namespace, <span class="hljs-attr"><span class="hljs-attr">thisFile</span></span>: std.thisFile, <span class="hljs-attr"><span class="hljs-attr">verbose</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, } )</code> </pre> <br><p>  O primeiro argumento para <strong>expandHelmTemplate</strong> passa o caminho para o gr√°fico, depois <strong>params.values</strong> , que <strong>extra√≠mos</strong> dos par√¢metros do ambiente e, em seguida, um objeto com </p><br><ul><li>  <strong>nameTemplate</strong> - nome da vers√£o </li><li>  <strong>namespace</strong> - namespace passado ao leme </li><li>  <strong>thisFile</strong> - par√¢metro necess√°rio passando o caminho para o arquivo atual </li><li>  <strong>detalhado</strong> - mostra o <strong>comando do modelo de leme</strong> com todos os argumentos ao renderizar o gr√°fico </li></ul><br><p>  Agora descreveremos os par√¢metros para nosso componente em <strong>environment / base.libsonnet</strong> : </p><br><pre> <code class="javascript hljs">local secrets = <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'../secrets/base.libsonnet'</span></span>; { <span class="hljs-attr"><span class="hljs-attr">components</span></span>: { <span class="hljs-attr"><span class="hljs-attr">gitlabRunner</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'gitlab-runner'</span></span>, <span class="hljs-attr"><span class="hljs-attr">values</span></span>: { <span class="hljs-attr"><span class="hljs-attr">gitlabUrl</span></span>: <span class="hljs-string"><span class="hljs-string">'https://gitlab.com/'</span></span>, <span class="hljs-attr"><span class="hljs-attr">rbac</span></span>: { <span class="hljs-attr"><span class="hljs-attr">create</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">runnerRegistrationToken</span></span>: secrets.runnerRegistrationToken, }, }, }, }</code> </pre> <br><p>  Preste aten√ß√£o ao <strong>runnerRegistrationToken</strong> que <strong>extra√≠mos do arquivo</strong> externo <strong>secrets / base.libsonnet</strong> , vamos cri√°-lo: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">runnerRegistrationToken</span></span>: <span class="hljs-string"><span class="hljs-string">'yga8y-jdCusVDn_t4Wxc'</span></span>, }</code> </pre> <br><p>  Verifique se tudo funciona: </p><br><pre> <code class="bash hljs">qbec show default</code> </pre> <br><p>  se tudo estiver em ordem, podemos remover nossa vers√£o anterior atrav√©s da vers√£o Helm: </p><br><pre> <code class="bash hljs">helm uninstall gitlab-runner</code> </pre> <br><p>  e implant√°-lo, mas j√° atrav√©s do qbec: </p><br><pre> <code class="bash hljs">qbec apply default</code> </pre> <br><hr><br><h1 id="7-znakomstvo-s-git-cryptanchorgit-cryptanchor">  7. Apresentando o git-crypt <a name="git-crypt"></a></h1><br><p>  <strong><a href="https://github.com/AGWA/git-crypt" rel="nofollow">Git-crypt</a></strong> √© uma ferramenta que permite configurar criptografia transparente para o seu reposit√≥rio. </p><br><p>  No momento, a estrutura do nosso diret√≥rio para o gitlab-runner est√° assim: </p><br><pre> <code class="plaintext hljs">. ‚îú‚îÄ‚îÄ components ‚îÇ  ‚îú‚îÄ‚îÄ gitlab-runner.jsonnet ‚îú‚îÄ‚îÄ environments ‚îÇ  ‚îú‚îÄ‚îÄ base.libsonnet ‚îÇ  ‚îî‚îÄ‚îÄ default.libsonnet ‚îú‚îÄ‚îÄ params.libsonnet ‚îú‚îÄ‚îÄ qbec.yaml ‚îú‚îÄ‚îÄ secrets ‚îÇ  ‚îî‚îÄ‚îÄ base.libsonnet ‚îî‚îÄ‚îÄ vendor ‚îî‚îÄ‚îÄ gitlab-runner (submodule)</code> </pre> <br><p>  Mas guardar segredos no Git n√£o √© seguro, √©?  Ent√£o, precisamos criptograf√°-los adequadamente. </p><br><blockquote>  Geralmente, por uma √∫nica vari√°vel, isso nem sempre faz sentido.  Voc√™ pode passar segredos para o <strong>qbec</strong> e pelas vari√°veis ‚Äã‚Äãde ambiente do seu sistema de IC. <br>  Mas √© importante notar que existem projetos mais complexos que podem conter muito mais segredos; ser√° extremamente dif√≠cil transferi-los por meio de vari√°veis ‚Äã‚Äãde ambiente. <br><br>  Al√©m disso, neste caso, eu n√£o seria capaz de falar sobre uma ferramenta t√£o maravilhosa como o <strong>git-crypt</strong> . <br><br>  <strong>O git-crypt</strong> tamb√©m <strong>√©</strong> conveniente porque permite salvar todo o hist√≥rico de segredos, al√©m de comparar, mesclar e resolver conflitos da mesma maneira que costum√°vamos fazer no caso do Git. </blockquote><p>  Primeiro de tudo, depois de instalar o <strong>git-crypt,</strong> precisamos gerar chaves para o nosso reposit√≥rio: </p><br><pre> <code class="plaintext hljs">git crypt init</code> </pre> <br><p>  Se voc√™ possui uma chave PGP, pode se adicionar imediatamente como colaborador deste projeto: </p><br><pre> <code class="plaintext hljs">git-crypt add-gpg-user kvapss@gmail.com</code> </pre> <br><p>  Assim, voc√™ sempre pode descriptografar este reposit√≥rio usando sua chave privada. </p><br><p>  Se voc√™ n√£o possui uma chave PGP e n√£o √© o esperado, pode seguir o outro caminho e exportar a chave do projeto: </p><br><pre> <code class="plaintext hljs">git crypt export-key /path/to/keyfile</code> </pre> <br><p>  Dessa forma, qualquer pessoa com um <strong>arquivo-chave</strong> exportado poder√° descriptografar seu reposit√≥rio. </p><br><p>  √â hora de estabelecer nosso primeiro segredo. <br>  Deixe-me lembr√°-lo de que ainda estamos no diret√≥rio <strong>deploy / gitlab-runner /</strong> , onde temos o diret√≥rio <strong>secrets /</strong> , vamos criptografar todos os arquivos nele, para isso criamos o <strong>arquivo secrets / .gitattributes</strong> com o seguinte conte√∫do: </p><br><pre> <code class="plaintext hljs">* filter=git-crypt diff=git-crypt .gitattributes !filter !diff</code> </pre> <br><p>  Como voc√™ pode ver no conte√∫do, todos os arquivos por mask <strong>*</strong> ser√£o executados no <strong>git-crypt</strong> , exceto o pr√≥prio <strong>.gitattributes</strong> </p><br><p>  Podemos verificar isso executando: </p><br><pre> <code class="bash hljs">git crypt status -e</code> </pre> <br><p>  Na sa√≠da, obtemos uma lista de todos os arquivos no reposit√≥rio para os quais a criptografia est√° ativada </p><br><p>  Isso √© tudo, agora podemos confirmar com seguran√ßa nossas altera√ß√µes: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ../.. git add . git commit -m <span class="hljs-string"><span class="hljs-string">"Add deploy for gitlab-runner"</span></span></code> </pre> <br><p>  Para bloquear o reposit√≥rio, basta: </p><br><pre> <code class="bash hljs">git crypt lock</code> </pre> <br><p>  e ent√£o todos os arquivos criptografados se transformam em algo bin√°rio, ser√° imposs√≠vel l√™-los. <br>  Para descriptografar um reposit√≥rio, fa√ßa: </p><br><pre> <code class="bash hljs">git crypt unlock</code> </pre> <br><hr><br><h1 id="8-sozdayom-toolbox-obrazanchortoolboxanchor">  8. Crie uma imagem da caixa de ferramentas <a name="toolbox"></a></h1><br><p>  Uma imagem da caixa de ferramentas √© uma imagem com todas as ferramentas que usaremos para implantar nosso projeto.  Ele ser√° usado pelo corredor gitlab para executar tarefas t√≠picas de implanta√ß√£o. </p><br><p>  Tudo √© simples aqui, criamos um novo <strong>dockerfiles / toolbox / Dockerfile</strong> com o seguinte conte√∫do: </p><br><pre> <code class="bash hljs">FROM alpine:3.11 RUN apk add --no-cache git git-crypt RUN QBEC_VER=0.10.3 \ &amp;&amp; wget -O- https://github.com/splunk/qbec/releases/download/v<span class="hljs-variable"><span class="hljs-variable">${QBEC_VER}</span></span>/qbec-linux-amd64.tar.gz \ | tar -C /tmp -xzf - \ &amp;&amp; mv /tmp/qbec /tmp/jsonnet-qbec /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/ RUN KUBECTL_VER=1.17.0 \ &amp;&amp; wget -O /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/kubectl \ https://storage.googleapis.com/kubernetes-release/release/v<span class="hljs-variable"><span class="hljs-variable">${KUBECTL_VER}</span></span>/bin/linux/amd64/kubectl \ &amp;&amp; chmod +x /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/kubectl RUN HELM_VER=3.0.2 \ &amp;&amp; wget -O- https://get.helm.sh/helm-v<span class="hljs-variable"><span class="hljs-variable">${HELM_VER}</span></span>-linux-amd64.tar.gz \ | tar -C /tmp -zxf - \ &amp;&amp; mv /tmp/linux-amd64/helm /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/helm</code> </pre> <br><p>  Como voc√™ pode ver, nesta imagem instalamos todos os utilit√°rios que usamos para implantar nosso aplicativo.  N√£o precisamos do <strong>kubectl aqui</strong> , mas conv√©m brincar com ele no est√°gio de configura√ß√£o do pipeline. </p><br><p>  Al√©m disso, para poder se comunicar com o Kubernetes e executar uma implanta√ß√£o nele, precisamos configurar a fun√ß√£o dos pods gerados pelo gitlab-runner. </p><br><p>  Para fazer isso, acesse o diret√≥rio com gitlab-runner: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> deploy/gitlab-runner</code> </pre> <br><p>  e adicione um novo componente <strong>components / rbac.jsonnet</strong> : </p><br><pre> <code class="javascript hljs">local env = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: std.extVar(<span class="hljs-string"><span class="hljs-string">'qbec.io/env'</span></span>), <span class="hljs-attr"><span class="hljs-attr">namespace</span></span>: std.extVar(<span class="hljs-string"><span class="hljs-string">'qbec.io/defaultNs'</span></span>), }; local p = <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'../params.libsonnet'</span></span>; local params = p.components.rbac; [ { <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: <span class="hljs-string"><span class="hljs-string">'v1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'ServiceAccount'</span></span>, <span class="hljs-attr"><span class="hljs-attr">metadata</span></span>: { <span class="hljs-attr"><span class="hljs-attr">labels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, }, }, { <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: <span class="hljs-string"><span class="hljs-string">'rbac.authorization.k8s.io/v1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'Role'</span></span>, <span class="hljs-attr"><span class="hljs-attr">metadata</span></span>: { <span class="hljs-attr"><span class="hljs-attr">labels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">rules</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">apiGroups</span></span>: [ <span class="hljs-string"><span class="hljs-string">'*'</span></span>, ], <span class="hljs-attr"><span class="hljs-attr">resources</span></span>: [ <span class="hljs-string"><span class="hljs-string">'*'</span></span>, ], <span class="hljs-attr"><span class="hljs-attr">verbs</span></span>: [ <span class="hljs-string"><span class="hljs-string">'*'</span></span>, ], }, ], }, { <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: <span class="hljs-string"><span class="hljs-string">'rbac.authorization.k8s.io/v1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'RoleBinding'</span></span>, <span class="hljs-attr"><span class="hljs-attr">metadata</span></span>: { <span class="hljs-attr"><span class="hljs-attr">labels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">roleRef</span></span>: { <span class="hljs-attr"><span class="hljs-attr">apiGroup</span></span>: <span class="hljs-string"><span class="hljs-string">'rbac.authorization.k8s.io'</span></span>, <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'Role'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">subjects</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'ServiceAccount'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, <span class="hljs-attr"><span class="hljs-attr">namespace</span></span>: env.namespace, }, ], }, ]</code> </pre> <br><p>  Tamb√©m descreveremos os novos par√¢metros em <strong>environment / base.libsonnet</strong> , que agora se parece com isso: </p><br><pre> <code class="javascript hljs">local secrets = <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'../secrets/base.libsonnet'</span></span>; { <span class="hljs-attr"><span class="hljs-attr">components</span></span>: { <span class="hljs-attr"><span class="hljs-attr">gitlabRunner</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'gitlab-runner'</span></span>, <span class="hljs-attr"><span class="hljs-attr">values</span></span>: { <span class="hljs-attr"><span class="hljs-attr">gitlabUrl</span></span>: <span class="hljs-string"><span class="hljs-string">'https://gitlab.com/'</span></span>, <span class="hljs-attr"><span class="hljs-attr">rbac</span></span>: { <span class="hljs-attr"><span class="hljs-attr">create</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">runnerRegistrationToken</span></span>: secrets.runnerRegistrationToken, <span class="hljs-attr"><span class="hljs-attr">runners</span></span>: { <span class="hljs-attr"><span class="hljs-attr">serviceAccountName</span></span>: $.components.rbac.name, <span class="hljs-attr"><span class="hljs-attr">image</span></span>: <span class="hljs-string"><span class="hljs-string">'registry.gitlab.com/kvaps/docs.example.org/toolbox:v0.0.1'</span></span>, }, }, }, <span class="hljs-attr"><span class="hljs-attr">rbac</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'gitlab-runner-deploy'</span></span>, }, }, }</code> </pre> <br><p>  Nota <strong>$ .components.rbac.name</strong> refere-se ao <strong>nome</strong> do componente <strong>rbac</strong> </p><br><p>  Vamos verificar o que mudou: </p><br><pre> <code class="bash hljs">qbec diff default</code> </pre> <br><p>  e aplique nossas altera√ß√µes ao Kubernetes: </p><br><pre> <code class="bash hljs">qbec apply default</code> </pre> <br><p>  Tamb√©m n√£o se esque√ßa de confirmar nossas altera√ß√µes no git: </p><br><pre> <code class="plaintext hljs">cd ../.. git add dockerfiles/toolbox git commit -m "Add Dockerfile for toolbox" git add deploy/gitlab-runner git commit -m "Configure gitlab-runner to use toolbox"</code> </pre> <br><hr><br><h1 id="9-nash-pervyy-payplayn-i-sborka-obrazov-po-tegamanchorpipeline-buildanchor">  9. Nosso primeiro pipeline e montagem de imagens por tags <a name="pipeline-build"></a></h1><br><p>  Na raiz do projeto, criaremos <strong>.gitlab-ci.yml</strong> com o seguinte conte√∫do: </p><br><pre> <code class="plaintext hljs">.build_docker_image: stage: build image: name: gcr.io/kaniko-project/executor:debug-v0.15.0 entrypoint: [""] before_script: - echo "{\"auths\":{\"$CI_REGISTRY\":{\"username\":\"$CI_REGISTRY_USER\",\"password\":\"$CI_REGISTRY_PASSWORD\"}}}" &gt; /kaniko/.docker/config.json build_toolbox: extends: .build_docker_image script: - /kaniko/executor --cache --context $CI_PROJECT_DIR/dockerfiles/toolbox --dockerfile $CI_PROJECT_DIR/dockerfiles/toolbox/Dockerfile --destination $CI_REGISTRY_IMAGE/toolbox:$CI_COMMIT_TAG only: refs: - tags build_website: extends: .build_docker_image variables: GIT_SUBMODULE_STRATEGY: normal script: - /kaniko/executor --cache --context $CI_PROJECT_DIR --dockerfile $CI_PROJECT_DIR/dockerfiles/website/Dockerfile --destination $CI_REGISTRY_IMAGE/website:$CI_COMMIT_TAG only: refs: - tags</code> </pre> <br><p>  Observe que usamos <strong>GIT_SUBMODULE_STRATEGY: normal</strong> para os trabalhos em que voc√™ precisa inicializar explicitamente os subm√≥dulos antes da execu√ß√£o. </p><br><p>  N√£o se esque√ßa de confirmar nossas altera√ß√µes: </p><br><pre> <code class="plaintext hljs">git add .gitlab-ci.yml git commit -m "Automate docker build"</code> </pre> <br><p>  Eu acho que voc√™ pode cham√°-lo com seguran√ßa de vers√£o <strong>v0.0.1</strong> e pendurar uma tag: </p><br><pre> <code class="bash hljs">git tag v0.0.1</code> </pre> <br><p>  Penduraremos as tags sempre que precisarmos lan√ßar uma nova vers√£o.  As tags nas imagens do Docker ser√£o vinculadas √†s tags Git.  Cada push com uma nova tag inicializar√° a montagem de imagens com essa tag. </p><br><p>  Execute <strong>git push --tags</strong> e veja nosso primeiro pipeline: </p><br><div class="spoiler">  <b class="spoiler_title">Captura de tela do primeiro pipeline</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/5u/ce/fg/5ucefgejcfjz7jpwvou206mwufy.png"></p></div></div><br><blockquote>  Vale a pena prestar aten√ß√£o ao fato de que a montagem por tags √© adequada para montar imagens do docker, mas n√£o para implantar um aplicativo no Kubernetes.  Como novas tags tamb√©m podem ser atribu√≠das a confirma√ß√µes antigas, nesse caso, a inicializa√ß√£o do pipeline para elas levar√° √† implanta√ß√£o da vers√£o antiga. <br><br>  Para resolver esse problema, geralmente o conjunto de imagens do Docker √© anexado √†s tags e a implanta√ß√£o do aplicativo na ramifica√ß√£o <strong>principal</strong> , na qual as vers√µes das imagens coletadas s√£o codificadas.  √â nesse caso que voc√™ pode inicializar a revers√£o com uma simples marca <strong>mestre de</strong> revers√£o. </blockquote><br><hr><br><h1 id="10-avtomatizaciya-deployaanchorpipeline-deployanchor">  10. Automa√ß√£o de implanta√ß√£o <a name="pipeline-deploy"></a></h1><br><p>  Para que o Gitlab-runner decifre nossos segredos, precisamos exportar a chave do reposit√≥rio e adicion√°-la √†s vari√°veis ‚Äã‚Äãde ambiente do nosso IC: </p><br><pre> <code class="plaintext hljs">git crypt export-key /tmp/docs-repo.key base64 -w0 /tmp/docs-repo.key; echo</code> </pre> <br><p>  salve a string resultante no Gitlab, para isso iremos para as configura√ß√µes do nosso projeto: <br>  <strong>Configura√ß√µes -&gt; CI / CD -&gt; Vari√°veis</strong> </p><br><p>    : </p><br><div class="scrollable-table"><table><thead><tr><th>  Tipo </th><th> Key </th><th> Value </th><th> Protected </th><th> Masked </th><th> Scope </th></tr></thead><tbody><tr><td> <code>File</code> </td> <td> <code>GITCRYPT_KEY</code> </td> <td> <code>&lt;your string&gt;</code> </td> <td> <code>true</code> <em>(     <code>false</code> )</em> </td><td> <code>true</code> </td> <td> <code>All environments</code> </td> </tr></tbody></table></div><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/vj/li/ea/vjliealfwwsmiy4-nvjfvcf89ig.png"></p></div></div><br><p>    <strong>.gitlab-ci.yml</strong>   : </p><br><pre> <code class="plaintext hljs">.deploy_qbec_app: stage: deploy only: refs: - master deploy_gitlab_runner: extends: .deploy_qbec_app variables: GIT_SUBMODULE_STRATEGY: normal before_script: - base64 -d "$GITCRYPT_KEY" | git-crypt unlock - script: - qbec apply default --root deploy/gitlab-runner --force:k8s-context __incluster__ --wait --yes deploy_website: extends: .deploy_qbec_app script: - qbec apply default --root deploy/website --force:k8s-context __incluster__ --wait --yes</code> </pre> <br><p>        qbec: </p><br><ul><li> <strong>--root some/app</strong> ‚Äî      </li><li> <strong>--force:k8s-context __incluster__</strong> ‚Äî   ,             gtilab-runner.   ,      qbec     Kubernetes-   kubeconfig </li><li> <strong>--wait</strong> ‚Äî  qbec ,        Ready       exit-code. </li><li> <strong>--yes</strong> ‚Äî     <strong>Are you sure?</strong>  . </li></ul><br><p>     : </p><br><pre> <code class="plaintext hljs">git add .gitlab-ci.yml git commit -m "Automate deploy"</code> </pre> <br><p>   <strong>git push</strong>       : </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/0p/aj/vs/0pajvs-a-lrxvfuw8zylnj6lleg.png"></p></div></div><br><hr><br><h1 id="11-artefakty-i-sborka-pri-push-v-masteranchorartifactsanchor"> 11.     push  master <a name="artifacts"></a></h1><br><p>            ,             .           digest  master-. </p><br><p>  :    <strong>website</strong>      push  <strong>master</strong> ,       Kubernetes. </p><br><p>        <strong>.gitlab-ci.yml</strong> : </p><br><pre> <code class="plaintext hljs">build_website: extends: .build_docker_image variables: GIT_SUBMODULE_STRATEGY: normal script: - mkdir -p $CI_PROJECT_DIR/artifacts - /kaniko/executor --cache --context $CI_PROJECT_DIR --dockerfile $CI_PROJECT_DIR/dockerfiles/website/Dockerfile --destination $CI_REGISTRY_IMAGE/website:$CI_COMMIT_REF_NAME --digest-file $CI_PROJECT_DIR/artifacts/website.digest artifacts: paths: - artifacts/ only: refs: - master - tags deploy_website: extends: .deploy_qbec_app script: - DIGEST="$(cat artifacts/website.digest)" - qbec apply default --root deploy/website --force:k8s-context __incluster__ --wait --yes --vm:ext-str digest="$DIGEST"</code> </pre> <br><p>  ,    <strong>master</strong>  <strong>refs</strong>   <strong>build_website</strong>     <strong>$CI_COMMIT_REF_NAME</strong>  <strong>$CI_COMMIT_TAG</strong> ,        Git           .  ,        ,           docker-registry. </p><br><p>   docker-       ,        Kubernetes,           ,         . </p><br><p>  <strong>--vm:ext-str digest="$DIGEST"</strong>  qbec ‚Äî      jsonnet.            .   ,     ,     ,               . </p><br><p>     Kaniko  digest    ( <strong>--digest-file</strong> ) <br>          . </p><br><p>     <strong>deploy/website/environments/base.libsonnet</strong>     : </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">components</span></span>: { <span class="hljs-attr"><span class="hljs-attr">website</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'example-docs'</span></span>, <span class="hljs-attr"><span class="hljs-attr">image</span></span>: <span class="hljs-string"><span class="hljs-string">'registry.gitlab.com/kvaps/docs.example.org/website@'</span></span> + std.extVar(<span class="hljs-string"><span class="hljs-string">'digest'</span></span>), <span class="hljs-attr"><span class="hljs-attr">replicas</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">containerPort</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-attr"><span class="hljs-attr">servicePort</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-attr"><span class="hljs-attr">nodeSelector</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">tolerations</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">ingressClass</span></span>: <span class="hljs-string"><span class="hljs-string">'nginx'</span></span>, <span class="hljs-attr"><span class="hljs-attr">domain</span></span>: <span class="hljs-string"><span class="hljs-string">'docs.example.org'</span></span>, }, }, }</code> </pre> <br><p> ,     <strong>master</strong>   docker-  <strong>website</strong> ,      Kubernetes. </p><br><p>     : </p><br><pre> <code class="bash hljs">git add . git commit -m <span class="hljs-string"><span class="hljs-string">"Configure dynamic build"</span></span></code> </pre> <br><p> ,  <strong>git push</strong>    - : </p><br><div class="spoiler"> <b class="spoiler_title">   master</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/7_/ry/nh/7_rynh5lgu_8hqnnl_gasx73zwq.png"></p></div></div><br><p>       gitlab-runner   push, , ,      ,     <strong>.gitlab-ci.yml</strong> : </p><br><pre> <code class="plaintext hljs">deploy_gitlab_runner: extends: .deploy_qbec_app variables: GIT_SUBMODULE_STRATEGY: normal before_script: - base64 -d "$GITCRYPT_KEY" | git-crypt unlock - script: - qbec apply default --root deploy/gitlab-runner --force:k8s-context __incluster__ --wait --yes only: changes: - deploy/gitlab-runner/**/*</code> </pre> <br><p> <strong>changes</strong>      <strong>deploy/gitlab-runner/</strong>          </p><br><p>     : </p><br><pre> <code class="bash hljs">git add .gitlab-ci.yml git commit -m <span class="hljs-string"><span class="hljs-string">"Reduce gitlab-runner deploy"</span></span></code> </pre> <br><p> <strong>git push</strong> , - : </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/-t/9b/3m/-t9b3mtofbunu7xfogpmb0pacsm.png"></p></div></div><br><hr><br><h1 id="12-dynamic-environmentsanchordynamic-environmentsanchor"> 12. Dynamic environments <a name="dynamic-environments"></a></h1><br><p>       . </p><br><p>     <strong>build_website</strong>   <strong>.gitlab-ci.yml</strong> ,     <strong>only</strong> ,   Gitlab        : </p><br><pre> <code class="plaintext hljs">build_website: extends: .build_docker_image variables: GIT_SUBMODULE_STRATEGY: normal script: - mkdir -p $CI_PROJECT_DIR/artifacts - /kaniko/executor --cache --context $CI_PROJECT_DIR --dockerfile $CI_PROJECT_DIR/dockerfiles/website/Dockerfile --destination $CI_REGISTRY_IMAGE/website:$CI_COMMIT_REF_NAME --digest-file $CI_PROJECT_DIR/artifacts/website.digest artifacts: paths: - artifacts/</code> </pre> <br><p>    <strong>deploy_website</strong> ,    <strong>environment</strong> : </p><br><pre> <code class="plaintext hljs">deploy_website: extends: .deploy_qbec_app environment: name: prod url: https://docs.example.org script: - DIGEST="$(cat artifacts/website.digest)" - qbec apply default --root deploy/website --force:k8s-context __incluster__ --wait --yes --vm:ext-str digest="$DIGEST"</code> </pre> <br><p>   Gitlab    <strong>prod</strong>       . </p><br><p>     : </p><br><pre> <code class="plaintext hljs">deploy_website: extends: .deploy_qbec_app environment: name: prod url: https://docs.example.org script: - DIGEST="$(cat artifacts/website.digest)" - qbec apply default --root deploy/website --force:k8s-context __incluster__ --wait --yes --vm:ext-str digest="$DIGEST" deploy_review: extends: .deploy_qbec_app environment: name: review/$CI_COMMIT_REF_NAME url: http://$CI_ENVIRONMENT_SLUG.docs.example.org on_stop: stop_review script: - DIGEST="$(cat artifacts/website.digest)" - qbec apply review --root deploy/website --force:k8s-context __incluster__ --wait --yes --vm:ext-str digest="$DIGEST" --vm:ext-str subdomain="$CI_ENVIRONMENT_SLUG" --app-tag "$CI_ENVIRONMENT_SLUG" only: refs: - branches except: refs: - master stop_review: extends: .deploy_qbec_app environment: name: review/$CI_COMMIT_REF_NAME action: stop stage: deploy before_script: - git clone "$CI_REPOSITORY_URL" master - cd master script: - qbec delete review --root deploy/website --force:k8s-context __incluster__ --yes --vm:ext-str digest="$DIGEST" --vm:ext-str subdomain="$CI_ENVIRONMENT_SLUG" --app-tag "$CI_ENVIRONMENT_SLUG" variables: GIT_STRATEGY: none only: refs: - branches except: refs: - master when: manual</code> </pre> <br><p>     push     master    preview  . </p><br><p>      qbec: <strong>--app-tag</strong> ‚Äî             ,       Kubernetes qbec    . <br>           review,       . </p><br><p>      <strong>qbec apply review</strong> ,  <strong>qbec apply default</strong> ‚Äî               (review  default): </p><br><p>  <strong>review</strong>   <strong>deploy/website/qbec.yaml</strong> </p><br><pre> <code class="plaintext hljs">spec: environments: review: defaultNamespace: docs server: https://kubernetes.example.org:8443</code> </pre> <br><p>     <strong>deploy/website/params.libsonnet</strong> : </p><br><pre> <code class="javascript hljs">local env = std.extVar(<span class="hljs-string"><span class="hljs-string">'qbec.io/env'</span></span>); local paramsMap = { <span class="hljs-attr"><span class="hljs-attr">_</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./environments/base.libsonnet'</span></span>, <span class="hljs-attr"><span class="hljs-attr">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./environments/default.libsonnet'</span></span>, <span class="hljs-attr"><span class="hljs-attr">review</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./environments/review.libsonnet'</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> std.objectHas(paramsMap, env) then paramsMap[env] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> error <span class="hljs-string"><span class="hljs-string">'environment '</span></span> + env + <span class="hljs-string"><span class="hljs-string">' not defined in '</span></span> + std.thisFile</code> </pre> <br><p>        <strong>deploy/website/environments/review.libsonnet</strong> : </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// this file has the param overrides for the default environment local base = import './base.libsonnet'; local slug = std.extVar('qbec.io/tag'); local subdomain = std.extVar('subdomain'); base { components+: { website+: { name: 'example-docs-' + slug, domain: subdomain + '.docs.example.org', }, }, }</span></span></code> </pre> <br><p>       <strong>stop_review</strong> ,         gitlab    checkout    <strong>GIT_STRATEGY: none</strong> ,    <strong>master</strong> -   review  . <br>  ,        . <br>       review   ,     . </p><br><p>     : </p><br><pre> <code class="plaintext hljs">git add . git commit -m "Enable automatic review"</code> </pre> <br><p> <strong>git push</strong> , <strong>git checkout -b test</strong> , <strong>git push origin test</strong> , : </p><br><div class="spoiler"> <b class="spoiler_title">  environments  Gitlab</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/wc/pz/ce/wcpzcedcwgfqvr0h_thgcw4ylqk.png"></p></div></div><br><p>  ? ‚Äî ,    : <strong>git checkout master</strong> , <strong>git push origin :test</strong> ,      environment   . </p><br><blockquote>    ,        ,     <strong>.gitlab-ci.yml</strong>       . <br>          protected-,   <strong>master</strong> ,        . </blockquote><br><hr><br><h1 id="13-review-appsanchorreview-appsanchor"> 13. Review Apps <a name="review-apps"></a></h1><br><p> <strong><a href="https://docs.gitlab.com/ee/ci/review_apps/" rel="nofollow">Review Apps</a></strong>    ,                . </p><br><p>      ,    <strong>.gitlab/route-map.yml</strong>       ,       : </p><br><pre> <code class="plaintext hljs"># Indices - source: /content\/(.+?)_index\.(md|html)/ public: '\1' # Pages - source: /content\/(.+?)\.(md|html)/ public: '\1/'</code> </pre> <br><p>     : </p><br><pre> <code class="plaintext hljs">git add .gitlab/ git commit -m "Enable review apps"</code> </pre> <br><p> <strong>git push</strong> ,  : </p><br><div class="spoiler"> <b class="spoiler_title">  Review App</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ns/wi/za/nswizajvjjozyoluazo21pzq7t8.png"></p></div></div><br><h1 id="job-is-done"> Job is done! </h1><br><p> <strong> :</strong> </p><br><ul><li>  Gitlab: <a href="" rel="nofollow">https://gitlab.com/kvaps/docs.example.org</a> </li><li>  GitHub: <a href="" rel="nofollow">https://github.com/kvaps/docs.example.org</a> </li></ul><br><p>   ,    <img src="https://habrastorage.org/getpro/habr/post_images/cd7/2c7/9c3/cd72c79c3eeb7355e20bba58e9088654.gif" alt="imagem"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt481662/">https://habr.com/ru/post/pt481662/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt481644/index.html">Como sobreviver a um banco de dados SQL no s√©culo 21: multimaster nuvens, Kubernetes e PostgreSQL</a></li>
<li><a href="../pt481648/index.html">Junos PyEZ no exemplo da tarefa de encontrar sub-redes ipv4 gratuitas</a></li>
<li><a href="../pt481652/index.html">Backdoor (?) Em smartphones BlackBerry Android</a></li>
<li><a href="../pt481654/index.html">A hist√≥ria de como o engenheiro de controle de qualidade tornou a vida mais f√°cil para voc√™ com a ajuda do Test IT, usando o Bot Framework</a></li>
<li><a href="../pt481656/index.html">PagerDuty, ou por que o departamento de opera√ß√µes pode n√£o dormir √† noite</a></li>
<li><a href="../pt481664/index.html">Pre√ßos e custos sem servidor: AWS Lambda</a></li>
<li><a href="../pt481666/index.html">Regras personalizadas do SwiftLint</a></li>
<li><a href="../pt481668/index.html">O primeiro problema do visualizador ou as dificuldades de converter fluxos de v√≠deo WebRTC em HLS</a></li>
<li><a href="../pt481670/index.html">Crie um plano de a√ß√£o usando o AWS Cloud Adoption Framework</a></li>
<li><a href="../pt481672/index.html">Aut√¥matos celulares no navegador</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>