<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤽🏼 🤯 🐶 Modèles personnalisés dans GTM: un exemple 👩‍👦‍👦 👨🏿‍🤝‍👨🏽 🤙🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fin mai, Google a introduit une nouvelle fonctionnalité dans Google Tag Manager (GTM): des modèles personnalisés ou des modèles personnalisés. Voyons ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Modèles personnalisés dans GTM: un exemple</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458788/">  Fin mai, Google a introduit une nouvelle fonctionnalité dans Google Tag Manager (GTM): des modèles personnalisés ou des modèles personnalisés.  Voyons pourquoi il est nécessaire, comment l'utiliser, quelles sont les différences avec les balises HTML et les variables JavaScript. <br><br>  Par exemple, envisagez de créer un modèle personnalisé pour un pixel de reciblage dynamique VKontakte et de personnaliser davantage les balises GTM à travers lui. <br><br><img src="https://habrastorage.org/webt/c-/62/zr/c-62zrfxks1t6c2gfsv0kn2brjm.png"><br><a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mots simples sur les modèles personnalisés</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Création d'un modèle personnalisé</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">• Onglet Info</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">• Onglet Champs</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">• Onglet Code</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">• Onglet Autorisations</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Personnalisation et test de la balise sur le modèle personnalisé créé</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">• Page vue</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">• AddToCart</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">• Test minier</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conclusion</a> <br><br><a name="1"></a><h2>  Mots simples sur les modèles personnalisés </h2><br>  Les modèles personnalisés sont des modèles grâce auxquels les utilisateurs peuvent créer de nouvelles balises ou variables.  GTM a des modèles prêts à l'emploi (dans la section En vedette ou recommandé), par exemple, la balise Google Analytics, Google Optimize et autres.  Nous pouvons maintenant les compléter avec nos modèles.  Une fois créés, ils apparaîtront dans l'onglet Personnalisé: <br><br><img src="https://habrastorage.org/webt/nx/q_/mu/nxq_mu_uxl6tyiumnl8xbzt6o2c.png"><br><br>  La principale différence avec les balises HTML et les variables JS est que lorsqu'un utilisateur crée une balise ou une variable à l'aide d'un modèle prêt à l'emploi, il n'interagit pas avec le code JS. <br><br>  Le code du modèle utilisateur est écrit par le développeur ou l'analyste Web au stade de sa création.  Ensuite, lors de la création d'une balise ou d'une variable selon un modèle utilisateur, toutes les interactions sont effectuées via l'interface (qui est également configurée lors de la création d'un modèle utilisateur): <br><br><img src="https://habrastorage.org/webt/pe/e2/te/pee2tevqbahm_nplbfgj0btis34.png"><br><br>  Par conséquent, par rapport à l'écriture d'une balise HTML ou d'une variable JS, la personnalisation d'une balise ou d'une variable selon un modèle utilisateur devient un ordre de grandeur plus facile, car cela ne nécessite pas de connaissances et de compétences pour travailler avec JavaScript. <br><br>  Un autre grand avantage des modèles personnalisés est que la probabilité de "mettre" un site est réduite d'un ordre de grandeur en raison d'une erreur dans le code JS de la balise. <br><br>  Dans notre exemple, pour configurer la balise de reciblage dynamique "VKontakte", vous n'avez plus besoin de contacter les développeurs - tout peut être configuré indépendamment, même le transfert de données sur les marchandises (lorsque le commerce électronique avancé de Google est configuré sur le site), n'ayant qu'une expérience avec GTM. <br><br><a name="2"></a><h2>  Création d'un modèle personnalisé </h2><br>  Puisque nous créons un modèle de balise, nous devons aller dans la section Modèles et cliquer sur le bouton Nouveau dans la section Modèles de balises. <br><br><img src="https://habrastorage.org/webt/ca/bt/sa/cabtsaamxy-zoglccqgvt1v_tra.png"><br><br>  Après cela, l'éditeur de modèle s'ouvre: <br><br><img src="https://habrastorage.org/webt/bf/c3/jf/bfc3jf2xgpkasmc3qvik2tp4wxy.png"><br><br>  Sur le côté gauche de l'éditeur, il y a une fenêtre de paramètres, sur le côté droit il y a une fenêtre d'aperçu et une console.  La fenêtre des paramètres contient quatre onglets nécessaires à la création et à l'utilisation du modèle. <br><br><a name="3"></a><h3>  Onglet Info </h3><br>  Les informations sur le tag sont renseignées sur cet onglet: nom, description, icône.  Voici les informations que nous verrons lors de la création d'une nouvelle balise dans la liste des modèles: <br><br><img src="https://habrastorage.org/webt/dd/nm/9f/ddnm9fvcygh2ob6jzkliccqgi1o.png"><br><br>  Il y a des exigences pour l'icône de balise: format PNG, JPEG ou GIF, une résolution d'au moins 64x64 pixels et une taille ne dépassant pas 50 Ko. <br><br><a name="4"></a><h3>  Onglet Champs </h3><br>  Cette section crée l'interface de notre modèle.  L'interface se compose de divers champs et formulaires avec lesquels l'utilisateur interagit au stade de la création d'une nouvelle balise ou variable. <br><br>  À l'avenir, les informations entrées par l'utilisateur lors de la création de la balise à l'aide de l'interface seront utilisées dans le code du modèle. <br><br>  Pour ajouter un nouvel élément, cliquez sur le bouton Ajouter un champ.  La fenêtre de sélection du type d'élément apparaît: <br><br><img src="https://habrastorage.org/webt/g5/ko/d7/g5kod7ox7dal761180kpdfhojto.png"><br><br>  GTM vous permet de sélectionner les types d'éléments d'interface suivants: <br><br><ul><li>  <b>zone de texte</b> </li><li>  <b>menu déroulant</b> </li><li>  <b>case à cocher</b> ; </li><li>  <b>interrupteurs</b> </li><li>  <b>tableau simple</b> , ici vous pouvez éditer chaque cellule. </li><li>  <b>table étendue</b> , vous ne pouvez modifier qu'une ligne, ce type de table est pratique à utiliser pour créer un dictionnaire à partir de paires clé-valeur; </li><li>  <b>groupe d'éléments</b> , vous permet de regrouper plusieurs types en un groupe; </li><li>  <b>le raccourci est</b> utilisé pour ajouter du texte à l'interface; il ne nécessite pas que l'utilisateur entre des données. </li></ul><br>  Après avoir ajouté un élément, vous devez lui donner un nom convivial, qui sera ensuite utilisé dans le code.  Il s'agit d'une sorte de nom de variable - il doit être compréhensible et révéler l'essence de l'élément d'interface créé.  Par exemple, le nom «ID» ne signifie rien de spécifique, mais le nom «pixelIDs» montre déjà que les identifiants de pixel saisis par l'utilisateur sont stockés dans cet élément: <br><br><img src="https://habrastorage.org/webt/fv/1h/ht/fv1hht_iaatbuhi1ejovajkehhc.png"><br><br>  Ensuite, accédez aux paramètres de chaque élément et activez les propriétés nécessaires. <br>  Dans différentes situations, différentes propriétés de l'élément d'interface sont requises, donc par défaut, elles sont toutes cachées et nous devons activer celles qui sont nécessaires maintenant: <br><br><img src="https://habrastorage.org/webt/ah/jx/o1/ahjxo1oz0w8fp6pntytshfs1y_o.png"><br><br>  Pour différents types d'éléments, les propriétés disponibles diffèrent, je vais indiquer les plus utilisées, qui sont presque tous des éléments: <br><br>  <b>1. Nom d'affichage</b> .  Voici le nom que l'utilisateur verra dans l'interface lors de la création de la balise: <br><br><img src="https://habrastorage.org/webt/jf/lk/-g/jflk-glzt0dahft6vpdx9qrzy8q.png"><br><br>  <b>2. Exemple de valeur</b> .  Voici un indice pour l'utilisateur sur les valeurs à saisir dans le champ: <br><br><img src="https://habrastorage.org/webt/b6/zz/sc/b6zzscielm1pjho74x22rk88c0c.png"><br><br>  <b>3. Texte d'aide</b> .  Voici le texte que l'utilisateur verra s'il survole l'icône d'aide de l'élément: <br><br><img src="https://habrastorage.org/webt/nv/wo/qr/nvwoqraide7hp-qrbdjaomwvg3e.png"><br><br>  <b>4. Règles de vérification des données</b> .  Dans cette propriété, vous pouvez définir certaines règles pour vérifier les données entrées par l'utilisateur dans le champ et, si nécessaire, le texte d'erreur qui apparaît lorsque vous essayez d'enregistrer une balise avec des données qui n'ont pas réussi le test. <br><br>  Par exemple, vous pouvez spécifier que le champ doit être rempli.  Le deuxième exemple: vous devez obtenir une adresse e-mail de l'utilisateur, puis vous pouvez vérifier que les données saisies par l'utilisateur doivent correspondre à l'expression régulière <b>. * @. * \ .. *</b> . <br><br><img src="https://habrastorage.org/webt/3s/ma/pb/3smapbl1aorsc4fsvhwpd-1oy4m.png"><br><br>  Pour spécifier le texte d'erreur qui apparaît si les données saisies ne sont pas conformes aux règles de vérification, vous devez activer les paramètres de règle avancés: <br><br><img src="https://habrastorage.org/webt/kb/zw/qr/kbzwqr32irigkreu9bbht9fxf1m.png"><br><br><img src="https://habrastorage.org/webt/ek/xh/hg/ekxhhgobsta59wpr6uxsbaqzdwg.png"><br><br>  De plus, dans les paramètres avancés, vous pouvez spécifier les conditions dans lesquelles cette règle est activée (le champ Activer la condition). <br><br>  <b>5. Conditions d'inclusion</b> .  Ce sont les conditions dans lesquelles l'utilisateur aura cet élément d'interface. <br><br>  Par exemple, afin de ne pas surcharger le modèle avec des éléments d'interface, vous pouvez faire apparaître les éléments nécessaires lorsque la case est cochée.  Autrement dit, supposons que si un utilisateur souhaite configurer le transfert des données de produit dans un pixel (cela est possible avec le site de commerce électronique avancé de Google configuré sur le site), il sélectionne la case "Utiliser dataLayer pour transférer les données de produit", et après avoir coché la case, des éléments apparaissent dans l'interface du tag nécessaire pour configurer un tel transfert.  Si la case n'est pas cochée, il n'y a aucun élément dans l'interface. <br><br><img src="https://habrastorage.org/webt/rp/ui/x_/rpuix__y-ya--_uat8taekcwpa0.png"><br><br>  Je note qu'ici, il est nécessaire d'indiquer le nom de l'élément, qui devait lui être attribué immédiatement après l'ajout. <br><br>  Lorsque vous ajoutez des paramètres et créez une interface, toutes les modifications peuvent être immédiatement visualisées et testées dans la fenêtre d'aperçu: <br><br><img src="https://habrastorage.org/webt/df/bl/l9/dfbll9mc0qvpwcxnbzzx-fbg71g.png"><br><br><a name="5"></a><h3>  Onglet Code </h3><br>  Cet onglet est un éditeur de code. <br><br>  Le code GTM Custom Templates est écrit en JavaScript «allégé» ES6 et s'exécute dans un environnement isolé où toutes les communications avec les données globales (c'est-à-dire directement avec la page) se font via l'API.  Il n'y a pas d'objets globaux, tels que fenêtre ou document, respectivement, dans les méthodes habituelles.  Par exemple, les constructeurs (nouvel objet et similaires), setTimeout, parseInt, delete, etc.  - tout cela ne fonctionnera pas dans le modèle personnalisé. <br><br>  Mais il y a une API pour tout ça.  Et par conséquent, l'écriture de code pour un modèle personnalisé doit commencer par le fait que nous définissons les API que nous utiliserons dans notre code: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// API //     const copyFromWindow = require('copyFromWindow'); //     const setInWindow = require('setInWindow'); //      const injectScript = require('injectScript'); //    const callInWindow = require('callInWindow'); //  ,     ,    const makeTableMap = require('makeTableMap'); //   URL  const getUrl = require('getUrl'); //    const getQueryParameters = require('getQueryParameters'); //     const makeInteger = require('makeInteger'); //    const makeString = require('makeString'); //  setTimeout const callLater = require('callLater'); //  console.log const logToConsole = require('logToConsole');</span></span></code> </pre> <br>  Consultez l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">aide aux développeurs Google pour obtenir une</a> liste complète des API avec une documentation détaillée. <br><br>  Je vais vous montrer des exemples de la façon de travailler avec l'API: <br><div class="scrollable-table"><table><tbody><tr><th>  Description de l'action </th><th>  Classic js </th><th>  API de modèle personnalisé </th></tr><tr><td>  Sortie console </td><td>  console.log ('Salut'); </td><td>  logToConsole ('Salut'); </td></tr><tr><td>  Régler la minuterie </td><td>  setTimeout (fonction, 100); </td><td>  callLater (fonction); </td></tr><tr><td>  Convertir en chaîne </td><td>  Chaîne (1234); </td><td>  makeString (1234); </td></tr><tr><td>  Conversion en entier </td><td>  parseInt («1234», 10); </td><td>  makeInteger («1234»); </td></tr><tr><td>  Hôte de la page </td><td>  window.location.hostname </td><td>  getUrl ('hôte'); </td></tr></tbody></table></div><br>  Comme vous pouvez le voir dans le tableau d'exemple, après avoir défini l'API, vous devez l'utiliser à la place des constructions JS standard. <br><br>  Après avoir défini l'API, il est souhaitable de définir un objet avec les paramètres que l'utilisateur a saisis.  Cela peut également être fait après, par exemple, pendant le code exécutable, en demandant les données nécessaires aux paramètres de l'utilisateur.  Mais si nous définissons l'objet settings depuis le tout début, travailler avec le code devient plus facile et plus compréhensible, car tous les paramètres utilisateur sont stockés dans un objet séparé. <br><br>  Pour obtenir des données d'un élément d'interface, vous devez utiliser la construction de données. <br><br>  {{nom d'élément}}: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    const settings = { //  event: data.event, //ID  () pixelIDs: data.pixelIDs, //ID - (  1 -) priceListId: data.priceListId, //   -? fewPriceLists: data.fewPriceLists, //ID - (    ) priceListIds: data.priceListIds === undefined ? data.priceListIds : makeTableMap(data.priceListIds,'hostname','priceListId'), //  ecommerce   ? ecommerceUse: data.ecommerceUse, // ecommerce   eventEcommerce: data.eventEcommerce, //     siteSearchQueryParam: data.siteSearchQueryParam };</span></span></code> </pre><br>  Remarque: si vous passez undefined à la méthode makeTableMap, cela provoquera une erreur de script, donc j'utilise une construction avec un opérateur ternaire (un enregistrement abrégé de la construction if-else) pour filtrer ces scripts. <br><br><div class="spoiler">  <b class="spoiler_title">À propos de la méthode makeTableMap.</b> <div class="spoiler_text">  Si l'interface utilise une table étendue, les données qu'elle contient sont stockées sous cette forme: <br><br><pre> <code class="javascript hljs">[ <span class="hljs-string"><span class="hljs-string">'key'</span></span>: <span class="hljs-string"><span class="hljs-string">'k1'</span></span>, <span class="hljs-string"><span class="hljs-string">'value'</span></span>: <span class="hljs-string"><span class="hljs-string">'v1'</span></span>}, <span class="hljs-string"><span class="hljs-string">'key'</span></span>: <span class="hljs-string"><span class="hljs-string">'k2'</span></span>, <span class="hljs-string"><span class="hljs-string">'value'</span></span>: <span class="hljs-string"><span class="hljs-string">'v2'</span></span>} ]</code> </pre><br>  Après traitement avec la méthode makeTableMap, les données deviennent un objet normal avec des paires clé-valeur: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">'k1'</span></span>: <span class="hljs-string"><span class="hljs-string">'v1'</span></span>, <span class="hljs-string"><span class="hljs-string">'k2'</span></span>: <span class="hljs-string"><span class="hljs-string">'v2'</span></span> }</code> </pre><br></div></div><br>  Autre exigence pour le code du modèle personnalisé: si la balise est correctement exécutée, vous devez appeler la méthode data.gtmOnSuccess () et en cas d'erreur, appeler la méthode data.gtmOnFailure (). <br><br>  Par exemple, dans mon code, la méthode data.gtmOnSuccess () est appelée après que la demande a été envoyée avec succès et la méthode data.gtmOnFailure () est appelée si le téléchargement échoue sur la page de script externe VK openapi.js. <br><br>  Après avoir défini l'API et défini l'objet avec les paramètres, vous pouvez commencer à écrire un algorithme pour travailler le pixel. <br><br>  La principale chose à retenir ici est: <br><br>  • Si vous avez besoin d'obtenir une variable globale - utilisez la méthode API copyFromWindow. <br><br><pre> <code class="javascript hljs">copyFromWindow(<span class="hljs-string"><span class="hljs-string">'VK'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//VK -   ,    </span></span></code> </pre><br>  • Si vous devez définir une variable globale, nous utilisons la méthode API setInWindow. <br><br><pre> <code class="javascript hljs">setInWindow(<span class="hljs-string"><span class="hljs-string">'openapiInject'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//openapiInject -   ,    //1 - ,    .</span></span></code> </pre><br>  • Si vous devez exécuter une fonction globale, nous utilisons la méthode API callInWindow. <br><br><pre> <code class="javascript hljs">callInWindow(<span class="hljs-string"><span class="hljs-string">'VK.Retargeting.Init'</span></span>, p); <span class="hljs-comment"><span class="hljs-comment">//VK.Retargeting.Init -   ,    //p - ,     </span></span></code> </pre><br>  • Si vous devez ajouter un script externe à la page - utilisez la méthode API injectScript. <br><br><pre> <code class="javascript hljs">injectScript(<span class="hljs-string"><span class="hljs-string">'https://vk.com/js/api/openapi.js?159'</span></span>, pixel.setVkAsyncInit(), data.gtmOnFailure, <span class="hljs-string"><span class="hljs-string">'vkPixel'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//https://vk.com/js/api/openapi.js?159 -  ,      //pixel.setVkAsyncInit() - ,        //data.gtmOnFailure - ,        //vkPixel -  ,  ,   URL  .    ,   JavaScript      </span></span></code> </pre><br>  • Si vous devez obtenir l'URL (ou une partie de celle-ci) - utilisez la méthode API getUrl. <br><br><pre> <code class="javascript hljs">getUrl(<span class="hljs-string"><span class="hljs-string">'host'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//host -  URL,  .  ,  host: protocol, port, path, extension, fragment, query.</span></span></code> </pre><br>  Comme je l'ai écrit ci-dessus, le modèle personnalisé prend en charge JS ES6.  Il est conseillé d'utiliser cette syntaxe, car elle raccourcit le code et le rend plus lisible, et le travail de JS est plus prévisible et similaire à d'autres langages de programmation. <br><br><div class="spoiler">  <b class="spoiler_title">Plus d'informations sur la syntaxe JS ES6</b> <div class="spoiler_text">  La principale chose qu'il est souhaitable d'utiliser est les fonctions fléchées et les déclarations de const et let variables au lieu de var. <br><br>  Une variable déclarée via const est une constante dont la valeur ne peut pas être modifiée. <br><br>  Une variable déclarée par let diffère d'une variable déclarée par var comme suit: <br><br><ul><li>  let n'est pas ajouté à l'objet de fenêtre globale; </li><li>  la visibilité est limitée au bloc de déclaration; </li><li>  les variables déclarées via let ne peuvent pas être re-déclarées. </li></ul><br>  Les fonctions fléchées sont l'abréviation des fonctions habituelles: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//1.   const func1 = function() { return 'test'; } //    const func1 = () =&gt; 'test'; //2.   const func2 = function(arg) { if (arg &gt; 0) return 'plus'; else return 'minus'; } //    const func2 = arg =&gt; { if (arg &gt; 0) return 'plus'; else return 'minus'; } //3.   const func3 = function(arg1, arg2){ if (arg1 &gt; arg2) return arg1; else return arg2; } //    const func3 = (arg1, arg2) =&gt; { if (arg1 &gt; arg2) return arg1; else return arg2; }</span></span></code> </pre><br></div></div><br>  Maintenant que nous comprenons comment utiliser l'API de modèle personnalisé, nous pouvons écrire le code d'opération de balise à l'aide de la syntaxe JavaScript ES6. <br><br>  Mon code contient des méthodes pour lancer un pixel, installer VK openapi.js, récupérer les données produit de dataLayer (avec le site de commerce électronique avancé de Google configuré), traiter ces données pour les mettre sous la forme nécessaire pour l'envoi au pixel de reciblage VKontakte et la méthode de répartition des événements. <br><br>  La méthode de déclenchement par pixel prend en charge trois scénarios: <br><br><ol><li>  Le pixel s'exécute sur une page où openapi.js est manquant. </li><li>  Le pixel s'exécute sur la page où se trouve openapi.js, mais il n'a pas encore été chargé. </li><li>  Le pixel est lancé sur la page avec openapi.js chargé. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Le code complet de mon modèle GTM personnalisé pour le pixel de reciblage dynamique VKontakte</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//api const copyFromWindow = require('copyFromWindow'); const setInWindow = require('setInWindow'); const injectScript = require('injectScript'); const callInWindow = require('callInWindow'); const makeTableMap = require('makeTableMap'); const getUrl = require('getUrl'); const getQueryParameters = require('getQueryParameters'); const makeInteger = require('makeInteger'); const makeString = require('makeString'); const callLater = require('callLater'); //    const settings = { event: data.event, pixelIDs: data.pixelIDs, priceListId: data.priceListId, fewPriceLists: data.fewPriceLists, priceListIds: data.priceListIds === undefined ? data.priceListIds : makeTableMap(data.priceListIds,'hostname','priceListId'), ecommerceUse: data.ecommerceUse, eventEcommerce: data.eventEcommerce, siteSearchQueryParam: data.siteSearchQueryParam }; //       const pixel = { //    getPageHostname: () =&gt; getUrl('host'), //    VK getVK: () =&gt; copyFromWindow('VK'), //    VK setVkAsyncInit: () =&gt; { setInWindow('vkAsyncInit', pixel.sendEvent); }, //       getSiteSearchPhrase: () =&gt; { if (settings.event === 'view_search') return getQueryParameters(settings.siteSearchQueryParam); else return undefined; }, //      getEventParams: (products, currencyCode, revenue) =&gt; { let eventParamsClean= {}; let eventParams = { products: eventProducts.getProductParams(products), category_ids: eventProducts.getCategoryString(products), currency_code: currencyCode, total_price: eventProducts.getTotalPrice(products, revenue), search_string: pixel.getSiteSearchPhrase() }; if (eventParams.products !== undefined) eventParamsClean.products = eventParams.products; if (eventParams.category_ids !== undefined) eventParamsClean.category_ids = eventParams.category_ids; if (eventParams.currency_code !== undefined) eventParamsClean.currency_code = eventParams.currency_code; if (eventParams.total_price !== undefined) eventParamsClean.total_price = eventParams.total_price; if (eventParams.search_string !== undefined) eventParamsClean.search_string = eventParams.search_string; return eventParamsClean; }, //  - getPriceListId: hostname =&gt; { if (settings.fewPriceLists) return settings.priceListIds[hostname]; else return settings.priceListId; }, //  openapi.js openapiInit: () =&gt; { injectScript('https://vk.com/js/api/openapi.js?159', pixel.setVkAsyncInit(), data.gtmOnFailure, 'vkPixel'); setInWindow('openapiInject', 1); }, //   sendEvent: () =&gt; { if (settings.event === 'hit') { settings.pixelIDs.split(',').forEach(p =&gt; { callInWindow('VK.Retargeting.Init',p); callInWindow('VK.Retargeting.Hit'); }); } else { const pricelist = pixel.getPriceListId(pixel.getPageHostname()); const name = settings.event; let products = []; if(settings.ecommerceUse) products = name === 'view_home' || name === 'view_category' || name === 'view_search' || name === 'view_other' ? settings.eventEcommerce : settings.eventEcommerce.products; else products = undefined; const currencyCode = settings.ecommerceUse ? settings.eventEcommerce.currencyCode : undefined; const revenue = (settings.ecommerceUse &amp;&amp; name === 'purchase') ? settings.eventEcommerce.actionField.revenue : undefined; const eventParams = settings.ecommerceUse ? pixel.getEventParams(products, currencyCode, revenue) : undefined; settings.pixelIDs.split(',').forEach(p =&gt; { callInWindow('VK.Retargeting.Init',p); callInWindow('VK.Retargeting.ProductEvent', pricelist, name, eventParams); }); }, //   start: () =&gt; { if (pixel.getVK() === undefined &amp;&amp; copyFromWindow('openapiInject') !== 1) { pixel.openapiInit(); data.gtmOnSuccess(); } else if (pixel.getVK() === undefined &amp;&amp; copyFromWindow('openapiInject') === 1) { if (pixel.count &lt; 50) { callLater(pixel.start); pixel.count++; } else return; } else { pixel.sendEvent(); data.gtmOnSuccess(); }, //   count: 0 }; //       const eventProducts = { //    products   getProductParams: products =&gt; { let arr = []; products.forEach(i =&gt; { let productParamsClean = {}; let productParams = { id: makeString(i.id), group_id: makeString(i.brand), price: makeInteger(i.price * 100) / 100 }; if (productParams.id !== 'undefined') productParamsClean.id = productParams.id; if (productParams.group_id !== 'undefined') productParamsClean.group_id = productParams.group_id; if (productParams.price !== 0) productParamsClean.price = productParams.price; arr.push(productParamsClean); }); return arr; }, //       'a,b,c'       getCategoryString: products =&gt; { let categoryId = ''; let check = []; products.forEach(i =&gt; { if(check.indexOf(i.category) === -1) { check.push(i.category); categoryId += ',' + i.category; }); return categoryId.slice(1); }, //     getTotalPrice: (products, revenue) =&gt; { let sumPrice = 0; if (revenue !== undefined ) return makeInteger(revenue * 100) / 100; else { products.forEach(i =&gt; { if (i.hasOwnProperty('quantity')) sumPrice += (makeInteger(i.price * 100) / 100) * makeInteger(i.quantity); else sumPrice += makeInteger(i.price * 100) / 100; }); return sumPrice; }; //  pixel.start();</span></span></code> </pre> <br></div></div><br><a name="6"></a><h2>  Onglet Autorisations </h2><br>  Après avoir écrit le code de balise, la dernière étape reste - pour émettre des autorisations d'interagir avec les données globales de la page.  Cela se fait uniquement sur l'onglet Autorisations. <br><br>  Étant donné que le code est exécuté dans un environnement isolé et que l'interaction avec les données globales se produit via l'API, pour chaque méthode API (si nécessaire), nous devons spécifier manuellement les autorisations pour certaines actions. <br><br>  Ceci est fait afin d'aborder le travail avec les données de page globales de manière aussi réfléchie que possible, et ainsi minimiser les chances de "mettre" le site dans une erreur dans le code de notre modèle. <br><br>  Pour les méthodes API utilisées dans mon code, trois types d'autorisations doivent être émis: <br><br><img src="https://habrastorage.org/webt/29/og/lw/29oglwyra6zkhac7_2lr4jpqq5a.png"><br><br>  <b>1. Accède aux variables globales</b> - lire, écrire, exécuter l'accès aux variables globales qui sont utilisées dans notre code.  Les variables doivent être ajoutées manuellement et pour chacune d'elles indiquer ce que nous autorisons à faire. <br><br><img src="https://habrastorage.org/webt/f3/qb/6b/f3qb6b9sj6rn1v4q55t_z9f362e.png"><br><br>  Par exemple, la variable VK ne peut être lue que, vkAsyncInit peut être lu et redéfini et la méthode VK.Retargeting.Hit ne peut être exécutée. <br><br>  <b>2. Lit l'URL</b> .  Ici, vous devez spécifier quelles parties de l'URL sont autorisées à recevoir.  J'autorise la réception de toutes les parties de l'URL: <br><br><img src="https://habrastorage.org/webt/do/um/li/doumlixqd-rw2cppm4ordw1svae.png"><br><br>  Mais si vous le souhaitez, vous pouvez spécifier tout spécifique: <br><br><img src="https://habrastorage.org/webt/sj/d3/ne/sjd3nefe52_foeat88kifeodi-w.png"><br><br>  <b>3. Injecte des scripts</b> .  Ici, il est nécessaire d'enregistrer les adresses à partir desquelles vous pouvez télécharger des scripts externes.  Dans mon code, un seul script avec VK openapi.js est chargé, je précise son adresse: <br><br><img src="https://habrastorage.org/webt/xt/oy/hd/xtoyhd-yprd2sn_eu41mbquh2s0.png"><br><br>  C'est tout, la configuration du modèle personnalisé est terminée, vous pouvez enregistrer le modèle et procéder aux tests. <br><br><a name="7"></a><h2>  Personnalisation et test de la balise sur le modèle personnalisé créé </h2><br>  Par exemple, nous allons créer deux balises de reciblage dynamique «VKontakte» en utilisant le modèle personnalisé créé: pageview et addToCart. <br><br><a name="8"></a><h3>  Page vue </h3><br>  Nous allons entrer dans le conteneur GTM nécessaire, créer une nouvelle balise, sélectionner le type de balise VK Pixel dans la section personnalisée: <br><br><img src="https://habrastorage.org/webt/gd/s-/fi/gds-fi0tqxxcmfkkccsi8trowq4.png"><br><br>  Remplissez le nom du tag, sélectionnez l'événement à suivre, sélectionnez Hit (il s'agit d'une page vue standard), dans le champ "Pixel ID" indiquez l'ID des deux pixels vers lesquels les données seront envoyées, et définissez le déclencheur Toutes les pages: <br><br><img src="https://habrastorage.org/webt/vr/op/-0/vrop-0cjfqndkh35qnbtdsoxpc4.png"><br><br>  Enregistrez la balise créée. <br><br><a name="9"></a><h3>  AddToCart </h3><br>  Créer une balise pour un événement en ajoutant un produit au panier sera un peu plus compliqué qu'une balise Hit. <br><br>  Tout d'abord, vous devez transférer les marchandises ajoutées au panier.  Comme je l'ai écrit ci-dessus, cela est possible avec le commerce électronique avancé de Google configuré sur le site.  Dans ce cas, les données produit sont extraites de dataLayer. <br><br>  Pour ce faire, nous devons créer la variable dataLayer dans GTM, qui stockera l'objet de commerce électronique pour l'événement addToCart.  Les paramètres variables ressemblent à ceci: <br><br><img src="https://habrastorage.org/webt/ko/r5/gu/kor5gumudjjzs9groemuo7nepco.png"><br><br>  Deuxièmement, vous devez créer un déclencheur qui activera la balise lorsque l'événement de commerce électronique addToCart se produit (le déclencheur activera la balise lors de l'introduction du dataLayer lorsque l'événement addToCart se produit): <br><br><img src="https://habrastorage.org/webt/og/xl/lt/ogxlltp_4_spurvq8fesqg3uy0m.png"><br><br>  Après avoir créé une variable avec un objet de commerce électronique et un déclencheur, vous pouvez commencer à créer la balise: <br><br><img src="https://habrastorage.org/webt/dp/qg/zq/dpqgzqb27rcdydnjeen5fftp6ba.png"><br><br>  Pour: <br><br><ol><li>  En tant qu'événement suivi, sélectionnez Ajouter au panier. </li><li>  Nous remplissons l'ID séparé par des virgules de deux pixels dans lesquels les données doivent être transférées. </li><li>  Cochez la case «Utiliser plusieurs listes de prix»: pour Moscou et Saint-Pétersbourg, dans notre exemple, il est nécessaire d'utiliser des listes de prix différentes. </li><li>  Remplissez le tableau avec les listes de prix. </li><li>  Cochez la case «Utiliser le commerce électronique pour transférer des produits et des paramètres». </li><li>  Dans l'objet de commerce électronique de cet événement, spécifiez la variable créée précédemment. </li><li>  Nous avons défini le déclencheur de l'événement surveillé, dans ce cas - AddToCart. </li><li>  Enregistrez. </li></ol><br><a name="10"></a><h3>  Test minier </h3><br>  Pour vérifier le fonctionnement des pixels du reciblage dynamique sur VKontakte, vous devez activer le mode Aperçu dans GTM, allez sur notre site Web et ouvrez la section Réseau dans la console du navigateur et entrez 'rtrg' dans le champ Filtre: <br><img src="https://habrastorage.org/webt/ci/m9/z8/cim9z824mbc9dfvdz-4425fe02w.png"><br><br>  Après cela, nous actualisons la page et nous devrions avoir deux demandes - l'événement Hit envoyé en deux pixels: <br><br><img src="https://habrastorage.org/webt/o0/5x/80/o05x80jeypiwcogusca_zgsnaju.png"><br><br>  Le statut 200 signifie que les demandes sont envoyées et reçues par le serveur avec succès. <br><br>  Toujours dans la fenêtre Aperçu GTM, nous voyons que notre balise créée a fonctionné correctement pour l'événement Vue de page. <br><br>  Pour vérifier l'événement Ajouter au panier, ajoutez le produit au panier et, dans la console, nous avons deux autres demandes: <br><br><img src="https://habrastorage.org/webt/wt/jm/-k/wtjm-k50mmapqa1xtyva_yd3wcc.png"><br><br>  Dans la fenêtre Aperçu GTM, nous voyons que la deuxième balise a fonctionné avec succès.  Les données de produit de dataLayer sont remontées et traitées correctement, la liste de prix correcte a également été remplacée. <br><br>  Pour le deuxième hôte, la liste de prix est également remplacée correctement: <br><br><img src="https://habrastorage.org/webt/n3/de/h3/n3deh30jep61h2kv9zefwruu8cy.png"><br><br>  Les balises des autres événements sont configurées et vérifiées de la même manière. <br><br><a name="11"></a><h2>  Conclusion </h2><br>  Les modèles personnalisés changent le paradigme familier de l'utilisation de GTM.  Tout le monde est habitué aux balises HTML et aux variables JS, mais il existe maintenant une excellente alternative. <br><br>  Il suffit de créer un modèle personnalisé de haute qualité une fois, puis toute personne familiarisée avec GTM peut l'utiliser. <br><br>  Étant donné la possibilité de partager les modèles créés, je pense qu'ils devraient gagner en popularité auprès des utilisateurs. <br><br>  Vous pouvez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">télécharger le modèle de</a> pixel de reciblage dynamique <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">personnalisé</a> VKontakte, que nous avons examiné dans cet article. <br><br>  Pour importer un modèle, vous devez créer un nouveau modèle personnalisé et sélectionner Importer dans le menu: <br><br><img src="https://habrastorage.org/webt/mx/nn/jc/mxnnjc0419poxmshokabjcgeoye.png"><br><br>  <i>Matériel préparé par moi pour ppc.world</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458788/">https://habr.com/ru/post/fr458788/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458774/index.html">SGBD fonctionnel</a></li>
<li><a href="../fr458778/index.html">Satellite 6.5 Reporting Engine: quoi et pourquoi</a></li>
<li><a href="../fr458782/index.html">Adaptation de programmes pour ZX Spectrum à TR-DOS par des moyens modernes. 3e partie</a></li>
<li><a href="../fr458784/index.html">Diffuser des projets et des bibliothèques d'Altium Designer vers PADS Professional</a></li>
<li><a href="../fr458786/index.html">Les gardiens de jeux vidéo gardent la culture du jeu étape par étape</a></li>
<li><a href="../fr458790/index.html">Introduction à CatBoost. Rapport Yandex</a></li>
<li><a href="../fr458792/index.html">Employés «brûlés»: y a-t-il une issue?</a></li>
<li><a href="../fr458794/index.html">Réunion des analystes d'affaires à Redmadrobot le 18 juillet</a></li>
<li><a href="../fr458796/index.html">Comment préparer votre site à de lourdes charges de travail: 5 conseils pratiques et outils utiles</a></li>
<li><a href="../fr458798/index.html">Nutrient Bot ou comment je veux prendre du pain avec des entraîneurs de fitness</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>