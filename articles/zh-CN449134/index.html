<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧚🏿 👭 👊🏾 动物园afl 🔐 ⚛️ 💎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在本文中，我们将不谈论经典的AFL本身，而是谈论为其设计的实用程序及其修改，我们认为这可以显着提高模糊测试的质量。 如果您想知道如何提高AFL以及如何更快地找到更多漏洞，请继续阅读！ 

 什么是AFL，这有什么好处？ 
 AFL是覆盖率导向或基于反馈的模糊器。 有关这些概念的更多信息，请参见“ F...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>动物园afl</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/449134/"><img src="https://habrastorage.org/webt/l4/vc/qr/l4vcqrdnz0vgsseyssmztrfrvdg.jpeg" alt="图片"><br><br> 在本文中，我们将不谈论经典的AFL本身，而是谈论为其设计的实用程序及其修改，我们认为这可以显着提高模糊测试的质量。 如果您想知道如何提高AFL以及如何更快地找到更多漏洞，请继续阅读！ <br><a name="habracut"></a><br><h1> 什么是AFL，这有什么好处？ </h1><br>  AFL是覆盖率导向或基于反馈的模糊器。 有关这些概念的更多信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ Fuzzing：艺术，科学和工程”一文</a> 。 让我们总结一下有关AFL的一般信息： <br><br><ul><li> 它修改可执行文件以了解它如何影响覆盖范围。 </li><li> 突变输入数据以最大化覆盖范围。 </li><li> 重复上一步，查找程序崩溃的位置。 <ul><li> 它非常有效，实践证明。 <ul><li> 它很容易使用。 </li></ul></li></ul></li></ul><br><br> 这是一个图形表示： <br><br><img src="https://habrastorage.org/webt/iq/5z/au/iq5zaub6qftefx3x_q5te6d6guo.png" alt="图片"><br><br> 如果您不知道什么是AFL，以下是一些有用的资源供您入门： <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">该项目的官方页面</a> 。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AFL培训-AFL</a>的简短介绍。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">afl-demo</a> -AFL模糊C ++程序的简单演示。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">afl-cve</a> -AFL发现的漏洞的集合（自2017年以来未更新）。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里，</a>您可以了解AFL在其构建过程中添加到程序中的内容。 </li><li> 有关使网络应用程序模糊化的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一些</a>有用技巧。 </li></ol><br> 在撰写本文时，AFL的最新版本是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.52b</a> 。 模糊测试器正在积极开发中，随着时间的推移，一些侧向开发已被并入AFL的主要分支中，并且变得无关紧要。 今天，我们可以命名几个有用的附件工具，这些工具将在下一章中列出。 <br><br><div class="spoiler">  <b class="spoiler_title">Rode0day比赛</b> <div class="spoiler_text"> 还值得一提的是每月<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">举行的Rode0day</a>竞赛-这是一个事件，在这种情况下，无论是否有源代码访问，模糊测试者都试图在预制语料库中以比对手少的时间找到最多数量的bug。 从本质上讲，Rode0day是AFL的不同修改与分支之间的一场战斗。 <br></div></div><br> 一些AFL用户<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">指出</a> ，自从上次修改日期至2017年11月5日以来，其作者Michal Zalewski显然已放弃了该项目。这可能与他离开Goog​​le并从事一些新项目有关。 因此，用户开始为最新的当前版本2.52b制作新的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">补丁程序</a> 。 <br><br><img src="https://habrastorage.org/webt/fy/00/xa/fy00xat3cumh3iq9a5biou30czi.png" alt="图片"><br><br>  AFL也有不同的变体和派生版本，它允许模糊化Python，Go，Rust，OCaml，GCJ Java，内核syscall甚至整个VM。 <br><br><div class="spoiler">  <b class="spoiler_title">其他编程语言的AFL</b> <div class="spoiler_text"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-python-afl-</a>适用于Python。 <br>  <a href="">-afl.rs-</a>用于模糊编写在Rust上的程序。 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-afl-fuzz-js</a> -JavaScript的afl-fuzz。 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-java-afl</a> -Java的AFL模糊测试。 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-kelinci</a> -Java的另一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">模糊</a>器（有关该主题的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a> ）。 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-javan-warty-pig</a> -JVM的类似于AFL的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">模糊器</a> 。 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-afl-swift-</a>用于模糊处理以swift编写的程序。 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-ocamlopt-afl-</a>适用于OCaml。 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-SharpFuzz-</a>基于.NET的afl的Fuzzer。 <br></div></div><br><h1> 辅助工具 </h1><br> 在本章中，我们收集了用于AFL的各种脚本和工具，并将它们分为几类： <br><br>  <u>崩溃处理</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">afl-utils-</a>一组实用程序，用于自动处理/分析崩溃并减少测试用例的数量。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">afl-crash-analyzer</a> -AFL的另一个崩溃分析器。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">fuzzer-utils-</a>一组用于分析结果的脚本。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">atriage-</a>一个简单的分类工具。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">afl-kit</a> -Python上的afl-cmin。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AFLize-</a>一种自动生成适用于AFL的debian软件包构建的工具。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">afl-fid-</a>一组用于处理输入数据的工具。 </li></ul><br>  <u>处理代码覆盖率</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">afl-cov-</a>提供有关覆盖率的人性化数据。 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">计数呼叫</a> -比率评估。 脚本计算二进制文件中检测块的数量。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">afl-sancov-</a>与afl-cov相似，但使用了叮当消毒剂。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">covnavi-</a>一个脚本，用于覆盖Cisco Talos Group的代码和分析。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">LAF LLVM通行证</a> -类似于AFL补丁程序的集合，它们修改了代码以使模糊测试者更容易找到分支。 </li></ul><br>  <u>一些用于最小化测试用例的脚本</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">afl-pytmin</a> -afl-tmin的包装器，它试图通过使用许多CPU内核来加快最小化测试用例的过程。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">afl-ddmin-</a> mod-基于ddmin算法的afl-tmin的变体。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">halfempty-</a>是Tavis Ormandy基于并行化的用于最小化测试用例的快速实用程序。 </li></ul><br>  <u>分布式执行</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">disfuzz-afl</a> -AFL的分布式模糊测试。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AFLDFF</a> -AFL分布式模糊测试框架。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">afl-launch-</a>执行许多AFL实例的工具。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">afl-mothership-</a>在AWS云上管理和执行许多同步的AFL模糊器。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">afl-in-the-cloud-</a>用于在AWS中运行AFL的另一个脚本。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VU_BSc_project-</a>使用libFuzzer和AFL对开源库进行模糊测试。 </li></ul><br> 最近，发表了一篇很好的文章，标题为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“将AFL扩展到256线程计算机”</a> 。 <br><br>  <u>部署，管理，监控，报告</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">afl-other-arch-</a>是一组补丁程序和脚本，用于轻松添加对AFL的各种非x86架构的支持。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">afl-trivia-</a>一些简化AFL管理的小脚本。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">afl-monitor-</a>监视AFL的脚本。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">afl-manager</a> -Python上的Web服务器，用于管理多afl。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">afl-tools-</a>具有afl-latest，afl-dyninst和Triforce-afl的码头工人的图像。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">afl-remote-</a>用于远程管理AFL实例的Web服务器。 </li></ul><br><h1>  AFL修改 </h1><br>  AFL对脆弱性研究人员的社区及其模糊性产生了非常强烈的影响。 一段时间之后，人们开始根据原始AFL进行修改，这一点也就不足为奇了。 让我们看看它们。 在不同情况下，与原始AFL相比，这些修改中的每一种都有其优点和缺点。 <br><br> 几乎所有mod都可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">hub.docker.com</a>上找到 <br><br> 干嘛 <br><br><ul><li> 提高速度和/或代码覆盖率 <br><ul><li> 演算法 </li><li> 环境环境 <br><ul><li> 操作系统 </li><li> 硬体 </li></ul></li></ul><br></li><li> 无需源代码即可工作 <br><ul><li> 代码仿真 </li><li> 代码检测 <br><ul><li> 静态的 </li><li> 动态的 </li></ul></li></ul></li></ul><br>  <u>AFL操作的默认模式</u> <br><br> 在继续研究AFL的不同修改和分支之前，我们必须谈论两种重要的模式，它们在过去也曾是修改，但最终被合并。 他们是Syzygy和Qemu。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Syzygy</a>模式-是在instrument.exe中工作的模式 <pre><code class="bash hljs">instrument.exe --mode=afl --input-image=test.exe --output-image=test.instr.exe</code> </pre>  Syzygy允许使用AFL静态重写PE32二进制文件，但需要符号和其他开发才能使WinAFL内核能够识别。 <br><br>  Qemu模式-它在QEMU下的工作方式可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ AFL模糊器的内部-QEMU Instrumentation”中</a>看到。 在版本1.31b中向上游AFL添加了使用QEMU处理二进制文件的支持。  AFL QEMU模式与qemu tcg（微型代码生成器）二进制翻译引擎中添加的二进制检测功能一起使用。 为此，AFL具有一个构建脚本qemu，该脚本可提取某个版本的qemu（2.10.0）的源，将它们放到几个小的补丁中，并为定义的体系结构构建。 然后，创建了一个名为afl-qemu-trace的文件，该文件实际上是qemu-的用户模式仿真文件（仅仿真可执行ELF文件）。 因此，对于qemu支持的许多不同体系结构，可以将模糊与对elf二进制文件的反馈一起使用。 另外，您还可以获得所有很棒的AFL工具，从带有有关当前会话的信息的监视器到诸如afl-analyze之类的高级内容。 但是您也得到qemu的限制。 同样，如果使用硬件SoC功能通过工具链构建文件，该文件会启动二进制文件，而qemu不支持该文件，则一旦有特定指令或使用特定MMIO，模糊处理就会被中断。 <br><br> 这是qemu模式的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">另一个有趣的分支</a> ，其中通过TCG代码检测和兑现将速度提高了3-4倍。 <br><br>  <u>前叉</u> <br><br>  AFL的前叉的出现首先与经典AFL的算法的更改和改进有关。 <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pe-afl-</a>一种用于模糊处理Windows OS中没有源代码的PE文件的修改。 为了进行操作，模糊器使用IDA Pro分析目标程序，并为以下静态仪器生成信息。 然后使用AFL对已检测版本进行模糊处理。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">afl-cygwin-</a>试图通过Cygwin将经典的AFL移植到Windows。 不幸的是，它有很多错误，非常慢，并且已经放弃了它的开发。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AFLFast</a> （用功率计划表扩展AFL）-最早的AFL分支之一。 它增加了启发式方法，使它可以在短时间内通过更多路径。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FairFuzz</a> -AFL的扩展，针对稀有分支。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AFLGo-</a>是AFL的扩展，旨在获取代码的某些部分而不是完整的程序覆盖范围。 它可以用于测试补丁或新添加的代码片段。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PerfFuzz</a> -AFL的扩展，用于查找可能会严重降低程序速度的测试用例。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Pythia-</a>是AFL的扩展，旨在预测发现新路径的难度。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">安哥拉猫</a> -是最新的模糊测试工具之一，写在生锈。 它使用新策略进行突变并增加覆盖范围。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Neuzz-</a>用神经网络模糊。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">UnTracer-AFL-</a>将AFl与UnTracer集成以进行有效跟踪。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Qsym-</a>专为混合模糊测试而设计的实用Concolic执行引擎。 本质上，它是一个符号执行引擎（基本组件实现为intel引脚的插件），与AFL一起执行混合模糊测试。 这是基于反馈的模糊测试发展的一个阶段，需要进行单独的讨论。 它的主要优点是可以相对较快地执行Condicate执行。 这是由于命令的本机执行而没有代码，快照和某些启发式的中间表示。 它使用旧的Intel引脚（由于支持libz3和其他DBT之间的问题），目前可以与elf x86和x86_64体系结构一起使用。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Superion</a> -Greybox模糊测试器的一个明显优势是，它与仪器化程序一起，也可以使用ANTLR语法获取输入数据的规范，然后在此语法的帮助下执行变异。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AFLSmart-</a>另一个Graybox模糊测试器。 作为输入，它以桃子模糊器使用的格式获取输入数据的规范。 </li></ul><br> 有许多研究论文致力于对AFL进行修改的新方法和模糊技术的实施。 只有白皮书可用，因此我们甚至都没有提到这些白皮书。 您可以根据需要搜索它们。 例如，最新的一些是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CollAFL：Path Sensitive Fuzzing</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">EnFuzz</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“用于模糊解释器的有效方法”</a> ，AFL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ML</a> 。 <br><br>  <u>基于Qemu的修改</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TriforceAFL</a> -AFL / QEMU模糊化，具有完整的系统仿真功能。  nccgroup的一个fork。 允许在qemu模式下模糊整个操作系统。 它是通过在QEMU x64 CPU中添加的特殊指令（aflCall（0f 24））实现的。 不幸的是，它不再受支持。  AFL的最新版本是2.06b。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TriforceLinuxSyscallFuzzer</a> -Linux系统调用的模糊处理。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">afl-qai</a> -QEMU增强仪器（qai）的小型演示项目。 </li></ul><br>  <u>基于KLEE的修改</u> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">kleefl-</a>用于通过符号执行生成测试用例（在大型程序上非常慢）。 <br><br>  <u>基于独角兽的修改</u> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">afl-unicorn-</a>通过在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Unicorn Engine</a>上进行仿真来模糊代码片段。 我们在实践中成功地在某个RTOS的代码区域中使用了AFL的这种变体，该区域在SOC上执行，因此我们不能使用QEMU模式。 如果我们没有源（我们无法构建用于分析器的独立二进制文件）并且程序没有直接获取输入数据（例如，数据），则使用此修改是合理的加密或像CGC二进制文件中那样是信号样本），然后我们可以反转并找到假定的places-functions，其中以对fuzzer方便的格式处理数据。 这是AFL的最通用/通用的修改形式，即，它允许对任何内容进行模糊测试。 它独立于体系结构，源，输入数据格式和二进制格式（最显着的裸机示例-只是控制器内存中的代码片段）。 研究人员首先检查此二进制文件，然后编写一个模糊器，以模拟解析器过程输入时的状态。 显然，与AFL不同，这需要对二进制文件进行一定的检查。 对于Wi-FI或基带之类的裸机固件，需要牢记某些缺点： <br><br><ol><li> 我们必须本地化控制和的检查。 </li><li> 请记住，模糊器的状态是保存在内存转储中的内存状态，这可能会阻止模糊器到达某些路径。 </li><li> 没有动态调用动态内存，但是可以手动实现，这取决于RTOS（有待研究）。 </li><li> 不模拟任务间RTOS交互，这也可能阻止找到某些路径。 </li></ol><br> 使用此修改的示例<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ afl-unicorn：模糊任意二进制代码”</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ afl-unicorn：第2部分-模糊'Unfuzzable'”</a> 。 <br><br> 在继续进行基于动态二进制工具（DBI）框架的修改之前，请不要忘记DynamoRIO，Dynlnst和PIN最终显示了这些框架的最高速度。 <br><br>  <u>基于PIN的修改</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">aflpin-</a>具有Intel PIN工具的AFL。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">afl_pin_mode-</a>通过Intel PIN实现的另一个AFL仪器。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">afl-</a> pin-带有PINtool的AFL。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NaFl</a> -AFL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">模糊器的</a> （基本核心）克隆。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PinAFL-</a>该工具的作者试图将AFL移植到Windows，以模糊已编译的二进制文件。 好像是为了娱乐而过夜。 该项目再也没有做过。 该存储库没有源，只有编译的二进制文件和启动指令。 我们不知道它基于哪个版本的AFL，它仅支持32位应用程序。 </li></ul><br> 如您所见，有许多不同的修改，但是它们在现实生活中不是很有用。 <br><br>  <u>基于Dyninst的修改</u> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">afl-dyninst-</a>美国模糊Lop + Dyninst == AFL balckbox模糊测试。 这个版本的特点是，首先使用Duninst对研究的程序（不带源代码）进行静态检测（静态二进制检测，静态二进制重写），然后对经典的AFL感到困惑，认为该程序是使用afl-构建的结果是，它允许在没有源代码的情况下以非常好的生产率工作-与本地编译相比，以前的速度是0.25倍。 与QEMU相比，它具有显着的优势：它允许检测动态链接库，而QEMU仅可以检测与库静态链接的基本可执行文件。 不幸的是，现在它仅与Linux有关。 为了获得Windows支持，需要对Dyninst本身进行更改，此操作<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">已完成</a> 。 <br><br> 还有另一个改进了速度和某些功能（支持AARCH64和PPC体系结构）的分支。 <br><br>  <u>基于DynamoRIO的修改</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">drAFL</a> -AFl + DynamoRIO-在Linux上无来源时进行模糊测试。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">afl-</a> dr-基于DynamoRIO的另一种实现，在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Habr</a>上有很好的描述。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">afl-dynamorio</a> -vanhauser-thc的修改形式。 他是这样说的：“当普通的afl-dyninst使二进制文件崩溃且qemu模式-Q不可行时，请使用DynamoRIO运行AFL。” 它支持ARM和AARCH64。 关于生产率：DynamoRIO比Qemu慢10倍，比dyninst慢25倍，但比Pintool快10倍。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WinAFL-</a>最著名的AFL前叉Windows。  （DynamoRIO，也是syzygy模式）。 这个mod的出现只是时间问题，因为许多人想在Windows上尝试AFL并将其应用于没有资源的应用中。 目前，该工具正在积极改进，无论AFL的代码库相对过时（撰写本文时为2.43b），它都有助于发现一些漏洞（CVE-2016-7212，CVE-2017-0073，CVE- 2017年1月90日，CVE-2017-11816）。  Google零项目团队和MSRC漏洞与缓解小组的专家正在从事此项目，因此我们可以希望进一步发展。 开发人员没有使用编译时工具，而是使用了动态工具（基于DynamoRIO），这大大减慢了所分析软件的执行速度，但是所产生的开销（增加了一倍）与二进制模式下的经典AFL相当。 他们还称其为持续模糊模式，从而解决了进程快速启动的问题。 他们选择要模糊化的函数（通过文件中的偏移量或导出表中存在的函数的名称）并进行检测，以便可以在循环中调用它，从而在不重新启动过程的情况下启动了多个输入数据样本。 最近<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">发表</a>了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一篇文章</a> ，描述了作者如何使用WinAFL在大约50天内发现了大约50个漏洞。 而且在发布之前不久，Intel PT模式已被添加到WinAFL中。 详细资料可以在<a href="">这里</a>找到。 </li></ul><br> 高级读者可能会注意到，除了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Frida</a>之外，所有流行的检测框架都进行了修改。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ Chizpurfle：用于供应商服务定制的灰色盒子Android Fuzzer</a>中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">”</a>找到了将Frida与AFL一起使用的唯一提及。 带有Frida的AFL版本非常有用，因为Frida支持多种RISC体系结构。 <br><br> 许多研究人员还期待Capstone，Unicorn和Keystone的创建者发布DBI Scopio框架。 基于此框架，作者已经创建了一个模糊器（Darko），并据此成功地将其用于模糊嵌入式设备。 有关更多信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“深入挖掘：使用代码覆盖率引导的模糊测试在嵌入式系统中查找0days”。</a> <br><br>  <u>根据处理器硬件功能进行修改</u> <br><br> 在支持处理器硬件功能的情况下进行AFL修改时，首先，它可以对内核代码进行模糊处理，其次，它可以在没有源代码的情况下对应用进行快速模糊处理。 <br><br> 当然，谈到处理器的硬件功能，我们最感兴趣的是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">英特尔PT</a> （处理器跟踪）。 从第六代处理器开始可用（大约从2015年开始）。 因此，为了能够使用下面列出的模糊器，您需要支持Intel PT的处理器。 <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WinAFL-IntelPT-</a>使用Intel PT而不是DynamoRIO的第三方WinAFL修改。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">kAFL-</a>是一个学术项目，旨在解决与操作系统无关的内核模糊的覆盖率指导问题。 问题是通过使用管理程序和Intel PT解决。 可以在白皮书<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ kAFL：OS内核的硬件辅助反馈模糊测试”中</a>找到更多信息。 </li></ul><br><h1> 结论 </h1><br> 如您所见，AFL修改领域正在积极发展。 尽管如此，仍有实验和创新解决方案的空间。 您可以创建一个有用且有趣的新修改。 <br><br> 感谢您阅读我们，祝您万事如意！ <br><br>  <b>合著者：</b> Nikita Knyzhov <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">presler</a> <br><br>  <i>PS感谢研究中心团队，没有他们，本文将是不可能的。</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN449134/">https://habr.com/ru/post/zh-CN449134/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN449120/index.html">留着胡子，戴着墨镜和外形：计算机视觉的困难情况</a></li>
<li><a href="../zh-CN449122/index.html">遗憾的是，在C ++中缺少一个成熟的static if或...</a></li>
<li><a href="../zh-CN449124/index.html">如此难以找到，容易错过且不可能发行</a></li>
<li><a href="../zh-CN449128/index.html">世界顶级游戏开发公司</a></li>
<li><a href="../zh-CN449132/index.html">适用于Android Studio的17个顶级插件</a></li>
<li><a href="../zh-CN449138/index.html">加密帽的5个理由 为什么IT人员不喜欢比特币</a></li>
<li><a href="../zh-CN449140/index.html">提出要求，我们将在1分钟内在线答复您。 还是我们如何远离OTRS</a></li>
<li><a href="../zh-CN449142/index.html">微生物群。 俄罗斯人的肠子里生活着什么细菌</a></li>
<li><a href="../zh-CN449144/index.html">JavaScript引擎基础知识：原型优化。 第二部分</a></li>
<li><a href="../zh-CN449146/index.html">但是我们不向光通信挥手吗？ 激光，太空，CubeSat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>