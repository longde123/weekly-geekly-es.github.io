<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👷🏻 🔮 📞 Kotlin DSL, Jadwal dan tes UI yang elegan di Android 🏂 🌓 🛩️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ketika saya bertemu Kotlin DSL, saya berpikir: hal yang hebat, sangat disayangkan dalam pengembangan produk ini tidak akan berguna. Namun, saya salah:...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kotlin DSL, Jadwal dan tes UI yang elegan di Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hh/blog/455042/"><p>  Ketika saya bertemu Kotlin DSL, saya berpikir: hal yang hebat, sangat disayangkan dalam pengembangan produk ini tidak akan berguna.  Namun, saya salah: dia membantu kami membuat cara yang sangat ringkas dan elegan untuk menulis tes UI End-to-end di Android. </p><br><p><img src="https://habrastorage.org/webt/sh/f7/ej/shf7ejqt1wouqjj5vjej-vwbnzi.jpeg" alt="gambar"></p><a name="habracut"></a><br><h1 id="pro-servis-testovye-dannye-i-pochemu-vse-ne-tak-prosto">  Tentang layanan, data uji, dan mengapa tidak sesederhana itu </h1><br><p>  Untuk mulai dengan, sedikit konteks tentang layanan kami, sehingga Anda mengerti mengapa kami membuat keputusan tertentu. </p><br><p>  Kami membantu pencari kerja dan pengusaha untuk saling menemukan: </p><br><ul><li>  majikan mendaftarkan perusahaan mereka dan memposting lowongan </li><li>  pencari kerja mencari pekerjaan, menambahkannya ke favorit, berlangganan hasil pencarian, membuat resume dan mengirim umpan balik </li></ul><br><p>  Untuk mensimulasikan skenario pengguna nyata dan memastikan bahwa aplikasi bekerja dengan benar pada mereka, kita perlu membuat semua data pengujian ini di server.  Anda akan mengatakan: "Jadi buat majikan ujian dan pencari kerja terlebih dahulu, dan kemudian bekerja sama dengan mereka dalam ujian."  Tetapi ada beberapa masalah: </p><br><ol><li>  selama pengujian kami mengubah data; </li><li>  tes berjalan secara paralel. </li></ol><br><h1 id="testovoe-okruzhenie-i-fikstury">  Lingkungan dan perlengkapan uji </h1><br><p>  Tes ujung ke ujung dijalankan di bangku tes.  Mereka hampir memiliki lingkungan militer, tetapi tidak ada data nyata.  Dalam hal ini, ketika menambahkan data baru, pengindeksan terjadi hampir secara instan. </p><br><p>  Untuk menambahkan data ke dudukan, kami menggunakan metode fixture khusus.  Mereka menambahkan data langsung ke database dan langsung mengindeksnya: </p><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestFixtureUserApi</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@POST(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"fx/employer/create"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createEmployerUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@Body</span></span></span></span><span class="hljs-function"><span class="hljs-params"> employer: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TestEmployer</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Call&lt;TestEmployer&gt; }</code> </pre> <br><p>  Fixture hanya tersedia dari jaringan lokal dan hanya untuk test stand.  Metode dipanggil dari tes segera sebelum memulai Kegiatan mulai. </p><br><h1 id="dsl">  DSL </h1><br><p>  Jadi kami sampai ke juiciest.  Bagaimana set data untuk pengujian? </p><br><pre> <code class="kotlin hljs">initialisation{ applicant { resume { title = <span class="hljs-string"><span class="hljs-string">"Resume for similar Vacancy"</span></span> isOptional = <span class="hljs-literal"><span class="hljs-literal">true</span></span> resumeStatus = ResumeStatus.APPROVED } resume { title = <span class="hljs-string"><span class="hljs-string">"Some other Resume"</span></span> } } employer { vacancy { title = <span class="hljs-string"><span class="hljs-string">"Resume for similar Vacancy"</span></span> } vacancy { title = <span class="hljs-string"><span class="hljs-string">"Resume for similar Vacancy"</span></span> description = <span class="hljs-string"><span class="hljs-string">"Working hard"</span></span> } vacancy { title = <span class="hljs-string"><span class="hljs-string">"Resume for similar Vacancy"</span></span> description = <span class="hljs-string"><span class="hljs-string">"Working very hard"</span></span> } } }</code> </pre> <br><p>  Di blok inisialisasi, kami memulai entitas yang diperlukan untuk pengujian: dalam contoh di atas, kami membuat satu pelamar dengan dua resume, serta satu majikan yang menyediakan beberapa lowongan. </p><br><p>  Untuk menghilangkan kesalahan yang terkait dengan persimpangan data pengujian, kami membuat pengidentifikasi unik untuk pengujian dan untuk setiap entitas. </p><br><p>  <strong>Hubungan antar Entitas</strong> </p><br><p>  Apa batasan utama ketika bekerja dengan DSL?  Karena struktur pohonnya, agak sulit untuk membangun koneksi antara cabang-cabang pohon yang berbeda. </p><br><p>  Misalnya, dalam aplikasi kami untuk pelamar ada bagian "Lowongan yang cocok untuk resume".  Agar lowongan muncul di daftar ini, kita perlu mengaturnya sedemikian rupa sehingga terkait dengan resume pengguna saat ini. </p><br><pre> <code class="kotlin hljs">initialisation { applicant { resume { title = <span class="hljs-string"><span class="hljs-string">"TEST_VACANCY_</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$uniqueTestId</span></span></span><span class="hljs-string">"</span></span> } } employer { vacancy { title = <span class="hljs-string"><span class="hljs-string">"TEST_VACANCY_</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$uniqueTestId</span></span></span><span class="hljs-string">"</span></span> } } }</code> </pre> <br><p>  Pengidentifikasi tes unik digunakan untuk ini.  Jadi, ketika bekerja dengan aplikasi, lowongan yang ditentukan direkomendasikan untuk resume ini.  Selain itu, penting untuk dicatat bahwa tidak ada lowongan lain akan muncul di daftar ini. </p><br><p>  <strong>Inisialisasi data dengan tipe yang sama</strong> </p><br><p>  Tetapi bagaimana jika Anda perlu membuat banyak lowongan?  Apakah setiap blok jadi salinan?  Tentu tidak!  Kami membuat metode dengan blok lowongan, yang menunjukkan jumlah lowongan yang diperlukan dan transformator untuk mendiversifikasi mereka tergantung pada pengidentifikasi unik. </p><br><pre> <code class="kotlin hljs">initialisation { employer { vacancyBlock { size = <span class="hljs-number"><span class="hljs-number">10</span></span> transformer = { it.also { vacancyDsl -&gt; vacancyDsl.description = <span class="hljs-string"><span class="hljs-string">"Some description with text </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${vacancyDsl.uniqueVacancyId}</span></span></span><span class="hljs-string">"</span></span> } } } } }</code> </pre> <br><p>  Di blok lowongan, kami menunjukkan berapa banyak klon lowongan yang perlu kami buat dan cara mengubahnya tergantung pada nomor seri. </p><br><p>  <strong>Bekerja dengan data dalam tes</strong> </p><br><p>  Selama tes, bekerja dengan data menjadi sangat sederhana.  Semua data yang kami buat tersedia untuk kami.  Dalam implementasi kami, mereka disimpan dalam pembungkus khusus untuk koleksi.  Data dapat diperoleh dari mereka berdua dengan nomor pesanan pekerjaan (lowongan [0]), jadi dengan tag yang dapat diatur dalam dsl (lowongan ["lowongan saya"]), dan dengan pintasan (vacancies.first () </p><br><div class="spoiler">  <b class="spoiler_title">TaggedItemContainer</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TaggedItemContainer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt;</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> items: MutableList&lt;TaggedItem&lt;T&gt;&gt; ) { <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(index: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: T { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items[index].<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tag: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: T { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items.first { it.tag == tag }.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plusAssign</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(item: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TaggedItem</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { items += item } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> items) action.invoke(item.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">first</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: T { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items[<span class="hljs-number"><span class="hljs-number">0</span></span>].<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">second</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: T { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items[<span class="hljs-number"><span class="hljs-number">1</span></span>].<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">third</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: T { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items[<span class="hljs-number"><span class="hljs-number">2</span></span>].<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">last</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: T { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items[items.size - <span class="hljs-number"><span class="hljs-number">1</span></span>].<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> } }</code> </pre> </div></div><br><p>  Dalam hampir 100% kasus, saat menulis tes, kami menggunakan metode pertama () dan kedua (), sisanya disimpan untuk fleksibilitas.  Di bawah ini adalah contoh dari tes dengan inisialisasi dan langkah-langkah pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kakao</a> </p><br><pre> <code class="kotlin hljs">initialisation { applicant { resume { title = <span class="hljs-string"><span class="hljs-string">"TEST_VACANCY_</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$uniqueTestId</span></span></span><span class="hljs-string">"</span></span> } } }.run { mainScreen { positionField { click() } jobPositionScreen { positionEntry(vacancies.first().title) } searchButton { click() } } }</code> </pre> <br><p>  <strong>Apa yang tidak cocok di DSL</strong> </p><br><p>  Bisakah semua data masuk ke dalam DSL?  Tujuan kami adalah menjaga DSL sesingkat dan sesederhana mungkin.  Dalam implementasi kami, karena fakta bahwa urutan pekerjaan pelamar dan pengusaha tidak penting, tidak mungkin untuk mencocokkan hubungan mereka - tanggapan. <br>  Pembuatan respons sudah dilakukan di blok berikutnya oleh operasi pada entitas yang sudah dibuat di server. </p><br><h1 id="realizaciya-dsl">  Implementasi DSL </h1><br><p>  Seperti yang Anda pahami dari artikel tersebut, algoritma untuk menentukan data tes dan melakukan tes adalah sebagai berikut: </p><br><ul><li>  Bagian dari DSL diurai dalam inisialisasi; </li><li>  Berdasarkan nilai yang diperoleh, data uji dibuat di server; </li><li>  Blok transformasi opsional dijalankan, di mana Anda dapat mengatur respons; </li><li>  Tes dilakukan dengan dataset yang sudah final. </li></ul><br><p>  <strong>Parsing data dari blok inisialisasi</strong> </p><br><p>  Sihir macam apa yang terjadi di sana?  Pertimbangkan bagaimana elemen TestCaseDsl tingkat atas dibangun: </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@TestCaseDslMarker</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCaseDsl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> applicants = mutableListOf&lt;ApplicantDsl&gt;() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> employers = mutableListOf&lt;EmployerDsl&gt;() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> uniqueTestId = CommonUtils.unique <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applicant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ApplicantDsl</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> = {}) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> applicantDsl = ApplicantDsl( uniqueTestId, uniqueApplicantId = CommonUtils.unique applicantDsl.block() applicants += applicantDsl } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">employer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EmployerDsl</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> = {}) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> employerDsl = EmployerDsl( uniqueTestId = uniqueTestId, uniqueEmployerId = CommonUtils.unique employerDsl.block() employers += employerDsl } }</code> </pre> <br><p>  Dalam metode pelamar, kami membuat ApplicantDsl. </p><br><div class="spoiler">  <b class="spoiler_title">ApplicantDsl</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@TestCaseDslMarker</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicantDsl</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> uniqueTestId: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> uniqueApplicantId: String, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tag: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> login: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> password: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstName: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> middleName: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastName: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> email: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> siteId: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areaId: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resumeViewLimit: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isMailingSubscription: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resumes = mutableListOf&lt;ResumeDsl&gt;() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ResumeDsl</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> = {}) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resumeDslBuilder = ResumeDsl( uniqueTestId = uniqueTestId, uniqueApplicantId = uniqueApplicantId, uniqueResumeId = CommonUtils.unique ) resumeDslBuilder.apply(block) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.resumes += resumeDslBuilder } }</code> </pre> </div></div><br><p>  Kemudian kami melakukan operasi di atasnya dari blok blok: ApplicantDsl. () -&gt; Unit.  Desain inilah yang memungkinkan kami untuk dengan mudah beroperasi dengan bidang ApplicantDsl di DSL kami. </p><br><p>  Harap perhatikan bahwa uniqueTestId dan uniqueApplicantId (pengidentifikasi unik untuk menghubungkan entitas di antara mereka sendiri) pada saat pelaksanaan blok sudah ditetapkan dan kami dapat mengaksesnya. </p><br><p>  Blok inisialisasi secara internal memiliki struktur yang serupa: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialisation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TestCaseDsl</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): Initialisation { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCaseDsl = TestCaseDsl().apply(block) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCase = TestCaseCreator.create(testCaseDsl) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Initialisation(testCase) }</code> </pre> <br><p>  Kami membuat tes, menerapkan tindakan blokir untuk itu, lalu menggunakan TestCaseCreator untuk membuat data di server dan memasukkannya ke dalam koleksi.  Fungsi TestCaseCreator.create () cukup sederhana - kita beralih pada data dan membuatnya di server. </p><br><h1 id="podvodnye-kamni-i-idei">  Perangkap dan ide </h1><br><blockquote>  Beberapa tes sangat mirip dan hanya berbeda dalam data input dan cara mengendalikan tampilan mereka (misalnya, ketika mata uang yang berbeda ditunjukkan dalam lowongan). </blockquote><p>  Dalam kasus kami, ada beberapa tes seperti itu, dan kami memutuskan untuk tidak mengacaukan DSL dengan sintaks khusus </p><br><blockquote>  Pada hari-hari sebelum DSL, kami mengindeks data untuk waktu yang lama, dan untuk menghemat waktu kami melakukan banyak tes dalam satu kelas dan membuat semua data dalam blok statis. </blockquote><p>  Jangan lakukan ini - itu akan membuat tidak mungkin bagi Anda untuk memulai kembali tes yang jatuh.  Faktanya adalah bahwa selama peluncuran uji jatuh, kita bisa mengubah data awal di server.  Misalnya, kami dapat menambahkan lowongan ke favorit Anda.  Kemudian, ketika Anda memulai ulang tes, mengklik tanda bintang akan sebaliknya mengarah pada penghapusan lowongan dari daftar favorit, dan ini adalah perilaku yang tidak kami harapkan. </p><br><h1 id="itogi">  Ringkasan </h1><br><p>  Metode menentukan data uji sangat menyederhanakan pekerjaan dengan tes: <br>  Saat menulis tes, Anda tidak perlu memikirkan apakah ada server dan dalam urutan apa Anda perlu menginisialisasi data; <br>  Semua entitas yang dapat diatur di server dengan mudah muncul dalam petunjuk IDE; <br>  Ada satu cara untuk menginisialisasi dan berkomunikasi data satu sama lain. </p><br><p>  <strong>Materi Terkait</strong> </p><br><p>  Jika Anda tertarik pada pendekatan kami untuk pengujian UI, maka sebelum Anda mulai, saya sarankan Anda membiasakan diri dengan materi berikut: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tipe-Safe Builders</a> - dokumentasi resmi di situs web kotlinlang.org; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kotlin DSL: Teori dan Praktik</a> - laporan luar biasa dari jPoint 2018 tentang kotlin dsl dan penguraiannya; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kakao - cara membuat pengujian UI hebat lagi</a> - pengetahuan dasar tentang kerangka Kakao untuk pengujian UI; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana menghentikan rasa takut dan mulai menulis tes UI dengan Kakao</a> - laporkan Kakao dengan AppsConf 2019. Hanya slide yang tersedia sejauh ini, maka akan ada video. </li></ul><br><p>  <strong>Apa selanjutnya</strong> </p><br><p>  Artikel ini adalah yang pertama dari seri tentang alat dan kerangka kerja tingkat tinggi untuk menulis dan mendukung tes UI di Android.  Ketika bagian-bagian baru tersedia, saya akan menautkannya ke artikel ini. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455042/">https://habr.com/ru/post/id455042/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455022/index.html">Bagaimana menjalankan Scrum secara efisien pada tahun 2019? Panduan cepat untuk pemula</a></li>
<li><a href="../id455024/index.html">5 prinsip akal sehat untuk membuat aplikasi cloud-asli</a></li>
<li><a href="../id455030/index.html">Spesifikasi PHP</a></li>
<li><a href="../id455038/index.html">Tentang bagaimana Plesk mengunjungi KubeCon</a></li>
<li><a href="../id455040/index.html">Meningkatkan kerja Wi-Fi. Bagian 2. Fitur Peralatan</a></li>
<li><a href="../id455048/index.html">Implementasi teknis dari metode potensi termal untuk analisis wilayah</a></li>
<li><a href="../id455050/index.html">Menggunakan Database Oracle untuk Analisis Pasar Teknis</a></li>
<li><a href="../id455054/index.html">Bagaimana Apple (secara pribadi) menemukan offline perangkat Anda yang hilang?</a></li>
<li><a href="../id455056/index.html">Grafik primitif untuk malas, oldfags, dan oldfags malas</a></li>
<li><a href="../id455060/index.html">Homer atau opensource pertama. bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>