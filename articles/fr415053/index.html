<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🤝‍👨🏾 👩‍👧‍👦 🤦🏿 Pourquoi les processeurs Skylake fonctionnent parfois 2 fois plus lentement 💇🏽 📖 🏳️‍🌈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On m'a informé que sur les nouveaux ordinateurs, certains tests de régression devenaient plus lents. Une chose courante, ça arrive. Configuration inco...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pourquoi les processeurs Skylake fonctionnent parfois 2 fois plus lentement</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415053/">  On m'a informé que sur les nouveaux ordinateurs, certains tests de régression devenaient plus lents.  Une chose courante, ça arrive.  Configuration incorrecte quelque part dans Windows ou pas les valeurs les plus optimales dans le BIOS.  Mais cette fois, nous n'avons pas réussi à trouver le même paramètre «renversé».  Étant donné que le changement est important: 9 contre 19 secondes (sur le graphique, le bleu est l'ancien fer et l'orange est le nouveau), j'ai dû creuser plus profondément. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a9/6db/d57/4a96dbd573606b0a0aabc6a0874dd2fa.png"><br><a name="habracut"></a><br><h1>  Même système d'exploitation, même matériel, processeur différent: 2 fois plus lent </h1><br>  La baisse des performances de 9,1 à 19,6 secondes peut certainement être qualifiée de significative.  Nous avons effectué des vérifications supplémentaires avec un changement dans les versions des programmes testés, des paramètres Windows et BIOS.  Mais non, le résultat n'a pas changé.  La seule différence n'apparaissait que sur différents processeurs.  Voici le résultat sur le dernier CPU. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6a2/fc8/12e/6a2fc812e9f12ae4581b9ed3fd46c4b7.png"><br><br>  Et voici celui qui est utilisé pour la comparaison. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e81/f8b/d4f/e81f8bd4f20ffe609673ef3db6dd414d.png"><br><br>  Xeon Gold fonctionne sur une architecture différente appelée Skylake, commune aux nouveaux processeurs Intel depuis la mi-2017.  Si vous achetez le dernier matériel, vous obtiendrez un processeur avec l'architecture Skylake.  Ce sont de bonnes voitures, mais, comme les tests l'ont montré, la nouveauté et la vitesse ne sont pas la même chose. <br><br>  Si rien d'autre ne vous aide, vous devez utiliser le profileur pour des recherches approfondies.  Essayons sur des équipements anciens et nouveaux et obtenons quelque chose comme ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3b3/6a3/98e/3b36a398e5ee9ce0950c1d940f3de9c7.png"><br><br>  L'onglet dans Windows Performance Analyzer (WPA) indique dans le tableau la différence entre la trace 2 (11 s) et la trace 1 (19 s).  Une différence négative dans le tableau correspond à une augmentation de la consommation de CPU dans un test plus lent.  Si vous regardez les différences les plus importantes dans la consommation de CPU, nous verrons <i>AwareLock :: Contention</i> , <i>JIT_MonEnterWorker_InlineGetThread_GetThread_PatchLabel</i> et <i>ThreadNative.SpinWait</i> .  Tout indique une «rotation» dans le CPU [rotation - une tentative cyclique pour obtenir un verrou, env.  par.], lorsque les threads se battent pour le blocage.  Mais c'est une fausse marque, car la filature n'est pas la principale raison de la baisse de productivité.  La concurrence accrue pour les verrous signifie que quelque chose dans notre logiciel a ralenti et conservé le verrou, ce qui a entraîné une augmentation de la rotation du processeur.  J'ai vérifié le temps de verrouillage et d'autres indicateurs clés, tels que les performances du disque, mais je n'ai rien trouvé de significatif qui pourrait expliquer la dégradation des performances.  Bien que ce ne soit pas logique, mais je suis revenu à augmenter la charge sur le processeur de différentes manières. <br><br>  Il serait intéressant de trouver exactement où le processeur est bloqué.  WPA a des colonnes de fichier # et de ligne #, mais elles ne fonctionnent qu'avec des caractères privés, ce que nous n'avons pas, car il s'agit du code .NET Framework.  La prochaine meilleure chose que nous pouvons faire est d'obtenir l'adresse dll où se trouve l'instruction appelée Image RVA.  Si vous chargez cette dll dans le débogueur et faites <br><br> <code>u xxx.dll+ImageRVA</code> <br> <br>  alors nous devrions voir l'instruction qui brûle la plupart des cycles de CPU, car ce sera la seule adresse "chaude". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9fe/54e/e7b/9fe54ee7bfe194a0e6fec932148f730c.png"><br><br>  Nous examinerons cette adresse en utilisant différentes méthodes Windbg: <br><br> <code>0:000&gt; u clr.dll+0x19566B-10 <br> clr!AwareLock::Contention+0x135: <br> 00007ff8`0535565b f00f4cc6 lock cmovl eax,esi <br> 00007ff8`0535565f 2bf0 sub esi,eax <br> 00007ff8`05355661 eb01 jmp clr!AwareLock::Contention+0x13f (00007ff8`05355664) <br> 00007ff8`05355663 cc int 3 <br> 00007ff8`05355664 83e801 sub eax,1 <br> 00007ff8`05355667 7405 je clr!AwareLock::Contention+0x144 (00007ff8`0535566e) <br> 00007ff8`05355669 f390 pause <br> 00007ff8`0535566b ebf7 jmp clr!AwareLock::Contention+0x13f (00007ff8`05355664)</code> <br> <br>  Et avec différentes méthodes JIT: <br><br> <code>0:000&gt; u clr.dll+0x2801-10 <br> clr!JIT_MonEnterWorker_InlineGetThread_GetThread_PatchLabel+0x124: <br> 00007ff8`051c27f1 5e pop rsi <br> 00007ff8`051c27f2 c3 ret <br> 00007ff8`051c27f3 833d0679930001 cmp dword ptr [clr!g_SystemInfo+0x20 (00007ff8`05afa100)],1 <br> 00007ff8`051c27fa 7e1b jle clr!JIT_MonEnterWorker_InlineGetThread_GetThread_PatchLabel+0x14a (00007ff8`051c2817) <br> 00007ff8`051c27fc 418bc2 mov eax,r10d <br> 00007ff8`051c27ff f390 pause <br> 00007ff8`051c2801 83e801 sub eax,1 <br> 00007ff8`051c2804 75f9 jne clr!JIT_MonEnterWorker_InlineGetThread_GetThread_PatchLabel+0x132 (00007ff8`051c27ff)</code> <br> <br>  Nous avons maintenant un modèle.  Dans un cas, l'adresse chaude est une instruction de saut, et dans l'autre cas, c'est une soustraction.  Mais les deux instructions chaudes sont précédées de la même instruction de pause générale.  Différentes méthodes exécutent la même instruction de processeur, ce qui, pour une raison quelconque, prend beaucoup de temps.  Mesurons la vitesse d'exécution de l'instruction pause et voyons si nous raisonnons correctement. <br><br><h1>  Si le problème est documenté, il devient alors une fonctionnalité. </h1><br><table cellpadding="2" width="400" border="1"><tbody><tr><td width="224">  <strong>CPU</strong> </td><td width="176">  <strong>pause en nanosecondes</strong> </td></tr><tr><td width="224">  Xeon E5 1620v3 3,5 GHz </td><td width="176">  4 </td></tr><tr><td width="224">  Xeon® Gold 6126 à 2,60 GHz </td><td width="176">  43 </td></tr></tbody></table><br>  La pause dans les nouveaux processeurs Skylake prend un ordre de grandeur plus long.  Bien sûr, tout peut devenir plus rapide et parfois un peu plus lent.  Mais <b>dix fois</b> plus lentement?  Cela ressemble plus à un bug.  Une petite recherche sur Internet sur les instructions de pause mène au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">manuel</a> d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Intel</a> , qui mentionne explicitement la microarchitecture Skylake et les instructions de pause: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8ca/c9f/30c/8cac9f30cd834d8c47eeab6297dda445.png"><br><br>  Non, ce n'est pas une erreur, c'est une fonction documentée.  Il y a même une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">page</a> indiquant le temps d'exécution de presque toutes les instructions du processeur. <br><br><ul><li>  Pont de sable 11 </li><li>  Ivy Bridege 10 </li><li>  Haswell 9 </li><li>  Broadwell 9 </li><li>  SkylakeX 141 </li></ul><br>  Le nombre de cycles du processeur est indiqué ici.  Pour calculer l'heure réelle, vous devez diviser le nombre de cycles par la fréquence du processeur (généralement en GHz) et obtenir l'heure en nanosecondes. <br><br>  Cela signifie que si vous exécutez des applications hautement multithread sur .NET sur le dernier matériel, elles peuvent fonctionner beaucoup plus lentement.  Quelqu'un l'a déjà remarqué et a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">enregistré un bug</a> en août 2017.  Le problème a été <a href="">résolu</a> dans .NET Core 2.1 et .NET Framework 4.8 Preview. <br><br><blockquote>  Amélioration du spin-wait dans plusieurs primitives de synchronisation pour de meilleures performances sur Intel Skylake et les microarchitectures ultérieures.  [495945, mscorlib.dll, bogue] </blockquote><br>  Mais comme il reste encore un an avant la sortie de .NET 4.8, j'ai demandé de rétroporter les correctifs pour que .NET 4.7.2 revienne à la vitesse normale sur les nouveaux processeurs.  Étant donné qu'il existe des verrous mutuellement exclusifs (verrous tournants) dans de nombreuses parties de .NET, vous devez suivre l'augmentation de la charge du processeur lorsque Thread.SpinWait et d'autres méthodes de rotation fonctionnent. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c35/a11/ec8/c35a11ec843bb50b6a4c96906fa705f1.png"><br><br>  Par exemple, Task.Result utilise en interne la rotation, donc je prévois une augmentation significative de la charge CPU et une baisse des performances dans d'autres tests. <br><br><h1>  À quel point est-ce mauvais? </h1><br>  J'ai regardé le code .NET Core pendant combien de temps le processeur continuera de tourner si le verrou n'est pas libéré avant d'appeler WaitForSingleObject pour payer le changement de contexte «cher».  Un changement de contexte prend quelque part une microseconde ou bien plus si de nombreux threads attendent le même objet noyau. <br><br>  Les verrous .NET multiplient la durée maximale de rotation par le nombre de cœurs, si nous prenons le cas absolu où le thread sur chaque cœur attend le même verrou et la rotation continue suffisamment longtemps pour que tout le monde travaille un peu avant de payer l'appel du noyau.  La rotation dans .NET utilise un algorithme de vieillissement exponentiel lorsqu'elle démarre avec un cycle de 50 appels de pause, où pour chaque itération le nombre de rotations triple jusqu'à ce que le compteur de rotation suivant dépasse leur durée maximale.  J'ai calculé la durée totale de rotation par processeur pour différents processeurs et un nombre différent de cœurs: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/238/63b/ef9/23863bef9c09567a160f8eb3a7c2d8e7.png"><br><br>  Voici le code de rotation simplifié dans les verrous .NET: <br><br><pre> <code class="hljs pgsql">/// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// This <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> how .NET <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> spinning during <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> contention minus the <span class="hljs-keyword"><span class="hljs-keyword">Lock</span></span> taking/SwitchToThread/Sleep calls /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="nCores"&gt;&lt;/param&gt; <span class="hljs-type"><span class="hljs-type">void</span></span> Spin(<span class="hljs-type"><span class="hljs-type">int</span></span> nCores) { const <span class="hljs-type"><span class="hljs-type">int</span></span> dwRepetitions = <span class="hljs-number"><span class="hljs-number">10</span></span>; const <span class="hljs-type"><span class="hljs-type">int</span></span> dwInitialDuration = <span class="hljs-number"><span class="hljs-number">0x32</span></span>; const <span class="hljs-type"><span class="hljs-type">int</span></span> dwBackOffFactor = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> dwMaximumDuration = <span class="hljs-number"><span class="hljs-number">20</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span> * nCores; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; dwRepetitions; i++) { <span class="hljs-type"><span class="hljs-type">int</span></span> duration = dwInitialDuration; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; duration; k++) { Call_PAUSE(); } duration *= dwBackOffFactor; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (duration &lt; dwMaximumDuration); } }</code> </pre> <br>  Auparavant, le temps de rotation était dans l'intervalle de millisecondes (19 ms pour 24 cœurs), ce qui est déjà beaucoup par rapport au temps de commutation de contexte susmentionné, qui est un ordre de grandeur plus rapide.  Mais dans les processeurs Skylake, le temps de rotation total pour le processeur explose simplement jusqu'à 246 ms sur une machine 24 bits ou 48 cœurs, simplement parce que l'instruction de pause a ralenti de 14 fois.  En est-il vraiment ainsi?  J'ai écrit un petit testeur pour vérifier la rotation globale du processeur - et les chiffres calculés sont bien conformes aux attentes.  Voici 48 threads sur un processeur 24 cœurs en attente d'un verrou, que j'ai appelé Monitor.PulseAll: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f9/6ad/e20/2f96ade20f682b4e7efe8a65d760e87e.png"><br><br>  Un seul fil gagnera la course, mais 47 continueront de tourner jusqu'à ce qu'ils perdent leur fréquence cardiaque.  Ceci est une preuve expérimentale que nous avons vraiment un problème de charge CPU et que la rotation très longue est réelle.  Cela mine l'évolutivité, car ces cycles vont à la place du travail utile d'autres threads, bien que l'instruction de pause libère certaines des ressources partagées du CPU, offrant un sommeil plus long.  La raison de la rotation est une tentative d'obtenir un verrou plus rapidement sans accéder au noyau.  Si c'est le cas, l'augmentation de la charge sur le processeur ne serait que nominale, mais n'affecterait pas du tout les performances, car les noyaux sont engagés dans d'autres tâches.  Mais les tests ont montré une diminution des performances dans des opérations presque à un seul thread, où un thread ajoute quelque chose à la file d'attente de travail, tandis que le thread de travail attend un résultat, puis effectue une certaine tâche avec l'élément de travail. <br><br>  La raison est plus facile à montrer dans le diagramme.  La rotation adversaire se produit avec un triplement de rotation à chaque étape.  Après chaque tour, le verrou est à nouveau vérifié pour voir si le thread actuel peut le recevoir.  Bien que la rotation essaie d'être honnête et passe de temps en temps à d'autres threads pour les aider à terminer leur travail.  Cela augmente les chances de libérer le verrou lors du prochain contrôle.  Le problème est qu'une vérification de prise n'est possible qu'à la fin d'un tour complet: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dec/def/1fd/decdef1fd8ee504f92375acf31eca87d.png"><br><br>  Par exemple, si au début du cinquième tour de rotation un verrou signale la disponibilité, vous ne pouvez le prendre qu'à la fin du tour.  Après avoir calculé la durée de rotation du dernier tour, nous pouvons estimer le pire cas de retard pour notre flux: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/610/b07/173/610b0717341447bc0415e77efaa731c8.png"><br><br>  Plusieurs millisecondes d'attente jusqu'à la fin de la rotation.  Est-ce un vrai problème? <br><br>  J'ai créé une application de test simple qui implémente une file d'attente de fabricants de consommateurs, où le flux de travail effectue chaque élément de travail pendant 10 ms, et le consommateur a un délai de 1 à 9 ms avant l'élément de travail suivant.  Cela suffit pour voir l'effet: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/701/70c/b97/70170cb97d0ac98a07b9733664c304fb.png"><br><br>  Nous constatons que pour des retards de 1 à 2 ms, la durée totale est de 2,2 à 2,3 s, tandis que dans d'autres cas, le travail est plus rapide jusqu'à 1,2 s.  Cela montre que la rotation excessive du processeur n'est pas seulement un problème esthétique dans les applications sur-threadées.  Cela nuit vraiment au filetage simple du producteur-consommateur, qui ne comprend que deux fils.  Pour le run ci-dessus, les données ETW parlent d'elles-mêmes: c'est l'augmentation du spin qui provoque le retard observé: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae9/325/01e/ae932501eb724b116bc0aceac8216ef5.png"><br><br>  Si vous regardez attentivement la section avec «freins», nous verrons 11 ms de rotation dans la zone rouge, bien que le travailleur (bleu clair) ait terminé son travail et ait donné le verrou il y a longtemps. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/89d/a51/030/89da5103028ac3b3285fced21f18d8bf.png"><br><br>  Un cas non dégénératif rapide semble beaucoup mieux, ici seulement 1 ms est dépensé pour tourner pour bloquer. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ef/220/8a4/6ef2208a4ec2e433fc2f9c8da030adca.png"><br><br>  J'ai utilisé l'application de test <i>SkylakeXPause</i> .  L' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">archive zip</a> contient du code source et des fichiers binaires pour .NET Core et .NET 4.5.  À titre de comparaison, j'ai installé .NET 4.8 Preview avec des correctifs et .NET Core 2.0, qui implémente toujours l'ancien comportement.  L'application est conçue pour .NET Standard 2.0 et .NET 4.5, produisant à la fois exe et dll.  Vous pouvez maintenant vérifier côte à côte l'ancien et le nouveau comportement de rotation sans avoir à réparer quoi que ce soit, c'est très pratique. <br><br><pre> <code class="hljs pgsql">readonly <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> _LockObject = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); <span class="hljs-type"><span class="hljs-type">int</span></span> WorkItems; <span class="hljs-type"><span class="hljs-type">int</span></span> CompletedWorkItems; Barrier SyncPoint; <span class="hljs-type"><span class="hljs-type">void</span></span> RunSlowTest() { const <span class="hljs-type"><span class="hljs-type">int</span></span> processingTimeinMs = <span class="hljs-number"><span class="hljs-number">10</span></span>; const <span class="hljs-type"><span class="hljs-type">int</span></span> WorkItemsToSend = <span class="hljs-number"><span class="hljs-number">100</span></span>; Console.WriteLine($"Worker thread works {processingTimeinMs} ms for {WorkItemsToSend} times"); // Test one sender one receiver thread <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> different timings <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> the sender wakes up again // <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> send the next <span class="hljs-keyword"><span class="hljs-keyword">work</span></span> item // synchronize worker <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> sender. Ensure that worker starts first <span class="hljs-type"><span class="hljs-type">double</span></span>[] sendDelayTimes = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (var sendDelay <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sendDelayTimes) { SyncPoint = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Barrier(<span class="hljs-number"><span class="hljs-number">2</span></span>); // one sender one receiver var sw = Stopwatch.StartNew(); Parallel.Invoke(() =&gt; Sender(workItems: WorkItemsToSend, delayInMs: sendDelay), () =&gt; Worker(maxWorkItemsToWork: WorkItemsToSend, workItemProcessTimeInMs: processingTimeinMs)); sw.Stop(); Console.WriteLine($"Send Delay: {sendDelay:F1} ms Work completed in {sw.Elapsed.TotalSeconds:F3} s"); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); // <span class="hljs-keyword"><span class="hljs-keyword">show</span></span> <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> gap <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ETW data so we can differentiate the test runs } } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// Simulate a worker thread which consumes CPU which <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> triggered <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> the Sender thread /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-type"><span class="hljs-type">void</span></span> Worker(<span class="hljs-type"><span class="hljs-type">int</span></span> maxWorkItemsToWork, <span class="hljs-type"><span class="hljs-type">double</span></span> workItemProcessTimeInMs) { SyncPoint.SignalAndWait(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (CompletedWorkItems != maxWorkItemsToWork) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (_LockObject) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WorkItems == <span class="hljs-number"><span class="hljs-number">0</span></span>) { Monitor.Wait(_LockObject); // wait <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">work</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; WorkItems; i++) { CompletedWorkItems++; SimulateWork(workItemProcessTimeInMs); // consume CPU under this <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> } WorkItems = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// <span class="hljs-keyword"><span class="hljs-keyword">Insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">work</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the Worker thread under a <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> wake up the worker thread n times /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-type"><span class="hljs-type">void</span></span> Sender(<span class="hljs-type"><span class="hljs-type">int</span></span> workItems, <span class="hljs-type"><span class="hljs-type">double</span></span> delayInMs) { CompletedWorkItems = <span class="hljs-number"><span class="hljs-number">0</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> previous <span class="hljs-keyword"><span class="hljs-keyword">work</span></span> SyncPoint.SignalAndWait(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; workItems; i++) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (_LockObject) { WorkItems++; Monitor.PulseAll(_LockObject); } SimulateWork(delayInMs); } }</code> </pre> <br><h1>  Conclusions </h1><br>  Ce n'est pas un problème .NET.  Toutes les implémentations spinlock utilisant l'instruction pause sont affectées.  J'ai rapidement vérifié le cœur de Windows Server 2016, mais il n'y a pas un tel problème en surface.  Il semble qu'Intel a été assez gentil - et a laissé entendre que certains changements dans l'approche de la rotation sont nécessaires. <br><br>  Un bogue pour .NET Core a été signalé en août 2017, et en septembre 2017, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un correctif</a> et une version de .NET Core 2.0.3 ont été publiés.  Le lien montre non seulement l'excellente réaction du groupe .NET Core, mais aussi le fait qu'il y a quelques jours, le problème a été résolu dans la branche principale, ainsi qu'une discussion sur des optimisations de rotation supplémentaires.  Malheureusement, Desktop .NET Framework ne se déplace pas si vite, mais face à l'aperçu de .NET Framework 4.8, nous avons au moins la preuve conceptuelle que les correctifs sont également implémentables.  J'attends maintenant le backport pour .NET 4.7.2 pour utiliser .NET à pleine vitesse et sur le dernier matériel.  C'est le premier bogue que j'ai trouvé qui est directement lié aux changements de performances dus à une instruction CPU.  ETW reste le principal profileur sous Windows.  Si je le pouvais, je demanderais à Microsoft de porter l'infrastructure ETW sur Linux, car les profileurs Linux actuels sont toujours de la merde.  Ils ont récemment ajouté des fonctionnalités de noyau intéressantes, mais il n'y a toujours pas d'outils d'analyse comme WPA. <br><br>  Si vous travaillez avec .NET Core 2.0 ou le bureau .NET Framework sur les derniers processeurs sortis depuis la mi-2017, en cas de problèmes de dégradation des performances, vous devez absolument vérifier vos applications avec un profileur - et mettre à niveau vers .NET Core et, espérons-le, bientôt Bureau .NET  Mon application de test vous informera de la présence ou de l'absence d'un problème. <br><br> <code>D:\SkylakeXPause\bin\Release\netcoreapp2.0&gt;dotnet SkylakeXPause.dll -check <br> Did call pause 1,000,000 in 3.5990 ms, Processors: 8 <br> No SkylakeX problem detected</code> <br> <br>  ou <br><br> <code>D:\SkylakeXPause\SkylakeXPause\bin\Release\net45&gt;SkylakeXPause.exe -check <br> Did call pause 1,000,000 in 3.6195 ms, Processors: 8 <br> No SkylakeX problem detected</code> <br> <br>  L'outil signalera un problème si vous travaillez sur le .NET Framework sans la mise à jour appropriée et sur le processeur Skylake. <br><br>  J'espère que vous avez trouvé l'enquête sur ce problème aussi excitante que moi.  Pour vraiment comprendre le problème, vous devez créer un moyen de le reproduire, vous permettant d'expérimenter et de rechercher des facteurs d'influence.  Le reste n'est qu'un travail ennuyeux, mais maintenant je suis beaucoup mieux à même de comprendre les causes et les conséquences d'une tentative cyclique de verrouiller le processeur. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr415053/">https://habr.com/ru/post/fr415053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr415043/index.html">Un robot volant change de forme dans l'air</a></li>
<li><a href="../fr415045/index.html">La politique de licence d'Oracle pousse l'analyse sur Hadoop</a></li>
<li><a href="../fr415047/index.html">Événements numériques à Moscou du 25 juin au 1er juillet</a></li>
<li><a href="../fr415049/index.html">Création de commandes de gestion dans Django</a></li>
<li><a href="../fr415051/index.html">Isométrie, z-indices dans les jeux mobiles et leur optimisation</a></li>
<li><a href="../fr415055/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 320 (18-24 juin 2018)</a></li>
<li><a href="../fr415057/index.html">PHP Digest n ° 133 (10-24 juin 2018)</a></li>
<li><a href="../fr415059/index.html">Secrets de la cuisine JavaScript: épices</a></li>
<li><a href="../fr415061/index.html">Du frontend au backend</a></li>
<li><a href="../fr415063/index.html">Blue Origin commencera à vendre des billets aux touristes de l'espace l'année prochaine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>