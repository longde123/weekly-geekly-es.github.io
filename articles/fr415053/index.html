<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçü§ù‚Äçüë®üèæ üë©‚Äçüëß‚Äçüë¶ ü§¶üèø Pourquoi les processeurs Skylake fonctionnent parfois 2 fois plus lentement üíáüèΩ üìñ üè≥Ô∏è‚Äçüåà</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On m'a inform√© que sur les nouveaux ordinateurs, certains tests de r√©gression devenaient plus lents. Une chose courante, √ßa arrive. Configuration inco...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pourquoi les processeurs Skylake fonctionnent parfois 2 fois plus lentement</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415053/">  On m'a inform√© que sur les nouveaux ordinateurs, certains tests de r√©gression devenaient plus lents.  Une chose courante, √ßa arrive.  Configuration incorrecte quelque part dans Windows ou pas les valeurs les plus optimales dans le BIOS.  Mais cette fois, nous n'avons pas r√©ussi √† trouver le m√™me param√®tre ¬´renvers√©¬ª.  √âtant donn√© que le changement est important: 9 contre 19 secondes (sur le graphique, le bleu est l'ancien fer et l'orange est le nouveau), j'ai d√ª creuser plus profond√©ment. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a9/6db/d57/4a96dbd573606b0a0aabc6a0874dd2fa.png"><br><a name="habracut"></a><br><h1>  M√™me syst√®me d'exploitation, m√™me mat√©riel, processeur diff√©rent: 2 fois plus lent </h1><br>  La baisse des performances de 9,1 √† 19,6 secondes peut certainement √™tre qualifi√©e de significative.  Nous avons effectu√© des v√©rifications suppl√©mentaires avec un changement dans les versions des programmes test√©s, des param√®tres Windows et BIOS.  Mais non, le r√©sultat n'a pas chang√©.  La seule diff√©rence n'apparaissait que sur diff√©rents processeurs.  Voici le r√©sultat sur le dernier CPU. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6a2/fc8/12e/6a2fc812e9f12ae4581b9ed3fd46c4b7.png"><br><br>  Et voici celui qui est utilis√© pour la comparaison. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e81/f8b/d4f/e81f8bd4f20ffe609673ef3db6dd414d.png"><br><br>  Xeon Gold fonctionne sur une architecture diff√©rente appel√©e Skylake, commune aux nouveaux processeurs Intel depuis la mi-2017.  Si vous achetez le dernier mat√©riel, vous obtiendrez un processeur avec l'architecture Skylake.  Ce sont de bonnes voitures, mais, comme les tests l'ont montr√©, la nouveaut√© et la vitesse ne sont pas la m√™me chose. <br><br>  Si rien d'autre ne vous aide, vous devez utiliser le profileur pour des recherches approfondies.  Essayons sur des √©quipements anciens et nouveaux et obtenons quelque chose comme ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3b3/6a3/98e/3b36a398e5ee9ce0950c1d940f3de9c7.png"><br><br>  L'onglet dans Windows Performance Analyzer (WPA) indique dans le tableau la diff√©rence entre la trace 2 (11 s) et la trace 1 (19 s).  Une diff√©rence n√©gative dans le tableau correspond √† une augmentation de la consommation de CPU dans un test plus lent.  Si vous regardez les diff√©rences les plus importantes dans la consommation de CPU, nous verrons <i>AwareLock :: Contention</i> , <i>JIT_MonEnterWorker_InlineGetThread_GetThread_PatchLabel</i> et <i>ThreadNative.SpinWait</i> .  Tout indique une ¬´rotation¬ª dans le CPU [rotation - une tentative cyclique pour obtenir un verrou, env.  par.], lorsque les threads se battent pour le blocage.  Mais c'est une fausse marque, car la filature n'est pas la principale raison de la baisse de productivit√©.  La concurrence accrue pour les verrous signifie que quelque chose dans notre logiciel a ralenti et conserv√© le verrou, ce qui a entra√Æn√© une augmentation de la rotation du processeur.  J'ai v√©rifi√© le temps de verrouillage et d'autres indicateurs cl√©s, tels que les performances du disque, mais je n'ai rien trouv√© de significatif qui pourrait expliquer la d√©gradation des performances.  Bien que ce ne soit pas logique, mais je suis revenu √† augmenter la charge sur le processeur de diff√©rentes mani√®res. <br><br>  Il serait int√©ressant de trouver exactement o√π le processeur est bloqu√©.  WPA a des colonnes de fichier # et de ligne #, mais elles ne fonctionnent qu'avec des caract√®res priv√©s, ce que nous n'avons pas, car il s'agit du code .NET Framework.  La prochaine meilleure chose que nous pouvons faire est d'obtenir l'adresse dll o√π se trouve l'instruction appel√©e Image RVA.  Si vous chargez cette dll dans le d√©bogueur et faites <br><br> <code>u xxx.dll+ImageRVA</code> <br> <br>  alors nous devrions voir l'instruction qui br√ªle la plupart des cycles de CPU, car ce sera la seule adresse "chaude". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9fe/54e/e7b/9fe54ee7bfe194a0e6fec932148f730c.png"><br><br>  Nous examinerons cette adresse en utilisant diff√©rentes m√©thodes Windbg: <br><br> <code>0:000&gt; u clr.dll+0x19566B-10 <br> clr!AwareLock::Contention+0x135: <br> 00007ff8`0535565b f00f4cc6 lock cmovl eax,esi <br> 00007ff8`0535565f 2bf0 sub esi,eax <br> 00007ff8`05355661 eb01 jmp clr!AwareLock::Contention+0x13f (00007ff8`05355664) <br> 00007ff8`05355663 cc int 3 <br> 00007ff8`05355664 83e801 sub eax,1 <br> 00007ff8`05355667 7405 je clr!AwareLock::Contention+0x144 (00007ff8`0535566e) <br> 00007ff8`05355669 f390 pause <br> 00007ff8`0535566b ebf7 jmp clr!AwareLock::Contention+0x13f (00007ff8`05355664)</code> <br> <br>  Et avec diff√©rentes m√©thodes JIT: <br><br> <code>0:000&gt; u clr.dll+0x2801-10 <br> clr!JIT_MonEnterWorker_InlineGetThread_GetThread_PatchLabel+0x124: <br> 00007ff8`051c27f1 5e pop rsi <br> 00007ff8`051c27f2 c3 ret <br> 00007ff8`051c27f3 833d0679930001 cmp dword ptr [clr!g_SystemInfo+0x20 (00007ff8`05afa100)],1 <br> 00007ff8`051c27fa 7e1b jle clr!JIT_MonEnterWorker_InlineGetThread_GetThread_PatchLabel+0x14a (00007ff8`051c2817) <br> 00007ff8`051c27fc 418bc2 mov eax,r10d <br> 00007ff8`051c27ff f390 pause <br> 00007ff8`051c2801 83e801 sub eax,1 <br> 00007ff8`051c2804 75f9 jne clr!JIT_MonEnterWorker_InlineGetThread_GetThread_PatchLabel+0x132 (00007ff8`051c27ff)</code> <br> <br>  Nous avons maintenant un mod√®le.  Dans un cas, l'adresse chaude est une instruction de saut, et dans l'autre cas, c'est une soustraction.  Mais les deux instructions chaudes sont pr√©c√©d√©es de la m√™me instruction de pause g√©n√©rale.  Diff√©rentes m√©thodes ex√©cutent la m√™me instruction de processeur, ce qui, pour une raison quelconque, prend beaucoup de temps.  Mesurons la vitesse d'ex√©cution de l'instruction pause et voyons si nous raisonnons correctement. <br><br><h1>  Si le probl√®me est document√©, il devient alors une fonctionnalit√©. </h1><br><table cellpadding="2" width="400" border="1"><tbody><tr><td width="224">  <strong>CPU</strong> </td><td width="176">  <strong>pause en nanosecondes</strong> </td></tr><tr><td width="224">  Xeon E5 1620v3 3,5 GHz </td><td width="176">  4 </td></tr><tr><td width="224">  Xeon¬Æ Gold 6126 √† 2,60 GHz </td><td width="176">  43 </td></tr></tbody></table><br>  La pause dans les nouveaux processeurs Skylake prend un ordre de grandeur plus long.  Bien s√ªr, tout peut devenir plus rapide et parfois un peu plus lent.  Mais <b>dix fois</b> plus lentement?  Cela ressemble plus √† un bug.  Une petite recherche sur Internet sur les instructions de pause m√®ne au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">manuel</a> d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Intel</a> , qui mentionne explicitement la microarchitecture Skylake et les instructions de pause: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8ca/c9f/30c/8cac9f30cd834d8c47eeab6297dda445.png"><br><br>  Non, ce n'est pas une erreur, c'est une fonction document√©e.  Il y a m√™me une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">page</a> indiquant le temps d'ex√©cution de presque toutes les instructions du processeur. <br><br><ul><li>  Pont de sable 11 </li><li>  Ivy Bridege 10 </li><li>  Haswell 9 </li><li>  Broadwell 9 </li><li>  SkylakeX 141 </li></ul><br>  Le nombre de cycles du processeur est indiqu√© ici.  Pour calculer l'heure r√©elle, vous devez diviser le nombre de cycles par la fr√©quence du processeur (g√©n√©ralement en GHz) et obtenir l'heure en nanosecondes. <br><br>  Cela signifie que si vous ex√©cutez des applications hautement multithread sur .NET sur le dernier mat√©riel, elles peuvent fonctionner beaucoup plus lentement.  Quelqu'un l'a d√©j√† remarqu√© et a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">enregistr√© un bug</a> en ao√ªt 2017.  Le probl√®me a √©t√© <a href="">r√©solu</a> dans .NET Core 2.1 et .NET Framework 4.8 Preview. <br><br><blockquote>  Am√©lioration du spin-wait dans plusieurs primitives de synchronisation pour de meilleures performances sur Intel Skylake et les microarchitectures ult√©rieures.  [495945, mscorlib.dll, bogue] </blockquote><br>  Mais comme il reste encore un an avant la sortie de .NET 4.8, j'ai demand√© de r√©troporter les correctifs pour que .NET 4.7.2 revienne √† la vitesse normale sur les nouveaux processeurs.  √âtant donn√© qu'il existe des verrous mutuellement exclusifs (verrous tournants) dans de nombreuses parties de .NET, vous devez suivre l'augmentation de la charge du processeur lorsque Thread.SpinWait et d'autres m√©thodes de rotation fonctionnent. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c35/a11/ec8/c35a11ec843bb50b6a4c96906fa705f1.png"><br><br>  Par exemple, Task.Result utilise en interne la rotation, donc je pr√©vois une augmentation significative de la charge CPU et une baisse des performances dans d'autres tests. <br><br><h1>  √Ä quel point est-ce mauvais? </h1><br>  J'ai regard√© le code .NET Core pendant combien de temps le processeur continuera de tourner si le verrou n'est pas lib√©r√© avant d'appeler WaitForSingleObject pour payer le changement de contexte ¬´cher¬ª.  Un changement de contexte prend quelque part une microseconde ou bien plus si de nombreux threads attendent le m√™me objet noyau. <br><br>  Les verrous .NET multiplient la dur√©e maximale de rotation par le nombre de c≈ìurs, si nous prenons le cas absolu o√π le thread sur chaque c≈ìur attend le m√™me verrou et la rotation continue suffisamment longtemps pour que tout le monde travaille un peu avant de payer l'appel du noyau.  La rotation dans .NET utilise un algorithme de vieillissement exponentiel lorsqu'elle d√©marre avec un cycle de 50 appels de pause, o√π pour chaque it√©ration le nombre de rotations triple jusqu'√† ce que le compteur de rotation suivant d√©passe leur dur√©e maximale.  J'ai calcul√© la dur√©e totale de rotation par processeur pour diff√©rents processeurs et un nombre diff√©rent de c≈ìurs: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/238/63b/ef9/23863bef9c09567a160f8eb3a7c2d8e7.png"><br><br>  Voici le code de rotation simplifi√© dans les verrous .NET: <br><br><pre> <code class="hljs pgsql">/// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// This <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> how .NET <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> spinning during <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> contention minus the <span class="hljs-keyword"><span class="hljs-keyword">Lock</span></span> taking/SwitchToThread/Sleep calls /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="nCores"&gt;&lt;/param&gt; <span class="hljs-type"><span class="hljs-type">void</span></span> Spin(<span class="hljs-type"><span class="hljs-type">int</span></span> nCores) { const <span class="hljs-type"><span class="hljs-type">int</span></span> dwRepetitions = <span class="hljs-number"><span class="hljs-number">10</span></span>; const <span class="hljs-type"><span class="hljs-type">int</span></span> dwInitialDuration = <span class="hljs-number"><span class="hljs-number">0x32</span></span>; const <span class="hljs-type"><span class="hljs-type">int</span></span> dwBackOffFactor = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> dwMaximumDuration = <span class="hljs-number"><span class="hljs-number">20</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span> * nCores; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; dwRepetitions; i++) { <span class="hljs-type"><span class="hljs-type">int</span></span> duration = dwInitialDuration; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; duration; k++) { Call_PAUSE(); } duration *= dwBackOffFactor; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (duration &lt; dwMaximumDuration); } }</code> </pre> <br>  Auparavant, le temps de rotation √©tait dans l'intervalle de millisecondes (19 ms pour 24 c≈ìurs), ce qui est d√©j√† beaucoup par rapport au temps de commutation de contexte susmentionn√©, qui est un ordre de grandeur plus rapide.  Mais dans les processeurs Skylake, le temps de rotation total pour le processeur explose simplement jusqu'√† 246 ms sur une machine 24 bits ou 48 c≈ìurs, simplement parce que l'instruction de pause a ralenti de 14 fois.  En est-il vraiment ainsi?  J'ai √©crit un petit testeur pour v√©rifier la rotation globale du processeur - et les chiffres calcul√©s sont bien conformes aux attentes.  Voici 48 threads sur un processeur 24 c≈ìurs en attente d'un verrou, que j'ai appel√© Monitor.PulseAll: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f9/6ad/e20/2f96ade20f682b4e7efe8a65d760e87e.png"><br><br>  Un seul fil gagnera la course, mais 47 continueront de tourner jusqu'√† ce qu'ils perdent leur fr√©quence cardiaque.  Ceci est une preuve exp√©rimentale que nous avons vraiment un probl√®me de charge CPU et que la rotation tr√®s longue est r√©elle.  Cela mine l'√©volutivit√©, car ces cycles vont √† la place du travail utile d'autres threads, bien que l'instruction de pause lib√®re certaines des ressources partag√©es du CPU, offrant un sommeil plus long.  La raison de la rotation est une tentative d'obtenir un verrou plus rapidement sans acc√©der au noyau.  Si c'est le cas, l'augmentation de la charge sur le processeur ne serait que nominale, mais n'affecterait pas du tout les performances, car les noyaux sont engag√©s dans d'autres t√¢ches.  Mais les tests ont montr√© une diminution des performances dans des op√©rations presque √† un seul thread, o√π un thread ajoute quelque chose √† la file d'attente de travail, tandis que le thread de travail attend un r√©sultat, puis effectue une certaine t√¢che avec l'√©l√©ment de travail. <br><br>  La raison est plus facile √† montrer dans le diagramme.  La rotation adversaire se produit avec un triplement de rotation √† chaque √©tape.  Apr√®s chaque tour, le verrou est √† nouveau v√©rifi√© pour voir si le thread actuel peut le recevoir.  Bien que la rotation essaie d'√™tre honn√™te et passe de temps en temps √† d'autres threads pour les aider √† terminer leur travail.  Cela augmente les chances de lib√©rer le verrou lors du prochain contr√¥le.  Le probl√®me est qu'une v√©rification de prise n'est possible qu'√† la fin d'un tour complet: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dec/def/1fd/decdef1fd8ee504f92375acf31eca87d.png"><br><br>  Par exemple, si au d√©but du cinqui√®me tour de rotation un verrou signale la disponibilit√©, vous ne pouvez le prendre qu'√† la fin du tour.  Apr√®s avoir calcul√© la dur√©e de rotation du dernier tour, nous pouvons estimer le pire cas de retard pour notre flux: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/610/b07/173/610b0717341447bc0415e77efaa731c8.png"><br><br>  Plusieurs millisecondes d'attente jusqu'√† la fin de la rotation.  Est-ce un vrai probl√®me? <br><br>  J'ai cr√©√© une application de test simple qui impl√©mente une file d'attente de fabricants de consommateurs, o√π le flux de travail effectue chaque √©l√©ment de travail pendant 10 ms, et le consommateur a un d√©lai de 1 √† 9 ms avant l'√©l√©ment de travail suivant.  Cela suffit pour voir l'effet: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/701/70c/b97/70170cb97d0ac98a07b9733664c304fb.png"><br><br>  Nous constatons que pour des retards de 1 √† 2 ms, la dur√©e totale est de 2,2 √† 2,3 s, tandis que dans d'autres cas, le travail est plus rapide jusqu'√† 1,2 s.  Cela montre que la rotation excessive du processeur n'est pas seulement un probl√®me esth√©tique dans les applications sur-thread√©es.  Cela nuit vraiment au filetage simple du producteur-consommateur, qui ne comprend que deux fils.  Pour le run ci-dessus, les donn√©es ETW parlent d'elles-m√™mes: c'est l'augmentation du spin qui provoque le retard observ√©: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae9/325/01e/ae932501eb724b116bc0aceac8216ef5.png"><br><br>  Si vous regardez attentivement la section avec ¬´freins¬ª, nous verrons 11 ms de rotation dans la zone rouge, bien que le travailleur (bleu clair) ait termin√© son travail et ait donn√© le verrou il y a longtemps. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/89d/a51/030/89da5103028ac3b3285fced21f18d8bf.png"><br><br>  Un cas non d√©g√©n√©ratif rapide semble beaucoup mieux, ici seulement 1 ms est d√©pens√© pour tourner pour bloquer. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ef/220/8a4/6ef2208a4ec2e433fc2f9c8da030adca.png"><br><br>  J'ai utilis√© l'application de test <i>SkylakeXPause</i> .  L' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">archive zip</a> contient du code source et des fichiers binaires pour .NET Core et .NET 4.5.  √Ä titre de comparaison, j'ai install√© .NET 4.8 Preview avec des correctifs et .NET Core 2.0, qui impl√©mente toujours l'ancien comportement.  L'application est con√ßue pour .NET Standard 2.0 et .NET 4.5, produisant √† la fois exe et dll.  Vous pouvez maintenant v√©rifier c√¥te √† c√¥te l'ancien et le nouveau comportement de rotation sans avoir √† r√©parer quoi que ce soit, c'est tr√®s pratique. <br><br><pre> <code class="hljs pgsql">readonly <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> _LockObject = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); <span class="hljs-type"><span class="hljs-type">int</span></span> WorkItems; <span class="hljs-type"><span class="hljs-type">int</span></span> CompletedWorkItems; Barrier SyncPoint; <span class="hljs-type"><span class="hljs-type">void</span></span> RunSlowTest() { const <span class="hljs-type"><span class="hljs-type">int</span></span> processingTimeinMs = <span class="hljs-number"><span class="hljs-number">10</span></span>; const <span class="hljs-type"><span class="hljs-type">int</span></span> WorkItemsToSend = <span class="hljs-number"><span class="hljs-number">100</span></span>; Console.WriteLine($"Worker thread works {processingTimeinMs} ms for {WorkItemsToSend} times"); // Test one sender one receiver thread <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> different timings <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> the sender wakes up again // <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> send the next <span class="hljs-keyword"><span class="hljs-keyword">work</span></span> item // synchronize worker <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> sender. Ensure that worker starts first <span class="hljs-type"><span class="hljs-type">double</span></span>[] sendDelayTimes = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (var sendDelay <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sendDelayTimes) { SyncPoint = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Barrier(<span class="hljs-number"><span class="hljs-number">2</span></span>); // one sender one receiver var sw = Stopwatch.StartNew(); Parallel.Invoke(() =&gt; Sender(workItems: WorkItemsToSend, delayInMs: sendDelay), () =&gt; Worker(maxWorkItemsToWork: WorkItemsToSend, workItemProcessTimeInMs: processingTimeinMs)); sw.Stop(); Console.WriteLine($"Send Delay: {sendDelay:F1} ms Work completed in {sw.Elapsed.TotalSeconds:F3} s"); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); // <span class="hljs-keyword"><span class="hljs-keyword">show</span></span> <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> gap <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ETW data so we can differentiate the test runs } } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// Simulate a worker thread which consumes CPU which <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> triggered <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> the Sender thread /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-type"><span class="hljs-type">void</span></span> Worker(<span class="hljs-type"><span class="hljs-type">int</span></span> maxWorkItemsToWork, <span class="hljs-type"><span class="hljs-type">double</span></span> workItemProcessTimeInMs) { SyncPoint.SignalAndWait(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (CompletedWorkItems != maxWorkItemsToWork) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (_LockObject) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WorkItems == <span class="hljs-number"><span class="hljs-number">0</span></span>) { Monitor.Wait(_LockObject); // wait <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">work</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; WorkItems; i++) { CompletedWorkItems++; SimulateWork(workItemProcessTimeInMs); // consume CPU under this <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> } WorkItems = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// <span class="hljs-keyword"><span class="hljs-keyword">Insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">work</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the Worker thread under a <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> wake up the worker thread n times /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-type"><span class="hljs-type">void</span></span> Sender(<span class="hljs-type"><span class="hljs-type">int</span></span> workItems, <span class="hljs-type"><span class="hljs-type">double</span></span> delayInMs) { CompletedWorkItems = <span class="hljs-number"><span class="hljs-number">0</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> previous <span class="hljs-keyword"><span class="hljs-keyword">work</span></span> SyncPoint.SignalAndWait(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; workItems; i++) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (_LockObject) { WorkItems++; Monitor.PulseAll(_LockObject); } SimulateWork(delayInMs); } }</code> </pre> <br><h1>  Conclusions </h1><br>  Ce n'est pas un probl√®me .NET.  Toutes les impl√©mentations spinlock utilisant l'instruction pause sont affect√©es.  J'ai rapidement v√©rifi√© le c≈ìur de Windows Server 2016, mais il n'y a pas un tel probl√®me en surface.  Il semble qu'Intel a √©t√© assez gentil - et a laiss√© entendre que certains changements dans l'approche de la rotation sont n√©cessaires. <br><br>  Un bogue pour .NET Core a √©t√© signal√© en ao√ªt 2017, et en septembre 2017, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un correctif</a> et une version de .NET Core 2.0.3 ont √©t√© publi√©s.  Le lien montre non seulement l'excellente r√©action du groupe .NET Core, mais aussi le fait qu'il y a quelques jours, le probl√®me a √©t√© r√©solu dans la branche principale, ainsi qu'une discussion sur des optimisations de rotation suppl√©mentaires.  Malheureusement, Desktop .NET Framework ne se d√©place pas si vite, mais face √† l'aper√ßu de .NET Framework 4.8, nous avons au moins la preuve conceptuelle que les correctifs sont √©galement impl√©mentables.  J'attends maintenant le backport pour .NET 4.7.2 pour utiliser .NET √† pleine vitesse et sur le dernier mat√©riel.  C'est le premier bogue que j'ai trouv√© qui est directement li√© aux changements de performances dus √† une instruction CPU.  ETW reste le principal profileur sous Windows.  Si je le pouvais, je demanderais √† Microsoft de porter l'infrastructure ETW sur Linux, car les profileurs Linux actuels sont toujours de la merde.  Ils ont r√©cemment ajout√© des fonctionnalit√©s de noyau int√©ressantes, mais il n'y a toujours pas d'outils d'analyse comme WPA. <br><br>  Si vous travaillez avec .NET Core 2.0 ou le bureau .NET Framework sur les derniers processeurs sortis depuis la mi-2017, en cas de probl√®mes de d√©gradation des performances, vous devez absolument v√©rifier vos applications avec un profileur - et mettre √† niveau vers .NET Core et, esp√©rons-le, bient√¥t Bureau .NET  Mon application de test vous informera de la pr√©sence ou de l'absence d'un probl√®me. <br><br> <code>D:\SkylakeXPause\bin\Release\netcoreapp2.0&gt;dotnet SkylakeXPause.dll -check <br> Did call pause 1,000,000 in 3.5990 ms, Processors: 8 <br> No SkylakeX problem detected</code> <br> <br>  ou <br><br> <code>D:\SkylakeXPause\SkylakeXPause\bin\Release\net45&gt;SkylakeXPause.exe -check <br> Did call pause 1,000,000 in 3.6195 ms, Processors: 8 <br> No SkylakeX problem detected</code> <br> <br>  L'outil signalera un probl√®me si vous travaillez sur le .NET Framework sans la mise √† jour appropri√©e et sur le processeur Skylake. <br><br>  J'esp√®re que vous avez trouv√© l'enqu√™te sur ce probl√®me aussi excitante que moi.  Pour vraiment comprendre le probl√®me, vous devez cr√©er un moyen de le reproduire, vous permettant d'exp√©rimenter et de rechercher des facteurs d'influence.  Le reste n'est qu'un travail ennuyeux, mais maintenant je suis beaucoup mieux √† m√™me de comprendre les causes et les cons√©quences d'une tentative cyclique de verrouiller le processeur. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr415053/">https://habr.com/ru/post/fr415053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr415043/index.html">Un robot volant change de forme dans l'air</a></li>
<li><a href="../fr415045/index.html">La politique de licence d'Oracle pousse l'analyse sur Hadoop</a></li>
<li><a href="../fr415047/index.html">√âv√©nements num√©riques √† Moscou du 25 juin au 1er juillet</a></li>
<li><a href="../fr415049/index.html">Cr√©ation de commandes de gestion dans Django</a></li>
<li><a href="../fr415051/index.html">Isom√©trie, z-indices dans les jeux mobiles et leur optimisation</a></li>
<li><a href="../fr415055/index.html">Le condens√© de mati√®res fra√Æches du monde du front-end de la derni√®re semaine n ¬∞ 320 (18-24 juin 2018)</a></li>
<li><a href="../fr415057/index.html">PHP Digest n ¬∞ 133 (10-24 juin 2018)</a></li>
<li><a href="../fr415059/index.html">Secrets de la cuisine JavaScript: √©pices</a></li>
<li><a href="../fr415061/index.html">Du frontend au backend</a></li>
<li><a href="../fr415063/index.html">Blue Origin commencera √† vendre des billets aux touristes de l'espace l'ann√©e prochaine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>