<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ™ğŸ¼ ğŸ‘¨ğŸ¾â€ğŸ¨ ğŸ‘¦ğŸ¿ Comment j'ai crÃ©Ã© un filtre qui ne corrompe pas l'image mÃªme aprÃ¨s un million d'exÃ©cutions ğŸ¤›ğŸ¾ ğŸ¿ ğŸ§šğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ayant terminÃ© la crÃ©ation de l'architecture web pour notre nouvelle bande dessinÃ©e web Meow the Infinite , j'ai dÃ©cidÃ© qu'il Ã©tait temps d'Ã©crire quel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment j'ai crÃ©Ã© un filtre qui ne corrompe pas l'image mÃªme aprÃ¨s un million d'exÃ©cutions</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468501/">  Ayant terminÃ© la crÃ©ation de l'architecture web pour notre nouvelle bande dessinÃ©e web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Meow the Infinite</a> , j'ai dÃ©cidÃ© qu'il Ã©tait temps d'Ã©crire quelques articles techniques attendus depuis longtemps.  Cet article se concentrera sur un filtre que j'ai dÃ©veloppÃ© il y a plusieurs annÃ©es.  Cela n'a jamais Ã©tÃ© discutÃ© dans le domaine de la compression vidÃ©o, bien qu'il me semble que cela en vaille la peine. <br><br>  En 2011, j'ai dÃ©veloppÃ© le Â«filtre demi-pelÂ».  Il s'agit d'un type spÃ©cial de filtre qui prend une image entrante et affiche de maniÃ¨re convaincante Ã  quoi ressemblerait l'image lorsqu'elle serait dÃ©calÃ©e <i>exactement d'un demi-pixel</i> . <br><br>  Vous vous demandez probablement pourquoi un tel filtre peut Ãªtre nÃ©cessaire.  En fait, ils sont assez courants dans les codecs vidÃ©o modernes.  Les codecs vidÃ©o utilisent des filtres similaires pour prendre des fragments d'images prÃ©cÃ©dentes et les utiliser dans les images suivantes.  Les codecs plus anciens ne dÃ©plaÃ§aient les donnÃ©es de trame que d'un pixel entier Ã  la fois, mais les nouveaux codecs allaient plus loin et permettaient un dÃ©calage d'un demi ou mÃªme d'un quart de pixel pour mieux transmettre les petits mouvements. <br><br>  Lors de l'analyse du comportement des algorithmes de compensation de mouvement dans les filtres demi-pixel traditionnels, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jeff Roberts a</a> constatÃ© que lorsqu'ils Ã©taient appliquÃ©s Ã  plusieurs reprises Ã  des images sÃ©quentielles, ils se dÃ©gradaient rapidement, forÃ§ant les autres parties du compresseur vidÃ©o Ã  utiliser plus de donnÃ©es que nÃ©cessaire pour corriger les artefacts.  Si vous dÃ©sactivez ces corrections et regardez les rÃ©sultats "bruts" du filtre halfpel, voici l'image d'origine: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br>  se transforme en ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a3/3f7/605/2a33f7605ba0b5456d11881f24be8226.png" width="1000" height="284"></div><br>  juste une seconde plus tard la vidÃ©o.  Comme il se doit, il est dÃ©calÃ© sur le cÃ´tÃ©, car chaque image a dÃ©calÃ© l'image d'un demi-pixel.  Mais le rÃ©sultat ne ressemble pas Ã  une version dÃ©placÃ©e de l'image d'origine, il est sÃ©rieusement dÃ©formÃ©. <br><a name="habracut"></a><br>  Pendant le "vidÃ©o d'une seconde", le filtre est en fait appliquÃ© plusieurs fois - 60 si la vidÃ©o est lue Ã  une frÃ©quence de 60 images par seconde.  Mais idÃ©alement, nous avons besoin de filtres rÃ©sistants Ã  de telles distorsions.  Si nous les avions, les vidÃ©os Ã  dÃ©filement fluide n'auraient pas Ã©tÃ© encodÃ©es avec autant de corrections d'artefacts, ce qui les aurait rendues infÃ©rieures, ou meilleures, ou les deux. <br><br>  Si vous connaissez le domaine de la compression vidÃ©o, vous vous demandez peut-Ãªtre pourquoi devons-nous mÃªme utiliser le filtre halfpel plus d'une fois.  En fin de compte, si nous appliquons le filtre halfpel deux fois, nous dÃ©placerons dÃ©jÃ  un pixel entier, alors pourquoi ne pas simplement utiliser les donnÃ©es de <i>deux</i> images et les reprendre? <br><br>  La rÃ©ponse n'est pas si simple.  PremiÃ¨rement, plus nous avons besoin de donnÃ©es pour coder les donnÃ©es, moins nous obtenons de compression.  Par consÃ©quent, si nous commenÃ§ons Ã  coder sans avoir besoin de trop de donnÃ©es telles que Â«Ã  partir de quelle image prendre les donnÃ©esÂ», la vidÃ©o ne sera pas trÃ¨s bien compressÃ©e. <br><br>  Mais ce n'est pas le plus important.  Le principal problÃ¨me est que si nous devons prendre des informations de trames prÃ©cÃ©dentes, nous <i>devrons les stocker</i> .  Pour conserver les deux images prÃ©cÃ©dentes, au lieu d'une, vous devez deviner que vous avez deux fois plus de mÃ©moire.  Pour les processeurs modernes, ce n'est pas un problÃ¨me particulier, ils ont beaucoup de mÃ©moire et une telle bagatelle ne les dÃ©range pas.  Mais c'est un <i>problÃ¨me</i> pour vous si vous voulez crÃ©er un format vidÃ©o rapide, portable et largement utilisÃ© qui devrait fonctionner dans des appareils avec une petite quantitÃ© de mÃ©moire (tÃ©lÃ©phones mobiles, Ã©lectronique intÃ©grÃ©e, etc.). <br><br>  Nous ne voulons vraiment pas stocker plusieurs images afin de compenser le mouvement afin de ne pas utiliser de filtre demi-pixel.  Par consÃ©quent, on m'a demandÃ© de savoir ce qui se passe exactement ici et de dÃ©terminer si je peux crÃ©er un filtre qui ne prÃ©sente pas de tels problÃ¨mes. <br><br>  Avant cela, je n'avais jamais travaillÃ© avec des filtres et je n'avais aucune idÃ©e de la faÃ§on dont ils sont gÃ©nÃ©ralement dÃ©veloppÃ©s.  Curieusement, cela s'est avÃ©rÃ© en ma faveur, car je devais examiner ce problÃ¨me sans prÃ©jugÃ©s. <br><br><h2>  Les bases </h2><br>  J'ai rapidement rÃ©alisÃ© que les filtres halfpel les plus populaires ont une structure similaire: pour chaque pixel de l'image de sortie, 2 Ã  8 pixels de l'image d'entrÃ©e sont pris, qui sont Ã©chantillonnÃ©s et mÃ©langÃ©s avec certains coefficients.  DiffÃ©rents filtres ne diffÃ¨rent que par le nombre de pixels sources Ã©chantillonnÃ©s (souvent dans le jargon des dÃ©veloppeurs de filtres, ils sont appelÃ©s tap) et les facteurs de mÃ©lange des pixels.  Ces coefficients sont souvent appelÃ©s Â«noyau de filtreÂ» et c'est tout ce qui est nÃ©cessaire pour dÃ©crire complÃ¨tement le filtre. <br><br>  Si vous connaissez tout type d'Ã©chantillonnage ou de rÃ©Ã©chantillonnage d'images (par exemple, la mise Ã  l'Ã©chelle d'images), cela devrait Ãªtre clair pour vous.  Essentiellement, les filtres font la mÃªme chose.  Ã‰tant donnÃ© que la compression vidÃ©o est un vaste domaine dans lequel diverses Ã©tudes sont effectuÃ©es, il est Ã©vident qu'il existe de nombreuses <i>autres</i> faÃ§ons de compenser le mouvement autres que le simple filtrage.  Mais les codecs courants utilisent gÃ©nÃ©ralement des procÃ©dures de compensation de mouvement avec des filtres demi-pixels, qui sont essentiellement identiques aux filtres de mise Ã  l'Ã©chelle de l'image: ils prennent simplement les pixels d'origine, les multiplient par certains poids, les ajoutent et obtiennent les pixels de sortie. <br><br><h2>  Le besoin de "nettetÃ©" </h2><br>  Nous devons donc dÃ©placer l'image d'un demi-pixel.  Si vous Ãªtes un programmeur graphique, mais que vous n'Ãªtes pas particuliÃ¨rement familier avec le filtrage, vous pourriez penser: "J'ai aussi un problÃ¨me, utilisez simplement un filtre bilinÃ©aire."  Il s'agit d'un processus standard pour travailler avec des graphiques, lorsque nous devons calculer des valeurs intermÃ©diaires entre deux Ã©lÃ©ments de donnÃ©es entrants, comme cela se produit ici. <br><br>  Un filtre bilinÃ©aire pour dÃ©placer exactement un demi-pixel peut Ãªtre facilement dÃ©crit par le noyau de filtre suivant: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// NOTE(casey): Simple bilinear filter BilinearKernel[] = {1.0/2.0, 1.0/2.0};</span></span></code> </pre> <br>  Cela fonctionnera, mais pas sans problÃ¨mes.  Si votre objectif est des images de haute qualitÃ©, et dans le cas de la compression vidÃ©o, l'objectif n'est que cela, alors un filtre bilinÃ©aire n'est pas la meilleure solution, car il ajoute plus de flou au rÃ©sultat que nÃ©cessaire.  Ce n'est pas tant, mais <i>plus</i> que d'autres filtres n'en crÃ©ent. <br><br>  Pour le montrer clairement, voici une image approximative de l'Å“il du morse Ã  partir de l'image d'origine aprÃ¨s une seule application des filtres les plus courants: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b0/97d/17e/1b097d17ed0bf71252e43527442a852b.png" width="670" height="140"></div><br>  A gauche, l'original, Ã  droite, le filtrage bilinÃ©aire.  Entre eux se trouvent les filtres halfpel les plus largement utilisÃ©s des codecs vidÃ©o.  Si vous regardez attentivement, vous pouvez voir que presque toutes les images se ressemblent, Ã  l' <i>exception d'une image</i> bilinÃ©aire, qui est lÃ©gÃ¨rement plus floue.  Bien qu'il n'y ait pas beaucoup de flou, si votre objectif principal est la qualitÃ© d'image, cela suffit pour prÃ©fÃ©rer un filtre diffÃ©rent Ã  un filtre bilinÃ©aire. <br><br>  Alors, comment les autres filtres Â«maintiennent-ilsÂ» la nettetÃ© et Ã©vitent-ils le flou?  Rappelons Ã  quoi ressemble le noyau du flou bilinÃ©aire: <br><br><pre> <code class="cpp hljs">BilinearKernel[] = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">2.0</span></span>};</code> </pre> <br>  C'est trÃ¨s simple.  Pour dÃ©caler l'image d'un demi-pixel, on prend un pixel et on le mÃ©lange Ã  50% avec son voisin.  Câ€™est tout.  On peut imaginer comment cela Â«brouilleÂ» l'image, car dans les endroits oÃ¹ le pixel blanc brillant est adjacent au noir foncÃ©, ces deux pixels sont moyennÃ©s lors du filtrage bilinÃ©aire, crÃ©ant un pixel gris qui Â«adoucitÂ» la bordure.  Cela se produit avec chaque pixel, donc littÃ©ralement chaque zone oÃ¹ il y a une nette diffÃ©rence de couleur ou de luminositÃ©.  lissÃ©. <br><br>  C'est pourquoi dans les codecs de haute qualitÃ©, le filtrage bilinÃ©aire n'est pas utilisÃ© pour la compensation de mouvement (bien qu'il puisse Ãªtre utilisÃ© dans d'autres cas).  Au lieu de cela, des filtres sont utilisÃ©s qui prÃ©servent la nettetÃ©, par exemple, tels que: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// NOTE(casey): Half-pel filters for the industry-standard h.264 and HEVC video codecs h264Kernel[] = {1.0/32.0, -5.0/32.0, 20.0/32.0, 20.0/32.0, -5.0/32.0, 1.0/32.0}; HEVCKernel[] = {-1.0/64.0, 4.0/64.0, -11.0/64.0, 40.0/64.0, 40/64.0, -11.0/64.0, 4.0/64.0, -1.0/64.0};</span></span></code> </pre> <br>  Comme vous pouvez le voir, lÃ  oÃ¹ le filtrage bilinÃ©aire ne prenait en compte que deux pixels, ces filtres prennent en compte six (h.264) voire huit (HEVC) pixels.  De plus, ils ne calculent pas seulement les valeurs moyennes pondÃ©rÃ©es habituelles de ces pixels, mais utilisent <i>des</i> poids <i>nÃ©gatifs</i> pour certains pixels pour <i>soustraire</i> ces pixels des autres valeurs. <br><br>  Pourquoi font-ils Ã§a? <br><br>  En fait, il n'est pas difficile de comprendre cela: en utilisant Ã  la fois des valeurs positives et nÃ©gatives, et en considÃ©rant Ã©galement une Â«fenÃªtreÂ» plus large, le filtre est capable de prendre en compte la <i>diffÃ©rence</i> entre les pixels adjacents et de simuler la nettetÃ© des deux pixels les plus proches par rapport Ã  leurs voisins les plus Ã©loignÃ©s.  Cela vous permet de maintenir la nettetÃ© du rÃ©sultat de l'image dans les endroits oÃ¹ les pixels diffÃ¨rent considÃ©rablement de leurs voisins, tandis que la moyenne est toujours utilisÃ©e pour crÃ©er des valeurs crÃ©dibles de dÃ©calages de "demi-pixel", qui doivent nÃ©cessairement reflÃ©ter la combinaison de pixels de l'image entrante. <br><br><h2>  Filtrage instable </h2><br>  Alors, le problÃ¨me est-il rÃ©solu?  Oui, c'est possible, mais si vous n'avez besoin que d'un dÃ©calage d'un demi-pixel.  Cependant, ces filtres Â«d'accentuationÂ» (et j'utilise ce terme ici intentionnellement) font en fait quelque chose de dangereux, <i>essentiellement similaire</i> Ã  ce que fait le filtrage bilinÃ©aire.  Ils savent mieux comment le cacher. <br><br>  Lorsque le filtrage bilinÃ©aire <i>rÃ©duit</i> la nettetÃ© de l'image, ces filtres standard l' <i>augmentent</i> , comme l'opÃ©ration de nettetÃ© dans certains programmes graphiques.  La quantitÃ© de nettetÃ© est trÃ¨s faible, donc si nous n'exÃ©cutons le filtre qu'une seule fois, nous ne le remarquerons pas.  Mais si le filtrage est effectuÃ© plusieurs fois, cela peut devenir trÃ¨s visible. <br><br>  Et, malheureusement, puisque cette nettetÃ© est procÃ©durale et dÃ©pend de la diffÃ©rence entre les pixels, elle <i>crÃ©e une boucle de rÃ©troaction</i> qui continuera Ã  rendre la mÃªme bordure encore et encore jusqu'Ã  ce qu'elle dÃ©truise l'image.  Vous pouvez le montrer avec des exemples spÃ©cifiques. <br><br>  Ci-dessus - l'image d'origine, ci-dessous - avec filtrage bilinÃ©aire, effectuÃ©e sur 60 images: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/346/0d9/d18/3460d9d18c2e74e79980d1ead799d7c4.png" width="1000" height="284"></div><br>  Comme vous pouvez vous y attendre, le flou continue simplement de rÃ©duire la nettetÃ© de l'image jusqu'Ã  ce qu'elle devienne assez floue.  Maintenant, l'original sera en haut et le filtre halfpel du codec h.264 qui fonctionnera pendant 60 images en bas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a3/3f7/605/2a33f7605ba0b5456d11881f24be8226.png" width="1000" height="284"></div><br>  Voir tous ces dÃ©chets?  Le filtre fait la mÃªme chose que l'effet Â«flouÂ» du filtrage bilinÃ©aire, mais <i>vice versa</i> - il Â«augmente la nettetÃ© de l'imageÂ» de sorte que toutes les parties oÃ¹ les dÃ©tails sont transformÃ©s en motifs clair / foncÃ© fortement dÃ©formÃ©s. <br><br>  Le codec HEVC utilisant 8 pixels se comporte-t-il mieux?  Eh bien, il fait certainement mieux que le h.264: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/337/309/98e/33730998e411bb57ad5e38bb835cf7e1.png" width="1000" height="284"></div><br>  mais si nous augmentons le temps de 60 images (1 seconde) Ã  120 images (2 secondes), nous verrons toujours qu'il y a un retour et l'image est dÃ©truite: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95c/672/b35/95c672b35482ac260a4ed0bbf10d7833.png" width="1000" height="284"></div><br>  Pour ceux qui aiment le traitement du signal, je vais ajouter un filtre fenÃªtrÃ©-sinc (appelÃ© filtre Lanczos) pour rÃ©fÃ©rence: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// NOTE(casey): Traditional 6-tap Lanczos filter LanczosKernel[] = {0.02446, -0.13587, 0.61141, 0.61141, -0.13587, 0.02446};</span></span></code> </pre> <br>  Je n'expliquerai pas dans cet article pourquoi quelqu'un pourrait Ãªtre intÃ©ressÃ© par le "windowed sinc", mais il suffit de dire que ce filtre est populaire pour des raisons thÃ©oriques, alors regardez Ã  quoi il ressemble lors du traitement de 60 images (1 seconde): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a46/5ce/35c/a465ce35c2009cc7cfd8ebfc2959748c.png" width="1000" height="284"></div><br>  et lors du traitement de 120 images (2 secondes): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/f55/da5/3b8f55da553059f6639982098c75f148.png" width="1000" height="284"></div><br>  Mieux que h.264, et Ã  peu prÃ¨s le mÃªme que HEVC. <br><br><h2>  Filtrage stable </h2><br>  Comment pouvons-nous obtenir de meilleurs rÃ©sultats que h.264, HEVC et sinc fenÃªtrÃ©?  Et combien peuvent-ils Ãªtre mieux? <br><br>  Je <i>m'attendrais Ã </i> voir des questions similaires dans la littÃ©rature sur la compression vidÃ©o et elles devraient Ãªtre bien connues des spÃ©cialistes de la compression, mais en fait (au moins pour 2011), je n'ai trouvÃ© personne qui a au moins dÃ©clarÃ© que c'Ã©tait un problÃ¨me.  J'ai donc dÃ» trouver une solution seule. <br><br>  Heureusement, l'Ã©noncÃ© du problÃ¨me est trÃ¨s simple: crÃ©ez un filtre qui peut Ãªtre appliquÃ© autant de fois que possible afin que l'image soit Ã  peu prÃ¨s la mÃªme qu'au dÃ©but. <br><br>  J'appelle cette dÃ©finition Â«filtrage stableÂ» car, Ã  mon avis, elle peut Ãªtre considÃ©rÃ©e comme une propriÃ©tÃ© de filtre.  Un filtre est Â«stableÂ» s'il ne tombe pas dans sa boucle de rÃ©troaction, c'est-Ã -dire qu'il peut Ãªtre appliquÃ© Ã  plusieurs reprises sans crÃ©er d'artefacts.  Un filtre est "instable" s'il crÃ©e des artefacts qui sont amplifiÃ©s par une utilisation rÃ©pÃ©tÃ©e et finissent par dÃ©truire l'image. <br><br>  Je le rÃ©pÃ¨te, je ne comprends pas pourquoi ce sujet n'est pas pris en compte dans la littÃ©rature sur les codecs vidÃ©o ou le traitement d'image.  Il utilise peut-Ãªtre une terminologie diffÃ©rente, mais je ne l'ai pas rencontrÃ©e.  Le concept de Â«feedbackÂ» est bien Ã©tabli dans le domaine du travail avec le son.  mais pas un problÃ¨me important dans le traitement d'image.  Peut-Ãªtre parce que les filtres ne doivent gÃ©nÃ©ralement Ãªtre appliquÃ©s qu'une seule fois? <br><br>  Si j'Ã©tais un spÃ©cialiste dans ce domaine, alors j'avais probablement une opinion Ã  ce sujet, et peut-Ãªtre mÃªme connaÃ®trais-je ces recoins de la littÃ©rature spÃ©cialisÃ©e oÃ¹ il existe dÃ©jÃ  des solutions Ã  ce problÃ¨me, peu connues.  Mais, comme je l'ai dit au dÃ©but de l'article, je n'avais jamais Ã©tÃ© en mesure de crÃ©er des filtres auparavant, j'ai donc cherchÃ© uniquement dans des articles bien connus (bien qu'il soit intÃ©ressant de noter qu'il y a au moins une personne bien connue dans la littÃ©rature qui n'a Ã©galement rien entendu de tel) ) <br><br>  Le matin, ils m'ont dit que nous avions besoin de ce filtre et j'ai essayÃ© de le crÃ©er toute la journÃ©e.  Mon approche Ã©tait simple: j'ai crÃ©Ã© un programme qui a exÃ©cutÃ© le filtre des centaines de fois et Ã  la fin a produit une image pour que je puisse voir le rÃ©sultat de longues exÃ©cutions.  Ensuite, j'ai expÃ©rimentÃ© diffÃ©rents coefficients de filtre et observÃ© les rÃ©sultats.  C'Ã©tait littÃ©ralement un processus directionnel d'essais et d'erreurs. <br><br>  Environ une heure plus tard, j'ai choisi les meilleurs coefficients de filtre adaptÃ©s Ã  cette tÃ¢che (mais ils avaient un dÃ©faut, dont je parlerai dans la deuxiÃ¨me partie de l'article): <br><br><pre> <code class="cpp hljs">MyKernel[] = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">-4.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">19.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">19.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">-4.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>};</code> </pre> <br>  Ce noyau est sur le point d'Ãªtre affÃ»tÃ© et flou.  Ã‰tant donnÃ© que la nettetÃ© conduit toujours Ã  une rÃ©troaction qui crÃ©e des artefacts vifs et Ã©vidents, ce noyau de filtre prÃ©fÃ¨re un peu de flou pour que l'image semble juste un peu plus Â«terneÂ». <br><br>  Voici Ã  quoi cela ressemble aprÃ¨s 60 images.  Pour rÃ©fÃ©rence, j'ai montrÃ© tous les filtres dans cet ordre: l'image d'origine (sans filtrage), mon filtre, bilinÃ©aire, Lanczos, h.264, HEVC: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc8/c7e/cd1/fc8c7ecd131c285b080ca8c6375c66b5.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/346/0d9/d18/3460d9d18c2e74e79980d1ead799d7c4.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a46/5ce/35c/a465ce35c2009cc7cfd8ebfc2959748c.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a3/3f7/605/2a33f7605ba0b5456d11881f24be8226.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/337/309/98e/33730998e411bb57ad5e38bb835cf7e1.png" width="1000" height="284"></div><br>  Comme vous pouvez le voir, mon filtre donne des rÃ©sultats lÃ©gÃ¨rement plus flous que les filtres de nettetÃ©, mais n'a pas d'artefacts de nettetÃ© inacceptables aprÃ¨s 60 images.  Cependant, vous pouvez prÃ©fÃ©rer les artefacts de flou pour aiguiser les artefacts, vous pouvez donc choisir entre le meilleur filtre de nettetÃ© (Lanczos) et le mien.  Cependant, si nous augmentons le nombre Ã  120 images, mon filtre est hors compÃ©tition: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44a/a48/c5e/44aa48c5ef416f191097379547061625.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a13/3a5/f66/a133a5f66fa5ddd6d5a9073a23f02b2e.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/f55/da5/3b8f55da553059f6639982098c75f148.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/410/92a/849/41092a8499f2ea7beab529cdeca274bc.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95c/672/b35/95c672b35482ac260a4ed0bbf10d7833.png" width="1000" height="284"></div><br>  AprÃ¨s 300 images, tous les filtres, sauf le mien, deviennent comme une mauvaise blague: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d2/1ca/007/2d21ca007ccba46c3a9427dd767d6fb7.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/816/ca3/619/816ca36196d48266af8218a585744068.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de4/45d/377/de445d3777d9d35e988585af3f83581f.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c5/0e4/31f/5c50e431ff7a624e078fe95479cafbe2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/ac8/5b7/8d9ac85b768064dfaacd5bdb8019b8c5.png" width="1000" height="284"></div><br>  AprÃ¨s 600 images, la blague devient encore plus cruelle: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f23/69e/d51/f2369ed51c63439be8c3281c706e10d7.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/344/544/b61/344544b6152756bcdce564d58ee61cc0.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/536/25d/943/53625d9435b36876edf087a753a63c61.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55d/32c/66a/55d32c66a716e40c2826bd5150e3e34f.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f5/b92/c95/4f5b92c95825178ca0ce82320c37a2bc.png" width="1000" height="284"></div><br>  Vous n'avez mÃªme pas besoin de dire ce qui se passe aprÃ¨s 900 images: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09c/46f/617/09c46f617c7dfe04b5cb7e7c1010ba62.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1c/f58/7a4/b1cf587a4ceea34f13f97bece1f70a07.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/271/860/34d/27186034d68d111643b325559a3d5b13.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9d/ac6/d55/f9dac6d551ef448f6b8a042a43af17b6.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/32e/742/9dd/32e7429dd6fa7f0d704f40d28e92e0dc.png" width="1000" height="284"></div><br><h2>  Est-il stable? </h2><br>  A ce stade, on se demandera naturellement: mon filtre est-il <i>vraiment</i> stable, ou est-ce juste un flou trÃ¨s lent, beaucoup plus lent que le filtrage bilinÃ©aire?  Peut-Ãªtre qu'aprÃ¨s des milliers de rÃ©pÃ©titions, mon filtre brouillera <i>progressivement</i> l'image? <br><br>  Ã‰tonnamment, la rÃ©ponse semble Ãªtre nÃ©gative.  Bien qu'un peu de flou soit ajoutÃ© au cours d'une centaine de premiÃ¨res superpositions, il semble que le filtre <i>converge</i> vers une reprÃ©sentation stable de l'image, qui <i>ne</i> se dÃ©grade ensuite <i>jamais</i> .  Voici une autre image agrandie d'un Å“il de morse: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4a/26d/19f/e4a26d19f9ba6142ab7c45aeaea765ec.png" width="768" height="128"></div><br>  De gauche Ã  droite: l'image d'origine, mon filtre appliquÃ© 60 fois, 120 fois, 300 fois, 600 et 900 fois.  Comme vous pouvez le voir, le flou converge vers un Ã©tat stable, qui ne se dÃ©grade plus mÃªme aprÃ¨s des centaines de superpositions de filtres.  Par contraste, comparez cela avec la synchronisation fenÃªtrÃ©e pour le mÃªme nombre d'Ã©chantillons (appuyez) et voyez Ã  quel point (et rapide!) Les artefacts forment le feedback et crÃ©ent un rÃ©sultat inutile: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/122/2ff/2f2/1222ff2f2fe380cfab03df453f06ce2f.png" width="768" height="128"></div><br>  Mon filtre semble trÃ¨s stable, et comparÃ© Ã  tous les filtres que j'ai vus, il crÃ©e les meilleurs rÃ©sultats aprÃ¨s une utilisation rÃ©pÃ©tÃ©e.  Il semble qu'il possÃ¨de une certaine propriÃ©tÃ© Â«asymptotiqueÂ», dans laquelle les donnÃ©es convergent rapidement vers une image lissÃ©e (limitÃ©e), puis cette image lissÃ©e est enregistrÃ©e et n'effectue pas de dÃ©gradation illimitÃ©e pour terminer les ordures. <br><br>  J'ai mÃªme essayÃ© d'appliquer le filtre un <i>million de</i> fois, et il semble qu'aprÃ¨s les quelques centaines de superpositions, il ne se dÃ©grade plus.  Sans une meilleure analyse mathÃ©matique (et je n'ai pas encore trouvÃ© de solution mathÃ©matique qui puisse le prouver exactement, mais je suis sÃ»r que c'est quelque part), je ne peux pas dire avec certitude que quelque part aprÃ¨s des milliards ou des milliards de superpositions qui -il ne cassera pas.  Dans des tests raisonnables, je n'ai pas pu dÃ©tecter de dÃ©gradation supplÃ©mentaire. <br><br><h2>  Est-ce le meilleur filtre Halfpel stable pour six tap? </h2><br>  A ce stade, il serait logique de se poser la question: est-ce vraiment le meilleur que l'on puisse trouver?  L'intuition nous dit que ce n'est pas le cas, parce que je n'avais absolument aucune connaissance sur le dÃ©veloppement des filtres et que je n'avais presque pas Ã©tudiÃ© la littÃ©rature, j'ai rÃ©cupÃ©rÃ© ce filtre en seulement une heure.  Au moins, on peut <i>supposer</i> qu'aprÃ¨s une Ã©tude aussi brÃ¨ve, je n'aurais pas trouvÃ© de filtre dÃ©finitif, le meilleur et le plus conquÃ©rant. <br><br>  Cette hypothÃ¨se est-elle vraie?  Et si c'est vrai, <i>quel</i> sera le meilleur filtre final?  Je vais en discuter plus en dÃ©tail dans la deuxiÃ¨me partie de l'article. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr468501/">https://habr.com/ru/post/fr468501/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr468487/index.html">Que peut-il arriver (vecteurs d'attaque typiques)</a></li>
<li><a href="../fr468489/index.html">Contrebande de requÃªtes HTTP - nouvelles approches</a></li>
<li><a href="../fr468491/index.html">MalÃ©diction karmique d'Habra</a></li>
<li><a href="../fr468493/index.html">La structure de la vue aÃ©rienne du projet Data Science</a></li>
<li><a href="../fr468497/index.html">Minuterie de brossage minutÃ©e de 3 minutes</a></li>
<li><a href="../fr468503/index.html">Le courrier ne fait pas plus de 500 miles - FAQ</a></li>
<li><a href="../fr468509/index.html">DÃ©veloppement de systÃ¨me d'exploitation de type Unix - Pilotes de pÃ©riphÃ©riques de caractÃ¨res (8)</a></li>
<li><a href="../fr468511/index.html">Publication d'un serveur via une passerelle DFL D-Link</a></li>
<li><a href="../fr468515/index.html">Conseils utiles pour l'intÃ©gration dans de nouveaux projets</a></li>
<li><a href="../fr468517/index.html">2. PrÃ©sentation du support technique et de la garantie du commutateur Extreme Networks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>