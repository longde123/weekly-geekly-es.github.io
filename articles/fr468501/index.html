<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙏🏼 👨🏾‍🎨 👦🏿 Comment j'ai créé un filtre qui ne corrompe pas l'image même après un million d'exécutions 🤛🏾 🏿 🧚🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ayant terminé la création de l'architecture web pour notre nouvelle bande dessinée web Meow the Infinite , j'ai décidé qu'il était temps d'écrire quel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment j'ai créé un filtre qui ne corrompe pas l'image même après un million d'exécutions</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468501/">  Ayant terminé la création de l'architecture web pour notre nouvelle bande dessinée web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Meow the Infinite</a> , j'ai décidé qu'il était temps d'écrire quelques articles techniques attendus depuis longtemps.  Cet article se concentrera sur un filtre que j'ai développé il y a plusieurs années.  Cela n'a jamais été discuté dans le domaine de la compression vidéo, bien qu'il me semble que cela en vaille la peine. <br><br>  En 2011, j'ai développé le «filtre demi-pel».  Il s'agit d'un type spécial de filtre qui prend une image entrante et affiche de manière convaincante à quoi ressemblerait l'image lorsqu'elle serait décalée <i>exactement d'un demi-pixel</i> . <br><br>  Vous vous demandez probablement pourquoi un tel filtre peut être nécessaire.  En fait, ils sont assez courants dans les codecs vidéo modernes.  Les codecs vidéo utilisent des filtres similaires pour prendre des fragments d'images précédentes et les utiliser dans les images suivantes.  Les codecs plus anciens ne déplaçaient les données de trame que d'un pixel entier à la fois, mais les nouveaux codecs allaient plus loin et permettaient un décalage d'un demi ou même d'un quart de pixel pour mieux transmettre les petits mouvements. <br><br>  Lors de l'analyse du comportement des algorithmes de compensation de mouvement dans les filtres demi-pixel traditionnels, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jeff Roberts a</a> constaté que lorsqu'ils étaient appliqués à plusieurs reprises à des images séquentielles, ils se dégradaient rapidement, forçant les autres parties du compresseur vidéo à utiliser plus de données que nécessaire pour corriger les artefacts.  Si vous désactivez ces corrections et regardez les résultats "bruts" du filtre halfpel, voici l'image d'origine: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br>  se transforme en ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a3/3f7/605/2a33f7605ba0b5456d11881f24be8226.png" width="1000" height="284"></div><br>  juste une seconde plus tard la vidéo.  Comme il se doit, il est décalé sur le côté, car chaque image a décalé l'image d'un demi-pixel.  Mais le résultat ne ressemble pas à une version déplacée de l'image d'origine, il est sérieusement déformé. <br><a name="habracut"></a><br>  Pendant le "vidéo d'une seconde", le filtre est en fait appliqué plusieurs fois - 60 si la vidéo est lue à une fréquence de 60 images par seconde.  Mais idéalement, nous avons besoin de filtres résistants à de telles distorsions.  Si nous les avions, les vidéos à défilement fluide n'auraient pas été encodées avec autant de corrections d'artefacts, ce qui les aurait rendues inférieures, ou meilleures, ou les deux. <br><br>  Si vous connaissez le domaine de la compression vidéo, vous vous demandez peut-être pourquoi devons-nous même utiliser le filtre halfpel plus d'une fois.  En fin de compte, si nous appliquons le filtre halfpel deux fois, nous déplacerons déjà un pixel entier, alors pourquoi ne pas simplement utiliser les données de <i>deux</i> images et les reprendre? <br><br>  La réponse n'est pas si simple.  Premièrement, plus nous avons besoin de données pour coder les données, moins nous obtenons de compression.  Par conséquent, si nous commençons à coder sans avoir besoin de trop de données telles que «à partir de quelle image prendre les données», la vidéo ne sera pas très bien compressée. <br><br>  Mais ce n'est pas le plus important.  Le principal problème est que si nous devons prendre des informations de trames précédentes, nous <i>devrons les stocker</i> .  Pour conserver les deux images précédentes, au lieu d'une, vous devez deviner que vous avez deux fois plus de mémoire.  Pour les processeurs modernes, ce n'est pas un problème particulier, ils ont beaucoup de mémoire et une telle bagatelle ne les dérange pas.  Mais c'est un <i>problème</i> pour vous si vous voulez créer un format vidéo rapide, portable et largement utilisé qui devrait fonctionner dans des appareils avec une petite quantité de mémoire (téléphones mobiles, électronique intégrée, etc.). <br><br>  Nous ne voulons vraiment pas stocker plusieurs images afin de compenser le mouvement afin de ne pas utiliser de filtre demi-pixel.  Par conséquent, on m'a demandé de savoir ce qui se passe exactement ici et de déterminer si je peux créer un filtre qui ne présente pas de tels problèmes. <br><br>  Avant cela, je n'avais jamais travaillé avec des filtres et je n'avais aucune idée de la façon dont ils sont généralement développés.  Curieusement, cela s'est avéré en ma faveur, car je devais examiner ce problème sans préjugés. <br><br><h2>  Les bases </h2><br>  J'ai rapidement réalisé que les filtres halfpel les plus populaires ont une structure similaire: pour chaque pixel de l'image de sortie, 2 à 8 pixels de l'image d'entrée sont pris, qui sont échantillonnés et mélangés avec certains coefficients.  Différents filtres ne diffèrent que par le nombre de pixels sources échantillonnés (souvent dans le jargon des développeurs de filtres, ils sont appelés tap) et les facteurs de mélange des pixels.  Ces coefficients sont souvent appelés «noyau de filtre» et c'est tout ce qui est nécessaire pour décrire complètement le filtre. <br><br>  Si vous connaissez tout type d'échantillonnage ou de rééchantillonnage d'images (par exemple, la mise à l'échelle d'images), cela devrait être clair pour vous.  Essentiellement, les filtres font la même chose.  Étant donné que la compression vidéo est un vaste domaine dans lequel diverses études sont effectuées, il est évident qu'il existe de nombreuses <i>autres</i> façons de compenser le mouvement autres que le simple filtrage.  Mais les codecs courants utilisent généralement des procédures de compensation de mouvement avec des filtres demi-pixels, qui sont essentiellement identiques aux filtres de mise à l'échelle de l'image: ils prennent simplement les pixels d'origine, les multiplient par certains poids, les ajoutent et obtiennent les pixels de sortie. <br><br><h2>  Le besoin de "netteté" </h2><br>  Nous devons donc déplacer l'image d'un demi-pixel.  Si vous êtes un programmeur graphique, mais que vous n'êtes pas particulièrement familier avec le filtrage, vous pourriez penser: "J'ai aussi un problème, utilisez simplement un filtre bilinéaire."  Il s'agit d'un processus standard pour travailler avec des graphiques, lorsque nous devons calculer des valeurs intermédiaires entre deux éléments de données entrants, comme cela se produit ici. <br><br>  Un filtre bilinéaire pour déplacer exactement un demi-pixel peut être facilement décrit par le noyau de filtre suivant: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// NOTE(casey): Simple bilinear filter BilinearKernel[] = {1.0/2.0, 1.0/2.0};</span></span></code> </pre> <br>  Cela fonctionnera, mais pas sans problèmes.  Si votre objectif est des images de haute qualité, et dans le cas de la compression vidéo, l'objectif n'est que cela, alors un filtre bilinéaire n'est pas la meilleure solution, car il ajoute plus de flou au résultat que nécessaire.  Ce n'est pas tant, mais <i>plus</i> que d'autres filtres n'en créent. <br><br>  Pour le montrer clairement, voici une image approximative de l'œil du morse à partir de l'image d'origine après une seule application des filtres les plus courants: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b0/97d/17e/1b097d17ed0bf71252e43527442a852b.png" width="670" height="140"></div><br>  A gauche, l'original, à droite, le filtrage bilinéaire.  Entre eux se trouvent les filtres halfpel les plus largement utilisés des codecs vidéo.  Si vous regardez attentivement, vous pouvez voir que presque toutes les images se ressemblent, à l' <i>exception d'une image</i> bilinéaire, qui est légèrement plus floue.  Bien qu'il n'y ait pas beaucoup de flou, si votre objectif principal est la qualité d'image, cela suffit pour préférer un filtre différent à un filtre bilinéaire. <br><br>  Alors, comment les autres filtres «maintiennent-ils» la netteté et évitent-ils le flou?  Rappelons à quoi ressemble le noyau du flou bilinéaire: <br><br><pre> <code class="cpp hljs">BilinearKernel[] = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">2.0</span></span>};</code> </pre> <br>  C'est très simple.  Pour décaler l'image d'un demi-pixel, on prend un pixel et on le mélange à 50% avec son voisin.  C’est tout.  On peut imaginer comment cela «brouille» l'image, car dans les endroits où le pixel blanc brillant est adjacent au noir foncé, ces deux pixels sont moyennés lors du filtrage bilinéaire, créant un pixel gris qui «adoucit» la bordure.  Cela se produit avec chaque pixel, donc littéralement chaque zone où il y a une nette différence de couleur ou de luminosité.  lissé. <br><br>  C'est pourquoi dans les codecs de haute qualité, le filtrage bilinéaire n'est pas utilisé pour la compensation de mouvement (bien qu'il puisse être utilisé dans d'autres cas).  Au lieu de cela, des filtres sont utilisés qui préservent la netteté, par exemple, tels que: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// NOTE(casey): Half-pel filters for the industry-standard h.264 and HEVC video codecs h264Kernel[] = {1.0/32.0, -5.0/32.0, 20.0/32.0, 20.0/32.0, -5.0/32.0, 1.0/32.0}; HEVCKernel[] = {-1.0/64.0, 4.0/64.0, -11.0/64.0, 40.0/64.0, 40/64.0, -11.0/64.0, 4.0/64.0, -1.0/64.0};</span></span></code> </pre> <br>  Comme vous pouvez le voir, là où le filtrage bilinéaire ne prenait en compte que deux pixels, ces filtres prennent en compte six (h.264) voire huit (HEVC) pixels.  De plus, ils ne calculent pas seulement les valeurs moyennes pondérées habituelles de ces pixels, mais utilisent <i>des</i> poids <i>négatifs</i> pour certains pixels pour <i>soustraire</i> ces pixels des autres valeurs. <br><br>  Pourquoi font-ils ça? <br><br>  En fait, il n'est pas difficile de comprendre cela: en utilisant à la fois des valeurs positives et négatives, et en considérant également une «fenêtre» plus large, le filtre est capable de prendre en compte la <i>différence</i> entre les pixels adjacents et de simuler la netteté des deux pixels les plus proches par rapport à leurs voisins les plus éloignés.  Cela vous permet de maintenir la netteté du résultat de l'image dans les endroits où les pixels diffèrent considérablement de leurs voisins, tandis que la moyenne est toujours utilisée pour créer des valeurs crédibles de décalages de "demi-pixel", qui doivent nécessairement refléter la combinaison de pixels de l'image entrante. <br><br><h2>  Filtrage instable </h2><br>  Alors, le problème est-il résolu?  Oui, c'est possible, mais si vous n'avez besoin que d'un décalage d'un demi-pixel.  Cependant, ces filtres «d'accentuation» (et j'utilise ce terme ici intentionnellement) font en fait quelque chose de dangereux, <i>essentiellement similaire</i> à ce que fait le filtrage bilinéaire.  Ils savent mieux comment le cacher. <br><br>  Lorsque le filtrage bilinéaire <i>réduit</i> la netteté de l'image, ces filtres standard l' <i>augmentent</i> , comme l'opération de netteté dans certains programmes graphiques.  La quantité de netteté est très faible, donc si nous n'exécutons le filtre qu'une seule fois, nous ne le remarquerons pas.  Mais si le filtrage est effectué plusieurs fois, cela peut devenir très visible. <br><br>  Et, malheureusement, puisque cette netteté est procédurale et dépend de la différence entre les pixels, elle <i>crée une boucle de rétroaction</i> qui continuera à rendre la même bordure encore et encore jusqu'à ce qu'elle détruise l'image.  Vous pouvez le montrer avec des exemples spécifiques. <br><br>  Ci-dessus - l'image d'origine, ci-dessous - avec filtrage bilinéaire, effectuée sur 60 images: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/346/0d9/d18/3460d9d18c2e74e79980d1ead799d7c4.png" width="1000" height="284"></div><br>  Comme vous pouvez vous y attendre, le flou continue simplement de réduire la netteté de l'image jusqu'à ce qu'elle devienne assez floue.  Maintenant, l'original sera en haut et le filtre halfpel du codec h.264 qui fonctionnera pendant 60 images en bas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a3/3f7/605/2a33f7605ba0b5456d11881f24be8226.png" width="1000" height="284"></div><br>  Voir tous ces déchets?  Le filtre fait la même chose que l'effet «flou» du filtrage bilinéaire, mais <i>vice versa</i> - il «augmente la netteté de l'image» de sorte que toutes les parties où les détails sont transformés en motifs clair / foncé fortement déformés. <br><br>  Le codec HEVC utilisant 8 pixels se comporte-t-il mieux?  Eh bien, il fait certainement mieux que le h.264: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/337/309/98e/33730998e411bb57ad5e38bb835cf7e1.png" width="1000" height="284"></div><br>  mais si nous augmentons le temps de 60 images (1 seconde) à 120 images (2 secondes), nous verrons toujours qu'il y a un retour et l'image est détruite: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95c/672/b35/95c672b35482ac260a4ed0bbf10d7833.png" width="1000" height="284"></div><br>  Pour ceux qui aiment le traitement du signal, je vais ajouter un filtre fenêtré-sinc (appelé filtre Lanczos) pour référence: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// NOTE(casey): Traditional 6-tap Lanczos filter LanczosKernel[] = {0.02446, -0.13587, 0.61141, 0.61141, -0.13587, 0.02446};</span></span></code> </pre> <br>  Je n'expliquerai pas dans cet article pourquoi quelqu'un pourrait être intéressé par le "windowed sinc", mais il suffit de dire que ce filtre est populaire pour des raisons théoriques, alors regardez à quoi il ressemble lors du traitement de 60 images (1 seconde): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a46/5ce/35c/a465ce35c2009cc7cfd8ebfc2959748c.png" width="1000" height="284"></div><br>  et lors du traitement de 120 images (2 secondes): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/f55/da5/3b8f55da553059f6639982098c75f148.png" width="1000" height="284"></div><br>  Mieux que h.264, et à peu près le même que HEVC. <br><br><h2>  Filtrage stable </h2><br>  Comment pouvons-nous obtenir de meilleurs résultats que h.264, HEVC et sinc fenêtré?  Et combien peuvent-ils être mieux? <br><br>  Je <i>m'attendrais à</i> voir des questions similaires dans la littérature sur la compression vidéo et elles devraient être bien connues des spécialistes de la compression, mais en fait (au moins pour 2011), je n'ai trouvé personne qui a au moins déclaré que c'était un problème.  J'ai donc dû trouver une solution seule. <br><br>  Heureusement, l'énoncé du problème est très simple: créez un filtre qui peut être appliqué autant de fois que possible afin que l'image soit à peu près la même qu'au début. <br><br>  J'appelle cette définition «filtrage stable» car, à mon avis, elle peut être considérée comme une propriété de filtre.  Un filtre est «stable» s'il ne tombe pas dans sa boucle de rétroaction, c'est-à-dire qu'il peut être appliqué à plusieurs reprises sans créer d'artefacts.  Un filtre est "instable" s'il crée des artefacts qui sont amplifiés par une utilisation répétée et finissent par détruire l'image. <br><br>  Je le répète, je ne comprends pas pourquoi ce sujet n'est pas pris en compte dans la littérature sur les codecs vidéo ou le traitement d'image.  Il utilise peut-être une terminologie différente, mais je ne l'ai pas rencontrée.  Le concept de «feedback» est bien établi dans le domaine du travail avec le son.  mais pas un problème important dans le traitement d'image.  Peut-être parce que les filtres ne doivent généralement être appliqués qu'une seule fois? <br><br>  Si j'étais un spécialiste dans ce domaine, alors j'avais probablement une opinion à ce sujet, et peut-être même connaîtrais-je ces recoins de la littérature spécialisée où il existe déjà des solutions à ce problème, peu connues.  Mais, comme je l'ai dit au début de l'article, je n'avais jamais été en mesure de créer des filtres auparavant, j'ai donc cherché uniquement dans des articles bien connus (bien qu'il soit intéressant de noter qu'il y a au moins une personne bien connue dans la littérature qui n'a également rien entendu de tel) ) <br><br>  Le matin, ils m'ont dit que nous avions besoin de ce filtre et j'ai essayé de le créer toute la journée.  Mon approche était simple: j'ai créé un programme qui a exécuté le filtre des centaines de fois et à la fin a produit une image pour que je puisse voir le résultat de longues exécutions.  Ensuite, j'ai expérimenté différents coefficients de filtre et observé les résultats.  C'était littéralement un processus directionnel d'essais et d'erreurs. <br><br>  Environ une heure plus tard, j'ai choisi les meilleurs coefficients de filtre adaptés à cette tâche (mais ils avaient un défaut, dont je parlerai dans la deuxième partie de l'article): <br><br><pre> <code class="cpp hljs">MyKernel[] = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">-4.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">19.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">19.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">-4.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>};</code> </pre> <br>  Ce noyau est sur le point d'être affûté et flou.  Étant donné que la netteté conduit toujours à une rétroaction qui crée des artefacts vifs et évidents, ce noyau de filtre préfère un peu de flou pour que l'image semble juste un peu plus «terne». <br><br>  Voici à quoi cela ressemble après 60 images.  Pour référence, j'ai montré tous les filtres dans cet ordre: l'image d'origine (sans filtrage), mon filtre, bilinéaire, Lanczos, h.264, HEVC: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc8/c7e/cd1/fc8c7ecd131c285b080ca8c6375c66b5.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/346/0d9/d18/3460d9d18c2e74e79980d1ead799d7c4.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a46/5ce/35c/a465ce35c2009cc7cfd8ebfc2959748c.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a3/3f7/605/2a33f7605ba0b5456d11881f24be8226.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/337/309/98e/33730998e411bb57ad5e38bb835cf7e1.png" width="1000" height="284"></div><br>  Comme vous pouvez le voir, mon filtre donne des résultats légèrement plus flous que les filtres de netteté, mais n'a pas d'artefacts de netteté inacceptables après 60 images.  Cependant, vous pouvez préférer les artefacts de flou pour aiguiser les artefacts, vous pouvez donc choisir entre le meilleur filtre de netteté (Lanczos) et le mien.  Cependant, si nous augmentons le nombre à 120 images, mon filtre est hors compétition: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44a/a48/c5e/44aa48c5ef416f191097379547061625.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a13/3a5/f66/a133a5f66fa5ddd6d5a9073a23f02b2e.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/f55/da5/3b8f55da553059f6639982098c75f148.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/410/92a/849/41092a8499f2ea7beab529cdeca274bc.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95c/672/b35/95c672b35482ac260a4ed0bbf10d7833.png" width="1000" height="284"></div><br>  Après 300 images, tous les filtres, sauf le mien, deviennent comme une mauvaise blague: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d2/1ca/007/2d21ca007ccba46c3a9427dd767d6fb7.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/816/ca3/619/816ca36196d48266af8218a585744068.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de4/45d/377/de445d3777d9d35e988585af3f83581f.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c5/0e4/31f/5c50e431ff7a624e078fe95479cafbe2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/ac8/5b7/8d9ac85b768064dfaacd5bdb8019b8c5.png" width="1000" height="284"></div><br>  Après 600 images, la blague devient encore plus cruelle: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f23/69e/d51/f2369ed51c63439be8c3281c706e10d7.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/344/544/b61/344544b6152756bcdce564d58ee61cc0.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/536/25d/943/53625d9435b36876edf087a753a63c61.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55d/32c/66a/55d32c66a716e40c2826bd5150e3e34f.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f5/b92/c95/4f5b92c95825178ca0ce82320c37a2bc.png" width="1000" height="284"></div><br>  Vous n'avez même pas besoin de dire ce qui se passe après 900 images: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09c/46f/617/09c46f617c7dfe04b5cb7e7c1010ba62.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1c/f58/7a4/b1cf587a4ceea34f13f97bece1f70a07.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/271/860/34d/27186034d68d111643b325559a3d5b13.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9d/ac6/d55/f9dac6d551ef448f6b8a042a43af17b6.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/32e/742/9dd/32e7429dd6fa7f0d704f40d28e92e0dc.png" width="1000" height="284"></div><br><h2>  Est-il stable? </h2><br>  A ce stade, on se demandera naturellement: mon filtre est-il <i>vraiment</i> stable, ou est-ce juste un flou très lent, beaucoup plus lent que le filtrage bilinéaire?  Peut-être qu'après des milliers de répétitions, mon filtre brouillera <i>progressivement</i> l'image? <br><br>  Étonnamment, la réponse semble être négative.  Bien qu'un peu de flou soit ajouté au cours d'une centaine de premières superpositions, il semble que le filtre <i>converge</i> vers une représentation stable de l'image, qui <i>ne</i> se dégrade ensuite <i>jamais</i> .  Voici une autre image agrandie d'un œil de morse: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4a/26d/19f/e4a26d19f9ba6142ab7c45aeaea765ec.png" width="768" height="128"></div><br>  De gauche à droite: l'image d'origine, mon filtre appliqué 60 fois, 120 fois, 300 fois, 600 et 900 fois.  Comme vous pouvez le voir, le flou converge vers un état stable, qui ne se dégrade plus même après des centaines de superpositions de filtres.  Par contraste, comparez cela avec la synchronisation fenêtrée pour le même nombre d'échantillons (appuyez) et voyez à quel point (et rapide!) Les artefacts forment le feedback et créent un résultat inutile: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/122/2ff/2f2/1222ff2f2fe380cfab03df453f06ce2f.png" width="768" height="128"></div><br>  Mon filtre semble très stable, et comparé à tous les filtres que j'ai vus, il crée les meilleurs résultats après une utilisation répétée.  Il semble qu'il possède une certaine propriété «asymptotique», dans laquelle les données convergent rapidement vers une image lissée (limitée), puis cette image lissée est enregistrée et n'effectue pas de dégradation illimitée pour terminer les ordures. <br><br>  J'ai même essayé d'appliquer le filtre un <i>million de</i> fois, et il semble qu'après les quelques centaines de superpositions, il ne se dégrade plus.  Sans une meilleure analyse mathématique (et je n'ai pas encore trouvé de solution mathématique qui puisse le prouver exactement, mais je suis sûr que c'est quelque part), je ne peux pas dire avec certitude que quelque part après des milliards ou des milliards de superpositions qui -il ne cassera pas.  Dans des tests raisonnables, je n'ai pas pu détecter de dégradation supplémentaire. <br><br><h2>  Est-ce le meilleur filtre Halfpel stable pour six tap? </h2><br>  A ce stade, il serait logique de se poser la question: est-ce vraiment le meilleur que l'on puisse trouver?  L'intuition nous dit que ce n'est pas le cas, parce que je n'avais absolument aucune connaissance sur le développement des filtres et que je n'avais presque pas étudié la littérature, j'ai récupéré ce filtre en seulement une heure.  Au moins, on peut <i>supposer</i> qu'après une étude aussi brève, je n'aurais pas trouvé de filtre définitif, le meilleur et le plus conquérant. <br><br>  Cette hypothèse est-elle vraie?  Et si c'est vrai, <i>quel</i> sera le meilleur filtre final?  Je vais en discuter plus en détail dans la deuxième partie de l'article. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr468501/">https://habr.com/ru/post/fr468501/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr468487/index.html">Que peut-il arriver (vecteurs d'attaque typiques)</a></li>
<li><a href="../fr468489/index.html">Contrebande de requêtes HTTP - nouvelles approches</a></li>
<li><a href="../fr468491/index.html">Malédiction karmique d'Habra</a></li>
<li><a href="../fr468493/index.html">La structure de la vue aérienne du projet Data Science</a></li>
<li><a href="../fr468497/index.html">Minuterie de brossage minutée de 3 minutes</a></li>
<li><a href="../fr468503/index.html">Le courrier ne fait pas plus de 500 miles - FAQ</a></li>
<li><a href="../fr468509/index.html">Développement de système d'exploitation de type Unix - Pilotes de périphériques de caractères (8)</a></li>
<li><a href="../fr468511/index.html">Publication d'un serveur via une passerelle DFL D-Link</a></li>
<li><a href="../fr468515/index.html">Conseils utiles pour l'intégration dans de nouveaux projets</a></li>
<li><a href="../fr468517/index.html">2. Présentation du support technique et de la garantie du commutateur Extreme Networks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>