<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐃 👡 👺 Tief tauchen: vom CSS zum Transistor 👐🏽 🗜️ 🤷🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor 70 Jahren, am 16. Dezember 1947, schufen John Bardin und Walter Brattain in den Bell Labs-Labors unter der Leitung von William Shockley den ersten...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tief tauchen: vom CSS zum Transistor</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/400363/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vor 70 Jahren, am 16. Dezember 1947, schufen John Bardin und Walter Brattain in den Bell Labs-Labors unter der Leitung von William Shockley den ersten betriebsbereiten Bipolartransistor. </font><font style="vertical-align: inherit;">Am 23. Dezember demonstrierte Brattain seinen Kollegen den ersten Transistorverstärker. </font><font style="vertical-align: inherit;">Daher wird dieser Tag oft als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transistortag bezeichnet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6u/ty/ic/6utyic2_kroyqcpgvrcybtv7kjm.jpeg" alt="Bardin steht links, Brattain steht rechts, Shockley sitzt"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es besteht keine Notwendigkeit, über die Bedeutung dieses Ereignisses zu sprechen. </font><font style="vertical-align: inherit;">Der Transistor gilt als eine der wichtigsten Erfindungen des 20. Jahrhunderts, ohne die Computer noch an Lampen und Relais arbeiten und ganze Gebäude einnehmen würden. </font><font style="vertical-align: inherit;">Shockley, Bardin und Brattain erhielten 1956 für ihre Arbeit den Nobelpreis für Physik. </font><font style="vertical-align: inherit;">Im Laufe der Jahre hat sich der Transistor auf wenige Atome miniaturisiert. </font><font style="vertical-align: inherit;">Jeder Prozessor hat Milliarden von Transistoren, so dass der Transistor als das massereichste Gerät bezeichnet werden kann, das von der Menschheit geschaffen wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber welche Art von Arbeit leistet der Transistor für uns? </font><font style="vertical-align: inherit;">Machen wir eine mentale Reise: Wir werden den Weg von einigen hochrangigen Fingerspitzen bis zu unserem Geburtstag verfolgen - dem Transistor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist als Ausgangspunkt zu nehmen? </font><font style="vertical-align: inherit;">Nun, ziehe wenigstens einen Habrakat-Knopf.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTML und CSS</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Schaltfläche besteht aus Hintergrundpixeln, Text und Rahmen. </font><font style="vertical-align: inherit;">Im Code, der durch das &lt;a&gt; -Tag festgelegt wird, auf das CSS-Layoutregeln angewendet werden. </font><font style="vertical-align: inherit;">Beispielsweise wird eine CSS-Regel auf einen Rand für runde Ecken angewendet:</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">border-radius</span></span>: 3<span class="hljs-selector-tag"><span class="hljs-selector-tag">px</span></span>;</code></pre><img src="https://habrastorage.org/getpro/geektimes/post_images/b36/f41/354/b36f41354796b490cd910c72747da8af.png" alt="Knopa"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Somit besteht die Grenze aus vier Segmenten und vier Bögen ("Viertel" eines Kreises). </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Browser</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für die Recherche habe ich meinen Lieblings-Firefox genommen. </font><font style="vertical-align: inherit;">Bevor FF mit dem Zeichnen unseres Buttons beginnt, muss er viel an der Analyse und Berechnung der Position von Elementen arbeiten:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laden Sie HTML über ein Netzwerk herunter, analysieren Sie es und erstellen Sie einen DOM-Baum</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Download über das CSS-Netzwerk, lexikalische Analyse durchführen, analysieren</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binden Sie Regeln basierend auf Priorität und Vererbung an Seitenelemente</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie für alle sichtbaren DOM-Knoten einen Baum ihrer rechteckigen Bereiche - Rahmen. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berechnen Sie für Frames die Abmessungen und den Standort (siehe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Video</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie Ebenen aus Frames unter Berücksichtigung des Z-Index und des Inhaltstyps (&lt;canvas&gt;, SVG, &lt;video&gt;).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie eine Zeichnungsliste in der Reihenfolge: Hintergrundfarbe, Hintergrundbild, Rahmen, Nachkommen, Umriss.</font></font></li>
</ul><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinzufügen. </font><font style="vertical-align: inherit;">Lesematerial:</font></font></b><div class="spoiler_text"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gecko:Overview</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">How Browsers Work: Behind the scenes of modern web browsers</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   </a><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden nicht im Detail auf diese Schritte eingehen. </font><font style="vertical-align: inherit;">Danach folgt die eigentliche Zeichnung der notwendigen Elemente.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laden Sie die Quelle herunter, um herauszufinden, was dort passiert.</font></font></b><div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  Mozilla Firefox</a>.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>    Firefox  Mercurial  Visual Studio   C++.  VS        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">symbols.mozilla.org</a>.      -  /layout/. <br>
<br>
 ,    ,     ,   Firefox.     c   ,       ,     —         FF.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Datei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nsCSSRenderingBorders.cpp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist für das Zeichnen von Rahmen verantwortlich </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Und die allgemeine Funktion des Zeichnens von Rändern heißt (wer hätte das gedacht): </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DrawBorders ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Die Funktion wählt die optimale Rendermethode für verschiedene Situationen aus. </font><font style="vertical-align: inherit;">Wir haben einen relativ einfachen Fall: Es gibt einen Randradius, aber die Ränder auf allen Seiten sind durchgehend und von derselben Farbe.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unser wenn</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (allBordersSame &amp;&amp;<font></font>
      mCompositeColors[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp;<font></font>
      mBorderStyles[<span class="hljs-number"><span class="hljs-number">0</span></span>] == NS_STYLE_BORDER_STYLE_SOLID &amp;&amp;<font></font>
      !mAvoidStroke &amp;&amp;<font></font>
      !mNoBorderRadius)<font></font>
  {<font></font>
    <span class="hljs-comment"><span class="hljs-comment">// Relatively simple case.</span></span><font></font>
    gfxRect outerRect = ThebesRect(mOuterRect);<font></font>
    <span class="hljs-function"><span class="hljs-function">RoundedRect </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">borderInnerRect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(outerRect, mBorderRadii)</span></span></span></span>;<font></font>
    borderInnerRect.Deflate(mBorderWidths[eSideTop],<font></font>
                            mBorderWidths[eSideBottom],<font></font>
                            mBorderWidths[eSideLeft],<font></font>
                            mBorderWidths[eSideRight]);<font></font>
<font></font>
    <span class="hljs-comment"><span class="hljs-comment">// Instead of stroking we just use two paths: an inner and an outer.</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// This allows us to draw borders that we couldn't when stroking. For example,</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// borders with a border width &gt;= the border radius. (i.e. when there are</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// square corners on the inside)</span></span>
    <span class="hljs-comment"><span class="hljs-comment">//</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// Further, this approach can be more efficient because the backend</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// doesn't need to compute an offset curve to stroke the path. We know that</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// the rounded parts are elipses we can offset exactly and can just compute</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// a new cubic approximation.</span></span><font></font>
    RefPtr&lt;PathBuilder&gt; builder = mDrawTarget-&gt;CreatePathBuilder();<font></font>
    AppendRoundedRectToPath(builder, mOuterRect, mBorderRadii, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);<font></font>
    AppendRoundedRectToPath(builder, ToRect(borderInnerRect.rect), borderInnerRect.corners, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);<font></font>
    RefPtr&lt;Path&gt; path = builder-&gt;Finish();<font></font>
    mDrawTarget-&gt;Fill(path, color);<font></font>
    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;<font></font>
  }<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt viel komplexere Optionen, z. B. das Andocken in Ecken mit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Randradius</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verschiedener Arten von gepunkteten und gestrichelten Rändern, siehe </font><i><font style="vertical-align: inherit;">DrawDashedOrDottedCorner ()</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dort im Code komplett</font></font><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tolle Kommentare</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs">    <span class="hljs-comment"><span class="hljs-comment">//      radius.width</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |&lt;-----------------&gt;|</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |                   |</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |             ___---+-------------</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |         __--     #|#       ###</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |       _-        ##|##     #####</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |     /           ##+##     ##+##</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |   /             # P #     #####</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |  |               #|#       ###</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// | |             __--+-------------</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// ||            _-    ^</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// ||          /       |</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |         /        first dot is filled</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |        |</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |       |</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |      |</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |      |</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |      |</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// +------+</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |##  ##|</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |##  ##|</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |##  ##|</span></span>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber zurück zu unserem Wenn. </font><font style="vertical-align: inherit;">Aus dem Kommentar erfahren wir, dass in diesem Fall der Rand mit zwei Rechtecken gezeichnet wird - intern und extern, dann wird der erstellte Pfad (Pfad) mit der gewünschten Farbe gefüllt.</font></font><br>
<br>
<pre><code class="cpp hljs">AppendRoundedRectToPath(builder, mOuterRect, mBorderRadii, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);<font></font>
AppendRoundedRectToPath(builder, ToRect(borderInnerRect.rect), borderInnerRect.corners, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);<font></font>
RefPtr&lt;Path&gt; path = builder-&gt;Finish();<font></font>
mDrawTarget-&gt;Fill(path, color);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gehen Sie zu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AppendRoundedRectToPath ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in gfx / 2d / PathHelpers.cpp.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wieder setzen wir Haltepunkte</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/getpro/geektimes/post_images/4cd/ab2/6a9/4cdab26a931ee33578231106b0bbf354.png" alt="a9430-clip-21kb"><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir lernen aus dem Kommentar zur Funktion, dass die Ecken an vier Kontrollpunkten durch </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bezier-Kurven</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gezeichnet werden </font><font style="vertical-align: inherit;">. Bezier-Kurven werden häufig in Computergrafiken verwendet, unter anderem zum Zeichnen von Kreisbögen und Ellipsen. Wie wir weiter aus dem Kommentar erfahren, gibt es viele Möglichkeiten, Kontrollpunkte für die Erstellung einer Kurve auszuwählen. In diesem Fall müssen die Punkte 0 und 3 zu den Seiten des Rechtecks ​​gehören, die Punkte 0, 1 und C liegen auf einer geraden Linie, die Punkte 3, 2 und C auf der anderen. Siehe Abbildung: </font></font><br>
<br>
<img src="https://habrastorage.org/files/9d2/6f9/e3a/9d26f9e3a86b42b09fe5fc35be1880a2.png" alt="Mozilla abgerundete Grenze Bezierkurve"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es bleibt uns überlassen, das Verhältnis der Längen der Segmente 01 / 0C und 32 / 3C zu berechnen. Hier verwenden die Autoren ungefähre Berechnungen und erhalten die magische Konstante Alpha:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Float alpha = Float(<span class="hljs-number"><span class="hljs-number">0.55191497064665766025</span></span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider sind Artikel mit dem Checkpoint-Auswahlalgorithmus, auf den der Kommentar verweist, nicht gemeinfrei. </font><font style="vertical-align: inherit;">Im Allgemeinen sollte jedoch beachtet werden, dass Algorithmen in der Computergrafik häufig eine Approximation verwenden, um die Leistung zu verbessern. </font><font style="vertical-align: inherit;">Mit dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brezenham-Algorithmus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> können Sie beispielsweise Segmente und Kreise nicht „in der Stirn“ zeichnen - indem Sie die Gleichungen y = f (x) lösen, sondern mit schlaueren ganzzahligen Operationen. </font><font style="vertical-align: inherit;">Gleiches gilt für Füllung usw. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weiter im Zyklus gehen wir von Ecke zu Ecke, verwenden Alpha, um die Koordinaten der Kontrollpunkte zu berechnen, und rufen schließlich die Funktionen zum Zeichnen der Grenzlinie und des Eckbogens auf:</font></font><br>
<br>
<pre><code class="cpp hljs">aPathBuilder-&gt;LineTo(p0);<font></font>
aPathBuilder-&gt;BezierTo(p1, p2, p3); </code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinzufügen. </font><font style="vertical-align: inherit;">Lesematerial</font></font></b><div class="spoiler_text"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> :       </a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> Javascript:     </a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cairo vs. Skia</a><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vollständiger AppendRoundedRectToPath () Code</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">
</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AppendRoundedRectToPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PathBuilder* aPathBuilder,
                        </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Rect&amp; aRect,
                        </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> RectCornerRadii&amp; aRadii,
                        </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aDrawClockwise)</span></span></span><span class="hljs-function">
</span></span>{
  <span class="hljs-comment"><span class="hljs-comment">// For CW drawing, this looks like:</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//  ...******0**      1    C</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//              ****</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//                  ***    2</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//                     **</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//                       *</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//                        *</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//                         3</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//                         *</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//                         *</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// Where 0, 1, 2, 3 are the control points of the Bezier curve for</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// the corner, and C is the actual corner point.</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// At the start of the loop, the current point is assumed to be</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// the point adjacent to the top left corner on the top</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// horizontal.  Note that corner indices start at the top left and</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// continue clockwise, whereas in our loop i = 0 refers to the top</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// right corner.</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// When going CCW, the control points are swapped, and the first</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// corner that's drawn is the top left (along with the top segment).</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// There is considerable latitude in how one chooses the four</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// control points for a Bezier curve approximation to an ellipse.</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// For the overall path to be continuous and show no corner at the</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// endpoints of the arc, points 0 and 3 must be at the ends of the</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// straight segments of the rectangle; points 0, 1, and C must be</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// collinear; and points 3, 2, and C must also be collinear.  This</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// leaves only two free parameters: the ratio of the line segments</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// 01 and 0C, and the ratio of the line segments 32 and 3C.  See</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// the following papers for extensive discussion of how to choose</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// these ratios:</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//   Dokken, Tor, et al. "Good approximation of circles by</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//      curvature-continuous Bezier curves."  Computer-Aided</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//      Geometric Design 7(1990) 33--41.</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//   Goldapp, Michael. "Approximation of circular arcs by cubic</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//      polynomials." Computer-Aided Geometric Design 8(1991) 227--238.</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//   Maisonobe, Luc. "Drawing an elliptical arc using polylines,</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//      quadratic, or cubic Bezier curves."</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//      http://www.spaceroots.org/documents/ellipse/elliptical-arc.pdf</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// We follow the approach in section 2 of Goldapp (least-error,</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// Hermite-type approximation) and make both ratios equal to</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//          2   2 + n - sqrt(2n + 28)</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//  alpha = - * ---------------------</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//          3           n - 4</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// where n = 3( cbrt(sqrt(2)+1) - cbrt(sqrt(2)-1) ).</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// This is the result of Goldapp's equation (10b) when the angle</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// swept out by the arc is pi/2, and the parameter "a-bar" is the</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// expression given immediately below equation (21).</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// Using this value, the maximum radial error for a circle, as a</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// fraction of the radius, is on the order of 0.2 x 10^-3.</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// Neither Dokken nor Goldapp discusses error for a general</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// ellipse; Maisonobe does, but his choice of control points</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// follows different constraints, and Goldapp's expression for</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// 'alpha' gives much smaller radial error, even for very flat</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// ellipses, than Maisonobe's equivalent.</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// For the various corners and for each axis, the sign of this</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// constant changes, or it might be 0 -- it's multiplied by the</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// appropriate multiplier from the list before using.</span></span><font></font>
<font></font>
  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Float alpha = Float(<span class="hljs-number"><span class="hljs-number">0.55191497064665766025</span></span>);<font></font>
<font></font>
  <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> Float a, b; } twoFloats;<font></font>
<font></font>
  twoFloats cwCornerMults[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { { <span class="hljs-number"><span class="hljs-number">-1</span></span>,  <span class="hljs-number"><span class="hljs-number">0</span></span> },    <span class="hljs-comment"><span class="hljs-comment">// cc == clockwise</span></span>
                                 {  <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span> },<font></font>
                                 { +<span class="hljs-number"><span class="hljs-number">1</span></span>,  <span class="hljs-number"><span class="hljs-number">0</span></span> },<font></font>
                                 {  <span class="hljs-number"><span class="hljs-number">0</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span> } };<font></font>
  twoFloats ccwCornerMults[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { { +<span class="hljs-number"><span class="hljs-number">1</span></span>,  <span class="hljs-number"><span class="hljs-number">0</span></span> },   <span class="hljs-comment"><span class="hljs-comment">// ccw == counter-clockwise</span></span>
                                  {  <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span> },<font></font>
                                  { <span class="hljs-number"><span class="hljs-number">-1</span></span>,  <span class="hljs-number"><span class="hljs-number">0</span></span> },<font></font>
                                  {  <span class="hljs-number"><span class="hljs-number">0</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span> } };<font></font>
<font></font>
  twoFloats *cornerMults = aDrawClockwise ? cwCornerMults : ccwCornerMults;<font></font>
<font></font>
  Point cornerCoords[] = { aRect.TopLeft(), aRect.TopRight(),<font></font>
                           aRect.BottomRight(), aRect.BottomLeft() };<font></font>
<font></font>
  Point pc, p0, p1, p2, p3;<font></font>
<font></font>
  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (aDrawClockwise) {<font></font>
    aPathBuilder-&gt;MoveTo(Point(aRect.X() + aRadii[RectCorner::TopLeft].width,<font></font>
                               aRect.Y()));<font></font>
  } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {<font></font>
    aPathBuilder-&gt;MoveTo(Point(aRect.X() + aRect.Width() - aRadii[RectCorner::TopRight].width,<font></font>
                               aRect.Y()));<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i) {
    <span class="hljs-comment"><span class="hljs-comment">// the corner index -- either 1 2 3 0 (cw) or 0 3 2 1 (ccw)</span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = aDrawClockwise ? ((i+<span class="hljs-number"><span class="hljs-number">1</span></span>) % <span class="hljs-number"><span class="hljs-number">4</span></span>) : ((<span class="hljs-number"><span class="hljs-number">4</span></span>-i) % <span class="hljs-number"><span class="hljs-number">4</span></span>);<font></font>
<font></font>
    <span class="hljs-comment"><span class="hljs-comment">// i+2 and i+3 respectively.  These are used to index into the corner</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// multiplier table, and were deduced by calculating out the long form</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// of each corner and finding a pattern in the signs and values.</span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i2 = (i+<span class="hljs-number"><span class="hljs-number">2</span></span>) % <span class="hljs-number"><span class="hljs-number">4</span></span>;
    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i3 = (i+<span class="hljs-number"><span class="hljs-number">3</span></span>) % <span class="hljs-number"><span class="hljs-number">4</span></span>;<font></font>
<font></font>
    pc = cornerCoords[c];<font></font>
<font></font>
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (aRadii[c].width &gt; <span class="hljs-number"><span class="hljs-number">0.0</span></span> &amp;&amp; aRadii[c].height &gt; <span class="hljs-number"><span class="hljs-number">0.0</span></span>) {<font></font>
      p0.x = pc.x + cornerMults[i].a * aRadii[c].width;<font></font>
      p0.y = pc.y + cornerMults[i].b * aRadii[c].height;<font></font>
<font></font>
      p3.x = pc.x + cornerMults[i3].a * aRadii[c].width;<font></font>
      p3.y = pc.y + cornerMults[i3].b * aRadii[c].height;<font></font>
<font></font>
      p1.x = p0.x + alpha * cornerMults[i2].a * aRadii[c].width;<font></font>
      p1.y = p0.y + alpha * cornerMults[i2].b * aRadii[c].height;<font></font>
<font></font>
      p2.x = p3.x - alpha * cornerMults[i3].a * aRadii[c].width;<font></font>
      p2.y = p3.y - alpha * cornerMults[i3].b * aRadii[c].height;<font></font>
<font></font>
      aPathBuilder-&gt;LineTo(p0);<font></font>
      aPathBuilder-&gt;BezierTo(p1, p2, p3);<font></font>
    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {<font></font>
      aPathBuilder-&gt;LineTo(pc);<font></font>
    }<font></font>
  }<font></font>
<font></font>
  aPathBuilder-&gt;Close();<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber dann hängt alles vom Backend der 2D-Grafiken ab, die Mozilla verwendet. </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grafik-Engine</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gecko verwendet die plattformunabhängige Moz2D-Bibliothek, die wiederum eines der Backends verwenden kann: Cairo, Skia, Direct2D, Quartz und NV Path. </font><font style="vertical-align: inherit;">Zum Beispiel sind Direct2D, Cairo, Skia für Windows verfügbar. </font><font style="vertical-align: inherit;">Skia ist auch das Chromium-Backend. </font><font style="vertical-align: inherit;">Sie können das Backend in about: config ändern. </font><font style="vertical-align: inherit;">Die Backends können wiederum alles auf der CPU lesen oder die GPU-Hardwarebeschleunigung in gewissem Umfang nutzen. </font><font style="vertical-align: inherit;">Zum Beispiel hat Skia ein eigenes OpenGL-Backend - Ganesh. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Direct2D-Code ist geschlossen, daher sollten wir Skia besser einschalten und sehen, was es tut. </font><font style="vertical-align: inherit;">Die Funktion zum Zeichnen einer kubischen Kurve SkPath :: cubicTo wird aufgerufen. </font><font style="vertical-align: inherit;">Um eine Kurve zu </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erstellen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wird sie vom </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">de Castelljo-Algorithmus</font></a><font style="vertical-align: inherit;"> in mehrere gerade Segmente unterteilt, die tatsächlich gezeichnet werden (siehe core / SkGeometry.cpp).</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinzufügen. </font><font style="vertical-align: inherit;">Lesematerial</font></font></b><div class="spoiler_text"><a href=""> skia/src/core/SkGeometry.cpp</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Adaptive Subdivision of Bezier Curves<br>
</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Performance Of Bézier Curves Rendering In Web Browsers</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Software vs. GPU rasterization in Chromium</a><br>
</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maschinencode</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um ehrlich zu sein, habe ich es nicht geschafft, die Skia-Interna vollständig zu verstehen, also bin ich einen Schritt zurückgegangen - zu AppendRoundedRectToPath (), wo alle Operationen mit ganzen Zahlen ausgeführt werden - was könnte einfacher sein? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir den zerlegten Code geöffnet haben, müssen wir die Additionsoperation darin finden.</font></font><br>
<br>
<pre><code class="hljs powershell">...
<span class="hljs-number"><span class="hljs-number">142</span></span>B1863 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>                add         byte ptr [<span class="hljs-type"><span class="hljs-type">eax</span></span>],al  
<span class="hljs-number"><span class="hljs-number">142</span></span>B1865 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>D <span class="hljs-number"><span class="hljs-number">43</span></span> FF <span class="hljs-number"><span class="hljs-number">0</span></span>F <span class="hljs-number"><span class="hljs-number">84</span></span>    add         byte ptr [<span class="hljs-type"><span class="hljs-type">ebp</span></span>-<span class="hljs-number"><span class="hljs-number">7</span></span><span class="hljs-type"><span class="hljs-type">BF000BDh</span></span>],cl  
<span class="hljs-number"><span class="hljs-number">142</span></span>B186B <span class="hljs-number"><span class="hljs-number">67</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>             add         dword ptr [<span class="hljs-type"><span class="hljs-type">bx</span></span>+<span class="hljs-type"><span class="hljs-type">si</span></span>],eax  
<span class="hljs-number"><span class="hljs-number">142</span></span>B186E <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">99</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>F <span class="hljs-number"><span class="hljs-number">57</span></span> C9 F7    add         byte ptr [<span class="hljs-type"><span class="hljs-type">ecx</span></span>-<span class="hljs-number"><span class="hljs-number">836</span></span><span class="hljs-type"><span class="hljs-type">A8F1h</span></span>],bl  
<span class="hljs-number"><span class="hljs-number">142</span></span>B1874 F9                   stc  
<span class="hljs-number"><span class="hljs-number">142</span></span>B1875 <span class="hljs-number"><span class="hljs-number">8</span></span>B C3                mov         eax,ebx  
<span class="hljs-number"><span class="hljs-number">142</span></span>B1877 <span class="hljs-number"><span class="hljs-number">8</span></span>B CA                mov         ecx,edx  
<span class="hljs-number"><span class="hljs-number">142</span></span>B1879 <span class="hljs-number"><span class="hljs-number">99</span></span>                   cdq  
<span class="hljs-number"><span class="hljs-number">142</span></span>B187A F7 <span class="hljs-number"><span class="hljs-number">7</span></span>C <span class="hljs-number"><span class="hljs-number">24</span></span> <span class="hljs-number"><span class="hljs-number">28</span></span>          idiv        eax,dword ptr [<span class="hljs-type"><span class="hljs-type">esp</span></span>+<span class="hljs-number"><span class="hljs-number">28</span></span><span class="hljs-type"><span class="hljs-type">h</span></span>]  <font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ja! Sogar eine Person, die so weit von ASM entfernt ist, wie ich leicht erraten kann, dass die ADD-Operation für die Hinzufügung verantwortlich ist. Nehmen Sie die erste Operation vor: </font></font><br>
<br>
<code>142B1863 00 00 add byte ptr [eax],al </code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0x142B1863 - Adresse im RAM </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0x00 - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opcode</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Prozessorbefehlscode. Dieser unter x86 kompilierte Mozilla und das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Öffnen der x86-Befehlstabelle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> werden sehen, dass Code 00 eine 8-Bit-Additionsoperation mit ADD-Mnemonik bedeutet. Der erste Operand kann ein Register oder eine Direktzugriffsspeicherzelle sein, der zweite kann ein Register sein. Der erste Operand wird zum zweiten hinzugefügt, das Ergebnis wird zum ersten geschrieben. Ich werde nur für den Fall erklären, dass das Register ein ultraschneller RAM-Speicher im Prozessor ist, zum Beispiel zum Speichern von Zwischenberechnungsergebnissen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das zweite Byte ist ebenfalls 0x00 und heißt </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MOD-REG-R / M.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Seine Bits geben die Operanden und die Adressierungsmethode an. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/09d/264/86f/09d26486fdeabed7c7d258cadfea7cc3.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MOD = 00b in Kombination mit R / M = 000b bedeutet, dass </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indirekte Adressierung verwendet wird.</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
REG = 000b bedeutet, dass das AL-Register verwendet wird (die unteren 8 Bits des EAX-Registers) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[eax] - zeigt an, dass die Addition mit der RAM-Zelle erfolgt. deren Adresse befindet sich im EAX-Register. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie verarbeitet der Prozessor den ADD-Befehl?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Basierend auf der Beschreibung der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skylake-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mikroarchitektur habe </font><font style="vertical-align: inherit;">ich eine (extrem vereinfachte) Liste von Schritten zusammengestellt:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X86-Befehle werden aus einem 32-KB-L1-Befehls-Cache in einen 16-Byte-Vorcodierungspuffer abgerufen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die vorcodierten Befehle sind in der Anweisungswarteschlange (2 x 25) organisiert und gelangen in die Decoder</font></font></li>
<li>  x86   1-4   (µOPs).  ADD  1 µOP  ALU (- )  2 µOP  AGU (  ) (<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.</a>,    ).           86      .</li>
<li>   Allocation Queue (IDQ).    ,   Loop Stream Detector —     .</li>
<li> :     ,      .              .   .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Mikrooperation geht an den Unified Scheduler-Manager, der entscheidet, an welchem ​​Punkt und an welchem ​​Port Operationen zur Ausführung außerhalb der Empfangsreihenfolge gesendet werden sollen. </font><font style="vertical-align: inherit;">Hinter jedem Anschluss befindet sich ein Aktuator. </font><font style="vertical-align: inherit;">Unsere Mikrooperationen werden an ALU und AGU gehen.</font></font></li>
</ol><br>
<img src="https://habrastorage.org/webt/xs/is/ij/xsisijruqtk6obopjmtkgx-fm7o.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Kern von SkyLake. </font><font style="vertical-align: inherit;">Bild von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.wikichip.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich wiederhole, dies ist meine sehr vereinfachte Beschreibung und gibt nicht vor, genau und vollständig zu sein. </font><font style="vertical-align: inherit;">Als weitere Referenz empfehle ich, den Beitrag </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reise durch den Computerprozessor-Prozessor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und den Artikel </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Prozessoren aus der Intel Core i7-Familie zu</font></a><font style="vertical-align: inherit;"> lesen</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ALU</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt wäre es interessant zu wissen, was in ALU passiert: Wie addieren sich die Zahlen? Leider sind Informationen zur spezifischen Implementierung von Mikroarchitektur und ALU Intels Geschäftsgeheimnis, daher wenden wir uns später der Theorie zu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Vorrichtung zum Hinzufügen von zwei Binärbits (d. H. Einem Bit) wird als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Addierer bezeichnet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Die Ausgabe ist das Summen- und Übertragsbit. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/un/ic/bx/unicbxzbhpwhf79hla4ssznt9rw.gif"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quelle: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Seit Im wirklichen Leben müssen wir Zahlen hinzufügen, die aus mehreren Ziffern bestehen. Der Addierer muss auch das Übertragsbit der vorherigen Ziffer als Eingabe akzeptieren. Ein solcher Addierer heißt </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">voll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/so/vw/jl/sovwjlxnsewbnpv5grlt8ii29_c.gif"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quelle: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wie aus der Abbildung ersichtlich, besteht der Addierer aus logischen Elementen: XOR, AND, OR. Und jedes logische Element</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit mehreren Transistoren </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">implementiert</font></a><font style="vertical-align: inherit;"> werden. Oder sogar ein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relais</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/355/ccc/357/355ccc357f77c624fc089e5513679985.jpg" alt="Mattausch, CMOS Design, H20 / 6/6"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine beispielhafte Implementierung eines Volladdierers auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMOS-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transistoren. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Also sind wir zum Transistor gekommen! Natürlich arbeiten nicht nur ALUs mit Transistoren, sondern auch mit anderen Prozessoreinheiten, aber die meisten Transistoren werden im Cache als Zellen verwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Realität kann die Addiererschaltung in unserem Prozessor anders aufgebaut und viel komplizierter sein. Zum Beispiel konnte Intel 8008 bereits vor 45 Jahren alle Übertragsbits im Voraus berechnen, um eine Addition parallel durchzuführen (der sogenannte Addierer mit parallelem Übertrag). Wen kümmert es, lesen Sie den interessanten </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Blog-</font></a><font style="vertical-align: inherit;"> Beitrag über Reverse Engineering ALU Intel 8008 im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blog</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ken Shirriff. </font><font style="vertical-align: inherit;">Das heißt, </font><font style="vertical-align: inherit;">Es werden verschiedene Optimierungen verwendet: Zum Beispiel ist die Multiplikation auch </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorteilhaft,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wenn sie nicht „frontal“ durchgeführt wird.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlussfolgerungen: Was haben wir gelernt?</font></font></h3><br>
<ul>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alles ist schwierig</font></font></i></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird deutlich gezeigt: Um das Problem der übermäßigen Komplexität zu lösen, verwenden Ingenieure die Aufteilung komplexer Systeme in Ebenen (Ebenen).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mehrstufige Architekturen bieten Portabilität: Firefox kann beispielsweise auf verschiedenen Betriebssystemen und auf unterschiedlicher Hardware ausgeführt werden.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Interaktion zwischen den Ebenen beruht auf der Offenheit der Spezifikationen für Schnittstellen, Dienste und Datenformate, z. B. HTML und CSS, C ++, eine Reihe von x86-Befehlen usw.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unser Held des Tages arbeitet ganz unten - ein </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transistor</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PS </font><font style="vertical-align: inherit;">Ich bin ein Amateur (Webentwickler) und kenne die C ++ -, ASM- und BT-Architektur ziemlich gut - vom Institutskurs aus könnte ich etwas durcheinander bringen. </font><font style="vertical-align: inherit;">Bitte zögern Sie nicht, Kommentare zu senden.</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de400363/">https://habr.com/ru/post/de400363/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de400351/index.html">KFC Smart Restaurant in China errät Besucherpräferenzen nach Gesicht</a></li>
<li><a href="../de400355/index.html">Amazon Crowdsourcing: Wie eine halbe Million Menschen einen Cent für KI-Training bekommen</a></li>
<li><a href="../de400357/index.html">Google zeigt ein dreifaches Wohltätigkeitsmuster</a></li>
<li><a href="../de400359/index.html">Propriozeption für Laien. Teil 3. Dynamisches Sitzen auf einem Stuhl</a></li>
<li><a href="../de400361/index.html">Foreve Elon 2016/2017 (Silvester online)</a></li>
<li><a href="../de400365/index.html">Was VKontakte-Nutzer 2017 versprechen</a></li>
<li><a href="../de400367/index.html">Was am Wochenende zu tun ist: Fernbedienungs-Gegensprechanlage, budgetloses Remapping Nextion, Showdown mit Onlaym</a></li>
<li><a href="../de400371/index.html">2017 ist nicht nur ein Prime ...</a></li>
<li><a href="../de400377/index.html">Übersicht über aktuelle 3D-Materialien</a></li>
<li><a href="../de400379/index.html">Wie wir die Quest in Telegram arrangiert haben und was daraus wurde. UPD: Wir haben die Ergebnisse des Wettbewerbs zusammengefasst</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>