<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ö†Ô∏è ü§® üôåüèΩ MVCC-3. Versi baris üõ•Ô∏è üßëüèæ üë©üèø‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jadi, kami melihat masalah yang berkaitan dengan isolasi dan membuat penyimpangan tentang pengorganisasian data pada tingkat rendah . Dan akhirnya sam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-3. Versi baris</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/445820/">  Jadi, kami melihat masalah yang berkaitan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">isolasi</a> dan membuat penyimpangan tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengorganisasian data pada tingkat rendah</a> .  Dan akhirnya sampai ke yang paling menarik - ke versi garis. <br><br><h1>  Berita utama </h1><br>  Seperti yang telah kami katakan, setiap baris dapat secara bersamaan hadir dalam database dalam beberapa versi.  Satu versi harus dibedakan dari yang lain, untuk tujuan ini, setiap versi memiliki dua tanda yang menentukan "waktu" dari tindakan versi ini (xmin dan xmax).  Dalam tanda kutip - karena bukan waktu yang digunakan seperti itu, tetapi penghitung kenaikan khusus.  Dan penghitung ini adalah nomor transaksi. <br><br>  (Seperti biasa, ini sebenarnya lebih rumit: jumlah transaksi tidak dapat bertambah setiap saat karena kapasitas bit counter yang terbatas. Tetapi kami akan mempertimbangkan detail ini secara terperinci ketika kami sampai di pembekuan.) <br><a name="habracut"></a><br>  Ketika garis dibuat, xmin diatur ke jumlah transaksi yang dieksekusi perintah INSERT, dan xmax tidak terisi. <br><br>  Ketika satu baris dihapus, nilai xmax dari versi saat ini ditandai dengan nomor transaksi yang dilakukan HAPUS. <br><br>  Ketika sebuah baris dimodifikasi dengan perintah UPDATE, dua operasi sebenarnya dilakukan: HAPUS dan INSERT.  Dalam versi baris saat ini, xmax diset sama dengan jumlah transaksi yang melakukan UPDATE.  Kemudian versi baru dari baris yang sama dibuat;  nilainya xmin cocok dengan nilai xmax dari versi sebelumnya. <br><br>  Bidang xmin dan xmax termasuk dalam header versi baris.  Selain bidang ini, tajuk berisi yang lain, misalnya: <br><br><ul><li>  infomask - serangkaian bit yang mendefinisikan properti versi ini.  Ada cukup banyak dari mereka;  yang utama akan kita pertimbangkan secara bertahap. </li><li>  ctid - tautan ke versi berikutnya yang lebih baru dari baris yang sama.  Dalam versi terbaru, string terbaru, ctid merujuk ke versi ini sendiri.  Angka memiliki bentuk (x, y), di mana x adalah nomor halaman, y adalah nomor seri dari penunjuk dalam array. </li><li>  bitmap dari nilai yang tidak ditentukan - menandai kolom-kolom dari versi ini yang berisi nilai yang tidak ditentukan (NULL).  NULL bukan salah satu nilai tipe data yang biasa, jadi atribut harus disimpan secara terpisah. </li></ul><br>  Akibatnya, tajuknya cukup besar - setidaknya 23 byte per versi string, dan biasanya lebih karena bitmap NULL.  Jika tabelnya "sempit" (artinya, memuat beberapa kolom), overhead mungkin memerlukan lebih dari informasi yang berguna. <br><br><h1>  Masukkan </h1><br>  Mari kita lihat lebih dekat bagaimana operasi string dilakukan pada level rendah, dan mulai dengan insert. <br><br>  Untuk percobaan, buat tabel baru dengan dua kolom dan indeks pada salah satunya: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">text</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> t(s);</code> </pre> <br>  Masukkan satu baris, setelah memulai transaksi. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'FOO'</span></span>);</code> </pre><br>  Inilah jumlah transaksi kami saat ini: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3664 (1 row)</code> </pre><br>  Lihatlah isi halaman.  Fungsi heap_page_items dari ekstensi pageinspect menyediakan informasi tentang pointer dan versi baris: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------------------- lp | 1 lp_off | 8160 lp_flags | 1 lp_len | 32 t_xmin | 3664 t_xmax | 0 t_field3 | 0 t_ctid | (0,1) t_infomask2 | 2 t_infomask | 2050 t_hoff | 24 t_bits | t_oid | t_data | \x0100000009464f4f</code> </pre><br>  Perhatikan bahwa kata heap (heap) di PostgreSQL mengacu pada tabel.  Ini adalah penggunaan aneh dari istilah - heap adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">struktur data</a> terkenal yang tidak ada hubungannya dengan tabel.  Di sini, kata ini digunakan dalam arti "semuanya bertumpuk," berbeda dengan indeks yang dipesan. <br><br>  Fungsi ini menampilkan data "apa adanya" dalam format yang sulit dibaca.  Untuk memahami, kami hanya akan meninggalkan sebagian informasi dan mendekripsi: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'(0,'</span></span>||lp||<span class="hljs-string"><span class="hljs-string">')'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ctid, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> lp_flags <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'unused'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'normal'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'redirect to '</span></span>||lp_off <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'dead'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> state, t_xmin <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmin, t_xmax <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmax, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">256</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmin_commited, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">512</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmin_aborted, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">1024</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmax_commited, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">2048</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmax_aborted, t_ctid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]-+------- ctid | (0,1) state | normal xmin | 3664 xmax | 0 xmin_commited | f xmin_aborted | f xmax_commited | f xmax_aborted | t t_ctid | (0,1)</code> </pre><br>  Inilah yang kami lakukan: <br><br><ul><li>  Kami menambahkan nol ke nomor indeks untuk membawanya ke bentuk yang sama dengan t_ctid: (nomor halaman, nomor indeks). </li><li>  Mendekripsi status pointer lp_flags.  Ini dia "normal" - ini berarti bahwa pointer benar-benar merujuk pada versi string.  Nilai-nilai lain akan dipertimbangkan nanti. </li><li>  Dari semua bit informasi, sejauh ini hanya dua pasangan telah dialokasikan.  Bit xmin_committed dan xmin_aborted menunjukkan apakah transaksi dengan nomor xmin dilakukan (dibatalkan).  Dua bit serupa merujuk ke nomor transaksi xmax. </li></ul><br>  Apa yang kita lihat  Saat Anda menyisipkan baris di halaman tabel, sebuah pointer muncul dengan nomor 1, merujuk pada versi pertama dan satu-satunya dari baris. <br><br>  Dalam versi baris, bidang xmin diisi dengan jumlah transaksi saat ini.  Transaksi masih aktif, sehingga kedua bit xmin_committed dan xmin_aborted tidak disetel. <br><br>  Bidang ctid dari versi baris merujuk ke baris yang sama.  Ini berarti bahwa versi yang lebih baru tidak ada. <br><br>  Bidang xmax diisi dengan angka dummy 0, karena versi baris ini tidak dihapus dan relevan.  Transaksi tidak akan memperhatikan nomor ini, karena bit xmax_aborted diatur. <br><br>  Mari kita mengambil satu langkah lagi untuk meningkatkan keterbacaan dengan menambahkan bit informasi ke nomor transaksi.  Dan kami akan membuat fungsi, karena kami akan membutuhkan permintaan lebih dari sekali: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> heap_page(relname <span class="hljs-type"><span class="hljs-type">text</span></span>, pageno <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>(ctid tid, state <span class="hljs-type"><span class="hljs-type">text</span></span>, xmin <span class="hljs-type"><span class="hljs-type">text</span></span>, xmax <span class="hljs-type"><span class="hljs-type">text</span></span>, t_ctid tid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> (pageno,lp)::</span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">text</span></span></span><span class="pgsql">::tid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> ctid, </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> lp_flags </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'unused'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'normal'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'redirect to '</span></span></span><span class="pgsql">||lp_off </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">3</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'dead'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> state, t_xmin || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmin, t_xmax || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1024</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2048</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmax, t_ctid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> heap_page_items(get_raw_page(relname,pageno)) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ORDER</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BY</span></span></span><span class="pgsql"> lp; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>;</code> </pre><br>  Dalam bentuk ini, jauh lebih jelas apa yang terjadi di header versi string: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3664 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Serupa, tetapi secara substansial kurang terperinci, informasi dapat diperoleh dari tabel itu sendiri, menggunakan pseudo-kolom xmin dan xmax: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3664 | 0 | 1 | FOO (1 row)</code> </pre><br><h1>  Fiksasi </h1><br>  Setelah berhasil menyelesaikan transaksi, Anda perlu mengingat statusnya - perhatikan bahwa itu sudah diperbaiki.  Untuk melakukan ini, gunakan struktur yang disebut XACT (dan sebelum versi 10 itu disebut CLOG (commit log) dan nama ini masih dapat ditemukan di tempat yang berbeda). <br><br>  XACT bukan tabel katalog sistem;  Ini adalah file dalam direktori PGDATA / pg_xact.  Di dalamnya, untuk setiap transaksi, dua bit dialokasikan: dikomit dan dibatalkan - persis sama seperti di header versi baris.  Informasi ini dibagi menjadi beberapa file semata-mata untuk kenyamanan, kami akan kembali ke masalah ini ketika kami mempertimbangkan pembekuan.  Dan bekerja dengan file-file ini dilakukan halaman demi halaman, seperti yang lainnya. <br><br>  Jadi, ketika melakukan transaksi dalam XACT, bit yang berkomitmen ditetapkan untuk transaksi ini.  Dan hanya itu yang terjadi selama komit (meskipun kita belum berbicara tentang jurnal prarekam belum). <br><br>  Ketika transaksi lain mengakses halaman tabel yang baru saja kita lihat, dia harus menjawab beberapa pertanyaan. <br><br><ol><li>  Sudahkah transaksi xmin selesai?  Jika tidak, versi string yang dihasilkan tidak akan terlihat. <br>  Pemeriksaan ini dilakukan dengan melihat struktur lain yang terletak di memori bersama instance dan disebut ProcArray.  Ini berisi daftar semua proses aktif, dan untuk setiap jumlah transaksi saat ini (aktif) ditunjukkan. </li><li>  Jika selesai, lalu bagaimana - dengan fiksasi atau pembatalan?  Jika dibatalkan, maka versi string juga tidak akan terlihat. <br>  Inilah tepatnya tujuan XACT.  Tetapi, meskipun halaman XACT terakhir disimpan dalam buffer dalam RAM, tidak perlu memeriksa XACT setiap kali.  Oleh karena itu, status transaksi yang pernah diklarifikasi dicatat dalam bit xmin_committed dan xmin_aborted dari versi baris.  Jika salah satu dari bit ini ditetapkan, maka status transaksi xmin dianggap diketahui dan transaksi berikutnya tidak lagi harus mengakses XACT. </li></ol><br>  Mengapa bit-bit ini tidak disetel oleh transaksi itu sendiri yang melakukan penyisipan?  Ketika memasukkan terjadi, transaksi belum tahu apakah itu akan selesai dengan sukses.  Dan pada saat memperbaikinya sudah tidak jelas baris mana halaman diubah.  Mungkin ada banyak halaman seperti itu, dan menghafalnya tidak menguntungkan.  Selain itu, sebagian halaman dapat didorong keluar dari cache buffer ke disk;  membacanya lagi untuk mengubah bit berarti secara signifikan memperlambat komit. <br><br>  Kelemahan dari penghematan adalah bahwa setelah perubahan, transaksi apa pun (bahkan melakukan pembacaan sederhana - SELECT) dapat mulai mengubah halaman data dalam cache buffer. <br><br>  Jadi, perbaiki perubahan. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Tidak ada yang berubah di halaman (tapi kami tahu bahwa status transaksi sudah dicatat dalam XACT): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3664 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Sekarang transaksi yang pertama kali mengakses halaman harus menentukan status transaksi xmin dan menuliskannya ke bit informasi: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3664 (c) | 0 (a) | (0,1) (1 row)</code> </pre><br><h1>  Hapus </h1><br>  Ketika sebuah baris dihapus, jumlah transaksi penghapusan saat ini dicatat dalam bidang xmax dari versi saat ini, dan bit xmax_aborted di-reset. <br><br>  Perhatikan bahwa nilai xmax set yang terkait dengan transaksi aktif bertindak sebagai kunci baris.  Jika transaksi lain akan memperbarui atau menghapus baris ini, itu akan dipaksa untuk menunggu transaksi xmax selesai.  Kami akan berbicara lebih banyak tentang kunci nanti.  Untuk saat ini, kami hanya mencatat bahwa jumlah kunci baris tidak terbatas.  Mereka tidak menempati tempat dalam RAM dan kinerja sistem tidak menderita dari kuantitasnya.  Benar, transaksi "panjang" memiliki kelemahan lain, tetapi lebih banyak tentang itu nanti. <br><br>  Hapus garis. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3665 (1 row)</code> </pre><br>  Kami melihat bahwa nomor transaksi dicatat di bidang xmax, tetapi bit informasi tidak disetel: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+------+-------- (0,1) | normal | 3664 (c) | 3665 | (0,1) (1 row)</code> </pre><br><h1>  Batalkan </h1><br>  Mengembalikan perubahan berfungsi mirip dengan komit, hanya dalam XACT untuk transaksi bit yang dibatalkan dibatalkan.  Pembatalan secepat komitmen.  Meskipun perintah itu disebut ROLLBACK, perubahan tidak dibatalkan: segala sesuatu yang berhasil diubah oleh transaksi di halaman data tetap tidak berubah. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+------+-------- (0,1) | normal | 3664 (c) | 3665 | (0,1) (1 row)</code> </pre><br>  Saat mengakses halaman, statusnya akan diperiksa dan bit petunjuk xmax_aborted akan disetel dalam versi baris.  Nomor xmax itu sendiri tetap ada di halaman, tetapi tidak ada yang akan melihatnya. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+----------+-------- (0,1) | normal | 3664 (c) | 3665 (a) | (0,1) (1 row)</code> </pre><br><h1>  Perbarui </h1><br>  Pembaruan berfungsi seolah-olah pertama kali menghapus versi baris saat ini, dan kemudian menyisipkan yang baru. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'BAR'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3666 (1 row)</code> </pre><br>  Permintaan menghasilkan satu baris (versi baru): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | BAR (1 row)</code> </pre><br>  Tetapi di halaman kita melihat kedua versi: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3664 (c) | 3666 | (0,2) (0,2) | normal | 3666 | 0 (a) | (0,2) (2 rows)</code> </pre><br>  Versi jarak jauh ditandai dengan nomor transaksi saat ini di bidang xmax.  Selain itu, nilai ini ditulis di atas yang lama, karena transaksi sebelumnya dibatalkan.  Dan bit xmax_aborted di-reset, karena status transaksi saat ini masih belum diketahui. <br><br>  Versi pertama dari baris sekarang merujuk ke yang kedua (bidang t_ctid), sebagai yang lebih baru. <br><br>  Pointer kedua dan baris kedua muncul di halaman indeks, menghubungkan ke versi kedua di halaman tabel. <br><br>  Seperti halnya penghapusan, nilai xmax dalam versi pertama string adalah tanda bahwa string dikunci. <br><br>  Nah, selesaikan transaksi. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Indeks </h1><br>  Sejauh ini, kami hanya berbicara tentang halaman tabular.  Dan apa yang terjadi di dalam indeks? <br><br>  Informasi dalam halaman indeks sangat tergantung pada jenis indeks tertentu.  Dan bahkan satu jenis indeks memiliki berbagai jenis halaman.  Sebagai contoh, B-tree memiliki halaman dengan halaman metadata dan ‚Äúreguler‚Äù. <br><br>  Namun, halaman biasanya memiliki array pointer ke garis dan garis itu sendiri (seperti di halaman tabel).  Selain itu, di akhir halaman ada tempat untuk data khusus. <br><br>  Baris dalam indeks juga dapat memiliki struktur yang sangat berbeda tergantung pada jenis indeks.  Misalnya, untuk B-tree, baris yang terkait dengan halaman daun berisi nilai kunci indeks dan tautan (ctid) ke baris tabel yang sesuai.  Secara umum, indeks dapat diatur dengan cara yang sama sekali berbeda. <br><br>  Poin yang paling penting adalah tidak ada versi baris dalam semua jenis indeks.  Baik, atau kita dapat mengasumsikan bahwa setiap baris diwakili oleh tepat satu versi.  Dengan kata lain, tidak ada bidang xmin dan xmax di header baris indeks.  Kami dapat mengasumsikan bahwa tautan dari indeks mengarah ke semua versi tabular dari baris - jadi Anda hanya bisa mengetahui versi transaksi yang akan dilihat jika Anda melihat tabel.  (Seperti biasa, ini bukan kebenaran keseluruhan. Dalam beberapa kasus, peta visibilitas memungkinkan Anda untuk mengoptimalkan proses, tetapi kami akan mempertimbangkan ini secara lebih rinci nanti.) <br><br>  Pada saat yang sama, di halaman indeks kami menemukan pointer ke kedua versi, baik saat ini dan yang lama: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> itemoffset, ctid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bt_page_items(<span class="hljs-string"><span class="hljs-string">'t_s_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,2) 2 | (0,1) (2 rows)</code> </pre><br><h1>  Transaksi virtual </h1><br>  Dalam praktiknya, PostgreSQL menggunakan optimisasi untuk "menyimpan" nomor transaksi. <br><br>  Jika suatu transaksi hanya membaca data, maka itu tidak mempengaruhi visibilitas versi baris.  Oleh karena itu, pada awalnya, proses penyajian mengeluarkan transaksi nomor virtual (virtual xid).  Angka terdiri dari pengidentifikasi proses dan nomor urut. <br><br>  Penerbitan nomor ini tidak memerlukan sinkronisasi antara semua proses dan karenanya sangat cepat.  Kita akan mengetahui alasan lain untuk menggunakan nomor virtual ketika kita berbicara tentang pembekuan. <br><br>  Nomor virtual tidak diperhitungkan dalam snapshot data. <br><br>  Pada titik waktu yang berbeda, transaksi virtual dengan angka yang telah digunakan mungkin muncul di sistem, dan ini normal.  Tetapi angka seperti itu tidak dapat ditulis ke halaman data, karena saat Anda mengakses halaman berikutnya, itu mungkin kehilangan semua makna. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_if_assigned();</code> </pre><pre> <code class="plaintext hljs"> txid_current_if_assigned -------------------------- (1 row)</code> </pre><br>  Jika transaksi mulai mengubah data, itu diberikan nomor transaksi nyata dan unik. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">1.00</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_if_assigned();</code> </pre><pre> <code class="plaintext hljs"> txid_current_if_assigned -------------------------- 3667 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Transaksi Bersarang </h1><br><h2>  Simpan poin </h2><br>  SQL mendefinisikan savepoint yang memungkinkan Anda untuk membatalkan bagian dari suatu transaksi tanpa mengganggu sepenuhnya.  Tetapi ini tidak cocok dengan skema di atas, karena status transaksi adalah satu untuk semua perubahannya, dan secara fisik tidak ada data yang digulung kembali. <br><br>  Untuk mengimplementasikan fungsi tersebut, transaksi dengan titik penyimpanan dibagi menjadi beberapa <em>transaksi bersarang</em> terpisah (subtransaksi), yang statusnya dapat dikontrol secara terpisah. <br><br>  Transaksi bersarang memiliki nomor sendiri (lebih tinggi dari nomor transaksi utama).  Status transaksi bersarang dicatat dengan cara yang biasa di XACT, namun, status final tergantung pada status transaksi utama: jika dibatalkan, maka semua transaksi yang bersarang juga dibatalkan. <br><br>  Informasi tentang transaksi bersarang disimpan dalam file di direktori PGDATA / pg_subtrans.  File diakses melalui buffer dalam memori bersama dari instance, diatur dengan cara yang sama seperti buffer XACT. <br><br>  Jangan bingung antara transaksi bertingkat dan transaksi otonom.  Transaksi otonom sama sekali tidak bergantung satu sama lain, dan yang bersarang tergantung.  Tidak ada transaksi otonom di PostgreSQL biasa, dan, mungkin, untuk yang lebih baik: dalam kasus mereka sangat diperlukan, sangat jarang, dan kehadiran mereka dalam DBMSs lainnya memprovokasi pelecehan, dari mana semua orang kemudian menderita. <br><br>  Kosongkan tabel, mulai transaksi dan masukkan baris: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'FOO'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3669 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Sekarang letakkan savepoint dan masukkan baris lain. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SAVEPOINT</span></span> sp; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'XYZ'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3669 (1 row)</code> </pre><br>  Perhatikan bahwa fungsi txid_current () mengembalikan jumlah transaksi utama, bukan bersarang. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3670 | 0 | 3 | XYZ (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (0,2) | normal | 3670 | 0 (a) | (0,2) (2 rows)</code> </pre><br>  Kami memutar kembali ke titik penyimpanan dan menyisipkan baris ketiga. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> sp; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'BAR'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3671 | 0 | 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 | 0 (a) | (0,3) (3 rows)</code> </pre><br>  Di halaman, kami terus melihat baris yang ditambahkan oleh transaksi bersarang yang dibatalkan. <br><br>  Kami memperbaiki perubahan. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3671 | 0 | 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 (c) | 0 (a) | (0,1) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 (c) | 0 (a) | (0,3) (3 rows)</code> </pre><br>  Sekarang Anda dapat dengan jelas melihat bahwa setiap transaksi bersarang memiliki statusnya sendiri. <br><br>  Perhatikan bahwa transaksi bersarang tidak dapat digunakan secara eksplisit dalam SQL, yaitu, Anda tidak dapat memulai transaksi baru tanpa menyelesaikan yang saat ini.  Mekanisme ini digunakan secara implisit ketika menggunakan savepoints, dan juga ketika menangani pengecualian PL / pgSQL dan dalam sejumlah kasus lain yang lebih eksotis. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>;</code> </pre><pre> <code class="plaintext hljs">BEGIN</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>;</code> </pre><pre> <code class="plaintext hljs">WARNING: there is already a transaction in progress BEGIN</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">COMMIT</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">WARNING: there is no transaction in progress COMMIT</code> </pre><br><h2>  Kesalahan dan atomitas operasi </h2><br>  Apa yang terjadi jika kesalahan terjadi selama operasi?  Misalnya, seperti ini: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = repeat(<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/(id<span class="hljs-number"><span class="hljs-number">-4</span></span>));</code> </pre><pre> <code class="plaintext hljs">ERROR: division by zero</code> </pre><br>  Telah terjadi kesalahan.  Sekarang transaksi dianggap dibatalkan dan tidak satu operasi pun diizinkan di dalamnya: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs">ERROR: current transaction is aborted, commands ignored until end of transaction block</code> </pre><br>  Dan bahkan jika Anda mencoba melakukan perubahan, PostgreSQL akan melaporkan pembatalan: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">ROLLBACK</code> </pre><br>  Mengapa saya tidak dapat melanjutkan transaksi setelah gagal?  Faktanya adalah bahwa kesalahan dapat terjadi sehingga kita akan mendapatkan akses ke bagian dari perubahan - atomitas bahkan bukan transaksi, tetapi operator akan dilanggar.  Seperti dalam contoh kami, di mana operator berhasil memperbarui satu baris sebelum kesalahan: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 (c) | 3672 | (0,4) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 (c) | 0 (a) | (0,3) (0,4) | normal | 3672 | 0 (a) | (0,4) (4 rows)</code> </pre><br>  Saya harus mengatakan bahwa dalam psql ada mode yang masih memungkinkan Anda untuk melanjutkan transaksi setelah kegagalan, seolah-olah tindakan operator yang salah dibatalkan. <br><br><pre> <code class="pgsql hljs">=&gt; \<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ON_ERROR_ROLLBACK <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = repeat(<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/(id<span class="hljs-number"><span class="hljs-number">-4</span></span>));</code> </pre><pre> <code class="plaintext hljs">ERROR: division by zero</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Sangat mudah untuk menebak bahwa dalam mode ini psql benar-benar menetapkan save point implisit di depan setiap perintah, dan dalam kasus kegagalan itu memulai rollback untuk itu.  Mode ini tidak digunakan secara default, karena pengaturan titik penyimpanan (bahkan tanpa mengembalikannya) dikaitkan dengan overhead signifikan. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Untuk dilanjutkan.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id445820/">https://habr.com/ru/post/id445820/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id445804/index.html">Enkapsulasi untuk samurai asli, atau nuansa yang terkait dengan kata kunci internal di C #</a></li>
<li><a href="../id445806/index.html">Bagaimana kecerdasan buatan mengubah ilmu pengetahuan</a></li>
<li><a href="../id445808/index.html">Kami membenci dan memburu: kehidupan berbahaya seorang cracker virus yang membuat musuh yang kuat</a></li>
<li><a href="../id445814/index.html">Bagaimana robot pengiriman telah mengubah kebiasaan kuliner siswa Amerika</a></li>
<li><a href="../id445816/index.html">Bagaimana kami melihat rendering server dan apa yang terjadi</a></li>
<li><a href="../id445822/index.html">Kenapa Jaop? Mengapa raket?</a></li>
<li><a href="../id445824/index.html">Pembuatan Kode di Dart. Bagian 1. Dasar-dasar</a></li>
<li><a href="../id445826/index.html">Kami berjalan keliling kota dengan bijak - 2: keliling kota dalam lingkaran menggunakan algoritma genetika</a></li>
<li><a href="../id445828/index.html">Spektrum matahari Cina</a></li>
<li><a href="../id445832/index.html">Radiasi: pembunuh tak terlihat dan putri-putrinya atau sedikit tentang radon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>