<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ò∏Ô∏è „äôÔ∏è üèõÔ∏è Kompilierungstypen in der JVM: Aufdecken der Black Magic-Sitzung üå©Ô∏è üêøÔ∏è üìè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! 

 Heute wird Ihre Aufmerksamkeit auf eine √úbersetzung des Artikels gelenkt, die Beispiele f√ºr Kompilierungsoptionen in der JVM zeig...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kompilierungstypen in der JVM: Aufdecken der Black Magic-Sitzung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/466529/">  Hallo allerseits! <br><br>  Heute wird Ihre Aufmerksamkeit auf eine √úbersetzung des Artikels gelenkt, die Beispiele f√ºr Kompilierungsoptionen in der JVM zeigt.  Besonderes Augenmerk wird auf die in Java 9 und h√∂her unterst√ºtzte AOT-Kompilierung gelegt. <br><br>  Viel Spa√ü beim Lesen! <br><a name="habracut"></a><br>  Ich glaube, jeder, der jemals in Java programmiert hat, hat von Instant Compilation (JIT) und m√∂glicherweise Compilation vor der Ausf√ºhrung (AOT) geh√∂rt.  Dar√ºber hinaus muss nicht erkl√§rt werden, was ‚Äûinterpretierte‚Äú Sprachen sind.  In diesem Artikel wird erl√§utert, wie all diese Funktionen in der Java Virtual Machine JVM implementiert sind. <br><br>  Sie wissen wahrscheinlich, dass Sie beim Programmieren in Java einen Compiler (mit dem Programm "javac") ausf√ºhren m√ºssen, der Java-Quellcode (.java-Dateien) in Java-Bytecode (.class-Dateien) sammelt.  Java-Bytecode ist eine Zwischensprache.  Es wird als "Zwischenprodukt" bezeichnet, da es von einem realen Computerger√§t (CPU) nicht verstanden wird und nicht von einem Computer ausgef√ºhrt werden kann und somit eine √úbergangsform zwischen dem Quellcode und dem im Prozessor ausgef√ºhrten "nativen" Maschinencode darstellt. <br><br>  Damit Java-Bytecode eine bestimmte Arbeit ausf√ºhren kann, gibt es drei M√∂glichkeiten, ihn dazu zu bringen: <br><br><ol><li>  F√ºhren Sie den Zwischencode direkt aus.  Es ist besser und korrekter zu sagen, dass es "interpretiert" werden muss.  Die JVM verf√ºgt √ºber einen Java-Interpreter.  Wie Sie wissen, m√ºssen Sie das Programm "Java" ausf√ºhren, damit die JVM funktioniert. </li><li>  Kompilieren Sie den Zwischencode kurz vor der Ausf√ºhrung in nativen Code und zwingen Sie die CPU, diesen frisch gebackenen nativen Code auszuf√ºhren.  Die Kompilierung erfolgt daher unmittelbar vor der Ausf√ºhrung (Just in Time) und wird als ‚Äûdynamisch‚Äú bezeichnet. </li><li>  3Die ersten Schritte, noch bevor das Programm gestartet wird, werden die Zwischencodes in native √ºbersetzt und von Anfang bis Ende durch die CPU ausgef√ºhrt.  Diese Kompilierung erfolgt vor der Ausf√ºhrung und hei√üt AoT (Ahead of Time). </li></ol><br>  (1) ist also die Arbeit des Interpreters, (2) ist das Ergebnis der JIT-Kompilierung und (3) ist das Ergebnis der AOT-Kompilierung. <br><br>  Der Vollst√§ndigkeit halber m√∂chte ich erw√§hnen, dass es einen vierten Ansatz gibt - die direkte Interpretation des Quellcodes, aber in Java wird dies nicht akzeptiert.  Dies geschieht beispielsweise in Python. <br>  Nun wollen wir sehen, wie "Java" als (1) der Interpreter von (2) dem JIT-Compiler und / oder (3) dem AOT-Compiler funktioniert - und wann. <br><br>  Kurz gesagt - in der Regel macht "Java" sowohl (1) als auch (2).  Ab Java 9 ist auch eine dritte Option m√∂glich. <br><br>  Hier ist unsere <code>Test</code> , die in zuk√ºnftigen Beispielen verwendet wird. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { System.out.println(<span class="hljs-string"><span class="hljs-string">"call "</span></span> + Integer.valueOf(i)); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> a = System.nanoTime(); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Test().f(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> b = System.nanoTime(); System.out.println(<span class="hljs-string"><span class="hljs-string">"elapsed= "</span></span> + (ba)); } } }</code> </pre> <br>  Wie Sie sehen k√∂nnen, gibt es eine <code>main</code> , die das Testobjekt instanziiert und die <code>f</code> Funktion zehnmal hintereinander zyklisch aufruft.  Die <code>f</code> Funktion macht fast nichts. <br><br>  Wenn Sie also den obigen Code kompilieren und ausf√ºhren, wird die Ausgabe durchaus erwartet (nat√ºrlich werden die Werte der verstrichenen Zeit f√ºr Sie unterschiedlich ausfallen): <br><br><pre> <code class="plaintext hljs">call 1 elapsed= 5373 call 2 elapsed= 913 call 3 elapsed= 654 call 4 elapsed= 623 call 5 elapsed= 680 call 6 elapsed= 710 call 7 elapsed= 728 call 8 elapsed= 699 call 9 elapsed= 853 call 10 elapsed= 645</code> </pre> <br>  Und jetzt lautet die Frage: Ist diese Schlussfolgerung das Ergebnis der Arbeit von ‚ÄûJava‚Äú als Interpreter, dh Option (1), ‚ÄûJava‚Äú als JIT-Compiler, dh Option (2), oder h√§ngt sie irgendwie mit der AOT-Kompilierung zusammen? das hei√üt, Option (3)?  In diesem Artikel werde ich die richtigen Antworten auf all diese Fragen finden. <br><br>  Die erste Antwort, die ich geben m√∂chte, ist h√∂chstwahrscheinlich, dass hier nur (1) stattfindet.  Ich sage "h√∂chstwahrscheinlich", da ich nicht wei√ü, ob hier eine Umgebungsvariable festgelegt ist, die die Standard-JVM-Optionen √§ndern w√ºrde.  Wenn nichts √úberfl√ºssiges installiert ist und ‚ÄûJava‚Äú standardm√§√üig so funktioniert, beobachten wir hier zu 100% nur Option (1), dh der Code wird vollst√§ndig interpretiert.  Da bin ich mir sicher: <br><br><ul><li>  Gem√§√ü der Java-Dokumentation wird die Option <code>-XX:CompileThreshold=invocations</code> mit den Standardaufrufen <code>invocations=1500</code> auf der Client-JVM ausgef√ºhrt (weitere <code>-XX:CompileThreshold=invocations</code> zur Client-JVM werden unten beschrieben).  Da ich es nur 10 Mal und 10 &lt;1500 ausf√ºhre, sprechen wir hier nicht √ºber dynamische Kompilierung.  In der Regel gibt diese Befehlszeilenoption an, wie oft (maximal) die Funktion interpretiert werden muss, bevor der dynamische Kompilierungsschritt beginnt.  Ich werde weiter unten darauf eingehen. </li><li>  Tats√§chlich habe ich diesen Code mit Diagnoseflags ausgef√ºhrt, sodass ich wei√ü, ob er dynamisch kompiliert wurde.  Ich werde diesen Punkt auch weiter unten erl√§utern. </li></ul><br>  Bitte beachten Sie: JVM kann im Client- oder Servermodus arbeiten, und die standardm√§√üig im ersten und zweiten Fall festgelegten Optionen sind unterschiedlich.  In der Regel wird die Entscheidung √ºber den Startmodus automatisch getroffen, abh√§ngig von der Umgebung oder dem Computer, auf dem die JVM gestartet wurde.  Im Folgenden werde <code>‚Äìclient</code> bei allen Starts die Option <code>‚Äìclient</code> angeben, um nicht zu bezweifeln, dass das Programm im Client-Modus ausgef√ºhrt wird.  Diese Option wirkt sich nicht auf die Aspekte aus, die ich in diesem Beitrag demonstrieren m√∂chte. <br><br>  Wenn Sie "Java" mit der <code>-XX:PrintCompilation</code> das Programm eine Zeile, wenn die Funktion dynamisch kompiliert wird.  Vergessen Sie nicht, dass die JIT-Kompilierung f√ºr jede Funktion separat ausgef√ºhrt wird. Einige Funktionen in der Klasse verbleiben m√∂glicherweise im Bytecode (dh nicht kompiliert), w√§hrend andere m√∂glicherweise bereits die JIT-Kompilierung bestanden haben, dh f√ºr die direkte Ausf√ºhrung im Prozessor bereit sind . <br><br>  Unten f√ºge ich auch die Option <code>-Xbatch</code> .  Die Option <code>-Xbatch</code> nur ben√∂tigt, um die Ausgabe pr√§sentabler zu gestalten.  Andernfalls wird die JIT-Kompilierung (zusammen mit der Interpretation) <code>-XX:PrintCompilation</code> , und die Ausgabe nach der Kompilierung kann zur Laufzeit manchmal seltsam aussehen (aufgrund von <code>-XX:PrintCompilation</code> ).  Die Option <code>‚ÄìXbatch</code> deaktiviert jedoch die Hintergrundkompilierung. Daher wird die Ausf√ºhrung unseres Programms vor dem Ausf√ºhren der JIT-Kompilierung gestoppt. <br><br>  (Aus Gr√ºnden der Lesbarkeit werde ich jede Option aus einer neuen Zeile schreiben.) <br><br><pre> <code class="plaintext hljs">$ java -client -Xbatch -XX:+PrintCompilation Test</code> </pre> <br>  Ich werde die Ausgabe dieses Befehls hier nicht einf√ºgen, da die JVM standardm√§√üig viele interne Funktionen kompiliert (z. B. in Bezug auf Java-, Sun- und JDK-Pakete), sodass die Ausgabe sehr lang ist. Auf meinem Bildschirm befinden sich also 274 Zeilen in den internen Funktionen und noch ein paar mehr - bis zum Abschluss des Programms).  Um diese Recherche zu vereinfachen, werde ich die JIT-Kompilierung f√ºr innere Klassen abbrechen oder sie selektiv nur f√ºr meine Methode <code>Test.f</code> ( <code>Test.f</code> ).  <code>-XX:CompileCommand</code> eine weitere Option an: <code>-XX:CompileCommand</code> .  Sie k√∂nnen viele Befehle angeben (Kompilierung), sodass es einfacher ist, sie in einer separaten Datei abzulegen.  Zum Gl√ºck haben wir die Option <code>-XX:CompileCommandFile</code> .  Fahren Sie also mit dem Erstellen der Datei fort.  Ich werde es <code>hotspot_compiler</code> aus einem Grund nennen, den ich kurz erl√§utern und Folgendes schreiben werde: <br><br><pre> <code class="plaintext hljs">quiet exclude java/* * exclude jdk/* * exclude sun/* *</code> </pre> <br>  In diesem Fall sollte v√∂llig klar sein, dass wir alle Funktionen (das letzte *) in allen Klassen von allen Paketen ausschlie√üen, die mit Java, JDK und Sun beginnen (Paketnamen werden durch / getrennt, und Sie k√∂nnen * verwenden).  Der Befehl <code>quiet</code> weist die JVM an, nichts √ºber die ausgeschlossenen Klassen zu schreiben, sodass nur die jetzt kompilierten Klassen an die Konsole ausgegeben werden.  Also renne ich: <br><br><pre> <code class="plaintext hljs">java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler Test</code> </pre> <br>  Bevor ich Sie √ºber die Ausgabe dieses Befehls <code>hotspot_compiler</code> , <code>hotspot_compiler</code> ich Sie daran erinnern, dass ich diese Datei <code>hotspot_compiler</code> , da anscheinend in Oracle JDK der Name <code>.hotspot_compiler</code> f√ºr die Datei mit Compilerbefehlen standardm√§√üig <code>.hotspot_compiler</code> ist (ich habe dies nicht √ºberpr√ºft). <br><br>  Die Schlussfolgerung lautet also: <br><br><pre> <code class="plaintext hljs">many lines like this 111 1 n 0 java.lang.invoke.MethodHandle::linkToStatic(LLLLLL)L (native) (static) call 1 some more lines like this 161 48 n 0 java.lang.invoke.MethodHandle::linkToStatic(ILIJL)I (native) (static) elapsed= 7558 call 2 elapsed= 1532 call 3 elapsed= 920 call 4 elapsed= 732 call 5 elapsed= 774 call 6 elapsed= 815 call 7 elapsed= 767 call 8 elapsed= 765 call 9 elapsed= 757 call 10 elapsed= 868</code> </pre> <br>  Erstens wei√ü ich nicht, warum einige <code>java.lang.invoke.MethodHandler.</code> Methoden noch kompiliert werden <code>java.lang.invoke.MethodHandler.</code>  Wahrscheinlich k√∂nnen einige Dinge einfach nicht ausgeschaltet werden.  Soweit ich wei√ü, werde ich diesen Beitrag aktualisieren.  Wie Sie sehen, sind jetzt alle anderen Kompilierungsschritte (zuvor waren es 274 Zeilen) verschwunden.  In weiteren Beispielen werde ich auch <code>java.lang.invoke.MethodHandler</code> aus der Ausgabe des Kompilierungsprotokolls entfernen. <br><br>  Mal sehen, wozu wir gekommen sind.  Jetzt haben wir einen einfachen Code, in dem wir unsere Funktion 10 Mal ausf√ºhren.  Ich habe bereits erw√§hnt, dass diese Funktion interpretiert und nicht kompiliert wird, wie in der Dokumentation angegeben. Jetzt sehen wir sie in den Protokollen (gleichzeitig sehen wir sie nicht in den Kompilierungsprotokollen, und dies bedeutet, dass sie keiner JIT-Kompilierung unterzogen wird).  Nun, Sie haben gerade das Java-Tool in Aktion gesehen, das unsere Funktion nur in 100% der F√§lle interpretiert und interpretiert.  Wir k√∂nnen also das Kontrollk√§stchen aktivieren, das mit Option (1) herausgefunden wurde.  Wir gehen zu (2), dynamischer Zusammenstellung. <br><br>  Laut Dokumentation k√∂nnen Sie die Funktion 1.500 Mal ausf√ºhren und sicherstellen, dass die JIT-Kompilierung tats√§chlich stattfindet.  Sie k√∂nnen jedoch auch die <code>-XX:CompileThreshold=invocations</code> , wobei der gew√ºnschte Wert anstelle von 1500 festgelegt wird.  Lassen Sie uns hier 5 zeigen. Dies bedeutet, dass wir Folgendes erwarten: Nach 5 ‚ÄûInterpretationen‚Äú unserer Funktion f muss die JVM die Methode kompilieren und dann die kompilierte Version ausf√ºhren. <br>  java -client -Xbatch <br><br><pre> <code class="plaintext hljs">-XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 Test</code> </pre> <br>  Wenn Sie diesen Befehl ausgef√ºhrt haben, haben Sie m√∂glicherweise festgestellt, dass sich im Vergleich zum obigen Beispiel nichts ge√§ndert hat.  Das hei√üt, die Kompilierung findet immer noch nicht statt.  Laut Dokumentation stellt sich heraus, dass <code>-XX:CompileThreshold</code> nur funktioniert, wenn <code>TieredCompilation</code> deaktiviert ist. <code>TieredCompilation</code> ist die Standardeinstellung.  Es <code>-XX:-TieredCompilation</code> : <code>-XX:-TieredCompilation</code> .  Tiered Compilation ist eine in Java 7 eingef√ºhrte Funktion, um sowohl die Start- als auch die Reisegeschwindigkeit der JVM zu verbessern.  Im Kontext dieses Beitrags ist dies nicht wichtig. Deaktivieren Sie ihn daher.  Lassen Sie uns diesen Befehl jetzt erneut ausf√ºhren: <br><br><pre> <code class="plaintext hljs">java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 -XX:-TieredCompilation Test</code> </pre> <br>  Hier ist die Ausgabe (ich erinnere mich, ich habe die Zeilen bez√ºglich <code>java.lang.invoke.MethodHandle</code> verpasst): <br><br><pre> <code class="plaintext hljs">call 1 elapsed= 9411 call 2 elapsed= 1291 call 3 elapsed= 862 call 4 elapsed= 1023 call 5 227 56 b Test::&lt;init&gt; (5 bytes) 228 57 b Test::f (4 bytes) elapsed= 1051739 call 6 elapsed= 18516 call 7 elapsed= 940 call 8 elapsed= 769 call 9 elapsed= 855 call 10 elapsed= 838</code> </pre> <br>  Wir begr√º√üen (hallo!) Die dynamisch kompilierte Funktion Test.f oder <code>Test::&lt;init&gt;</code> unmittelbar nach dem Aufruf von Nummer 5, da ich CompileThreshold auf 5 gesetzt habe. Die JVM interpretiert die Funktion f√ºnfmal, kompiliert sie dann und f√ºhrt schlie√ülich die kompilierte Version aus.  Da die Funktion kompiliert ist, sollte sie schneller ausgef√ºhrt werden. Dies k√∂nnen wir hier jedoch nicht √ºberpr√ºfen, da diese Funktion nichts bewirkt.  Ich denke, dies ist ein gutes Thema f√ºr einen separaten Beitrag. <br><br>  Wie Sie wahrscheinlich bereits vermutet haben, wird hier eine andere Funktion kompiliert, n√§mlich <code>Test::&lt;init&gt;</code> , ein Konstruktor der <code>Test</code> .  Da der Code den Konstruktor (new <code>Test()</code> ) aufruft, wird er bei jedem Aufruf von <code>f</code> genau nach 5 Aufrufen gleichzeitig mit der Funktion <code>f</code> kompiliert. <br><br>  Im Prinzip kann dies die Diskussion √ºber Option (2), JIT-Kompilierung, beenden.  Wie Sie sehen, wird die Funktion in diesem Fall zuerst von der JVM interpretiert und dann nach f√ºnffacher Interpretation dynamisch kompiliert.  Ich m√∂chte das letzte Detail bez√ºglich der JIT-Kompilierung hinzuf√ºgen, n√§mlich die Option <code>-XX:+PrintAssembly</code> zu erw√§hnen.  Wie der Name schon sagt, gibt es eine kompilierte Version der Funktion an die Konsole aus (kompilierte Version = nativer Maschinencode = Assembler-Code).  Dies funktioniert jedoch nur, wenn sich im Bibliothekspfad ein Disassembler befindet.  Ich denke, der Disassembler kann sich in verschiedenen JVMs unterscheiden, aber in diesem Fall handelt es sich um hsdis - einen Disassembler f√ºr openjdk.  Der Quellcode der hsdis-Bibliothek oder ihrer Bin√§rdatei kann an verschiedenen Stellen verwendet werden.  In diesem Fall habe ich diese Datei kompiliert und <code>hsdis-amd64.so</code> in <code>JAVA_HOME/lib/server</code> . <br><br>  Jetzt k√∂nnen wir diesen Befehl ausf√ºhren.  Aber zuerst muss ich das hinzuf√ºgen, um <code>-XX:+PrintAssembly</code> m√ºssen auch die <code>-XX:+UnlockDiagnosticVMOptions</code> hinzuf√ºgen, die vor der Option <code>PrintAssembly</code> folgen muss.  Ist dies nicht der <code>PrintAssembly</code> , werden Sie von der JVM vor einer falschen Verwendung der Option <code>PrintAssembly</code> .  Lassen Sie uns diesen Code ausf√ºhren: <br><br><pre> <code class="plaintext hljs">java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly Test</code> </pre> <br>  Die Ausgabe wird lang sein und es wird Zeilen geben wie: <br><br><pre> <code class="plaintext hljs">0x00007f4b7cab1120: mov 0x8(%rsi),%r10d 0x00007f4b7cab1124: shl $0x3,%r10 0x00007f4b7cab1128: cmp %r10,%rax</code> </pre> <br>  Wie Sie sehen k√∂nnen, werden die entsprechenden Funktionen in nativen Maschinencode kompiliert. <br><br>  Besprechen Sie abschlie√üend Option 3, AOT.  Die Kompilierung vor der Ausf√ºhrung, AOT, war vor Version 9 in Java nicht verf√ºgbar. <br><br>  In JDK 9 ist ein neues Tool erschienen, jaotc - wie der Name schon sagt, handelt es sich um einen AOT-Compiler f√ºr Java.  Die Idee ist folgende: F√ºhren Sie den Java-Compiler "javac", dann den AOT-Compiler f√ºr Java "jaotc" und anschlie√üend die JVM "java" wie gewohnt aus.  Die JVM f√ºhrt normalerweise die Interpretation und JIT-Kompilierung durch.  Wenn die Funktion jedoch √ºber AOT-kompilierten Code verf√ºgt, verwendet sie diesen direkt und greift nicht auf Interpretation oder JIT-Kompilierung zur√ºck.  Lassen Sie mich erkl√§ren: Sie m√ºssen den AOT-Compiler nicht ausf√ºhren, er ist optional. Wenn Sie ihn verwenden, k√∂nnen Sie nur die gew√ºnschten Klassen kompilieren, bevor er ausgef√ºhrt wird. <br><br>  Erstellen wir eine Bibliothek, die aus einer AOT-kompilierten Version von <code>Test::f</code> .  Vergessen Sie nicht: Um dies selbst zu tun, ben√∂tigen Sie JDK 9 in Build 150+. <br><br><pre> <code class="plaintext hljs">jaotc --output=libTest.so Test.class</code> </pre> <br>  Als Ergebnis wird <code>libTest.so</code> generiert, eine Bibliothek, die AOT-kompilierten nativen Funktionscode enth√§lt, der in der <code>libTest.so</code> .  Sie k√∂nnen die in dieser Bibliothek definierten Zeichen anzeigen: <br><br><pre> <code class="plaintext hljs">nm libTest.so</code> </pre> <br>  In unserer Schlussfolgerung wird es unter anderem Folgendes geben: <br><br><pre> <code class="plaintext hljs">0000000000002120 t Test.f()I 00000000000021a0 t Test.&lt;init&gt;()V 00000000000020a0 t Test.main([Ljava/lang/String;)V</code> </pre> <br>  Alle unsere Funktionen, Konstruktor, <code>f</code> , statische Methode <code>main</code> sind also in der Bibliothek <code>libTest.so</code> . <br><br>  Wie bei der entsprechenden Option "Java" kann die Option in diesem Fall von einer Datei begleitet werden. Hierzu gibt es die Option ‚Äìcompile-Befehle f√ºr jaotc.  JEP 295 enth√§lt relevante Beispiele, die ich hier nicht zeigen werde. <br><br>  Lassen Sie uns nun "Java" ausf√ºhren und pr√ºfen, ob AOT-kompilierte Methoden verwendet werden.  Wenn Sie "Java" wie zuvor ausf√ºhren, wird die AOT-Bibliothek nicht verwendet, und dies ist nicht √ºberraschend.  Um diese neue Funktion nutzen zu k√∂nnen, steht die Option <code>-XX:AOTLibrary</code> zur Verf√ºgung, die Sie angeben m√ºssen: <br><br><pre> <code class="plaintext hljs">java -XX:AOTLibrary=./libTest.so Test</code> </pre> <br>  Sie k√∂nnen mehrere AOT-Bibliotheken angeben, die durch Kommas getrennt sind. <br><br>  Die Ausgabe dieses Befehls ist genau die gleiche wie beim Starten von "Java" ohne <code>AOTLibrary</code> , da sich das Verhalten des Testprogramms √ºberhaupt nicht ge√§ndert hat.  Um zu √ºberpr√ºfen, ob AOT-kompilierte Funktionen verwendet werden, k√∂nnen Sie eine weitere neue Option <code>-XX:+PrintAOT</code> . <br><br><pre> <code class="plaintext hljs">java -XX:AOTLibrary=./libTest.so -XX:+PrintAOT Test</code> </pre> <br>  Vor der Ausgabe des <code>Test</code> zeigt dieser Befehl Folgendes an: <br><br><pre> <code class="plaintext hljs"> 9 1 loaded ./libTest.so aot library 99 1 aot[ 1] Test.main([Ljava/lang/String;)V 99 2 aot[ 1] Test.f()I 99 3 aot[ 1] Test.&lt;init&gt;()V</code> </pre> <br>  Wie geplant wird die AOT-Bibliothek geladen und AOT-kompilierte Funktionen werden verwendet. <br><br>  Wenn Sie interessiert sind, k√∂nnen Sie den folgenden Befehl ausf√ºhren und pr√ºfen, ob die JIT-Kompilierung stattfindet. <br><br><pre> <code class="plaintext hljs">java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 -XX:-TieredCompilation -XX:AOTLibrary=./libTest.so -XX:+PrintAOT Test</code> </pre> <br>  Wie erwartet findet keine JIT-Kompilierung statt, da die Methoden in der Testklasse vor der Ausf√ºhrung kompiliert und als Bibliothek bereitgestellt werden. <br><br>  Eine m√∂gliche Frage ist: Wenn wir einen nativen Funktionscode bereitstellen, wie stellt die JVM dann fest, ob der native Code veraltet / veraltet ist?  Als letztes Beispiel √§ndern wir die Funktion <code>f</code> und setzen a auf 6. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre> <br>  Ich habe dies nur getan, um die Klassendatei zu √§ndern.  Jetzt lassen wir javac kompilieren und f√ºhren den gleichen Befehl wie oben aus. <br><br><pre> <code class="plaintext hljs">javac Test.java java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 -XX:-TieredCompilation -XX:AOTLibrary=./libTest.so -XX:+PrintAOT Test</code> </pre> <br>  Wie Sie sehen k√∂nnen, habe ich "jaotc" nicht nach "javac" ausgef√ºhrt, daher ist der Code aus der AOT-Bibliothek jetzt alt und falsch, und die Funktion <code>f</code> hat a = 5. <br><br>  Die Ausgabe des obigen Befehls "Java" zeigt: <br><br><pre> <code class="plaintext hljs">228 56 b Test::&lt;init&gt; (5 bytes) 229 57 b Test::f (5 bytes)</code> </pre> <br>  Dies bedeutet, dass die Funktionen in diesem Fall dynamisch kompiliert wurden, sodass der aus der AOT-Kompilierung resultierende Code nicht verwendet wurde.  Daher wurde eine √Ñnderung in der Klassendatei festgestellt.  Wenn die Kompilierung mit javac durchgef√ºhrt wird, wird der Fingerabdruck in die Klasse eingegeben, und der Klassenfingerabdruck wird auch in der AOT-Bibliothek gespeichert.  Da sich der neue Fingerabdruck der Klasse von dem in der AOT-Bibliothek gespeicherten unterscheidet, wurde im Voraus kompilierter nativer Code (AOT) nicht verwendet.  Das ist alles, was ich Ihnen √ºber die letzte Kompilierungsoption vor der Ausf√ºhrung erz√§hlen wollte. <br><br>  In diesem Artikel habe ich versucht, anhand einfacher realistischer Beispiele zu erkl√§ren und zu veranschaulichen, wie die JVM Java-Code ausf√ºhrt: Interpretieren, dynamisch kompilieren (JIT) oder im Voraus (AOT) - au√üerdem erschien die letzte Gelegenheit nur in JDK 9. Ich hoffe, Sie haben etwas gelernt neu. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466529/">https://habr.com/ru/post/de466529/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466517/index.html">Lokalisierungstraining an der Universit√§t von Washington</a></li>
<li><a href="../de466519/index.html">Detaillierte Analyse von AWS Lambda</a></li>
<li><a href="../de466521/index.html">C for Metal - Edelmetall f√ºr Computer auf Intel-Grafikkarten</a></li>
<li><a href="../de466525/index.html">Was ist ein PSD iPhone Layout und wie wird es verwendet?</a></li>
<li><a href="../de466527/index.html">Testen der Benutzerfunktionalit√§t von Websites mit Capybara-Seitenobjekten</a></li>
<li><a href="../de466535/index.html">DeepClone neu denken</a></li>
<li><a href="../de466537/index.html">Verwendung von JavaScript-Modulen in der Produktion: aktueller Stand der Dinge. Teil 1</a></li>
<li><a href="../de466539/index.html">Verwendung von JavaScript-Modulen in der Produktion: aktueller Stand der Dinge. Teil 2</a></li>
<li><a href="../de466541/index.html">Verwenden von DbTool zum Seeding von Datenbanken in .NET-Anwendungen (Core)</a></li>
<li><a href="../de466543/index.html">Habr Weekly # 17 / Sberbank-Darlehen werden von AI genehmigt - be√§ngstigend, Werbung in Open-Source-Produkten - zweifelhaft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>