<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔢 👩‍👦‍👦 💆🏼 Rekayasa terbalik dari rendering The Witcher 3 👏🏿 🧑🏿‍🤝‍🧑🏼 👨🏼‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagian pertama dari terjemahan ada di sini . Pada bagian ini, kita akan berbicara tentang efek ketajaman, kecerahan rata-rata, fase bulan dan fenomena...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rekayasa terbalik dari rendering The Witcher 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437100/">  Bagian pertama dari terjemahan ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Pada bagian ini, kita akan berbicara tentang efek ketajaman, kecerahan rata-rata, fase bulan dan fenomena atmosfer selama hujan. <br><br><h2>  Bagian 6. Mempertajam </h2><br>  Pada bagian ini, kita akan melihat lebih dekat efek post-processing lain dari The Witcher 3 - Sharpen. <br><br>  Mengasah membuat gambar output sedikit lebih tajam.  Efek ini diketahui oleh kami dari Photoshop dan editor grafis lainnya. <br><br>  Dalam The Witcher 3, penajaman memiliki dua opsi: rendah dan tinggi.  Saya akan berbicara tentang perbedaan di antara mereka di bawah ini, tetapi untuk sekarang, mari kita lihat screenshotnya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/285/1fc/6bc/2851fc6bc19e39660e0307f2775b0322.png" alt="gambar"></div><br>  <i>Opsi "Rendah" - hingga</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc2/cd4/4cd/dc2cd44cd83306f2c08bbf7f87831d8c.png" alt="gambar"></div><br>  <i>Opsi "Rendah" - setelah</i> <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aad/807/2aa/aad8072aa3977f32549856c0be24206b.png"></div><br>  <i>Opsi tinggi - hingga</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b87/3ce/0f3/b873ce0f320a785f4fb4bc83e9a696f5.png"></div><br>  <i>Opsi "Tinggi" - setelah</i> <br><br>  Jika Anda ingin melihat perbandingan yang lebih rinci (interaktif), lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian dalam Panduan Kinerja The Witcher 3 Nvidia</a> .  Seperti yang Anda lihat, efeknya terutama terlihat pada rumput dan dedaunan. <br><br>  Di bagian posting ini, kita akan mempelajari bingkai dari awal permainan: Saya memilihnya dengan sengaja, karena di sini kita melihat relief (jarak jarak jauh) dan kubah langit. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/898/e97/895/898e9789593705231157a07ebcf34f5e.png"></div><br>  Dalam hal input, mengasah memerlukan buffer warna <b>t0</b> (LDR setelah koreksi nada dan suar lensa) dan buffer kedalaman <b>t1</b> . <br><br>  Mari kita periksa kode assembler untuk pixel shader: <br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb3[3], immediateIndexed <br> dcl_constantbuffer cb12[23], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_input_ps_siv v0.xy, position <br> dcl_output o0.xyzw <br> dcl_temps 7 <br> 0: ftoi r0.xy, v0.xyxx <br> 1: mov r0.zw, l(0, 0, 0, 0) <br> 2: ld_indexable(texture2d)(float,float,float,float) r0.x, r0.xyzw, t1.xyzw <br> 3: mad r0.x, r0.x, cb12[22].x, cb12[22].y <br> 4: mad r0.y, r0.x, cb12[21].x, cb12[21].y <br> 5: max r0.y, r0.y, l(0.000100) <br> 6: div r0.y, l(1.000000, 1.000000, 1.000000, 1.000000), r0.y <br> 7: mad_sat r0.y, r0.y, cb3[1].z, cb3[1].w <br> 8: add r0.z, -cb3[1].x, cb3[1].y <br> 9: mad r0.y, r0.y, r0.z, cb3[1].x <br> 10: add r0.y, r0.y, l(1.000000) <br> 11: ge r0.x, r0.x, l(1.000000) <br> 12: movc r0.x, r0.x, l(0), l(1.000000) <br> 13: mul r0.z, r0.x, r0.y <br> 14: round_z r1.xy, v0.xyxx <br> 15: add r1.xy, r1.xyxx, l(0.500000, 0.500000, 0.000000, 0.000000) <br> 16: div r1.xy, r1.xyxx, cb3[0].zwzz <br> 17: sample_l(texture2d)(float,float,float,float) r2.xyz, r1.xyxx, t0.xyzw, s0, l(0) <br> 18: lt r0.z, l(0), r0.z <br> 19: if_nz r0.z <br> 20: div r3.xy, l(0.500000, 0.500000, 0.000000, 0.000000), cb3[0].zwzz <br> 21: add r0.zw, r1.xxxy, -r3.xxxy <br> 22: sample_l(texture2d)(float,float,float,float) r4.xyz, r0.zwzz, t0.xyzw, s0, l(0) <br> 23: mov r3.zw, -r3.xxxy <br> 24: add r5.xyzw, r1.xyxy, r3.zyxw <br> 25: sample_l(texture2d)(float,float,float,float) r6.xyz, r5.xyxx, t0.xyzw, s0, l(0) <br> 26: add r4.xyz, r4.xyzx, r6.xyzx <br> 27: sample_l(texture2d)(float,float,float,float) r5.xyz, r5.zwzz, t0.xyzw, s0, l(0) <br> 28: add r4.xyz, r4.xyzx, r5.xyzx <br> 29: add r0.zw, r1.xxxy, r3.xxxy <br> 30: sample_l(texture2d)(float,float,float,float) r1.xyz, r0.zwzz, t0.xyzw, s0, l(0) <br> 31: add r1.xyz, r1.xyzx, r4.xyzx <br> 32: mul r3.xyz, r1.xyzx, l(0.250000, 0.250000, 0.250000, 0.000000) <br> 33: mad r1.xyz, -r1.xyzx, l(0.250000, 0.250000, 0.250000, 0.000000), r2.xyzx <br> 34: max r0.z, abs(r1.z), abs(r1.y) <br> 35: max r0.z, r0.z, abs(r1.x) <br> 36: mad_sat r0.z, r0.z, cb3[2].x, cb3[2].y <br> 37: mad r0.x, r0.y, r0.x, l(-1.000000) <br> 38: mad r0.x, r0.z, r0.x, l(1.000000) <br> 39: dp3 r0.y, l(0.212600, 0.715200, 0.072200, 0.000000), r2.xyzx <br> 40: dp3 r0.z, l(0.212600, 0.715200, 0.072200, 0.000000), r3.xyzx <br> 41: max r0.w, r0.y, l(0.000100) <br> 42: div r1.xyz, r2.xyzx, r0.wwww <br> 43: add r0.y, -r0.z, r0.y <br> 44: mad r0.x, r0.x, r0.y, r0.z <br> 45: max r0.x, r0.x, l(0) <br> 46: mul r2.xyz, r0.xxxx, r1.xyzx <br> 47: endif <br> 48: mov o0.xyz, r2.xyzx <br> 49: mov o0.w, l(1.000000) <br> 50: ret</code> <br> <br>  50 baris kode assembler terlihat seperti tugas yang layak.  Mari kita mulai mengatasinya. <br><br><h3>  Pertajam Generasi Nilai </h3><br>  Langkah pertama adalah memuat buffer kedalaman (baris 1).  Perlu dicatat bahwa "The Witcher 3" menggunakan kedalaman terbalik (1,0 - tutup, 0,0 - jauh).  Seperti yang Anda ketahui, kedalaman perangkat keras terikat secara nonlinier (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini untuk detailnya</a> ). <br><br>  Baris 3-6 menyediakan cara yang sangat menarik untuk mengaitkan kedalaman perangkat keras ini [1,0 - 0,0] dengan nilai-nilai [hampir-jauh] (kami atur pada tahap MatrixPerspectiveFov).  Pertimbangkan nilai-nilai dari buffer konstan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/636/345/52a/63634552ae9daf03f14305c118cccc25.png"></div><br>  Memiliki nilai "tutup" 0,2 dan nilai "jauh" 5000, kita dapat menghitung nilai cb12_v21.xy sebagai berikut: <br><br> <code>cb12_v21.y = 1.0 / near <br> cb12_v21.x = - (1.0 / near) + (1.0 / near) * (near / far)</code> <br> <br>  Sepotong kode ini cukup umum di TW3 shader, jadi saya pikir ini hanya sebuah fungsi. <br><br>  Setelah mendapatkan "kedalaman piramida visibilitas", baris 7 menggunakan skala / distorsi untuk membuat koefisien interpolasi (di sini kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saturate</a> untuk membatasi nilai pada interval [0-1]). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e89/efd/571/e89efd5711cb2aa1a3c544e9deda9321.png"></div><br>  cb3_v1.xy dan cb3_v2.xy - ini adalah kecerahan dari efek penajaman pada jarak pendek dan panjang.  Sebut mereka menajamkan, Dekat, dan menajam.  Dan ini adalah satu-satunya perbedaan antara opsi "Rendah" dan "Tinggi" dari efek ini di The Witcher 3. <br><br>  Sekarang saatnya menggunakan rasio yang dihasilkan.  Baris 8-9 hanya melakukan <code>lerp(sharpenNear, sharpenFar, interpolationCoeff)</code> .  Untuk apa ini?  Berkat ini, kami mendapatkan kecerahan berbeda di dekat Geralt dan menjauh darinya.  Lihatlah: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/646/233/515/6462335151728759f236b58f14b894dd.png"></div><br>  Mungkin ini hampir tidak terlihat, tapi di sini kita diinterpolasi berdasarkan jarak mempertajam kecerahan di sebelah pemain (2.177151) dan efek kecerahannya sangat jauh (1.91303).  Setelah perhitungan ini, kami menambahkan 1,0 ke kecerahan (baris 10).  Mengapa ini dibutuhkan?  Misalkan operasi lerp yang ditunjukkan di atas memberi kami 0,0.  Setelah menambahkan 1,0, kami secara alami mendapatkan 1,0, dan ini adalah nilai yang tidak akan memengaruhi piksel saat melakukan penajaman.  Baca lebih lanjut tentang ini di bawah ini. <br><br>  Saat mengasah, kami tidak ingin memengaruhi langit.  Ini dapat dicapai dengan menambahkan pemeriksaan bersyarat sederhana: <br><br> <code>//   sharpen   <br> float fSkyboxTest = (fDepth &gt;= 1.0) ? 0 : 1;</code> <br> <br>  Dalam The Witcher 3, nilai kedalaman piksel langit adalah 1,0, jadi kami menggunakannya untuk mendapatkan semacam "filter biner" (fakta yang menarik: dalam hal ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">langkah</a> tidak akan bekerja dengan benar). <br><br>  Sekarang kita dapat melipatgandakan kecerahan yang diinterpolasi dengan "filter langit": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63c/ed1/f50/63ced1f5036d9ee63cfe54de6a501bc1.png"></div><br>  Perkalian ini dilakukan pada baris 13. <br><br>  Contoh kode shader: <br><br> <code>//    sharpen <br> float fSharpenAmount = fSharpenIntensity * fSkyboxTest;</code> <br> <br><h3>  Pixel Sampling Center </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SV_Position</a> memiliki aspek yang penting di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">offset setengah piksel</a> .  Ternyata piksel ini di sudut kiri atas (0, 0) tidak memiliki koordinat (0, 0) dalam hal SV_Position.xy, tetapi (0,5, 0,5).  Wow! <br><br>  Di sini kita ingin mengambil sampel di tengah pixel, jadi mari kita lihat garis 14-16.  Anda dapat menulisnya di HLSL: <br><br> <code>//   . <br> //   ""   SV_Position.xy. <br> float2 uvCenter = trunc( Input.Position.xy ); <br> <br> //   ,       <br> uvCenter += float2(0.5, 0.5); <br> uvCenter /= g_Viewport.xy</code> <br> <br>  Dan kemudian, kami mencicipi tekstur warna input dari texcoords "uvCenter".  Jangan khawatir, hasil pengambilan sampel akan sama dengan metode "normal" (SV_Position.xy / ViewportSize.xy). <br><br><h3>  Menajam atau tidak menajam </h3><br>  Keputusan untuk menggunakan mempertajam tergantung pada fSharpenAmount. <br><br> <code>//     <br> float3 colorCenter = TexColorBuffer.SampleLevel( samplerLinearClamp, uvCenter, 0 ).rgb; <br> <br> //   <br> float3 finalColor = colorCenter; <br> <br> if ( fSharpenAmount &gt; 0 ) <br> { <br> //   sharpening... <br> } <br> <br> return float4( finalColor, 1 );</code> <br> <br><h3>  Pertajam </h3><br>  Sekarang saatnya untuk melihat bagian dalam algoritma itu sendiri. <br><br>  Pada dasarnya, ia melakukan tindakan berikut: <br><br>  - sampel empat kali tekstur warna input di sudut-sudut piksel, <br><br>  - menambah sampel dan menghitung nilai rata-rata, <br><br>  - menghitung perbedaan antara "center" dan "cornerAverage", <br><br>  - Menemukan komponen absolut maksimum perbedaan, <br><br>  - mengoreksi maks.  abs  komponen menggunakan skala + nilai bias, <br><br>  - Menentukan besarnya efek menggunakan maks.  abs  komponen <br><br>  - menghitung nilai kecerahan (luma) untuk "centerColor" dan "averageColor", <br><br>  - Membagi colorCenter menjadi luma-nya, <br><br>  - Menghitung nilai luma baru yang diinterpolasi berdasarkan besarnya efek, <br><br>  - Mengalikan colorCenter dengan nilai luma baru. <br><br>  Banyak pekerjaan, dan sulit bagi saya untuk mengetahuinya, karena saya belum pernah bereksperimen dengan mempertajam filter. <br><br>  Mari kita mulai dengan pola pengambilan sampel.  Seperti yang dapat Anda lihat dalam kode assembler, dilakukan empat pembacaan tekstur. <br><br>  Ini akan ditampilkan dengan menggunakan contoh gambar piksel (tingkat keterampilan artis adalah <i>ahli</i> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e3/d46/5fa/5e3d465fadc0bccd551256c40c6e5368.png"></div><br>  Semua bacaan di shader menggunakan pengambilan sampel bilinear (D3D11_FILTER_MIN_MAG_LINEAR_MIP_POINT). <br><br>  Offset dari pusat ke masing-masing sudut adalah (± 0,5, ± 0,5), tergantung pada sudutnya. <br><br>  Lihat bagaimana ini dapat diterapkan pada HLSL?  Mari kita lihat: <br><br> <code>float2 uvCorner; <br> float2 uvOffset = float2( 0.5, 0.5 ) / g_Viewport.xy; // remember about division! <br> <br> float3 colorCorners = 0; <br> <br> //    <br> // -0,5, -0.5 <br> uvCorner = uvCenter - uvOffset; <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb; <br> <br> //    <br> // +0.5, -0.5 <br> uvCorner = uvCenter + float2(uvOffset.x, -uvOffset.y); <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb; <br> <br> //    <br> // -0.5, +0.5 <br> uvCorner = uvCenter + float2(-uvOffset.x, uvOffset.y); <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb; <br> <br> //    <br> // +0.5, +0.5 <br> uvCorner = uvCenter + uvOffset; <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb;</code> <br> <br>  Jadi, sekarang keempat sampel dirangkum dalam variabel "colorCorners".  Mari ikuti langkah-langkah ini: <br><br> <code>//     <br> float3 averageColorCorners = colorCorners / 4.0; <br> <br> //    <br> float3 diffColor = colorCenter - averageColorCorners; <br> <br> //  . . RGB-  <br> float fDiffColorMaxComponent = max( abs(diffColor.x), max( abs(diffColor.y), abs(diffColor.z) ) ); <br> <br> //    <br> float fDiffColorMaxComponentScaled = saturate( fDiffColorMaxComponent * sharpenLumScale + sharpenLumBias ); <br> <br> //     . <br> //   "1.0" -      fSharpenIntensity  1.0. <br> float fPixelSharpenAmount = lerp(1.0, fSharpenAmount, fDiffColorMaxComponentScaled); <br> <br> //   ""     . <br> float lumaCenter = dot( LUMINANCE_RGB, finalColor ); <br> float lumaCornersAverage = dot( LUMINANCE_RGB, averageColorCorners ); <br> <br> //  "centerColor"    <br> float3 fColorBalanced = colorCenter / max( lumaCenter, 1e-4 ); <br> <br> //    <br> float fPixelLuminance = lerp(lumaCornersAverage, lumaCenter, fPixelSharpenAmount); <br> <br> //     <br> finalColor = fColorBalanced * max(fPixelLuminance, 0.0); <br> } <br> <br> return float4(finalColor, 1.0);</code> <br> <br>  Pengenalan tepi dilakukan dengan menghitung maks.  abs  komponen perbedaan.  Langkah cerdas!  Lihat visualisasinya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa9/a26/44a/aa9a2644a16b1b79c6213f7d4effe068.jpg"></div><br>  <i>Visualisasi komponen absolut maksimum perbedaan.</i> <br><br>  Bagus  Shader HLSL yang telah selesai tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Maaf untuk pemformatan yang sangat buruk.  Anda dapat menggunakan program <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HLSLexplorer</a> saya dan bereksperimen dengan kode tersebut. <br><br>  Saya dengan senang hati dapat mengatakan bahwa kode di atas menciptakan kode assembler yang sama seperti di dalam game! <br><br>  Untuk meringkas: The Witcher 3 ketajaman shader ditulis dengan sangat baik (perhatikan bahwa fPixelSharpenAmount lebih besar dari 1,0! Ini menarik ...).  Selain itu, cara utama untuk mengubah kecerahan efek adalah kecerahan objek dekat / jauh.  Dalam game ini, mereka bukan konstanta;  Saya telah mengumpulkan beberapa contoh nilai: <br><br>  Skellige: <br><br><table><tbody><tr><th></th><th>  menajamkan Dekat </th><th>  menajamkan Far </th><th>  pertajamSkala </th><th>  PertajamBiasBias </th><th>  pertajamLumSkala </th><th>  mempertajamLumBias </th></tr><tr><td>  <b>rendah</b> </td></tr></tbody><tbody><tr><td>  <b>tinggi</b> </td><td>  2.0 </td><td>  1.8 </td><td>  0,025 <br></td><td>  -0,25 <br></td><td>  -13.33333 <br></td><td>  1.33333 </td></tr></tbody></table><br>  Kaer Morhen: <br><br><table><tbody><tr><th></th><th>  menajamkan Dekat <br></th><th>  menajamkan Far <br></th><th>  pertajamSkala <br></th><th>  PertajamBiasBias <br></th><th>  pertajamLumSkala <br></th><th>  mempertajamLumBias <br></th></tr><tr><td>  rendah <br></td><td>  0,57751 <br></td><td>  0,31303 <br></td><td>  0,06665 <br></td><td>  -0,33256 <br></td><td>  -1.0 <br></td><td>  2.0 <br></td></tr><tr><td>  tinggi <br></td><td>  2.17751 <br></td><td>  1.91303 <br></td><td>  0,06665 <br></td><td>  -0,33256 <br></td><td>  -1.0 <br></td><td>  2.0 </td></tr></tbody></table><br><h2>  Bagian 7. Kecerahan rata-rata </h2><br>  Pengoperasian menghitung kecerahan rata-rata bingkai saat ini dapat ditemukan di hampir semua gim video modern.  Nilai ini sering digunakan kemudian untuk efek adaptasi mata dan koreksi nada (lihat bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya pada</a> pos).  Dalam solusi sederhana, perhitungan kecerahan digunakan untuk, katakanlah, tekstur 512 <sup>2</sup> , kemudian perhitungan level mip dan aplikasi yang terakhir.  Ini biasanya berhasil, tetapi sangat membatasi kemungkinan.  Solusi yang lebih kompleks menggunakan shader komputasi yang melakukan, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">reduksi paralel</a> . <br><br>  Mari kita cari tahu bagaimana tim CD Projekt Red memecahkan masalah ini di The Witcher 3.  Di bagian sebelumnya, saya sudah memeriksa koreksi nada dan adaptasi mata, jadi satu-satunya bagian puzzle yang tersisa adalah kecerahan rata-rata. <br><br>  Untuk mulai dengan, perhitungan kecerahan rata-rata The Witcher 3 terdiri dari dua lintasan.  Untuk lebih jelasnya, saya memutuskan untuk memecahnya menjadi beberapa bagian, dan pertama-tama kita melihat pass pertama - "distribusi kecerahan" (perhitungan histogram kecerahan). <br><br><h3>  Distribusi kecerahan </h3><br>  Dua lintasan ini cukup mudah ditemukan di setiap penganalisa bingkai.  Ini adalah panggilan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengiriman</a> agar tepat sebelum melakukan adaptasi mata: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7de/5fb/09c/7de5fb09ce00453f14262f9e2b1bae30.png"></div><br>  Mari kita lihat input untuk pass ini.  Ia membutuhkan dua tekstur: <br><br>  1) buffer warna HDR, skala yang direduksi menjadi 1/4 x 1/4 (misalnya, dari 1920x1080 menjadi 480x270), <br><br>  2) Buffer kedalaman layar penuh <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/021/38b/795/02138b795946d192f553eadc20d34366.png"></div><br>  <i>1/4 x 1/4 buffer warna HDR.</i>  <i>Perhatikan trik rumit - buffer ini adalah bagian dari buffer yang lebih besar.</i>  <i>Menggunakan kembali buffer adalah praktik yang baik.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e3/62d/c97/0e362dc97908f75db564cff0f46b1e7e.png"></div><br>  <i>Penyangga Kedalaman Layar Penuh</i> <br><br>  Mengapa memperkecil buffer warna?  Saya pikir ini semua tentang kinerja. <br><br>  Adapun output dari pass ini, itu adalah buffer terstruktur.  256 elemen masing-masing 4 byte. <br><br>  Shader tidak memiliki informasi debug di sini, jadi anggap itu hanya penyangga nilai int yang tidak ditandatangani. <br><br>  Penting: langkah pertama dalam menghitung kecerahan panggilan rata-rata <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ClearUnorderedAccessViewUint</a> untuk mengatur ulang semua elemen buffer terstruktur ke nol. <br><br>  Mari kita pelajari kode assembler dari shader komputasi (ini adalah shader komputasi pertama dalam seluruh analisis kami!) <br><br> <code>cs_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[3], immediateIndexed <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_uav_structured u0, 4 <br> dcl_input vThreadGroupID.x <br> dcl_input vThreadIDInGroup.x <br> dcl_temps 6 <br> dcl_tgsm_structured g0, 4, 256 <br> dcl_thread_group 64, 1, 1 <br> 0: store_structured g0.x, vThreadIDInGroup.x, l(0), l(0) <br> 1: iadd r0.xyz, vThreadIDInGroup.xxxx, l(64, 128, 192, 0) <br> 2: store_structured g0.x, r0.x, l(0), l(0) <br> 3: store_structured g0.x, r0.y, l(0), l(0) <br> 4: store_structured g0.x, r0.z, l(0), l(0) <br> 5: sync_g_t <br> 6: ftoi r1.x, cb0[2].z <br> 7: mov r2.y, vThreadGroupID.x <br> 8: mov r2.zw, l(0, 0, 0, 0) <br> 9: mov r3.zw, l(0, 0, 0, 0) <br> 10: mov r4.yw, l(0, 0, 0, 0) <br> 11: mov r1.y, l(0) <br> 12: loop <br> 13: utof r1.z, r1.y <br> 14: ge r1.z, r1.z, cb0[0].x <br> 15: breakc_nz r1.z <br> 16: iadd r2.x, r1.y, vThreadIDInGroup.x <br> 17: utof r1.z, r2.x <br> 18: lt r1.z, r1.z, cb0[0].x <br> 19: if_nz r1.z <br> 20: ld_indexable(texture2d)(float,float,float,float) r5.xyz, r2.xyzw, t0.xyzw <br> 21: dp3 r1.z, r5.xyzx, l(0.212600, 0.715200, 0.072200, 0.000000) <br> 22: imul null, r3.xy, r1.xxxx, r2.xyxx <br> 23: ld_indexable(texture2d)(float,float,float,float) r1.w, r3.xyzw, t1.yzwx <br> 24: eq r1.w, r1.w, cb0[2].w <br> 25: and r1.w, r1.w, cb0[2].y <br> 26: add r2.x, -r1.z, cb0[2].x <br> 27: mad r1.z, r1.w, r2.x, r1.z <br> 28: add r1.z, r1.z, l(1.000000) <br> 29: log r1.z, r1.z <br> 30: mul r1.z, r1.z, l(88.722839) <br> 31: ftou r1.z, r1.z <br> 32: umin r4.x, r1.z, l(255) <br> 33: atomic_iadd g0, r4.xyxx, l(1) <br> 34: endif <br> 35: iadd r1.y, r1.y, l(64) <br> 36: endloop <br> 37: sync_g_t <br> 38: ld_structured r1.x, vThreadIDInGroup.x, l(0), g0.xxxx <br> 39: mov r4.z, vThreadIDInGroup.x <br> 40: atomic_iadd u0, r4.zwzz, r1.x <br> 41: ld_structured r1.x, r0.x, l(0), g0.xxxx <br> 42: mov r0.w, l(0) <br> 43: atomic_iadd u0, r0.xwxx, r1.x <br> 44: ld_structured r0.x, r0.y, l(0), g0.xxxx <br> 45: atomic_iadd u0, r0.ywyy, r0.x <br> 46: ld_structured r0.x, r0.z, l(0), g0.xxxx <br> 47: atomic_iadd u0, r0.zwzz, r0.x <br> 48: ret</code> <br> <br>  Dan buffer konstan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c14/805/dc6/c14805dc6b7ffd431d9307cc46dcba0d.png"></div><br>  Kita sudah tahu bahwa input pertama adalah buffer warna HDR.  Dengan FullHD, resolusinya adalah 480x270.  Mari kita lihat panggilan Pengiriman. <br><br>  Pengiriman (270, 1, 1) - ini artinya kami menjalankan 270 grup utas.  Sederhananya, kami menjalankan satu grup benang per baris buffer warna. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e9a/a97/7e3/e9aa977e3f9a60104fe9a66d797a27cc.png"></div><br>  <i>Setiap grup thread mengeksekusi satu baris buffer warna HDR</i> <br><br>  Sekarang kita memiliki konteks ini, mari kita coba mencari tahu apa yang shader lakukan. <br><br>  Setiap grup utas memiliki 64 utas dalam arah X (dcl_thread_group 64, 1, 1), serta memori bersama, 256 elemen dengan masing-masing 4 byte (dcl_tgsm_structured g0, 4, 256). <br><br>  Perhatikan bahwa dalam shader kita menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SV_GroupThreadID</a> (vThreadIDInGroup.x) [0-63] dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SV_GroupID</a> (vThreadGroupID.x) [0-269]. <br><br>  1) Kita mulai dengan menetapkan semua elemen dari nilai nol memori yang dibagikan.  Karena total memori berisi 256 elemen dan 64 utas per grup, ini dapat dengan mudah dilakukan dengan loop sederhana: <br><br> <code>//   -      . <br> //        64 ,          4 . <br> [unroll] for (uint idx=0; idx &lt; 4; idx++) <br> { <br> const uint offset = threadID + idx*64; <br> shared_data[ offset ] = 0; <br> }</code> <br> <br>  2) Setelah itu, kami mengatur penghalang menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GroupMemoryBarrierWithGroupSync</a> (sync_g_t).  Kami melakukan ini untuk memastikan bahwa semua utas di memori bersama grup diatur ulang ke nol sebelum melanjutkan ke langkah berikutnya. <br><br>  3) Sekarang kita menjalankan loop, yang secara kasar dapat ditulis seperti ini: <br><br> <code>// cb0_v0.x -      .  1920x1080   1920/4 = 480; <br> float ViewportSizeX = cb0_v0.x; <br> [loop] for ( uint PositionX = 0; PositionX &lt; ViewportSizeX; PositionX += 64 ) <br> { <br> ...</code> <br> <br>  Ini sederhana untuk loop dengan selisih 64 (apakah Anda sudah mengerti mengapa?). <br><br>  Langkah selanjutnya adalah menghitung posisi piksel yang dimuat. <br><br>  Mari kita pikirkan. <br><br>  Untuk koordinat Y, kita dapat menggunakan SV_GroupID.x karena kami meluncurkan 270 grup utas. <br><br>  Untuk koordinat X, kita ... dapat memanfaatkan aliran grup saat ini!  Mari kita coba melakukannya. <br><br>  Karena ada 64 utas di setiap grup, solusi seperti itu akan mem-bypass semua piksel. <br><br>  Pertimbangkan grup utas (0, 0, 0). <br><br>  - Aliran (0, 0, 0) akan memproses piksel (0, 0), (64, 0), (128, 0), (192, 0), (256, 0), (320, 0), (320, 0), (384, 0), (448,0). <br><br>  - Utas (1, 0, 0) akan memproses piksel (1, 0), (65, 0), (129, 0), (193, 0), (257, 0), (321, 0), (385, 0) 0), (449, 0) ... <br><br>  - Aliran (63, 0, 0) akan memproses piksel (63, 0), (127, 0), (191, 0), (255, 0), (319, 0), (383, 0), (383, 0), (447, 0) <br><br>  Dengan demikian, semua piksel akan diproses. <br><br>  Kami juga perlu memastikan bahwa kami tidak memuat piksel dari luar buffer warna: <br><br> <code>//      X.  Y  GroupID. <br> uint CurrentPixelPositionX = PositionX + threadID; <br> uint CurrentPixelPositionY = groupID; <br> if ( CurrentPixelPositionX &lt; ViewportSizeX ) <br> { <br> // HDR- . <br> //   HDR-    ,     . <br> uint2 colorPos = uint2(CurrentPixelPositionX, CurrentPixelPositionY); <br> float3 color = texture0.Load( int3(colorPos, 0) ).rgb; <br> float luma = dot(color, LUMA_RGB);</code> <br> <br>  Lihat?  Sederhana saja! <br><br>  Saya juga menghitung kecerahan (baris 21 dari kode assembler). <br><br>  Hebat, kami sudah menghitung kecerahan dari piksel warna.  Langkah selanjutnya adalah memuat (bukan sampel!) Nilai kedalaman yang sesuai. <br><br>  Tapi di sini kita punya masalah, karena kami menghubungkan buffer kedalaman resolusi penuh.  Apa yang harus dilakukan? <br><br>  Ini sangat sederhana - cukup gandakan colorPos dengan konstanta (cb0_v2.z).  Kami mengurangi buffer warna HDR empat kali.  oleh karena itu nilainya 4! <br><br> <code>const int iDepthTextureScale = (int) cb0_v2.z; <br> uint2 depthPos = iDepthTextureScale * colorPos; <br> float depth = texture1.Load( int3(depthPos, 0) ).x;</code> <br> <br>  Sejauh ini bagus!  Tapi ... kita harus antre 24-25 ... <br><br> <code>24: eq r2.x, r2.x, cb0[2].w <br> 25: and r2.x, r2.x, cb0[2].y</code> <br> <br>  Jadi  Pertama kita memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perbandingan kesetaraan</a> floating point, hasilnya ditulis dalam r2.x, dan setelah itu pergi ... apa?  Bitwise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dan</a> ??  Benarkah?  Untuk nilai floating point?  Apa-apaan ini ??? <br><br>  <b>Masalah 'eq + dan'</b> <br><br>  Izinkan saya mengatakan bahwa bagi saya itu adalah bagian tersulit dari shader.  Saya bahkan mencoba kombinasi asint / asfloat yang aneh ... <br><br>  Dan jika Anda menggunakan pendekatan yang sedikit berbeda?  Mari kita lakukan perbandingan float-float di HLSL. <br><br> <code>float DummyPS() : SV_Target0 <br> { <br> float test = (cb0_v0.x == cb0_v0.y); <br> return test; <br> }</code> <br> <br>  Dan inilah output dalam kode assembler: <br><br> <code>0: eq r0.x, cb0[0].y, cb0[0].x <br> 1: and o0.x, r0.x, l(0x3f800000) <br> 2: ret</code> <br> <br>  Menarik, bukan?  Saya tidak berharap melihat "dan" di sini. <br><br>  0x3f800000 hanya 1,0f ... Itu logis karena kita mendapatkan 1,0 dan 0,0 sebaliknya jika perbandingan berhasil. <br><br>  Tetapi bagaimana jika kita “mengganti” 1.0 dengan beberapa nilai lain?  Misalnya, seperti ini: <br><br> <code>float DummyPS() : SV_Target0 <br> { <br> float test = (cb0_v0.x == cb0_v0.y) ? cb0_v0.z : 0.0; <br> return test; <br> }</code> <br> <br>  Kami mendapatkan hasil sebagai berikut: <br><br> <code>0: eq r0.x, cb0[0].y, cb0[0].x <br> 1: and o0.x, r0.x, cb0[0].z <br> 2: ret</code> <br> <br>  Ha!  Itu berhasil.  Ini hanya keajaiban dari kompiler HLSL.  Catatan: jika Anda mengganti 0,0 dengan sesuatu yang lain, maka Anda hanya mendapatkan movc. <br><br>  Mari kita kembali ke shader komputasi.  Langkah selanjutnya adalah memverifikasi bahwa kedalamannya sama dengan cb0_v2.w.  Itu selalu sama dengan 0,0 - dengan kata lain, kami memeriksa apakah suatu piksel berada di bidang yang jauh (di langit).  Jika demikian, maka kami menetapkan koefisien ini beberapa nilai, sekitar 0,5 (saya memeriksa beberapa frame). <br><br>  Koefisien yang dihitung ini digunakan untuk menginterpolasi antara kecerahan warna dan kecerahan "langit" (nilai cb0_v2.x, yang sering kira-kira sama dengan 0,0).  Saya berasumsi bahwa ini diperlukan untuk mengontrol pentingnya langit dalam menghitung kecerahan rata-rata.  Biasanya kepentingannya berkurang.  Ide yang sangat pintar. <br><br> <code>// ,       ( ).  ,    ,    <br> //    . <br> float value = (depth == cb0_v2.w) ? cb0_v2.y : 0.0; <br> <br> //  'value'  0.0,   lerp    'luma'.   'value'  <br> // (  0.50),   luma    . (cb0_v2.x    0.0). <br> float lumaOk = lerp( luma, cb0_v2.x, value );</code> <br> <br>  Karena kita memiliki lumaOk, langkah selanjutnya adalah menghitung logaritma natural untuk membuat distribusi yang baik.  Tapi tunggu, katakan saja lumaOk adalah 0,0.  Kita tahu bahwa nilai log (0) tidak terdefinisi, jadi kami menambahkan 1,0 karena log (1) = 0,0. <br><br>  Setelah itu, kami skala logaritma yang dihitung untuk 128 untuk mendistribusikannya dalam 256 sel.  Sangat pintar! <br><br>  Dan dari sini nilai ini diambil 88.722839.  Ini adalah <code>128 *   (2)</code> . <br><br>  Ini adalah cara HLSL menghitung logaritma. <br><br>  Hanya ada satu fungsi dalam kode assembler HLSL yang menghitung logaritma: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">log</a> , dan ia memiliki basis 2. <br><br> <code>// ,  lumaOk  0.0. <br> // log(0)   undefined <br> // log(1) = 0. <br> //     <br> lumaOk = log(lumaOk + 1.0); <br> <br> //     128 <br> lumaOk *= 128;</code> <br> <br>  Akhirnya, kami menghitung indeks sel dari kecerahan yang didistribusikan secara logaritmik dan menambahkan 1 ke sel yang sesuai dalam memori bersama. <br><br> <code>//   .    Uint,    256 , <br> //  ,      . <br> uint uLuma = (uint) lumaOk; <br> uLuma = min(uLuma, 255); <br> <br> //  1    . <br> InterlockedAdd( shared_data[uLuma], 1 );</code> <br> <br>  Langkah selanjutnya lagi akan menetapkan penghalang untuk memastikan bahwa semua piksel di baris telah diproses. <br><br>  Dan langkah terakhir adalah menambahkan nilai dari memori bersama ke buffer terstruktur.  Ini dilakukan dengan cara yang sama, melalui loop sederhana: <br><br> <code>// ,       <br> GroupMemoryBarrierWithGroupSync(); <br> <br> //      . <br> [unroll] for (uint idx = 0; idx &lt; 4; idx++) <br> { <br> const uint offset = threadID + idx*64; <br> <br> uint data = shared_data[offset]; <br> InterlockedAdd( g_buffer[offset], data ); <br> }</code> <br> <br>  Setelah semua 64 utas dalam grup utas mengisi data umum, masing-masing utas menambahkan 4 nilai ke buffer output. <br><br>  Pertimbangkan buffer output.  Mari kita pikirkan.  Jumlah semua nilai dalam buffer sama dengan jumlah total piksel!  (pada 480x270 = 129.600).  Artinya, kita tahu berapa banyak piksel yang memiliki nilai kecerahan tertentu. <br><br>  Jika Anda kurang berpengalaman dalam shading komputasi (seperti saya), maka pada awalnya mungkin tidak jelas, jadi bacalah posting beberapa kali lagi, ambil kertas dan pensil, dan cobalah untuk memahami konsep-konsep bahwa teknik ini dibangun. <br><br>  Itu saja!  Itulah cara The Witcher 3 menghitung histogram kecerahan.  Secara pribadi, saya belajar banyak ketika menulis bagian ini.  Selamat kepada orang-orang dari CD Projekt Red atas kerja luar biasa mereka! <br><br>  Jika Anda tertarik dengan shader HLSL lengkap, maka tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Saya selalu berusaha untuk mendapatkan kode perakitan sedekat mungkin dengan permainan dan sangat senang bahwa saya berhasil lagi! <br><br><h2>  Perhitungan kecerahan rata-rata </h2><br>  Ini adalah bagian kedua dari analisis perhitungan kecerahan sedang dalam "The Witcher 3: Wild Hunt". <br><br>  Sebelum kita berperang dengan shader komputasi lain, mari kita ulangi secara singkat apa yang terjadi di bagian terakhir: kita bekerja dengan penyangga warna HDR dengan skala hingga 1 / 4x1 / 4.  Setelah lulus pertama, kami mendapat histogram kecerahan (buffer terstruktur dari 256 nilai integer yang tidak ditandatangani).  Kami menghitung logaritma untuk kecerahan setiap piksel, mendistribusikannya lebih dari 256 sel dan meningkatkan nilai buffer terstruktur sebesar 1 per piksel.  Karena ini, jumlah total semua nilai dalam 256 sel ini sama dengan jumlah piksel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c3/89c/d16/3c389cd16ec2eed7617dcf9334429c6e.png"></div><br>  <i>Contoh output dari pass pertama.</i>  <i>Ada 256 elemen.</i> <br><br>  Misalnya, buffer layar penuh kami memiliki ukuran 1920x1080.  Setelah melakukan zoom out, pass pertama menggunakan buffer 480x270.  Jumlah dari semua 256 nilai dalam buffer akan sama dengan 480 * 270 = 129 600. <br><br>  Setelah pengantar singkat ini, kami siap untuk melanjutkan ke langkah berikutnya: ke komputasi. <br><br>  Kali ini hanya satu grup utas yang digunakan (Pengiriman (1, 1, 1)). <br><br>  Mari kita lihat kode assembler dari shader komputasi: <br><br> <code>cs_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[1], immediateIndexed <br> dcl_uav_structured u0, 4 <br> dcl_uav_typed_texture2d (float,float,float,float) u1 <br> dcl_input vThreadIDInGroup.x <br> dcl_temps 4 <br> dcl_tgsm_structured g0, 4, 256 <br> dcl_thread_group 64, 1, 1 <br> 0: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.x, vThreadIDInGroup.x, l(0), u0.xxxx <br> 1: store_structured g0.x, vThreadIDInGroup.x, l(0), r0.x <br> 2: iadd r0.xyz, vThreadIDInGroup.xxxx, l(64, 128, 192, 0) <br> 3: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.w, r0.x, l(0), u0.xxxx <br> 4: store_structured g0.x, r0.x, l(0), r0.w <br> 5: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.x, r0.y, l(0), u0.xxxx <br> 6: store_structured g0.x, r0.y, l(0), r0.x <br> 7: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.x, r0.z, l(0), u0.xxxx <br> 8: store_structured g0.x, r0.z, l(0), r0.x <br> 9: sync_g_t <br> 10: if_z vThreadIDInGroup.x <br> 11: mul r0.x, cb0[0].y, cb0[0].x <br> 12: ftou r0.x, r0.x <br> 13: utof r0.y, r0.x <br> 14: mul r0.yz, r0.yyyy, cb0[0].zzwz <br> 15: ftoi r0.yz, r0.yyzy <br> 16: iadd r0.x, r0.x, l(-1) <br> 17: imax r0.y, r0.y, l(0) <br> 18: imin r0.y, r0.x, r0.y <br> 19: imax r0.z, r0.y, r0.z <br> 20: imin r0.x, r0.x, r0.z <br> 21: mov r1.z, l(-1) <br> 22: mov r2.xyz, l(0, 0, 0, 0) <br> 23: loop <br> 24: breakc_nz r2.x <br> 25: ld_structured r0.z, r2.z, l(0), g0.xxxx <br> 26: iadd r3.x, r0.z, r2.y <br> 27: ilt r0.z, r0.y, r3.x <br> 28: iadd r3.y, r2.z, l(1) <br> 29: mov r1.xy, r2.yzyy <br> 30: mov r3.z, r2.x <br> 31: movc r2.xyz, r0.zzzz, r1.zxyz, r3.zxyz <br> 32: endloop <br> 33: mov r0.w, l(-1) <br> 34: mov r1.yz, r2.yyzy <br> 35: mov r1.xw, l(0, 0, 0, 0) <br> 36: loop <br> 37: breakc_nz r1.x <br> 38: ld_structured r2.x, r1.z, l(0), g0.xxxx <br> 39: iadd r1.y, r1.y, r2.x <br> 40: utof r2.x, r2.x <br> 41: utof r2.w, r1.z <br> 42: add r2.w, r2.w, l(0.500000) <br> 43: mul r2.w, r2.w, l(0.011271) <br> 44: exp r2.w, r2.w <br> 45: add r2.w, r2.w, l(-1.000000) <br> 46: mad r3.z, r2.x, r2.w, r1.w <br> 47: ilt r2.x, r0.x, r1.y <br> 48: iadd r2.w, -r2.y, r1.y <br> 49: itof r2.w, r2.w <br> 50: div r0.z, r3.z, r2.w <br> 51: iadd r3.y, r1.z, l(1) <br> 52: mov r0.y, r1.z <br> 53: mov r3.w, r1.x <br> 54: movc r1.xzw, r2.xxxx, r0.wwyz, r3.wwyz <br> 55: endloop <br> 56: store_uav_typed u1.xyzw, l(0, 0, 0, 0), r1.wwww <br> 57: endif <br> 58: ret</code> <br> <br>  Ada satu buffer konstan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbe/13a/0ab/bbe13a0abe0d79f47b0a59d33d51ab9c.png"></div><br>  Lihatlah kode assembler: dua UAV terpasang (u0: input buffer dari bagian pertama dan u1: tekstur output format 1x1 R32_FLOAT).  Kita juga melihat bahwa ada 64 utas per grup dan 256 elemen memori grup 4-byte yang dibagi. <br><br>  Kami mulai dengan mengisi memori bersama dengan data dari buffer input.  Kami memiliki 64 utas, jadi Anda harus melakukan hampir sama seperti sebelumnya. <br><br>  Untuk benar-benar yakin bahwa semua data telah dimuat untuk diproses lebih lanjut, setelah itu kami menempatkan penghalang. <br><br> <code>//   -        . <br> //        64 ,    4     <br> //    . <br> [unroll] for (uint idx=0; idx &lt; 4; idx++) <br> { <br> const uint offset = threadID + idx*64; <br> shared_data[ offset ] = g_buffer[offset]; <br> } <br> //    ,       ,     <br> //             . <br> GroupMemoryBarrierWithGroupSync();</code> <br> <br>  Semua perhitungan dilakukan hanya dalam satu utas, semua yang lain hanya digunakan untuk memuat nilai dari buffer ke memori bersama. <br><br>  Aliran "komputasi" memiliki indeks 0. Mengapa?  Secara teoritis, kita dapat menggunakan aliran apa pun dari interval [0-63], tetapi berkat perbandingan dengan 0, kita dapat menghindari perbandingan integer-integer tambahan (instruksi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ieq</a> ). <br><br>  Algoritma didasarkan pada indikasi interval piksel yang akan diperhitungkan dalam operasi. <br><br>  Pada baris 11, kita mengalikan lebar * tinggi untuk mendapatkan jumlah total piksel dan mengalikannya dengan dua angka dari interval [0,0f-1.0f], yang menunjukkan awal dan akhir interval.  Pembatasan lebih lanjut digunakan untuk memastikan bahwa <code>0 &lt;= Start &lt;= End &lt;= totalPixels - 1</code> : <br><br> <code>//        0. <br> [branch] if (threadID == 0) <br> { <br> //         <br> uint totalPixels = cb0_v0.x * cb0_v0.y; <br> <br> //   (,  ,    ), <br> //        . <br> int pixelsToConsiderStart = totalPixels * cb0_v0.z; <br> int pixelsToConsiderEnd = totalPixels * cb0_v0.w; <br> <br> int pixelsMinusOne = totalPixels - 1; <br> <br> pixelsToConsiderStart = clamp( pixelsToConsiderStart, 0, pixelsMinusOne ); <br> pixelsToConsiderEnd = clamp( pixelsToConsiderEnd, pixelsToConsiderStart, pixelsMinusOne );</code> <br> <br>  Seperti yang Anda lihat, ada dua siklus di bawah ini.  Masalah dengan mereka (atau dengan kode assembler mereka) adalah bahwa ada transisi bersyarat yang aneh di ujung loop.  Sangat sulit bagi saya untuk menciptakannya kembali.  Lihat juga baris 21. Mengapa ada "-1"?  Saya akan jelaskan sedikit di bawah ini. <br><br>  Tugas dari siklus pertama adalah untuk menjatuhkan <i>pixelToConsiderStart</i> dan memberi kami indeks sel buffer di mana <i>pixelToConsiderStart</i> +1 hadir (serta jumlah semua piksel dalam sel sebelumnya). <br><br>  Katakanlah <i>pixelToConsiderStart</i> kira-kira sama dengan 30.000, dan di buffer ada 37.000 piksel dalam sel "nol" (ini terjadi di permainan di malam hari).  Oleh karena itu, kami ingin memulai analisis kecerahan dengan kira-kira piksel 30001, yang ada di sel "nol".  Dalam hal ini, kami segera keluar dari loop, mendapatkan indeks awal '0' dan nol piksel yang dibuang. <br><br>  Lihatlah kode HLSL: <br><br> <code>//     <br> int numProcessedPixels = 0; <br> <br> //   [0-255] <br> int lumaValue = 0; <br> <br> //      <br> bool bExitLoop = false; <br> <br> //    -  "pixelsToConsiderStart" . <br> //          lumaValue,      . <br> [loop] <br> while (!bExitLoop) <br> { <br> //       . <br> uint numPixels = shared_data[lumaValue]; <br> <br> // ,      lumaValue <br> int tempSum = numProcessedPixels + numPixels; <br> <br> //  ,  pixelsToConsiderStart,    . <br> // ,      lumaValue. <br> //  , pixelsToConsiderStart -   "" ,   ,    . <br> [flatten] <br> if (tempSum &gt; pixelsToConsiderStart) <br> { <br> bExitLoop = true; <br> } <br> else <br> { <br> numProcessedPixels = tempSum; <br> lumaValue++; <br> } <br> }</code> <br> <br>  Angka misterius "-1" dari baris 21 kode assembler dikaitkan dengan kondisi Boolean untuk eksekusi loop (saya menemukan ini hampir secara tidak sengaja). <br><br>  Setelah menerima jumlah piksel dari sel <i>lumaValue</i> dan <i>lumaValue</i> sendiri, kita dapat beralih ke siklus kedua. <br><br>  Tugas siklus kedua adalah untuk menghitung pengaruh piksel dan kecerahan rata-rata. <br><br>  Kita mulai dengan <i>lumaValue yang</i> dihitung di loop pertama. <br><br> <code>float finalAvgLuminance = 0.0f; <br> <br> //       <br> uint numProcessedPixelStart = numProcessedPixels; <br> <br> //    -      . <br> //    ,    ,        lumaValue. <br> //      [0-255],     ,    ,   ,    <br> //    pixelsToConsiderEnd. <br> //          . <br> bExitLoop = false; <br> [loop] <br> while (!bExitLoop) <br> { <br> //       . <br> uint numPixels = shared_data[lumaValue]; <br> <br> //      <br> numProcessedPixels += numPixels; <br> <br> //    ,    [0-255] (uint) <br> uint encodedLumaUint = lumaValue; <br> <br> //        <br> float numberOfPixelsWithCurrentLuma = numPixels; <br> <br> //    ,    [0-255] (float) <br> float encodedLumaFloat = encodedLumaUint;</code> <br> <br>  Pada tahap ini, kami memperoleh nilai kecerahan yang dikodekan dalam interval [0,0f-255.f]. <br><br>  Proses decoding cukup sederhana - Anda harus membalikkan perhitungan tahap penyandian. <br><br>  Pengulangan singkat dari proses pengkodean: <br><br> <code>float luma = dot( hdrPixelColor, float3(0.2126, 0.7152, 0.0722) ); <br> ... <br> float outLuma; <br> <br> //   log(0)  undef,  log(1) = 0 <br> outLuma = luma + 1.0; <br> <br> //   <br> outLuma = log( outLuma ); <br> <br> //   128,   log(1) * 128 = 0, log(2,71828) * 128 = 128, log(7,38905) * 128 = 256 <br> outLuma = outLuma * 128 <br> <br> //   uint <br> uint outLumaUint = min( (uint) outLuma, 255);</code> <br> <br>  Untuk mendekode kecerahan, kami membalikkan proses pengkodean, misalnya, seperti ini: <br><br> <code>//    0.5f (  ,    ) <br> float fDecodedLuma = encodedLumaFloat + 0.5; <br> <br> //   : <br> <br> //   128 <br> fDecodedLuma /= 128.0; <br> <br> // exp(x),   log(x) <br> fDecodedLuma = exp(fDecodedLuma); <br> <br> //  1.0 <br> fDecodedLuma -= 1.0;</code> <br> <br>  Kemudian kita menghitung distribusi dengan mengalikan jumlah piksel dengan kecerahan yang diberikan dengan kecerahan yang didekodekan, dan menjumlahkannya sampai kita sampai pada pemrosesan piksel <i>ToTonsamaEnd</i> piksel. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah itu, kami membagi efek total pada jumlah piksel yang dianalisis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut adalah sisa dari loop (dan shader): </font><font style="vertical-align: inherit;">Shader lengkap tersedia di </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">sini</font></a><font style="vertical-align: inherit;"> . Ini sepenuhnya kompatibel dengan program </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">HLSLexplorer</font></a><font style="vertical-align: inherit;"> saya </font><font style="vertical-align: inherit;">, tanpanya saya tidak akan dapat secara efektif membuat kembali perhitungan kecerahan rata-rata di The Witcher 3 (dan semua efek lainnya juga!). </font><font style="vertical-align: inherit;">Kesimpulannya, beberapa pemikiran. Dalam hal menghitung kecerahan rata-rata, shader ini sulit dibuat ulang. Alasan utama: </font><font style="vertical-align: inherit;">1) Pemeriksaan "pending" yang aneh pada pelaksanaan siklus, butuh waktu lebih banyak daripada yang saya pikir sebelumnya. </font><font style="vertical-align: inherit;">2) Masalah dengan debugging shader komputasi ini di RenderDoc (v. 1.2).</font></font><br><br> <code>//     <br> float fCurrentLumaContribution = numberOfPixelsWithCurrentLuma * fDecodedLuma; <br> <br> // ()       . <br> float tempTotalContribution = fCurrentLumaContribution + finalAvgLuminance; <br> <br> <br> [flatten] <br> if (numProcessedPixels &gt; pixelsToConsiderEnd ) <br> { <br> //     <br> bExitLoop = true; <br> <br> //      ,     . <br> //         <br> int diff = numProcessedPixels - numProcessedPixelStart; <br> <br> //     <br> finalAvgLuminance = tempTotalContribution / float(diff); <br> } <br> else <br> { <br> //       lumaValue <br> finalAvgLuminance = tempTotalContribution; <br> lumaValue++; <br> } <br> } <br> <br> //    <br> g_avgLuminance[uint2(0,0)] = finalAvgLuminance;</code> <br> <br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operasi "ld_structured_indexable" tidak sepenuhnya didukung, meskipun hasil membaca dari indeks 0 memberikan nilai yang benar, semua yang lain mengembalikan nol, itulah sebabnya siklus terus berlanjut tanpa batas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun saya tidak dapat mencapai kode perakitan yang sama seperti aslinya (lihat screenshot di bawah untuk perbedaan), menggunakan RenderDoc saya bisa menyuntikkan shader ini ke dalam pipa - dan hasilnya sama!</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de1/a0e/74f/de1a0e74f0f6619994d1edc9621d148d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasil pertempuran. </font><font style="vertical-align: inherit;">Di sebelah kiri adalah shader saya, di sebelah kanan adalah kode assembler asli.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagian 8. Bulan dan fasanya </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada bagian kedelapan artikel, saya memeriksa shader bulan dari The Witcher 3 (dan lebih khusus lagi, dari ekstensi Darah dan Anggur). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bulan adalah elemen penting dari langit malam, dan itu bisa sangat sulit untuk membuatnya dapat dipercaya, tetapi bagi saya berjalan di malam hari di TW3 benar-benar menyenangkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lihat saja adegan ini!</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53f/099/b6c/53f099b6ccfcef0eeb0755ced73894b9.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum kita mengambil pixel shader, saya akan mengatakan beberapa kata tentang nuansa rendering. Dari sudut pandang geometris, Bulan hanyalah sebuah bola (lihat di bawah), yang memiliki koordinat tekstur, vektor normal dan garis singgung. Vertex shader menghitung posisi di ruang dunia, serta vektor normals yang dinormalisasi, garis singgung dan garis singgung ke dua titik (menggunakan produk vektor), dikalikan dengan matriks dunia. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memastikan bahwa Bulan terletak sepenuhnya pada pesawat remote, bidang dan MinDepth MaxDepth struktur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D3D11_VIEWPORT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ditugaskan nilai 0.0 (trik yang sama yang digunakan untuk kubah langit). Bulan dirender segera setelah langit.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f5/999/ec7/6f5999ec7ca1176dfac370f60820d97f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bola yang digunakan untuk menggambar bulan.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nah, semuanya, saya pikir, Anda bisa melanjutkan. </font><font style="vertical-align: inherit;">Mari kita lihat pixel shader: </font><font style="vertical-align: inherit;">Alasan utama saya memilih shader dari Blood and Wine adalah sederhana - lebih pendek. </font><font style="vertical-align: inherit;">Pertama, kami menghitung offset untuk sampel tekstur. </font><font style="vertical-align: inherit;">cb0 [0] .w digunakan sebagai offset di sepanjang sumbu X. Dengan trik sederhana ini kita dapat mensimulasikan rotasi bulan di sekitar porosnya.</font></font><br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[1], immediateIndexed <br> dcl_constantbuffer cb2[3], immediateIndexed <br> dcl_constantbuffer cb12[267], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_input_ps linear v1.w <br> dcl_input_ps linear v2.xyzw <br> dcl_input_ps linear v3.xy <br> dcl_input_ps linear v4.xy <br> dcl_output o0.xyzw <br> dcl_temps 3 <br> 0: mov r0.x, -cb0[0].w <br> 1: mov r0.y, l(0) <br> 2: add r0.xy, r0.xyxx, v2.xyxx <br> 3: sample_indexable(texture2d)(float,float,float,float) r0.xyzw, r0.xyxx, t0.xyzw, s0 <br> 4: add r0.xyz, r0.xyzx, l(-0.500000, -0.500000, -0.500000, 0.000000) <br> 5: log r0.w, r0.w <br> 6: mul r0.w, r0.w, l(2.200000) <br> 7: exp r0.w, r0.w <br> 8: add r0.xyz, r0.xyzx, r0.xyzx <br> 9: dp3 r1.x, r0.xyzx, r0.xyzx <br> 10: rsq r1.x, r1.x <br> 11: mul r0.xyz, r0.xyzx, r1.xxxx <br> 12: mul r1.xy, r0.yyyy, v3.xyxx <br> 13: mad r0.xy, v4.xyxx, r0.xxxx, r1.xyxx <br> 14: mad r0.xy, v2.zwzz, r0.zzzz, r0.xyxx <br> 15: mad r0.z, cb0[0].y, l(0.033864), cb0[0].w <br> 16: mul r0.z, r0.z, l(6.283185) <br> 17: sincos r1.x, r2.x, r0.z <br> 18: mov r2.y, r1.x <br> 19: dp2_sat r0.x, r0.xyxx, r2.xyxx <br> 20: mul r0.xyz, r0.xxxx, cb12[266].xyzx <br> 21: mul r0.xyz, r0.xyzx, r0.wwww <br> 22: mul r0.xyz, r0.xyzx, cb2[2].xyzx <br> 23: add_sat r0.w, -v1.w, l(1.000000) <br> 24: mul r0.w, r0.w, cb2[2].w <br> 25: mul o0.xyz, r0.wwww, r0.xyzx <br> 26: mov o0.w, l(0) <br> 27: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc2/ddb/c02/fc2ddbc0262d27002f70d837a623c366.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh nilai dari buffer konstan.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Satu tekstur (1024x512) dilampirkan sebagai input. </font><font style="vertical-align: inherit;">Peta normal dikodekan dalam saluran RGB, dan warna permukaan bulan di saluran alfa. </font><font style="vertical-align: inherit;">Pandai!</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/392/733/1a1/3927331a17867d712e667c36a0ee6641.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saluran alfa dari suatu tekstur adalah warna permukaan bulan.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/542/d70/c64542d70a7e3b58aa9426f12e8880d7.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tekstur saluran RGB adalah peta normal.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Setelah menerima koordinat tekstur yang benar, kami mencicipi saluran RGBA. Kita perlu membongkar peta normal dan melakukan koreksi gamma pada warna permukaan. Saat ini, shader HLSL dapat ditulis seperti ini, misalnya: </font><font style="vertical-align: inherit;">Langkah selanjutnya adalah melakukan penjilidan normal, tetapi hanya di komponen XY. (Dalam The Witcher 3, sumbu Z naik, dan seluruh saluran Z tekstur adalah 1.0). Kita dapat melakukannya dengan cara ini: </font><font style="vertical-align: inherit;">Sekarang saatnya untuk bagian favorit saya dari shader ini. </font><font style="vertical-align: inherit;">Lihat </font><font style="vertical-align: inherit;">lagi pada baris 15-16: </font><font style="vertical-align: inherit;">Apakah 0,033864 yang misterius ini? Pada awalnya, tampaknya itu tidak masuk akal, tetapi jika kita menghitung nilai kebalikannya, kita mendapatkan sekitar 29,53, yang sama dengan durasi </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">bulan sinode.</font></a></font><br><br> <code>float4 MoonPS(in InputStruct IN) : SV_Target0 <br> { <br> //  Texcoords <br> float2 uvOffsets = float2(-cb0_v0.w, 0.0); <br> <br> //  texcoords <br> float2 uv = IN.param2.xy + uvOffsets; <br> <br> //   <br> float4 sampledTexture = texture0.Sample( sampler0, uv); <br> <br> //    -  - <br> float moonColorTex = pow(sampledTexture.a, 2.2 ); <br> <br> //     [0,1]   [-1,1]. <br> // : sampledTexture.xyz * 2.0 - 1.0    <br> float3 sampledNormal = normalize((sampledTexture.xyz - 0.5) * 2);</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>//    <br> float3 Tangent = IN.param4.xyz; <br> float3 Normal = float3(IN.param2.zw, IN.param3.w); <br> float3 Bitangent = IN.param3.xyz; <br> <br> //  TBN <br> float3x3 TBN = float3x3(Tangent, Bitangent, Normal); <br> <br> //    XY <br> //   TBN  float3x2: 3 , 2  <br> float2 vNormal = mul(sampledNormal, (float3x2)TBN).xy;</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>15: mad r0.z, cb0[0].y, l(0.033864), cb0[0].w <br> 16: mul r0.z, r0.z, l(6.283185)</code> <br> <br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam beberapa hari! </font><font style="vertical-align: inherit;">Inilah yang saya perhatikan detail! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami dapat mengasumsikan bahwa cb0 [0] .y adalah jumlah hari yang telah berlalu selama bermain game. </font><font style="vertical-align: inherit;">Deviasi tambahan digunakan di sini, digunakan sebagai offset di sepanjang sumbu x tekstur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah menerima koefisien ini, kami mengalikannya dengan 2 * Pi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemudian menggunakan sincos kita menghitung vektor 2d lainnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan menghitung produk skalar antara vektor normal dan vektor "bulan", satu fase bulan disimulasikan. </font><font style="vertical-align: inherit;">Lihatlah tangkapan layar dengan berbagai fase bulan:</font></font><br><br> <code>//  . <br> //   days/29.53 + bias. <br> float phase = cb0_v0.y * (1.0 / SYNODIC_MONTH_LENGTH) + cb0_v0.w; <br> <br> //   2*PI.  , 29.53     <br> //   sin/cos. <br> phase *= TWOPI; <br> <br> //      . <br> float outSin = 0.0; <br> float outCos = 0.0; <br> sincos(phase, outSin, outCos); <br> <br> //    <br> float lunarPhase = saturate( dot(vNormal, float2(outCos, outSin)) );</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c54/e7f/648/c54e7f6488b10d402a7f4b45e61d455d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/899/133/edc/899133edc0c04c67ffb4987748e908b7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langkah terakhir adalah melakukan serangkaian operasi multiplikasi untuk menghitung warna akhir. </font><font style="vertical-align: inherit;">Anda mungkin tidak mengerti mengapa shader ini mengirimkan nilai alpha 0,0 ke output. </font><font style="vertical-align: inherit;">Ini karena bulan dirender dengan blending diaktifkan:</font></font><br><br> <code>//        . <br> <br> // cb12_v266.xyz ,      . <br> //  (1.54, 2.82, 4.13) <br> float3 moonSurfaceGlowColor = cb12_v266.xyz; <br> <br> float3 moonColor = lunarPhase * moonSurfaceGlowColor; <br> moonColor = moonColorTex * moonColor; <br> <br> // cb_v2.xyz - , , ,  (1.0, 1.0, 1.0) <br> moonColor *= cb2_v2.xyz; <br> <br> //   ,    , .  -   . <br> //     ,         , <br> //   . <br> float paramHorizon = saturate(1.0 - IN.param1.w); <br> paramHorizon *= cb2_v2.w; <br> <br> moonColor *= paramHorizon; <br> <br> //        <br> return float4(moonColor, 0.0);</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d9/549/32c/2d954932c188bcdcdd0a156796b85da7.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pendekatan ini memungkinkan Anda untuk mendapatkan warna latar belakang (langit) jika shader ini kembali hitam. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda tertarik pada shader lengkap, maka Anda dapat membawanya di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ini memiliki buffer konstan besar dan harus sudah siap untuk injeksi ke RenderDoc bukan shader asli (cukup ganti nama "MoonPS" menjadi "EditedShaderPS"). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan yang terakhir: Saya ingin berbagi hasil dengan Anda: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sebelah kiri adalah shader saya, di sebelah kanan adalah shader asli dari permainan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perbedaannya minimal dan tidak mempengaruhi hasil.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff8/c4a/8fa/ff8c4a8fa103b9592941c965ad060729.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seperti yang Anda lihat, shader ini cukup mudah dibuat ulang. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagian 9. G-buffer </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada bagian ini, saya akan mengungkapkan beberapa detail gbuffer di The Witcher 3. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan menganggap bahwa Anda mengetahui dasar-dasar peneduhan yang ditangguhkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengulangan singkat: ide menunda bukan untuk menghitung semua pencahayaan jadi dan bayangan sekaligus, tetapi untuk membagi perhitungan menjadi dua tahap. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada yang pertama (lintasan geometri) kami mengisi GBuffer dengan data permukaan (posisi, normal, warna specular, dll ...), dan pada lintasan yang kedua (penerangan penerangan) kami menggabungkan semuanya dan menghitung pencahayaan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peneduhan ditangguhkan adalah pendekatan yang sangat populer karena memungkinkan Anda untuk menghitung dalam satu layar penuh lulus dengan teknik seperti </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peneduhan ubin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang sangat meningkatkan kinerja.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sederhananya, GBuffer adalah sekumpulan tekstur dengan properti geometri. </font><font style="vertical-align: inherit;">Sangat penting untuk membuat struktur yang tepat untuk itu. </font><font style="vertical-align: inherit;">Sebagai contoh dari kehidupan nyata, Anda dapat mempelajari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">teknologi rendering Crysis 3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah pengantar singkat ini, mari kita lihat contoh frame dari The Witcher 3: Blood and Wine:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c3/6f5/537/2c36f5537e82217c31d0f5f682b17b6c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salah satu dari banyak hotel di Toussent</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Basic GBuffer terdiri dari tiga target render layar penuh dalam format DXGI_FORMAT_R8G8B8A8_UNORM dan buffer stensil kedalaman + dalam format DXGI_FORMAT_D24_UNORM_S8_UINT. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut screenshot mereka:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/309/dec/857/309dec857a7839f41984b44ff82516ab.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Render Target 0 - saluran RGB, warna permukaan</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16c/44c/b90/16c44cb90b067cb420d921e101319bb0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Render Target 0 - saluran alpha. </font><font style="vertical-align: inherit;">Jujur, saya tidak tahu apa informasi ini.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de9/f1a/cf3/de9f1acf36c9f9e18ec6f4a9708ede11.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Render Target 1 - saluran RGB. </font><font style="vertical-align: inherit;">Vektor normal dalam interval [0-1] direkam di sini.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a5/a60/1e8/0a5a601e893d88a619b94f1ed7d21ae2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Render Target 1 - saluran alpha. </font><font style="vertical-align: inherit;">Tampak seperti reflektifitas!</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fa/8f5/d61/7fa8f5d61cfc903b764eec1e9b46c431.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Render Target 2 - saluran RGB. </font><font style="vertical-align: inherit;">Tampak seperti warna specular! </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam adegan ini, saluran alfa berwarna hitam (tetapi kemudian digunakan).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7e/27d/dab/e7e27ddab2102174b3f63bb9037e28a0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kedalaman penyangga. </font><font style="vertical-align: inherit;">Perhatikan bahwa kedalaman terbalik digunakan di sini.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4e/77d/daa/e4e77ddaa01705381f956410f546fdf4.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buffer stensil digunakan untuk menandai jenis piksel tertentu (misalnya, kulit, vegetasi, dll.)</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ini bukan seluruh GBuffer. </font><font style="vertical-align: inherit;">Pass pencahayaan juga menggunakan probe pencahayaan dan buffer lainnya, tetapi saya tidak akan membahasnya di artikel ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum melanjutkan ke bagian "utama" dari pos, saya akan memberikan pengamatan umum:</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengamatan umum </font></font></h3><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) Satu-satunya penyangga yang harus dibersihkan adalah penyangga kedalaman / stensil.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika Anda menganalisis tekstur yang disebutkan di atas dalam penganalisis bingkai yang baik, Anda akan sedikit terkejut, karena mereka tidak menggunakan panggilan "Hapus", dengan pengecualian Kedalaman / Stensil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada kenyataannya, RenderTarget1 terlihat seperti ini (perhatikan piksel "buram" di pesawat jauh):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22a/16a/3a7/22a16a3a7df971c2d1609f15e254cd06.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah optimasi sederhana dan cerdas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pelajaran penting: </font><font style="vertical-align: inherit;">Anda perlu menghabiskan sumber daya </font><font style="vertical-align: inherit;">pada panggilan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ClearRenderTargetView</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , jadi gunakan hanya saat diperlukan. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) terbalik kedalaman - itu adalah dingin</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">banyak </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang sudah </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ditulis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tentang akurasi buffer mendalam dengan floating point. Witcher 3 menggunakan terbalik-z. Ini adalah pilihan alami untuk gim dunia terbuka dengan jarak render yang panjang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beralih ke DirectX tidak akan sulit: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Kami menghapus buffer kedalaman dengan menulis "0", bukan "1". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam pendekatan tradisional, nilai jauh "1" digunakan untuk menghapus buffer kedalaman. Setelah flip kedalaman, nilai "jauh" baru menjadi 0, jadi Anda perlu mengubah semuanya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Tukar batas dekat dan jauh ketika menghitung matriks proyeksi </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c) Ubah pemeriksaan kedalaman dari "kurang" menjadi "lebih" </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk OpenGL, sedikit lebih banyak pekerjaan yang harus dilakukan (lihat artikel yang disebutkan di atas), tetapi itu sepadan. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3) Kami tidak menjaga posisi kami di dunia.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ya, semuanya sangat sederhana. </font><font style="vertical-align: inherit;">Dalam perjalanan pencahayaan, kita menciptakan kembali posisi di dunia dari kedalaman.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada bagian ini, saya ingin menunjukkan pixel shader yang memasok data permukaan ke GBuffer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi sekarang kita sudah tahu cara menyimpan warna, normals dan specular. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentu saja, semuanya tidak sesederhana yang Anda bayangkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah dengan pixel shader adalah ia memiliki banyak opsi. </font><font style="vertical-align: inherit;">Mereka berbeda dalam jumlah tekstur yang ditransfer ke mereka dan jumlah parameter yang digunakan dari buffer konstan (mungkin dari buffer konstan menggambarkan materi). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk analisis, saya memutuskan untuk menggunakan tong yang indah ini:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/262/635/aa0/262635aa0a42dde5353586c867bc91d1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Barel heroik kami! </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Harap sambut teksturnya:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e4/fde/9bb/9e4fde9bbe2ebcc3c1088eff5e3ea40d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi kami memiliki Albedo, peta normal, dan warna specular. Kasing standar cantik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum kita mulai, beberapa kata tentang input geometri: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geometri ditransmisikan dengan posisi, texcoords, buffer normal dan tangen. </font><font style="vertical-align: inherit;">Vertex </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shader menghasilkan </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setidaknya</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> texcoords, vektor tangen / normal / tangen dinormalisasi menjadi dua titik, yang sebelumnya dikalikan dengan matriks dunia. Untuk bahan yang lebih kompleks (misalnya, dengan dua peta difus atau dua peta normal), vertex shader dapat menampilkan data lain, tetapi saya ingin menunjukkan contoh sederhana di sini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pixel shader dalam kode assembler: </font><font style="vertical-align: inherit;">Shader terdiri dari beberapa langkah. Saya akan menjelaskan setiap bagian utama dari shader ini secara terpisah.</font></font><br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb4[3], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_sampler s13, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_resource_texture2d (float,float,float,float) t2 <br> dcl_resource_texture2d (float,float,float,float) t13 <br> dcl_input_ps linear v0.zw <br> dcl_input_ps linear v1.xyzw <br> dcl_input_ps linear v2.xyz <br> dcl_input_ps linear v3.xyz <br> dcl_input_ps_sgv v4.x, isfrontface <br> dcl_output o0.xyzw <br> dcl_output o1.xyzw <br> dcl_output o2.xyzw <br> dcl_temps 3 <br> 0: sample_indexable(texture2d)(float,float,float,float) r0.xyzw, v1.xyxx, t1.xyzw, s0 <br> 1: sample_indexable(texture2d)(float,float,float,float) r1.xyz, v1.xyxx, t0.xyzw, s0 <br> 2: add r1.w, r1.y, r1.x <br> 3: add r1.w, r1.z, r1.w <br> 4: mul r2.x, r1.w, l(0.333300) <br> 5: add r2.y, l(-1.000000), cb4[1].x <br> 6: mul r2.y, r2.y, l(0.500000) <br> 7: mov_sat r2.z, r2.y <br> 8: mad r1.w, r1.w, l(-0.666600), l(1.000000) <br> 9: mad r1.w, r2.z, r1.w, r2.x <br> 10: mul r2.xzw, r1.xxyz, cb4[0].xxyz <br> 11: mul_sat r2.xzw, r2.xxzw, l(1.500000, 0.000000, 1.500000, 1.500000) <br> 12: mul_sat r1.w, abs(r2.y), r1.w <br> 13: add r2.xyz, -r1.xyzx, r2.xzwx <br> 14: mad r1.xyz, r1.wwww, r2.xyzx, r1.xyzx <br> 15: max r1.w, r1.z, r1.y <br> 16: max r1.w, r1.w, r1.x <br> 17: lt r1.w, l(0.220000), r1.w <br> 18: movc r1.w, r1.w, l(-0.300000), l(-0.150000) <br> 19: mad r1.w, v0.z, r1.w, l(1.000000) <br> 20: mul o0.xyz, r1.wwww, r1.xyzx <br> 21: add r0.xyz, r0.xyzx, l(-0.500000, -0.500000, -0.500000, 0.000000) <br> 22: add r0.xyz, r0.xyzx, r0.xyzx <br> 23: mov r1.x, v0.w <br> 24: mov r1.yz, v1.zzwz <br> 25: mul r1.xyz, r0.yyyy, r1.xyzx <br> 26: mad r1.xyz, v3.xyzx, r0.xxxx, r1.xyzx <br> 27: mad r0.xyz, v2.xyzx, r0.zzzz, r1.xyzx <br> 28: uge r1.x, l(0), v4.x <br> 29: if_nz r1.x <br> 30: dp3 r1.x, v2.xyzx, r0.xyzx <br> 31: mul r1.xyz, r1.xxxx, v2.xyzx <br> 32: mad r0.xyz, -r1.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), r0.xyzx <br> 33: endif <br> 34: sample_indexable(texture2d)(float,float,float,float) r1.xyz, v1.xyxx, t2.xyzw, s0 <br> 35: max r1.w, r1.z, r1.y <br> 36: max r1.w, r1.w, r1.x <br> 37: lt r1.w, l(0.200000), r1.w <br> 38: movc r2.xyz, r1.wwww, r1.xyzx, l(0.120000, 0.120000, 0.120000, 0.000000) <br> 39: add r2.xyz, -r1.xyzx, r2.xyzx <br> 40: mad o2.xyz, v0.zzzz, r2.xyzx, r1.xyzx <br> 41: lt r1.x, r0.w, l(0.330000) <br> 42: mul r1.y, r0.w, l(0.950000) <br> 43: movc r1.x, r1.x, r1.y, l(0.330000) <br> 44: add r1.x, -r0.w, r1.x <br> 45: mad o1.w, v0.z, r1.x, r0.w <br> 46: dp3 r0.w, r0.xyzx, r0.xyzx <br> 47: rsq r0.w, r0.w <br> 48: mul r0.xyz, r0.wwww, r0.xyzx <br> 49: max r0.w, abs(r0.y), abs(r0.x) <br> 50: max r0.w, r0.w, abs(r0.z) <br> 51: lt r1.xy, abs(r0.zyzz), r0.wwww <br> 52: movc r1.yz, r1.yyyy, abs(r0.zzyz), abs(r0.zzxz) <br> 53: movc r1.xy, r1.xxxx, r1.yzyy, abs(r0.yxyy) <br> 54: lt r1.z, r1.y, r1.x <br> 55: movc r1.xy, r1.zzzz, r1.xyxx, r1.yxyy <br> 56: div r1.z, r1.y, r1.x <br> 57: div r0.xyz, r0.xyzx, r0.wwww <br> 58: sample_l(texture2d)(float,float,float,float) r0.w, r1.xzxx, t13.yzwx, s13, l(0) <br> 59: mul r0.xyz, r0.wwww, r0.xyzx <br> 60: mad o1.xyz, r0.xyzx, l(0.500000, 0.500000, 0.500000, 0.000000), l(0.500000, 0.500000, 0.500000, 0.000000) <br> 61: mov o0.w, cb4[2].x <br> 62: mov o2.w, l(0) <br> 63: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tapi pertama-tama, seperti biasa - tangkapan layar dengan nilai dari buffer konstan: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e94/24c/abb/e9424cabbd31630a47b7489e0e32c6af.jpg"></div><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Albedo </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan mulai dengan hal-hal yang kompleks. </font><font style="vertical-align: inherit;">Ini bukan hanya </font></font><strike><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"OutputColor.rgb = Texture.Sample (uv) .rgb"</font></font></strike> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Setelah mengambil sampel tekstur warna RGB (baris 1), 14 baris berikutnya adalah apa yang saya sebut "buffer pengurangan saturasi". </font><font style="vertical-align: inherit;">Mari saya tunjukkan kode HLSL: </font><font style="vertical-align: inherit;">Untuk sebagian besar objek, kode ini tidak melakukan apa-apa selain mengembalikan warna asli dari tekstur. </font><font style="vertical-align: inherit;">Ini dicapai dengan nilai "material cbuffer" yang sesuai. </font><font style="vertical-align: inherit;">cb4_v1.x memiliki nilai 1.0, yang mengembalikan mask 0,0 dan mengembalikan warna input dari instruksi </font><i><font style="vertical-align: inherit;">lerp</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Namun, ada beberapa pengecualian. </font><i><font style="vertical-align: inherit;">DesaturationFactor</font></i><font style="vertical-align: inherit;"> terbesar yang </font><font style="vertical-align: inherit;">saya </font><i><font style="vertical-align: inherit;">temukan</font></i><font style="vertical-align: inherit;"> adalah 4.0 (tidak pernah kurang dari 1.0), dan </font><i><font style="vertical-align: inherit;">desaturatedColor</font></i></font><br><br> <code>float3 albedoColorFilter( in float3 color, in float desaturationFactor, in float3 desaturationValue ) <br> { <br> float sumColorComponents = color.r + color.g + color.b; <br> <br> float averageColorComponentValue = 0.3333 * sumColorComponents; <br> float oneMinusAverageColorComponentValue = 1.0 - averageColorComponentValue; <br> <br> float factor = 0.5 * (desaturationFactor - 1.0); <br> <br> float avgColorComponent = lerp(averageColorComponentValue, oneMinusAverageColorComponentValue, saturate(factor)); <br> float3 desaturatedColor = saturate(color * desaturationValue * 1.5); <br> <br> float mask = saturate( avgColorComponent * abs(factor) ); <br> <br> float3 finalColor = lerp( color, desaturatedColor, mask ); <br> return finalColor; <br> }</code> <br> <br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tergantung bahannya. </font><font style="vertical-align: inherit;">Itu bisa seperti (0.2, 0.3, 0.4); </font><font style="vertical-align: inherit;">Tidak ada aturan ketat. </font><font style="vertical-align: inherit;">Tentu saja, saya tidak bisa menolak menerapkan ini dalam kerangka DX11 saya sendiri, dan di sini adalah hasil di mana semua nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaturatedColor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sama dengan float3 (0,25, 0,3, 0,45)</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12f/184/2d9/12f1842d9d272fc057f35bc73439c4c1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaturationFactor = 1.0 (tidak berpengaruh)</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03c/ead/3a3/03cead3a3d5a713e051e7d863d99ecb0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaturationFactor = 2.0</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/caf/c81/992/cafc81992ebb70914c1e9d6605b8ba17.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaturationFactor = 3.0</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f37/193/7fb/f371937fb39f94a887410a951f9eb628.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaturationFactor = 4.0</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saya yakin ini hanya aplikasi parameter material, tetapi tidak dilakukan di akhir bagian albedo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baris 15-20 menambahkan sentuhan akhir: </font><font style="vertical-align: inherit;">v0.z adalah output dari vertex shader, dan semuanya nol. </font><font style="vertical-align: inherit;">Jangan lupakan itu, karena v0.z nantinya akan digunakan beberapa kali. </font><font style="vertical-align: inherit;">Sepertinya itu semacam koefisien, dan seluruh kode tampak seperti albedo peredupan sedikit, tetapi karena v0.z adalah 0, warnanya tetap tidak berubah. </font><font style="vertical-align: inherit;">HLSL: </font><font style="vertical-align: inherit;">Mengenai RT0.a, seperti yang dapat kita lihat, ini diambil dari buffer konstanta material, tetapi karena shader tidak memiliki informasi debug, sulit untuk mengatakan apa itu. </font><font style="vertical-align: inherit;">Mungkin tembus cahaya? </font><font style="vertical-align: inherit;">Kami selesai dengan target render pertama!</font></font><br><br> <code>15: max r1.w, r1.z, r1.y <br> 16: max r1.w, r1.w, r1.x <br> 17: lt r1.w, l(0.220000), r1.w <br> 18: movc r1.w, r1.w, l(-0.300000), l(-0.150000) <br> 19: mad r1.w, v0.z, r1.w, l(1.000000) <br> 20: mul o0.xyz, r1.wwww, r1.xyzx</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>/* ALBEDO */ <br> //     (?) <br> float3 albedoColor = albedoColorFilter( colorTex, cb4_v1.x, cb4_v0.rgb ); <br> float albedoMaxComponent = getMaxComponent( albedoColor ); <br> <br> //   ,   <br> //       "paramZ"   0 <br> float paramZ = Input.out0.z; // ,    0 <br> <br> // ,  0.70  0.85      <br> //       lerp,     . <br> float param = (albedoMaxComponent &gt; 0.22) ? 0.70 : 0.85; <br> float mulParam = lerp(1, param, paramZ); <br> <br> //  <br> pout.RT0.rgb = albedoColor * mulParam; <br> pout.RT0.a = cb4_v2.x;</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Normal </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita mulai dengan membongkar peta normal, dan kemudian, seperti biasa, kita akan mengikat normals: </font><font style="vertical-align: inherit;">Sejauh ini, tidak ada yang mengejutkan. </font><i><font style="vertical-align: inherit;">Lihatlah baris 28-33:</font></i><font style="vertical-align: inherit;"> Kita dapat menuliskannya secara kasar sebagai berikut: </font><font style="vertical-align: inherit;">Tidak yakin apakah itu benar untuk ditulis. </font><font style="vertical-align: inherit;">Jika Anda tahu operasi matematika ini, beri tahu saya. </font><font style="vertical-align: inherit;">Kami melihat bahwa pixel shader menggunakan SV_IsFrontFace.</font></font><br><br> <code>/*  */ <br> float3 sampledNormal = ((normalTex.xyz - 0.5) * 2); <br> <br> //     TBN <br> float3 Tangent = Input.TangentW.xyz; <br> float3 Normal = Input.NormalW.xyz; <br> float3 Bitangent; <br> Bitangent.x = Input.out0.w; <br> Bitangent.yz = Input.out1.zw; <br> <br> //      ;  ,  ,   normal-tbn <br> //      'mad'   'mov' <br> Bitangent = saturate(Bitangent); <br> <br> float3x3 TBN = float3x3(Tangent, Bitangent, Normal); <br> float3 normal = mul( sampledNormal, TBN );</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <i><font style="vertical-align: inherit;"></font></i> <br><br> <code>28: uge r1.x, l(0), v4.x <br> 29: if_nz r1.x <br> 30: dp3 r1.x, v2.xyzx, r0.xyzx <br> 31: mul r1.xyz, r1.xxxx, v2.xyzx <br> 32: mad r0.xyz, -r1.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), r0.xyzx <br> 33: endif</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>[branch] if (bIsFrontFace &lt;= 0) <br> { <br> float cosTheta = dot(Input.NormalW, normal); <br> float3 invNormal = cosTheta * Input.NormalW; <br> normal = normal - 2*invNormal; <br> }</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br>  Apa ini<font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> datang untuk membantu </font><font style="vertical-align: inherit;">(saya ingin menulis "msdn", tetapi ...):</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menentukan apakah segitiga melihat kamera. </font><font style="vertical-align: inherit;">Untuk garis dan titik, IsFrontFace benar. </font><font style="vertical-align: inherit;">Pengecualian adalah garis yang diambil dari segitiga (mode wireframe), yang mengatur IsFrontFace mirip dengan rasterisasi sebuah segitiga dalam mode padat. </font><font style="vertical-align: inherit;">Menulis untuk itu dapat dilakukan oleh geometri shader, dan membaca darinya dengan pixel shader.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya ingin memeriksanya sendiri. </font><font style="vertical-align: inherit;">Dan pada kenyataannya, efeknya hanya terlihat dalam mode wireframe. </font><font style="vertical-align: inherit;">Saya percaya potongan kode ini diperlukan untuk perhitungan normals yang benar (dan karenanya pencahayaan) dalam mode wireframe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut ini perbandingannya: baik warna bingkai adegan yang sudah selesai dengan trik on / off ini, maupun tekstur gbuffer [0-1] normals dengan trick on / off:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/598/46b/81b/59846b81b8b9ed57f0441f29e22e6656.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warna adegan tanpa trik</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/590/7e1/a97/5907e1a978e58b6fa362ef2e4b6187a8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adegan warna dengan aksi</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/745/09a/c0e/74509ac0e56fa639ec4ae2d70a39be44.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normal [0-1] tidak ada trik</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db8/2f8/622/db82f86223182135807d316fe479ff08.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normal [0-1] dengan trik</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pernahkah Anda memperhatikan bahwa setiap target render di GBuffer memiliki format R8G8B8A8_UNORM? Ini berarti ada 256 nilai yang mungkin per komponen. Apakah ini cukup untuk menyimpan normals? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menyimpan normals berkualitas tinggi dengan byte yang cukup di Gbuffer adalah masalah yang diketahui, tetapi untungnya ada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">banyak </font></font></a> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">bahan yang </font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berbeda</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">dipelajari</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Mungkin beberapa dari Anda sudah tahu teknik apa yang digunakan di sini. Saya harus mengatakan bahwa di seluruh bagian geometri ada satu tekstur tambahan yang melekat pada slot 13 ...:</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab1/e4a/0bf/ab1e4a0bf128bfed8837d3cd081748f8.jpg"></div><br><br>  Ha!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Witcher 3 menggunakan teknik yang disebut " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Best Fit Normals</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ." </font><font style="vertical-align: inherit;">Di sini saya tidak akan menjelaskannya secara detail (lihat presentasi). </font><font style="vertical-align: inherit;">Itu diciptakan sekitar 2009-2010 oleh Crytek, dan karena CryEngine memiliki open source, BFN juga </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">open source</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BFN memberi tekstur tampilan yang "kasar" pada normals. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah penskalaan normalnya menggunakan BFN, kami mengode ulangnya dari interval [-1; 1] ke [0, 1].</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Specular </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita mulai dari baris 34 dan sampel tekstur specular: </font><font style="vertical-align: inherit;">Seperti yang Anda lihat, ada filter "peredupan" yang kita tahu dari Albedo: Kami </font><font style="vertical-align: inherit;">menghitung komponen dengan maks. </font><font style="vertical-align: inherit;">nilai, dan kemudian menghitung warna "gelap" dan menyisipkannya dengan warna specular asli, mengambil parameter dari vertex shader ... yaitu 0, jadi pada output kita mendapatkan warna dari tekstur. </font><font style="vertical-align: inherit;">HLSL:</font></font><br><br> <code>34: sample_indexable(texture2d)(float,float,float,float) r1.xyz, v1.xyxx, t2.xyzw, s0 <br> 35: max r1.w, r1.z, r1.y <br> 36: max r1.w, r1.w, r1.x <br> 37: lt r1.w, l(0.200000), r1.w <br> 38: movc r2.xyz, r1.wwww, r1.xyzx, l(0.120000, 0.120000, 0.120000, 0.000000) <br> 39: add r2.xyz, -r1.xyzx, r2.xyzx <br> 40: mad o2.xyz, v0.zzzz, r2.xyzx, r1.xyzx</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>/* SPECULAR */ <br> float3 specularTex = texture2.Sample( samplerAnisoWrap, Texcoords ).rgb; <br> <br> //   ,    Albedo.  . ,    <br> // -        "". <br> //      paramZ   0,    <br> //  . <br> float specularMaxComponent = getMaxComponent( specularTex ); <br> float3 specB = (specularMaxComponent &gt; 0.2) ? specularTex : float3(0.12, 0.12, 0.12); <br> float3 finalSpec = lerp(specularTex, specB, paramZ); <br> pout.RT2.xyz = finalSpec;</code> <br> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reflektivitas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya tidak tahu apakah nama ini cocok untuk parameter ini, karena saya tidak tahu bagaimana ini mempengaruhi jalannya pencahayaan. </font><font style="vertical-align: inherit;">Faktanya adalah saluran alfa dari peta normal input berisi data tambahan:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d2/9e5/bd1/5d29e5bd1cb4888593139c38630e3f8e.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tekstur saluran alfa "peta normal". </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode Assembler: </font><font style="vertical-align: inherit;">Katakan halo kepada teman lama kita - v0.z! </font><font style="vertical-align: inherit;">Artinya mirip dengan Albedo dan specular:</font></font><br><br> <code>41: lt r1.x, r0.w, l(0.330000) <br> 42: mul r1.y, r0.w, l(0.950000) <br> 43: movc r1.x, r1.x, r1.y, l(0.330000) <br> 44: add r1.x, -r0.w, r1.x <br> 45: mad o1.w, v0.z, r1.x, r0.w</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>/* REFLECTIVITY */ <br> float reflectivity = normalTex.a; <br> float reflectivity2 = (reflectivity &lt; 0.33) ? (reflectivity * 0.95) : 0.33; <br> <br> float finalReflectivity = lerp(reflectivity, reflectivity2, paramZ); <br> pout.RT1.a = finalReflectivity;</code> <br> <br>  Hebat!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah akhir dari analisis versi pertama dari shader piksel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut ini adalah perbandingan shader saya (kiri) dengan yang asli (kanan):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c1/f18/47b/2c1f1847b5ceef3cd0e2f8dfba45d2a6.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perbedaan-perbedaan ini tidak mempengaruhi perhitungan, jadi pekerjaan saya di sini selesai. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel Shader: Albedo + Opsi Normal </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya memutuskan untuk menunjukkan satu opsi lagi, sekarang hanya dengan albedo dan peta normal, tanpa tekstur specular. Kode assembler sedikit lebih panjang: </font><font style="vertical-align: inherit;">Perbedaan antara ini dan opsi sebelumnya adalah sebagai berikut: </font><font style="vertical-align: inherit;">a) </font><b><font style="vertical-align: inherit;">baris 1, 19</font></b><font style="vertical-align: inherit;"> : parameter interpolasi v0.z dikalikan dengan cb4 [0] .x dari buffer konstan, tetapi produk ini hanya digunakan untuk interpolasi albedo pada baris 19. Untuk output lain, nilai "normal" dari v0.z digunakan. </font><font style="vertical-align: inherit;">b) </font><b><font style="vertical-align: inherit;">baris 54-55</font></b><font style="vertical-align: inherit;"> : o2.w sekarang diatur dalam kondisi bahwa (cb4 [7] .x&gt; 0,0) </font><font style="vertical-align: inherit;">Kita sudah mengenali pola ini "semacam perbandingan - DAN" dari perhitungan histogram kecerahan. Dapat ditulis seperti ini: </font><font style="vertical-align: inherit;">c) </font><b><font style="vertical-align: inherit;">baris 34-42</font></b><font style="vertical-align: inherit;"> : perhitungan specular yang sama sekali berbeda.</font></font><br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb4[8], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_sampler s13, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_resource_texture2d (float,float,float,float) t13 <br> dcl_input_ps linear v0.zw <br> dcl_input_ps linear v1.xyzw <br> dcl_input_ps linear v2.xyz <br> dcl_input_ps linear v3.xyz <br> dcl_input_ps_sgv v4.x, isfrontface <br> dcl_output o0.xyzw <br> dcl_output o1.xyzw <br> dcl_output o2.xyzw <br> dcl_temps 4 <br> 0: mul r0.x, v0.z, cb4[0].x <br> 1: sample_indexable(texture2d)(float,float,float,float) r1.xyzw, v1.xyxx, t1.xyzw, s0 <br> 2: sample_indexable(texture2d)(float,float,float,float) r0.yzw, v1.xyxx, t0.wxyz, s0 <br> 3: add r2.x, r0.z, r0.y <br> 4: add r2.x, r0.w, r2.x <br> 5: add r2.z, l(-1.000000), cb4[2].x <br> 6: mul r2.yz, r2.xxzx, l(0.000000, 0.333300, 0.500000, 0.000000) <br> 7: mov_sat r2.w, r2.z <br> 8: mad r2.x, r2.x, l(-0.666600), l(1.000000) <br> 9: mad r2.x, r2.w, r2.x, r2.y <br> 10: mul r3.xyz, r0.yzwy, cb4[1].xyzx <br> 11: mul_sat r3.xyz, r3.xyzx, l(1.500000, 1.500000, 1.500000, 0.000000) <br> 12: mul_sat r2.x, abs(r2.z), r2.x <br> 13: add r2.yzw, -r0.yyzw, r3.xxyz <br> 14: mad r0.yzw, r2.xxxx, r2.yyzw, r0.yyzw <br> 15: max r2.x, r0.w, r0.z <br> 16: max r2.x, r0.y, r2.x <br> 17: lt r2.x, l(0.220000), r2.x <br> 18: movc r2.x, r2.x, l(-0.300000), l(-0.150000) <br> 19: mad r0.x, r0.x, r2.x, l(1.000000) <br> 20: mul o0.xyz, r0.xxxx, r0.yzwy <br> 21: add r0.xyz, r1.xyzx, l(-0.500000, -0.500000, -0.500000, 0.000000) <br> 22: add r0.xyz, r0.xyzx, r0.xyzx <br> 23: mov r1.x, v0.w <br> 24: mov r1.yz, v1.zzwz <br> 25: mul r1.xyz, r0.yyyy, r1.xyzx <br> 26: mad r0.xyw, v3.xyxz, r0.xxxx, r1.xyxz <br> 27: mad r0.xyz, v2.xyzx, r0.zzzz, r0.xywx <br> 28: uge r0.w, l(0), v4.x <br> 29: if_nz r0.w <br> 30: dp3 r0.w, v2.xyzx, r0.xyzx <br> 31: mul r1.xyz, r0.wwww, v2.xyzx <br> 32: mad r0.xyz, -r1.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), r0.xyzx <br> 33: endif <br> 34: add r0.w, -r1.w, l(1.000000) <br> 35: log r1.xyz, cb4[3].xyzx <br> 36: mul r1.xyz, r1.xyzx, l(2.200000, 2.200000, 2.200000, 0.000000) <br> 37: exp r1.xyz, r1.xyzx <br> 38: mad r0.w, r0.w, cb4[4].x, cb4[5].x <br> 39: mul_sat r1.xyz, r0.wwww, r1.xyzx <br> 40: log r1.xyz, r1.xyzx <br> 41: mul r1.xyz, r1.xyzx, l(0.454545, 0.454545, 0.454545, 0.000000) <br> 42: exp r1.xyz, r1.xyzx <br> 43: max r0.w, r1.z, r1.y <br> 44: max r0.w, r0.w, r1.x <br> 45: lt r0.w, l(0.200000), r0.w <br> 46: movc r2.xyz, r0.wwww, r1.xyzx, l(0.120000, 0.120000, 0.120000, 0.000000) <br> 47: add r2.xyz, -r1.xyzx, r2.xyzx <br> 48: mad o2.xyz, v0.zzzz, r2.xyzx, r1.xyzx <br> 49: lt r0.w, r1.w, l(0.330000) <br> 50: mul r1.x, r1.w, l(0.950000) <br> 51: movc r0.w, r0.w, r1.x, l(0.330000) <br> 52: add r0.w, -r1.w, r0.w <br> 53: mad o1.w, v0.z, r0.w, r1.w <br> 54: lt r0.w, l(0), cb4[7].x <br> 55: and o2.w, r0.w, l(0.064706) <br> 56: dp3 r0.w, r0.xyzx, r0.xyzx <br> 57: rsq r0.w, r0.w <br> 58: mul r0.xyz, r0.wwww, r0.xyzx <br> 59: max r0.w, abs(r0.y), abs(r0.x) <br> 60: max r0.w, r0.w, abs(r0.z) <br> 61: lt r1.xy, abs(r0.zyzz), r0.wwww <br> 62: movc r1.yz, r1.yyyy, abs(r0.zzyz), abs(r0.zzxz) <br> 63: movc r1.xy, r1.xxxx, r1.yzyy, abs(r0.yxyy) <br> 64: lt r1.z, r1.y, r1.x <br> 65: movc r1.xy, r1.zzzz, r1.xyxx, r1.yxyy <br> 66: div r1.z, r1.y, r1.x <br> 67: div r0.xyz, r0.xyzx, r0.wwww <br> 68: sample_l(texture2d)(float,float,float,float) r0.w, r1.xzxx, t13.yzwx, s13, l(0) <br> 69: mul r0.xyz, r0.wwww, r0.xyzx <br> 70: mad o1.xyz, r0.xyzx, l(0.500000, 0.500000, 0.500000, 0.000000), l(0.500000, 0.500000, 0.500000, 0.000000) <br> 71: mov o0.w, cb4[6].x <br> 72: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>pout.RT2.w = (cb4_v7.x &gt; 0.0) ? (16.5/255.0) : 0.0;</code> <br> <br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak ada tekstur specular di sini. </font><font style="vertical-align: inherit;">Mari kita lihat kode assembler yang bertanggung jawab untuk bagian ini: </font><font style="vertical-align: inherit;">Perhatikan bahwa kita digunakan di sini (1 - kemampuan tercermin). </font><font style="vertical-align: inherit;">Untungnya, menulis ini di HLSL cukup sederhana: </font><font style="vertical-align: inherit;">Saya akan menambahkan bahwa dalam versi ini buffer konstan dengan data material sedikit lebih besar. </font><font style="vertical-align: inherit;">Di sini, nilai-nilai tambahan ini digunakan untuk meniru warna specular. </font><font style="vertical-align: inherit;">Sisa shader sama dengan di versi sebelumnya. </font><font style="vertical-align: inherit;">72 baris kode assembler terlalu banyak untuk ditampilkan di WinMerge, jadi terima kata-kata saya untuk itu: kode saya ternyata hampir sama dengan yang asli. </font><font style="vertical-align: inherit;">Atau Anda dapat mengunduh </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">HLSLexplorer</font></a><font style="vertical-align: inherit;"> saya </font><font style="vertical-align: inherit;">dan lihat sendiri!</font></font><br><br> <code>34: add r0.w, -r1.w, l(1.000000) <br> 35: log r1.xyz, cb4[3].xyzx <br> 36: mul r1.xyz, r1.xyzx, l(2.200000, 2.200000, 2.200000, 0.000000) <br> 37: exp r1.xyz, r1.xyzx <br> 38: mad r0.w, r0.w, cb4[4].x, cb4[5].x <br> 39: mul_sat r1.xyz, r0.wwww, r1.xyzx <br> 40: log r1.xyz, r1.xyzx <br> 41: mul r1.xyz, r1.xyzx, l(0.454545, 0.454545, 0.454545, 0.000000) <br> 42: exp r1.xyz, r1.xyzx</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>float oneMinusReflectivity = 1.0 - normalTex.a; <br> float3 specularTex = pow(cb4_v3.rgb, 2.2); <br> oneMinusReflectivity = oneMinusReflectivity * cb4_v4.x + cb4_v5.x; <br> specularTex = saturate(specularTex * oneMinusReflectivity); <br> specularTex = pow(specularTex, 1.0/2.2); <br> <br> //     ... <br> float specularMaxComponent = getMaxComponent( specularTex ); <br> ...</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk meringkas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... dan jika Anda membacanya di sini, maka Anda mungkin ingin masuk lebih dalam. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa yang tampak sederhana dalam kehidupan nyata seringkali tidak demikian, dan transfer data ke gbuffer The Witcher 3 tidak terkecuali. </font><font style="vertical-align: inherit;">Saya menunjukkan kepada Anda hanya versi paling sederhana dari pixel shader yang bertanggung jawab untuknya, dan juga memberikan pengamatan umum yang berhubungan dengan shading yang ditangguhkan secara umum. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk sebagian besar pasien, ada dua opsi untuk pixel shaders di pastebin: </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opsi 1 - dengan tekstur specular </font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opsi 2 - tanpa tekstur specular</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagian 10. Tirai hujan di kejauhan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada bagian ini kita akan melihat efek atmosfer yang indah yang sangat saya sukai - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tirai</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hujan / cahaya </font><font style="vertical-align: inherit;">jauh di </font><font style="vertical-align: inherit;">dekat cakrawala. </font><font style="vertical-align: inherit;">Dalam permainan, mereka paling mudah untuk bertemu di Kepulauan Skellig.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/VXt4PEEqV2k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara pribadi, saya sangat menyukai fenomena atmosfer ini dan ingin tahu bagaimana programer grafis CD Projekt Red menerapkannya. </font><font style="vertical-align: inherit;">Mari kita cari tahu! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut adalah dua tangkapan layar sebelum dan sesudah menerapkan tirai hujan:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/62a/eb6/a9a62aeb6050efd2404f9d352fc89d33.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ke tirai hujan</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9aa/e43/fcf/9aae43fcf34413a4810778e101b8a209.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah tirai hujan</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Geometri </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama, kita akan fokus pada geometri. </font><font style="vertical-align: inherit;">Idenya adalah menggunakan silinder kecil:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc4/df3/add/fc4df3addf2524bc18f91c46a42fcd6a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Silinder di ruang lokal</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dari sudut pandang posisinya di ruang lokal, cukup kecil - posisinya ada di kisaran (0,0 - 1,0). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sirkuit input untuk panggilan undian ini terlihat seperti ini ...</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1d/a35/c00/c1da35c0080225e7a47d8010c42aeab8.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut ini penting bagi kami di sini: Texcoords dan Instance_Transform. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texcoords dibungkus cukup sederhana: U dari pangkalan atas dan bawah berada dalam interval [0,02777 - 1,02734]. V pada basis yang lebih rendah adalah 1.0, dan di atas - 0.0. Seperti yang Anda lihat, Anda dapat dengan mudah membuat mesh ini bahkan secara prosedural. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah menerima silinder kecil ini di ruang lokal, kami mengalikannya dengan matriks dunia yang disediakan untuk setiap instance elemen input INSTANCE_TRANSFORM. Mari kita periksa nilai dari matriks ini:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e88/791/17e/e8879117edb6f1dd9b53d3e7334a22df.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/adf/fb8/697/adffb8697a86ac86b935a00d6ae23dda.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/608/599/f6c/608599f6cf3930889c92df1a256991af.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terlihat sangat menakutkan, bukan? </font><font style="vertical-align: inherit;">Tapi jangan khawatir, kami akan menganalisis matriks ini dan melihat apa yang disembunyikannya! </font><font style="vertical-align: inherit;">Hasilnya sangat menarik: </font><font style="vertical-align: inherit;">Penting untuk mengetahui posisi kamera dalam bingkai khusus ini: (-116.5338, 234.8695, 2.09) </font><font style="vertical-align: inherit;">Seperti yang Anda lihat, kami menskalakan silinder untuk membuatnya cukup besar di ruang dunia (di TW3 sumbu Z naik), memindahkannya relatif ke posisi kamera , dan berbalik. </font><font style="vertical-align: inherit;">Beginilah bentuk silinder setelah konversi dengan vertex shader:</font></font><br><br> <code>XMMATRIX mat( -227.7472, 159.8043, 374.0736, -116.4951, <br> -194.7577, -173.3836, -494.4982, 238.6908, <br> -14.16466, -185.4743, 784.564, -1.45565, <br> 0.0, 0.0, 0.0, 1.0 ); <br> <br> mat = XMMatrixTranspose( mat ); <br> <br> XMVECTOR vScale; <br> XMVECTOR vRotateQuat; <br> XMVECTOR vTranslation; <br> XMMatrixDecompose( &amp;vScale, &amp;vRotateQuat, &amp;vTranslation, mat ); <br> <br> //  ... <br> XMMATRIX matRotate = XMMatrixRotationQuaternion( vRotateQuat );</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>vRotateQuat: (0.0924987569, -0.314900011, 0.883411944, -0.334462732) <br> <br> vScale: (299.999969, 300.000000, 1000.00012) <br> <br> vTranslation: (-116.495102, 238.690796, -1.45564997)</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f60/457/ca6/f60457ca61dd2d15ec3805b387e71def.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Silinder setelah konversi oleh vertex shader. </font><font style="vertical-align: inherit;">Lihat bagaimana letaknya relatif terhadap piramida visibilitas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vertex shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Input geometri dan vertex shader sangat tergantung satu sama lain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita lihat lebih dekat kode assembler untuk vertex shader: </font><font style="vertical-align: inherit;">Seiring dengan Texcoords (garis 0) yang lewat sederhana dan Instance_LOD_Params (baris 8), dua elemen lagi diperlukan untuk output: SV_Position (ini jelas) dan Tinggi (komponen .z) dari posisi di dunia. </font><font style="vertical-align: inherit;">Ingat bahwa ruang lokal berada dalam kisaran [0-1]? Jadi, tepat sebelum menerapkan matriks dunia, shader vertex menggunakan skala dan deviasi untuk mengubah posisi lokal. Langkah cerdas! </font><font style="vertical-align: inherit;">Dalam hal ini, skala = float3 (4, 4, 2), dan bias = float3 (-2, -2, -1). &lt; </font><font style="vertical-align: inherit;">Pola yang terlihat antara garis 9 dan 28 adalah perkalian dari dua matriks utama-baris. </font><font style="vertical-align: inherit;">Mari kita lihat vertex shader yang sudah jadi pada HLSL:</font></font><br><br> <code>vs_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb1[7], immediateIndexed <br> dcl_constantbuffer cb2[6], immediateIndexed <br> dcl_input v0.xyz <br> dcl_input v1.xy <br> dcl_input v4.xyzw <br> dcl_input v5.xyzw <br> dcl_input v6.xyzw <br> dcl_input v7.xyzw <br> dcl_output o0.xyz <br> dcl_output o1.xyzw <br> dcl_output_siv o2.xyzw, position <br> dcl_temps 2 <br> 0: mov o0.xy, v1.xyxx <br> 1: mul r0.xyzw, v5.xyzw, cb1[6].yyyy <br> 2: mad r0.xyzw, v4.xyzw, cb1[6].xxxx, r0.xyzw <br> 3: mad r0.xyzw, v6.xyzw, cb1[6].zzzz, r0.xyzw <br> 4: mad r0.xyzw, cb1[6].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 5: mad r1.xyz, v0.xyzx, cb2[4].xyzx, cb2[5].xyzx <br> 6: mov r1.w, l(1.000000) <br> 7: dp4 o0.z, r1.xyzw, r0.xyzw <br> 8: mov o1.xyzw, v7.xyzw <br> 9: mul r0.xyzw, v5.xyzw, cb1[0].yyyy <br> 10: mad r0.xyzw, v4.xyzw, cb1[0].xxxx, r0.xyzw <br> 11: mad r0.xyzw, v6.xyzw, cb1[0].zzzz, r0.xyzw <br> 12: mad r0.xyzw, cb1[0].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 13: dp4 o2.x, r1.xyzw, r0.xyzw <br> 14: mul r0.xyzw, v5.xyzw, cb1[1].yyyy <br> 15: mad r0.xyzw, v4.xyzw, cb1[1].xxxx, r0.xyzw <br> 16: mad r0.xyzw, v6.xyzw, cb1[1].zzzz, r0.xyzw <br> 17: mad r0.xyzw, cb1[1].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 18: dp4 o2.y, r1.xyzw, r0.xyzw <br> 19: mul r0.xyzw, v5.xyzw, cb1[2].yyyy <br> 20: mad r0.xyzw, v4.xyzw, cb1[2].xxxx, r0.xyzw <br> 21: mad r0.xyzw, v6.xyzw, cb1[2].zzzz, r0.xyzw <br> 22: mad r0.xyzw, cb1[2].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 23: dp4 o2.z, r1.xyzw, r0.xyzw <br> 24: mul r0.xyzw, v5.xyzw, cb1[3].yyyy <br> 25: mad r0.xyzw, v4.xyzw, cb1[3].xxxx, r0.xyzw <br> 26: mad r0.xyzw, v6.xyzw, cb1[3].zzzz, r0.xyzw <br> 27: mad r0.xyzw, cb1[3].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 28: dp4 o2.w, r1.xyzw, r0.xyzw <br> 29: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>cbuffer cbPerFrame : register (b1) <br> { <br> row_major float4x4 g_viewProjMatrix; <br> row_major float4x4 g_rainShaftsViewProjMatrix; <br> } <br> <br> cbuffer cbPerObject : register (b2) <br> { <br> float4x4 g_mtxWorld; <br> float4 g_modelScale; <br> float4 g_modelBias; <br> } <br> <br> struct VS_INPUT <br> { <br> float3 PositionW : POSITION; <br> float2 Texcoord : TEXCOORD; <br> float3 NormalW : NORMAL; <br> float3 TangentW : TANGENT; <br> float4 InstanceTransform0 : INSTANCE_TRANSFORM0; <br> float4 InstanceTransform1 : INSTANCE_TRANSFORM1; <br> float4 InstanceTransform2 : INSTANCE_TRANSFORM2; <br> float4 InstanceLODParams : INSTANCE_LOD_PARAMS; <br> }; <br> <br> struct VS_OUTPUT <br> { <br> float3 TexcoordAndZ : Texcoord0; <br> <br> float4 LODParams : LODParams; <br> float4 PositionH : SV_Position; <br> }; <br> <br> VS_OUTPUT RainShaftsVS( VS_INPUT Input ) <br> { <br> VS_OUTPUT Output = (VS_OUTPUT)0; <br> <br> //    <br> Output.TexcoordAndZ.xy = Input.Texcoord; <br> Output.LODParams = Input.InstanceLODParams; <br> <br> //   <br> float3 meshScale = g_modelScale.xyz; // float3( 4, 4, 2 ); <br> float3 meshBias = g_modelBias.xyz; // float3( -2, -2, -1 ); <br> float3 PositionL = Input.PositionW * meshScale + meshBias; <br> <br> //    instanceWorld  float4s: <br> float4x4 matInstanceWorld = float4x4(Input.InstanceTransform0, Input.InstanceTransform1, <br> Input.InstanceTransform2 , float4(0, 0, 0, 1) ); <br> <br> //     (.z) <br> float4x4 matWorldInstanceLod = mul( g_rainShaftsViewProjMatrix, matInstanceWorld ); <br> Output.TexcoordAndZ.z = mul( float4(PositionL, 1.0), transpose(matWorldInstanceLod) ).z; <br> <br> // SV_Posiiton <br> float4x4 matModelViewProjection = mul(g_viewProjMatrix, matInstanceWorld ); <br> Output.PositionH = mul( float4(PositionL, 1.0), transpose(matModelViewProjection) ); <br> <br> return Output; <br> }</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perbandingan shader saya (kiri) dan asli (kanan): </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef3/4f3/4ed/ef34f34edbc63113a08f47b7cde00df0.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perbedaan tidak memengaruhi perhitungan. </font><font style="vertical-align: inherit;">Saya menyuntikkan shader saya ke bingkai dan semuanya masih baik-baik saja!</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel shader </font></font></h3><br>  Akhirnya!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memulai, saya akan menunjukkan kepada Anda input: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dua tekstur digunakan di sini: tekstur noise dan buffer kedalaman:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/83a/558/fc3/83a558fc3c8c7e723eb85308b12657d6.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db5/0da/111/db50da111880f6b934d8bed6b74491e6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nilai dari buffer konstan: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a12/394/bdc/a12394bdc039e522beeff97b8e41cd80.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/37a/c47/485/37ac47485335960b2efbefc9f315ef14.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e7/e70/38a/4e7e7038a1bc956aadbb695d70b80ded.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/775/bc4/7ae775bc4a9388feceaa1ddf8c0a214a.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan kode perakitan pixel shader: </font><font style="vertical-align: inherit;">Wow! Jumlah yang cukup besar, tetapi pada kenyataannya, semuanya tidak terlalu buruk. </font><font style="vertical-align: inherit;">Apa yang sedang terjadi di sini? Pertama, kami menghitung animasi UV menggunakan waktu yang telah berlalu dari cbuffer (cb0 [0] .x) dan skala / offset. Texcoords ini digunakan untuk mengambil sampel dari tekstur noise (baris 2). </font><font style="vertical-align: inherit;">Setelah menerima nilai noise dari tekstur, kami menginterpolasi antara nilai min / maks (biasanya 0 dan 1). </font><font style="vertical-align: inherit;">Kemudian kita melakukan penggandaan, misalnya, dengan koordinat tekstur V (ingat bahwa koordinat V berubah dari 1 menjadi 0?) - baris 5. </font><font style="vertical-align: inherit;">Jadi, kami menghitung "topeng kecerahan" - tampilannya seperti ini:</font></font><br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[8], immediateIndexed <br> dcl_constantbuffer cb2[3], immediateIndexed <br> dcl_constantbuffer cb12[23], immediateIndexed <br> dcl_constantbuffer cb4[8], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_sampler s15, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t15 <br> dcl_input_ps linear v0.xyz <br> dcl_input_ps linear v1.w <br> dcl_input_ps_siv v2.xy, position <br> dcl_output o0.xyzw <br> dcl_temps 1 <br> 0: mul r0.xy, cb0[0].xxxx, cb4[5].xyxx <br> 1: mad r0.xy, v0.xyxx, cb4[4].xyxx, r0.xyxx <br> 2: sample_indexable(texture2d)(float,float,float,float) r0.x, r0.xyxx, t0.xyzw, s0 <br> 3: add r0.y, -cb4[2].x, cb4[3].x <br> 4: mad_sat r0.x, r0.x, r0.y, cb4[2].x <br> 5: mul r0.x, r0.x, v0.y <br> 6: mul r0.x, r0.x, v1.w <br> 7: mul r0.x, r0.x, cb4[1].x <br> 8: mul r0.yz, v2.xxyx, cb0[1].zzwz <br> 9: sample_l(texture2d)(float,float,float,float) r0.y, r0.yzyy, t15.yxzw, s15, l(0) <br> 10: mad r0.y, r0.y, cb12[22].x, cb12[22].y <br> 11: mad r0.y, r0.y, cb12[21].x, cb12[21].y <br> 12: max r0.y, r0.y, l(0.000100) <br> 13: div r0.y, l(1.000000, 1.000000, 1.000000, 1.000000), r0.y <br> 14: add r0.y, r0.y, -v0.z <br> 15: mul_sat r0.y, r0.y, cb4[6].x <br> 16: mul_sat r0.x, r0.y, r0.x <br> 17: mad r0.y, cb0[7].y, r0.x, -r0.x <br> 18: mad r0.x, cb4[7].x, r0.y, r0.x <br> 19: mul r0.xyz, r0.xxxx, cb4[0].xyzx <br> 20: log r0.xyz, r0.xyzx <br> 21: mul r0.xyz, r0.xyzx, l(2.200000, 2.200000, 2.200000, 0.000000) <br> 22: exp r0.xyz, r0.xyzx <br> 23: mul r0.xyz, r0.xyzx, cb2[2].xyzx <br> 24: mul o0.xyz, r0.xyzx, cb2[2].wwww <br> 25: mov o0.w, l(0) <br> 26: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/064/1a8/801/0641a88012fb6ec18797c0b143fb5f27.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatikan bahwa objek yang jauh (mercusuar, pegunungan ...) telah menghilang. </font><font style="vertical-align: inherit;">Ini terjadi karena silinder melewati uji kedalaman - silinder tidak berada di bidang jauh dan ditarik di atas benda-benda ini:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/106/8f5/ffd/1068f5ffde6b0efba2c4894b88d5ddf5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tes Kedalaman</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami ingin mensimulasikan bahwa tirai hujan lebih jauh (tetapi tidak harus di pesawat jauh). </font><font style="vertical-align: inherit;">Untuk melakukan ini, kita menghitung topeng lain, "topeng benda yang jauh." </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itu dihitung dengan rumus berikut: </font></font><br><br> <code>farObjectsMask = saturate( (FrustumDepth - CylinderWorldSpaceHeight) * 0.001 );</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(0,001 diambil dari buffer), yang memberi kita topeng yang diinginkan:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/02a/153/9ff02a1534054fb27b370d5cd58e7a75.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Pada bagian tentang efek Sharpen, saya sudah secara dangkal menjelaskan bagaimana kedalaman piramida visibilitas diekstraksi dari buffer kedalaman.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara pribadi, menurut saya efek ini dapat direalisasikan lebih murah tanpa menghitung ketinggian di ruang dunia dengan mengalikan kedalaman piramida visibilitas dengan jumlah yang lebih kecil, misalnya 0,0004. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika kedua topeng dikalikan, yang terakhir diperoleh:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c49/fb2/c1e/c49fb2c1e1dd2ee8d38d81c0cccb0daf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah menerima topeng terakhir ini (baris 16), kami melakukan interpolasi lain, yang hampir tidak menghasilkan apa-apa (setidaknya dalam kasus yang diuji), dan kemudian mengalikan topeng akhir dengan warna tirai (baris 19), melakukan koreksi gamma (baris 20). -22) dan perkalian terakhir (23-24). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada akhirnya, kami mengembalikan warna dengan nilai alpha nol. Ini karena pencampuran diaktifkan pada lintasan ini: </font></font><br><br> <code>FinalColor = SourceColor * 1.0 + (1.0 - SourceAlpha) * DestColor</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda tidak begitu memahami cara kerja pencampuran, berikut adalah penjelasan singkat: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SourceColor adalah output RGB dari pixel shader, dan DestColor adalah warna RGB saat ini dari piksel dalam target render. . Sejak SourceAlpha selalu sama untuk 0.0, persamaan di atas tereduksi menjadi: </font></font><code>FinalColor = SourceColor + DestColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sederhananya, di sini kami melakukan pencampuran aditif. </font><font style="vertical-align: inherit;">Jika pixel shader kembali (0, 0, 0), maka warnanya akan tetap sama. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut ini adalah kode HLSL yang telah selesai - Saya pikir setelah menjelaskannya akan jauh lebih mudah untuk dipahami: </font><font style="vertical-align: inherit;">Saya dapat mengatakan dengan senang hati bahwa pixel shader saya membuat kode assembler yang sama seperti pada aslinya. </font><font style="vertical-align: inherit;">Saya harap Anda menikmati artikel ini. </font><font style="vertical-align: inherit;">Terima kasih sudah membaca!</font></font><br><br> <code>struct VS_OUTPUT <br> { <br> float3 TexcoordAndWorldspaceHeight : Texcoord0; <br> float4 LODParams : LODParams; // float4(1,1,1,1) <br> float4 PositionH : SV_Position; <br> }; <br> <br> float getFrustumDepth( in float depth ) <br> { <br> // from [1-0] to [0-1] <br> float d = depth * cb12_v22.x + cb12_v22.y; <br> <br> // special coefficents <br> d = d * cb12_v21.x + cb12_v21.y; <br> <br> // return frustum depth <br> return 1.0 / max(d, 1e-4); <br> } <br> <br> float4 EditedShaderPS( in VS_OUTPUT Input ) : SV_Target0 <br> { <br> // * Input from Vertex Shader <br> float2 InputUV = Input.TexcoordAndWorldspaceHeight.xy; <br> float WorldHeight = Input.TexcoordAndWorldspaceHeight.z; <br> float LODParam = Input.LODParams.w; <br> <br> // * Inputs <br> float elapsedTime = cb0_v0.x; <br> float2 uvAnimation = cb4_v5.xy; <br> float2 uvScale = cb4_v4.xy; <br> float minValue = cb4_v2.x; // 0.0 <br> float maxValue = cb4_v3.x; // 1.0 <br> float3 shaftsColor = cb4_v0.rgb; // RGB( 147, 162, 173 ) <br> <br> float3 finalColorFilter = cb2_v2.rgb; // float3( 1.175, 1.296, 1.342 ); <br> float finalEffectIntensity = cb2_v2.w; <br> <br> float2 invViewportSize = cb0_v1.zw; <br> <br> float depthScale = cb4_v6.x; // 0.001 <br> <br> // sample noise <br> float2 uvOffsets = elapsedTime * uvAnimation; <br> float2 uv = InputUV * uvScale + uvOffsets; <br> float disturb = texture0.Sample( sampler0, uv ).x; <br> <br> // * Intensity mask <br> float intensity = saturate( lerp(minValue, maxValue, disturb) ); <br> intensity *= InputUV.y; // transition from (0, 1) <br> intensity *= LODParam; // usually 1.0 <br> intensity *= cb4_v1.x; // 1.0 <br> <br> // Sample depth <br> float2 ScreenUV = Input.PositionH.xy * invViewportSize; <br> float hardwareDepth = texture15.SampleLevel( sampler15, ScreenUV, 0 ).x; <br> float frustumDepth = getFrustumDepth( hardwareDepth ); <br> <br> <br> // * Calculate mask covering distant objects behind cylinder. <br> <br> // Seems that the input really is world-space height (.z component, see vertex shader) <br> float depth = frustumDepth - WorldHeight; <br> float distantObjectsMask = saturate( depth * depthScale ); <br> <br> // * calculate final mask <br> float finalEffectMask = saturate( intensity * distantObjectsMask ); <br> <br> // cb0_v7.y and cb4_v7.x are set to 1.0 so I didn't bother with naming them :) <br> float paramX = finalEffectMask; <br> float paramY = cb0_v7.y * finalEffectMask; <br> float effectAmount = lerp(paramX, paramY, cb4_v7.x); <br> <br> // color of shafts comes from contant buffer <br> float3 effectColor = effectAmount * shaftsColor; <br> <br> // gamma correction <br> effectColor = pow(effectColor, 2.2); <br> <br> // final multiplications <br> effectColor *= finalColorFilter; <br> effectColor *= finalEffectIntensity; <br> <br> // return with zero alpha 'cause the blending used here is: <br> // SourceColor * 1.0 + (1.0 - SrcAlpha) * DestColor <br> return float4( effectColor, 0.0 ); <br> }</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437100/">https://habr.com/ru/post/id437100/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id437088/index.html">Promosi startup di luar negeri: cara menjangkau ratusan ribu pembaca berbahasa Inggris dengan Medium</a></li>
<li><a href="../id437092/index.html">Keamanan algoritma pembelajaran mesin. Serangan Python</a></li>
<li><a href="../id437094/index.html">Kami memompa Atlassian Service Desk - pengumuman mitap dan siaran langsung</a></li>
<li><a href="../id437096/index.html">UDB. Apa ini Bagian 4. Datapath ALU</a></li>
<li><a href="../id437098/index.html">6 Februari, Moskow, DI Telegraph - Big QIWI Kitchen on Design Produk</a></li>
<li><a href="../id437102/index.html">Pertemuan Lego Champion Baru: Lego Boost</a></li>
<li><a href="../id437104/index.html">Introscope: baik, unit pengujian sangat malas</a></li>
<li><a href="../id437106/index.html">IT di zona .it</a></li>
<li><a href="../id437108/index.html">Sebagian besar teks di Internet ditulis oleh orang gila.</a></li>
<li><a href="../id437110/index.html">Nanomaterial mengubah dunia kita, dan kita masih belum memiliki prosedur untuk memeriksa keamanannya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>