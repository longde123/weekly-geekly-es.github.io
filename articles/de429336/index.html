<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚ÄçüöÄ üî° ‚öõÔ∏è Kommunikation zwischen Treiber und Ger√§t √ºber die _HID ACPI-Methode am Beispiel des GPIO des Lynxpoint-Controllers üè∫ üõ´ ‚õπüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Erkl√§rung des Problems 
 Linux verf√ºgt √ºber eine Standardschnittstelle f√ºr die Arbeit mit GPIO √ºber sysfs. Die Dokumentation dazu finden Sie hier . 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kommunikation zwischen Treiber und Ger√§t √ºber die _HID ACPI-Methode am Beispiel des GPIO des Lynxpoint-Controllers</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429336/"><h3>  Erkl√§rung des Problems </h3><br>  Linux verf√ºgt √ºber eine Standardschnittstelle f√ºr die Arbeit mit GPIO √ºber sysfs.  Die Dokumentation dazu finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Kurz gesagt, im Ordner "/ sys / class / gpio" befinden sich "Export" - und "Nicht-Export" -Dateien.  Durch Schreiben der Nummer X in die Exportdatei k√∂nnen Sie die Benutzeroberfl√§che im Benutzerbereich √∂ffnen, um GPIOX zu steuern <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#    user space   GPIO12 $ echo 12 &gt; /sys/class/gpio/export</span></span></code> </pre> <br>  Nach dem √ñffnen der Benutzeroberfl√§che wird der Ordner / sys / class / gpio / gpioX / angezeigt, in dem sich Dateien wie "Wert" oder "Richtung" befinden. Schreiben Sie "In" oder "Out" in die Datei "Richtung" und schreiben Sie 1 oder 0 in die Datei "Wert" kann die GPIO-Ausgabe direkt √ºber die Befehlszeile steuern. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  GPIO   $ echo "out" &gt; /sys/class/gpio/gpio12/direction #  1   GPIO $ echo 1 &gt; /sys/class/gpio/gpio12/value</span></span></code> </pre> <br>  Damit der Befehl "echo X&gt; / sys / class / gpio / export" den Ordner "gpioX" erstellen kann, muss der GPIO-Controller-Treiber im Kernel registriert sein, wodurch die Schnittstelle zu den GPIO-Leitungen ge√∂ffnet wird. <br><br>  Zuf√§llig arbeite ich daran, Coreboot f√ºr ein benutzerdefiniertes Board zu portieren, das auf dem Intel Haswell i7-Prozessor basiert. [F√ºr diejenigen, die es nicht wissen, ist Coreboot ein Open Source-Open-Source-BIOS-Projekt ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.coreboot.org/</a> ). ].  Die LynxpointLP-S√ºdbr√ºcke mit 94 GPIO-Leitungen ist in meinen Prozessor integriert.  Und ich wollte sie in sysfs √∂ffnen ... <br><a name="habracut"></a><br><h3>  Probleml√∂sung (Treiber- und Ger√§tekommunikation unter Linux) </h3><br>  Nach einer kurzen Suche im Kernel-Code stellte ich fest, dass der Treiber bereits geschrieben, in der Datei "drivers \ gpio \ gpio-lynxpoint.c" gespeichert und mit Kconfig aktiviert wurde <br><br><pre> <code class="hljs pgsql">config GPIO_LYNXPOINT tristate "Intel Lynxpoint GPIO support" <span class="hljs-keyword"><span class="hljs-keyword">depends</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ACPI &amp;&amp; X86 <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> GPIOLIB_IRQCHIP help driver <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GPIO functionality <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> Intel Lynxpoint PCH chipset Requires ACPI device enumeration code <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> up a platform device.</code> </pre> <br>  Die Option GPIO_LYNXPOINT wurde in dem Kernel aktiviert, mit dem ich gearbeitet habe. Es gab jedoch keinen einzigen Ordner "gpiochipN" f√ºr den GPIO-Controller im Ordner "/ sys / class / gpio /" (der sein sollte), und selbst ein solches Skript f√ºhrte nicht zum Export Linien. <br><br><pre> <code class="bash hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> {0..255}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$i</span></span> &gt; /sys/class/gpio/<span class="hljs-built_in"><span class="hljs-built_in">export</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  Wenn Sie sich den Coreboot-Code oder die Dokumentation f√ºr diese South Bridge ansehen, sehen Sie, dass der GPIO-Controller kein separates PCI-Ger√§t ist.  Es ist Teil eines anderen PCI-Ger√§ts: LPC Interface Bridge.  Mithilfe der PCI-Konfigurationsbereichsregister dieses Ger√§ts m√ºssen Sie den GPIO-Controller aktivieren und ihm BASE_ADDRESS im E / A-Bereich zuweisen.  Dadurch wird ein Fenster im 1-kV-E / A-Bereich ge√∂ffnet.  Durch Schreiben / Lesen von Bytes in diesem Fenster k√∂nnen Sie die GPIO-Leitungen steuern. <br><br>  Was wir im Coreboot-Code sehen k√∂nnen: <br><br>  Southbridge \ Intel \ Lynxpoint \ pch.h: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEFAULT_GPIOBASE 0x1400 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEFAULT_GPIOSIZE 0x400 ... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GPIO_BASE 0x48 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* LPC GPIO Base Address Register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GPIO_CNTL 0x4C </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* LPC GPIO Control Register */</span></span></span><span class="hljs-meta"> ... </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* PCI Configuration Space (D31:F0): LPC */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PCH_LPC_DEV PCI_DEV(0, 0x1f, 0)</span></span></code> </pre><br>  Southbridge \ Intel \ Lynxpoint \ Early_Pch.C: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Setup GPIO Base Address */</span></span> pci_write_config32(PCH_LPC_DEV, GPIO_BASE, DEFAULT_GPIOBASE|<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Enable GPIO functionality. */</span></span> pci_write_config8(PCH_LPC_DEV, GPIO_CNTL, <span class="hljs-number"><span class="hljs-number">0x10</span></span>);</code> </pre> <br>  Wenn wir uns die LPC-Ger√§teregister unter Linux √ºber "lspci -xxx" ansehen, werden wir sehen, dass sich die von uns aufgezeichneten Daten in diesen Registern befinden.  Also scheint alles so konfiguriert zu sein, wie es sollte. <br><br>  Als ich den Treibercode weiter betrachtete, bemerkte ich, dass der Linux-Treiber √ºber das Feld .acpi_match_table mit dem Ger√§t kommuniziert.  Da unser Ger√§t nicht aufgelistet werden kann (es befindet sich weder auf der PCI noch auf dem USB-Bus), ist daf√ºr ein Plattformtreiber erforderlich, und die Verbindung dieses Treibers mit dem Ger√§t erfolgt √ºber ACPI-Tabellen.  Im √ºblichen Fall f√ºr x86, im Fall von ARM, w√ºrden wir unser Ger√§t in DeviceTree registrieren oder die alten Hardcodes im Kernel verwenden. <br><br>  Treiber \ gpio \ gpio-lynxpoint.c: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">acpi_device_id</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lynxpoint_gpio_acpi_match</span></span></span><span class="hljs-class">[] = {</span></span> { <span class="hljs-string"><span class="hljs-string">"INT33C7"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"INT3437"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { } }; MODULE_DEVICE_TABLE(acpi, lynxpoint_gpio_acpi_match); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">platform_driver</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lp_gpio_driver</span></span></span><span class="hljs-class"> = {</span></span> .probe = lp_gpio_probe, .remove = lp_gpio_remove, .driver = { .name = <span class="hljs-string"><span class="hljs-string">"lp_gpio"</span></span>, .pm = &amp;lp_gpio_pm_ops, .acpi_match_table = ACPI_PTR(lynxpoint_gpio_acpi_match), }, };</code> </pre><br>  Dies funktioniert folgenderma√üen: Wenn der Kernel beim Parsen der ACPI-Tabelle ein Ger√§t mit der _HID-Kennung ‚ÄûINT33C7‚Äú sieht, versucht er, den Plattformtreiber daf√ºr mit √ºbereinstimmenden Bezeichnern in den Feldern der Struktur ‚Äû.driver-&gt; acpi_match_table‚Äú zu finden. <br><br>  Wenn eine √úbereinstimmung gefunden wird, f√ºhrt Linux die .probe-Treiberfunktion aus. <br><br>  Wie sich herausstellte, wurde der ACPI-Code f√ºr dieses Ger√§t in coreboot dargestellt, ich habe ihn nur auskommentiert.  Auskommentiert aufgrund der Tatsache, dass Windows f√ºr dieses Ger√§t den Treiber nicht finden konnte und im Ger√§te-Manager "Unbekanntes Ger√§t" angezeigt wurde.  Mehr dazu weiter unten. <br><br>  Wir sind also an den Informationen aus der Datei interessiert <br>  src \ southbridge \ intel \ lynxpoint \ acpi \ serialio.asl (der Code ist etwas vereinfacht): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*     * src\southbridge\intel\lynxpoint\pch.h * #define DEFAULT_GPIOBASE 0x1400 * #define DEFAULT_GPIOSIZE 0x400 */</span></span> Scope (\_SB) { Device (PCI0) { ... Device (GPIO) { <span class="hljs-comment"><span class="hljs-comment">// GPIO Controller Name (_HID, "INT33C7") Name (_CID, "INT33C7") Name (_UID, 1) Name (RBUF, ResourceTemplate() { DWordIo (ResourceProducer, MinFixed, // IsMinFixed MaxFixed, // IsMaxFixed PosDecode, // Decode EntireRange, // ISARanges 0x00000000, // AddressGranularity 0x00000000, // AddressMinimum 0x00000000, // AddressMaximum 0x00000000, // AddressTranslation 0x00000001, // RangeLength , // ResourceSourceIndex , // ResourceSource BAR0) Interrupt (ResourceConsumer, Level, ActiveHigh, Shared, , , ) {14} }) Method (_CRS, 0, NotSerialized) { CreateDwordField (^RBUF, ^BAR0._MIN, BMIN) CreateDwordField (^RBUF, ^BAR0._MAX, BMAX) CreateDwordField (^RBUF, ^BAR0._LEN, BLEN) Store (DEFAULT_GPIOSIZE, BLEN) Store (DEFAULT_GPIOBASE, BMIN) Store (Subtract (Add (DEFAULT_GPIOBASE, DEFAULT_GPIOSIZE), 1), BMAX) Return (RBUF) } Method (_STA, 0, NotSerialized) { Return (0xF) } } ... } }</span></span></code> </pre><br>  Um diesen Code im Detail zu verstehen, sollten Sie sich mit der ASL-Syntax in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der ACPI-Spezifikation</a> vertraut machen. <br><br>  Kurz gesagt, dieser Code erstellt ein Ger√§t mit der Kennung "INT33C7", das √ºber zwei Ressourcen verf√ºgt: <br><br><pre> <code class="hljs mel">I/O <span class="hljs-keyword"><span class="hljs-keyword">memory</span></span>: <span class="hljs-number"><span class="hljs-number">1400</span></span><span class="hljs-number"><span class="hljs-number">-17</span></span>ff; IRQ: <span class="hljs-number"><span class="hljs-number">14</span></span>;</code> </pre> <br>  Innerhalb seiner .probe Linux-Funktion erh√§lt der Treiber die oben genannten Ger√§teressourcen wie folgt: <br><br><pre> <code class="cpp hljs">io_rc = platform_get_resource(pdev, IORESOURCE_IO, <span class="hljs-number"><span class="hljs-number">0</span></span>); irq_rc = platform_get_resource(pdev, IORESOURCE_IRQ, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  Basierend auf diesen Daten f√ºllt der Treibercode die Struktur gpio_chip aus und registriert den gpio-Controller im System, wodurch er √ºber die sysfs-Schnittstelle zug√§nglich wird. <br><br>  Nachdem der ASL-Code des Ger√§ts zur√ºckgegeben und das BIOS-Image neu kompiliert wurde, gelang es dem System, √ºber sysfs auf das GPIO zuzugreifen. <br><br>  Zu Beginn wurde der Ordner "gpiochip162" in / sys / class / gpio angezeigt.  Dieser Ordner enth√§lt die Dateien "base" und "ngpio".  Die Basisdatei ist f√ºr die Nummer des ersten GPIO dieses Controllers verantwortlich, ngpio f√ºr deren Nummer. <br><br><pre> <code class="bash hljs">$ cat /sys/class/gpio/gpiochip162/base 162 $ cat /sys/class/gpio/gpiochip162/ngpio 94</code> </pre> <br>  Somit wurde alles so exportiert, wie es sollte.  Wir f√ºhren das Skript aus: <br><br><pre> <code class="bash hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> {162..255}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$i</span></span> &gt; /sys/class/gpio/<span class="hljs-built_in"><span class="hljs-built_in">export</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  Danach werden die gpioN-Unterordner im Ordner / sys / class / gpio / angezeigt, in dem sich Dateien befinden, mit denen der Status der Zeile gesteuert werden kann. <br><br>  Ein paar Kommentare: <br><br><ul><li>  Der Ordner / sys / class / gpio162 / ist f√ºr die Verwaltung von GPIO0 verantwortlich, der Ordner / sys / class / gpio163 / ist f√ºr GPIO1 verantwortlich  Diese Verschiebung erfolgte aufgrund der Tatsache, dass der Treiber w√§hrend der Initialisierung der Kontrollstruktur "struct gpio_chip" "gc-&gt; base = -1;" zugewiesen hat.  Das hei√üt, ich habe den Kernel verlassen, um die Zahlen selbst auszuw√§hlen.  Dies ist im Allgemeinen nicht kritisch, aber es lohnt sich, sich daran zu erinnern. </li><li>  Der Zugriff wird nur auf GPIO-Leitungen gew√§hrt, die als GPIO konfiguriert sind, und nicht auf native Southbridge-Funktionen.  F√ºr solche Zeilen zeigt der Treiber Informationen in dmesg an: "gpio% d reserviert f√ºr ACPI".  Bei Coreboot wird das GPIO in der Datei ‚Äûgpio.h‚Äú im Ordner mit dem Motherboard konfiguriert. </li><li>  Das Ger√§t und der Treiber k√∂nnen auch mithilfe der _CID-Methode (Compatible ID) zugeordnet werden. Die Dokumentation zu unserem Thema im Kernel finden Sie im Dokument <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûACPI-basierte Ger√§teaufz√§hlung‚Äú.</a> </li></ul><br>  Es ist anzumerken, dass das INT33C7-Ger√§t nicht √ºber zwei propriet√§re Motherboards auf demselben Chipsatz in den ACPI-Tabellen verf√ºgt (von IBASE und DFI).  Es stimmt, es werden h√∂chstwahrscheinlich keine GPIO-Leitungen ausgegeben (ich habe mir die Dokumentation zu diesem Zeitpunkt nicht im Detail angesehen). <br><br><h3>  Kennung "INT33C7" </h3><br>  Nachdem ich die sysfs-Funktionalit√§t erh√∂ht hatte, hatte ich eine Frage, woher die Identifikationsnummer ‚ÄûINT33C7‚Äú stammt. <br><br>  Nach Durchsicht der Dokumentation zur _HID-Methode wurde klar, dass es sich lohnt, einen Blick auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://www.uefi.org/PNP_ACPI_Registry zu</a> werfen <br><br><div class="spoiler">  <b class="spoiler_title">_HID (Hardware ID)</b> <div class="spoiler_text">  <b>_HID (Hardware ID)</b> <br>  Dieses Objekt wird verwendet, um OSPM mit der PNP-ID oder ACPI-ID * des Ger√§ts zu versorgen. <br>  Bei der Beschreibung einer Plattform ist die Verwendung von _HID-Objekten optional.  Ein _HID-Objekt muss jedoch sein <br>  wird verwendet, um alle Ger√§te zu beschreiben, die von OSPM aufgelistet werden.  OSPM z√§hlt nur ein Ger√§t auf <br>  wenn kein Bus-Enumerator die Ger√§te-ID erkennen kann.  Beispielsweise sind Ger√§te an einem ISA-Bus <br>  von OSPM aufgez√§hlt.  Verwenden Sie das _ADR-Objekt, um Ger√§te zu beschreiben, die von Bus-Enumeratoren aufgelistet werden <br>  au√üer OSPM. <br><br>  <b>Argumente:</b> <br>  Keine <br><br>  <b>R√ºckgabewert:</b> <br>  Eine Ganzzahl oder Zeichenfolge, die die HID enth√§lt <br>  Ein _HID-Objekt wird entweder als numerische 32-Bit-komprimierte EISA-Typ-ID oder als Zeichenfolge ausgewertet.  Wenn a <br>  Zeichenfolge, das Format muss eine alphanumerische PNP- oder ACPI-ID ohne Sternchen oder andere f√ºhrende Zeichen sein <br>  Zeichen. <br><br>  Eine g√ºltige PNP-ID muss die Form "AAA ####" haben, wobei A ein Gro√übuchstabe und # ein Hex ist <br>  Ziffer.  Eine g√ºltige ACPI-ID muss die Form "NNNN ####" haben, wobei N ein Gro√übuchstabe oder a ist <br>  Ziffer ('0' - '9') und # ist eine hexadezimale Ziffer.  Diese Spezifikation reserviert die Zeichenfolge "ACPI" nur zur Verwendung <br>  mit Ger√§ten definierte Liste.  Es reserviert ferner alle Zeichenfolgen, die 4 HEX-Ziffern f√ºr darstellen <br>  Ausschlie√üliche Verwendung mit PCI-zugewiesenen Hersteller-IDs. <br><br>  * -PNP ID und ACPI ID Registry finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://www.uefi.org/PNP_ACPI_Registry</a> <br></div></div><br>  Es gibt 3 Punkte auf diesem Link: <br><br><ul><li>  Hier sind alle Arten von 3-Buchstaben-Kennungen (PNP-ID) angegeben </li><li>  Hier werden PNP-IDs angezeigt, die mit "PNP" beginnen, das von Microsoft reserviert wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.</a> <br></li><li>  Hier werden alle Arten von 4-Buchstaben-Kennungen (ACPI-ID) angegeben </li></ul><br>  Es ist nicht ganz klar, warum, aber aus der PNP-ID-Liste k√∂nnen Sie entnehmen, dass die "INT" -Kennungen bei INTERPHASE CORPORATION reserviert sind: <br><br><pre> <code class="hljs pgsql">INTERPHASE CORPORATION <span class="hljs-type"><span class="hljs-type">INT</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>/<span class="hljs-number"><span class="hljs-number">29</span></span>/<span class="hljs-number"><span class="hljs-number">1996</span></span></code> </pre> <br>  Anscheinend wird keine einzige Liste vollst√§ndiger Ger√§tekennungen (Buchstabenteil + digital) ver√∂ffentlicht.  Mit Hilfe von Google konnten beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> oder <a href="">hier</a> Listen von Ger√§ten und deren _HID <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gefunden</a> <a href="">werden</a> . <br><br>  Sie zeigen an: <br><br><pre> <code class="hljs pgsql">INT33C7=Intel <span class="hljs-type"><span class="hljs-type">Serial</span></span> I/O GPIO Host Controller</code> </pre> <br>  Und nach dem Rest der Zeilen aus dieser Liste sind alle INTxxxx-Ger√§te Intel-Ger√§te (jetzt klingt es ziemlich offensichtlich, aber die Verbindung mit INTERPHASE CORPORATION ist immer noch nicht klar, es ist auch nicht sehr klar, warum die Nummerierung mit so gro√üen Zahlen beginnt, aber sie ist sichtbar auf Intel Diskretion). <br><br><h3>  Kommunikationstreiber und Ger√§t in Windows </h3><br>  Nachdem ich meine Neugier befriedigt hatte, beschloss ich, Windows auf mein Board herunterzuladen.  Wie erwartet konnte das System keinen Treiber f√ºr das Ger√§t finden.  Es gab keine Hilfe von den Treibern f√ºr die IBASE- und DFI-Karten, was verst√§ndlich ist, da dieses Ger√§t im BIOS dieser Karten nicht angegeben ist. <br><br>  Ich habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf der Microsoft-Website</a> einen Treiber gefunden <br><br>  Dort wird dieser Treiber jedoch nur f√ºr Windows 8.1 und h√∂her angezeigt.  Ich arbeite immer noch mit Windows 7. <br><br>  Trotzdem habe ich versucht, einen der Treiber herunterzuladen und seinen Ordner anzugeben, wenn ich nach einem Treiber f√ºr mein unbekanntes Ger√§t gesucht habe. <br><br>  Der Dispatcher konnte den Treiber jedoch nicht dem Ger√§t zuordnen.  Obwohl die Inf-Datei eindeutig Informationen √ºber das INT33C7-Ger√§t enthielt. <br><br><pre> <code class="hljs mel">[Manufacturer] %INTEL%=Intel,NTamd64<span class="hljs-number"><span class="hljs-number">.6</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span> [Intel.NTamd64<span class="hljs-number"><span class="hljs-number">.6</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span>] %iaLPSS_GPIO.DeviceDesc_LPT%=iaLPSS_GPIO_Device, ACPI\INT33C7 %iaLPSS_GPIO.DeviceDesc_WPT%=iaLPSS_GPIO_Device, ACPI\INT3437</code> </pre> <br>  Beim Parsen der INF-Datei stellte sich heraus, dass im Abschnitt [Hersteller] eindeutig angegeben wurde, dass sie nicht f√ºr mein System bestimmt ist: <br><br>  Was Intel.NTamd64.6.3 bedeutet, kann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Beschreibung</a> entnommen werden: <br><br><pre> <code class="hljs powershell">nt[<span class="hljs-type"><span class="hljs-type">Architecture</span></span>][<span class="hljs-type"><span class="hljs-type">.</span></span>[<span class="hljs-type"><span class="hljs-type">OSMajorVersion</span></span>][<span class="hljs-type"><span class="hljs-type">.</span></span>[<span class="hljs-type"><span class="hljs-type">OSMinorVersion</span></span>] <span class="hljs-type"><span class="hljs-type">OSMajorVersion</span></span>=<span class="hljs-number"><span class="hljs-number">6</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Windows</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>/<span class="hljs-type"><span class="hljs-type">Windows</span></span> <span class="hljs-number"><span class="hljs-number">8.1</span></span>/<span class="hljs-type"><span class="hljs-type">Windows</span></span> <span class="hljs-type"><span class="hljs-type">Server</span></span> <span class="hljs-number"><span class="hljs-number">2012</span></span> <span class="hljs-type"><span class="hljs-type">R2</span></span>/<span class="hljs-type"><span class="hljs-type">...</span></span> <span class="hljs-type"><span class="hljs-type">OSMinorVersion</span></span>=<span class="hljs-number"><span class="hljs-number">3</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Windows</span></span> <span class="hljs-number"><span class="hljs-number">8.1</span></span>/<span class="hljs-type"><span class="hljs-type">Windows</span></span> <span class="hljs-type"><span class="hljs-type">Server</span></span> <span class="hljs-number"><span class="hljs-number">2012</span></span> <span class="hljs-type"><span class="hljs-type">R2</span></span></code> </pre> <br>  Der Versuch, den Windows 7-Treiber durch Ersetzen von Intel.NTamd64.6.3 durch Intel.NTamd64.6.1 zu pushen, schlug, gelinde gesagt, fehl, da ich einen Bluescreen des Todes und ein nicht bootf√§higes Betriebssystem hatte und daher eine Wiederherstellung durchf√ºhren musste. <br><br>  Der Treiber f√ºr Win7 wurde nur auf einer unverst√§ndlichen Website im Internet gefunden, und danach wird das Ger√§t im Ger√§te-Manager mit einem Ausrufezeichen angezeigt. <br><br>  Als ich seine Ohnmacht erkannte, beschloss ich, die Funktionalit√§t unter Windows 10 zu testen. Es gab eine angenehme √úberraschung.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Intel Chipset Device Software (INF Update Utility) hat</a> den Treiber f√ºr meinen Controller problemlos installiert. <br><br><img src="https://habrastorage.org/webt/xb/28/jq/xb28jqet9w3tieq0atau1f2aoum.png"><br><br>  Wie Sie sehen k√∂nnen, verf√ºgt dieses Ger√§t √ºber die von uns angegebenen Ressourcen. <br><br><img src="https://habrastorage.org/webt/2o/fs/p0/2ofsp055fsxm4smnghgxc3eye8u.png"><br><br>  Theoretisch ist es nach der Installation des Treibers mit dem GPIO-Controller h√∂chstwahrscheinlich m√∂glich, IOCTL-Funktionen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie in diesem Dokument) zu verwenden</a> . <br><br>  Da es jedoch keine GPIO-Programmieraufgabe von Windows gab, wurde die Suche nach einem √§hnlichen Dokument f√ºr meinen Chipsatz verschoben. <br><br><hr><br><h3>  Fazit: </h3><br>  In diesem Artikel wurde die Verbindung zwischen dem Treiber und dem Ger√§t mithilfe der _HID ACPI-Methode untersucht.  Eine solche Kommunikation kann auf einem x86-System f√ºr Ger√§te erforderlich sein, die nicht aufgelistet werden k√∂nnen. <br><br><ul><li>  Unter Linux erfolgt die Kommunikation mit dem Treiber √ºber .acpi_match_table </li><li>  Bei Windows erfolgt die Kommunikation mit dem Treiber √ºber eine INF-Datei </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de429336/">https://habr.com/ru/post/de429336/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de429324/index.html">Unreal Engine 4.21 Release</a></li>
<li><a href="../de429326/index.html">App Store ruft nicht an. Oder wie ich meine Bewerbung gemacht habe, aber sie wird die Benutzer nicht erreichen</a></li>
<li><a href="../de429328/index.html">Softwaremodul zur Digitalisierung besch√§digter Dokumente</a></li>
<li><a href="../de429330/index.html">Mythen und Legenden von Agile - von den Pharaonen bis heute</a></li>
<li><a href="../de429332/index.html">Selbstgemachtes Laserlichtschwert - wie es war, Teil 1</a></li>
<li><a href="../de429338/index.html">Android-Speicher: intern, extern, entfernbar. Teil 1/3</a></li>
<li><a href="../de429340/index.html">√úberlegen Sie zweimal, bevor Sie Helm verwenden.</a></li>
<li><a href="../de429342/index.html">Angular 6+ ist eine vollst√§ndige Anleitung zur Abh√§ngigkeitsinjektion. zur Verf√ºgung gestellt gegen Anbieter: []</a></li>
<li><a href="../de429344/index.html">Wochenendlesung: Ressourcen f√ºr Audio-Tuning und Lautsprecherdesign</a></li>
<li><a href="../de429346/index.html">Zum Masterstudiengang ohne Pr√ºfungen: eine neue Richtung "Big Data" bei den Olympischen Spielen "Ich bin ein Profi"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>