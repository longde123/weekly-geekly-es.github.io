<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤘🏾 💣 👝 PHP 8中最有趣的事情 👳 👸 🕯️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PHP 7.4刚刚被宣布是稳定的，我们已经提交了更多的改进。 最重要的是，PHP等待着什么可以告诉Dmitry Stogov-开放源码PHP的领先开发者之一，并且可能是最老的活跃贡献者。 

 德米特里（Dmitry）的所有报告仅涉及他亲自研究的那些技术和解决方案。 在Ontiko的最佳传统中，从P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PHP 8中最有趣的事情</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/481092/">  PHP 7.4刚刚被宣布是稳定的，我们已经提交了更多的改进。 最重要的是，PHP等待着什么可以告诉Dmitry Stogov-开放源码PHP的领先开发者之一，并且可能是最老的活跃贡献者。 <br><br> 德米特里（Dmitry）的所有报告仅涉及他亲自研究的那些技术和解决方案。 在Ontiko的最佳传统中，从PHP 8的Dmitry创新角度出发，最有趣的<a href="https://youtu.be/7UOWus-5yxg">故事</a>是文本版本，可以打开新的用例。 首先，准时制和外国直接投资-并非处于“令人惊叹的前景”的关键，而是具有实施细节和陷阱。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h9/o1/xd/h9o1xdb-wntc2xl0eipeb4bd7du.png" width="500"></div><br>  <i>供参考：</i> Dmitry Stogov于1984年熟悉编程，那时并非所有读者都出生了，并设法为开发工具（尤其是PHP）的开发做出了重大贡献（尽管Dmitry改进了PHP性能，但并不专门针对俄罗斯开发人员，他们<a href="https://habr.com/ru/company/oleg-bunin/blog/477426/">表示</a>我以HighLoad ++ Award的形式表示感谢）。  Dmitry是Turck MMCache for PHP（eAccelerator）的作者，Zend OPcache维护者，PHPNG项目的负责人，该项目构成了PHP 7的基础，并且是PHP JIT开发的负责人。 <br><a name="habracut"></a><br><h2>  PHP性能开发 </h2><br>  15年前，我加入Zend时就开始从事PHP性能方面的工作。 然后，我们发布了版本5.0，这是该语言真正成为面向对象的第一个版本。 从那时起，我们已经能够将综合测试的生产率提高40倍，将实际应用的生产率提高6倍。 <br><br><img src="https://habrastorage.org/webt/xp/gc/xe/xpgcxedjqqy7_ay7vzrocx2cl3y.jpeg"><br><br> 在这段时间里，有两个突破时刻： <br><br><ul><li>  5.1版，在其中可以显着提高解释速度。 我们实施了专业的口译员，这主要影响了综合测试。 </li><li>版本7.0，其中处理了所有关键数据结构，从而优化了内存和处理器缓存的工作（ <a href="https://habr.com/ru/company/oleg-bunin/blog/444508/">在此处</a>了解有关这些优化的更多信息）。 在合成测试和实际应用中，这导致了两倍以上的加速。 </li></ul><br> 所有其他版本均通过实施许多效果较差的想法逐渐提高了生产率。 例如，在7.1版中，人们非常关注优化字节码（有关这些解决方案<a href="https://habr.com/ru/company/oleg-bunin/blog/445512/">的文章</a> ）。 <br><br> 该图显示，在第5版的开发结束时和第7版的开发周期结束时，我们都进入了平稳状态并放慢了速度。 因此，在去年的v7.4工作中，生产率仅提高了2％。 这还不错，因为出现了诸如类型化属性和协变量类型之类的新功能，这些功能减慢了PHP的速度（Nikita Popov在PHP Russia中<a href="https://youtu.be/teKnckg5x7I">谈到</a>了这些新产品）。 <br><br> 现在，每个人都想知道第八版会带来什么，它能否延续v7的成功？ <br><br><h3> 准时或不准时 </h3><br> 改进口译员的想法尚未穷尽，但是所有这些都需要进行大量的研究。 其中的许多必须在概念证明阶段被拒绝，因为所获得的收益证明与复杂性或施加的技术限制无法相比。 <br><br> 但是，仍然有希望获得新的突破性技术-当然，我还记得JIT和JavaScript引擎的成功故事。 <br><br> 实际上，自2012年以来就一直在进行PHP的JIT研究。 我们曾与Intel同事，JavaScript黑客合作过3或4种实现方式，但是以某种方式无法将JIT包含在主分支中。 最后，在PHP 8中，我们将JIT包含在编译器中，并且看到了双重加速，但仅在综合测试上，而在实际应用程序上却出现了放慢速度。 <br><br><img src="https://habrastorage.org/webt/no/ly/58/noly58x1blcmkwv80nd8n60yu3q.jpeg"><br><br> 当然，这不是我们要争取的。 <br><br> 怎么了 也许我们做错了事，也许WordPress太糟糕了，没有JIT可以帮助他（是的，实际上是这样）。 也许我们已经使解释器太好了，但是在JavaScript中，情况更糟。 在计算测试中，这是事实： <strong>PHP解释器是最好的之一</strong> 。 <br><br><img src="https://habrastorage.org/webt/fi/ya/lc/fiyalccpg18n2aieqgj7bmy-nho.jpeg"><br><br> 在Mandelbrot测试中，他甚至超越了以汇编语言编写的解释器LuaJIT之类的宝石。 在此测试中，我们仅比优化的GCC-5.3编译器落后4倍。 使用JIT，我们可以在Mandelbrot测试中获得更好的结果。 实际上，我们已经做到了，也就是说，我们能够生成与C编译器竞争的代码。 <br><br> 那为什么我们不能加速实际应用呢？ 为了理解，我将告诉您我们如何进行准时生产。 让我们从基础开始。 <br><br><h3>  PHP如何工作 </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/r3/u7/zz/r3u7zzdgmpo37fihs44l6jl29wq.jpeg" width="300"></div><br> 服务器接受该请求，将其编译为字节码，然后将其发送到虚拟机以执行。 通过执行字节码，虚拟机还可以调用其他PHP文件，这些文件再次重新编译为字节码并再次执行。 <br><br> 查询完成后，将从内存中删除与其相关的所有信息，包括字节码。 也就是说，每个PHP脚本都必须针对每个请求再次进行编译。 当然，将JIT编译嵌入这样的方案根本是不可能的，因为编译器必须非常快。 <br><br> 但是很可能没有人使用裸露的PHP，每个人都将其与OPcache一起使用。 <br><br><h3>  PHP + OPcache </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w4/cg/wr/w4cgwrta9e7mdka4mzsylnfzbqa.jpeg" width="484"></div><br>  OPcache的主要目标是摆脱对每个请求的重新编译脚本。 它被嵌入专门为此设计的点中，拦截所有编译请求并将编译后的字节码缓存在共享内存中。 <br><br> 同时，不仅节省了编译时间，还节省了内存，因为较早的字节码内存分配在每个进程的地址空间中，现在它存在于单个副本中。 <br><br> 您已经可以在此电路中嵌入JIT，我们将这样做。 但首先，我将向您展示口译员的工作方式。 <br><br><img src="https://habrastorage.org/webt/jt/d5/50/jtd550mfh4al9klurcdde6yfzce.jpeg"><br><br> 解释器首先是为每个指令调用其自己的处理程序的循环。 <br><br> 我们使用两个寄存器： <br><br><ul><li>  execute_data-指向当前激活帧的指针； </li><li>  opline-指向当前可执行虚拟指令的指针。 </li></ul><br> 使用gcc扩展，这两种类型的寄存器映射到实际的硬件寄存器，因此它们可以非常快速地工作。 <br><br> 在循环中，我们只需为每个指令调用处理程序，然后在每个处理程序的结尾将指针移至下一条指令。 <br><br> 重要的是要注意，处理程序的地址直接写入字节码。 一条指令可以有多个不同的处理程序。 最初是为了专门化而发明的，以便处理程序可以专门研究操作数类型。  JIT使用相同的技术，因为如果您将地址作为处理程序写入新生成的代码中，则将启动JIT处理程序，而无需对解释程序进行任何更改。 <br><br> 在上面的示例中，为加法指令编写的处理程序显示在右侧。 它接受操作数（这里的第一个和第二个可以是常量，临时或局部变量），读取操作数，检查类型，产生直接逻辑-加法-然后返回到循环，将控制权转移到下一个处理程序。 <br><br> 从此描述中生成了专用功能。 由于存在三个可能的第一个操作数，三个可能的第二个操作数，我们得到9个不同的函数。 <br><br><img src="https://habrastorage.org/webt/sx/ac/ud/sxacudlzwpaetj0jdqlj-n-udqm.jpeg"><br><br> 在这些函数中，代替用于获取操作数的通用方法，而是使用不进行任何检查的特定方法。 <br><br><h3> 混合虚拟机 </h3><br> 我们在7.2版中所做的另一个复杂功能是所谓的混合虚拟机。 <br><br> 如果以前我们总是在解释器循环中直接使用间接调用来调用处理程序，那么现在对于每个处理程序，我们都在循环体中另外输入了一个标签，我们可以使用间接跳转跳转到该标签，并直接调用处理程序本身。 <br><br><img src="https://habrastorage.org/webt/ym/ve/1r/ymve1rgaxks_48lgcgt_m2zf3xm.jpeg"><br><br> 似乎他们早先进行了一次间接调用，现在进行了两次：间接转换和直接调用，这样的系统应该运行得更慢。 但是实际上它运行得更快，因为我们可以帮助处理器预测过渡。 以前，只有一个地方可以过渡到其他地方。 处理器经常被误认为是因为它根本不记得有必要先跳转到一条指令，然后再跳转到另一条指令。 现在，在每次直接调用之后，都将间接转换到下一个标签。 结果，当执行PHP循环时，虚拟PHP指令以稳定的顺序排列，然后几乎以线性方式执行。 <br><br> 混合虚拟机又使生产率提高了5-10％。 <br><br><h3>  PHP + OPcache + JIT </h3><br>  JIT作为OPcache的一部分实现。 <br><br><img src="https://habrastorage.org/webt/ye/ad/ad/yeadadf8b-tvejykkpdgpf3pacq.jpeg"><br><br> 编译并优化字节码后，将为其启动JIT编译器，该JIT编译器不再与源代码一起使用。  JIT编译器从PHP字节码生成本机代码，然后在字节码中更改第一条指令（实际上是函数）的地址。 <br><br> 之后，无需任何更改就可以从现有解释器中调用已经生成的本机代码。 我将向您展示一个简单的示例。 <br><br><img src="https://habrastorage.org/webt/y8/zs/jz/y8zsjz7rzbiuvct-l146whbcotw.jpeg"><br><br> 左侧是用PHP编写的某个函数，该函数对从0到100的数字之和进行计数。在右侧，是生成的字节码。 第一条指令为总和分配0，第二条指令对i分配相同，然后无条件跳转到标签。 在标签L1上，检查退出循环的条件：如果满足，则退出，如果不满足，则进入循环。 接下来，将i加到总和中，将结果写成数量，然后将i加1。 <br><br> 直接从这里生成汇编代码，结果非常好。 <br><br><img src="https://habrastorage.org/webt/_g/q2/8b/_gq28bxpchqg3bc5duu7tysvpsq.jpeg"><br><br> 第一条<code>QM_ASSIGN</code>指令<code>QM_ASSIGN</code>编译为两条机器指令（2-3行）。  <code>%esi</code>寄存器包含一个指向当前激活帧的指针。 在偏移量30处存在可变量。 第一条指令写入值0，第二条指令写入值4-这是整数类型（ <code>IS_LONG</code> ）的标识符。 对于变量<code>i</code>编译器意识到它总是很长，因此不需要存储类型。 此外，它可以存储在机器寄存器中。 因此，这里简单地将寄存器与自身进行XOR是最简单，最便宜的复位指令。 <br><br> 然后，以相同的方式进行无条件转换，我们检查是否发生了某些外部事件，检查周期的条件，然后进入周期。 在循环中，检查总和是否为整数：如果是，则读取整数值，将值i加上它，检查是否有溢出，将结果写回总和并将1加到<code>%edx</code> 。 <br><br> 可以看出，该代码已接近最优。 甚至可以优化它，而不必在循环的每次迭代中检查类型的总和。 但这已经是相当复杂的优化，我们还没有这样做。  <strong>我们正在将JIT开发为一种相当简单的技术</strong> ，我们并未尝试执行Java HotSpot正在尝试做的V8，我们的功能更少。 <br><br><h2>  jit怎么了 </h2><br> 为什么使用如此好的汇编代码，我们不能加速实际的应用程序？ <br><br> 其实应该吗？ <br><br><ul><li> 如果瓶颈不在CPU中，那么JIT将无济于事。 </li><li> 生成太多代码（代码膨胀）。 </li><li> 静态类型推断并非始终有效。 </li><li> 诚实的代码（用于从未执行过的情况）。 </li><li> 支持虚拟机的一致状态（突然出现异常）。 </li><li> 上课仅适用于一个请求。 </li></ul><br> 如果应用程序在80％的时间内等待数据库的响应，则JIT将无济于事。 如果我们调用外部资源密集型函数（例如，与正则表达式匹配），那么JIT也将以相同的方式调用相同的函数。 此外，如果应用程序先构建大型数据结构-树，图，然后再读取它们，那么在JIT的帮助下，我们生成的代码将读取较少的指令，但要加载数据本身，则需要花费全部时间。您还需要加载代码。 <br><br> 正如您已经看到的那样，JIT甚至可以减慢实际应用程序的速度，因为它会生成大量代码，并且读取它会成为问题-当读取大量代码时，其他数据被迫移出缓存，从而导致速度降低。 <br><br><h2>  PHP 8的适度计划 </h2><br> 我们要在PHP 8中实现的改进之一是<strong>生成更少的代码</strong> 。 现在，正如我所说，我们为整个脚本生成本机代码，并在加载阶段加载。 但是肯定不会调用其中一半功能。 因此，我们进行了进一步介绍，并引入了一个触发器，该触发器使我们可以配置何时运行JIT。 可以运行： <br><br><ul><li> 用于所有功能； </li><li> 仅适用于首次调用的函数； </li><li> 您可以在每个函数上挂一个计数器，并仅编译真正热的那些函数。 </li></ul><br> 这样的方案可能会更好一些，但仍然不是最佳方案，因为在每个函数中同样存在被执行的路径和从未执行过的路径。 由于PHP是一种动态编程语言，也就是说，每个变量可以具有不同的类型，因此您需要支持静态分析器预测的所有类型。 当他无法证明其他类型的人不能做到这一点时，他经常会谨慎地做。 <br><br>  <strong>在这种情况下，我们将摆脱诚实的编译，开始进行推测性的编译。</strong> <br><br><img src="https://habrastorage.org/webt/cf/fu/2z/cffu2zfla_l00cqpouzm-ldteoi.jpeg"><br><br> 将来，我们计划首先在应用程序工作期间分析“最热”的函数，查看程序的路径，变量的类型，甚至还记得边界条件，然后才生成针对当前最优的函数代码执行方式-仅适用于那些实际执行的部分。 <br><br> 对于其他所有内容，我们将放置存根。 一样，将存在检查和可能的输出，从该处开始去优化过程，也就是说，我们将还原解释所需的虚拟机状态，并将其交给解释器执行。 <br><br>  HotSpot Java VM和V8中都使用了类似的方案。 但是使技术适应PHP存在许多困难。 首先，这是我们共享了来自不同进程的字节码和本地代码。 我们不能直接在共享内存中更改它们，我们必须首先复制某个地方，进行更改，然后再提交回共享内存。 <br><br><h2> 预加载。 类绑定问题 </h2><br> 实际上，PHP 7甚至PHP 5中长期包含的许多PHP增强思想都来自JIT相关工作。 今天，我将讨论另一个这样的技术-这是预加载。 该技术已包含在PHP 7.4中，它使得可以指定一组文件，在服务器启动时加载它们，并使这些文件的所有功能永久化。 <br><br> 预加载技术解决的问题之一是类绑定问题。 事实是，当我们仅用PHP编译文件时，每个文件都是独立编译的。 这样做是因为它们每个都可以分别更改。 您不能将一个脚本中的类与另一个脚本中的类相关联，因为在下一个请求下，它们之一可能会更改，并且会出问题。 此外，在几个文件中可能有一个同名的类，在一个请求中，其中一个被用作父类，而在另一个请求中，则使用另一个文件中的另一个类（具有相同的名称，但名称完全不同）。 事实证明，当生成将在多个请求上执行的代码时，您不能引用类或方法，因为它们每次都会重新创建（代码生存期超过类生存期）。 <br><br> 预加载使您可以初始绑定类，并因此更优化地生成代码。 至少，对于将使用预加载来加载的框架。 <br><br> 该技术不仅有助于类绑定。 在Java中，类数据共享也实现了类似的功能。 在那里，这项技术的主要目的是加速应用程序的启动并减少消耗的内存总量。 在PHP中获得了相同的优点，因为现在类绑定不是在运行时完成的，而是只完成一次。 另外，相关的类现在不存储在每个进程的地址空间中，而是存储在共享内存中，因此总的内存消耗下降了。 <br><br> 使用预加载还有助于对所有PHP脚本进行全局优化，完全消除了OPcache的开销，并允许您生成更有效的JIT代码。 <br><br> 但是也有缺点。  <strong>如果不重新启动PHP，则无法替换在启动时加载的脚本。</strong> 如果我们下载了某些东西并将其永久保存，则无法再卸载它。 因此，该技术可以与稳定的框架一起使用，但是如果您每天多次部署应用程序，则很可能对您不起作用。 <br><br> 该技术被认为是透明的，也就是说，它允许在不进行任何更改的情况下加载现有应用程序（或其部分）。 但是在实施之后，事实证明这并非完全正确<strong>，如果使用preload加载了所有应用程序，则并非所有应用程序都能按预期运行</strong> 。 例如，如果根据检查<code>function_exists</code>或<code>class_exists</code>的结果在应用程序中调用代码，并且该函数分别变为常量，那么<code>function_exists</code>始终返回<code>true</code> ，并且认为先前调用的代码未被调用。 <br><br> 从技术上讲，仅通过一个配置指令opcache.preload启用预加载，然后在该输入的输入中提供一个脚本文件-一个常规的PHP文件，该文件将在应用程序启动阶段启动（不只是加载，而是执行）。 <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_preload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $preload, string $pattern = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"/\.php$/"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_file($path) &amp;&amp; preg_match($pattern, $path)) { opcache_compile_file($path) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>(<span class="hljs-string"><span class="hljs-string">"Preloading failed"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_dir($path)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($dh = opendir($path)) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (($file = readdir($dh)) !== <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($file !== <span class="hljs-string"><span class="hljs-string">"."</span></span> &amp;&amp; $file !== <span class="hljs-string"><span class="hljs-string">".."</span></span>) { _preload($path . <span class="hljs-string"><span class="hljs-string">"/"</span></span> . $file, $pattern); } } closedir($dh); } } } _preload(<span class="hljs-string"><span class="hljs-string">"/usr/local/lib/ZendFramework"</span></span>);</code> </pre> <br> 这是递归读取某个目录（在本例中为ZendFramework）中所有文件的可能方案之一。 您可以使用PHP绝对实现任何脚本：读取列表，添加异常，甚至与作曲者交叉使用，以便它预加载所需的podsoval文件。 这全都是技术问题，更有趣的不是如何运输，而是运输什么。 <br><br><h3> 预加载中要加载的内容 </h3><br> 我在WordPress上尝试了这项技术。 如果仅上传所有* .php文件，则WordPress将由于先前提到的功能而停止工作：它具有function_exists检查，该检查始终为true。 因此，我不得不稍微修改上一个示例中的脚本（添加例外），然后在WordPress本身不做任何更改的情况下就可以正常工作了。 <br><br><div class="scrollable-table"><table><tbody><tr><td></td><td> 速度[req / seq] </td><td> 记忆体[MB] </td><td> 脚本数量 </td><td> 功能数量 </td><td> 班数 </td></tr><tr><td> 没事 </td><td>  378 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td></tr><tr><td> 全部（几乎*） </td><td>  395 </td><td>  7.5 </td><td>  254 </td><td>  1770年 </td><td>  148 </td></tr><tr><td> 仅使用的脚本 </td><td>  396 </td><td>  4,5 </td><td>  84 </td><td>  1532 </td><td>  51 </td></tr></tbody></table></div><br> 结果， <strong>由于预加载，我们获得了5％的加速度</strong> ，这已经不错了。 <br><br> 我下载了几乎所有文件，但其中一半未使用。 您甚至可以做得更好-驱动应用程序，查看已下载的文件。 您可以使用<code>opcache_get_status()</code>函数执行此操作，该函数将返回所有OPcache缓存的文件并为它们创建一个列表以进行预加载。 因此，您可以节省3 MB并获得更多的加速。 事实是，需要的内存越多，处理器高速缓存就会变得越来越脏，并且效率越低。  <strong>使用的内存越少，速度越高。</strong> <br><br><h2>  FFI-外部功能接口 </h2><br> 为PHP开发的另一项与JIT相关的技术是FFI（外功能接口），或者用俄语调用无需编译即可调用用其他已编译程序语言编写的函数的功能。 用Python实现的这种技术给我的老板（Zeev Surazki）留下了深刻的印象，当我开始将其适应PHP时，我印象深刻。 <br><br>  PHP已经进行了几次尝试来为FFI创建扩展，但是它们都使用自己的语言或API来描述接口。 我在LuaJIT中窥探了这个想法，其中使用C语言（一个子集）描述了接口，结果得到了一个非常酷的玩具。 现在，当我需要检查某些东西在C中的工作方式时，我用PHP编写了它-它发生在命令行上。 <br><br>  FFI允许您使用C中定义的数据结构，并且可以与JIT集成以生成更有效的代码。 它基于libffi的实现已包含在PHP 7.4中。 <br><br> 但是： <br><br><ul><li> 这是1000种射击自己的新方法。 </li><li> 需要C知识，有时需要手动内存管理。 </li><li> 不支持C预处理器（＃include，＃define等）和C ++。 </li><li> 没有JIT的性能相当低。 </li></ul><br> 虽然，也许对于某些人来说会很方便，因为不需要编译器。 即使在Windows下，也可以在没有PHP的Visual-C的情况下使用。 <br><br> 我将向您展示如何使用FFI为Linux实现真正的GUI应用程序。 <br><br> 不用担心C代码，我自己大约在20年前用C编写了一个GUI，但是我在Internet上找到了这个示例。 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;gtk/gtk.h&gt; static void activate(GtkApplication* app, gpointer user_data) { GtkWidget *window = gtk_application_window_new(app); gtk_window_set_title(GTK_WINDOW(window), "Hello from C"); gtk_window_set_default_size(GTK_WINDOW(window), 200, 200); gtk_widget_show_all(window); } int main() { int status; GtkApplication *app; app = gtk_application_new("org.gtk.example", G_APPLICATION_FLAGS_NONE); g_signal_connect(app, "activate", G_CALLBACK(activate), NULL); status = g_application_run(G_APPLICATION(app), 0, NULL); g_object_unref(app); return status; }</span></span></span></span></code> </pre> <br> 该程序将创建应用程序，挂在activate回调事件上，然后启动应用程序。 在回调中，创建一个窗口，为其分配标题大小并显示它。 <br><br> 现在，用PHP重写了同一件事： <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $ffi = FFI::cdef(<span class="hljs-string"><span class="hljs-string">" … // #include &lt;gtk/gtk.h&gt; "</span></span>, <span class="hljs-string"><span class="hljs-string">"libgtk-3.so.0"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">activate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($app, $user_data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> $ffi; $window = $ffi-&gt;gtk_application_window_new($app); $ffi-&gt;gtk_window_set_title($window, <span class="hljs-string"><span class="hljs-string">"Hello from PHP"</span></span>); $ffi-&gt;gtk_window_set_default_size($window, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); $ffi-&gt;gtk_widget_show_all($window); } $app = $ffi-&gt;gtk_application_new(<span class="hljs-string"><span class="hljs-string">"org.gtk.example"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); $ffi-&gt;g_signal_connect_data($app, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); $ffi-&gt;g_application_run($app, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); $ffi-&gt;g_object_unref($app);</code> </pre> <br> 在此，首先创建FFI对象。 接口的描述作为输入（实质上是h文件）和我们要下载的库发送给他。 之后，接口中描述的所有功能都可以作为ffi对象的方法使用，并且所有传输的参数都自动且绝对透明地转换为必要的机器表示形式。 <br><br> 可以看出，一切都与前面的示例完全相同。 唯一的区别是，在C中，我们发送了一个回调作为地址，而在PHP中，连接是通过字符串指定的名称进行的。 <br><br> 现在，让我们看看界面是什么样的。 在第一部分中，我们确定C语言中的类型和函数，在最后一行中，我们加载共享库： <br><br><pre> <code class="cpp hljs">&lt;?php $ffi = FFI::cdef(<span class="hljs-string"><span class="hljs-string">" typedef struct _GtkApplication GtkApplication; typedef struct _GtkWidget GtkWidget; typedef void (*GCallback)(void*,void*); int g_application_run (GtkApplication *app, int argc, char **argv); unsigned long * g_signal_connect_data (void *ptr, const char *signal, GCallback handler, void *data, GCallback *destroy, int flags); void g_object_unref (void *ptr); GtkApplication * gtk_application_new (const char *app_id, int flags); GtkWidget * gtk_application_window_new (GtkApplication *app); void gtk_window_set_title (GtkWidget *win, const char *title); void gtk_window_set_default_size (GtkWidget *win, int width, int height); void gtk_widget_show_all (GtkWidget *win); "</span></span>, <span class="hljs-string"><span class="hljs-string">"libgtk-3.so.0"</span></span>); ...</code> </pre> <br> 在这种情况下，这些C定义从GTK库的h文件复制而来，几乎没有变化。 <br><br> 为了不干扰同一文件中的C和PHP，您可以将整个C代码放入一个单独的文件中，例如，名称为gtk-ffi.h，并在开头添加几个特殊的define'ov，以指定用于加载的接口名称和库： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FFI_SCOPE </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GTK"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FFI_LIB </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"libgtk-3.so.0"</span></span></span></span></code> </pre> <br> 因此，我们在一个文件中选择了C接口的整个描述。 这个gtk-ffi.h几乎是真实的，但是不幸的是，我们还没有实现C预处理器，这意味着宏和包含将无法工作。 <br><br> 现在让我们在PHP中加载此接口： <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GTK</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $ffi = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_window</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($title)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_null(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi)) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi = FFI::load(<span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span> . <span class="hljs-string"><span class="hljs-string">"/gtk_ffi.h"</span></span>); $app = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_application_new(<span class="hljs-string"><span class="hljs-string">"org.gtk.example"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_signal_connect_data($app, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($app, $data)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($title)</span></span></span><span class="hljs-function"> </span></span>{ $window = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_application_window_new($app); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_window_set_title($window, $title); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_window_set_default_size($window, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_widget_show_all($window); }, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_application_run($app, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_object_unref($app); } }</code> </pre> <br> 由于FFI是一种相当危险的技术，因此我们不想将其交给任何人。 让我们至少隐藏FFI对象，即在类中将其设为私有。 我们将创建一个FFI对象，而不是使用<code>FFI::cdef</code> ，而是使用<code>FFI::load</code> ，该对象仅读取上一个示例中的h文件。 <br><br> 剩下的代码没有太大变化，只是作为事件处理程序，我们开始使用未命名的函数，并使用词法绑定来传递标题。 也就是说，我们同时使用C和PHP的优势，而C则没有。 <br><br> 以这种方式创建的库可能已在您的应用程序中使用。 但是如果它<strong>只能在命令行上运行</strong> ，并且将其放置在网络服务器中，则会在每次请求时读取gtk_ffi.h文件，创建并加载一个库，完成绑定，然后再进行所有这些重复性工作，从而加载您的服务器。 <br><br> 为了避免这种情况，并且实际上允许在PHP本身中编写PHP扩展，我们决定将FFI与预加载交叉使用。 <br><br><h3>  FFI +预加载 </h3><br> 代码没有太大变化，只是现在我们将h文件提供给预加载，并且我们在预<code>FFI::load</code>直接执行<code>FFI::load</code> ，而不是在创建对象时执行。 也就是说，加载库，所有解析和绑定都完成一次（服务器启动时），然后使用<code>FFI::scope("GTK")</code>在脚本中按名称访问预加载的接口。 <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> FFI::load(<span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span> . <span class="hljs-string"><span class="hljs-string">"/gtk_ffi.h"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GTK</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $ffi = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_window</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($title)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_null(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi)) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi = FFI::scope(<span class="hljs-string"><span class="hljs-string">"GTK"</span></span>); $app = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_application_new(<span class="hljs-string"><span class="hljs-string">"org.gtk.example"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_signal_connect_data($app, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($app, $data)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($title)</span></span></span><span class="hljs-function"> </span></span>{ $window = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_application_window_new($app); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_window_set_title($window, $title); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_window_set_default_size($window, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_widget_show_all($window); }, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_application_run($app, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_object_unref($app); } }</code> </pre> <br> 在此实施例中，可以从Web服务器使用FFI。 当然，这不是针对GUI的，而是通过这种方式，您可以编写（例如）绑定到数据库。 <br><br> 可以通过命令行直接使用以这种方式创建的扩展名： <br><pre> <code class="xml hljs">$ php -d opcache.preload=gtk.php -r 'GTK::create_window(" !");'</code> </pre> <br>  FFI杂交和预加载的另一个优点是可以禁止在所有用户级脚本中使用FFI。 您可以指定ffi.enable = preload，这表示我们信任预加载的文件，但是禁止从常规PHP脚本调用FFI。 <br><br><h3> 使用数据结构C </h3><br>  FFI的另一个有趣的功能是它可以与本机数据结构一起使用。 您可以随时在内存中创建C中描述的任何数据结构。 <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $points = FFI::new(<span class="hljs-string"><span class="hljs-string">"struct {int x,y;} [100]"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($x = <span class="hljs-number"><span class="hljs-number">0</span></span>; $x &lt; count($points); $x++) { $points[$x]-&gt;x = $x; $points[$x]-&gt;y = $x * $x; } var_dump($points[<span class="hljs-number"><span class="hljs-number">25</span></span>]-&gt;y); <span class="hljs-comment"><span class="hljs-comment">// 625 var_dump(FFI::sizeof($points)); // 800  foreach ($points as &amp;$p) { $p-&gt;x += 10; } var_dump($points[25]-&gt;x); // 35</span></span></code> </pre> <br>    100  (  FFI::new != new FFI),     integer.       ,    C.             PHP,     .     count, /        foreach  .      800 ,      PHP      PHP'   ,       10 . <br><br>   FFI: <br><br><ul><li> <a href="https://github.com/dstogov/php-tensorflow"> </a>  PHP. </li><li> <a href="https://github.com/ircmaxell/libgccffi"></a>  PHP. </li></ul><br> Python/CFFI    :  (Cario, JpegTran),  (ffmpeg),  (LibreOfficeKit),   (SDL)    (TensorFlow). <br><br> <strong> ,   FFI    .</strong> <br><br>   -   PHP.    ,      ,      callback'        ,      .         FFI.  ,   .    FFI c JIT, ,   LuaJIT,    .      ,    ,     . <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($k=<span class="hljs-number"><span class="hljs-number">0</span></span>; $k&lt;<span class="hljs-number"><span class="hljs-number">1000</span></span>; $k++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i=$n<span class="hljs-number"><span class="hljs-number">-1</span></span>; $i&gt;=<span class="hljs-number"><span class="hljs-number">0</span></span>; $i--) { $Y[$i] += $X[$i]; } }</code> </pre> <br>      FFI   . <br><div class="scrollable-table"><table><tbody><tr><td></td><td> Native Arrays </td><td> FFI Arrays </td></tr><tr><td> PyPy </td><td> 0,010 </td><td> 0,081 </td></tr><tr><td> Python </td><td> 0,212 </td><td> 0,343 </td></tr><tr><td> LuaJIt -joff </td><td> 0,037 </td><td> 0,412 </td></tr><tr><td> LuaJit -jon </td><td> 0,003 </td><td> 0,002 </td></tr><tr><td>  p </td><td> 0,040 </td><td> 0,093 </td></tr><tr><td> PHP + JIT </td><td> 0,016 </td><td> 0,087 </td></tr></tbody></table></div><br> <em>  : Zeev Surasky (Zend), Andi Gutmans (ex-Zend, Amazon), Xinchen Hui (ex-Weibo, ex-Zend, Lianjia), Nikita Popov (JetBrains), Anatol Belsky (Microsoft), Anthony Ferrara (ex-Google, Lingo Live), Joe Watkins, Mohammad Reza Haghighat (Intel)   Intel, Andy Wingo (JS hacker, Igalia), Mike Pall ( LuaJIT).</em> <br><br>        ,       ,    <a href="https://www.youtube.com/watch%3Fv%3D7UOWus-5yxg%26amp%3Bfeature%3Dyoutu.be%26amp%3Bt%3D1804"></a> . <br><br><blockquote> <a href="https://phprussia.ru/moscow/2020">PHP Russia 2020</a> !     <a href="http://eepurl.com/VYVaf"></a>  <a href="https://t.me/PHPRussiaConfChannel">telegram-</a> ,    2019     <a href="https://www.youtube.com/channel/UCxLQ9eT6YHnc6dMLRFzEc7Q">youtube-</a>  ,       , — <a href="https://conf.ontico.ru/lectures/propose%3Fconference%3Dpc2020"> </a>  . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN481092/">https://habr.com/ru/post/zh-CN481092/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN481074/index.html">Python计算器</a></li>
<li><a href="../zh-CN481078/index.html">投票失败：我们将AgentTesla带到干净的水中。 第三部分</a></li>
<li><a href="../zh-CN481082/index.html">Mohnatiki占领了游戏行业的市场！ Peregrine Labs宣布与Epic Games合作</a></li>
<li><a href="../zh-CN481084/index.html">Python，数据库简介</a></li>
<li><a href="../zh-CN481086/index.html">Vivaldi 2.10-卧底特工</a></li>
<li><a href="../zh-CN481094/index.html">关于具有太阳能的JBL无线耳机以及它们的毛病</a></li>
<li><a href="../zh-CN481100/index.html">Angular 9，有什么新功能？</a></li>
<li><a href="../zh-CN481102/index.html">跨平台.NET UI工具包发布AvaloniaUI 0.9</a></li>
<li><a href="../zh-CN481104/index.html">融合OpenJDK和NodeJS：跨语言交互和垂直架构</a></li>
<li><a href="../zh-CN481106/index.html">LANIT如何在他的办公室拍摄DIY情景喜剧</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>