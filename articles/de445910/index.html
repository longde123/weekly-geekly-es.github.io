<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💅🏾 🤚🏿 🤲🏿 Wie wir uns mit EF 6 MSSQL und PostgresSQL angefreundet haben 📸 😮 🙍🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es war einmal ein Projekt auf EF 6 mit dem MSSQL DBMS. Außerdem musste die Möglichkeit hinzugefügt werden, mit PostgreSQL zu arbeiten. Wir haben hier ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir uns mit EF 6 MSSQL und PostgresSQL angefreundet haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/crosstech/blog/445910/"><img src="https://habrastorage.org/webt/_a/jr/dp/_ajrdpk_rrdrsqmckt71xkfceve.jpeg" alt="Bild"><br><br>  Es war einmal ein Projekt auf EF 6 mit dem MSSQL DBMS.  Außerdem musste die Möglichkeit hinzugefügt werden, mit PostgreSQL zu arbeiten.  Wir haben hier keine Probleme erwartet, da es eine große Anzahl von Artikeln zu diesem Thema gibt und Sie in den Foren eine Diskussion über ähnliche Probleme finden.  In Wirklichkeit stellte sich jedoch nicht alles als so einfach heraus, und in diesem Artikel werden wir über diese Erfahrung, über die Probleme, die bei der Integration des neuen Anbieters aufgetreten sind, und über die von uns gewählte Lösung sprechen. <br><a name="habracut"></a><br><h3>  Einführung </h3><br>  Wir haben ein Boxprodukt und es hat eine bereits etablierte Struktur.  Ursprünglich war es für die Arbeit mit einem DBMS - MSSQL konfiguriert.  Das Projekt verfügt über eine Datenzugriffsschicht mit EF 6-Implementierung (Code First-Ansatz).  Wir arbeiten mit Migrationen über EF 6 Migrations.  Migrationen werden manuell erstellt.  Die Erstinstallation der Datenbank erfolgt über die Konsolenanwendung mit der Initialisierung des Kontexts in der Verbindungszeichenfolge, die als Argument übergeben wird: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (args.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"No arguments in command line"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> connectionString = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Initializing dbcontext via </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{connectionString}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> context = MyDbContext(connectionString)) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Database created"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { Console.WriteLine(e.Message); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } }</code> </pre> <br>  Gleichzeitig werden die EF-Infrastruktur und die Domänendomäne in einem anderen Projekt beschrieben, das als Bibliothek mit der Konsolenanwendung verbunden ist.  Der Kontextkonstruktor im Infrastrukturprojekt sieht folgendermaßen aus: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyDbContext</span></span> : <span class="hljs-title"><span class="hljs-title">IdentityDbContext</span></span>&lt;<span class="hljs-title"><span class="hljs-title">User</span></span>, <span class="hljs-title"><span class="hljs-title">Role</span></span>, <span class="hljs-title"><span class="hljs-title">Key</span></span>, <span class="hljs-title"><span class="hljs-title">UserLogin</span></span>, <span class="hljs-title"><span class="hljs-title">UserRole</span></span>, <span class="hljs-title"><span class="hljs-title">UserClaim</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">IUnitOfWork</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyDbContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> connectionString</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">connectionString</span></span></span><span class="hljs-function">)</span></span> { Database.SetInitializer(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbInitializer()); Database.Initialize(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } }</code> </pre><br><h3>  Erster Start </h3><br>  Als erstes haben wir zwei Pakete über Nuget mit dem Projekt verbunden: Npgsql und EntityFramework6.Npgsql. <br><br>  Wir haben auch die Einstellungen für Postgres in der App.config unserer Konsolenanwendung registriert. <br><br>  Im Abschnitt entityFramework wurde die Standard-Postgres-Factory als Verbindungsfactory angegeben: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">entityFramework</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--&lt;defaultConnectionFactory type="System.Data.Entity.Infrastructure.SqlConnectionFactory, EntityFramework" /&gt;--&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">defaultConnectionFactory</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Npgsql.NpgsqlConnectionFactory, EntityFramework6.Npgsql"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">providers</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">provider</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">invariantName</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"System.Data.SqlClient"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"System.Data.Entity.SqlServer.SqlProviderServices, EntityFramework.SqlServer"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">provider</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">invariantName</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Npgsql"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Npgsql.NpgsqlServices, EntityFramework6.Npgsql"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">providers</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">entityFramework</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Im Bereich DbProviderFactories wurde die Fabrik des neuen Anbieters registriert: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">system.data</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">DbProviderFactories</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">add</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Npgsql Data Provider"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">invariant</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Npgsql"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">support</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"FF"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">description</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".Net Framework Data Provider for Postgresql"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Npgsql.NpgsqlFactory, Npgsql"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">DbProviderFactories</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">system.data</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Und sofort versuchten sie, die Datenbank zu initialisieren, indem sie die Adresse des Postgres-Servers und die Anmeldeinformationen des Serveradministrators in der Verbindungszeichenfolge angaben.  Das Ergebnis ist die folgende Zeile: <br><blockquote>  “Server = localhost;  Datenbank = TestPostgresDB;  Integrierte Sicherheit = falsch;  Benutzer-ID = postgres;  Passwort = pa $$ w0rd ” </blockquote>  Wie erwartet wurde die Initialisierung dank des manuellen EF-Migrationsmodus nicht bestanden, und es trat ein Fehler auf, der nicht mit dem Datenbankabbild des aktuellen Modells übereinstimmte.  Um die Erstellung der primären Migration mit dem neuen Anbieter zu umgehen und die Datenbankinitialisierung auf Postgres zu testen, haben wir unsere Infrastrukturkonfiguration leicht angepasst. <br><br>  Erstens haben wir "Auto-Migrationen" aktiviert - eine nützliche Option, wenn ein Entwickler Änderungen an den Domänenmodellen und der EF-Infrastruktur im Team vornimmt: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Configuration</span></span> : <span class="hljs-title"><span class="hljs-title">DbMigrationsConfiguration</span></span>&lt;<span class="hljs-title"><span class="hljs-title">MyDbContext</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configuration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { AutomaticMigrationsEnabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ContextKey = <span class="hljs-string"><span class="hljs-string">"Project.Infrastructure.MyDbContext"</span></span>; } }</code> </pre><br>  Zweitens haben wir in der neu definierten Methode InitializeDatabase der geerbten Klasse CreateDatabaseIfNotExists einen neuen Anbieter angegeben, mit dem wir die Migrationen starten: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DbInitializer</span></span> : <span class="hljs-title"><span class="hljs-title">CreateDatabaseIfNotExists</span></span>&lt;<span class="hljs-title"><span class="hljs-title">MyDbContext</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeDatabase</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MyDbContext context</span></span></span><span class="hljs-function">)</span></span> { DbMigrator dbMigrator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbMigrator(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Configuration { <span class="hljs-comment"><span class="hljs-comment">//TargetDatabase = new DbConnectionInfo(context.Database.Connection.ConnectionString, "System.Data.SqlClient") TargetDatabase = new DbConnectionInfo(context.Database.Connection.ConnectionString, "Npgsql") }); // There some code for run migrations } }</span></span></code> </pre><br>  Als Nächstes haben wir unsere Konsolenanwendung erneut mit derselben Verbindungszeichenfolge wie ein Argument gestartet.  Diesmal verlief die Initialisierung des Kontexts fehlerfrei, und unsere Domänenmodelle passen sicher in die neue Postgres-Datenbank.  Das Label "__MigrationHistory" wurde in der neuen Datenbank angezeigt, in der ein einziger Datensatz der ersten automatisch erstellten Migration vorhanden war. <br><br>  Zusammenfassend: Wir konnten problemlos einen neuen Anbieter mit einem vorhandenen Projekt verbinden, gleichzeitig aber die Einstellungen des Migrationsmechanismus ändern. <br><br><h3>  Aktivieren Sie den manuellen Migrationsmodus </h3><br>  Wie oben erwähnt, entziehen Sie Ihrem Team bei aktiviertem automatischen Migrationsmodus die parallele Entwicklung in den Bereichen Domäne und Datenzugriff.  Für uns war diese Option nicht akzeptabel.  Daher mussten wir im Projekt einen manuellen Migrationsmodus einrichten. <br><br>  Zuerst haben wir das Feld AutomaticMigrationsEnabled auf false zurückgesetzt.  Dann war es notwendig, sich mit der Schaffung neuer Migrationen zu befassen.  Wir haben verstanden, dass Migrationen für verschiedene DBMS zumindest in verschiedenen Projektordnern gespeichert werden sollten.  Aus diesem Grund haben wir beschlossen, einen neuen Ordner für Postgres-Migrationen in einem Infrastrukturprojekt namens PostgresMigrations zu erstellen (der Ordner mit MsSql-Migrationen wurde aus Gründen der Übersichtlichkeit in MsSqlMigrations umbenannt) und die Konfigurationsdatei für die MsSql-Migration in diesen Ordner kopiert.  Gleichzeitig haben wir nicht alle vorhandenen MsSql-Migrationen nach PostgresSql kopiert.  Erstens, da sie alle einen Snapshot der Konfiguration für den MsSql-Anbieter enthalten und wir sie dementsprechend nicht auf dem neuen DBMS verwenden können.  Zweitens ist der Verlauf der Änderungen für das neue DBMS nicht wichtig, und wir können mit dem neuesten Schnappschuss des Status von Domänenmodellen auskommen. <br><br>  Wir dachten, dass alles bereit war für die Bildung der ersten Migration nach Postgres.  Die Datenbank, die während der Initialisierung des Kontexts mit aktiviertem automatischen Migrationsmodus erstellt wurde, wurde gelöscht.  Ausgehend von der Tatsache, dass Sie für die erste Migration eine physische Datenbank erstellen müssen, die auf dem aktuellen Status der Domänenmodelle basiert, haben wir den Befehl Update-Database in der Package Manager-Konsole mit der Angabe nur des Verbindungszeichenfolgenparameters bewertet.  Infolgedessen ist beim Herstellen einer Verbindung zum DBMS ein Fehler aufgetreten. <br><br>  Nachdem wir zusätzlich das Funktionsprinzip des Befehls Update-Database untersucht haben, haben wir Folgendes getan: <br><br><ul><li>  Der Migrationskonfigurationseinstellungen wurde der folgende Code hinzugefügt: <br><br>  für MsSql: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configuration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { AutomaticMigrationsEnabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; ContextKey = <span class="hljs-string"><span class="hljs-string">"Project.Infrastructure.MyDbContext"</span></span>; MigrationsDirectory = <span class="hljs-string"><span class="hljs-string">@"MsSqlMigrations"</span></span>; }</code> </pre><br>  für Postgres: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configuration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { AutomaticMigrationsEnabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; ContextKey = <span class="hljs-string"><span class="hljs-string">"Project.Infrastructure.MyDbContext"</span></span>; MigrationsDirectory = <span class="hljs-string"><span class="hljs-string">@"PostgresMigrations"</span></span>; }</code> </pre></li><li>  gab den erforderlichen Parameter des Befehls Update-Database an, wobei der Name des Anbieters übergeben wurde </li><li>  Es wurden Parameter hinzugefügt, die das Projekt mit der Beschreibung der ef-Infrastruktur und den Ordner mit der Migrationskonfiguration des neuen Anbieters angeben </li></ul><br>  Als Ergebnis haben wir diesen Befehl erhalten: <br><blockquote>  Update-Database -ProjectName "Project.Infrastructure" -ConfigurationTypeName Project.Infrastructure.PostgresMigrations.Configuration -ConnectionString "Server = localhost;  Datenbank = TestPostgresDB;  Integrierte Sicherheit = falsch;  Benutzer-ID = postgres;  password = pa $$ w0rd "-ConnectionProviderName" Npgsql " </blockquote>  Nachdem wir diesen Befehl ausgeführt hatten, konnten wir den Befehl Add-Migration mit ähnlichen Parametern ausführen und die erste Migration benennen. InitialCreate: <br><blockquote>  Add-Migration -Name "InitialCreate" -ProjectName "CrossTech.DSS.Infrastructure" -ConfigurationTypeName CrossTech.DSS.Infrastructure.PostgresMigrations.Configuration -ConnectionString "Server = localhost;  Datenbank = TestPostgresDB;  Integrierte Sicherheit = falsch;  Benutzer-ID = postgres;  password = pa $$ w0rd "-ConnectionProviderName" Npgsql " </blockquote>  Eine neue Datei wurde im Ordner PostgresMigrations angezeigt: 2017010120705068_InitialCreate.cs <br><br>  Anschließend haben wir die nach dem Ausführen des Befehls Update-Database erstellte Datenbank gelöscht und unsere Konsolenanwendung mit der oben als Argument angegebenen Verbindungszeichenfolge gestartet.  Und so haben wir die Datenbank bereits auf Basis einer manuell erstellten Migration erhalten. <br><br>  Zusammenfassend lässt sich sagen, dass wir mit minimalem Aufwand die erste Migration für den Postgres-Anbieter hinzufügen und den Kontext über die Konsolenanwendung initialisieren konnten, um eine neue Datenbank zu erhalten, in die die Änderungen aus unserer ersten manuellen Migration übernommen wurden. <br><br><h3>  Zwischen Anbietern wechseln </h3><br>  Wir hatten noch eine offene Frage: Wie konfiguriere ich die Kontextinitialisierung so, dass zur Laufzeit auf ein bestimmtes DBMS zugegriffen werden kann? <br><br>  Die Aufgabe bestand darin, dass in der Initialisierungsphase des Kontexts die eine oder andere Zieldatenbank des gewünschten Anbieters ausgewählt werden konnte.  Als Ergebnis wiederholter Versuche, diesen Switch zu konfigurieren, haben wir eine Lösung gefunden, die so aussieht. <br><br>  In der Konsolenanwendung des Projekts in app.config (und wenn Sie app.config nicht verwenden, dann machine.config) fügen wir eine neue Verbindungszeichenfolge mit dem Anbieter und dem Namen der Verbindung hinzu, und im Kontextkonstruktor "löschen" wir den Verbindungsnamen anstelle der Verbindungszeichenfolge.  Gleichzeitig verbinden wir die Verbindungszeichenfolge selbst über den Singleton der DbConfiguration-Instanz mit dem Kontext.  Wir übergeben die Instanz der geerbten Klasse von DbConfiguration als Parameter. <br><br>  Die resultierende geerbte DbConfiguration-Klasse: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DbConfig</span></span> : <span class="hljs-title"><span class="hljs-title">DbConfiguration</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DbConfig</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> connectionName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> connectionString, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> provideName</span></span></span><span class="hljs-function">)</span></span> { ConfigurationManager.ConnectionStrings.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConnectionStringSettings(connectionName, connectionString, provideName)); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (connectionName) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"PostgresDbConnection"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetDefaultConnectionFactory(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NpgsqlConnectionFactory()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetProviderServices(provideName, NpgsqlServices.Instance); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetProviderFactory(provideName, NpgsqlFactory.Instance); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"MsSqlDbConnection"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetDefaultConnectionFactory(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SqlConnectionFactory()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetProviderServices(provideName, SqlProviderServices.Instance); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetProviderFactory(provideName, SqlClientFactory.Instance); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetDefaultConnectionFactory(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SqlConnectionFactory()); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }</code> </pre><br>  Und die Kontextinitialisierung selbst sieht jetzt so aus: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> connectionName = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> connectionString = args[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> provideName = args[<span class="hljs-number"><span class="hljs-number">2</span></span>]; DbConfiguration.SetConfiguration(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbConfig(connectionName, connectionString, provideName)); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> context = MyDbContext(connectionName)) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Database created"</span></span>); }</code> </pre><br>  Und wer genau folgte, bemerkte wahrscheinlich, dass wir den Code noch einmal ändern mussten.  Dies ist die Definition der Zieldatenbank während der Datenbankinitialisierung, die in der zuvor beschriebenen InitializeDatabase-Methode erfolgt. <br><br>  Wir haben einen einfachen Schalter hinzugefügt, um die Migrationskonfiguration eines bestimmten Anbieters zu bestimmen: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DbInitializer</span></span> : <span class="hljs-title"><span class="hljs-title">CreateDatabaseIfNotExists</span></span>&lt;<span class="hljs-title"><span class="hljs-title">MyDbContext</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> _connectionName; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DbInitializer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> connectionName</span></span></span><span class="hljs-function">)</span></span> { _connectionName = connectionName; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeDatabase</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MyDbContext context</span></span></span><span class="hljs-function">)</span></span> { DbMigrationsConfiguration&lt;MyDbContext&gt; config; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (_connectionName) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"PostgresDbConnection"</span></span>: config = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PostgresMigrations.Configuration(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"MsSqlDbConnection"</span></span>: config = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MsSqlMigrations.Configuration(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: config = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (config == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; config.TargetDatabase = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbConnectionInfo(_connectionName); DbMigrator dbMigrator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbMigrator(config); <span class="hljs-comment"><span class="hljs-comment">// There some code for run migrations } }</span></span></code> </pre><br>  Und der Kontextkonstruktor selbst sah folgendermaßen aus: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyDbContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> connectionNameParam</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">connectionString</span></span></span><span class="hljs-function">)</span></span> { Database.SetInitializer(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbInitializer(connectionName = connectionNameParam)); Database.Initialize(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre><br>  Als Nächstes haben wir die Konsolenanwendung gestartet und den MsSql-Anwendungsparameter als DBMS-Anbieter angegeben.  Wir setzen die Argumente für die Anwendung wie folgt: <blockquote>  "MsSqlDbConnection" "Server = localhost \ SQLEXPRESS;  Datenbank = TestMsSqlDB;  Benutzer-ID = sa;  password = pa $$ w0rd "" System.Data.SqlClient " </blockquote><br>  Die MsSql-Datenbank wurde fehlerfrei erstellt. <br><br>  Dann haben wir die Anwendungsargumente angegeben: <br><blockquote>  "PostgresDbConnection" "Server = localhost;  Datenbank = TestPostgresDB;  Integrierte Sicherheit = falsch;  Benutzer-ID = postgres;  Passwort = pa $$ w0rd "" Npgsql " </blockquote>  Die Postgres-Datenbank wurde ebenfalls fehlerfrei erstellt. <br><br>  Also noch eine Zwischensumme - damit EF den Datenbankkontext für einen bestimmten Anbieter zur Laufzeit initialisieren kann, benötigen Sie: <br><br><ul><li>  Geben Sie den Migrationsmechanismus für diesen Anbieter an </li><li>  Konfigurieren Sie DBMS-Verbindungszeichenfolgen vor der Kontextinitialisierung </li></ul><br><h3>  Wir arbeiten mit den Migrationen von zwei DBMS in einem Team </h3><br>  Wie wir gesehen haben, beginnt der interessanteste Teil nach dem Auftreten neuer Änderungen in der Domäne.  Sie müssen Migrationen für zwei DBMS unter Berücksichtigung eines bestimmten Anbieters generieren. <br><br>  Für MSSQL Server müssen Sie also sequentielle Befehle ausführen (für Postgres die oben beschriebenen Befehle beim Erstellen der ersten Migration): <br><br><ul><li>  Aktualisieren der Datenbank gemäß dem letzten Snapshot <br><blockquote>  Update-Database -ProjectName "Project.Infrastructure" -ConfigurationTypeName Project.Infrastructure.MsSqlMigrations.Configuration -ConnectionString "Server = localhost;  Datenbank = TestMsSqlDB;  Integrierte Sicherheit = falsch;  Benutzer-ID = sa;  password = pa $$ w0rd "-ConnectionProviderName" System.Data.SqlClient " </blockquote></li><li>  Hinzufügen einer neuen Migration <br><blockquote>  Add-Migration -Name "SomeMigrationName" -ProjectName "Project.Infrastructure" -ConfigurationTypeName Project.Infrastructure.MsSqlMigrations.Configuration -ConnectionString "Server = localhost;  Datenbank = TestMsSqlDB;  Integrierte Sicherheit = falsch;  Benutzer-ID = sa;  password = pa $$ w0rd "-ConnectionProviderName" System.Data.SqlClient " </blockquote></li></ul><br>  Wenn Entwickler parallel Änderungen an der Domäne vornehmen, treten beim Zusammenführen dieser Änderungen im Versionskontrollsystem mehrere Konflikte auf (der Einfachheit halber werden wir git nennen).  Dies liegt an der Tatsache, dass Migrationen zu EF nacheinander erfolgen.  Und wenn ein Entwickler eine Migration erstellt, gelingt es einem anderen Entwickler einfach nicht, die Migration nacheinander hinzuzufügen.  Bei jeder nachfolgenden Migration werden Informationen zur vorherigen gespeichert.  Daher ist es notwendig, die sogenannten Modell-Snapshots bei der Migration auf die zuletzt erstellte zu aktualisieren. <br><br>  Gleichzeitig kommt es bei der Lösung von Konflikten bei EF-Migrationen in einem Team darauf an, die Bedeutung von Änderungen eines bestimmten Entwicklers zu priorisieren.  Und deren Änderungen eine höhere Priorität haben, sollten diese als erste in git ausfüllen, und der Rest der Entwickler gemäß der vereinbarten Hierarchie muss Folgendes tun: <br><br><ol><li>  Löschen Sie erstellte lokale Migrationen </li><li>  Ziehen Sie Änderungen aus dem Repository in sich selbst, wo andere Kollegen mit hoher Priorität bereits ihre Migrationen durchgeführt haben </li><li>  Erstellen Sie eine lokale Migration und laden Sie die resultierenden Änderungen zurück zu git </li></ol><br>  Soweit wir mit dem EF-Migrationsmechanismus vertraut sind, können wir beurteilen, dass der beschriebene Teamentwicklungsansatz derzeit der einzige ist.  Wir halten diese Lösung nicht für ideal, aber sie hat das Recht auf Leben.  Und die Frage, eine Alternative zum EF-Migrationsmechanismus zu finden, ist für uns dringend geworden. <br><br><h3>  Abschließend </h3><br>  Die Arbeit mit mehreren DBMS mit EF6 in Verbindung mit EF Migrations ist real, aber in dieser Version haben die Mitarbeiter von Microsoft die Möglichkeit einer parallelen Arbeit des Teams mit Versionskontrollsystemen nicht berücksichtigt. <br><br>  Es gibt viele alternative EF Migrations-Lösungen auf dem Markt (kostenpflichtig und kostenlos): DbUp, RoundhousE, ThinkingHome.Migrator, FluentMigrator usw.  Und nach den Bewertungen sind sie eher Entwickler als EF Migrations. <br><br>  Glücklicherweise haben wir jetzt die Möglichkeit, ein Upgrade in unserem Projekt vorzunehmen.  Und in naher Zukunft werden wir zu EF Core wechseln.  Wir haben die Vor- und Nachteile des EF Core Migrations-Mechanismus abgewogen und sind zu dem Schluss gekommen, dass es für uns bequemer wäre, mit einer Drittanbieterlösung zu arbeiten, nämlich Fluent Migrator. <br><br>  Wir hoffen, Sie haben sich für unsere Erfahrung interessiert.  Bereit, Kommentare anzunehmen und Fragen zu beantworten. Willkommen! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445910/">https://habr.com/ru/post/de445910/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445898/index.html">Über neue Ideen, enge Ansichten und Mundpropaganda</a></li>
<li><a href="../de445900/index.html">So halten Sie erhöhten Systemlasten stand: Sprechen Sie über umfangreiche Vorbereitungen für den Black Friday</a></li>
<li><a href="../de445904/index.html">Arten von Unendlichkeiten und Hirnstamm</a></li>
<li><a href="../de445906/index.html">Iss kein Aspirin</a></li>
<li><a href="../de445908/index.html">Golang und die Entwicklung der Datenbankinteraktion</a></li>
<li><a href="../de445912/index.html">Hallo Habr, wir sind Advantech</a></li>
<li><a href="../de445914/index.html">Ist Docker ein Spielzeug oder nicht? Oder ist es wirklich so?</a></li>
<li><a href="../de445918/index.html">20 Jahre RollerCoaster Tycoon: Ein Interview mit dem Schöpfer des Spiels</a></li>
<li><a href="../de445920/index.html">Live: Wie Sie die iOS-Entwicklung in großen Teams eindämmen können</a></li>
<li><a href="../de445922/index.html">Warum Online-Sendungen ansehen, wenn Sie Habr lesen können?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>