<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÖüèæ ü§öüèø ü§≤üèø Wie wir uns mit EF 6 MSSQL und PostgresSQL angefreundet haben üì∏ üòÆ üôçüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es war einmal ein Projekt auf EF 6 mit dem MSSQL DBMS. Au√üerdem musste die M√∂glichkeit hinzugef√ºgt werden, mit PostgreSQL zu arbeiten. Wir haben hier ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir uns mit EF 6 MSSQL und PostgresSQL angefreundet haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/crosstech/blog/445910/"><img src="https://habrastorage.org/webt/_a/jr/dp/_ajrdpk_rrdrsqmckt71xkfceve.jpeg" alt="Bild"><br><br>  Es war einmal ein Projekt auf EF 6 mit dem MSSQL DBMS.  Au√üerdem musste die M√∂glichkeit hinzugef√ºgt werden, mit PostgreSQL zu arbeiten.  Wir haben hier keine Probleme erwartet, da es eine gro√üe Anzahl von Artikeln zu diesem Thema gibt und Sie in den Foren eine Diskussion √ºber √§hnliche Probleme finden.  In Wirklichkeit stellte sich jedoch nicht alles als so einfach heraus, und in diesem Artikel werden wir √ºber diese Erfahrung, √ºber die Probleme, die bei der Integration des neuen Anbieters aufgetreten sind, und √ºber die von uns gew√§hlte L√∂sung sprechen. <br><a name="habracut"></a><br><h3>  Einf√ºhrung </h3><br>  Wir haben ein Boxprodukt und es hat eine bereits etablierte Struktur.  Urspr√ºnglich war es f√ºr die Arbeit mit einem DBMS - MSSQL konfiguriert.  Das Projekt verf√ºgt √ºber eine Datenzugriffsschicht mit EF 6-Implementierung (Code First-Ansatz).  Wir arbeiten mit Migrationen √ºber EF 6 Migrations.  Migrationen werden manuell erstellt.  Die Erstinstallation der Datenbank erfolgt √ºber die Konsolenanwendung mit der Initialisierung des Kontexts in der Verbindungszeichenfolge, die als Argument √ºbergeben wird: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (args.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"No arguments in command line"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> connectionString = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Initializing dbcontext via </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{connectionString}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> context = MyDbContext(connectionString)) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Database created"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { Console.WriteLine(e.Message); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } }</code> </pre> <br>  Gleichzeitig werden die EF-Infrastruktur und die Dom√§nendom√§ne in einem anderen Projekt beschrieben, das als Bibliothek mit der Konsolenanwendung verbunden ist.  Der Kontextkonstruktor im Infrastrukturprojekt sieht folgenderma√üen aus: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyDbContext</span></span> : <span class="hljs-title"><span class="hljs-title">IdentityDbContext</span></span>&lt;<span class="hljs-title"><span class="hljs-title">User</span></span>, <span class="hljs-title"><span class="hljs-title">Role</span></span>, <span class="hljs-title"><span class="hljs-title">Key</span></span>, <span class="hljs-title"><span class="hljs-title">UserLogin</span></span>, <span class="hljs-title"><span class="hljs-title">UserRole</span></span>, <span class="hljs-title"><span class="hljs-title">UserClaim</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">IUnitOfWork</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyDbContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> connectionString</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">connectionString</span></span></span><span class="hljs-function">)</span></span> { Database.SetInitializer(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbInitializer()); Database.Initialize(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } }</code> </pre><br><h3>  Erster Start </h3><br>  Als erstes haben wir zwei Pakete √ºber Nuget mit dem Projekt verbunden: Npgsql und EntityFramework6.Npgsql. <br><br>  Wir haben auch die Einstellungen f√ºr Postgres in der App.config unserer Konsolenanwendung registriert. <br><br>  Im Abschnitt entityFramework wurde die Standard-Postgres-Factory als Verbindungsfactory angegeben: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">entityFramework</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--&lt;defaultConnectionFactory type="System.Data.Entity.Infrastructure.SqlConnectionFactory, EntityFramework" /&gt;--&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">defaultConnectionFactory</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Npgsql.NpgsqlConnectionFactory, EntityFramework6.Npgsql"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">providers</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">provider</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">invariantName</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"System.Data.SqlClient"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"System.Data.Entity.SqlServer.SqlProviderServices, EntityFramework.SqlServer"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">provider</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">invariantName</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Npgsql"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Npgsql.NpgsqlServices, EntityFramework6.Npgsql"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">providers</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">entityFramework</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Im Bereich DbProviderFactories wurde die Fabrik des neuen Anbieters registriert: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">system.data</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">DbProviderFactories</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">add</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Npgsql Data Provider"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">invariant</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Npgsql"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">support</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"FF"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">description</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".Net Framework Data Provider for Postgresql"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Npgsql.NpgsqlFactory, Npgsql"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">DbProviderFactories</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">system.data</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Und sofort versuchten sie, die Datenbank zu initialisieren, indem sie die Adresse des Postgres-Servers und die Anmeldeinformationen des Serveradministrators in der Verbindungszeichenfolge angaben.  Das Ergebnis ist die folgende Zeile: <br><blockquote>  ‚ÄúServer = localhost;  Datenbank = TestPostgresDB;  Integrierte Sicherheit = falsch;  Benutzer-ID = postgres;  Passwort = pa $$ w0rd ‚Äù </blockquote>  Wie erwartet wurde die Initialisierung dank des manuellen EF-Migrationsmodus nicht bestanden, und es trat ein Fehler auf, der nicht mit dem Datenbankabbild des aktuellen Modells √ºbereinstimmte.  Um die Erstellung der prim√§ren Migration mit dem neuen Anbieter zu umgehen und die Datenbankinitialisierung auf Postgres zu testen, haben wir unsere Infrastrukturkonfiguration leicht angepasst. <br><br>  Erstens haben wir "Auto-Migrationen" aktiviert - eine n√ºtzliche Option, wenn ein Entwickler √Ñnderungen an den Dom√§nenmodellen und der EF-Infrastruktur im Team vornimmt: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Configuration</span></span> : <span class="hljs-title"><span class="hljs-title">DbMigrationsConfiguration</span></span>&lt;<span class="hljs-title"><span class="hljs-title">MyDbContext</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configuration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { AutomaticMigrationsEnabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ContextKey = <span class="hljs-string"><span class="hljs-string">"Project.Infrastructure.MyDbContext"</span></span>; } }</code> </pre><br>  Zweitens haben wir in der neu definierten Methode InitializeDatabase der geerbten Klasse CreateDatabaseIfNotExists einen neuen Anbieter angegeben, mit dem wir die Migrationen starten: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DbInitializer</span></span> : <span class="hljs-title"><span class="hljs-title">CreateDatabaseIfNotExists</span></span>&lt;<span class="hljs-title"><span class="hljs-title">MyDbContext</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeDatabase</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MyDbContext context</span></span></span><span class="hljs-function">)</span></span> { DbMigrator dbMigrator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbMigrator(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Configuration { <span class="hljs-comment"><span class="hljs-comment">//TargetDatabase = new DbConnectionInfo(context.Database.Connection.ConnectionString, "System.Data.SqlClient") TargetDatabase = new DbConnectionInfo(context.Database.Connection.ConnectionString, "Npgsql") }); // There some code for run migrations } }</span></span></code> </pre><br>  Als N√§chstes haben wir unsere Konsolenanwendung erneut mit derselben Verbindungszeichenfolge wie ein Argument gestartet.  Diesmal verlief die Initialisierung des Kontexts fehlerfrei, und unsere Dom√§nenmodelle passen sicher in die neue Postgres-Datenbank.  Das Label "__MigrationHistory" wurde in der neuen Datenbank angezeigt, in der ein einziger Datensatz der ersten automatisch erstellten Migration vorhanden war. <br><br>  Zusammenfassend: Wir konnten problemlos einen neuen Anbieter mit einem vorhandenen Projekt verbinden, gleichzeitig aber die Einstellungen des Migrationsmechanismus √§ndern. <br><br><h3>  Aktivieren Sie den manuellen Migrationsmodus </h3><br>  Wie oben erw√§hnt, entziehen Sie Ihrem Team bei aktiviertem automatischen Migrationsmodus die parallele Entwicklung in den Bereichen Dom√§ne und Datenzugriff.  F√ºr uns war diese Option nicht akzeptabel.  Daher mussten wir im Projekt einen manuellen Migrationsmodus einrichten. <br><br>  Zuerst haben wir das Feld AutomaticMigrationsEnabled auf false zur√ºckgesetzt.  Dann war es notwendig, sich mit der Schaffung neuer Migrationen zu befassen.  Wir haben verstanden, dass Migrationen f√ºr verschiedene DBMS zumindest in verschiedenen Projektordnern gespeichert werden sollten.  Aus diesem Grund haben wir beschlossen, einen neuen Ordner f√ºr Postgres-Migrationen in einem Infrastrukturprojekt namens PostgresMigrations zu erstellen (der Ordner mit MsSql-Migrationen wurde aus Gr√ºnden der √úbersichtlichkeit in MsSqlMigrations umbenannt) und die Konfigurationsdatei f√ºr die MsSql-Migration in diesen Ordner kopiert.  Gleichzeitig haben wir nicht alle vorhandenen MsSql-Migrationen nach PostgresSql kopiert.  Erstens, da sie alle einen Snapshot der Konfiguration f√ºr den MsSql-Anbieter enthalten und wir sie dementsprechend nicht auf dem neuen DBMS verwenden k√∂nnen.  Zweitens ist der Verlauf der √Ñnderungen f√ºr das neue DBMS nicht wichtig, und wir k√∂nnen mit dem neuesten Schnappschuss des Status von Dom√§nenmodellen auskommen. <br><br>  Wir dachten, dass alles bereit war f√ºr die Bildung der ersten Migration nach Postgres.  Die Datenbank, die w√§hrend der Initialisierung des Kontexts mit aktiviertem automatischen Migrationsmodus erstellt wurde, wurde gel√∂scht.  Ausgehend von der Tatsache, dass Sie f√ºr die erste Migration eine physische Datenbank erstellen m√ºssen, die auf dem aktuellen Status der Dom√§nenmodelle basiert, haben wir den Befehl Update-Database in der Package Manager-Konsole mit der Angabe nur des Verbindungszeichenfolgenparameters bewertet.  Infolgedessen ist beim Herstellen einer Verbindung zum DBMS ein Fehler aufgetreten. <br><br>  Nachdem wir zus√§tzlich das Funktionsprinzip des Befehls Update-Database untersucht haben, haben wir Folgendes getan: <br><br><ul><li>  Der Migrationskonfigurationseinstellungen wurde der folgende Code hinzugef√ºgt: <br><br>  f√ºr MsSql: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configuration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { AutomaticMigrationsEnabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; ContextKey = <span class="hljs-string"><span class="hljs-string">"Project.Infrastructure.MyDbContext"</span></span>; MigrationsDirectory = <span class="hljs-string"><span class="hljs-string">@"MsSqlMigrations"</span></span>; }</code> </pre><br>  f√ºr Postgres: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configuration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { AutomaticMigrationsEnabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; ContextKey = <span class="hljs-string"><span class="hljs-string">"Project.Infrastructure.MyDbContext"</span></span>; MigrationsDirectory = <span class="hljs-string"><span class="hljs-string">@"PostgresMigrations"</span></span>; }</code> </pre></li><li>  gab den erforderlichen Parameter des Befehls Update-Database an, wobei der Name des Anbieters √ºbergeben wurde </li><li>  Es wurden Parameter hinzugef√ºgt, die das Projekt mit der Beschreibung der ef-Infrastruktur und den Ordner mit der Migrationskonfiguration des neuen Anbieters angeben </li></ul><br>  Als Ergebnis haben wir diesen Befehl erhalten: <br><blockquote>  Update-Database -ProjectName "Project.Infrastructure" -ConfigurationTypeName Project.Infrastructure.PostgresMigrations.Configuration -ConnectionString "Server = localhost;  Datenbank = TestPostgresDB;  Integrierte Sicherheit = falsch;  Benutzer-ID = postgres;  password = pa $$ w0rd "-ConnectionProviderName" Npgsql " </blockquote>  Nachdem wir diesen Befehl ausgef√ºhrt hatten, konnten wir den Befehl Add-Migration mit √§hnlichen Parametern ausf√ºhren und die erste Migration benennen. InitialCreate: <br><blockquote>  Add-Migration -Name "InitialCreate" -ProjectName "CrossTech.DSS.Infrastructure" -ConfigurationTypeName CrossTech.DSS.Infrastructure.PostgresMigrations.Configuration -ConnectionString "Server = localhost;  Datenbank = TestPostgresDB;  Integrierte Sicherheit = falsch;  Benutzer-ID = postgres;  password = pa $$ w0rd "-ConnectionProviderName" Npgsql " </blockquote>  Eine neue Datei wurde im Ordner PostgresMigrations angezeigt: 2017010120705068_InitialCreate.cs <br><br>  Anschlie√üend haben wir die nach dem Ausf√ºhren des Befehls Update-Database erstellte Datenbank gel√∂scht und unsere Konsolenanwendung mit der oben als Argument angegebenen Verbindungszeichenfolge gestartet.  Und so haben wir die Datenbank bereits auf Basis einer manuell erstellten Migration erhalten. <br><br>  Zusammenfassend l√§sst sich sagen, dass wir mit minimalem Aufwand die erste Migration f√ºr den Postgres-Anbieter hinzuf√ºgen und den Kontext √ºber die Konsolenanwendung initialisieren konnten, um eine neue Datenbank zu erhalten, in die die √Ñnderungen aus unserer ersten manuellen Migration √ºbernommen wurden. <br><br><h3>  Zwischen Anbietern wechseln </h3><br>  Wir hatten noch eine offene Frage: Wie konfiguriere ich die Kontextinitialisierung so, dass zur Laufzeit auf ein bestimmtes DBMS zugegriffen werden kann? <br><br>  Die Aufgabe bestand darin, dass in der Initialisierungsphase des Kontexts die eine oder andere Zieldatenbank des gew√ºnschten Anbieters ausgew√§hlt werden konnte.  Als Ergebnis wiederholter Versuche, diesen Switch zu konfigurieren, haben wir eine L√∂sung gefunden, die so aussieht. <br><br>  In der Konsolenanwendung des Projekts in app.config (und wenn Sie app.config nicht verwenden, dann machine.config) f√ºgen wir eine neue Verbindungszeichenfolge mit dem Anbieter und dem Namen der Verbindung hinzu, und im Kontextkonstruktor "l√∂schen" wir den Verbindungsnamen anstelle der Verbindungszeichenfolge.  Gleichzeitig verbinden wir die Verbindungszeichenfolge selbst √ºber den Singleton der DbConfiguration-Instanz mit dem Kontext.  Wir √ºbergeben die Instanz der geerbten Klasse von DbConfiguration als Parameter. <br><br>  Die resultierende geerbte DbConfiguration-Klasse: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DbConfig</span></span> : <span class="hljs-title"><span class="hljs-title">DbConfiguration</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DbConfig</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> connectionName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> connectionString, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> provideName</span></span></span><span class="hljs-function">)</span></span> { ConfigurationManager.ConnectionStrings.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConnectionStringSettings(connectionName, connectionString, provideName)); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (connectionName) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"PostgresDbConnection"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetDefaultConnectionFactory(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NpgsqlConnectionFactory()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetProviderServices(provideName, NpgsqlServices.Instance); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetProviderFactory(provideName, NpgsqlFactory.Instance); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"MsSqlDbConnection"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetDefaultConnectionFactory(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SqlConnectionFactory()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetProviderServices(provideName, SqlProviderServices.Instance); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetProviderFactory(provideName, SqlClientFactory.Instance); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetDefaultConnectionFactory(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SqlConnectionFactory()); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }</code> </pre><br>  Und die Kontextinitialisierung selbst sieht jetzt so aus: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> connectionName = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> connectionString = args[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> provideName = args[<span class="hljs-number"><span class="hljs-number">2</span></span>]; DbConfiguration.SetConfiguration(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbConfig(connectionName, connectionString, provideName)); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> context = MyDbContext(connectionName)) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Database created"</span></span>); }</code> </pre><br>  Und wer genau folgte, bemerkte wahrscheinlich, dass wir den Code noch einmal √§ndern mussten.  Dies ist die Definition der Zieldatenbank w√§hrend der Datenbankinitialisierung, die in der zuvor beschriebenen InitializeDatabase-Methode erfolgt. <br><br>  Wir haben einen einfachen Schalter hinzugef√ºgt, um die Migrationskonfiguration eines bestimmten Anbieters zu bestimmen: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DbInitializer</span></span> : <span class="hljs-title"><span class="hljs-title">CreateDatabaseIfNotExists</span></span>&lt;<span class="hljs-title"><span class="hljs-title">MyDbContext</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> _connectionName; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DbInitializer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> connectionName</span></span></span><span class="hljs-function">)</span></span> { _connectionName = connectionName; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeDatabase</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MyDbContext context</span></span></span><span class="hljs-function">)</span></span> { DbMigrationsConfiguration&lt;MyDbContext&gt; config; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (_connectionName) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"PostgresDbConnection"</span></span>: config = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PostgresMigrations.Configuration(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"MsSqlDbConnection"</span></span>: config = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MsSqlMigrations.Configuration(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: config = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (config == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; config.TargetDatabase = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbConnectionInfo(_connectionName); DbMigrator dbMigrator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbMigrator(config); <span class="hljs-comment"><span class="hljs-comment">// There some code for run migrations } }</span></span></code> </pre><br>  Und der Kontextkonstruktor selbst sah folgenderma√üen aus: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyDbContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> connectionNameParam</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">connectionString</span></span></span><span class="hljs-function">)</span></span> { Database.SetInitializer(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbInitializer(connectionName = connectionNameParam)); Database.Initialize(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre><br>  Als N√§chstes haben wir die Konsolenanwendung gestartet und den MsSql-Anwendungsparameter als DBMS-Anbieter angegeben.  Wir setzen die Argumente f√ºr die Anwendung wie folgt: <blockquote>  "MsSqlDbConnection" "Server = localhost \ SQLEXPRESS;  Datenbank = TestMsSqlDB;  Benutzer-ID = sa;  password = pa $$ w0rd "" System.Data.SqlClient " </blockquote><br>  Die MsSql-Datenbank wurde fehlerfrei erstellt. <br><br>  Dann haben wir die Anwendungsargumente angegeben: <br><blockquote>  "PostgresDbConnection" "Server = localhost;  Datenbank = TestPostgresDB;  Integrierte Sicherheit = falsch;  Benutzer-ID = postgres;  Passwort = pa $$ w0rd "" Npgsql " </blockquote>  Die Postgres-Datenbank wurde ebenfalls fehlerfrei erstellt. <br><br>  Also noch eine Zwischensumme - damit EF den Datenbankkontext f√ºr einen bestimmten Anbieter zur Laufzeit initialisieren kann, ben√∂tigen Sie: <br><br><ul><li>  Geben Sie den Migrationsmechanismus f√ºr diesen Anbieter an </li><li>  Konfigurieren Sie DBMS-Verbindungszeichenfolgen vor der Kontextinitialisierung </li></ul><br><h3>  Wir arbeiten mit den Migrationen von zwei DBMS in einem Team </h3><br>  Wie wir gesehen haben, beginnt der interessanteste Teil nach dem Auftreten neuer √Ñnderungen in der Dom√§ne.  Sie m√ºssen Migrationen f√ºr zwei DBMS unter Ber√ºcksichtigung eines bestimmten Anbieters generieren. <br><br>  F√ºr MSSQL Server m√ºssen Sie also sequentielle Befehle ausf√ºhren (f√ºr Postgres die oben beschriebenen Befehle beim Erstellen der ersten Migration): <br><br><ul><li>  Aktualisieren der Datenbank gem√§√ü dem letzten Snapshot <br><blockquote>  Update-Database -ProjectName "Project.Infrastructure" -ConfigurationTypeName Project.Infrastructure.MsSqlMigrations.Configuration -ConnectionString "Server = localhost;  Datenbank = TestMsSqlDB;  Integrierte Sicherheit = falsch;  Benutzer-ID = sa;  password = pa $$ w0rd "-ConnectionProviderName" System.Data.SqlClient " </blockquote></li><li>  Hinzuf√ºgen einer neuen Migration <br><blockquote>  Add-Migration -Name "SomeMigrationName" -ProjectName "Project.Infrastructure" -ConfigurationTypeName Project.Infrastructure.MsSqlMigrations.Configuration -ConnectionString "Server = localhost;  Datenbank = TestMsSqlDB;  Integrierte Sicherheit = falsch;  Benutzer-ID = sa;  password = pa $$ w0rd "-ConnectionProviderName" System.Data.SqlClient " </blockquote></li></ul><br>  Wenn Entwickler parallel √Ñnderungen an der Dom√§ne vornehmen, treten beim Zusammenf√ºhren dieser √Ñnderungen im Versionskontrollsystem mehrere Konflikte auf (der Einfachheit halber werden wir git nennen).  Dies liegt an der Tatsache, dass Migrationen zu EF nacheinander erfolgen.  Und wenn ein Entwickler eine Migration erstellt, gelingt es einem anderen Entwickler einfach nicht, die Migration nacheinander hinzuzuf√ºgen.  Bei jeder nachfolgenden Migration werden Informationen zur vorherigen gespeichert.  Daher ist es notwendig, die sogenannten Modell-Snapshots bei der Migration auf die zuletzt erstellte zu aktualisieren. <br><br>  Gleichzeitig kommt es bei der L√∂sung von Konflikten bei EF-Migrationen in einem Team darauf an, die Bedeutung von √Ñnderungen eines bestimmten Entwicklers zu priorisieren.  Und deren √Ñnderungen eine h√∂here Priorit√§t haben, sollten diese als erste in git ausf√ºllen, und der Rest der Entwickler gem√§√ü der vereinbarten Hierarchie muss Folgendes tun: <br><br><ol><li>  L√∂schen Sie erstellte lokale Migrationen </li><li>  Ziehen Sie √Ñnderungen aus dem Repository in sich selbst, wo andere Kollegen mit hoher Priorit√§t bereits ihre Migrationen durchgef√ºhrt haben </li><li>  Erstellen Sie eine lokale Migration und laden Sie die resultierenden √Ñnderungen zur√ºck zu git </li></ol><br>  Soweit wir mit dem EF-Migrationsmechanismus vertraut sind, k√∂nnen wir beurteilen, dass der beschriebene Teamentwicklungsansatz derzeit der einzige ist.  Wir halten diese L√∂sung nicht f√ºr ideal, aber sie hat das Recht auf Leben.  Und die Frage, eine Alternative zum EF-Migrationsmechanismus zu finden, ist f√ºr uns dringend geworden. <br><br><h3>  Abschlie√üend </h3><br>  Die Arbeit mit mehreren DBMS mit EF6 in Verbindung mit EF Migrations ist real, aber in dieser Version haben die Mitarbeiter von Microsoft die M√∂glichkeit einer parallelen Arbeit des Teams mit Versionskontrollsystemen nicht ber√ºcksichtigt. <br><br>  Es gibt viele alternative EF Migrations-L√∂sungen auf dem Markt (kostenpflichtig und kostenlos): DbUp, RoundhousE, ThinkingHome.Migrator, FluentMigrator usw.  Und nach den Bewertungen sind sie eher Entwickler als EF Migrations. <br><br>  Gl√ºcklicherweise haben wir jetzt die M√∂glichkeit, ein Upgrade in unserem Projekt vorzunehmen.  Und in naher Zukunft werden wir zu EF Core wechseln.  Wir haben die Vor- und Nachteile des EF Core Migrations-Mechanismus abgewogen und sind zu dem Schluss gekommen, dass es f√ºr uns bequemer w√§re, mit einer Drittanbieterl√∂sung zu arbeiten, n√§mlich Fluent Migrator. <br><br>  Wir hoffen, Sie haben sich f√ºr unsere Erfahrung interessiert.  Bereit, Kommentare anzunehmen und Fragen zu beantworten. Willkommen! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445910/">https://habr.com/ru/post/de445910/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445898/index.html">√úber neue Ideen, enge Ansichten und Mundpropaganda</a></li>
<li><a href="../de445900/index.html">So halten Sie erh√∂hten Systemlasten stand: Sprechen Sie √ºber umfangreiche Vorbereitungen f√ºr den Black Friday</a></li>
<li><a href="../de445904/index.html">Arten von Unendlichkeiten und Hirnstamm</a></li>
<li><a href="../de445906/index.html">Iss kein Aspirin</a></li>
<li><a href="../de445908/index.html">Golang und die Entwicklung der Datenbankinteraktion</a></li>
<li><a href="../de445912/index.html">Hallo Habr, wir sind Advantech</a></li>
<li><a href="../de445914/index.html">Ist Docker ein Spielzeug oder nicht? Oder ist es wirklich so?</a></li>
<li><a href="../de445918/index.html">20 Jahre RollerCoaster Tycoon: Ein Interview mit dem Sch√∂pfer des Spiels</a></li>
<li><a href="../de445920/index.html">Live: Wie Sie die iOS-Entwicklung in gro√üen Teams eind√§mmen k√∂nnen</a></li>
<li><a href="../de445922/index.html">Warum Online-Sendungen ansehen, wenn Sie Habr lesen k√∂nnen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>