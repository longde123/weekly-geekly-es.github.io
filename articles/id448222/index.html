<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👖 👨🏽‍🌾 🍯 GPU, akselerator heksagonal, dan aljabar linier 😜 ⬛️ 🛀🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Semua kata-kata ini jauh lebih erat kaitannya dengan pengembangan ponsel daripada yang terlihat pada pandangan pertama: akselerator heksagonal sudah m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GPU, akselerator heksagonal, dan aljabar linier</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/448222/">  Semua kata-kata ini jauh lebih erat kaitannya dengan pengembangan ponsel daripada yang terlihat pada pandangan pertama: akselerator heksagonal sudah membantu melatih jaringan saraf pada perangkat seluler;  aljabar dan matan berguna untuk mendapatkan pekerjaan di Apple;  dan pemrograman GPU tidak hanya memungkinkan Anda untuk mempercepat aplikasi, tetapi juga mengajarkan Anda untuk melihat esensi dari berbagai hal. <br><br>  Bagaimanapun, demikian kata kepala pengembangan ponsel Prisma <b>Andrey Volodin</b> .  Dan juga tentang bagaimana ide mengalir ke pengembangan mobile dari GameDev, bagaimana perbedaan paradigma, mengapa Android tidak memiliki blur asli - dan lebih banyak lagi, rilis produktif AppsCast telah dirilis.  Di bawah potongan, kami akan berbicara tentang laporan Andrey di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AppsConf</a> tanpa spoiler. <br><br><img src="https://habrastorage.org/webt/0q/af/fk/0qaffkk1onyogn5werp4i1_rcxg.jpeg"><br><a name="habracut"></a><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AppsCast</a> adalah podcast konferensi pengembang aplikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AppsConf</a> .</i>  <i>Setiap masalah adalah tamu baru.</i>  <i>Setiap tamu adalah pembicara dalam konferensi dengan siapa kami mendiskusikan laporannya dan berbicara tentang topik yang terkait dengannya.</i>  <i>Podcast dipandu oleh anggota komite program AppsConf, Alexei Kudryavtsev dan Daniil Popov.</i> <br><br>  <strong>Alexey Kudryavtsev:</strong> Halo semuanya!  Andrey, tolong beri tahu kami tentang pengalaman Anda. <br><br>  <b>Andrey Volodin</b> : Kami di Prisma mengembangkan produk yang terutama terkait dengan pemrosesan foto dan video.  Aplikasi andalan kami adalah Prisma.  Sekarang kami membuat aplikasi Lensa lain untuk fungsi mirip Facetune. <br><br>  Saya memimpin pengembangan ponsel, tapi saya pelatih game.  Saya memiliki seluruh bagian inti, saya menulis saluran pipa GPU untuk semua aplikasi ini.  Saya mengembangkan kerangka kerja inti sehingga algoritme dan neuron yang dikembangkan tim R&amp;D berjalan di perangkat seluler, bekerja secara waktu nyata.  Singkatnya, untuk membunuh komputasi server dan semua itu. <br><br>  <b>Alexei Kudryavtsev:</b> Ini tidak terdengar seperti pengembangan iOS biasa. <br><br>  <b>Andrey Volodin:</b> Ya, saya memiliki spesifik seperti itu - saya menulis di Swift setiap hari, tetapi pada saat yang sama sangat jauh dari apa yang dianggap pengembangan iOS. <br><br>  <b>Daniil Popov:</b> Anda menyebutkan pipa-pipa GPU, ada apa? <br><br>  <b>Andrey Volodin:</b> Ketika Anda membuat editor foto, Anda juga perlu mengkonfigurasi arsitektur dan menguraikan logika, karena aplikasi memiliki alat yang berbeda.  Misalnya, di Lensa ada alat bokeh yang mengaburkan latar belakang menggunakan neuron, ada alat retouching yang membuat seseorang lebih cantik.  Semua ini perlu bekerja lebih efisien pada GPU.  Selain itu, disarankan untuk tidak mentransfer data antara prosesor dan kartu video setiap kali, tetapi untuk pra-membangun satu set operasi, menjalankannya dalam sekali jalan, dan menunjukkan hasil akhir kepada pengguna. <br><br>  Saluran pipa GPU adalah "gumpalan kecil" dari mana instruksi untuk kartu video dirakit.  Kemudian dia melakukan semua ini dengan sangat cepat dan efisien, dan Anda mengambil hasilnya pada suatu waktu, dan tidak setelah setiap instrumen.  Saya memastikan bahwa jalur pipa GPU kami secepat mungkin, efisien dan pada prinsipnya ada. <br><br>  <b>Alexey Kudryavtsev:</b> Katakan, bagaimana Anda sampai pada ini?  Pengembang iOS biasa mulai dengan memukau dan cetakan, kemudian pergi ke suatu tempat oleh API dan senang.  Bagaimana mungkin Anda melakukan sesuatu yang sama sekali berbeda? <br><br>  <b>Andrey Volodin:</b> Sebagian besar, ini adalah kebetulan.  Sebelum saya mendapat pekerjaan, saya membuat game untuk iOS.  Itu selalu menarik bagi saya, tetapi saya mengerti bahwa di Rusia tidak ada tempat khusus untuk berkembang ke arah ini.  Kebetulan kami bertemu satu sama lain dengan Prisma.  Mereka membutuhkan pengembang iOS yang dapat menulis di Swift dan pada saat yang sama mengetahui GPU, khususnya, Metal, yang baru saja keluar, dan saya pasti cocok dengan deskripsi itu. <br><br>  Saya menanggapi lowongan itu, kami memiliki sinergi, dan untuk tahun ketiga sekarang saya sudah semakin dalam dalam hal ini.  Jika ada yang tidak beres sekarang, maka saya sudah memiliki semua Viper dan MVVM ini - saya bahkan tidak tahu bagaimana itu mendekripsi - saya harus mengerti dari awal. <br><br><h2>  Apa yang dilakukan Insinyur GPU </h2><br>  <b>Daniil Popov:</b> Profil AppsConf Anda mengatakan Engineer GPU.  Apa yang dilakukan GPU Engineer hampir sepanjang hari selain minum kopi? <br><br>  <b>Andrey Volodin:</b> Di sini perlu disebutkan bagaimana prosesor secara fundamental berbeda dari GPU.  Prosesor melakukan operasi seolah-olah berurutan.  Bahkan multithreading yang kita miliki sering palsu: prosesor berhenti dan beralih untuk membuat tugas-tugas kecil yang berbeda, dan melakukannya dalam beberapa irisan.  GPU bekerja dengan cara sebaliknya.  Ada n prosesor yang benar-benar bekerja secara paralel, dan ada paralelisme antara proses dan paralelisme dalam GPU. <br><br>  Pekerjaan utama saya, selain hal-hal biasa seperti mengoptimalkan pekerjaan dengan memori dan mengatur kembali kode, adalah bahwa saya port algoritma yang ditulis untuk CPU ke kartu video sehingga mereka sejajar.  Ini tidak selalu merupakan tugas sepele, karena ada algoritma yang sangat efisien yang sepenuhnya terkait dengan pelaksanaan instruksi secara berurutan.  Pekerjaan saya adalah menghasilkan, misalnya, perkiraan untuk suatu algoritma yang mungkin, tidak persis sama, tetapi secara visual hasilnya tidak dapat dibedakan.  Sehingga kita bisa mendapatkan akselerasi 100 kali, sedikit mengorbankan kualitas. <br><br>  Saya juga porting neuron.  Ngomong-ngomong, kami akan segera membuat rilis Open Source utama.  Bahkan sebelum Core ML muncul, kami memiliki mitra kami sendiri, dan kami akhirnya matang untuk meletakkannya di Open Source.  Paradigmanya sedikit berbeda dari Core ML.  Saya, termasuk, sedang mengembangkan bagian intinya. <br><br>  Secara umum, saya melakukan segalanya di sekitar algoritma dan komputasi Vision Komputer. <br><br>  <b>Alexey Kudryavtsev:</b> Pengumuman yang menarik. <br><br>  <b>Andrey Volodin:</b> Ini bukan rahasia, kami tidak akan mengumumkannya dengan semacam keriuhan, hanya saja mungkin untuk melihat contoh kerangka kerja yang digunakan di dalam Prisma. <br><br><h2>  Mengapa mengoptimalkan untuk GPU </h2><br>  <b>Alexei Kudryavtsev:</b> Katakan, tolong, mengapa kita mengoptimalkan algoritma untuk GPU secara umum?  Tampaknya sudah cukup untuk menambahkan core ke prosesor atau mengoptimalkan algoritma.  Kenapa tepatnya GPU? <br><br>  <b>Andrey Volodin:</b> Bekerja pada GPU dapat mempercepat algoritme.  Misalnya, kami memiliki neuron yang akan berjalan pada prosesor pusat Samsung S10 selama 30 detik, dan pada GPU akan ada 1 frame, mis. 1/60 detik.  Ini sangat mengubah pengalaman pengguna.  Tidak ada layar pemuatan abadi, Anda dapat melihat hasil dari algoritma yang bekerja pada aliran video, atau memutar slider dan melihat efeknya di sana. <br><br><blockquote>  Sama sekali tidak terlalu keren untuk menulis di CPU, jadi kami menulis ulang semua yang ada di GPU.  Menggunakan GPU memiliki tujuan transparan - mempercepat segalanya. </blockquote><br>  <b>Alexei Kudryavtsev:</b> GPU menangani operasi yang mirip satu sama lain secara paralel.  Apakah Anda hanya memiliki operasi seperti itu dan karena itu berhasil mencapai kesuksesan seperti itu? <br><br>  <b>Andrey Volodin:</b> Ya, kesulitan utama bukan pada kode, tetapi untuk membuat algoritma yang ditransfer dengan baik ke GPU.  Ini tidak selalu sepele.  Kebetulan Anda tahu cara melakukan semuanya dengan keren, tetapi untuk ini Anda memerlukan terlalu banyak titik sinkronisasi.  Misalnya, Anda menulis semuanya dalam satu properti, dan ini adalah tanda yang jelas bahwa itu akan paralel dengan buruk.  Jika Anda menulis banyak di satu tempat, maka semua utas perlu disinkronkan untuk ini.  Tugas kami adalah untuk memperkirakan algoritma sehingga mereka sejajar dengan baik. <br><br>  <b>Alexei Kudryavtsev:</b> Bagi saya, sebagai pengembang seluler, kedengarannya seperti ilmu roket. <br><br>  <b>Andrey Volodin:</b> Sebenarnya, tidak begitu sulit.  Bagi saya, ilmu roket adalah VIPER. <br><br><h2>  Chip ketiga </h2><br>  <b>Daniil Popov:</b> Tampaknya pada konferensi Google I / O terakhir mereka mengumumkan sepotong besi untuk TensorFlow dan hal-hal lainnya.  Kapan chip ketiga akhirnya muncul di ponsel, TPU atau apa namanya, yang juga akan melakukan semua keajaiban ML pada perangkat? <br><br>  <b>Andrey Volodin:</b> Kami memiliki hal ini, terhubung melalui USB, dan Anda dapat mengarahkan neuron dari Google di dalamnya.  Huawei sudah memiliki ini, kami bahkan menulis perangkat lunak untuk akselerator heksagonal mereka, sehingga neuron segmentasi akan dengan cepat mengejar P20. <br><br>  Saya harus mengatakan bahwa di iPhone mereka sebenarnya sudah ada.  Sebagai contoh, di iPhone XS terbaru ada coprocessor yang disebut NPU (Neural Processing Unit), tetapi sejauh ini hanya Apple yang memiliki akses ke sana.  Coprocessor ini sudah memotong GPU di iPhone.  Beberapa model Core ML menggunakan NPU dan karenanya lebih cepat daripada bare Metal. <br><br>  Ini penting, mengingat bahwa selain neuron inferensi terendah, Core ML memerlukan banyak tindakan tambahan.  Pertama, Anda perlu mengonversi data input ke format Core ML, itu akan memprosesnya, lalu mengembalikannya dalam formatnya - Anda perlu mengonversinya kembali, dan baru kemudian menunjukkannya kepada pengguna.  Ini semua membutuhkan waktu.  Kami menulis saluran pipa bebas biaya overhead yang berfungsi dari awal hingga akhir pada GPU, sementara model Core ML lebih cepat justru karena proses perangkat keras ini. <br><br><blockquote>  Kemungkinan besar, di WWDC pada bulan Juni mereka akan menunjukkan kerangka kerja untuk bekerja dengan NPU. </blockquote><br>  Artinya, seperti yang Anda katakan, sudah ada perangkat, hanya pengembang yang belum bisa menggunakannya secara penuh.  Hipotesis saya adalah bahwa perusahaan itu sendiri belum memahami bagaimana melakukan ini dengan hati-hati dalam bentuk kerangka kerja.  Atau mereka hanya tidak ingin memberikan untuk mendapatkan keuntungan pasar. <br><br>  <b>Alexei Kudryavtsev:</b> Dengan pemindai sidik jari, hal yang sama ada di IPhone, seingat saya. <br><br>  <b>Andrey Volodin:</b> Dia bahkan tidak <b>semurah</b> itu sekarang.  Anda dapat menggunakannya tingkat atas, tetapi Anda tidak bisa mendapatkan hasil cetaknya sendiri.  Anda bisa meminta Apple untuk membiarkan pengguna menggunakannya.  Masih belum akses penuh ke pemindai itu sendiri. <br><br><h2>  Akselerator Heksagonal </h2><br>  <b>Daniil Popov:</b> Anda menyebutkan istilah akselerator heksagonal.  Saya pikir tidak semua orang tahu apa itu. <br><br>  <b>Andrey Volodin:</b> Ini hanya sepotong arsitektur perangkat keras yang digunakan Huawei.  Saya harus mengatakan, dia agak canggih.  Hanya sedikit orang yang tahu, tetapi di beberapa Huawei prosesor ini, tetapi tidak digunakan, karena mereka memiliki bug perangkat keras.  Huawei merilisnya, dan kemudian menemukan masalah, sekarang di beberapa ponsel chip khusus mati berat.  Dalam versi baru, semuanya sudah berfungsi. <br><br>  Dalam pemrograman, ada paradigma SIMD (Single Instruction, Multiple Data), ketika instruksi yang sama dijalankan secara paralel pada data yang berbeda.  Chip dirancang sedemikian rupa sehingga dapat memproses beberapa operasi secara paralel pada beberapa aliran data sekaligus.  Secara khusus, heksagonal berarti bahwa pada 6 elemen secara paralel. <br><br>  <b>Alexei Kudryavtsev:</b> Saya pikir GPU hanya berfungsi seperti ini: ini vectorizes tugas dan melakukan operasi yang sama pada data yang berbeda.  Apa bedanya? <br><br>  <b>Andrey Volodin</b> : GPU adalah tujuan yang lebih umum.  Terlepas dari kenyataan bahwa pemrograman untuk GPU adalah level yang agak rendah, sehubungan dengan bekerja dengan coprocessor, itu adalah level yang cukup tinggi.  Untuk pemrograman pada GPU, bahasa seperti C digunakan.  Di iOS, kode masih dikompilasi dengan LLVM ke dalam instruksi mesin.  Dan hal-hal ini untuk koprosesor paling sering ditulis langsung dengan hardcore - dalam assembler, berdasarkan instruksi mesin.  Oleh karena itu, ada peningkatan produktivitas yang jauh lebih terlihat, karena mereka dipertajam untuk operasi tertentu.  Anda tidak dapat mengandalkan mereka apa pun, tetapi Anda hanya dapat menghitung apa yang semula dimaksudkan untuk mereka. <br><br>  <b>Alexei Kudryavtsev:</b> Dan mengapa mereka biasanya dirancang? <br><br>  <b>Andrey Volodin:</b> Sekarang terutama untuk operasi yang paling umum dalam jaringan saraf: konvolusi - konvolusi atau semacam aktivasi perantara.  Mereka memiliki fungsi pra-kabel yang bekerja sangat cepat.  Jadi mereka jauh lebih cepat pada beberapa tugas daripada GPU, tetapi di semua sisanya mereka tidak berlaku. <br><br>  <b>Alexei Kudryavtsev:</b> Sepertinya prosesor DSP, yang dulu digunakan untuk audio, dan semua plugin dan efek bekerja dengan sangat cepat.  Perangkat keras mahal khusus dijual, tetapi kemudian prosesor tumbuh, dan sekarang kami merekam dan memproses podcast langsung di laptop. <br><br>  <b>Andrey Volodin:</b> Ya, hampir sama. <br><br><h2>  GPU tidak hanya untuk grafis </h2><br>  <b>Daniil Popov:</b> Saya mengerti benar bahwa sekarang pada GPU Anda dapat memproses data yang tidak terkait langsung dengan grafik?  Ternyata GPU kehilangan tujuan aslinya. <br><br>  <b>Andrey Volodin:</b> Tepat.  Saya sering membicarakan hal ini di konferensi.  Yang pertama adalah NVidia, yang memperkenalkan CUDA.  Ini adalah teknologi yang membuat GPGPU (Komputasi serba guna pada unit pemrosesan grafik) lebih sederhana.  Anda dapat menulis di atasnya sebuah superset dari algoritma C ++ yang diparalelkan pada GPU. <br><br>  Tetapi orang-orang telah melakukan ini sebelumnya.  Sebagai contoh, pengrajin di OpenGL atau bahkan pada DirectX yang lebih tua hanya menulis data ke tekstur - setiap piksel ditafsirkan sebagai data: 4 byte pertama di piksel pertama, 4 byte kedua di kedua.  Mereka mengolah tekstur, lalu kembali data dari tekstur diekstraksi dan diinterpretasikan.  Itu sangat kaku dan rumit.  Sekarang kartu video mendukung logika tujuan umum.  Anda dapat memberi makan buffer apa pun dalam GPU, menggambarkan struktur Anda, bahkan hierarki struktur di mana mereka akan merujuk satu sama lain, menghitung sesuatu dan mengembalikannya ke prosesor. <br><br>  <b>Daniil Popov:</b> Artinya, kita dapat mengatakan bahwa GPU sekarang adalah Data PU. <br><br>  <b>Andrey Volodin:</b> Ya, grafik pada GPU terkadang diproses kurang dari perhitungan umum. <br><br>  <b>Alexei Kudryavtsev:</b> Arsitektur CPU dan GPU pada dasarnya berbeda, tetapi Anda dapat mempertimbangkan keduanya di sana dan di sana. <br><br>  <b>Andrey Volodin</b> : Memang, dalam beberapa hal CPU lebih cepat, dalam beberapa hal GPU.  Ini bukan untuk mengatakan bahwa GPU selalu lebih cepat. <br><br>  <b>Daniil Popov:</b> Sejauh yang saya ingat, jika tugasnya menghitung sesuatu yang sangat berbeda, maka pada CPU bisa jauh lebih cepat. <br><br>  <b>Andrey Volodin: Itu juga</b> tergantung pada jumlah data.  Selalu ada overhead mentransfer data dari CPU ke GPU dan sebaliknya.  Jika Anda mempertimbangkan, misalnya, sejuta elemen, maka menggunakan GPU biasanya dibenarkan.  Tetapi menghitung seribu elemen pada CPU bisa lebih cepat daripada hanya menyalinnya ke kartu grafis.  Karena itu, Anda harus selalu memilih tugas. <br><br>  Omong-omong, Core ML yang melakukannya.  Core ML dapat runtime, menurut Apple, untuk memilih di mana lebih cepat untuk menghitung: pada prosesor atau pada kartu video.  Saya tidak tahu apakah ini bekerja dalam kenyataan, tetapi mereka mengatakan ya. <br><br><h2>  Pengetahuan Hardcore GPU Engineer untuk pengembang seluler </h2><br>  <b>Alexey Kudryavtsev:</b> Mari kita kembali ke pengembangan seluler.  Anda adalah Insinyur GPU, Anda memiliki banyak pengetahuan hardcore.  Bagaimana pengetahuan ini dapat diterapkan pada pengembang seluler?  Misalnya, apa yang Anda lihat di UIKit yang tidak dilihat orang lain? <br><br>  <b>Andrey Volodin:</b> Saya akan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membicarakan</a> ini secara terperinci di AppsConf.  Anda bisa menerapkan banyak hal di mana.  Ketika saya melihat, misalnya, bagaimana API UIKit bekerja, saya dapat segera memahami mengapa ini dilakukan dan mengapa.  Mengamati penurunan kinerja ketika memberikan beberapa tampilan, saya dapat memahami alasannya, karena saya tahu bagaimana rendering ditulis di dalamnya.  Saya mengerti: untuk menampilkan efek yang sebenarnya Gaussian blur lakukan di atas frame buffer, pertama-tama Anda perlu cache seluruh tekstur, menerapkan operasi blur berat untuk itu, mengembalikan hasilnya, menyelesaikan rendering sisa tampilan, dan hanya kemudian menampilkannya di layar.  Semua ini harus sesuai dalam 1/60 detik, jika tidak maka akan melambat. <br><br>  Sangat jelas bagi saya mengapa ini adalah waktu yang lama, tetapi bagi kolega saya ini tidak jelas.  Itulah mengapa saya ingin berbagi trik desain yang sering kita gunakan di GameDev, dan wawasan saya tentang bagaimana saya melihat masalah dan mencoba menyelesaikannya.  Ini akan menjadi eksperimen, tetapi saya pikir itu harus menarik. <br><br><h2>  Mengapa Android tidak memiliki blur asli </h2><br>  <b>Daniil Popov:</b> Anda menyebutkan blur, dan saya punya pertanyaan yang membuat saya khawatir, semua pengembang Android: mengapa ada bluer asli di iOS dan bukan di Android. <br><br>  <b>Andrei Volodin:</b> Saya pikir ini karena arsitektur.  Platform Apple menggunakan arsitektur rendering Tiled Shading.  Dengan pendekatan ini, bukan seluruh frame diberikan, tetapi ubin kecil - kotak, bagian layar.  Ini memungkinkan Anda untuk mengoptimalkan operasi algoritma, karena perolehan kinerja utama saat menggunakan GPU memberikan penggunaan cache yang efisien.  Di iOS, frame sering dirender sehingga tidak memakan memori sama sekali.  Misalnya, pada iPhone 7 Plus, resolusinya adalah 1920 * 1080, yaitu sekitar 2 juta piksel.  Kami kalikan dengan 4 byte per saluran, ternyata sekitar 20 megabyte per frame.  20 MB untuk hanya menyimpan buffer bingkai sistem. <br><br>  Pendekatan Tiled Shading memungkinkan Anda untuk memecah buffer ini menjadi potongan-potongan kecil dan membuatnya sedikit.  Ini sangat meningkatkan jumlah akses cache, karena untuk mengaburkan, Anda perlu membaca piksel yang sudah ditarik dan menghitung distribusi Gaussian pada mereka.  Jika Anda membaca seluruh frame, laju cache akan sangat rendah, karena setiap aliran akan membaca tempat yang berbeda.  Tetapi jika Anda membaca potongan-potongan kecil, maka tingkat cache akan sangat tinggi, dan produktivitas juga akan tinggi. <br><br>  Sepertinya saya bahwa kurangnya blur asli di Android terhubung dengan fitur arsitektur.  Meskipun, mungkin ini adalah solusi produk. <br><br>  <b>Daniil Popov:</b> Di Android, ada RenderScript untuk ini, tetapi di sana Anda perlu mencampur, menggambar, menanamkan dengan tangan Anda.  Ini jauh lebih rumit daripada mengatur satu kotak centang di iOS. <br><br>  <b>Andrey Volodin:</b> Kemungkinan besar, kinerja juga lebih rendah. <br><br>  <b>Daniil Popov:</b> Ya, untuk memuaskan Wishlist desainer, kita harus menurunkan skala gambar, membakarnya, dan kemudian meningkatkan kembali untuk menghemat. <br><br>  <b>Andrey Volodin:</b> Omong-omong, dengan ini Anda dapat melakukan berbagai trik.  Distribusi Gaussian adalah lingkaran kabur.  Gauss sigma tergantung pada jumlah piksel yang Anda ingin kumpulkan.  Seringkali, sebagai optimasi, Anda dapat menurunkan skala gambar dan sedikit mempersempit sigma, dan ketika Anda mengembalikan skala asli, tidak akan ada perbedaan, karena sigma secara langsung tergantung pada ukuran gambar.  Kami sering menggunakan trik ini di dalam untuk mempercepat blur. <br><br>  <b>Daniil Popov:</b> Namun, RenderScript di Android tidak memungkinkan Anda membuat radius lebih dari 30. <br><br>  <b>Andrey Volodin:</b> Sebenarnya, jari-jari 30 banyak.    ,  30     GPU     . <br><br><h2>      GameDev </h2><br> <b> :</b>       ,       GameDev  .  ,  ? <br><br> <b> :</b>  UIKit    ,  .     Entity Component System,      .  UIKit   ,  ,   ,      .     GameDev,  Component System    Thief  98 . <br><br> , , Cocos2d,      ,  ,     ,  .  ,    Scene graph —  ,      -,        ,    iOS  CGAffineTransform.    4*4,  ,    .     . <br><br>    ,   UIKit      .    -  —       .    :  GameDev     ,   UIKit  setNeedsLayout, layoutIfNeeded. <br><br>        —  ,   - ,   ,      Apple.      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AppsConf</a> . <br><br> <b> :</b> , API Cocos2d   iOS ( UI).  ,         ? <br><br> <b> :</b> ,  - . Cocos2d   2008-2009 ,  UIKit    UIKit,    .   ,  -    ,     ,     . <br><br> ,   :  core- Cocos2d    Apple,   Apple   Cocos2d,     . SpriteKit      ,    Cocos2d.    Apple   . <br><br> <b> :</b>  ,   ,   UIKit  2009,    MacOS,     .    setNeedsLayout, layoutIfNeeded ,  . <br><br> <b> :</b> ,  GameDev   ,  MacOS. <br><br> <b> :</b>  ! <br><br> <b> :</b>     Cocos2d   Apple,      ,    GameDev.   GameDev   ,   —  .     ,  GameDev   ,    ,   .  ,  ,     . <br><br> <b> :</b> ,    - ,   —  . <br><br> <b> </b> : ,   , ,       ,   —  .    Protocol-Oriented Programming  Swift, ,    - .  GameDev      . <br><br> <b> :</b>  :     ,   .  ,    ,    ,     . <br><br><h2>     GameDev </h2><br> <b> :</b>    :  GameDev     ,    GameDev    ? <br><br> <b> :</b>  ,    ,     .       «  ,  ».    ,     .      :    ,    ,  . <br><br> GameDev-    .     : 30  60        ,  ,   ,    .   ,      .      —       .  --   1/60  1/30 .   ,     , ,  GPU  ,   CPU .        ,    . <br><br> <b> :</b>         ? <br><br> <b> :</b>    . -       , , ,         .     —   .     , , ,  —  - ,  - ,  .      ,      ,      . <br><br>      . , GPU     float,    double, -    . , ,     ,    .  CPU  ,        ,       ,   GPU     . <br><br>      ,      ,    —     . <br><br><h2>      GameDev,    </h2><br> <b> :</b>        ,  «     GameDev,   ».     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>    ,     ,   .     ,  GameDev —      .        ,  .      GameDev. <br><br> <b> :</b> , enterprise-   ,    GameDev    .      .   ,     ,    GameDev,     . <br><br> ,  .    ,      4*4.  CGAffineTransform —    ,   -        ,   . <br><br><blockquote>        ,     ,   ,  ,    . </blockquote><br><h2>    </h2><br> <b> :</b>       ?  ,       UIKit,     ,     ?  ,   ,       ,   .   ,     ? <br><br> <b> :</b>    —   pet project. <br><br> ,      :    GPU     ,     . iOS GPU      ,     .    iOS     ,     -  NVidia  AMD-   .    . API  ,   ,         . <br><br> <b> :</b>   API, ,   Cocos2d  Unity,      —   - .    ,    ,   ,   UIKit    ? <br><br> <b> :</b> Cocos2d — Open Source    .    ,      ,   ,     ,     .       objective-C,        . <br><br>      pet project,          ,   ,   API,  , , -. ,   API,   VHS-.    ,   GPU.    ,     .     ,      .      ,   : «     saturation  Instagram,   lightroom!» ,   ,   4      —  . <br><br><blockquote>     ,   . </blockquote><br>         — ,   , .     ,      ,    -  ,   ,      ,   . <br><br> <b> :</b>    ,   -  . ,  Cocos2d -  —  5  ,       ,    ,    ,   . ,       ,   ,    .. <br><br> <b> :</b>   .       ,   .   ,         ,          ,        ,        ,    , , ,    ,     . <br><br> <b> :</b>     ,       . ,     ,    . <br><br> <b> :</b>     .    ,  ,       .       ,      Apple,   ARKit.       ,       ,    .    ,     ,        ,     ,   . <br><br> ,            ,  : «,      IDE, ,   ,     ,   .        ». <br><br> <b> :</b>   —  ? <br><br> <b> :</b> , ,    ,      . <br><br> <b> :</b>   ,   ,       . <br><br> <b> :</b> ,      ,   ,  VR   .    Project Template  Xcode,    ,   , - .    ,       . <br><br> <b> :</b>       . <br><br><h2>  </h2><br> <b> :</b>  -  ,      GameDev  GPU. <br><br> <b> :</b>    .   - ,      ,   ,  .   ,         ,   ,   ,  ,      UI: ,  , runtime Objective-C —  ,    ,     .     .      ,     : ,  — , X  Y, ! <br><br><blockquote>    ,  ,  - ,  GameDev  GPU- —   . </blockquote><br> <b>        ,   .          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AppsConf</a> 22  23     .</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448222/">https://habr.com/ru/post/id448222/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448212/index.html">Protokol AIBUS Cina dan reaktor kimia laboratorium</a></li>
<li><a href="../id448214/index.html">ES6 Proxy dalam praktiknya</a></li>
<li><a href="../id448216/index.html">Menyiapkan perakitan proyek yang nyaman di Visual Studio</a></li>
<li><a href="../id448218/index.html">Keamanan MFP Baru: imageRUNNER ADVANCE III</a></li>
<li><a href="../id448220/index.html">Dasar-dasar format GLTF dan GLB, bagian 1</a></li>
<li><a href="../id448224/index.html">AppsConf untuk mengatur semuanya</a></li>
<li><a href="../id448226/index.html">Mencari yang sangat (topik laporan untuk AppsConf)</a></li>
<li><a href="../id448228/index.html">Jenis-jenis pemodelan. Dasar-dasar Sculpting, Retopology, dan Sweep</a></li>
<li><a href="../id448230/index.html">Mengelola Kontinuitas Bisnis dengan ClearView</a></li>
<li><a href="../id448234/index.html">AI dan MO: beberapa tren dan tren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>