<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎃 👨‍👩‍👧 🤞🏿 Cara membuat game bekerja pada 60fps 👩‍❤️‍👨 ♂️ 👨🏿‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bayangkan masalahnya: Anda memiliki gim, dan Anda membutuhkannya untuk bekerja pada 60 fps pada monitor 60 Hz. Komputer Anda cukup cepat untuk renderi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara membuat game bekerja pada 60fps</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442528/">  Bayangkan masalahnya: Anda memiliki gim, dan Anda membutuhkannya untuk bekerja pada 60 fps pada monitor 60 Hz.  Komputer Anda cukup cepat untuk rendering dan pembaruan untuk mengambil jumlah waktu yang tidak signifikan, sehingga Anda menyalakan vsync dan menulis loop game ini: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running) { update(); render(); display(); }</code> </pre> <br>  Sangat mudah!  Sekarang gim ini bekerja pada 60fps dan semuanya berjalan seperti jarum jam.  Selesai  Terima kasih telah membaca posting ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ae/57e/bf1/0ae57ebf1f1695e4ecbcafddcb4255bb.jpg"></div><br>  Yah, jelas, semuanya tidak begitu baik.  Bagaimana jika seseorang memiliki komputer yang lemah yang tidak dapat membuat game dengan kecepatan yang cukup untuk menyediakan 60fps?  Bagaimana jika seseorang membeli salah satu dari 144 monitor hertz baru yang keren itu?  Bagaimana jika dia mematikan vsync di pengaturan driver? <br><a name="habracut"></a><br>  Anda mungkin berpikir: Saya perlu mengukur waktu di suatu tempat dan memberikan pembaruan dengan frekuensi yang benar.  Ini cukup sederhana - cukup kumpulkan waktu di setiap siklus dan perbarui setiap kali melebihi ambang batas dengan 1/60 detik. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running) { deltaTime = CurrentTime()-OldTime; oldTime = CurrentTime(); accumulator += deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>){ update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; } render(); display(); }</code> </pre> <br>  Selesai, tidak ada tempat yang lebih mudah.  Bahkan, ada banyak permainan di mana kode dasarnya terlihat seperti itu.  Tapi ini salah.  Ini cocok untuk mengatur timing, tetapi menyebabkan masalah dengan menyentak (gagap) dan ketidakcocokan lainnya.  Masalah seperti itu sangat umum: frame tidak ditampilkan tepat 1/60 detik;  bahkan ketika vsync dihidupkan, selalu ada sedikit noise pada saat mereka ditampilkan (dan dalam keakuratan pengatur waktu OS).  Oleh karena itu, akan ada situasi ketika Anda membuat bingkai, dan permainan percaya bahwa waktu untuk memperbarui kembali belum tiba (karena baterai tertinggal sebagian kecil), jadi itu hanya mengulangi frame yang sama lagi, tetapi sekarang permainan sudah terlambat untuk bingkai, sehingga gandakan pembaruan.  Ini berkedut! <br><br>  Googling, Anda dapat menemukan beberapa solusi siap pakai untuk menghilangkan kedutan ini.  Misalnya, gim dapat menggunakan variabel daripada langkah waktu yang konstan, dan cukup meninggalkan baterai dalam kode pewaktuan.  Atau Anda dapat menerapkan langkah waktu konstan dengan penyaji interpolasi, dijelaskan dalam artikel yang agak terkenal " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow noopener">Perbaiki Waktu Anda</a> " oleh Glenn Fielder.  Atau Anda dapat membuat kembali kode pengatur waktu sehingga sedikit lebih fleksibel, seperti yang dijelaskan dalam posting <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://web.archive.org/web/20171206005813/" rel="nofollow noopener">Frame Timing Issues</a> Slick Entertainment (sayangnya blog ini sudah tidak ada lagi). <br><br><hr><br><h3>  Pengaturan waktu yang kabur </h3><br>  Metode Slick Entertainment dengan "timing fuzzy" di mesin saya adalah yang paling mudah diterapkan, karena tidak memerlukan perubahan dalam logika dan rendering game.  Jadi pada akhirnya aku sudah menggunakannya.  Sudah cukup hanya dengan memasukkannya ke mesin.  Bahkan, itu hanya memungkinkan game untuk diperbarui "sedikit lebih awal" untuk menghindari masalah dengan ketidakcocokan waktu.  Jika game menyertakan vsync, maka itu hanya memungkinkan Anda untuk menggunakan vsync sebagai timer utama gim, dan memberikan gambar yang halus. <br><br>  Beginilah tampilan kode pembaruan sekarang (permainan “dapat bekerja” pada 62 fps, tetapi masih memproses setiap langkah waktu seolah-olah bekerja pada 60fps. Saya tidak mengerti mengapa harus membatasi sehingga nilai baterai tidak turun di bawah 0, tetapi tanpa kode ini tidak berfungsi).  Anda dapat menafsirkannya dengan cara ini: "permainan diperbarui dengan langkah tetap, jika diberikan dalam interval dari 60fps hingga 62fps": <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">62.0</span></span>){ update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(accumulator &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) accumulator = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Jika vsync diaktifkan, itu pada dasarnya memungkinkan game untuk bekerja dengan nada tetap, yang cocok dengan kecepatan refresh monitor, dan memberikan gambar yang halus.  Masalah utama di sini adalah ketika vsync dinonaktifkan, gim akan bekerja <i>sedikit</i> lebih cepat, tetapi perbedaannya sangat kecil sehingga tidak ada yang akan memperhatikannya. <br><br>  Pelari kecepatan.  Speedrunners akan melihat.  Tak lama setelah permainan dirilis, mereka memperhatikan bahwa beberapa orang di daftar speedscore speedran memiliki waktu tempuh yang lebih buruk, tetapi ternyata lebih baik daripada yang lain.  Dan alasan langsung untuk ini adalah timing yang tidak jelas dan terputusnya vsync dalam game (atau 144 Hz monitor).  Oleh karena itu, menjadi jelas bahwa Anda perlu mematikan kekaburan ini saat melepas vsync. <br><br>  Oh, tapi kami masih tidak dapat memeriksa apakah vsync dinonaktifkan.  Tidak ada panggilan untuk ini di OS, dan meskipun kami dapat meminta dari aplikasi untuk mengaktifkan atau menonaktifkan vsync, sebenarnya itu sepenuhnya tergantung pada OS dan driver grafis.  Satu-satunya hal yang dapat dilakukan adalah merender banyak frame, mencoba mengukur waktu pelaksanaan tugas ini, dan kemudian membandingkan apakah mereka membutuhkan waktu yang sama.  Itulah tepatnya yang saya lakukan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow noopener">The End</a> .  Jika gim ini tidak menyertakan vsync dengan frekuensi 60 Hz, maka gulir kembali ke timer frame asli dengan "fps ketat 60".  Selain itu, saya menambahkan parameter ke file konfigurasi yang memaksa game untuk tidak menggunakan ketidakjelasan (terutama untuk pelari kecepatan yang membutuhkan waktu yang akurat) dan menambahkan pengatur waktu dalam permainan yang tepat untuk mereka, yang memungkinkan menggunakan autosplitter (ini adalah skrip yang bekerja dengan timer waktu atom). <br><br>  Beberapa pengguna masih mengeluh tentang sesekali menyentak frame individu, tetapi mereka tampak sangat langka sehingga mereka dapat dijelaskan oleh peristiwa OS atau alasan eksternal lainnya.  Bukan masalah besar.  Benar? <br><br>  Melihat-lihat kode timer saya baru-baru ini, saya melihat sesuatu yang aneh.  Baterai diganti, setiap frame membutuhkan waktu sedikit lebih lama dari 1/60 detik, jadi dari waktu ke waktu permainan berpikir sudah terlambat untuk frame, dan melakukan pembaruan ganda.  Ternyata monitor saya bekerja dengan frekuensi 59,94 Hz, dan bukan 60 Hz.  Ini berarti bahwa setiap 1000 frame ia harus melakukan pembaruan ganda untuk "mengejar ketinggalan".  Namun, ini sangat mudah untuk diperbaiki - cukup ubah interval frekuensi bingkai yang diizinkan (bukan dari 60 menjadi 62, tetapi dari 59 menjadi 61). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">61.0</span></span>){ update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">59.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(accumulator &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) accumulator = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Masalah yang dijelaskan di atas dengan monitor vsync terputus dan frekuensi tinggi masih berlanjut, dan solusi yang sama berlaku untuk itu (kembalikan ke timer ketat jika monitor <i>tidak</i> disinkronkan vsync oleh 60). <br><br>  Tetapi bagaimana Anda tahu jika ini adalah solusi yang tepat?  Bagaimana memastikan bahwa itu akan bekerja dengan benar pada semua kombinasi komputer dengan berbagai jenis monitor, dengan dan tanpa vsync dihidupkan, dan seterusnya?  Sangat sulit untuk melacak semua masalah timer ini di kepala, dan untuk memahami apa yang menyebabkan desync, loop aneh dan sejenisnya. <br><br><h3>  Monitor simulator </h3><br>  Mencoba menemukan solusi yang dapat diandalkan untuk "masalah monitor hertz 59,94", saya menyadari bahwa saya tidak bisa hanya melakukan pemeriksaan coba-coba, berharap menemukan solusi yang dapat diandalkan.  Saya membutuhkan cara yang mudah untuk menguji berbagai upaya untuk menulis timer berkualitas tinggi dan cara mudah untuk memeriksa apakah itu menyebabkan sentakan atau pergeseran waktu dalam konfigurasi monitor yang berbeda. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow noopener">Monitor Simulator</a> muncul di tempat kejadian.  Ini adalah kode "kotor dan cepat" yang saya tulis, mensimulasikan "operasi monitor", dan pada dasarnya menunjukkan kepada saya banyak angka yang memberikan gambaran stabilitas setiap timer yang diuji. <br><br>  Misalnya, untuk penghitung waktu paling sederhana, nilai-nilai berikut ini ditampilkan dari awal artikel: <br><br> <code>20211012021011202111020211102012012102012[...] <br> TOTAL UPDATES: 10001 <br> TOTAL VSYNCS: 10002 <br> TOTAL DOUBLE UPDATES: 2535 <br> TOTAL SKIPPED RENDERS: 0 <br> GAME TIME: 166.683 <br> SYSTEM TIME: 166.7</code> <br> <br>  Pertama, kode menampilkan untuk setiap vsync yang ditiru jumlah jumlah "pembaruan" ke siklus permainan setelah vsync sebelumnya.  Nilai apa pun selain solid 1 mengarah ke gambar gugup.  Pada akhirnya, kode menampilkan statistik akumulasi. <br><br>  Saat menggunakan "fuzzy timer" (dengan interval 60-62fps) pada monitor 59,94-Hertz, kode ini menampilkan yang berikut: <br><br> <code>111111111111111111111111111111111111111111111[...] <br> TOTAL UPDATES: 10000 <br> TOTAL VSYNCS: 9991 <br> TOTAL DOUBLE UPDATES: 10 <br> TOTAL SKIPPED RENDERS: 0 <br> GAME TIME: 166.667 <br> SYSTEM TIME: 166.683</code> <br> <br>  Menyentak frame sangat jarang, sehingga bisa sulit untuk melihat dengan sejumlah 1. Tapi statistik yang ditampilkan jelas menunjukkan bahwa permainan telah melakukan beberapa pembaruan ganda di sini, yang mengarah pada menyentak.  Dalam versi tetap (dengan interval 59-61 fps), ada 0 pembaruan dilewati atau dua kali lipat. <br><br>  Anda juga dapat menonaktifkan vsync.  Sisa data statistik menjadi tidak penting, tetapi ini dengan jelas menunjukkan kepada saya besarnya "pergeseran waktu" (waktu sistem bergeser relatif ke tempat waktu permainan seharusnya). <br><br> <code>GAME TIME: 166.667 <br> SYSTEM TIME: 169.102</code> <br> <br>  Itulah sebabnya ketika vsync dinonaktifkan, Anda harus beralih ke penghitung waktu yang ketat, jika tidak, perbedaan ini menumpuk dari waktu ke waktu. <br><br>  Jika saya mengatur waktu rendering ke 0,02 (yaitu, "lebih dari satu frame" diperlukan untuk rendering), maka saya akan mendapatkan kedutan.  Idealnya, pola permainan harus seperti 202020202020, tetapi agak tidak merata. <br><br>  Dalam situasi ini, timer ini berperilaku sedikit lebih baik dari yang sebelumnya, tetapi menjadi lebih membingungkan dan lebih sulit untuk mengetahui bagaimana dan mengapa ia bekerja.  Tapi saya hanya bisa memasukkan tes ke dalam simulator ini dan memeriksa bagaimana mereka berperilaku, dan Anda bisa mengetahui alasannya nanti.  Trial and error, sayang! <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt;= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">61.0</span></span>){ simulate_update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(accumulator &lt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">59.0</span></span>–<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>) accumulator = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Anda dapat mengunduh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow noopener">simulator monitor</a> dan secara independen memeriksa berbagai metode penghitungan waktu.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow noopener">Email saya</a> jika Anda menemukan sesuatu yang lebih baik. <br><br>  Saya tidak 100% puas dengan keputusan saya (masih membutuhkan peretasan dengan "vsync recognition" dan sesekali menyentak dapat terjadi selama desinkronisasi), tetapi saya percaya bahwa itu hampir sama baiknya dengan upaya untuk mengimplementasikan siklus permainan dengan langkah yang tetap.  Sebagian dari masalah ini muncul karena sangat sulit untuk menentukan parameter dari apa yang dianggap “dapat diterima” di sini.  Kesulitan utama terletak pada tradeoff antara time shift dan double / skipping frames.  Jika Anda menjalankan game 60 Hz pada monitor 50 Hz PAL ... lalu apa keputusan yang tepat?  Apakah Anda ingin menyentak liar, atau bermain game terasa lebih lambat?  Kedua opsi itu tampak buruk. <br><br><h3>  Render terpisah </h3><br>  Dalam metode sebelumnya, saya menggambarkan apa yang saya sebut "rendststep rendering".  Gim memperbarui statusnya, lalu merender, dan saat merender, gim ini selalu menampilkan kondisi gim terbaru.  Rendering dan pembaruan terhubung bersama. <br><br>  Tetapi Anda dapat memisahkan mereka.  Inilah yang metode yang dijelaskan dalam pos " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow noopener">Perbaiki Your Timestep</a> " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow noopener">tidak</a> .  Saya tidak akan mengulangi lagi, Anda pasti harus membaca posting ini.  Ini (seperti yang saya mengerti) adalah "standar industri" yang digunakan dalam game AAA dan mesin seperti Unity dan Unreal (namun, dalam game 2D aktif yang intens, mereka biasanya lebih suka menggunakan langkah tetap (lockstep), karena terkadang akurasi yang memberi Anda metode ini). <br><br>  Tetapi jika kita menjelaskan secara singkat posting Glenn, itu hanya menjelaskan metode pembaruan dengan frame rate yang tetap, tetapi ketika rendering, interpolasi dilakukan antara keadaan "saat ini" dan "sebelumnya" dari permainan, dan nilai baterai saat ini digunakan sebagai nilai interpolasi.  Dengan metode ini, Anda dapat merender dalam frame rate apa pun dan memperbarui game pada frekuensi berapa pun, dan gambar akan selalu mulus.  Tidak menyentak, bekerja secara universal. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running){ computeDeltaTimeSomehow(); accumulator += deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt;= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>){ previous_state = current_state; current_state = update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; } render_interpolated_somehow(previous_state, current_state, accumulator/(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>)); display(); }</code> </pre> <br>  Jadi, dasar.  Masalahnya teratasi. <br><br>  Sekarang Anda hanya perlu memastikan bahwa permainan dapat membuat status yang diinterpolasi ... tapi tunggu sebentar, itu benar-benar tidak mudah sama sekali.  Dalam posting Glenn, hanya diasumsikan bahwa ini bisa dilakukan.  Cukup mudah untuk men-cache posisi sebelumnya dari objek game dan melakukan interpolasi gerakannya, tetapi status game jauh lebih dari itu.  Perlu untuk mempertimbangkan di dalamnya keadaan animasi, penciptaan dan penghancuran objek, dan banyak hal. <br><br>  Plus, dalam logika permainan, Anda perlu mempertimbangkan apakah objek tersebut diteleportasi atau jika perlu dipindahkan dengan lancar sehingga interpolator tidak membuat asumsi yang salah tentang jalur yang dibuat oleh objek game ke posisi saat ini.  Kekacauan nyata dapat terjadi dengan belokan, terutama jika dalam satu bingkai pergantian objek dapat berubah lebih dari 180 derajat.  Dan bagaimana cara memproses objek yang dibuat dan dihancurkan dengan benar? <br><br>  Saat ini, saya hanya mengerjakan tugas ini di mesin saya.  Faktanya, saya hanya menginterpolasi gerakannya, dan membiarkan yang lainnya apa adanya.  Anda tidak akan melihat menyentak jika objek tidak bergerak dengan lancar, sehingga melewatkan bingkai animasi dan menyinkronkan pembuatan / penghancuran objek hingga satu bingkai tidak akan menjadi masalah jika semuanya dilakukan dengan lancar. <br><br>  Namun, aneh bahwa, pada kenyataannya, metode ini membuat permainan dalam keadaan yang terlambat oleh 1 keadaan permainan dari tempat simulasi sekarang berada.  Ini tidak mencolok, tetapi dapat dihubungkan ke sumber keterlambatan lain, misalnya, keterlambatan input dan monitor kecepatan refresh, sehingga mereka yang membutuhkan gameplay paling responsif (saya berbicara tentang Anda, pelari kecepatan) kemungkinan besar akan lebih suka menggunakan penguncian dalam permainan. <br><br>  Di mesin saya, saya hanya memberi pilihan.  Jika Anda memiliki monitor 60 hertz dan komputer yang cepat, yang terbaik adalah menggunakan lockstep dengan mengaktifkan vsync.  Jika monitor memiliki kecepatan refresh yang tidak standar, atau komputer Anda yang lemah tidak dapat membuat 60 frame per detik secara konstan, maka aktifkan interpolasi frame.  Saya ingin menyebut opsi ini "membuka framerate", tetapi orang mungkin berpikir bahwa itu berarti "aktifkan opsi ini jika Anda memiliki komputer yang bagus."  Namun, masalah ini bisa diselesaikan nanti. <br><br>  Sebenarnya, ada metode untuk mengatasi masalah ini. <br><br><h3>  Pembaruan langkah waktu variabel </h3><br>  Banyak orang bertanya kepada saya mengapa tidak hanya memperbarui game dengan langkah waktu variabel, dan programmer teoritis sering mengatakan: "jika game ditulis dengan BENAR, maka Anda dapat memperbaruinya dengan langkah waktu sewenang-wenang". <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running) { deltaTime = CurrentTime()-OldTime; oldTime = CurrentTime(); update(deltaTime); render(); display(); }</code> </pre> <br>  Tidak ada keanehan dengan pengaturan waktu.  Tidak ada rendering interpolasi yang aneh.  Semuanya sederhana, semuanya berfungsi. <br><br>  Jadi, dasar.  Masalahnya teratasi.  Dan sekarang selamanya!  Tidak mungkin mencapai hasil yang lebih baik! <br><br>  Sekarang cukup sederhana untuk membuat logika game berfungsi dengan langkah waktu sewenang-wenang.  Sederhana, ganti saja semua kode ini: <br><br><pre> <code class="cpp hljs">position += speed;</code> </pre> <br>  tentang ini: <br><br><pre> <code class="cpp hljs">position += speed * deltaTime;</code> </pre> <br>  dan ganti kode berikut: <br><br><pre> <code class="cpp hljs">speed += acceleration; position += speed;</code> </pre> <br>  tentang ini: <br><br><pre> <code class="cpp hljs">speed += acceleration * deltaTime; position += speed * deltaTime;</code> </pre> <br>  dan ganti kode berikut: <br><br><pre> <code class="cpp hljs">speed += acceleration; speed *= friction; position += speed;</code> </pre> <br>  tentang ini: <br><br><pre> <code class="cpp hljs">Vec3D p0 = position; Vec3D v0 = velocity; Vec3D a = acceleration*(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> f = friction; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> n = dt*<span class="hljs-number"><span class="hljs-number">60</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> fN = <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(friction, n); position = p0 + ((f*(a*(f*fN-f*(n+<span class="hljs-number"><span class="hljs-number">1</span></span>)+n)+(f<span class="hljs-number"><span class="hljs-number">-1</span></span>)*v0*(fN<span class="hljs-number"><span class="hljs-number">-1</span></span>)))/((f<span class="hljs-number"><span class="hljs-number">-1</span></span>)*(f<span class="hljs-number"><span class="hljs-number">-1</span></span>)))*(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>); velocity = v0*fN+a*(f*(fN<span class="hljs-number"><span class="hljs-number">-1</span></span>)/(f<span class="hljs-number"><span class="hljs-number">-1</span></span>));</code> </pre> <br>  ... jadi, tunggu <br><br>  Dari mana semua ini berasal? <br><br>  Bagian terakhir secara harfiah disalin dari kode bantu mesin saya, yang melakukan "gerakan frame rate-independent yang benar, dengan kecepatan membatasi gesekan".  Ada sedikit sampah di dalamnya (perkalian dan pembagian ini dengan 60).  Tetapi ini adalah versi kode yang “benar” dengan langkah waktu variabel untuk fragmen sebelumnya.  Saya menemukan jawabannya selama lebih dari satu jam dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow noopener">Wolfram Alpha</a> . <br><br>  Sekarang mereka mungkin bertanya kepada saya mengapa tidak melakukannya seperti ini: <br><br><pre> <code class="cpp hljs">speed += acceleration * deltaTime; speed *= <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(friction, deltaTime); position += speed * deltaTime;</code> </pre> <br>  Dan meskipun tampaknya berhasil, sebenarnya itu salah.  Anda bisa memeriksanya sendiri.  Lakukan dua pembaruan dengan deltaTime = 1, dan kemudian lakukan satu pembaruan dengan deltaTime = 2, dan hasilnya akan berbeda.  Biasanya kami berusaha agar gim bekerja dalam konser, sehingga perbedaan seperti itu tidak diterima.  Ini mungkin solusi yang cukup baik, jika Anda tahu pasti bahwa deltaTime selalu kira-kira sama dengan satu nilai, tetapi kemudian Anda perlu menulis kode untuk memastikan bahwa pembaruan dilakukan pada frekuensi yang konstan dan ... ya.  Itu benar, sekarang kami mencoba melakukan segalanya "DENGAN BENAR." <br><br>  Jika sepotong kecil kode terungkap menjadi perhitungan matematika yang mengerikan, maka bayangkan pola gerakan yang lebih kompleks di mana banyak objek yang berinteraksi berpartisipasi, dan sejenisnya.  Sekarang Anda dapat dengan jelas melihat bahwa solusi "benar" tidak dapat direalisasikan.  Maksimum yang bisa kita capai adalah "perkiraan kasar".  Mari kita lupakan untuk saat ini, dan misalkan kita benar-benar memiliki versi fungsi gerak yang “benar-benar benar”.  Bagus kan? <br><br>  Tidak, sebenarnya.  Ini adalah contoh nyata dari masalah yang saya alami dengan ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow noopener">Bombernauts</a> .  Seorang pemain dapat bangkit sekitar 1 ubin, dan permainan berlangsung dalam kotak blok dalam 1 ubin.  Untuk mendarat di blok, kaki karakter harus naik di atas permukaan atas blok. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/956/eff/806/956eff806c65598bd694f6bc81713c1c.png"></div><br>  Tetapi karena pengenalan tabrakan di sini dilakukan dengan langkah diskrit, maka jika permainan bekerja dengan frame rate yang rendah, kadang-kadang kaki tidak akan mencapai permukaan ubin, meskipun mereka mengikuti kurva gerakan yang sama, dan bukannya mengangkat pemain akan meluncur turun dari dinding. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ad/ab7/cfc/5adab7cfc0abca780385cb3da53d63e5.png"></div><br>  Jelas, masalah ini bisa dipecahkan.  Tapi itu menggambarkan jenis masalah yang kita temui ketika mencoba untuk mengimplementasikan pekerjaan siklus permainan dengan benar dengan langkah waktu variabel.  Kami kehilangan koherensi dan determinisme, jadi kami harus menyingkirkan fungsi replay game dengan merekam input pemain, multipemain deterministik, dan sejenisnya.  Untuk game 2D cepat berbasis refleks, konsistensi sangat penting (dan sapa lagi untuk pelari cepat). <br><br>  Jika Anda mencoba menyesuaikan langkah waktu sehingga tidak terlalu besar atau terlalu kecil, maka Anda akan kehilangan keuntungan utama yang diperoleh dari langkah waktu variabel, dan Anda dapat dengan aman menggunakan dua metode lain yang dijelaskan di sini.  Permainan ini tidak sebanding dengan lilin.  Terlalu banyak upaya ekstra akan dimasukkan ke dalam logika permainan (implementasi matematika gerak yang benar), dan terlalu banyak korban akan diperlukan di bidang determinisme dan konsistensi.  Saya akan menggunakan metode ini hanya untuk permainan ritme musik (di mana persamaan geraknya sederhana dan membutuhkan responsif dan kehalusan maksimum).  Dalam semua kasus lain, saya akan memilih pembaruan tetap. <br><br><hr><br><h3>  Kesimpulan </h3><br>  Sekarang Anda tahu cara membuat gim bekerja pada frekuensi konstan 60fps.  Ini sangat sederhana, dan tidak ada orang lain yang memiliki masalah dengannya.  Tidak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ada masalah lain yang</a> menyulitkan tugas ini. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id442528/">https://habr.com/ru/post/id442528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id442518/index.html">10 Teknik Peretasan Web Terbaik 2018</a></li>
<li><a href="../id442520/index.html">Kasing. Hemat 300 000 p. per bulan pada iklan kontekstual</a></li>
<li><a href="../id442522/index.html">Intuitive RL (Reinforcement Learning): Pengantar Advantage-Actor-Critic (A2C)</a></li>
<li><a href="../id442524/index.html">Cara meningkatkan keamanan dalam identifikasi pribadi dan sistem kontrol akses</a></li>
<li><a href="../id442526/index.html">Sejarah pemutar kaset Soviet (bagian dua): booming Walkmen, gadget untuk KGB dan tape recorder</a></li>
<li><a href="../id442530/index.html">Wireshark 3.0.0: ulasan inovasi</a></li>
<li><a href="../id442532/index.html">Perekam video untuk pengawasan video - gratis</a></li>
<li><a href="../id442534/index.html">Ulasan Sprint: Shitty to Great</a></li>
<li><a href="../id442536/index.html">Menghubungkan kotak surat eksternal ke Zimbra</a></li>
<li><a href="../id442542/index.html">SmartMail Conf: Konferensi Mail Learning Mesin Mail.ru Pertama</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>