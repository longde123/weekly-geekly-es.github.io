<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üß† üö≠ üë∏üèª Java 9-Tutorial f√ºr diejenigen, die mit Legacy-Code arbeiten m√ºssen üìô üõ¥ üòñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Abend, Kollegen. Vor genau einem Monat haben wir von Manning einen Auftrag f√ºr die √úbersetzung von Modern Java erhalten , der n√§chstes Jahr eine...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Java 9-Tutorial f√ºr diejenigen, die mit Legacy-Code arbeiten m√ºssen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/417733/"> Guten Abend, Kollegen.  Vor genau einem Monat haben wir von Manning einen Auftrag f√ºr die √úbersetzung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Modern Java erhalten</a> , der n√§chstes Jahr eines unserer bemerkenswertesten neuen Produkte sein soll.  Das Problem von "Modern" und "Legacy" in Java ist so akut, dass die Notwendigkeit eines solchen Buches ziemlich reif ist.  Das Ausma√ü der Katastrophe und die L√∂sung von Problemen in Java 9 werden in einem Artikel von Wayne Citrin kurz beschrieben, dessen √úbersetzung wir Ihnen heute anbieten m√∂chten. <br><a name="habracut"></a><br>  Alle paar Jahre, mit der Ver√∂ffentlichung einer neuen Version von Java, beginnen die Sprecher von JavaOne, neue Sprachkonstrukte und APIs zu genie√üen und ihre Tugenden zu loben.  Und eifrige Entwickler sind inzwischen bestrebt, neue Funktionen einzuf√ºhren.  Ein solches Bild ist weit von der Realit√§t entfernt - es ber√ºcksichtigt nicht, dass die meisten Programmierer damit besch√§ftigt sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, vorhandene Anwendungen</a> zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unterst√ºtzen und zu finalisieren</a> , und schreibt keine neuen Anwendungen von Grund auf neu. <br><br>  Die meisten Anwendungen - insbesondere kommerzielle - m√ºssen abw√§rtskompatibel mit fr√ºheren Java-Versionen sein, die nicht alle diese neuen Super-Duper-Funktionen unterst√ºtzen.  Schlie√ülich sind die meisten Kunden und Endbenutzer, insbesondere im Gro√üunternehmenssegment, besorgt √ºber ein radikales Upgrade der Java-Plattform und warten lieber, bis sie st√§rker wird. <br><br>  Sobald der Entwickler eine neue Gelegenheit ausprobiert, ist er daher mit Problemen konfrontiert.  W√ºrden Sie die Standardschnittstellenmethoden in Ihrem Code verwenden?  Vielleicht - wenn Sie Gl√ºck haben und Ihre Anwendung nicht mit Java 7 oder niedriger interagieren muss.  <code>java.util.concurrent.ThreadLocalRandom</code> Klasse <code>java.util.concurrent.ThreadLocalRandom</code> , um Pseudozufallszahlen in einer Multithread-Anwendung zu generieren?  Es funktioniert nicht, wenn Ihre Anwendung gleichzeitig auf Java 6, 7, 8 oder 9 ausgef√ºhrt werden soll. <br><br>  Mit der Ver√∂ffentlichung der neuen Version f√ºhlen sich Entwickler, die Legacy-Code unterst√ºtzen, wie Kinder gezwungen, auf ein Fenster einer Konditorei zu starren.  Sie d√ºrfen nicht hinein, daher ist ihr Schicksal Entt√§uschung und Frustration. <br><br>  Gibt es in der neuen Version von Java 9 etwas f√ºr Programmierer, die an der Unterst√ºtzung von Legacy-Code beteiligt sind?  Etwas, das ihnen das Leben erleichtern k√∂nnte?  Zum Gl√ºck ja. <br><br>  <b>Was mit der Unterst√ºtzung von Legacy-Code getan werden musste, ist das Erscheinungsbild von Java 9</b> <br><br>  Nat√ºrlich k√∂nnen Sie die Funktionen der neuen Plattform in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Legacy-Anwendungen integrieren,</a> in denen Sie die Abw√§rtskompatibilit√§t einhalten m√ºssen.  Insbesondere gibt es immer M√∂glichkeiten, die neuen APIs zu nutzen.  Es kann sich jedoch als etwas h√§sslich herausstellen. <br><br>  Sie k√∂nnen beispielsweise eine sp√§te Bindung anwenden, wenn Sie auf die neue API zugreifen m√∂chten, wenn Ihre Anwendung auch mit √§lteren Java-Versionen arbeiten muss, die diese API nicht unterst√ºtzen.  Angenommen, Sie m√∂chten die in Java 8 eingef√ºhrte Klasse <code>java.util.stream.LongStream</code> verwenden und die Methode <code>anyMatch(LongPredicate)</code> dieser Klasse verwenden, die Anwendung muss jedoch mit Java 7 kompatibel sein. Sie k√∂nnen eine <code>anyMatch(LongPredicate)</code> erstellen: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> classLongStreamHelper { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Class longStreamClass; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Class longPredicateClass; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Method anyMatchMethod; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { longStreamClass = Class.forName(<span class="hljs-string"><span class="hljs-string">"java.util.stream.LongStream"</span></span>); longPredicateClass = Class.forName(<span class="hljs-string"><span class="hljs-string">"java.util.function.LongPredicate"</span></span>); anyMatchMethod = longStreamClass.getMethod(<span class="hljs-string"><span class="hljs-string">"anyMatch"</span></span>, longPredicateClass): } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ClassNotFoundException e) { longStreamClass = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; longPredicateClass = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; anyMatchMethod = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (NoSuchMethodException e) { longStreamClass = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; longPredicateClass = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; anyMatchMethod = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anyMatch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object theLongStream, Object thePredicate)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> NotImplementedException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (longStreamClass == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotImplementedException(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Boolean result = (Boolean) anyMatchMethod.invoke(theLongStream, thePredicate); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result.booleanValue(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable e) { <span class="hljs-comment"><span class="hljs-comment">// lots of potential exceptions to handle. Let's simplify. throw new NotImplementedException(); } } }</span></span></code> </pre> <br>  Es gibt M√∂glichkeiten, diesen Vorgang zu vereinfachen oder allgemeiner oder effektiver zu gestalten - Sie haben die Idee. <br><br>  Anstatt <code>theLongStream.anyMatch(thePredicate)</code> wie in Java 8 <code>LongStreamHelper.anyMatch(theLongStream, thePredicate)</code> k√∂nnen Sie <code>LongStreamHelper.anyMatch(theLongStream, thePredicate)</code> in jeder Java-Version <code>LongStreamHelper.anyMatch(theLongStream, thePredicate)</code> .  Wenn Sie mit Java 8 arbeiten, funktioniert dies, aber wenn Sie mit Java 7 arbeiten, <code>NotImplementedException</code> das Programm eine <code>NotImplementedException</code> . <br><br>  Warum ist das h√§sslich?  Da der Code zu kompliziert werden kann, wenn Sie auf viele APIs zugreifen m√ºssen (dies ist bereits jetzt mit einer einzigen API unpraktisch).  Dar√ºber hinaus ist diese Vorgehensweise nicht typsicher, da im Code <code>LongStream</code> oder <code>LongPredicate</code> nicht direkt erw√§hnt <code>LongStream</code> <code>LongPredicate</code> .  Schlie√ülich ist diese Praxis aufgrund des Overheads der Reflexion sowie zus√§tzlicher <code>try-catch</code> Bl√∂cke viel weniger effizient.  Obwohl dies auf diese Weise m√∂glich ist, ist es daher nicht allzu interessant und aufgrund von Nachl√§ssigkeit mit Fehlern behaftet. <br><br>  Ja, Sie k√∂nnen auf die neuen APIs zugreifen, und Ihr Code beh√§lt gleichzeitig die Abw√§rtskompatibilit√§t bei, aber Sie werden mit den neuen Sprachkonstrukten keinen Erfolg haben.  Angenommen, wir m√ºssen Lambda-Ausdr√ºcke in Code verwenden, der abw√§rtskompatibel bleiben und in Java 7 funktionieren soll. Sie haben kein Gl√ºck.  Mit dem Java-Compiler k√∂nnen Sie keine h√∂here Quellversion als das Ziel angeben.  Wenn Sie also die Konformit√§tsstufe des Quellcodes auf 1,8 (d. H. Java 8) festlegen und die Zielkonformit√§tsstufe 1,7 (Java 7) betr√§gt, l√§sst der Compiler dies nicht zu. <br><br>  <b>JAR-Dateien mit mehreren Versionen helfen Ihnen dabei</b> <br><br>  In j√ºngerer Zeit hat sich eine weitere gro√üartige Gelegenheit ergeben, die neuesten Java-Funktionen zu verwenden und gleichzeitig Anwendungen mit √§lteren Java-Versionen zu erm√∂glichen, bei denen solche Anwendungen nicht unterst√ºtzt wurden.  In Java 9 wird diese Funktion sowohl f√ºr neue APIs als auch f√ºr neue Java-Sprachkonstrukte bereitgestellt: Es handelt sich um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JAR-Dateien</a> mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mehreren Versionen</a> . <br><br>  JAR-Dateien mit mehreren Versionen unterscheiden sich fast nicht von den guten alten JAR-Dateien, aber mit einer wichtigen Einschr√§nkung: In den neuen JAR-Dateien ist eine neue ‚ÄûNische‚Äú erschienen, in der Sie Klassen schreiben k√∂nnen, die die neuesten Java 9-Funktionen verwenden. Wenn Sie mit Java 9 arbeiten, dann Die JVM findet diese "Nische", verwendet die Klassen daraus und ignoriert die gleichnamigen Klassen aus dem Hauptteil der JAR-Datei. <br><br>  Bei der Arbeit mit Java 8 oder niedriger ist der JVM jedoch die Existenz dieser ‚ÄûNische‚Äú nicht bekannt.  Sie ignoriert es und verwendet Klassen aus dem Hauptteil der JAR-Datei.  Mit der Ver√∂ffentlichung von Java 10 wird eine neue √§hnliche ‚ÄûNische‚Äú f√ºr Klassen angezeigt, die die relevantesten Funktionen von Java 10 usw. verwenden. <br><br>  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 238</a> , einem Vorschlag f√ºr die Java-Entwicklung, der ausgehungerte JAR-Dateien beschreibt, wird ein einfaches Beispiel bereitgestellt.  Angenommen, wir haben eine JAR-Datei mit vier Klassen, die in Java 8 oder niedriger ausgef√ºhrt werden: <br><br><pre> <code class="java hljs">JAR root - A.class - B.class - C.class - D.class</code> </pre> <br>  Stellen Sie sich nun vor, dass wir nach der Ver√∂ffentlichung von Java 9 die Klassen A und B neu schreiben, damit sie die neuen Funktionen von Java 9 verwenden k√∂nnen. Dann kommt Java 10 heraus und wir schreiben Klasse A neu, damit sie die neuen Funktionen von Java 10 verwenden k√∂nnen. sollte die Anwendung mit Java 8 weiterhin einwandfrei funktionieren. Die neue JAR-Datei mit mehreren Versionen sieht folgenderma√üen aus: <br><br><pre> <code class="java hljs">JAR root - A.class - B.class - C.class - D.class - META-INF Versions - <span class="hljs-number"><span class="hljs-number">9</span></span> - A.class - B.class - <span class="hljs-number"><span class="hljs-number">10</span></span> - A.class</code> </pre> <br>  Die JAR-Datei hat nicht nur eine neue Struktur erhalten.  In seinem Manifest wird nun darauf hingewiesen, dass diese Datei mehrfach versioniert ist. <br><br>  Wenn Sie diese JAR-Datei in der Java 8-JVM ausf√ºhren, wird der Abschnitt <code>\META-INF\Versions</code> ignoriert, da er nicht einmal vermutet oder gesucht wird.  Es werden nur die Originalklassen A, B, C und D verwendet. <br><br>  Unter Java 9 werden die Klassen in <code>\META-INF\Versions\9</code> verwendet. Au√üerdem werden sie anstelle der urspr√ºnglichen Klassen A und B verwendet, die Klassen in <code>\META-INF\Versions\10</code> ignoriert. <br><br>  Unter Java 10 werden beide Zweige <code>\META-INF\Versions</code> .  insbesondere Version A von Java 10, Version B von Java 9 und die Standardversionen C und D. <br><br>  Wenn Sie also eine neue ProcessBuilder-API von Java 9 in Ihrer Anwendung ben√∂tigen, aber sicherstellen m√ºssen, dass die Anwendung unter Java 8 weiterhin funktioniert, schreiben Sie einfach die neuen Versionen Ihrer Klassen mit ProcessBuilder in den Abschnitt <code>\META-INF\Versions\9</code> der JAR-Datei und belassen Sie die alten Klassen im Hauptteil des Archivs, der standardm√§√üig verwendet wird.  Dies ist der einfachste Weg, die neuen Funktionen von Java 9 zu nutzen, ohne die Abw√§rtskompatibilit√§t zu beeintr√§chtigen. <br><br>  Java 9 JDK verf√ºgt √ºber eine Version des Tools jar.exe, die die Erstellung von JAR-Dateien mit mehreren Versionen unterst√ºtzt.  Andere Nicht-JDK-Tools bieten diese Unterst√ºtzung ebenfalls. <br><br>  <b>Java 9: ‚Äã‚ÄãModule, Module √ºberall</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Java 9-Modulsystem</a> (auch als Project Jigsaw bekannt) ist zweifellos die gr√∂√üte √Ñnderung in Java 9. Eines der Modularisierungsziele besteht darin, den Kapselungsmechanismus von Java zu st√§rken, damit der Entwickler angeben kann, welche APIs f√ºr andere Komponenten bereitgestellt werden und z√§hlen k√∂nnen. dass die JVM die Kapselung erzwingt.  Die Kapselung ist bei der Modularisierung leistungsf√§higer als bei <code>public/protected/private</code> Zugriffsmodifikatoren f√ºr Klassen oder Klassenmitglieder. <br><br>  Das zweite Ziel der Modularisierung besteht darin, anzugeben, welche Module andere Module ben√∂tigen, und vor dem Starten der Anwendung sicherzustellen, dass alle erforderlichen Module vorhanden sind.  In diesem Sinne sind Module st√§rker als der herk√∂mmliche Klassenpfadmechanismus, da Klassenpfadpfade nicht im Voraus √ºberpr√ºft werden und Fehler aufgrund des Fehlens der erforderlichen Klassen m√∂glich sind.  Somit kann ein falscher Klassenpfad bereits erkannt werden, wenn die Anwendung Zeit hat, lange genug zu arbeiten, oder nachdem sie mehrmals gestartet wurde. <br>  Das gesamte Modulsystem ist gro√ü und komplex, und eine ausf√ºhrliche Diskussion dar√ºber w√ºrde den Rahmen dieses Artikels sprengen (hier eine gute, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausf√ºhrliche Erkl√§rung</a> ).  Hier werde ich auf die Aspekte der Modularisierung eingehen, die dem Entwickler bei der Unterst√ºtzung √§lterer Anwendungen helfen. <br><br>  Modularisierung ist eine gute Sache, und der Entwickler sollte versuchen, den neuen Code nach M√∂glichkeit in Module aufzuteilen, auch wenn der Rest der Anwendung (noch) nicht modularisiert ist.  Gl√ºcklicherweise ist dies dank der Spezifikation f√ºr die Arbeit mit Modulen einfach zu bewerkstelligen. <br><br>  Zun√§chst wird die JAR-Datei modularisiert (und in ein Modul umgewandelt), wobei die Datei module-info.class (kompiliert aus module-info.java) im Stammverzeichnis der JAR-Datei angezeigt wird.  <code>module-info.java</code> enth√§lt Metadaten, insbesondere den Namen des Moduls, dessen Pakete exportiert werden ( <code>module-info.java</code> von au√üen sichtbar werden), welche Module dieses Modul ben√∂tigt, und einige andere Informationen. <br><br>  Die Informationen in <code>module-info.class</code> sind nur sichtbar, wenn die JVM danach sucht. Das hei√üt, das System behandelt die modularisierten JAR-Dateien wie gewohnt, wenn es mit √§lteren Java-Versionen funktioniert (es wird davon ausgegangen, dass der Code f√ºr die Arbeit mit einer √§lteren Java-Version kompiliert wurde Genau genommen erfordert es ein wenig Chemie, und es ist immer noch Java 9, das als Zielversion von module-info.class angegeben ist, aber das ist real. <br><br>  Daher sollten Sie in der Lage sein, modularisierte JAR-Dateien mit Java 8 und niedriger auszuf√ºhren, sofern sie auch in anderer Hinsicht mit fr√ºheren Java-Versionen kompatibel sind.  Beachten Sie auch, dass <code>module-info.class</code> unter Vorbehalt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in versionierten Bereichen von JAR-Dateien mit mehreren Versionen abgelegt werden k√∂nnen</a> . <br><br>  In Java 9 gibt es sowohl einen Klassenpfad als auch einen Modulpfad.  und einen Modulpfad.  Der Klassenpfad funktioniert wie gewohnt.  Wenn Sie eine modularisierte JAR-Datei in einen Klassenpfad einf√ºgen, wird sie wie jede andere JAR-Datei verschwendet.  Das hei√üt, wenn Sie die JAR-Datei modularisiert haben und Ihre Anwendung noch nicht bereit ist, sie als Modul zu behandeln, k√∂nnen Sie sie in den Klassenpfad einf√ºgen. Sie funktioniert wie immer.  Ihr Legacy-Code sollte damit recht erfolgreich umgehen k√∂nnen. <br><br>  Beachten Sie au√üerdem, dass die Auflistung aller JAR-Dateien im Klassenpfad als Teil eines einzelnen, nicht benannten Moduls betrachtet wird.  Ein solches Modul wird als das h√§ufigste angesehen, exportiert jedoch alle Informationen in andere Module und kann auf alle anderen Module verweisen.  Wenn Sie also noch keine modularisierte Java-Anwendung haben, aber einige alte Bibliotheken nicht modularisiert sind (und dies wahrscheinlich auch nie tun werden), k√∂nnen Sie einfach alle diese Bibliotheken in den Klassenpfad einf√ºgen, und das gesamte System funktioniert einwandfrei. <br><br>  Java 9 verf√ºgt √ºber einen Modulpfad, der mit dem Klassenpfad zusammenarbeitet.  Bei Verwendung von Modulen aus diesem Pfad kann die JVM (sowohl zur Kompilierungszeit als auch zur Laufzeit) pr√ºfen, ob alle erforderlichen Module vorhanden sind, und einen Fehler melden, wenn Module fehlen.  Alle JAR-Dateien im Klassenpfad sind als Mitglieder eines unbenannten Moduls f√ºr die im modularen Pfad aufgelisteten Module zug√§nglich - und umgekehrt. <br><br>  Es ist nicht schwierig, die JAR-Datei vom Klassenpfad in den Modulpfad zu √ºbertragen - und die Modularisierung voll auszunutzen.  Zuerst k√∂nnen Sie die Datei <code>module-info.class</code> zur JAR-Datei hinzuf√ºgen und dann die modularisierte JAR-Datei in den <code>module-info.class</code> .  Ein solches neu erstelltes Modul kann weiterhin auf alle verbleibenden JAR-Dateien in der Klassenpfad-JAR zugreifen, da sie in das unbenannte Modul eintreten und weiterhin Zugriff haben. <br><br>  Es ist auch m√∂glich, dass Sie die JAR-Datei nicht modulieren m√∂chten oder dass die JAR-Datei nicht Ihnen, sondern jemand anderem geh√∂rt, sodass Sie sie nicht selbst modulieren k√∂nnen.  In diesem Fall kann die JAR-Datei weiterhin in den Modulpfad eingef√ºgt werden. Sie wird zu einem automatischen Modul. <br><br>  Ein automatisches Modul wird als Modul betrachtet, auch wenn es keine <code>module-info.class</code> .  Dieses Modul hat denselben Namen wie die darin enthaltene JAR-Datei, und andere Module k√∂nnen es explizit anfordern.  Es exportiert automatisch alle √∂ffentlich verf√ºgbaren APIs und liest (d. H. Erfordert) alle anderen benannten Module sowie namenlosen Module. <br><br>  Somit kann eine nicht modularisierte JAR-Datei aus einem Klassenpfad in ein Modul umgewandelt werden, ohne etwas zu tun.  Vererbte JAR-Dateien werden automatisch in Module konvertiert. Es fehlen lediglich einige Informationen, die bestimmen, ob alle erforderlichen Module vorhanden sind oder was fehlt. <br><br>  Nicht jede nicht modularisierte JAR-Datei kann in den Modulpfad verschoben und in ein automatisches Modul umgewandelt werden.  Es gibt eine Regel: Ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Paket kann Teil nur eines benannten Moduls sein</a> .  Wenn sich ein Paket in mehr als einer JAR-Datei befindet, kann nur eine JAR-Datei mit diesem Paket in der Komposition in ein automatisches Modul umgewandelt werden.  Der Rest kann im Klassenpfad verbleiben und dem unbenannten Modul beitreten. <br><br>  Auf den ersten Blick erscheint der hier beschriebene Mechanismus kompliziert, in der Praxis ist er jedoch sehr einfach.  In diesem Fall k√∂nnen Sie die alten JAR-Dateien nur im Klassenpfad belassen oder in den Modulpfad verschieben.  Sie k√∂nnen sie in Module aufteilen oder nicht.  Wenn Ihre alten JAR-Dateien modularisiert sind, k√∂nnen Sie sie im Klassenpfad belassen oder in den Modulpfad verschieben. <br><br>  In den meisten F√§llen sollte einfach alles wie bisher funktionieren.  Ihre geerbten JAR-Dateien sollten im neuen modularen System verwurzelt sein.  Je mehr Sie den Code modulieren, desto mehr Abh√§ngigkeitsinformationen m√ºssen Sie √ºberpr√ºfen, und die fehlenden Module und APIs werden in viel fr√ºheren Entwicklungsstadien erkannt und sparen Ihnen wahrscheinlich viel Arbeit. <br><br>  <b>Java 9 "Do it yourself": Modulares JDK und Jlink</b> <br><br>  Eines der Probleme mit √§lteren Java-Anwendungen besteht darin, dass der Endbenutzer m√∂glicherweise nicht mit einer geeigneten Java-Umgebung arbeitet.  Eine M√∂glichkeit, den Zustand einer Java-Anwendung zu gew√§hrleisten, besteht darin, eine Laufzeit mit der Anwendung bereitzustellen.  Mit Java k√∂nnen Sie private (weiterverteilbare) JREs erstellen, die innerhalb der Anwendung verteilt werden k√∂nnen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> erfahren Sie, wie Sie eine private JRE erstellen.  In der Regel wird die JRE-Dateihierarchie verwendet, die mit dem JDK installiert wird, die erforderlichen Dateien werden gespeichert und die optionalen Dateien mit den Funktionen, die m√∂glicherweise in Ihrer Anwendung ben√∂tigt werden, werden gespeichert. <br><br>  Der Vorgang ist etwas m√ºhsam: Sie m√ºssen eine Hierarchie von Installationsdateien beibehalten und dabei vorsichtig sein, damit Sie keine einzelne Datei und kein einzelnes Verzeichnis verpassen.  Dies an sich wird nicht schaden, aber Sie m√∂chten immer noch alles √ºberfl√ºssige loswerden, da diese Dateien Speicherplatz beanspruchen.  Ja, es ist einfach nachzugeben und einen solchen Fehler zu machen. <br><br>  Warum also nicht diese Arbeit an das JDK delegieren? <br><br>  In Java 9 k√∂nnen Sie eine eigenst√§ndige Umgebung erstellen, die der Anwendung hinzugef√ºgt wird. In dieser Umgebung ist alles vorhanden, damit die Anwendung funktioniert.  Sie m√ºssen sich keine Sorgen mehr machen, dass der Computer des Benutzers die falsche Umgebung f√ºr die Ausf√ºhrung von Java hat. Sie m√ºssen sich keine Sorgen mehr machen, dass Sie selbst eine private JRE nicht ordnungsgem√§√ü erstellt haben. <br><br>  Eine Schl√ºsselressource zum Erstellen solcher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in sich geschlossenen ausf√ºhrbaren Bilder</a> ist ein modulares System.  Jetzt k√∂nnen Sie nicht nur Ihren eigenen Code, sondern auch Java 9 JDK selbst modularisieren.  Jetzt ist die Java-Klassenbibliothek eine Sammlung von Modulen, und die JDK-Tools bestehen auch aus Modulen.  F√ºr das Modulsystem m√ºssen Sie die Basisklassenmodule angeben, die in Ihrem Code ben√∂tigt werden, und Sie m√ºssen die erforderlichen JDK-Elemente angeben. <br><br>  Um alles zusammenzubringen, bietet Java 9 ein spezielles neues Tool namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jlink</a> .  Durch das Starten von jlink erhalten Sie eine Hierarchie von Dateien - genau die, die Sie zum Ausf√ºhren Ihrer Anwendung ben√∂tigen, nicht mehr und nicht weniger.  Ein solcher Satz ist viel kleiner als der Standard-JRE, au√üerdem ist er plattformspezifisch (dh er wird f√ºr ein bestimmtes Betriebssystem und einen bestimmten Computer ausgew√§hlt).  Wenn Sie solche ausf√ºhrbaren Images f√ºr andere Plattformen erstellen m√∂chten, m√ºssen Sie jlink daher im Kontext der Installation auf jeder bestimmten Plattform ausf√ºhren, f√ºr die Sie ein solches Image ben√∂tigen. <br><br>  Beachten Sie auch: Wenn Sie jlink mit einer Anwendung ausf√ºhren, in der nichts modularisiert ist, verf√ºgt das Tool einfach nicht √ºber die erforderlichen Informationen, um die JRE zu komprimieren, sodass jlink nur noch die gesamte JRE packen muss.  Selbst in diesem Fall ist es f√ºr Sie etwas bequemer: jlink packt die JRE f√ºr Sie, sodass Sie sich keine Gedanken dar√ºber machen m√ºssen, wie die Dateihierarchie korrekt kopiert wird. <br><br>  Mit jlink wird es einfach, die Anwendung und alles, was Sie zum Ausf√ºhren ben√∂tigen, zu packen - und Sie m√ºssen sich keine Sorgen machen, dass Sie etwas falsch machen.  Das Tool packt nur den Teil der Laufzeit, der f√ºr die Arbeit der Anwendung erforderlich ist.  Das hei√üt, eine √§ltere Java-Anwendung erh√§lt garantiert eine Umgebung, in der sie betriebsbereit ist. <br><br>  <b>Das Zusammentreffen von Alt und Neu</b> <br><br>   ,     Java-   ,      ,     .  Java 9,     ,      API   ,   (  )  ,      ,         Java. <br><br>     Java 9: -,      ,        ,      Java. <br><br>  JAR-      Java 9       JAR-,     Java   .  ,      Java 9,     Java 8        ‚Äì     . <br><br>   Java,    ,     JAR-   ,     .   ,             ,  ¬´  ¬ª   . <br><br>   JDK  jlink,             ,       .       ,    Java    ‚Äì    . <br><br>      Java,  Java 9       ,             ‚Äì       ,   ,          Java. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417733/">https://habr.com/ru/post/de417733/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417721/index.html">GPUs zur L√∂sung moderner IT-Probleme</a></li>
<li><a href="../de417723/index.html">Arbeiten Sie mit der KOMPAS-3D-API ‚Üí Lektion 11 ‚Üí Einfache Textbeschriftungen</a></li>
<li><a href="../de417725/index.html">Wie Flant Mitarbeiter anstellt</a></li>
<li><a href="../de417729/index.html">Der Intel Core i7-8086K (Teil 2)</a></li>
<li><a href="../de417731/index.html">Die Geschichte eines T61</a></li>
<li><a href="../de417735/index.html">Infrastruktur f√ºr √∂ffentliche Schl√ºssel: GnuPG / SMIME- und PKCS # 11-Token mit Unterst√ºtzung f√ºr die russische Kryptographie</a></li>
<li><a href="../de417737/index.html">Hier ist unser Sommer</a></li>
<li><a href="../de417739/index.html">Maschinelles Lernen gegen Kreditrisiko oder "Komm schon, Gini, komm schon"</a></li>
<li><a href="../de417741/index.html">27. Juli 2018 - totale Mondfinsternis und die gro√üe Konfrontation des Mars</a></li>
<li><a href="../de417743/index.html">Legend√§re Verst√§rker - Historische Trendanatomie: Cold Transistor Sound</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>