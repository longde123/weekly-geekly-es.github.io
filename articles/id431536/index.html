<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤲 📍 😛 Ceph. Anatomi bencana 👨‍👩‍👧‍👦 🚵🏻 📐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ceph adalah penyimpanan objek yang dirancang untuk membantu membangun kluster failover. Tetap saja, kegagalan bisa terjadi. Setiap orang yang bekerja ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ceph. Anatomi bencana</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/431536/">  Ceph adalah penyimpanan objek yang dirancang untuk membantu membangun kluster failover.  Tetap saja, kegagalan bisa terjadi.  Setiap orang yang bekerja dengan Ceph tahu legenda tentang CloudMouse atau Rosreestr.  Sayangnya, tidak lazim untuk berbagi pengalaman negatif dengan kami, penyebab kegagalan paling sering ditutup-tutupi, dan tidak memungkinkan generasi mendatang untuk belajar dari kesalahan orang lain. <br><br>  Baiklah, mari kita buat gugus uji, tetapi dekat dengan yang asli, dan menganalisis bencana dengan tulang.  Kami akan mengukur semua penarikan kinerja, menemukan kebocoran memori, dan menganalisis proses pemulihan layanan.  Dan semua ini di bawah kepemimpinan Artemy Kapitula, yang menghabiskan hampir satu tahun mempelajari jebakan, menyebabkan kinerja cluster gagal nol dan latensi tidak melompat ke nilai tidak senonoh.  Dan saya mendapat grafik merah, yang jauh lebih baik. <br><img src="https://habrastorage.org/webt/c8/nr/1a/c8nr1akew1kjleodu5trq_ow3oy.png"><br><br>  Selanjutnya, Anda akan menemukan versi video dan teks dari salah satu laporan terbaik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DevOpsConf Russia</a> 2018. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_fWYUl2QsoI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br>  <strong>Tentang pembicara:</strong> Arsitek sistem Artemy Kapitula RCNTEC.  Perusahaan ini menawarkan solusi IP telephony (kolaborasi, organisasi kantor jarak jauh, sistem penyimpanan yang ditentukan perangkat lunak, dan sistem manajemen / distribusi daya).  Perusahaan ini terutama bekerja di sektor perusahaan, oleh karena itu tidak terlalu terkenal di pasar DevOps.  Namun demikian, beberapa pengalaman telah diakumulasikan dengan Ceph, yang dalam banyak proyek digunakan sebagai elemen dasar dari infrastruktur penyimpanan. <br><br>  <strong>Ceph adalah repositori yang ditentukan perangkat lunak dengan banyak komponen perangkat lunak.</strong> <br><img src="https://habrastorage.org/webt/dw/ow/hm/dwowhmqvjfugd0u-ljhhz3fy2ji.png"><br><br>  Dalam diagram: <br><br><ul><li>  Level atas adalah jaringan cluster internal yang digunakan oleh cluster itu sendiri untuk berkomunikasi; </li><li>  Level bawah - sebenarnya Ceph - adalah seperangkat daemon Ceph internal (MON, MDS, dan OSD) yang menyimpan data. </li></ul><br>  Semua data, sebagai aturan, direplikasi. Dalam diagram, saya sengaja memilih tiga kelompok, masing-masing dengan tiga OSD, dan masing-masing kelompok ini biasanya berisi satu replika data.  Akibatnya, data disimpan dalam tiga salinan. <br><br>  Jaringan kluster tingkat yang lebih tinggi adalah jaringan yang melaluinya klien Ceph mengakses data.  Melalui itu, klien berkomunikasi dengan monitor, dengan MDS (siapa yang membutuhkannya) dan dengan OSD.  Setiap klien bekerja dengan masing-masing OSD dan dengan setiap monitor secara independen.  Oleh karena itu, <strong>sistem ini tidak memiliki satu titik kegagalan</strong> , yang sangat menyenangkan. <br><br><h2>  Pelanggan <br></h2><br>  ● pelanggan S3 <br><br>  S3 adalah API untuk HTTP.  Klien S3 bekerja melalui HTTP dan terhubung ke komponen Ceph Rados Gateway (RGW).  Mereka hampir selalu berkomunikasi dengan komponen melalui jaringan khusus.  Jaringan ini (saya menyebutnya jaringan S3) hanya menggunakan HTTP, pengecualian jarang. <br><br>  ● Hypervisor dengan mesin virtual <br><br>  Kelompok pelanggan ini sering digunakan.  Mereka bekerja dengan monitor dan dengan OSD, dari mana mereka menerima informasi umum tentang status cluster dan distribusi data.  Untuk data, klien ini langsung pergi ke daemon OSD melalui jaringan publik Cluster. <br><br>  ● klien RBD <br><br>  Ada juga host logam BR fisik, yang biasanya Linux.  Mereka adalah klien RBD dan mendapatkan akses ke gambar yang disimpan di dalam cluster Ceph (gambar disk mesin virtual). <br><br>  ● klien CephFS <br><br>  Kelompok keempat klien, yang masih belum banyak, tetapi semakin menarik, adalah klien sistem file CephFS cluster.  Sistem cluster CephFS dapat dipasang secara bersamaan dari banyak node, dan semua node mendapatkan akses ke data yang sama, bekerja dengan masing-masing OSD.  Artinya, tidak ada Gateway seperti itu (Samba, NFS dan lain-lain).  Masalahnya adalah klien seperti itu hanya bisa Linux, dan versi yang cukup modern. <br><img src="https://habrastorage.org/webt/fw/nm/xc/fwnmxcaiig0yy6tkofrljqri3ck.png"><br><br>  Perusahaan kami bekerja di pasar korporat, dan di sana bola dikuasai oleh ESXi, HyperV, dan lainnya.  Oleh karena itu, cluster Ceph, yang entah bagaimana digunakan di sektor korporasi, diperlukan untuk mendukung teknik yang sesuai.  Ini tidak cukup bagi kami di Ceph, jadi kami harus memperbaiki dan memperluas cluster Ceph dengan komponen kami, bahkan membangun sesuatu yang lebih dari Ceph, platform kami sendiri untuk menyimpan data. <br><br>  Selain itu, pelanggan di sektor korporasi tidak di Linux, tetapi kebanyakan dari mereka Windows, kadang-kadang Mac OS, tidak dapat pergi ke cluster Ceph sendiri.  Mereka harus melalui semacam gateway, yang dalam hal ini menjadi kemacetan. <br><br>  Kami harus menambahkan semua komponen ini, dan kami mendapat klaster yang sedikit lebih luas. <br><img src="https://habrastorage.org/webt/p2/tg/j2/p2tgj2qtpzrzsnst5bophkclywi.png"><br><br>  Kami memiliki dua komponen utama: <strong>grup Gateway SCSI</strong> , yang menyediakan akses ke data dalam cluster Ceph melalui FibreChannel atau iSCSI.  Komponen-komponen ini digunakan untuk menghubungkan HyperV dan ESXi ke cluster Ceph.  Pelanggan PROXMOX masih bekerja dengan caranya sendiri - melalui RBD. <br><br>  Kami tidak membiarkan klien file langsung ke jaringan cluster, beberapa Gateway toleran-kesalahan dialokasikan untuk mereka.  Setiap Gateway menyediakan akses ke sistem cluster file melalui NFS, AFP, atau SMB.  Dengan demikian, hampir semua klien, apakah itu Linux, FreeBSD atau bukan hanya klien, server (OS X, Windows), mendapat akses ke CephFS. <br><br>  Untuk mengelola semua ini, kami harus benar-benar mengembangkan orkestra Ceph kami sendiri dan semua komponen kami, yang jumlahnya banyak di sana.  Tetapi membicarakannya sekarang tidak masuk akal, karena ini adalah perkembangan kita.  Sebagian besar mungkin akan tertarik pada "telanjang" Ceph itu sendiri. <br><br>  Ceph banyak digunakan di mana, dan kadang-kadang terjadi kegagalan.  Tentunya semua orang yang bekerja dengan Ceph tahu legenda tentang CloudMouse.  Ini adalah legenda urban yang mengerikan, tetapi semuanya tidak begitu buruk di sana seperti yang terlihat.  Ada dongeng baru tentang Rosreestr.  Ceph berputar di mana-mana, dan di mana-mana itu gagal.  Di suatu tempat itu berakhir fatal, di suatu tempat berhasil dengan cepat menghilangkan konsekuensinya. <br><br>  Sayangnya, tidak lazim bagi kami untuk berbagi pengalaman negatif, semua orang berusaha menyembunyikan informasi yang relevan.  Perusahaan asing sedikit lebih terbuka, khususnya DigitalOcean (penyedia terkenal yang mendistribusikan mesin virtual) juga mengalami kegagalan Ceph selama hampir satu hari, yaitu 1 April - hari yang indah!  Mereka memposting beberapa laporan, log pendek di bawah ini. <br><img src="https://habrastorage.org/webt/qo/sb/ds/qosbdsczlkvzh-zqsfvid86er5u.png"><br><br>  Masalahnya dimulai pukul 7 pagi, jam 11 mereka mengerti apa yang terjadi, dan mulai menghilangkan kegagalan.  Untuk melakukan ini, mereka mengalokasikan dua perintah: satu karena beberapa alasan berlari di sekitar server dan memasang memori di sana, dan yang kedua untuk beberapa alasan secara manual memulai satu server demi satu dan dengan hati-hati memonitor semua server.  Mengapa  Kita semua terbiasa dengan semua yang dihidupkan dengan satu klik. <br><br>  <em>Apa yang pada dasarnya terjadi dalam sistem terdistribusi ketika sistem itu secara efektif dibangun dan bekerja hampir pada batas kemampuannya?</em> <br><br>  Untuk menjawab pertanyaan ini, kita perlu melihat bagaimana cluster Ceph bekerja dan bagaimana kegagalan terjadi. <br><img src="https://habrastorage.org/webt/ln/ks/rd/lnksrda1mb-lmfbymyacym1f8aw.png"><br><br><h2>  Skenario Kegagalan Ceph <br></h2><br>  Pada awalnya, cluster berfungsi dengan baik, semuanya berjalan dengan baik.  Kemudian sesuatu terjadi, setelah itu daemon OSD, tempat data disimpan, kehilangan kontak dengan komponen pusat dari cluster (monitor).  Pada titik ini, batas waktu terjadi dan seluruh kluster mendapat taruhan.  Cluster berdiri untuk sementara sampai menyadari bahwa ada sesuatu yang salah dengan itu, dan setelah itu mengoreksi pengetahuan internalnya.  Setelah itu, layanan pelanggan dipulihkan sampai batas tertentu, dan gugus kembali bekerja dalam mode terdegradasi.  Dan lucunya adalah ia bekerja lebih cepat daripada dalam mode normal - ini adalah fakta yang luar biasa. <br><br>  Maka kita menghilangkan kegagalan itu.  Misalkan kita kehilangan daya, rak itu benar-benar dipotong.  Listrik datang berjalan, mereka semua pulih, mereka memasok daya, server dihidupkan dan kemudian <strong>kesenangan dimulai</strong> . <br><br><blockquote>  Semua orang terbiasa dengan fakta bahwa ketika server gagal, semuanya menjadi buruk, dan ketika kita menghidupkan server, semuanya menjadi baik.  Semuanya benar-benar salah di sini. <br></blockquote><br>  Cluster praktis berhenti, melakukan sinkronisasi primer, dan kemudian memulai pemulihan yang lancar dan lambat, secara bertahap kembali ke mode normal. <br><img src="https://habrastorage.org/webt/ml/r_/i3/mlr_i3llw-lsdaybp4vbedxeuhi.png"><br><br>  Di atas adalah grafik kinerja cluster Ceph sebagai kegagalan berkembang.  Harap perhatikan bahwa di sini interval yang kami bicarakan sangat jelas dilacak: <br><br><ul><li>  Pengoperasian normal hingga sekitar 70 detik; </li><li>  Kegagalan selama satu menit hingga sekitar 130 detik; </li><li>  Sebuah dataran tinggi yang terasa lebih tinggi dari operasi normal adalah pekerjaan dari cluster terdegradasi; </li><li>  Kemudian kita nyalakan simpul yang hilang - ini adalah cluster pelatihan, hanya ada 3 server dan 15 SSD.  Kami memulai server di suatu tempat sekitar 260 detik. </li><li>  Server dihidupkan, memasuki cluster - IOPS'y jatuh. </li></ul><br>  Mari kita coba mencari tahu apa yang sebenarnya terjadi di sana.  Hal pertama yang menarik minat kami adalah penurunan di awal grafik. <br><br><h3>  Kegagalan OSD <br></h3><br>  Pertimbangkan contoh cluster dengan tiga rak, beberapa node di masing-masing.  Jika rak kiri gagal, semua daemon OSD (bukan host!) Ping sendiri dengan pesan Ceph pada interval tertentu.  Jika ada beberapa pesan yang hilang, sebuah pesan dikirim ke monitor: "Saya, OSD begini dan begitu, tidak dapat mencapai OSD begini dan begini." <br><img src="https://habrastorage.org/webt/zh/1s/ge/zh1sge1ljlclxjmgfygxpyyyc8i.png"><br><br>  Dalam hal ini, pesan biasanya dikelompokkan berdasarkan host, yaitu, jika dua pesan dari OSD yang berbeda tiba di host yang sama, mereka digabungkan menjadi satu pesan.  Dengan demikian, jika OSD 11 dan OSD 12 melaporkan bahwa mereka tidak dapat mencapai OSD 1, ini akan ditafsirkan sebagai Host 11 mengeluh tentang OSD 1. Ketika OSD 21 dan OSD 22 dilaporkan, ia ditafsirkan sebagai Host 21 tidak puas dengan OSD 1 Setelah itu monitor menganggap bahwa OSD 1 berada dalam kondisi turun dan memberi tahu semua anggota cluster (dengan mengubah peta OSD), pekerjaan berlanjut dalam mode terdegradasi. <br><img src="https://habrastorage.org/webt/uu/-c/1w/uu-c1wnwflbqk6ueyumhohtlvjy.png"><br><br>  Jadi, inilah rak kami dan rak gagal (Host 5 dan Host 6).  Kami menyalakan Host 5 dan Host 6, saat daya muncul, dan ... <br><br><h3>  Perilaku internal Ceph <br></h3><br>  Dan sekarang bagian yang paling menarik adalah kita memulai <strong>sinkronisasi data awal</strong> .  Karena ada banyak replika, mereka harus sinkron dan berada di versi yang sama.  Dalam proses memulai OSD mulai: <br><br><ul><li>  OSD membaca versi yang tersedia, riwayat yang tersedia (pg_log - untuk menentukan versi objek saat ini). </li><li>  Setelah itu menentukan OSD mana versi terbaru dari objek terdegradasi (missing_loc) aktif, dan yang di belakang. </li><li>  Di mana versi mundur disimpan, sinkronisasi diperlukan, dan versi baru dapat digunakan sebagai referensi untuk membaca dan menulis data. </li></ul><br>  Sebuah cerita digunakan yang dikumpulkan dari semua OSD, dan cerita ini bisa sangat banyak;  lokasi sebenarnya dari set objek di cluster di mana versi yang sesuai berada ditentukan.  Berapa banyak objek dalam cluster, berapa banyak catatan yang diperoleh, jika cluster telah berdiri lama dalam mode terdegradasi, maka ceritanya panjang. <br><br>  <strong>Sebagai perbandingan:</strong> ukuran tipikal sebuah objek saat kami bekerja dengan gambar RBD adalah 4 MB.  Ketika kami bekerja dalam penghapusan kode - 1MB.  Jika kami memiliki disk 10 TB, kami mendapatkan sejuta megabyte objek di disk.  Jika kita memiliki 10 disk di server, maka sudah ada 10 juta objek, jika ada 32 disk (kami sedang membangun cluster yang efisien, kami memiliki alokasi yang ketat), maka 32 juta objek harus disimpan dalam memori.  Selain itu, pada kenyataannya, informasi tentang setiap objek disimpan dalam beberapa salinan, karena setiap salinan menunjukkan bahwa di tempat ini terletak di versi ini, dan ini - di sini. <br><br>  Ternyata sejumlah besar data, yang terletak di RAM: <br><br><ul><li>  semakin banyak objek, semakin besar sejarah missing_loc; </li><li>  semakin banyak PG - semakin banyak pg_log dan peta OSD; </li></ul><br>  sebagai tambahan: <br><br><ul><li>  semakin besar ukuran disk; </li><li>  semakin tinggi kepadatan (jumlah disk di setiap server); </li><li>  semakin tinggi beban pada cluster dan semakin cepat cluster Anda; </li><li>  semakin lama OSD turun (dalam kondisi Offline); </li></ul><br>  dengan kata lain, semakin <strong>curam cluster yang kami bangun, dan semakin lama bagian cluster tidak merespons, semakin banyak RAM yang dibutuhkan saat startup</strong> . <br><br><h2>  Optimalisasi ekstrim adalah akar dari semua kejahatan <br></h2><br><blockquote>  <em>"... dan OOM hitam datang ke anak laki-laki dan perempuan jahat di malam hari dan membunuh semua proses kiri dan kanan"</em> <br><br>  Legenda sysadmin kota <br></blockquote><br>  Jadi, RAM membutuhkan banyak, konsumsi memori tumbuh (kami mulai segera di sepertiga dari cluster) dan sistem secara teori dapat masuk ke SWAP, jika Anda membuatnya tentu saja.  Saya pikir ada banyak orang yang berpikir bahwa SWAP itu buruk dan mereka tidak menciptakannya: “Mengapa?  Kami memiliki banyak memori! "  Tapi ini pendekatan yang salah. <br><br>  Jika file SWAP belum dibuat sebelumnya, karena diputuskan bahwa Linux akan bekerja lebih efisien, maka cepat atau lambat akan terjadi kehabisan memori pembunuh (OOM-killer). Dan bukan fakta bahwa itu akan membunuh orang yang memakan semua memori, bukan orang yang pertama kali sial.  Kami tahu apa lokasi yang optimis - kami meminta memori, mereka menjanjikannya kepada kami, kami mengatakan: "Sekarang beri kami satu", sebagai tanggapan: "Tapi tidak!"  - dan keluar dari memory killer. <br><br>  Ini adalah pekerjaan Linux biasa, kecuali jika dikonfigurasi di area memori virtual. <br><br>  Proses keluar dari memory killer dan jatuh dengan cepat dan tanpa ampun.  Lagipula, tidak ada proses lain yang dia mati tidak tahu.  Dia tidak punya waktu untuk memberi tahu siapa pun tentang sesuatu, mereka hanya menghentikannya. <br><br>  Maka prosesnya, tentu saja, akan dimulai kembali - kita memiliki systemd, itu juga meluncurkan, jika perlu, OSD yang telah jatuh.  OSD yang jatuh mulai, dan ... reaksi berantai dimulai. <br><img src="https://habrastorage.org/webt/9p/s8/4z/9ps84zkjtmuamxyllkcgffsgxkq.png"><br><br>  Dalam kasus kami, kami memulai OSD 8 dan OSD 9, mereka mulai menghancurkan segalanya, tetapi tidak beruntung OSD 0 dan OSD 5. Pembunuh kehabisan memori terbang ke mereka dan menghentikan mereka.  Mereka memulai kembali - mereka membaca data mereka, mulai menyinkronkan dan menghancurkan sisanya.  Tiga lagi sial (OSD 9, OSD 4 dan OSD 7).  Ketiganya dimulai kembali, mulai memberi tekanan pada seluruh cluster, paket berikutnya adalah sial. <br><br>  <strong>Gugusan mulai berantakan secara harfiah di depan mata kita</strong> .  Degradasi terjadi dengan sangat cepat, dan "sangat cepat" ini biasanya dinyatakan dalam menit, maksimum puluhan menit.  Jika Anda memiliki 30 node (10 node per rak), dan kurangi rak karena kegagalan daya - setelah 6 menit, setengah dari cluster terletak. <br><br>  Jadi, kami mendapat sesuatu seperti berikut ini. <br><img src="https://habrastorage.org/webt/1b/hq/bu/1bhqburpjt74vwnpbgqn5ehdhh0.png"><br><br>  Di hampir setiap server, kami memiliki OSD yang gagal.  Dan jika pada setiap server, yaitu, di setiap domain kegagalan yang kami miliki untuk OSD yang gagal, maka <strong>sebagian besar data kami tidak dapat diakses</strong> .  Setiap permintaan diblokir - untuk ditulis, untuk dibaca - tidak ada bedanya.  Itu saja!  Kami bangun. <br><br>  Apa yang harus dilakukan dalam situasi seperti itu?  Lebih tepatnya, <strong>apa yang harus dilakukan</strong> ? <br><br>  <strong>Jawaban:</strong> Jangan memulai cluster segera, yaitu, seluruh rak, tetapi hati-hati mengangkat satu setan masing-masing. <br><br>  Tapi kami tidak tahu itu.  Kami segera mulai, dan mendapatkan apa yang kami dapatkan.  Dalam hal ini, kami meluncurkan salah satu dari empat daemon (8, 9, 10, 11), konsumsi memori akan meningkat sekitar 20%.  Sebagai aturan, kita berdiri lompatan seperti itu.  Kemudian, konsumsi memori mulai berkurang, karena beberapa struktur yang digunakan untuk menyimpan informasi tentang bagaimana cluster terdegradasi meninggalkan.  Yaitu, bagian dari Grup Penempatan telah kembali ke keadaan normal, dan semua yang diperlukan untuk mempertahankan kondisi terdegradasi dibebaskan - <strong>dalam teori ia dibebaskan</strong> . <br><br>  Mari kita lihat sebuah contoh.  Kode C di kiri dan kanan hampir identik, perbedaannya hanya pada konstanta. <br><img src="https://habrastorage.org/webt/sy/1j/u0/sy1ju0rfqjg507jxvk_4wax9_o4.png"><br><br>  Dua contoh ini meminta jumlah memori yang berbeda dari sistem: <br><br><ul><li>  kiri - 2048 buah masing-masing 1 MB; </li><li>  kanan - 2097152 buah 1 Kbyte. </li></ul><br>  Kemudian kedua contoh menunggu kami untuk memotret mereka di atas.  Dan setelah menekan ENTER, mereka membebaskan memori - semuanya kecuali bagian terakhir.  Ini sangat penting - bagian terakhir tetap ada.  Dan lagi mereka menunggu kita untuk memotret mereka. <br><br>  Di bawah ini adalah apa yang sebenarnya terjadi. <br><img src="https://habrastorage.org/webt/zx/ah/ug/zxahugrdasantcktho7dbu-tnes.png"><br><br><ul><li>  Pertama, kedua proses dimulai dan memakan memori.  Kedengarannya seperti kebenaran - RSS 2 GB. </li><li>  Tekan ENTER dan kaget.  Program pertama yang menonjol dalam potongan besar mengembalikan memori.  Tetapi program kedua tidak kembali. </li></ul><br>  Jawaban mengapa ini terjadi terletak di Linux malloc. <br><br>  Jika kami meminta memori dalam potongan besar, itu dikeluarkan menggunakan mekanisme mmap anonim, yang diberikan ke ruang alamat prosesor, dari mana memori kemudian dipotong kepada kami.  Ketika kita bebas (), memori dibebaskan dan halaman dikembalikan ke halaman cache (sistem). <br><br>  Jika kami mengalokasikan memori dalam potongan kecil, kami melakukan sbrk ().  sbrk () menggeser pointer ke ekor heap; secara teori, ekor yang bergeser dapat dikembalikan kembali dengan mengembalikan halaman memori ke sistem jika memori tidak digunakan. <br><br>  Sekarang lihat ilustrasinya.  Kami memiliki banyak catatan dalam sejarah lokasi objek terdegradasi, dan kemudian datang sesi pengguna - objek berumur panjang.  Kami menyinkronkan dan semua struktur tambahan hilang, tetapi objek yang berumur panjang tetap ada, dan kami tidak dapat memindahkan sbrk () kembali. <br><img src="https://habrastorage.org/webt/06/wf/eg/06wfegwyvu0ibae8xjlwizrwteo.png"><br><br>  Kami masih memiliki banyak ruang yang tidak terpakai yang dapat dibebaskan jika kami memiliki SWAP.  Tapi kami pintar - kami menonaktifkan SWAP. <br><br>  Tentu saja, kemudian beberapa bagian dari memori dari awal tumpukan akan digunakan, tetapi ini hanya sebagian, dan sisanya yang sangat signifikan akan tetap ditempati. <br><br>  Apa yang harus dilakukan dalam situasi seperti itu?  Jawabannya ada di bawah ini. <br><br><h3>  Peluncuran terkendali <br></h3><br><ul><li>  Kami memulai satu daemon OSD. </li><li>  Kami menunggu saat disinkronkan, kami memeriksa anggaran memori. </li><li>  Jika kita mengerti bahwa kita akan selamat dari permulaan iblis berikutnya, kita mulai yang berikutnya. </li><li>  Jika tidak, maka cepat restart daemon yang mengambil sebagian besar memori.  Dia mampu turun untuk waktu yang singkat, dia tidak memiliki banyak sejarah, hilang locs dan hal-hal lain, sehingga dia akan memakan lebih sedikit memori, anggaran memori akan meningkat sedikit. </li><li>  Kami berlari di sekitar cluster, mengendalikannya, dan secara bertahap meningkatkan segalanya. </li><li>  Kami memeriksa apakah mungkin untuk melanjutkan ke OSD berikutnya, pergi ke sana. </li></ul><br>  DigitalOcean sebenarnya melakukan ini: <br>  <em>"Tim Datacenter kami melakukan penambahan memori sementara tim lain perlahan melanjutkan memunculkan node sambil mengelola secara manual anggaran memori masing-masing host."</em> <br><img src="https://habrastorage.org/webt/nr/yg/a1/nryga17av_ez5yj0mt3lm5grkk0.png"><br><br>  Mari kita kembali ke konfigurasi dan situasi kita saat ini.  Sekarang kami memiliki cluster yang runtuh setelah reaksi berantai dari pembunuh memori.  Kami melarang restart otomatis OSD di domain merah, dan satu per satu kami memulai node dari domain biru.  Karena <strong>tugas pertama kami adalah selalu mengembalikan layanan</strong> , tanpa memahami mengapa ini terjadi.  Kami akan mengerti nanti, ketika kami mengembalikan layanan.  Dalam operasi, ini selalu terjadi. <br><br>  Kami membawa cluster ke status target untuk memulihkan layanan, dan kemudian kami mulai menjalankan satu OSD demi satu sesuai dengan metodologi kami.  Kami melihat yang pertama, jika perlu, restart yang lain untuk menyesuaikan anggaran memori, berikutnya - 9, 10, 11 - dan cluster tampaknya akan disinkronkan dan siap untuk memulai pemeliharaan. <br><br>  Masalahnya adalah bagaimana <strong>pemeliharaan tulis</strong> dilakukan <strong>di Ceph</strong> . <br><img src="https://habrastorage.org/webt/hl/rp/ek/hlrpekm0rvjgrjwl11zgdklwecc.png"><br><br>  Kami memiliki 3 replika: satu master OSD dan dua budak untuk itu.  Kami akan mengklarifikasi bahwa master / budak di setiap Grup Penempatan memiliki sendiri, tetapi masing-masing memiliki satu master dan dua budak. <br><br>  Operasi tulis atau baca jatuh pada master.  Saat membaca, jika master memiliki versi yang tepat, ia akan memberikannya kepada klien.  Perekaman sedikit lebih rumit, rekaman harus diulang pada semua replika.  Dengan demikian, ketika klien menulis 64 KB di OSD 0, 64 KB yang sama dalam contoh kita pergi ke OSD 5 dan OSD 8. <br><br>  Tetapi kenyataannya adalah bahwa OSD 8 kami sangat rusak, karena kami memulai kembali banyak proses. <br><img src="https://habrastorage.org/webt/es/_z/fr/es_zfrsvdaq8a7f_rgn7hcakpi4.png"><br><br>  Karena di Ceph perubahan apa pun adalah transisi dari versi ke versi, pada OSD 0 dan OSD 5 kita akan memiliki versi baru, pada OSD 8 - yang lama.  ,   ,    ( 64 )    OSD 8   —   4  ( ).     4   OSD 0,   OSD 8,  ,    .       ,      64 . <br><br>    —  . <br><img src="https://habrastorage.org/webt/ch/uc/l_/chucl_b0vhoi-jvuhl3xokm26qg.png"><br><br>   : <br><br><ul><li>    4   1 ,  1000 /  1 . </li><li>   4  ( )  22 ,  45 /. </li></ul><br> ,      ,       ,        ,         . <br><br>      —     . <br><img src="https://habrastorage.org/webt/it/0p/34/it0p34kbqfs3u9hvyhmextflvqc.png"><br><br>    4   22 ,  22 ,   1    4   .   45          SSD,       1  — <strong>   45 </strong> . <br><br>       ,    . <br><br><h2>    <br></h2><br><br><ul><li>   <strong> </strong> ,    — (45+1) / 2 = <strong>23 .</strong> </li><li>   <strong>75% </strong> ,  (45 * 3 + 1) / 4 = <strong>34 </strong> . </li><li>  90% —(45 * 9 + 1) / 10 = 41  —  40  ,   . </li></ul><br>     Ceph,      .                 ,     ,    ,     . <br><br>      Ceph       . <br><img src="https://habrastorage.org/webt/ng/jj/od/ngjjodzmfd4n6kes71g4n6pg7os.png"><br><br><ol><li>     —   :  , ,  ,  ,    . <br></li><li>  — latency.   latency  ,   .      100%    (    ,          ). Latency  60     ,       . <br></li></ol><br><img src="https://habrastorage.org/webt/z3/pb/ob/z3pbobkev0bfszscnwgprpop3xe.png"><br><br>       ,       .  10 ,   1 200 /,    300      ,    ,   .  10 SSD —   300   ,   — ,  - 300   . <br><br><blockquote>    ,     . <br></blockquote><br>  ,     .       900 / (  SSD).     2 500   128    ( , ESXi  HyperV     128 ).      degraded,   225   .     file store,   object store,         ( ),    110   ,     - . <br><br> SSD  110    — ! <br><br> <strong>   ?</strong> <br><br> <strong> 1:</strong>     — <b>   </b> . <br><img src="https://habrastorage.org/webt/ls/ib/rh/lsibrhcfnucjiox9f8gzxbk1cc8.png"><br><br>    :   ;   PG; <br>       . <br><br>    : <br><br><ul><li>    ,  45  —   . </li><li>     (     . ),   14 . </li><li>    ,  8  (  10% PG). </li></ul><br>   <strong>  ,  </strong> ,       , ,  ,     . <br><br> <strong> 2:</strong>   — <b>  </b> (order, objectsize)  . <br><br>     , , ,   4   2  1 .      ,     ,   .  : <br><br><ul><li>     ; </li><li>     (latency)     . </li></ul><br>     : <br><br><ul><li>    ; </li><li>     ; </li><li>   —        .     4 ,   . </li></ul><br>        (32  ) —      ! <br><br> <strong> 3:</strong>    —  <b> Ceph</b> . <br><br>     ,   -,  <strong> Ceph</strong> .                  ,      ,      .     . <br><img src="https://habrastorage.org/webt/c8/nr/1a/c8nr1akew1kjleodu5trq_ow3oy.png"><br><br>     ,   — Latency.  —  ,  — . Latency      30% ,       ,      . <br><br>  Community     ,     preproduction .     ,     .      ,   . <br><br><h1>  Kesimpulan <br></h1><br>      -  ,     .        ,   Ceph    - ,  ,    . <br><br> ● <strong>   -  </strong> . <br>     ,     .  ,  <strong>     </strong> .       .  ,         ,    production.  ,       ,     ,    DigitalOcean  ,   .   ,  ,    ,  . <br><br>   ,        ,        .    ,  : «    !  ?!»     ,  ,     .   ,      : ,   ,    down time. <br><br> ● <strong>    (OSD).</strong> <br>  ,       ,     —     , ,  -      ,   . <strong>     OSD —    —   </strong> .    ,     . <br><br> ● <strong>  .</strong> <br>        OSD       . <strong>   ,   </strong> .  ,     ,     ,   . <br><br> ● <strong>  RAM   OSD.</strong> <br><br> ● <strong>  SWAP.</strong> <br>   SWAP    Ceph' ,    Linux' .         . <br><br> ● <strong>    .</strong> <br>         100%,    10%. ,    ,      ,   . <br><br> ● <strong>        RBD      Rados Getway.</strong> <br>  ,         . <strong>   SWAP —    .</strong> ,    SWAP  —    , ,  ,    ,     . <br><br><blockquote>   —      DevOpsConf Russia.             .  ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">youtube</a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ,            DevOps-. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id431536/">https://habr.com/ru/post/id431536/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id431526/index.html">Pengaruh korup: bagaimana Stasi membela Jerman Timur dari video game</a></li>
<li><a href="../id431528/index.html">Jenius matematika misterius dan penulis mempromosikan solusi masalah permutasi</a></li>
<li><a href="../id431530/index.html">Buka pelajaran "Desain Material Android: pembaruan ikhtisar"</a></li>
<li><a href="../id431532/index.html">Memristor terdiri dari bagian tebal 2 nm</a></li>
<li><a href="../id431534/index.html">Identitas Masalah Di Antara Pengembang</a></li>
<li><a href="../id431538/index.html">Case Rate & Barang dan Mobio: peningkatan bertahap dalam semua indikator</a></li>
<li><a href="../id431540/index.html">Paket dan manajer paket untuk k8s</a></li>
<li><a href="../id431542/index.html">Pengembangan dan pemeliharaan yang efektif untuk peran yang memungkinkan</a></li>
<li><a href="../id431544/index.html">Bawa DevOps ke massa</a></li>
<li><a href="../id431546/index.html">Kenapa kita bilang oke?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>