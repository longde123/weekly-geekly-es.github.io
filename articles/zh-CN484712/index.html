<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥪 🤬 💓 相对二进制兼容性：我们如何提供它 👩🏻‍💼 🈹 👨🏻‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="你好 我叫Yuri Vlad，我是Badoo的一名Android开发人员，参与了创建Reaktive库-纯Kotlin上的Reactive Extensions。 


 任何库都应尽可能遵守二进制兼容性。 如果依赖项中库的不同版本不兼容，则结果将导致运行时崩溃。 例如，当向MVICore添加Rea...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>相对二进制兼容性：我们如何提供它</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/484712/"><p> 你好 我叫Yuri Vlad，我是Badoo的一名Android开发人员，参与了创建<a href="https://github.com/badoo/Reaktive">Reaktive</a>库-纯Kotlin上的Reactive Extensions。 </p><br><p> 任何库都应尽可能遵守二进制兼容性。 如果依赖项中库的不同版本不兼容，则结果将导致运行时崩溃。 例如，当向MVICore添加Reaktive支持时，我们可能会遇到这样的问题。 </p><br><p><img src="https://habrastorage.org/webt/6w/hx/mc/6whxmcr9swxn5rtbxjeo46igkv8.jpeg"></p><br><p> 在本文中，我将简要介绍一下二进制兼容性是什么以及Kotlin的二进制特性是什么，以及在JetBrains和现在的Badoo中如何支持二进制兼容性。 </p><a name="habracut"></a><br><h2 id="problema-binarnoy-sovmestimosti-v-kotlin">  Kotlin二进制兼容性问题 </h2><br><p>假设我们有一个很棒的库<code>com.sample:lib:1.0</code>和此类： </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>)</code> </pre> <br><p> 基于此，我们创建了第二个库<code>com.sample:lib-extensions:1.0</code> 。 其依赖项包括<code>com.sample:lib:1.0</code> 。 例如，它包含类<code>A</code>的工厂方法： </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: A = A(a)</code> </pre> <br><p> 现在，我们将发布库<code>com.sample:lib:2.0</code>的新版本，并进行以下更改： </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>)</code> </pre> <br><p>  Kotlin完全兼容的更改，不是吗？ 使用默认参数，我们可以继续使用构造<code>val a = A(a)</code> ，但前提是必须完全重新编译所有依赖项。 默认参数不是JVM的一部分，而是由特殊的合成构造函数<code>A</code>实现的，该构造函数在参数中包含类的所有字段。 在从Maven存储库接收依赖项的情况下，我们已经将它们组装好了，无法重新编译它们。 </p><br><p>  <code>com.sample:lib</code>新版本<code>com.sample:lib</code> ，我们立即将其连接到我们的项目。 我们希望与时俱进！ 新功能，新修复程序， <del> 新错误 </del>  ！ </p><br><pre> <code class="plaintext hljs">dependencies { implementation 'com.sample:lib:2.0' implementation 'com.sample:lib-extensions:1.0' }</code> </pre> <br><p> 在这种情况下，我们在运行时崩溃。 字节码中<code>createA</code>函数将尝试使用一个参数调用<code></code>类构造函数，但字节码中没有此类参数。 在具有相同组和名称的所有依赖项中，Gradle将选择具有最新版本的依赖项并将其包括在程序集中。 </p><br><p> 您很可能已经在项目中遇到了二进制不兼容问题。 就个人而言，当我将应用程序迁移到AndroidX时遇到了这个问题。 </p><br><p> 您可以在<a href="https://habr.com/ru/users/gvsmirnov/" class="user_link">gvsmirnov</a>用户的<a href="https://wiki.eclipse.org/Evolving_Java-based_APIs_2">“</a> <a href="https://habr.com/ru/post/133907/">示例中的二进制兼容性，不仅是示例</a> <a href="https://wiki.eclipse.org/Evolving_Java-based_APIs_2">”</a> ，Eclipse创建者的<a href="https://wiki.eclipse.org/Evolving_Java-based_APIs_2">“基于Java的不断发展的API 2”</a>以及Jake Wharton最近发表的文章<a href="https://jakewharton.com/public-api-challenges-in-kotlin/">“ Kotlin中的公共API挑战”中</a>阅读有关二进制兼容性的更多信息。 </p><br><h2 id="sposoby-obespecheniya-binarnoy-sovmestimosti"> 确保二进制兼容性的方法 </h2><br><p> 似乎您只需要尝试进行兼容的更改。 例如，在添加新字段时添加具有默认值的构造函数，通过用新参数覆盖方法将新参数添加到函数中，等等。但是总是很容易犯错。 因此，创建了多种工具来检查同一库的两个不同版本的二进制兼容性，例如： </p><br><ol><li>  Java API合规性检查器 </li><li> 克利尔 </li><li>  Revapi </li><li>  Japicmp </li><li>  Japitools </li><li> 周刊 </li><li>  Japi检查器 </li><li> 西格斯特 </li></ol><br><p> 它们采用两个JAR文件并给出结果：它们的兼容性。 </p><br><p> 但是，我们正在开发Kotlin库，到目前为止，仅从Kotlin使用才有意义。 这意味着例如对于<code>internal</code>类，我们并不总是需要100％的兼容性。 尽管它们以字节码形式公开，但不太可能在Kotlin码之外使用它们。 因此，为了维持二进制兼容性，kotlin-stdlib JetBrains使用<a href="https://github.com/jetBrains/kotlin/tree/master/libraries/tools/binary-compatibility-validator">二进制兼容性检查器</a> 。 基本原理是这样的：从JAR文件创建整个公共API的转储并将其写入该文件。 该文件是所有进一步检查的基准（参考），看起来像这样： </p><br><pre> <code class="plaintext hljs">public final class kotlin/coroutines/ContinuationKt { public static final fun createCoroutine (Lkotlin/jvm/functions/Function1;Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation; public static final fun createCoroutine (Lkotlin/jvm/functions/Function2;Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation; public static final fun startCoroutine (Lkotlin/jvm/functions/Function1;Lkotlin/coroutines/Continuation;)V public static final fun startCoroutine (Lkotlin/jvm/functions/Function2;Ljava/lang/Object;Lkotlin/coroutines/Continuation;)V }</code> </pre> <br><p> 对源代码进行更改后，将与当前库进行比较，重新生成基线库，并且如果对基线出现任何更改，则检查失败。 可以通过传递<code>-Doverwrite.output=true</code>来覆盖这些更改。 即使发生二进制兼容更改，也会发生错误。 为了及时更新基准并直接在拉取请求中查看其更改，这是必需的。 </p><br><h2 id="binary-compatibility-validator"> 二进制兼容性验证器 </h2><br><p> 让我们看看这个工具是如何工作的。 二进制兼容性在JVM（字节码）级别提供，并且与语言无关。 可以使用Kotlin-替换Java类实现而不会破坏二进制兼容性（反之亦然）。 <br> 首先，您需要了解库中的类。 我们记得即使对于全局函数和常量，也会创建一个带有文件名和后缀<code>Kt</code> ，例如<code>ContinuationKt</code> 。 要获取所有类，我们使用JDK中的<code>JarFile</code>类，获取指向每个类的指针，并将它们传递给<code>org.objectweb.asm.tree.ClassNode</code> 。 此类将使我们知道该类的可见性，其方法，字段和注释。 </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> jar = JarFile(<span class="hljs-string"><span class="hljs-string">"/path/to/lib.jar"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classStreams = jar.classEntries().map { entry -&gt; jar.getInputStream(entry) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classNodes = classStreams.map { it.use { stream -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classNode = ClassNode() ClassReader(stream).accept(classNode, ClassReader.SKIP_CODE) classNode } }</code> </pre> <br><p>  Kotlin进行编译时，会将其<code>@Metadata</code>运行时批注添加到每个类，以便<code>kotlin-reflect</code>可以在将Kotlin类转换为字节码之前恢复其外观。 看起来像这样： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Metadata</span></span>( mv = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>}, bv = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}, k = <span class="hljs-number"><span class="hljs-number">1</span></span>, d1 = {<span class="hljs-string"><span class="hljs-string">"\u0000 \n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0000\n\u0002\u0010\b\n\u0002\b\u0006\n\u0002\u0010\u000b\n\u0002\b\u0003\n\u0002\u0010\u000e\n\u0000\b\u0086\b\u0018\u00002\u00020\u0001B\r\u0012\u0006\u0010\u0002\u001a\u00020\u0003¢\u0006\u0002\u0010\u0004J\t\u0010\u0007\u001a\u00020\u0003HÆ\u0003J\u0013\u0010\b\u001a\u00020\u00002\b\b\u0002\u0010\u0002\u001a\u00020\u0003HÆ\u0001J\u0013\u0010\t\u001a\u00020\n2\b\u0010\u000b\u001a\u0004\u0018\u00010\u0001HÖ\u0003J\t\u0010\f\u001a\u00020\u0003HÖ\u0001J\t\u0010\r\u001a\u00020\u000eHÖ\u0001R\u0011\u0010\u0002\u001a\u00020\u0003¢\u0006\b\n\u0000\u001a\u0004\b\u0005\u0010\u0006¨\u0006\u000f"</span></span>}, d2 = {<span class="hljs-string"><span class="hljs-string">"Lcom/sample/A;"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"(I)V"</span></span>, <span class="hljs-string"><span class="hljs-string">"getA"</span></span>, <span class="hljs-string"><span class="hljs-string">"()I"</span></span>, <span class="hljs-string"><span class="hljs-string">"component1"</span></span>, <span class="hljs-string"><span class="hljs-string">"copy"</span></span>, <span class="hljs-string"><span class="hljs-string">"equals"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"other"</span></span>, <span class="hljs-string"><span class="hljs-string">"hashCode"</span></span>, <span class="hljs-string"><span class="hljs-string">"toString"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"app_release"</span></span>} )</code> </pre> <br><p>  <code>ClassNode</code>可以从<code>@Metadata</code>获取<code>@Metadata</code>批注，并将其解析为<code>KotlinClassHeader</code> 。 您必须手动执行此操作，因为<code>kotlin-reflect</code>不知道如何使用ObjectWeb ASM。 </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ClassNode.kotlinMetadata: KotlinClassMetadata? <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> metadata = findAnnotation(<span class="hljs-string"><span class="hljs-string">"kotlin/Metadata"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) ?: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> header = with(metadata) { KotlinClassHeader( kind = <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"k"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>?, metadataVersion = (<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"mv"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;?)?.toIntArray(), bytecodeVersion = (<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"bv"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;?)?.toIntArray(), data1 = (<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"d1"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;String&gt;?)?.toTypedArray(), data2 = (<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;String&gt;?)?.toTypedArray(), extraString = <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"xs"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> String?, packageName = <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"pn"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> String?, extraInt = <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"xi"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>? ) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> KotlinClassMetadata.read(header) }</code> </pre> <br><p> 需要kotlin.Metadata来正确处理<code>internal</code> ，因为它在字节码中不存在。  <code>internal</code>类和函数的更改不会影响库用户，尽管就字节码而言，它们是公共API。 </p><br><p> 从kotlin.Metadata中，您可以找到有关<code>companion object</code> 。 即使您将其声明为私有，它仍将存储在公共静态字段<code>Companion</code> ，这意味着该字段符合二进制兼容性的要求。 </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompositeException</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { } }</code> </pre> <br><pre> <code class="plaintext hljs">public final static Lcom/badoo/reaktive/base/exceptions/CompositeException$Companion; Companion @Ljava/lang/Deprecated;()</code> </pre> <br><p> 在必要的批注中，值得注意的是<code>@PublishedApi</code>提供了公共<code>inline</code>函数中使用的类和方法。 这些函数的主体保留在它们的调用位置，这意味着它们中的类和方法必须是二进制兼容的。 当您尝试在此类函数中使用非公共类和方法时，Kotlin编译器将<code>@PublishedApi</code>错误并提供使用<code>@PublishedApi</code>批注对其进行标记的功能。 </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> ClassNode.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isPublishedApi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = findAnnotation(<span class="hljs-string"><span class="hljs-string">"kotlin/PublishedApi"</span></span>, includeInvisible = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) != <span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre> <br><p> 类继承树和接口的实现对于支持二进制兼容性很重要。 例如，我们不能简单地从类中删除某些接口。 获取父类和可实现的接口非常简单。 </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> supertypes = listOf(classNode.superName) - <span class="hljs-string"><span class="hljs-string">"java/lang/Object"</span></span> + classNode.interfaces.sorted()</code> </pre> <br><p>  <code>Object</code>已从列表中删除，因为对其进行跟踪没有任何意义。 </p><br><p> 验证器内部还有许多其他特定于Kotlin的检查：通过<code>Interface$DefaultImpls</code>检查接口中的默认方法，忽略<code>$WhenMappings</code>类以使<code>when</code>操作符工作，等等。 </p><br><p> 接下来，您需要遍历所有<code>ClassNode</code>并获取它们的<code>MethodNode</code>和<code>FieldNode</code> 。 从类的签名，它们的字段和方法，我们得到<code>ClassBinarySignature</code> ， <code>FieldBinarySignature</code>和<code>MethodBinarySignature</code> ，它们在项目中本地声明。 它们全部实现<code>MemberBinarySignature</code>接口，能够使用<code>isEffectivelyPublic</code>方法确定其公共可见性，并以可读格式的<code>val signature: String</code>显示其签名。 </p><br><pre> <code class="kotlin hljs">classNodes.map { with(it) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> metadata = kotlinMetadata <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mVisibility = visibilityMapNew[name] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classAccess = AccessFlags(effectiveAccess and Opcodes.ACC_STATIC.inv()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> supertypes = listOf(superName) - <span class="hljs-string"><span class="hljs-string">"java/lang/Object"</span></span> + interfaces.sorted() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> memberSignatures = ( fields.map { with(it) { FieldBinarySignature(JvmFieldSignature(name, desc), isPublishedApi(), AccessFlags(access)) } } + methods.map { with(it) { MethodBinarySignature(JvmMethodSignature(name, desc), isPublishedApi(), AccessFlags(access)) } } ).filter { it.isEffectivelyPublic(classAccess, mVisibility) } ClassBinarySignature(name, superName, outerClassName, supertypes, memberSignatures, classAccess, isEffectivelyPublic(mVisibility), metadata.isFileOrMultipartFacade() || isDefaultImpls(metadata) } }</code> </pre> <br><p> 收到<code>ClassBinarySignature</code>列表后，您可以使用<code>dump(to: Appendable)</code>将其写入文件或内存，并将其与基线进行比较，这在<code>RuntimePublicAPITest</code>测试中会发生： </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RuntimePublicAPITest</span></span></span><span class="hljs-class"> </span></span>{ @[Rule JvmField] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testName = TestName() <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kotlinStdlibRuntimeMerged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { snapshotAPIAndCompare(<span class="hljs-string"><span class="hljs-string">"../../stdlib/jvm/build/libs"</span></span>, <span class="hljs-string"><span class="hljs-string">"kotlin-stdlib"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">snapshotAPIAndCompare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( basePath: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, jarPattern: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, publicPackages: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; = emptyList()</span></span></span></span>, nonPublicPackages: List&lt;String&gt; = emptyList() ) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> base = File(basePath).absoluteFile.normalize() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> jarFile = getJarPath(base, jarPattern, System.getProperty(<span class="hljs-string"><span class="hljs-string">"kotlinVersion"</span></span>)) println(<span class="hljs-string"><span class="hljs-string">"Reading binary API from </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$jarFile</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> api = getBinaryAPI(JarFile(jarFile)).filterOutNonPublic(nonPublicPackages) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> target = File(<span class="hljs-string"><span class="hljs-string">"reference-public-api"</span></span>) .resolve(testName.methodName.replaceCamelCaseWithDashedLowerCase() + <span class="hljs-string"><span class="hljs-string">".txt"</span></span>) api.dumpAndCompareWith(target) }</code> </pre> <br><p> 通过提交新的基准，我们以可读格式获得更改，例如，在此<a href="https://github.com/badoo/Reaktive/pull/312/commits/c8985c15d24346ecfe89cb2ac84fbe7cf6cbeb3e">commit中</a> ： </p><br><pre> <code class="diff hljs"> public static final fun flattenObservable (Lcom/badoo/reaktive/single/Single;)Lcom/badoo/reaktive/observable/Observable; } + public final class com/badoo/reaktive/single/MapIterableKt { + public static final fun mapIterable (Lcom/badoo/reaktive/single/Single;Lkotlin/jvm/functions/Function1;)Lcom/badoo/reaktive/single/Single; + public static final fun mapIterableTo (Lcom/badoo/reaktive/single/Single;Lkotlin/jvm/functions/Function0;Lkotlin/jvm/functions/Function1;)Lcom/badoo/reaktive/single/Single; + } public final class com/badoo/reaktive/single/MapKt {</code> </pre> <br><h2 id="ispolzovanie-validatora-v-svoyom-proekte"> 在项目中使用验证器 </h2><br><p> 使用非常简单。 将<code>binary-compatibility-validator</code>复制到您的项目中，并更改其<code>build.gradle</code>和<code>RuntimePublicAPITest</code> ： </p><br><pre> <code class="kotlin hljs">plugins { id(<span class="hljs-string"><span class="hljs-string">"org.jetbrains.kotlin.jvm"</span></span>) } dependencies { implementation(Deps.asm) implementation(Deps.asm.tree) implementation(Deps.kotlinx.metadata.jvm) testImplementation(Deps.kotlin.test.junit) } tasks.named(<span class="hljs-string"><span class="hljs-string">"test"</span></span>, Test::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      ,   -     Gradle       : dependsOn( ":coroutines-interop:jvmJar", ":reaktive-annotations:jvmJar", ":reaktive:jvmJar", ":reaktive-annotations:jvmJar", ":reaktive-testing:jvmJar", ":rxjava2-interop:jar", ":rxjava3-interop:jar", ":utils:jvmJar" ) //    ,          baseline-: outputs.upToDateWhen { false } //    systemProperty("overwrite.output", findProperty("binary-compatibility-override") ?: "true") systemProperty("kotlinVersion", findProperty("reaktive_version").toString()) systemProperty("testCasesClassesDirs", sourceSets.test.get().output.classesDirs.asPath) jvmArgs("-ea") }</span></span></code> </pre> <br><p> 在我们的例子中， <code>RuntimePublicAPITest</code>文件的测试功能之一如下所示： </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reaktive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { snapshotAPIAndCompare(<span class="hljs-string"><span class="hljs-string">"../../reaktive/build/libs"</span></span>, <span class="hljs-string"><span class="hljs-string">"reaktive-jvm"</span></span>) }</code> </pre> <br><p> 现在，对于每个请求请求，运行<code>./gradlew :tools:binary-compatibility:test -Pbinary-compatibility-override=false</code>并强制开发人员及时更新基线文件。 </p><br><h2 id="lozhka-dyogtya"> 美中不足 </h2><br><p> 但是，这种方法有一些缺点。 </p><br><p> 首先，我们必须独立分析对基准文件的更改。 它们的更改并非总是会导致二进制不兼容。 例如，如果实现一个新接口，则基线会有这样的差异： </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- public final class com/test/A { + public final class com/test/A : Comparable {</span></span></code> </pre> <br><p> 其次，使用了非预期的工具。 测试不应以将某些文件写入磁盘的形式产生副作用，该文件随后将由同一测试使用，甚至更重要的是，通过环境变量将参数传递给该文件。 最好在Gradle插件中使用此工具并使用任务创建基准。 但我真的不想在验证器中自行更改某些内容，以便以后可以很轻松地从Kotlin存储库中提取所有更改，因为将来将来可能会需要支持这种语言的新构造出现。 </p><br><p> 第三，仅支持JVM。 </p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 使用<a href="https://github.com/jetBrains/kotlin/tree/master/libraries/tools/binary-compatibility-validator">二进制兼容性检查器，</a>您可以实现二进制兼容性并及时响应其状态更改。 要在项目中使用它，仅需更改两个文件并将测试连接到我们的CI。 该解决方案有一些缺点，但是使用起来还是很方便的。 现在，Reaktive将尝试以与JetBrains对Kotlin标准库相同的方式维护JVM的二进制兼容性。 </p><br><p> 感谢您的关注！ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN484712/">https://habr.com/ru/post/zh-CN484712/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN484700/index.html">Java 14：记录预览</a></li>
<li><a href="../zh-CN484702/index.html">2020年的Prestashop替代品：顶级电子商务平台</a></li>
<li><a href="../zh-CN484706/index.html">练习使用Redd综合工厂的定制轮胎</a></li>
<li><a href="../zh-CN484708/index.html">理查德·汉明 “不存在的章节”：我们如何知道我们所知道的（完整版本）</a></li>
<li><a href="../zh-CN484710/index.html">打破统一垃圾收集规则</a></li>
<li><a href="../zh-CN484716/index.html">停止调用一切AI</a></li>
<li><a href="../zh-CN484718/index.html">HP现代打印机拒绝不使用墨水而无法工作</a></li>
<li><a href="../zh-CN484720/index.html">带管弦乐队的城市音乐会：谁和为什么录制日常生活的声音</a></li>
<li><a href="../zh-CN484722/index.html">哪种Ruby on Rails开发工具适合您的项目：2020年顶级Ruby on Rails宝石</a></li>
<li><a href="../zh-CN484724/index.html">来自世界开放地图494号的新闻（12.31.2019-06.01.2020）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>