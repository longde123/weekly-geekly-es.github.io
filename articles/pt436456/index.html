<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üß¢ üí¢ ü•™ Crie um efeito de distribui√ß√£o de cores no Unity ü§≤üèΩ ü§òüèº üòÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este efeito foi inspirado no epis√≥dio de Powerpuff Girls . Eu queria criar o efeito da propaga√ß√£o da cor em um mundo preto e branco, mas implement√°-lo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Crie um efeito de distribui√ß√£o de cores no Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436456/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ia/i5/in/iai5inmdx06iz81yoz8pu_2oyui.gif"></div><br>  Este efeito foi inspirado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">epis√≥dio de Powerpuff Girls</a> .  Eu queria criar o efeito da propaga√ß√£o da cor em um mundo preto e branco, mas <strong>implement√°-lo nas coordenadas do espa√ßo mundial</strong> , para ver como a <strong>cor pinta objetos</strong> , e n√£o apenas espalhar-se na tela, como em um desenho animado. <br><br>  Criei o efeito no novo <strong>Lightweight Rendering Pipeline do</strong> mecanismo Unity, um exemplo interno do pipeline Scriptable Rendering Pipeline.  Todos os conceitos se aplicam a outros pipelines, mas algumas fun√ß√µes ou matrizes internas podem ter nomes diferentes.  Tamb√©m usei a nova pilha de p√≥s-processamento, mas no tutorial vou omitir uma descri√ß√£o detalhada de suas configura√ß√µes, porque ela √© descrita muito bem em outros manuais, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste v√≠deo</a> . <br><a name="habracut"></a><br><hr><br><h1>  O efeito do p√≥s-processamento em escala de cinza </h1><br>  Apenas para refer√™ncia, √© assim que uma cena se parece sem efeitos de p√≥s-processamento. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43b/283/6ad/43b2836ad62ee59df7efdd98494d0140.png"></div><br>  Para esse efeito, usei o novo pacote de p√≥s-processamento do Unity 2018, que pode ser baixado do gerenciador de pacotes.  Se voc√™ n√£o sabe como us√°-lo, recomendo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este tutorial</a> . <br><br>  Eu escrevi meu pr√≥prio efeito estendendo as classes PostProcessingEffectSettings e PostProcessEffectRenderer escritas em C #, cujo c√≥digo-fonte pode ser visto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Na verdade, eu n√£o fiz nada de particularmente interessante com esses efeitos no lado da CPU (no c√≥digo C #), exceto que adicionei um grupo de propriedades gerais ao Inspector, por isso n√£o explicarei como fazer isso no tutorial.  Espero que meu c√≥digo fale por si. <br><br>  Vamos passar para o c√≥digo do sombreador e come√ßar com o efeito de escala de cinza.  No tutorial, n√£o modificaremos o arquivo shaderlab, as estruturas de entrada e o shader de v√©rtice, para que voc√™ possa ver o c√≥digo fonte <a href="">aqui</a> .  Em vez disso, cuidaremos do shader de fragmento. <br><br>  Para converter uma cor em uma escala de cinza, <strong>reduzimos o valor de cada pixel para um valor de lumin√¢ncia</strong> que descreve seu <strong>brilho</strong> .  Isso pode ser feito considerando o produto escalar do <strong>valor de cor da textura da c√¢mera</strong> e o <strong>vetor ponderado</strong> , que descreve a contribui√ß√£o de cada canal de cor para o brilho geral da cor. <br><br>  <strong>Por que usamos produtos escalares?</strong>  N√£o esque√ßa que os produtos escalares s√£o calculados da seguinte maneira: <br><br> <code>dot(a, b) = a <sub>x</sub> * b <sub>x</sub> + a <sub>y</sub> * b <sub>y</sub> + a <sub>z</sub> * b <sub>z</sub></code> <br> <br>  Nesse caso, multiplicamos cada canal do <strong>valor da cor</strong> por <strong>peso</strong> .  Em seguida, adicionamos esses produtos para reduzi-los a um √∫nico valor escalar.  Quando a cor RGB possui os mesmos valores nos canais R, G e B, a cor fica cinza. <br><br>  Aqui est√° a apar√™ncia do c√≥digo shader: <br><br><pre> <code class="cpp hljs">float4 fullColor = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.screenPos); float3 weight = float3(<span class="hljs-number"><span class="hljs-number">0.299</span></span>, <span class="hljs-number"><span class="hljs-number">0.587</span></span>, <span class="hljs-number"><span class="hljs-number">0.114</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> luminance = dot(fullColor.rgb, weight); float3 greyscale = luminance.xxx; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float4(greyscale, <span class="hljs-number"><span class="hljs-number">1.0</span></span>);</code> </pre> <br>  Se o sombreador base estiver configurado corretamente, o efeito de p√≥s-processamento dever√° colorir a tela inteira em escala de cinza. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/596/217/fc5/596217fc5e9caed9176480f1f9eb2bb1.png"></div><br><hr><br><h1>  Renderizando efeito de cor no espa√ßo do mundo </h1><br>  Como esse √© um efeito de p√≥s-processamento, <strong>n√£o temos informa√ß√µes sobre a geometria da</strong> cena no sombreador de v√©rtices.  No est√°gio de p√≥s-processamento, a √∫nica informa√ß√£o que temos √© a <strong>imagem renderizada pela c√¢mera</strong> e o <strong>espa√ßo das coordenadas truncadas</strong> para amostr√°-la.  No entanto, queremos que o efeito de colora√ß√£o se espalhe pelos objetos, como se estivesse acontecendo no mundo, e n√£o apenas em uma tela plana. <br><br>  Para desenhar esse efeito na geometria da cena, precisamos das <strong>coordenadas do espa√ßo mundial de</strong> cada pixel.  Para passar das <strong>coordenadas do espa√ßo de coordenadas truncadas</strong> para as <strong>coordenadas do espa√ßo mundial</strong> , precisamos realizar uma <strong>transforma√ß√£o do espa√ßo de coordenadas</strong> . <br><br>  Normalmente, para ir de um espa√ßo de coordenadas para outro, √© necess√°ria uma matriz que defina a transforma√ß√£o do espa√ßo de coordenadas A para o espa√ßo B. Para ir de A para B, multiplicamos o vetor no espa√ßo de coordenadas A por essa matriz de transforma√ß√£o.  No nosso caso, realizaremos a seguinte transi√ß√£o: o <strong>espa√ßo das coordenadas truncadas (espa√ßo do clipe)</strong> -&gt; <strong>ver espa√ßo (ver espa√ßo)</strong> -&gt; <strong>espa√ßo do mundo (espa√ßo do mundo)</strong> .  Ou seja, precisamos da matriz clip-to-view-space e da matriz view-to-world-space que o Unity fornece. <br><br>  No entanto, as <strong>coordenadas da unidade do espa√ßo de coordenadas truncadas n√£o t√™m um valor z</strong> que determina a profundidade do pixel ou a dist√¢ncia da c√¢mera.  Precisamos desse valor para passar do espa√ßo de coordenadas truncadas para o espa√ßo de esp√©cies.  Vamos come√ßar com isso! <br><br><h2>  Obtendo o valor do buffer de profundidade </h2><br>  Se o pipeline de renderiza√ß√£o estiver ativado, ele desenha uma textura na <strong>viewport</strong> que armazena <strong>os valores z</strong> em uma estrutura chamada <strong>buffer de profundidade</strong> .  Podemos amostrar esse buffer para obter o <strong>valor z</strong> ausente <strong>do</strong> nosso espa√ßo de coordenadas de coordenadas truncadas! <br><br>  Primeiro, verifique se o <strong>buffer de profundidade √©</strong> realmente renderizado clicando na se√ß√£o "Adicionar dados adicionais" da c√¢mera no Inspetor e verificando se a caixa "Requer textura de profundidade" est√° marcada.  Verifique tamb√©m se a op√ß√£o Permitir MSAA est√° ativada para a c√¢mera.  N√£o sei por que esse efeito precisa ser verificado, mas √©.  Se o buffer de profundidade for desenhado, no <strong>depurador de quadros,</strong> voc√™ dever√° ver o est√°gio <strong>"Depth Prepass"</strong> . <br><br>  Crie um amostrador _CameraDepthTexture no <strong>arquivo hlsl</strong> <br><br><pre> <code class="cpp hljs">TEXTURE2D_SAMPLER2D(_CameraDepthTexture, sampler_CameraDepthTexture);</code> </pre> <br>  Agora vamos escrever a fun√ß√£o GetWorldFromViewPosition e, por enquanto, vamos us√°-la para verificar <strong>o buffer de profundidade</strong> .  (Mais tarde expandiremos para obter uma posi√ß√£o no mundo.) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWorldFromViewPosition</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VertexOutput i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> z = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, sampler_CameraDepthTexture, i.screenPos).r; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> z.xxx; }</code> </pre> <br>  No sombreador de fragmento, desenhe o valor da amostra de textura de profundidade. <br><br><pre> <code class="cpp hljs">float3 depth = GetWorldFromViewPosition(i); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float4(depth, <span class="hljs-number"><span class="hljs-number">1.0</span></span>);</code> </pre> <br>  √â assim que meus resultados se parecem quando h√° apenas uma plan√≠cie montanhosa na cena (desliguei todas as √°rvores para simplificar ainda mais o teste dos valores do espa√ßo mundial).  Seu resultado deve ser semelhante.  Os valores em preto e branco descrevem a dist√¢ncia da geometria √† c√¢mera. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b10/6b6/5cc/b106b65cc3d1441aacd5042ee21b25a6.png"></div><br>  Aqui est√£o algumas etapas que voc√™ pode executar se encontrar problemas: <br><br><ul><li>  Verifique se a c√¢mera possui a renderiza√ß√£o em profundidade ativada. </li><li>  Verifique se a c√¢mera possui o MSAA ativado. </li><li>  Tente alterar o plano pr√≥ximo e distante da c√¢mera. </li><li>  Verifique se os objetos que voc√™ espera ver no buffer de profundidade usam um sombreador com um passe de profundidade.  Isso garante que o objeto seja atra√≠do para o buffer de profundidade.  Todos os shaders padr√£o no LWRP fazem isso. </li></ul><br><h2>  Obtendo valor no espa√ßo mundial </h2><br>  Agora que temos todas as informa√ß√µes necess√°rias para o <strong>espa√ßo de coordenadas truncadas</strong> , vamos transformar no <strong>espa√ßo de esp√©cies</strong> e depois no <strong>espa√ßo</strong> do <strong>mundo</strong> . <br><br>  Observe que as matrizes de transforma√ß√£o necess√°rias para essas opera√ß√µes j√° est√£o na biblioteca SRP.  No entanto, eles est√£o contidos na biblioteca C # do mecanismo do Unity, ent√£o os inseri no sombreador na fun√ß√£o Render do script <a href="">ColorSpreadRenderer</a> : <br><br><pre> <code class="cpp hljs">sheet.properties.SetMatrix(<span class="hljs-string"><span class="hljs-string">"unity_ViewToWorldMatrix"</span></span>, context.camera.cameraToWorldMatrix); sheet.properties.SetMatrix(<span class="hljs-string"><span class="hljs-string">"unity_InverseProjectionMatrix"</span></span>, projectionMatrix.inverse);</code> </pre> <br>  Agora vamos estender nossa fun√ß√£o GetWorldFromViewPosition. <br><br>  Primeiro, precisamos obter a posi√ß√£o na viewport <strong>multiplicando a posi√ß√£o no espa√ßo de coordenadas truncado pelo InverseProjectionMatrix</strong> .  Tamb√©m precisamos fazer um pouco mais de magia vodu com uma posi√ß√£o na tela, relacionada √† forma como o Unity armazena sua posi√ß√£o no espa√ßo de coordenadas truncadas. <br><br>  Finalmente, podemos <strong>multiplicar a posi√ß√£o na janela de exibi√ß√£o por ViewToWorldMatrix</strong> para obter a posi√ß√£o no <strong>espa√ßo do mundo</strong> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWorldFromViewPosition</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VertexOutput i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    float z = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, sampler_CameraDepthTexture, i.screenPos).r; //      float4 result = mul(unity_InverseProjectionMatrix, float4(2*i.screenPos-1.0, z, 1.0)); float3 viewPos = result.xyz / result.w; //      float3 worldPos = mul(unity_ViewToWorldMatrix, float4(viewPos, 1.0)); return worldPos; }</span></span></code> </pre> <br>  Vamos fazer uma verifica√ß√£o para garantir que as posi√ß√µes no espa√ßo global estejam corretas.  Para fazer isso, escrevi um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sombreador</a> que retorna apenas a posi√ß√£o de um objeto no <strong>espa√ßo do mundo</strong> ;  esse √© um c√°lculo bastante simples, baseado em um sombreador regular, cuja corre√ß√£o pode ser confi√°vel.  Desative o efeito do p√≥s-processamento e fa√ßa uma captura de tela deste shader de teste para o <strong>espa√ßo mundial</strong> .  Meu depois de aplicar o shader na superf√≠cie da terra na cena √© assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a91/4f2/b78/a914f2b787501e385ef27746865429bd.png"></div><br>  (Observe que os valores no espa√ßo mundial s√£o muito maiores que 1,0, portanto, n√£o se preocupe, pois essas cores fazem algum sentido; em vez disso, verifique se os resultados s√£o os mesmos para as respostas "verdadeiras" e "calculadas".) Em seguida, voltemos ao teste o objeto √© material comum (e n√£o o material de teste do espa√ßo mundial) e, em seguida, ative o efeito de p√≥s-processamento novamente.  Meus resultados s√£o assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9e/deb/7ce/f9edeb7cea30fb33b72705a568264638.png"></div><br>  Isso √© completamente semelhante ao shader de teste que escrevi, ou seja, √© prov√°vel que os c√°lculos do espa√ßo mundial estejam corretos! <br><br><h2>  Desenhando um c√≠rculo no espa√ßo do mundo </h2><br>  Agora que temos <strong>posi√ß√µes no espa√ßo do mundo</strong> , podemos desenhar um c√≠rculo de cores na cena!  Precisamos definir o <strong>raio</strong> dentro do qual o efeito desenhar√° cor.  L√° fora, o efeito renderizar√° a imagem em escala de cinza.  Para defini-lo, voc√™ precisa ajustar os valores <strong>do raio do</strong> efeito ( <strong>_MaxSize</strong> ) e do centro do c√≠rculo (_Center).  <a href="">Defino</a> esses valores na classe C # <a href="">ColorSpread</a> para que sejam vis√≠veis no inspetor.  Vamos expandir nosso shader de fragmento for√ßando-o <strong>a verificar se o pixel atual est√° dentro do raio do c√≠rculo</strong> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VertexOutput i)</span></span></span><span class="hljs-function"> : SV_Target </span></span>{ float3 worldPos = GetWorldFromViewPosition(i); <span class="hljs-comment"><span class="hljs-comment">// ,      .  //   ,   ,  ,   float dist = distance(_Center, worldPos); float blend = dist &lt;= _MaxSize? 0 : 1; //   float4 fullColor = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.screenPos); //   float luminance = dot(fullColor.rgb, float3(0.2126729, 0.7151522, 0.0721750)); float3 greyscale = luminance.xxx; // ,       float3 color = (1-blend)*fullColor + blend*greyscale; return float4(color, 1.0); }</span></span></code> </pre> <br>  Finalmente, podemos desenhar a cor com base em se ela est√° dentro de um <strong>raio</strong> no <strong>espa√ßo do mundo</strong> .  √â assim que o efeito base se parece! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/983/6be/fb0/9836befb050f5a354b1eb4e6faee50d5.png"></div><br><hr><br><h1>  Adicionando efeitos especiais </h1><br>  Vou examinar mais algumas t√©cnicas usadas para fazer a cor se espalhar pelo ch√£o.  H√° muito mais para o efeito total, mas o tutorial j√° se tornou muito grande, portanto, nos limitaremos ao mais importante. <br><br><h2>  Anima√ß√£o de amplia√ß√£o do c√≠rculo </h2><br>  Queremos que o efeito se espalhe pelo mundo, isto √©, como se estivesse crescendo.  Para fazer isso, voc√™ precisa alterar o <strong>raio,</strong> dependendo da hora. <br><br>  _StartTime indica a hora em que o c√≠rculo deve come√ßar a crescer.  No meu projeto, usei um script adicional que permite clicar em qualquer lugar da tela para iniciar o crescimento do c√≠rculo;  nesse caso, a hora de in√≠cio √© igual √† hora em que o mouse foi clicado. <br><br>  _GrowthSpeed ‚Äã‚Äãdefine a velocidade do aumento do c√≠rculo. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//           float timeElapsed = _Time.y - _StartTime; float effectRadius = min(timeElapsed * _GrowthSpeed, _MaxSize); //  ,      effectRadius = clamp(effectRadius, 0, _MaxSize);</span></span></code> </pre> <br>  Tamb√©m precisamos atualizar a verifica√ß√£o de dist√¢ncia para comparar a dist√¢ncia atual com o <strong>raio</strong> crescente <strong>do efeito</strong> , e n√£o com _MaxSize. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ,         //   ,   ,  ,   float dist = distance(_Center, worldPos); float blend = dist &lt;= effectRadius? 0 : 1; //     ...</span></span></code> </pre> <br>  Aqui est√° como deve ser o resultado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecb/3bc/761/ecb3bc76112c56270745db56f2272e7c.gif"></div><br><h2>  Adicionando ao raio do ru√≠do </h2><br>  Eu queria que o efeito fosse mais como um borr√£o de tinta, n√£o apenas um c√≠rculo crescente.  Para fazer isso, vamos <strong>adicionar ru√≠do ao raio do efeito,</strong> para que a distribui√ß√£o seja desigual. <br><br>  Primeiro, precisamos provar a textura no <strong>espa√ßo do mundo</strong> .  As coordenadas UV do i.screenPos est√£o localizadas no <strong>espa√ßo</strong> da <strong>tela</strong> e, se fizermos uma amostra com base nelas, a forma do efeito se mover√° com a c√¢mera;  ent√£o vamos usar as coordenadas no <strong>espa√ßo do mundo</strong> .  <strong>Adicionei o</strong> par√¢metro <strong>_NoiseTexScale</strong> para controlar a <strong>escala da amostra de textura de ru√≠do</strong> , porque as coordenadas no espa√ßo do mundo s√£o muito grandes. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//          float2 worldUV = worldPos.xz; worldUV *= _NoiseTexScale;</span></span></code> </pre> <br>  Agora vamos provar a textura do ru√≠do e adicionar esse valor ao raio do efeito.  Usei a escala _NoiseSize para ter mais controle sobre o tamanho do ru√≠do. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     float noise = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, worldUV).r; effectRadius -= noise * _NoiseSize;</span></span></code> </pre> <br>  A seguir, como s√£o os resultados ap√≥s alguns ajustes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51f/b77/f57/51fb77f570eb4ba77fa4e8eaa8cadb20.gif"></div><br><hr><br><h1>  Em conclus√£o </h1><br>  Voc√™ pode acompanhar as atualiza√ß√µes dos tutoriais no meu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Twitter</a> e no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Twitch</a> eu gasto codifica√ß√£o de streams!  (Al√©m disso, eu transmito jogos de vez em quando, ent√£o n√£o se surpreenda se voc√™ me ver sentada de pijama e jogando Kingdom Hearts 3.) <br><br>  Agradecimentos: <br><br><ul><li>  Todos os modelos de projeto s√£o obtidos neste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LowPoly Environment Pack</a> da loja Unity. </li><li>  <a href="">O efeito ScreenSpaceReflections do mecanismo Unity</a> realmente me ajudou a descobrir como obter uma posi√ß√£o tridimensional na janela de exibi√ß√£o a partir das coordenadas UV bidimensionais do espa√ßo da tela. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt436456/">https://habr.com/ru/post/pt436456/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt436444/index.html">Implanta√ß√£o invis√≠vel de um aplicativo monol√≠tico em produ√ß√£o na AWS. Experi√™ncia pessoal</a></li>
<li><a href="../pt436448/index.html">Analise o monitor IPS de 27 ‚ÄùAcer HA270bid: para auto-aperfei√ßoamento</a></li>
<li><a href="../pt436450/index.html">Controle remoto, liberdade e governo. Conversa com Staply</a></li>
<li><a href="../pt436452/index.html">7 √°reas de desenvolvimento Linux em 2019</a></li>
<li><a href="../pt436454/index.html">Perguntas e respostas sobre JavaScript</a></li>
<li><a href="../pt436458/index.html">Progresso e hype na pesquisa ai</a></li>
<li><a href="../pt436460/index.html">A escolha da tecnologia, arquitetura e design em projetos de software - sem dinheiro</a></li>
<li><a href="../pt436464/index.html">2. An√°lise do log de ponto de verifica√ß√£o: SmartEvent</a></li>
<li><a href="../pt436466/index.html">Electron: desenvolvendo aplicativos de desktop usando HTML, CSS e JavaScript</a></li>
<li><a href="../pt436468/index.html">Experi√™ncia legislativa com inova√ß√£o digital</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>