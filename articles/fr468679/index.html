<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦔 ✅ 🧒🏾 L'ABC de la sécurité dans Kubernetes: authentification, autorisation, audit 🦉 👌🏽 🤶🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tôt ou tard, le fonctionnement de tout système pose la question de la sécurité: assurer l'authentification, la séparation des droits, l'audit et autre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>L'ABC de la sécurité dans Kubernetes: authentification, autorisation, audit</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/468679/"><img src="https://habrastorage.org/webt/ao/pp/ke/aoppkeeufk5-tv1rmtmtw9oce7a.png"><br><br>  Tôt ou tard, le fonctionnement de tout système pose la question de la sécurité: assurer l'authentification, la séparation des droits, l'audit et autres tâches.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">De nombreuses solutions</a> ont déjà été créées pour Kubernetes qui peuvent atteindre la conformité aux normes même dans des environnements très exigeants ... Le même matériel est consacré aux aspects de sécurité de base mis en œuvre dans le cadre des mécanismes intégrés de K8.  Tout d'abord, il sera utile pour ceux qui commencent à se familiariser avec Kubernetes, comme point de départ pour étudier les problèmes liés à la sécurité. <a name="habracut"></a><br><br><h2>  Authentification </h2><br>  Kubernetes a deux types d'utilisateurs: <br><br><ul><li>  <i>Comptes de service</i> - comptes gérés par l'API Kubernetes; </li><li>  <i>Utilisateurs</i> - <i>utilisateurs</i> «normaux» contrôlés par des services externes indépendants. </li></ul><br>  La principale différence entre ces types est que pour les comptes de service, il existe des objets spéciaux dans l'API Kubernetes (ils sont appelés <code>ServiceAccounts</code> ) qui sont liés à l'espace de noms et à l'ensemble de données d'autorisation stockées dans le cluster dans des objets de type Secrets.  Ces utilisateurs (comptes de service) sont principalement destinés à gérer les droits d'accès aux processus de l'API Kubernetes exécutés dans un cluster Kubernetes. <br><br>  Les utilisateurs ordinaires n'ont pas d'entrées dans l'API Kubernetes: elles doivent être gérées par des mécanismes externes.  Ils sont destinés aux personnes ou processus vivant en dehors du cluster. <br><br>  Chaque demande à l'API est liée soit au compte de service, soit à l'utilisateur, ou est considérée comme anonyme. <br><br>  Les données d'authentification des utilisateurs incluent: <br><br><ul><li>  <i>Nom d'utilisateur</i> - nom d'utilisateur (sensible à la casse!); </li><li>  <i>L'UID</i> est une chaîne d'identification d'utilisateur lisible par machine qui est «plus cohérente et unique que le nom d'utilisateur»; </li><li>  <i>Groupes</i> - une liste des groupes auxquels l'utilisateur appartient; </li><li>  <i>Extra</i> - champs supplémentaires pouvant être utilisés par le mécanisme d'autorisation. </li></ul><br>  Kubernetes peut utiliser un grand nombre de mécanismes d'authentification: certificats X509, jetons de support, procurations d'authentification, HTTP Basic Auth.  En utilisant ces mécanismes, un grand nombre de schémas d'autorisation peuvent être mis en œuvre: d'un fichier statique avec des mots de passe à OpenID OAuth2. <br><br>  De plus, plusieurs régimes d'autorisation sont autorisés en même temps.  Par défaut, le cluster utilise: <br><br><ul><li>  jetons de compte de service - pour les comptes de service; </li><li>  X509 - pour les utilisateurs. </li></ul><br>  La question sur la gestion des ServiceAccounts dépasse le cadre de cet article, mais je recommande de commencer à en savoir plus sur ce problème à partir de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">page de documentation officielle</a> .  Nous examinerons plus en détail la question du travail des certificats X509. <br><br><h3>  Certificats pour les utilisateurs (X.509) </h3><br>  La manière classique de travailler avec des certificats implique: <br><br><ul><li>  génération de clés: <br><br><pre> <code class="bash hljs">mkdir -p ~/mynewuser/.certs/ openssl genrsa -out ~/.certs/mynewuser.key 2048</code> </pre> </li><li>  génération de demande de certificat: <br><br><pre> <code class="bash hljs">openssl req -new -key ~/.certs/mynewuser.key -out ~/.certs/mynewuser.csr -subj <span class="hljs-string"><span class="hljs-string">"/CN=mynewuser/O=company"</span></span></code> </pre> </li><li>  traitement de la demande de certificat à l'aide des clés d'autorité de certification du cluster Kubernetes, obtention d'un certificat utilisateur (pour obtenir un certificat, vous devez utiliser un compte qui a accès à la clé d'autorité de certification du cluster Kubernetes, qui se trouve dans <code>/etc/kubernetes/pki/ca.key</code> par défaut): <br><br><pre> <code class="bash hljs">openssl x509 -req -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ~/.certs/mynewuser.csr -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial -out ~/.certs/mynewuser.crt -days 500</code> </pre> </li><li>  création d'un fichier de configuration: <br><ul><li>  description du cluster (spécifiez l'adresse et l'emplacement du fichier de certificat CA de l'installation de cluster particulière): <br><br><pre> <code class="bash hljs">kubectl config <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-cluster kubernetes --certificate-authority=/etc/kubernetes/pki/ca.crt --server=https://192.168.100.200:6443</code> </pre> </li><li>  ou - si ce <b>n'est pas l'</b> option recommandée - vous pouvez omettre le certificat racine (alors kubectl ne vérifiera pas l'exactitude du cluster api-server): <br><br><pre> <code class="bash hljs">kubectl config <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-cluster kubernetes --insecure-skip-tls-verify=<span class="hljs-literal"><span class="hljs-literal">true</span></span> --server=https://192.168.100.200:6443</code> </pre> </li><li>  ajout d'un utilisateur au fichier de configuration: <br><br><pre> <code class="bash hljs">kubectl config <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-credentials mynewuser --client-certificate=.certs/mynewuser.crt --client-key=.certs/mynewuser.key</code> </pre> </li><li>  ajout de contexte: <br><br><pre> <code class="bash hljs">kubectl config <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-context mynewuser-context --cluster=kubernetes --namespace=target-namespace --user=mynewuser</code> </pre> </li><li>  affectation de contexte par défaut: <br><br><pre> <code class="bash hljs">kubectl config use-context mynewuser-context</code> </pre> </li></ul></li></ul><br>  Après les manipulations ci-dessus, une configuration du formulaire sera créée dans le fichier <code>.kube/config</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: v1 clusters: - cluster: certificate-authority: /etc/kubernetes/pki/ca.crt server: https://192.168.100.200:6443 name: kubernetes contexts: - context: cluster: kubernetes namespace: target-namespace user: mynewuser name: mynewuser-context current-context: mynewuser-context kind: Config preferences: {} users: - name: mynewuser user: client-certificate: /home/mynewuser/.certs/mynewuser.crt client-key: /home/mynewuser/.certs/mynewuser.key</code> </pre> <br>  Pour faciliter le transfert de la configuration entre les comptes et les serveurs, il est utile de modifier les valeurs des clés suivantes: <br><br><ul><li> <code>certificate-authority</code> </li> <li> <code>client-certificate</code> </li> <li> <code>client-key</code> </li> </ul><br>  Pour ce faire, vous pouvez encoder les fichiers qui y sont indiqués en utilisant base64 et les enregistrer dans la configuration en ajoutant le suffixe <code>-data</code> au nom des clés, c'est-à-dire  obtenir <code>certificate-authority-data</code> , etc. <br><br><h3>  Certificats avec kubeadm </h3><br>  Avec la sortie de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kubernetes 1.15,</a> travailler avec des certificats est devenu beaucoup plus facile grâce à la version alpha de son support dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'utilitaire kubeadm</a> .  Par exemple, voici à quoi pourrait ressembler la génération d'un fichier de configuration avec des clés utilisateur: <br><br><pre> <code class="bash hljs">kubeadm alpha kubeconfig user --client-name=mynewuser --apiserver-advertise-address 192.168.100.200</code> </pre> <br>  <i><b>NB</b> : L' <i>adresse de publicité</i> requise peut être consultée dans la configuration d'api-server, qui se trouve par défaut dans <code>/etc/kubernetes/manifests/kube-apiserver.yaml</code> .</i> <br><br>  La configuration résultante sera sortie sur stdout.  Il doit être enregistré dans <code>~/.kube/config</code> compte utilisateur ou dans le fichier spécifié dans la <code>KUBECONFIG</code> environnement <code>KUBECONFIG</code> . <br><br><h3>  Creusez plus profondément </h3><br>  Pour ceux qui souhaitent bien comprendre les problèmes décrits: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article séparé</a> sur l'utilisation des certificats dans la documentation officielle de Kubernetes; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un bon article de Bitnami</a> , qui aborde la question des certificats d'un point de vue pratique. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation générale d'</a> authentification dans Kubernetes. </li></ul><br><h2>  Se connecter </h2><br>  Un compte authentifié n'est pas autorisé à agir dans un cluster par défaut.  Kubernetes dispose d'un mécanisme d'autorisation pour accorder des autorisations. <br><br>  Avant la version 1.6, Kubernetes utilisait un type d'authentification appelé <b>ABAC</b> (contrôle d'accès basé sur les attributs).  Des détails à ce sujet peuvent être trouvés dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation officielle</a> .  Cette approche est actuellement considérée comme héritée, mais vous pouvez toujours l'utiliser en même temps que d'autres types d'autorisation. <br><br>  La façon actuelle (et plus flexible) de diviser les droits d'accès aux clusters est appelée <b>RBAC</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">contrôle d'accès basé sur les rôles</a> ).  Il a été déclaré stable depuis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kubernetes 1.8</a> .  RBAC met en œuvre un modèle de droits qui interdit tout ce qui n'est pas explicitement autorisé. <br>  <b>Pour activer RBAC</b> , vous devez exécuter Kubernetes api-server avec l' <code>--authorization-mode=RBAC</code> .  Les paramètres sont définis dans le manifeste avec la configuration api-server, qui par défaut se trouve sur le chemin <code>/etc/kubernetes/manifests/kube-apiserver.yaml</code> , dans la section des <code>command</code> .  Cependant, RBAC est déjà activé par défaut, vous ne devriez donc pas vous en soucier: vous pouvez le vérifier par la valeur du <code>authorization-mode</code> d' <code>authorization-mode</code> (dans le <code>kube-apiserver.yaml</code> déjà mentionné).  Soit dit en passant, parmi ses valeurs, il peut y avoir d'autres types d'autorisation ( <code>node</code> , <code>webhook</code> , <code>always allow</code> ), mais nous les laisserons en dehors de la portée du matériel. <br><br>  Soit dit en passant, nous avons déjà publié <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article</a> avec une histoire assez détaillée sur les principes et les caractéristiques de travailler avec RBAC, donc je me limiterai à une brève liste des bases et des exemples. <br><br>  Les entités API suivantes sont utilisées pour contrôler l'accès à Kubernetes via RBAC: <br><br><ul><li>  <code>Role</code> et <code>ClusterRole</code> sont des rôles qui décrivent les privilèges: </li><li>  <code>Role</code> vous permet de décrire les droits dans un espace de noms; </li><li>  <code>ClusterRole</code> - au sein du cluster, y compris les objets spécifiques au cluster tels que les nœuds, les URL non liées aux ressources (c'est-à-dire non liés aux ressources Kubernetes - par exemple, <code>/version</code> , <code>/logs</code> , <code>/api*</code> ); </li><li>  <code>RoleBinding</code> et <code>ClusterRoleBinding</code> - sert à lier <code>Role</code> et <code>ClusterRole</code> à un utilisateur, un groupe d'utilisateurs ou un ServiceAccount. </li></ul><br>  Le rôle des entités et la liaison de rôles sont limités par l'espace de noms, c'est-à-dire  doit être dans le même espace de noms.  Cependant, RoleBinding peut faire référence à ClusterRole, qui vous permet de créer un ensemble d'autorisations standard et de contrôler l'accès à l'aide de celles-ci. <br><br>  Les rôles décrivent les droits à l'aide d'ensembles de règles contenant: <br><br><ul><li>  Groupes d'API - voir la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation officielle</a> des apiGroups et la sortie des <code>kubectl api-resources</code> de <code>kubectl api-resources</code> ; </li><li>  ressources ( <i>ressources</i> : <code>pod</code> , <code>namespace</code> , <code>deployment</code> , etc.); </li><li>  verbes ( <i>verbes</i> : <code>set</code> , <code>update</code> , etc.). </li><li>  noms de ressource ( <code>resourceNames</code> ) - pour le cas où vous devez fournir un accès à une ressource spécifique, et non à toutes les ressources de ce type. </li></ul><br>  Une discussion plus détaillée de l'autorisation dans Kubernetes peut être trouvée sur la page de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> officielle.  Au lieu de cela (ou plutôt, en plus de cela), je donnerai des exemples qui illustrent son travail. <br><br><h3>  Exemples d'entités RBAC </h3><br>  Un <code>Role</code> simple qui vous permet d'obtenir la liste et l'état des pods et de les surveiller dans l' <code>target-namespace</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: target-namespace name: pod-reader rules: - apiGroups: [""] resources: ["pods"] verbs: ["get", "watch", "list"]</code> </pre> <br>  Un exemple de <code>ClusterRole</code> , qui vous permet d'obtenir une liste et l'état des pods et de les surveiller dans tout le cluster: <br><br><pre> <code class="plaintext hljs">apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: #  "namespace" ,   ClusterRole    name: pod-reader rules: - apiGroups: [""] resources: ["pods"] verbs: ["get", "watch", "list"]</code> </pre> <br>  Exemple <code>RoleBinding</code> , qui permet à l'utilisateur <code>mynewuser</code> "lire" des pods dans l' <code>my-namespace</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: read-pods namespace: target-namespace subjects: - kind: User name: mynewuser #     ! apiGroup: rbac.authorization.k8s.io roleRef: kind: Role #    “Role”  “ClusterRole” name: pod-reader #  Role,      namespace, #   ClusterRole,   #    apiGroup: rbac.authorization.k8s.io</code> </pre> <br><h2>  Audit d'événement </h2><br>  Schématiquement, l'architecture de Kubernetes peut être représentée comme suit: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/617/793/499/6177934998b4bf1c5c8816c75beaef3f.png" alt="image"><br><br>  Le composant clé de Kubernetes, qui est responsable du traitement des demandes, est <b>api-server</b> .  Toutes les opérations sur le cluster le traversent.  Pour en savoir plus sur ces mécanismes internes, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">consultez</a> l'article « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Que se passe-t-il dans Kubernetes lorsque l'exécution de kubectl démarre?</a>  ". <br><br>  L'audit système est une fonctionnalité intéressante de Kubernetes, qui est désactivée par défaut.  Il vous permet de consigner tous les appels vers l'API Kubernetes.  Comme vous pouvez facilement le deviner, grâce à cette API, toutes les actions liées à la surveillance et à la modification de l'état du cluster sont effectuées.  Une bonne description de ses fonctionnalités se trouve (comme d'habitude) dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation officielle de</a> K8s.  Ensuite, je vais essayer de présenter le sujet dans un langage plus simple. <br><br>  Donc, <b>pour activer l'audit</b> , nous devons passer trois paramètres requis au conteneur dans l'api-server, plus sur ce qui est décrit ci-dessous: <br><br><ul><li> <code>--audit-policy-file=/etc/kubernetes/policies/audit-policy.yaml</code> </li> <li> <code>--audit-log-path=/var/log/kube-audit/audit.log</code> </li> <li> <code>--audit-log-format=json</code> </li> </ul><br>  En plus de ces trois paramètres nécessaires, il existe de nombreux paramètres supplémentaires liés à l'audit: de la rotation des journaux aux descriptions des webhooks.  Exemples de paramètres de rotation des journaux: <br><br><ul><li> <code>--audit-log-maxbackup=10</code> </li> <li> <code>--audit-log-maxsize=100</code> </li> <li> <code>--audit-log-maxage=7</code> </li> </ul><br>  Mais nous ne nous attarderons pas sur eux plus en détail - vous pouvez trouver tous les détails dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation de kube-apiserver</a> . <br><br>  Comme déjà mentionné, tous les paramètres sont définis dans le manifeste avec la configuration api-server (par défaut <code>/etc/kubernetes/manifests/kube-apiserver.yaml</code> ), dans la section des <code>command</code> .  Revenons aux 3 paramètres requis et analysons-les: <br><br><ol><li>  <code>audit-policy-file</code> - chemin d'accès au fichier YAML avec la description de la politique d'audit.  Nous reviendrons sur son contenu, mais pour l'instant je note que le fichier doit être accessible à la lecture par le processus api-server.  Par conséquent, il est nécessaire de le monter à l'intérieur du conteneur, pour lequel vous pouvez ajouter le code suivant aux sections appropriées de la configuration: <br><br><pre> <code class="plaintext hljs"> volumeMounts: - mountPath: /etc/kubernetes/policies name: policies readOnly: true volumes: - hostPath: path: /etc/kubernetes/policies type: DirectoryOrCreate name: policies</code> </pre> </li><li>  <code>audit-log-path</code> - chemin d'accès au fichier journal.  Le chemin devrait également être accessible au processus api-server, par conséquent, nous décrivons de la même manière son montage: <br><br><pre> <code class="plaintext hljs"> volumeMounts: - mountPath: /var/log/kube-audit name: logs readOnly: false volumes: - hostPath: path: /var/log/kube-audit type: DirectoryOrCreate name: logs</code> </pre> </li><li>  <code>audit-log-format</code> - format du journal d'audit.  Par défaut, il s'agit de <code>json</code> , mais le format de texte hérité est également disponible. </li></ol><br><h3>  Politique d'audit </h3><br>  Maintenant sur le fichier mentionné avec la description de la politique de journalisation.  Le premier concept de politique d'audit est le <code>level</code> , le <b>niveau de journalisation</b> .  Ils sont les suivants: <br><br><ul><li>  <code>None</code> - ne vous connectez pas; </li><li>  <code>Metadata</code> - enregistrer les métadonnées de demande: utilisateur, heure de la demande, ressource cible (pod, espace de noms, etc.), type d'action (verbe), etc. </li><li>  <code>Request</code> - enregistrer les métadonnées et le corps de la demande; </li><li>  <code>RequestResponse</code> - <code>RequestResponse</code> métadonnées, le corps de la demande et le corps de la réponse. </li></ul><br>  Les deux derniers niveaux ( <code>Request</code> et <code>RequestResponse</code> ) <code>RequestResponse</code> pas les requêtes qui n'ont pas accédé aux ressources (appels à des URL dites non-ressources). <br><br>  De plus, toutes les demandes passent par <b>plusieurs étapes</b> : <br><br><ul><li>  <code>RequestReceived</code> - l'étape à laquelle la demande est reçue par le gestionnaire et n'a pas encore été transférée le long de la chaîne de gestionnaires; </li><li>  <code>ResponseStarted</code> - en-têtes de réponse envoyés, mais avant d'envoyer le corps de la réponse.  Généré pour les longues requêtes (par exemple, <code>watch</code> ); </li><li>  <code>ResponseComplete</code> - corps de réponse envoyé, plus d'informations ne seront pas envoyées; </li><li>  <code>Panic</code> - des événements sont générés lorsqu'une urgence est détectée. </li></ul><br>  Vous pouvez utiliser <code>omitStages</code> pour ignorer toutes les étapes. <br><br>  Dans le fichier de stratégie, nous pouvons décrire plusieurs sections avec différents niveaux de journalisation.  La première règle de correspondance trouvée dans la description de la politique s'applique. <br><br>  Le démon kubelet surveille la modification du manifeste avec la configuration du serveur api, et s'il en détecte, il redémarre le conteneur avec le serveur api.  Mais il y a un détail important: <b>ils ignoreront les modifications apportées au fichier de stratégie</b> .  Après avoir apporté des modifications au fichier de stratégie, vous devrez redémarrer manuellement api-server.  Étant donné qu'api-server fonctionne comme un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pod statique</a> , la commande <code>kubectl delete</code> ne le redémarrera pas.  Vous devrez manuellement <code>docker stop</code> Docker sur les maîtres de cube où la stratégie d'audit a été modifiée: <br><br><pre> <code class="bash hljs">docker stop $(docker ps | grep k8s_kube-apiserver | awk <span class="hljs-string"><span class="hljs-string">'{print $1}'</span></span>)</code> </pre> <br>  Lorsque vous activez l'audit, il est important de se rappeler que <b>kube-apiserver a une charge plus élevée</b> .  En particulier, la consommation de mémoire pour stocker le contexte des requêtes augmente.  La journalisation démarre uniquement après l'envoi de l'en-tête de réponse.  En outre, la charge dépend de la configuration de la stratégie d'audit. <br><br><h3>  Exemples de politiques </h3><br>  Analysons la structure des fichiers de stratégie à l'aide d'exemples. <br><br>  Voici un fichier de <code>policy</code> simple pour tout enregistrer au niveau des <code>Metadata</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: audit.k8s.io/v1 kind: Policy rules: - level: Metadata</code> </pre> <br>  Vous pouvez spécifier une liste d'utilisateurs ( <code>Users</code> et <code>ServiceAccounts</code> ) et de groupes d'utilisateurs dans la stratégie.  Par exemple, voici comment nous allons ignorer les utilisateurs du système, mais enregistrer tout le reste au niveau de la <code>Request</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: audit.k8s.io/v1 kind: Policy rules: - level: None userGroups: - "system:serviceaccounts" - "system:nodes" users: - "system:anonymous" - "system:apiserver" - "system:kube-controller-manager" - "system:kube-scheduler" - level: Request</code> </pre> <br>  Il est également possible de décrire la cible: <br><br><ul><li>  <code>namespaces</code> </li><li>  verbes ( <i>verbes</i> : <code>get</code> , <code>update</code> , <code>delete</code> et autres); </li><li>  ressources ( <i>ressources</i> , à savoir: <code>pod</code> , <code>configmaps</code> , etc.) et groupes de ressources ( <code>apiGroups</code> ). </li></ul><br>  <b>Faites attention!</b>  Les ressources et groupes de ressources (groupes API, c'est-à-dire apiGroups), ainsi que leurs versions installées dans le cluster, peuvent être obtenus à l'aide des commandes: <br><br><pre> <code class="bash hljs">kubectl api-resources kubectl api-versions</code> </pre> <br>  La stratégie d'audit suivante est fournie à titre de démonstration des meilleures pratiques dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation d'Alibaba Cloud</a> : <br><br><pre> <code class="plaintext hljs">apiVersion: audit.k8s.io/v1beta1 kind: Policy #    RequestReceived omitStages: - "RequestReceived" rules: #   ,     : - level: None users: ["system:kube-proxy"] verbs: ["watch"] resources: - group: "" #  api group   ,    #   Kubernetes,  “core” resources: ["endpoints", "services"] - level: None users: ["system:unsecured"] namespaces: ["kube-system"] verbs: ["get"] resources: - group: "" # core resources: ["configmaps"] - level: None users: ["kubelet"] verbs: ["get"] resources: - group: "" # core resources: ["nodes"] - level: None userGroups: ["system:nodes"] verbs: ["get"] resources: - group: "" # core resources: ["nodes"] - level: None users: - system:kube-controller-manager - system:kube-scheduler - system:serviceaccount:kube-system:endpoint-controller verbs: ["get", "update"] namespaces: ["kube-system"] resources: - group: "" # core resources: ["endpoints"] - level: None users: ["system:apiserver"] verbs: ["get"] resources: - group: "" # core resources: ["namespaces"] #     read-only URLs: - level: None nonResourceURLs: - /healthz* - /version - /swagger* #   ,     “”: - level: None resources: - group: "" # core resources: ["events"] #   Secret, ConfigMap  TokenReview    , #         - level: Metadata resources: - group: "" # core resources: ["secrets", "configmaps"] - group: authentication.k8s.io resources: ["tokenreviews"] #   get, list  watch   ;    - level: Request verbs: ["get", "list", "watch"] resources: - group: "" # core - group: "admissionregistration.k8s.io" - group: "apps" - group: "authentication.k8s.io" - group: "authorization.k8s.io" - group: "autoscaling" - group: "batch" - group: "certificates.k8s.io" - group: "extensions" - group: "networking.k8s.io" - group: "policy" - group: "rbac.authorization.k8s.io" - group: "settings.k8s.io" - group: "storage.k8s.io" #        API - level: RequestResponse resources: - group: "" # core - group: "admissionregistration.k8s.io" - group: "apps" - group: "authentication.k8s.io" - group: "authorization.k8s.io" - group: "autoscaling" - group: "batch" - group: "certificates.k8s.io" - group: "extensions" - group: "networking.k8s.io" - group: "policy" - group: "rbac.authorization.k8s.io" - group: "settings.k8s.io" - group: "storage.k8s.io" #         - level: Metadata</code> </pre> <br><br>  Un autre bon exemple de politique d'audit est le <a href="">profil utilisé dans GCE</a> . <br><br>  Pour une réponse rapide aux événements d'audit, il est possible de <b>décrire un webhook</b> .  Ce problème est divulgué dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation officielle</a> , je le laisserai en dehors du champ d'application de cet article. <br><br><h2>  Résumé </h2><br>  L'article fournit une vue d'ensemble des mécanismes de sécurité de base dans les clusters Kubernetes qui vous permettent de créer des comptes d'utilisateurs personnalisés, de partager leurs droits et d'enregistrer leurs actions.  J'espère que cela sera utile à ceux qui sont confrontés à de telles questions en théorie ou déjà en pratique.  Je vous recommande également de consulter la liste d'autres documents sur le thème de la sécurité dans Kubernetes, qui est répertoriée dans le "PS" - peut-être y trouverez-vous les détails nécessaires sur les questions qui vous concernent. <br><br><h2>  PS </h2><br>  Lisez aussi dans notre blog: <br><br><ul><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">33+ outils de sécurité Kubernetes</a> »; </li><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Introduction aux stratégies de réseau Kubernetes pour les professionnels de la sécurité</a> »; </li><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comprendre RBAC chez Kubernetes</a> »; </li><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">9 meilleures pratiques de sécurité chez Kubernetes</a> »; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">11 façons de (pas) devenir une victime du piratage Kubernetes</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr468679/">https://habr.com/ru/post/fr468679/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr468657/index.html">Danses avec support: types et formes de support. Systèmes de soutien fonctionnant au combat</a></li>
<li><a href="../fr468663/index.html">Approche End2 End dans les tâches de reconnaissance automatique de la parole</a></li>
<li><a href="../fr468665/index.html">Mais est-il temps d'acheter un irrigateur?</a></li>
<li><a href="../fr468673/index.html">Atelier "Garantir la sécurité des données personnelles" - 3 octobre, Saint-Pétersbourg</a></li>
<li><a href="../fr468677/index.html">L'annonce du smartphone Xiaomi Mi Mix Alpha</a></li>
<li><a href="../fr468683/index.html">Théorie et pratique de la normalisation des services Docker</a></li>
<li><a href="../fr468687/index.html">Nous analysons les nouvelles initiatives de la Banque centrale pour réguler le marché boursier: 3 groupes d'investisseurs, restrictions pour les débutants</a></li>
<li><a href="../fr468689/index.html">Enregistrer votre entreprise informatique à Singapour: que dois-je faire?</a></li>
<li><a href="../fr468691/index.html">Pilotes tiers dangereux sur votre système ou pilotes LOLD</a></li>
<li><a href="../fr468693/index.html">Comment l'automatisation détruit les employés de Walmart</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>