<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¾ ğŸ‘® ğŸƒ 12 tips untuk menskalakan Node.js ğŸ—ï¸ ğŸ¤µğŸ» ğŸ§—ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Node.js sudah berhasil beroperasi pada skala global, sebagaimana dibuktikan oleh aplikasi yang dikerahkan di perusahaan-perusahaan seperti Netflix, Re...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>12 tips untuk menskalakan Node.js</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425275/">  Node.js sudah berhasil beroperasi pada skala global, sebagaimana dibuktikan oleh aplikasi yang dikerahkan di perusahaan-perusahaan seperti Netflix, Reddit, Walmart dan Ebay.  Namun, ia memiliki serangkaian masalah saat penskalaan;  dari sudut pandang penskalaan orang yang bekerja pada basis kode tunggal, jadi dari sudut pandang penskalaan vertikal dan horizontal di awan.  Selain pengalaman pribadi saya dengan penskalaan Node.js untuk perusahaan seperti Reddit dan Netflix, saya berbicara dengan beberapa pakar di Microsoft Azure dan memberikan beberapa tips untuk Anda tentang penskalaan Node.js untuk perusahaan Anda. <br><a name="habracut"></a><br><h3>  Tulis Node.js yang berkualitas </h3><br>  Semakin cepat Anda mulai menggunakan linter, memformat, dan mengetikkan alat pemeriksaan dalam kode Anda, semakin baik. <br><br>  Hal-hal ini mungkin sulit untuk diperkenalkan di tengah-tengah proyek karena potensi besar jumlah refactoring yang mungkin diperlukan, itu juga dapat mencemari riwayat git Anda, tetapi pada akhirnya alat ini akan membantu Anda membuat kode dapat dibaca. <br>  Jika Anda masih belum menggunakannya, segera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alihkan</a> mata Anda ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ESLint</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Prettier</a> .  ESLint akan melindungi kode Anda dari pola yang buruk, Prettier akan membantu Anda memformat kode Anda secara otomatis sebelum menarik permintaan. <br><br>  Solusi yang lebih substansial adalah menambahkan alat seperti Flow atau TypeScript ke basis kode Anda.  Alat-alat ini memungkinkan Anda untuk menangkap kesalahan yang lebih halus, seperti memanggil fungsi dengan parameter numerik alih-alih string atau memanggil metode <b>.filter</b> pada objek, bukan array.  Terlepas dari kerumitan dan kebutuhan untuk melatih tim Anda, alat-alat ini pantas mendapatkan perhatian Anda: mereka dapat mempercepat pengembangan dengan Intellisense dan mencegah kesalahan runtime dengan perlindungan tipe. <br><br><h3>  Tulis tes </h3><br>  Tes selalu menjadi masalah sulit bagi pengembang.  Beberapa sangat percaya pada pengembangan yang digerakkan oleh tes, sementara yang lain jarang menulis tes sama sekali.  Tapi ada jalan tengah: <br><br><ul><li>  <b>Tetapkan modul-modul utama</b> dan tulis tes unit komprehensif untuknya.  Berikan perhatian khusus pada "perjalanan bahagia": kasus tepi dan skenario di mana kesalahan dapat berpotensi terjadi.  Untuk modul lain, tulis satu atau dua unit test yang mencakup "jalur bahagia" dan mungkin kasus umum yang mungkin Anda temukan </li><li>  <b>Tes UI minimum</b> .  UI terus berubah dan sering kali tidak praktis untuk menghabiskan banyak waktu melakukan tes untuk kode yang akan sering berubah. <br></li><li>  <b>Tulis tes untuk mendeteksi bug</b> .  Setiap kali Anda menemukan dan memperbaiki bug dalam kode Anda, tulis unit test yang akan menangkap bug ini di masa depan. <br></li><li>  <b>Tulis beberapa tes integrasi</b> untuk memastikan bahwa semua bagian cocok satu sama lain. <br></li><li>  <b>Tulis tes end-to-end yang lebih sedikit</b> .  Tutupi jalur utama di situs Anda, misalnya, jika Anda membuat situs e-commerce, mungkin ada baiknya menulis tes untuk memasuki situs, menambahkannya ke keranjang dan memeriksa daftar produk.  Tes-tes ini mahal untuk dipertahankan, jadi pertimbangkan untuk mempertahankan inti kecil dari tes yang dapat Anda motivasi untuk mempertahankannya. <br></li></ul><br>  Titik awal untuk menulis tes adalah kemampuan untuk menyebarkan kode baru dengan percaya diri.  Tulis begitu banyak tes yang tidak kurang dari apa yang Anda rasakan sendiri, tetapi cobalah untuk menulis tidak lebih dari daftar di atas. <br><br><h3>  Desain Stateless </h3><br>  Kuncinya saat menulis Node.js yang dapat diskalakan adalah bahwa server Anda tidak harus menyimpan status untuk seseorang atau sesuatu.  Ini akan mencegah penskalaan horizontal.  Pindahkan status ke aplikasi lain dan selesaikan masalah di tempat lain (mis. Redis, Etcd, ...).  Anda harus memikirkan ini terlebih dahulu.  Maka akan sangat sulit untuk diurai jika Anda belum melakukan ini sebelumnya.  Ini juga akan membantu jika Anda pernah memutuskan untuk menguraikan monolith menjadi layanan microser. <br><br><h3>  Statistik: untuk pengembangan - Node.js, untuk produksi - CDN </h3><br>  Bagaimana saya ingin perusahaan melihat kesalahan dalam kesalahan ini.  Melayani aset statis Anda dari aplikasi web Anda (khususnya, melalui sesuatu seperti webpack-dev-server atau server dev Parsel) adalah pengalaman pengembang yang hebat karena memperpendek siklus pengenalan saat menulis kode.  Namun, Anda sebaiknya tidak pernah melayani statika melalui Node.js.  Itu harus dikirim secara terpisah melalui CDN, seperti Azure CDN. <br><br>  Pengembalian statis dengan Node.js tidak perlu lambat karena CDN lebih tersebar dan oleh karena itu secara fisik lebih dekat dengan pengguna akhir, dan server CDN sangat dioptimalkan untuk sumber daya kecil.  Mempertahankan statika dengan Node juga tidak masuk akal mahal, karena waktu server Node.js jauh lebih mahal daripada waktu server CDN. <br><br><h3>  Mulai penggelaran awal, sebarkan lebih sering </h3><br>  Saya tidak mengenal Anda, tetapi ketika saya men-deblock sesuatu untuk pertama kalinya, itu tidak pernah berhasil.  Ini biasanya karena saya lupa mengirim kunci privat yang benar atau mengkodekan path ke host lokal.  Masalah kecil yang bekerja secara lokal menolak untuk melakukan ini.  Masalah-masalah ini dapat menumpuk, dan apa yang dapat dengan mudah diperbaiki sebelum, jika, tentu saja, mereka terlalu dini untuk menemukannya, dapat berubah menjadi sejumlah besar kesalahan yang tidak dapat dipahami yang tidak dapat ditangkap secara normal. <br><br>  Omong-omong, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Visual Studio Code memungkinkan Anda untuk memecahkan masalah semacam ini</a> .  Ini memungkinkan Anda untuk menyebarkan aplikasi Anda langsung ke Azure dengan satu klik.  Ini adalah cara yang cukup sederhana untuk memverifikasi bahwa tidak ada masalah penyebaran ke lingkungan lain. <br><br><h3>  Menyebarkan 2 server sekaligus </h3><br>  Nasihat ini datang dari pengetahuan saya yang sulit didapat dan lautan sakit hati.  Inti dari saran ini adalah bahwa ada beberapa perbedaan antara penyebaran dua server dan sepuluh server, dan tidak ada banyak perbedaan antara penyebaran sepuluh server dan seratus server.  Namun, hanya ada perbedaan besar antara menggunakan satu server dan dua server. <br>  Mirip dengan masalah penggelaran server stateless, dimulai dengan dua server, Anda dapat dengan cepat mengatasi masalah penskalaan horizontal Anda sehingga ketika ada lonjakan tajam dalam lalu lintas, Anda siap untuk mengukur. <br><br><h3>  Jangan takut dengan garis </h3><br>  Database modern mengatasi sejumlah membaca dan menulis sendiri, tanpa bantuan Anda.  Saat Anda menguji ide Anda, silakan mengandalkan database Anda untuk menangani beban kerja berukuran kecil hingga menengah. <br><br>  Penskalaan prematur lebih mungkin membunuh Anda daripada menyelamatkan Anda.  Tetapi, pada titik tertentu, aplikasi Anda akan tumbuh sehingga Anda tidak akan dapat menulis semuanya ke database juga, dihadapkan dengan masalah bandwidth baca dan tulis.  Untuk beberapa aplikasi yang memiliki catatan ringan, atau jika Anda memilih database seperti Cassandra, yang menangani skala besar sendiri, ini akan menjadi masalah nanti, bagi yang lain itu akan lebih awal. <br><br>  Jika Anda memiliki atau akan segera memiliki masalah seperti itu, Anda akan memiliki opsi untuk memilih teknologi yang akan Anda gunakan lebih lanjut.  Salah satu teknologi ini mungkin adalah antrian pesan.  Standar aktual saat ini adalah Apache Kafka, yang memungkinkan Anda untuk mengatur pesan Anda dalam topik, dan kemudian aplikasi untuk berlangganan topik ini.  Jadi, misalnya, Anda dapat mengakumulasikan pesan dalam aplikasi, mendengarkan topik tertentu, dan kemudian menulis data ke dalam basis data Anda sehingga tidak tersumbat setiap saat.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Selain itu, Kafka berjalan dengan mudah di Azure</a> . <br><br><h3>  Layanan microser untuk penskalaan </h3><br>  Ketika aplikasi Anda tumbuh, pembagian logis alami mulai muncul.  Satu bagian dari aplikasi dapat memproses pembayaran, sementara bagian lainnya akan melayani API untuk frontend Anda.  Saat membuat pembagian yang logis, pertimbangkan untuk memisahkannya dengan layanan microser.  Tapi hati-hati, karena pengenalan layanan mikro juga penuh dengan kompleksitas.  Tapi itu sepadan.  Jadi, misalnya, setiap layanan mikro dapat memiliki metrik sendiri.  Dengan mengevaluasi mereka, Anda dapat mengatur skala mereka secara mandiri. <br><br><h3>  Gunakan wadah </h3><br>  Aplikasi Anda mungkin berfungsi dengan baik secara lokal, tetapi mungkin ada masalah serius yang mencoba untuk digunakan.  Alat-alat seperti Docker dan Kubernetes akan bekerja untuk Anda untuk menghindari masalah ini.  Docker, yang dapat Anda bayangkan sebagai mini-instance (wadah) Linux atau Windows, di mana Anda dapat menjalankan aplikasi;  dan Kubernet sebagai alat yang menghubungkan semua kontainer Anda bersama di cloud. <br><br>  Kubernetes mungkin binatang yang kompleks, tetapi binatang yang memecahkan masalah yang kompleks.  Jika Anda seorang penyihir DevOps yang tidak berpengalaman, maka Anda mungkin mengalami kesulitan, jadi saya sarankan memulai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Draft</a> .  Jika Anda terbiasa dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Yeoman</a> untuk proyek Javascript, maka Anda dapat mengevaluasi Draft sebagai alat yang serupa, tetapi untuk proyek Kubernetes: alat yang membuat kerangka gambar untuk proyek Anda.  Dari sana, Anda dapat menggunakan alat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Helm</a> untuk menginstal potongan arsitektur tambahan yang perlu Anda bangun (mis. Nginx, lebih banyak Node.js, MongoDB, server Kafka, dll.), Hampir seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">npm</a> untuk Kubernetes. <br><br>  Segera setelah Anda memahami ekosistem Kubernetes, mulai sekarang, menggunakan awan akan menjadi permainan anak-anak. <br><br><h3>  Kumpulkan metrik </h3><br>  Jika Anda tidak tahu bagaimana menjawab pertanyaan "Bagaimana cara kerja aplikasi saya?", Maka Anda akan memiliki masalah atau mereka akan segera.  Lagi pula, berbagai macam indikator dari waktu ke waktu akan membantu Anda terus meningkatkan keadaan aplikasi Anda.  Dari sudut pandang biaya untuk masa depan, dan dari sudut pandang kenyamanan pengguna dalam hal meningkatkan waktu respons.  Anda pasti harus melacak metrik seperti jalur lambat, tampilan halaman, waktu sesi, dan metrik kunci lainnya yang penting bagi bisnis Anda. <br><br>  Ada banyak cara untuk mengumpulkan indikator-indikator ini.  Layanan seperti New Relic dan AppDynamics akan memberi Anda informasi yang sangat berharga tentang cara meningkatkan aplikasi Anda. <br><br>  Jika Anda bekerja dengan Azure, Wawasan Aplikasi juga mengatasi kebutuhan ini, dan juga mudah untuk menyambungkan alat lain seperti CI / CD. <br><br><h3>  CI / CD akan menyelamatkan Anda dari begitu banyak rasa sakit </h3><br>  Berapa kali Anda merusak penyebaran selama FTP dan mematikan server Anda selama beberapa menit?  Itu bersamaku.  Anda tidak boleh mempercayai diri sendiri dalam menyebarkan kode produksi.  Cara melakukan ini menggunakan Visual Studio Code cukup keren, tetapi terutama untuk tujuan pengembangan atau demonstrasi.  Ketika Anda siap untuk membuat sistem tingkat produksi, Anda harus menggunakan integrasi berkelanjutan dan penyebaran berkelanjutan (sering disingkat CI / CD - integrasi berkelanjutan dan penyebaran berkelanjutan). <br><br>  Integrasi berkelanjutan adalah praktik pengembangan perangkat lunak, yang terdiri dari menggabungkan copy pekerjaan ke dalam cabang utama umum pengembangan beberapa kali sehari dan melakukan rakitan proyek otomatis yang sering dilakukan untuk dengan cepat mengidentifikasi potensi kerusakan dan menyelesaikan masalah integrasi. <br><br>  Penerapan berkelanjutan terus mengambil kode Anda yang lulus CI, menjalankan langkah-langkah yang diperlukan untuk membangun, kemas atau mengepaknya, dan mengirimkannya ke server.  Ini adalah praktik yang baik untuk memiliki beberapa level untuk diuji.  Anda mungkin lebih dulu pergi ke server dev internal untuk melihatnya di lingkungan berisiko rendah terlebih dahulu.  Anda dapat mengujinya terlebih dahulu sebelum mengirimnya ke lingkungan QA di mana teknisi QA Anda atau mungkin layanan eksternal akan mengonfirmasi bahwa semuanya berfungsi seperti yang diharapkan.  Dari sana, Anda dapat pergi ke lingkungan perantara di mana aplikasi Anda masih hanya internal, tetapi bekerja menggunakan data dan pengaturan produksi, sehingga Anda dapat mengujinya di lingkungan produksi itu sendiri sebelum mengirimkannya langsung ke produksi.  Anda juga dapat memilih sekelompok kecil server untuk memeriksa kode baru: Anda dan mengarahkan hanya sebagian kecil lalu lintas nyata ke server ini untuk memastikan tidak ada yang rusak saat bekerja dengan pengguna nyata.  Jika rusak, Anda tahu ke mana harus mencari masalah.  Jika tidak, Anda dapat beralih dari sekelompok kecil pengguna ke semua orang. <br><br>  Banyak vendor dan proyek open source menangani kebutuhan ini.  Jenkins, Travis dan CircleCI adalah pilihan bagus untuk CI.  Azure memiliki layanan CI / CD sendiri yang disebut Azure Pipelines, dan cukup intuitif untuk digunakan, dan sekali lagi, ia dengan mudah terhubung ke ekosistem Azure yang terintegrasi. <br><br><h3>  Jaga rahasia </h3><br>  Setiap aplikasi pasti memiliki beberapa rahasia.  Itu bisa berupa kunci dan jalur rahasia dari kredensial, database, dan banyak lagi.  Akan sangat buruk jika mereka beralih ke tangan yang salah.  Namun, mereka perlu menjalankan aplikasi.  Jadi apa yang kita lakukan?  Biasanya dalam pengembangan kita akan menggunakan alat-alat seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dotenv</a> untuk menyimpan file konfigurasi secara lokal dan dapat membacanya melalui process.env di Node.js.  Ini bagus untuk pengembang, tetapi buruk untuk produksi. <br><br>  Sebagai gantinya, berguna untuk menggunakan beberapa jenis alat manajemen rahasia.  Untungnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kubernetes memiliki sistem bawaan</a> dan cukup mudah digunakan.  Anda memberikan rahasia Kubernetes di sisi wadah, dan kemudian akan memberikannya ke aplikasi Anda sebagai lingkungan yang sangat mempersulit serangan. <br><br>  Alat lain yang patut Anda perhatikan adalah Azure <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Key Vault</a> .  Apa yang keren tentang Vault Kunci, meskipun Microsoft tidak dapat membaca kunci Anda (hanya Anda yang dapat mendekripsi), Azure akan melacak log Anda dan melacak setiap penggunaan yang meragukan dari kunci Anda untuk mengingatkan Anda akan adanya kompromi. <br><br><h3>  Kesimpulan </h3><br>  Node.js, seperti platform lainnya, perlu ditingkatkan.  Dan, seperti platform lainnya, ia memiliki tugasnya sendiri dan kekhususan penskalaan, yang patut diketahui dan yang harus diperhitungkan ketika merancang proyek-proyek besar. <br><br>  Artikel asli: "Sebelas Tips untuk Menimbang Node.js" ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">En</a> ). <br><br>  Saya sarankan di komentar untuk berbagi kiat yang dapat Anda berikan pada penskalaan Node.js.  Akan menarik untuk didengar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425275/">https://habr.com/ru/post/id425275/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425265/index.html">Aturan pengembangan di Yandex.Health</a></li>
<li><a href="../id425267/index.html">Tempat kerja pengembang .NET atau kesulitan dalam memilih konfigurasi ideal ver.2.0</a></li>
<li><a href="../id425269/index.html">Hackathon GAZ - cara menyentuh raksasa otomatis</a></li>
<li><a href="../id425271/index.html">WPA3 bisa lebih aman: pendapat ahli</a></li>
<li><a href="../id425273/index.html">Cara lain untuk menggunakan komposisi buruh pelabuhan</a></li>
<li><a href="../id425279/index.html">Bagaimana cara mewawancarai Google: apa yang akan terjadi, apa yang tidak boleh dilewati</a></li>
<li><a href="../id425281/index.html">Pedoman untuk membawa "mengkondisikan" klon dari router mini populer Cina Hame A15, alias "A5-V11 tidak bermerek"</a></li>
<li><a href="../id425283/index.html">Lokalisasi tanpa batas, atau bagaimana kami menerjemahkan peta secara real time</a></li>
<li><a href="../id425285/index.html">Jika Anda tidak mempekerjakan Jones, maka Anda tidak layak mendapatkan junjungan</a></li>
<li><a href="../id425287/index.html">Rumah FIAS di PostgreSQL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>