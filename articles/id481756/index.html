<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’„ â›½ï¸ ğŸ™ğŸ¿ Bagaimana cara mengatur DDoS untuk tujuan yang baik? ğŸ§‘ğŸ» ğŸ€ ğŸ’</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sebelum merilis layanan baru, alangkah baiknya untuk memastikan bahwa ia bekerja sesuai dengan harapan kami dan tersedia terlepas dari berapa banyak p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana cara mengatur DDoS untuk tujuan yang baik?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ntc-vulkan/blog/481756/"><p><img src="https://habrastorage.org/webt/qa/gk/up/qagkupe_y5cx7thbrqpj4aynn1y.png" alt="gambar"></p><br><p>  Sebelum merilis layanan baru, alangkah baiknya untuk memastikan bahwa ia bekerja sesuai dengan harapan kami dan tersedia terlepas dari berapa banyak pelanggan yang menggunakannya pada saat yang sama. </p><br><p>  Dan bagaimana layanan ini akan bereaksi jika serangan DoS terdistribusi diatur terhadapnya?  Apakah sumber daya dilindungi dari penyerang potensial? </p><br><p>  Untuk menilai risiko yang mungkin terjadi dan meningkatkan keamanan, masuk akal untuk secara mandiri melakukan tindakan yang mensimulasikan serangan DDoS, sementara sumber daya belum diluncurkan untuk penggunaan massal. </p><br><p>  Pada artikel ini, kita akan berbicara tentang pengalaman mengatur pengujian beban untuk layanan DNS dan HTTP. </p><a name="habracut"></a><br><h1>  Persiapan </h1><br><p>  Untuk memprovokasi generasi lalu lintas jaringan dalam jumlah besar pada sumber daya yang dipantau, Anda perlu menggunakan banyak mesin virtual, yang masing-masing akan mengirimkan jumlah maksimum permintaan ke layanan.  Jika Anda tidak memiliki pusat data yang kuat, masuk akal untuk sementara menyewa mesin virtual di cloud.  Gagasan ini memiliki satu fitur: Anda perlu memastikan bahwa cloud tidak merangkak, mengambil aktivitas Anda untuk tindakan penyerang. </p><br><p>  Membandingkan kebijakan berbagai layanan cloud (seseorang dengan kejam melarang akun yang, mungkin, diambil tindakan yang menyebabkan kegagalan sumber daya) terkait pengujian beban menggunakan fungsionalitasnya, kami memutuskan untuk berhenti di <a href="https://aws.amazon.com/">Amazon Web Services</a> (AWS).  <a href="https://aws.amazon.com/ru/ec2/testing/">Dokumen</a> mereka menunjukkan bahwa AWS memungkinkan pengujian muatan, tetapi meminta persetujuan dengan mengirim email ke alamat tertentu. </p><br><h1>  Harmonisasi pengujian stres </h1><br><p>  Kami mengirim pesan di mana kami secara singkat berbicara tentang niat kami, dan kami mendapatkan formulir yang harus diisi: </p><br><pre><code class="plaintext hljs">Customer ID: Customer Name: Email Address: AWS Account ID load test will be performed from: Does the customer have an NDA? Target Data EC2 Resources: Cloudfront Distribution: API Gateway / Lambda ID: ELB Names: Non-AWS Target: Region (please list all regions in scope for testing): Source Data: IP Addresses: Source Account ID: Regions involved: Testing Parameters: How much traffic do you plan to generate by region during testing? What is your expected peak load from source by region? (ie xx Gbps) What is your expected peak load at destination? (ie xx Gbps) Are you testing traffic outbound from EC2, inbound into EC2, or both? Are you testing traffic outbound (egress) from EC2, inbound (ingress) into EC2, or both: Egress. What is your expected peak load from source by region? (ie xx Gbps) Ingress. What is your expected peak load from source by region? (ie xx Gbps) Start Date: End Date: Finite testing details including timeline of testing: Summary of Test: Testing Timelines by phase including rps, pps, and Gbps: Peak bandwidth for each source IP: Tools Used for each phase of test: Types of testing to be performed for each phase of the request: What criteria/metrics will you monitor to ensure the success of this test? Who is performing the Load Test? (Please provide contact details): Does the tester have an NDA? Testing Security Do you have a way to monitor the data traffic for the duration of the test to verify bandwidth limits do not exceed approved rates? Do you have a way to immediately stop the traffic if we/you discover any issue? 2 Emergency contact names and phone numbers:</code> </pre> <br><p>  Ada beberapa nuansa: </p><br><ol><li><p>  Mereka bertanya kepada kami siapa yang akan kami "tan".  Apakah kita punya hak untuk ini?  Kami mengatakan bahwa ini adalah sumber daya kami (tampaknya, tidak ada yang memeriksa apakah ini benar) dan bahwa pengujian sepenuhnya konsisten. </p><br></li><li><p>  Kita perlu menentukan berapa banyak traffic yang akan kita buat di masing-masing daerah.  Selama korespondensi, kami menemukan bahwa masing-masing daerah memiliki batas sendiri pada jumlah lalu lintas jaringan.  Secara total, mereka diizinkan untuk meminta 645 Gb / s.  Kami mempertimbangkan berapa banyak yang dibutuhkan untuk serangan itu, dan kami memilih daerah sedemikian rupa untuk mendapatkan nilai yang diperlukan. </p><br></li><li><p>  Diperlukan untuk menggambarkan kapan serangan itu akan dilakukan, berapa lama itu akan berlangsung dan bagaimana kekuatannya akan tumbuh.  Dalam bentuk bebas, tetapi dalam detail yang cukup kita berbicara tentang rencana kita.  Serangan itu dilakukan dengan peningkatan kekuatan secara bertahap, jadi kami mengecat tahap pengujian apa yang akan dilakukan dan kekuatan maksimum apa yang diharapkan dari masing-masing.  Tanggal serangan dapat dihilangkan hingga satu hari, dimungkinkan untuk menunjukkan rentang dua hingga tiga minggu. </p><br></li><li><p>  Dan tanpa gagal, kami melakukan yang terbaik untuk memastikan bahwa kami akan berperilaku baik, dengan cermat memantau kemajuan pengujian dan menghentikannya pada permintaan pertama jika perlu. </p><br></li></ol><br><p>  Kemungkinan besar, dalam menanggapi formulir yang telah diisi mereka akan meminta klarifikasi, jadi kami berkorespondensi dan menjawab pertanyaan sampai kami mendapat izin untuk menguji. </p><br><p>  Dibutuhkan sekitar tiga hari kerja untuk menyelesaikan proses persetujuan jika dijawab segera. </p><br><h1>  Persiapan infrastruktur </h1><br><p>  Setelah persetujuan, kami dihadapkan dengan kebutuhan untuk mempersiapkan infrastruktur untuk pengujian.  Faktanya adalah bahwa selama pemeriksaan kita perlu segera: </p><br><p>  â€¢ menyertakan sebuah instance; </p><br><p>  â€¢ meluncurkan serangan uji; </p><br><p>  â€¢ mengumpulkan statistik tentang kemajuan; </p><br><p>  â€¢ hentikan serangan uji coba; </p><br><p>  â€¢ mengubah alamat IP; </p><br><p>  â€¢ matikan mesin virtual. </p><br><h2>  Buat Gambar Instance </h2><br><h3>  Pilih Jenis Instance </h3><br><p>  Pertama, mari kita membangun gambar AWS yang akan berisi alat dan skrip yang diperlukan untuk manajemen.  Langkah pertama adalah memilih contoh yang akan disewa.  Kami mempelajari karakteristik berbagai jenis instance: kami melihat harga, jumlah lalu lintas maksimum, daya CPU (yang terakhir penting, karena lalu lintas dibuat oleh kapasitas prosesor setelah semua), kemudian kami menguji kinerja nyata dan jumlah permintaan maksimum.  Menurut perkiraan kami, contoh kecil adalah yang paling nyaman untuk pengujian, tetapi di sini semua orang memilih seleranya. </p><br><p>  Karakteristik contoh dapat ditemukan di <a href="https://aws.amazon.com/ec2/instance-types/">sini</a> .  Anda juga dapat memilih dan membandingkan contoh di <a href="https://www.ec2instances.info/">sini</a> . </p><br><h3>  Batasi permintaan </h3><br><p>  Anda harus berpikir terlebih dahulu tentang berapa banyak contoh yang akan berpartisipasi dalam pengujian.  Faktanya adalah bahwa Amazon memberikan batasan masing-masing daerah pada jumlah daerah.  Jika Anda merasa bahwa Anda akan membutuhkan lebih banyak instance daripada yang tersedia secara default, maka Anda harus meminta peningkatan batas sedini mungkin.  Untuk melakukan ini, pergi ke bagian <a href="https://console.aws.amazon.com/support/cases">Dukungan</a> , buat panggilan tipe peningkatan batas Layanan.  Waktu pemrosesan untuk permintaan bisa berbeda: seseorang menjawab keesokan harinya, memberikan sebanyak entitas seperti yang diminta, seseorang mengatakan bahwa ia tidak akan membiarkan lebih dari N instance dijalankan.  Ada daerah yang menanggapi permintaan selama sekitar satu bulan. </p><br><h3>  Penyesuaian kinerja </h3><br><p>  Selanjutnya, Anda perlu membuat gambar instan yang akan diluncurkan selama pengujian.  Untuk melakukan ini, kita menghidupkan instance dari jenis yang dipilih, membuat semua pengaturan di atasnya, lalu menyimpan apa yang terjadi sebagai gambar (dalam menu Tindakan, di mana Anda dapat mengaktifkan instance, serta fungsi untuk membuat Gambar Buat Gambar). </p><br><p>  Kita perlu mendapatkan lalu lintas keluar maksimum dari setiap instance, jadi pertama-tama kita mengoptimalkan pengaturan jaringan dan memori untuk tugas kita pada instance. </p><br><p>  Untuk melakukan ini, buat pengaturan di file <code>/etc/sysctl.conf</code> : </p><br><p>  â€¢ Tingkatkan kisaran port lokal dan kurangi waktu yang dihabiskan oleh soket dalam status FIN_WAIT: </p><br><pre> <code class="plaintext hljs">net.ipv4.ip_local_port_range = 1024-65535 ( : 32768-61000) net.ipv4.tcp_fin_timeout = 10 ( : 60)</code> </pre> <br><p>  Rentang port lokal menentukan jumlah maksimum soket keluar yang dapat dibuat oleh host dari IP tertentu. </p><br><p>  Dengan pengaturan default (61.000â€“32.768), 28.233 soket diperoleh.  Dengan pengaturan baru - 64 500. </p><br><p>  Fin_timeout menentukan waktu minimum soket yang keluar bisa dalam status FIN_WAIT. </p><br><p>  Jika nilai standar ditentukan, sistem dapat menyediakan tidak lebih dari (61.000â€“32.768) / 60 = 470 soket per detik. </p><br><p>  Dengan meningkatkan port_range dan mengurangi fin_timeout, kita dapat memengaruhi kemampuan sistem untuk menghasilkan lebih banyak koneksi keluar. </p><br><p>  â€¢ Mari kita gunakan kembali soket dalam keadaan TIME_WAIT saat yang gratis berakhir: </p><br><pre> <code class="plaintext hljs">net.ipv4.tcp_tw_reuse = 1</code> </pre> <br><p>  Mengatur opsi di atas (yang dinonaktifkan secara default) membantu meminimalkan hilangnya "idle" koneksi yang sudah terpenuhi. </p><br><p>  Sangat detail tentang TIME_WAIT dijelaskan dalam <a href="https://vincent.bernat.ch/en/blog/2014-tcp-time-wait-state-linux">artikel</a> ini. </p><br><p>  â€¢ Aktifkan opsi tcp_timestamps agar opsi tcp_tw_reuse di atas berfungsi: </p><br><pre> <code class="plaintext hljs">net.ipv4.tcp_timestamps = 1 â€“   `tcp_timestamps`     tcp_tw_reuse</code> </pre> <br><p>  â€¢ Opsi lain: </p><br><pre> <code class="plaintext hljs">net.ipv4.tcp_max_tw_buckets = 720000 â€“       TIME_WAIT net.ipv4.tcp_keepalive_time = 600 â€“  - keepalive- net.ipv4.tcp_keepalive_probes = 3 â€“   keepalive- net.ipv4.tcp_keepalive_intvl = 10 â€“     keepalive- net.ipv4.tcp_window_scaling = 1 â€“   TCP- net.ipv4.tcp_mem = 8192 131072 196304 â€“     TCP- net.ipv4.udp_mem = 8192 131072 196304 â€“     udp- net.ipv4.tcp_slow_start_after_idle=0 â€“  Slow-Start Restart net.core.wmem_default = 31457280 â€“         net.core.wmem_max = 33554432 â€“        net.core.somaxconn = 65535 â€“        net.core.netdev_max_backlog = 65535 â€“          vm.swappiness = 30 â€“    vm.dirty_ratio = 50 â€“     50 %  vm.pagecache = 90 â€“    </code> </pre> <br><h3>  Uji skrip serangan </h3><br><p>  <strong>1. Serangan DNS</strong> </p><br><p>  Salah satu tugas utama pengujian adalah untuk mengevaluasi kinerja server DNS.  Yaitu, server DNS dapat menjadi penghambat toleransi kesalahan suatu situs, karena meskipun layanan paling stabil tidak tersedia jika ada masalah dengan DNS.  Untuk membuat beban pada server DNS, kami akan menghasilkan banyak permintaan DNS yang berbeda.  Permintaan harus valid dan membutuhkan respons terbesar dan terlama dari server DNS. </p><br><p>  Utilitas <a href="https://www.dns-oarc.net/tools/dnsperf">DNSPerf</a> cocok untuk menghasilkan lalu lintas tersebut. </p><br><p>  DNSPerf adalah alat pengujian kinerja DNS sederhana, fleksibel, dan gratis.  Ini terutama dirancang untuk server DNS otoritatif, tetapi juga dapat digunakan untuk mengukur kinerja server caching. </p><br><p>  Dalam kasus kami, server DNS otoritatif dimuat yang melayani satu zona - example.com. </p><br><p>  Untuk DNSPerf, pertama-tama kami menyiapkan file dengan permintaan <code>dns_queries.txt</code> (terutama APA SAJA untuk meningkatkan waktu dan ukuran respons dari server DNS): </p><br><pre> <code class="plaintext hljs">#dns_queries.txt example.com ANY www.example.com ANY test.example.com ANY static.example.com ANY example.com  www.example.com  test.example.com MX</code> </pre> <br><p>  Contoh menjalankan utilitas: </p><br><pre> <code class="plaintext hljs">dnsperf -s TARGET_IP -d dns_queries.txt -c 100 -n 100 -s =  IP- -d =      .   â€“ stdin -c =   .         -n =  Â«Â»   .</code> </pre> <br><p>  <strong>2. Menyerang ICMP</strong> </p><br><p>  Tahap pengujian berikutnya adalah menilai resistansi terhadap sejumlah besar lalu lintas ICMP.  Karena, karena alasan teknis, server sering harus dapat menanggapi permintaan ping, ada kemungkinan serangan DDoS menggunakan permintaan ping.  Selain menentukan pengaturan yang mengecualikan kemungkinan <code>ping-to-death</code> , Anda perlu memastikan bahwa server tahan terhadap beban ICMP puncak.  Untuk membuat beban seperti itu, lebih baik menggunakan utilitas <a href="https://linux.die.net/man/8/hping3">hping3 yang</a> terkenal, yang memungkinkan Anda untuk menyesuaikan jumlah permintaan, interval antar pengiriman, serta ukuran paket. </p><br><p>  Contoh menjalankan utilitas: </p><br><pre> <code class="plaintext hljs">hping3 -i u1000 -d 1500 -c 100000 -1 TARGET_IP -i u100 =     (uX for X microseconds) -d 1500 =    -c 1000000 =     -1 =  ICMP</code> </pre> <br><p>  <strong>3. Serangan HTTP</strong> </p><br><p>  Sekarang kami memeriksa ketahanan terhadap stres fungsi utama dari layanan - memproses lalu lintas HTTP (S).  Salah satu alat yang paling fleksibel dan termudah untuk menghasilkan lalu lintas HTTP adalah <a href="https://linux.die.net/man/1/siege">pengepungan</a> .  Siege adalah utilitas multi-utas sumber terbuka yang dirancang untuk menguji kinerja sumber daya web. </p><br><p>  Seperti DNSPerf, pengepungan memungkinkan Anda memuat server dengan permintaan dari sejumlah pengguna virtual (emulasi pengguna dilakukan menggunakan port terpisah), serta menggunakan serangkaian permintaan yang telah ditentukan.  Ini sangat mudah, karena Anda dapat memasukkan pertanyaan paling banyak sumber daya dalam pengujian. </p><br><p>  Contoh menjalankan utilitas: </p><br><pre> <code class="plaintext hljs">siege -b -c 100 -f test_urls.txt -b =   ( benchmark) -c =   .         -f =   </code> </pre> <br><p>  Format konten <code>test_urls.txt</code> : </p><br><pre> <code class="plaintext hljs">http://example.com/site/login POST login=username&amp;password=test http://example.com/site/client POST useragent=Mozilla&amp;version=123&amp;date=24May http://example.com/site/order POST user=username&amp;company=ooo&amp;phone=812345678</code> </pre> <br><p>  Seperti yang Anda lihat, tes dilakukan menggunakan permintaan POST terutama yang membutuhkan pemrosesan di sisi server dan menempati jumlah sumber daya terbesar dibandingkan dengan jenis permintaan lainnya. </p><br><p>  Tidak ada opsi yang menggunakan spoofing IP, karena Amazon tidak mengizinkan ini.  Apa pun src_IP yang ditentukan dalam paket, itu akan diubah ke yang benar saat keluar dari instance. </p><br><p>  Semua permintaan yang dihasilkan harus sah - tidak ada gelombang lalu lintas keluar yang tidak dijawab - karena kebijakan DDoS Amazon cukup ketat.  Bahkan stress test yang terkoordinasi membutuhkan waktu minimal beberapa hari untuk berkomunikasi dengan dukungan teknis, dan pada tindakan "jahat" pertama kami mendapatkan larangan pelabuhan dari mana lalu lintas keluar, dan persyaratan untuk segera menjelaskan. </p><br><h3>  Skrip untuk meluncurkan serangan </h3><br><p>  Untuk manajemen pengujian jarak jauh, kami akan menyiapkan skrip bash (dns.sh, ping.sh, http.sh) yang meluncurkan jenis serangan yang diinginkan, dan file dengan muatan (test_urls.txt, valid_dns_queries.txt). </p><br><p>  Saat kami mengunggah semua ini ke gambar AWS (dari mana semua instance akan dibuat), setiap pengujian dapat dijalankan dari jarak jauh menggunakan perintah dari format berikut: </p><br><pre> <code class="plaintext hljs">ssh instance-amazon 'sudo &lt;stress-script&gt;.sh start &lt;params&gt; &amp;&gt;&gt;stress.log &amp;'</code> </pre> <br><p>  Script dari tipe yang diperlukan ditentukan sebagai stress-script.sh, dan params adalah parameter yang sesuai.  Dalam file stress.log, kami akan melacak output dari utilitas yang berjalan.  Untuk kenyamanan, kami akan menggunakan log yang berbeda untuk utilitas yang berbeda: dns.log, ping.log, http.log. </p><br><p>  Contoh skrip <code>dns.sh</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash if [[ ! "$1" =~ ^(start|stop|status)$ ]]; then echo "nothing to do: need argument for stop,start or status" exit 1 fi if [[ "$1" = "start" ]]; then shift dnsperf $@ fi if [[ "$1" = "stop" ]]; then kill $(pidof dnsperf) fi if [[ "$1" = "status" ]]; then if [[ ! "$(pidof dnsperf)" = "" ]]; then echo "dnperf is running with PID $(pidof dnsperf)" ps aux | grep dnsperf else echo "dnsperf is not running" fi fi</span></span></code> </pre> <br><p>  Seperti dapat dilihat dari kode, skrip dapat dimulai dan dihentikan, serta memeriksa statusnya (berjalan / tidak berjalan). </p><br><p>  Skrip untuk tes ICMP dan HTTP dibuat dengan cara yang sama, mulai hping3 dan pengepungan, masing-masing, dengan parameter string melewati argumen. </p><br><p>  Contoh perintah: </p><br><pre> <code class="plaintext hljs">ssh instance-amazon 'sudo dns.sh start -s TARGET_IP -d valid_dns_queries.txt -c 1 -n 100 &amp;&gt;&gt;dns.log &amp;' ssh instance-amazon 'sudo ping.sh start -i u1000 -d 1500 -c 100000 -1 TARGET_IP &amp;&gt;&gt;ping.log &amp;' ssh instance-amazon 'sudo http.sh start -b -c 100 -f test_urls.txt &amp;&gt;&gt; http.log &amp;'</code> </pre> <br><h3>  Skrip pemantauan </h3><br><p>  Untuk mengevaluasi lalu lintas keluar dan keadaan infrastruktur pengujian, kami membutuhkan alat pemantauan.  Untuk alasan kesederhanaan dan penghematan sumber daya, kami menggunakan iptables.  Untuk melakukan ini, kami akan menulis skrip yang menghitung jumlah MB yang dikirim, dan meletakkannya di gambar AWS: </p><br><pre> <code class="plaintext hljs">#iptables.sh sudo iptables -N TRAFFIC_OUT sudo iptables -A TRAFFIC_OUT -p tcp sudo iptables -A TRAFFIC_OUT -p udp sudo iptables -A TRAFFIC_OUT -p icmp sudo iptables -A OUTPUT -j TRAFFIC_OUT sudo iptables-save</code> </pre> <br><p>  Script menciptakan rantai TRAFFIC_OUT baru dan menambahkan filter untuk itu untuk protokol yang diperlukan: tcp, udp, icmp. </p><br><p>  Penerusan paket ke TRAFFIC_OUT ditambahkan ke rantai OUTPUT. </p><br><p>  Jumlah data yang ditransfer dapat ditemukan oleh perintah: </p><br><pre> <code class="plaintext hljs"># iptables -L TRAFFIC_OUT -v -n -x | tail -n 3 | awk '{print $2/1024/1024,"Mb\t\t\t",$3}' : 2.2 Mb tcp 4.4 Mb udp 3.2 Mb icmp</code> </pre> <br><p>  Instal skrip sebagai layanan.  Untuk melakukan ini, buat file monitoring.service dan pindahkan ke <code>/etc/systemd/system</code> image kita: </p><br><pre> <code class="plaintext hljs"># /etc/systemd/system/monitoring.service [Unit] After=network.target [Service] ExecStart=/usr/local/bin/monitoring.sh [Install] WantedBy=default.target</code> </pre> <br><p>  Sekarang Anda dapat menambahkan layanan ke startup: </p><br><pre> <code class="plaintext hljs">systemctl enable monitoring.service systemctl start monitoring.service</code> </pre> <br><h2>  Manajemen instance </h2><br><p>  Sekarang mari kita berurusan dengan manajemen instance jarak jauh (seotomatis mungkin). </p><br><p>  Untuk tujuan ini, Anda dapat menggunakan mekanisme <a href="https://aws.amazon.com/ru/cli/">AWS CLI</a> - manajemen konsol. </p><br><p>  Buat <a href="https://console.aws.amazon.com/iam/home%3Fnc2%3Dh_m_sc">Kunci Rahasia</a> ( <a href="https://console.aws.amazon.com/iam/home%3Fnc2%3Dh_m_sc">Kunci</a> akses (ID kunci akses dan kunci akses rahasia)) dan konfigurasikan konsol. </p><br><p>  Sekarang kami memiliki akses ke semua fitur akun. </p><br><p>  Keunikan bekerja dengan AWS adalah bahwa semua tindakan dilakukan untuk wilayah tertentu dan harus diulang jika beberapa daerah terlibat. </p><br><p>  Untuk membuat instance baru dari gambar yang kami buat di atas (kami berasumsi bahwa ada ami-ID publik yang kami gunakan dalam skrip), kami akan melakukan hal berikut: </p><br><ul><li>  buat kunci SSH dan tambahkan ke AWS: </li></ul><br><pre> <code class="bash hljs">yes n |ssh-keygen -q -t rsa -f <span class="hljs-variable"><span class="hljs-variable">$KEYNAME</span></span> -m pem -N <span class="hljs-string"><span class="hljs-string">""</span></span> &gt; /dev/null chmod 400 <span class="hljs-variable"><span class="hljs-variable">$KEYNAME</span></span> aws ec2 import-key-pair --region <span class="hljs-variable"><span class="hljs-variable">$REGION</span></span> --key-name <span class="hljs-variable"><span class="hljs-variable">$KEYNAME</span></span> --public-key-material file:///$(<span class="hljs-built_in"><span class="hljs-built_in">pwd</span></span>)/<span class="hljs-variable"><span class="hljs-variable">$KEYNAME</span></span>.pub</code> </pre> <br><ul><li>  buat grup keamanan yang memungkinkan akses ke mesin melalui SSH.  Jika tidak, koneksi SSH yang masuk akan ditolak: </li></ul><br><pre> <code class="bash hljs">SECURITY=<span class="hljs-string"><span class="hljs-string">"ssh-group"</span></span> aws ec2 create-security-group --region <span class="hljs-variable"><span class="hljs-variable">$REGION</span></span> --group-name <span class="hljs-variable"><span class="hljs-variable">$SECURITY</span></span> --description <span class="hljs-string"><span class="hljs-string">"Just ssh. Nothing more"</span></span> IP_RANGE=<span class="hljs-string"><span class="hljs-string">"0.0.0.0/24"</span></span> aws ec2 authorize-security-group-ingress --region <span class="hljs-variable"><span class="hljs-variable">$REGION</span></span> --group-name <span class="hljs-variable"><span class="hljs-variable">$SECURITY</span></span> --protocol tcp --port 22 --cidr <span class="hljs-variable"><span class="hljs-variable">$IP_RANGE</span></span></code> </pre> <br><ul><li>  buat instance dengan kunci yang dibuat sebelumnya dan grup keamanan dan tentukan ID gambar.  Jumlah instance yang dibuat pada satu waktu dapat berubah-ubah: </li></ul><br><pre> <code class="bash hljs">IMG=<span class="hljs-string"><span class="hljs-string">'ami-0d0eaed20348a3389'</span></span> NUM=1 aws ec2 run-instances --region <span class="hljs-variable"><span class="hljs-variable">$REGION</span></span> --image-id <span class="hljs-variable"><span class="hljs-variable">$IMG</span></span> --count <span class="hljs-variable"><span class="hljs-variable">$NUM</span></span> --instance-type t2.micro --key-name <span class="hljs-variable"><span class="hljs-variable">$KEYNAME</span></span> --security-groups default <span class="hljs-variable"><span class="hljs-variable">$SECURITY</span></span> &gt; instances.json</code> </pre> <br><ul><li>  tunggu sampai mesin diinisialisasi.  Ini membutuhkan waktu: pertama kita mendapatkan respons sukses (instances.json), tetapi pada saat itu mesin baru saja dibuat tetapi belum dimulai (misalnya, belum ditetapkan alamat IP).  Hal ini diperlukan untuk menunggu peluncuran selesai (biasanya satu menit sudah cukup untuk ini). </li></ul><br><p>  Maka Anda dapat terhubung melalui SSH jika kami tahu alamat IP.  Cukup minta daftar mesin yang sedang berjalan.  Di antara parameter mereka, kami menemukan PublicDnsName atau PublicIpAddress. </p><br><pre> <code class="bash hljs">aws ec2 describe-instances --region</code> </pre> <br><p>  Selanjutnya, kami menjalankan perintah SSH, menunjukkan kunci SSH yang dibuat di atas: </p><br><pre> <code class="plaintext hljs">ssh -I $KEYNAME -oStrictHostKeyChecking=no ubuntu''+ins_dns echo''O''</code> </pre> <br><p>  Perintah SSH memungkinkan Anda untuk mengontrol serangan dan mendapatkan semua informasi tentang keadaan serangan, karena kami telah memberikan contoh dengan semua skrip dan alat yang diperlukan. </p><br><p>  Anda perlu memahami bahwa sebagian besar pertahanan terhadap serangan penolakan layanan memblokir alamat IP dari mana banyak permintaan diterima secara anomali.  Oleh karena itu, alamat IP mesin virtual harus terus berubah untuk mempertahankan kekuatan serangan. </p><br><p>  AWS memberikan alamat IP baru setiap kali mesin mulai.  Oleh karena itu, untuk mengubah IP, Anda harus mematikan dan menghidupkan mesin lagi (tidak perlu menghapusnya!). </p><br><p>  Perbedaan antara mematikan dan menghapus adalah kami mengirim sinyal yang berbeda.  Berhenti - untuk mematikan, mengakhiri - untuk mematikan dan menghapus segera. </p><br><p>  Untuk memantau lalu lintas masuk dari instance, kami menggunakan perintah berikut dengan instance ID: ketika pengukuran lalu lintas dimulai, ketika itu berakhir, untuk periode berapa nilai-nilai dijumlahkan: </p><br><pre> <code class="bash hljs">aws cloudwatch get-metric-statistics --region REGION --namespace AWS/EC2 \ --statistics Sum --metric-name NetworkIn --start-time <span class="hljs-variable"><span class="hljs-variable">$STARTTIME</span></span> --end-time <span class="hljs-variable"><span class="hljs-variable">$FINISHTIME</span></span> --period <span class="hljs-variable"><span class="hljs-variable">$PERIOD</span></span> --dimensions Name=InstanceId,Value=<span class="hljs-variable"><span class="hljs-variable">$INCTANCEID</span></span></code> </pre> <br><h1>  Pemantauan Ketersediaan Layanan </h1><br><p>  Selain itu, untuk melakukan serangan, Anda perlu mengamati apakah layanan yang kami uji masih hidup. </p><br><p>  Kami membuat dan menjalankan skrip "ping" paling sederhana yang memantau ketersediaan port target (53 dan 80 dalam kasus kami). </p><br><p>  Contoh kode Python yang mengotomatiskan pemeriksaan ketersediaan: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span><span class="hljs-function">:</span></span> cmd = [<span class="hljs-string"><span class="hljs-string">'curl'</span></span>, <span class="hljs-string"><span class="hljs-string">'-w'</span></span>, <span class="hljs-string"><span class="hljs-string">'"%{time_total}"'</span></span>, <span class="hljs-string"><span class="hljs-string">'-o'</span></span>, <span class="hljs-string"><span class="hljs-string">'/dev/null'</span></span>, <span class="hljs-string"><span class="hljs-string">'-s'</span></span>, url] result = check_output(cmd).decode(<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>) result = float(json.loads(result)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result * <span class="hljs-number"><span class="hljs-number">1000000</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dns</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ip, domain)</span></span></span><span class="hljs-function">:</span></span> cmd = [<span class="hljs-string"><span class="hljs-string">'dig'</span></span>, <span class="hljs-string"><span class="hljs-string">'any'</span></span>, <span class="hljs-string"><span class="hljs-string">'@'</span></span>+ip, domain ] result = check_output(cmd).decode(<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>) result = int(result.split(<span class="hljs-string"><span class="hljs-string">'Query time:'</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>].split(<span class="hljs-string"><span class="hljs-string">'msec'</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result</code> </pre> <br><p>  Informasi yang diterima disimpan dalam file log, atas dasar itu, berdasarkan pada hasil serangan, akan mungkin untuk membuat grafik ketersediaan sumber daya. </p><br><p>  Selama pengujian, perlu untuk selalu memeriksa log "ping" agar tidak mematikan sumber daya sepenuhnya dan tidak dapat dibatalkan.  Segera setelah degradasi yang signifikan muncul dan respons terhadap permintaan terlalu banyak waktu, serangan harus dihentikan. </p><br><p>  Jika perlambatan tidak signifikan, dan kekuatan serangan telah mencapai maksimum yang ditetapkan, maka masuk akal untuk menunggu satu atau dua menit, dan jika layanan terus bekerja tanpa gangguan, maka pemeriksaan dianggap berhasil. </p><br><h1>  Masalah keuangan </h1><br><p>  Perlu membahas masalah lain yang terkait dengan organisasi pengujian - biaya seluruh acara ini. </p><br><p>  Amazon memberikan informasi harga yang terperinci, tetapi Anda harus memahami bahwa Anda harus membayar hampir semua hal.  Namun demikian, banyak perhitungan dapat diabaikan.  Pertama-tama, ada baiknya menghitung biaya lalu lintas (tergantung pada wilayah dan pada seberapa banyak jumlah total informasi yang akan ditransmisikan) dan biaya penyewaan contoh (pembayaran per menit).  Barang-barang ini membentuk sekitar 99% dari biaya seluruh serangan. </p><br><p>  Oleh karena itu, biaya serangan dihitung dalam setiap kasus secara terpisah, tergantung pada kekuatan serangan maksimum [skala permusuhan] dan jumlah peluncuran yang direncanakan. </p><br><p>  Dari sudut pandang penyederhanaan perhitungan, lebih baik menggunakan akun Amazon, yang terdaftar tidak lebih dari setahun yang lalu.  Maka bagian dari operasi akan bebas.  Baca lebih lanjut tentang batasan penggunaan gratis di <a href="https://aws.amazon.com/ru/free/%3Fall-free-tier.sort-by%3Ditem.additionalFields.SortRank%26all-free-tier.sort-order%3Dasc">sini</a> . </p><br><p>  Untuk mengilustrasikan perhitungan biaya melakukan pengujian beban, katakanlah kita ingin memeriksa stabilitas server DNS ke beban 10 Gb / s. </p><br><p>  Kita tahu bahwa alat yang digunakan dan kemampuan instance t3.small diluncurkan di Mumbai memungkinkan Anda untuk mengeluarkan 500 Mb / s dari satu instance yang sedang berjalan.  Harga untuk menyewa suatu entitas adalah $ 0,0224 per jam, untuk lalu lintas - $ 0,01093 untuk 1 GB.  Artinya, puncak serangan berarti operasi simultan dari 20 entitas. </p><br><p>  Kami akan meningkatkan kekuatan serangan secara bertahap, untuk ini pertama-tama kami meluncurkan satu entitas, kemudian menambahkan yang lain setiap 60 detik. </p><br><p>  Rumus untuk menghitung biaya berupa: </p><br><pre> <code class="plaintext hljs">60  * (   ) + 60  * 0,5 /c * (  ) =       60 . 1 * (    ) + 2 * (    ) + ... + 20 * (    ) =   </code> </pre> <br><p>  Ternyata biaya satu serangan dengan kapasitas 10 Gb / s ke server DNS adalah sekitar $ 70.  Perhatikan bahwa ini adalah perkiraan kasar, karena volume lalu lintas tidak dapat diprediksi secara akurat.      <a href="https://aws.amazon.com/ru/ec2/pricing/on-demand/"></a> .  ,   â€“    ,     . </p><br><p>       .          . </p><cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481756/">https://habr.com/ru/post/id481756/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481746/index.html">Menyiapkan lingkungan di CLI. Terminal WSL / Windows</a></li>
<li><a href="../id481748/index.html">Paket Manfaat di Armenia: dari asuransi dan bonus rujukan hingga pijat dan pinjaman</a></li>
<li><a href="../id481750/index.html">Tugas nomor 3. Konversi data dan unggah ke layanan pihak ketiga</a></li>
<li><a href="../id481752/index.html">Hasil Survei Bahasa</a></li>
<li><a href="../id481754/index.html">Saya bot dan penusuk saya</a></li>
<li><a href="../id481758/index.html">Statistik konstruksi, persediaan dan kunjungan ke ISS</a></li>
<li><a href="../id481762/index.html">Persamaan untuk dapur di bawah pohon Natal</a></li>
<li><a href="../id481764/index.html">Mengapa energi hijau memiliki masa depan yang sulit?</a></li>
<li><a href="../id481770/index.html">Pelopor pemrograman komputer Tony Brucker meninggal pada usia 94</a></li>
<li><a href="../id481774/index.html">Lembar Cheat Keamanan: Penambalan Virtual</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>