<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôãüèΩ ‚û°Ô∏è üôå Gro√ües Interview mit Cliff Click, dem Vater der JIT-Kompilierung in Java üåÖ ü§¥üèº üë®üèº‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cliff Click ist Cratus 'CTO (IoT-Sensoren zur Prozessverbesserung), der Gr√ºnder und Mitbegr√ºnder mehrerer Startups (einschlie√ülich Rocket Realtime Sch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gro√ües Interview mit Cliff Click, dem Vater der JIT-Kompilierung in Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/458718/"><p><img src="https://habrastorage.org/getpro/habr/post_images/bed/01d/799/bed01d799e35f74331803908a94516bb.jpg" width="200" align="left">  <strong>Cliff Click</strong> ist Cratus 'CTO (IoT-Sensoren zur Prozessverbesserung), der Gr√ºnder und Mitbegr√ºnder mehrerer Startups (einschlie√ülich Rocket Realtime School, Neurensic und H2O.ai) mit mehreren erfolgreichen Exits.  Cliff schrieb seinen ersten Compiler im Alter von 15 Jahren (Pascal f√ºr TRS Z-80)!  Am bekanntesten f√ºr die Arbeit an C2 in Java (Sea of ‚Äã‚ÄãNodes IR).  Dieser Compiler hat der Welt gezeigt, dass JIT qualitativ hochwertigen Code produzieren kann, was zu einem der Faktoren geworden ist, die Java zu einer der wichtigsten modernen Softwareplattformen gemacht haben.  Cliff half Azul Systems dann beim Aufbau eines 864-Core-Mainframes mit reiner Java-Software, die GC-Pausen auf einem 500-Gigabyte-Heap f√ºr 10 Millisekunden unterst√ºtzte.  Im Allgemeinen gelang es Cliff, an allen Aspekten der JVM zu arbeiten. <br clear="all"><br>  Dieser Hubrapost ist ein gro√üartiges Interview mit Cliff.  Wir werden √ºber folgende Themen sprechen: </p><br><ul><li>  √úbergang zu Optimierungen auf niedriger Ebene </li><li>  Wie man viel Refactoring macht </li><li>  Kostenmodell </li><li>  Low-Level-Optimierungstraining </li><li>  Fallstudien zur Produktivit√§tsverbesserung </li><li>  Warum erstellen Sie Ihre eigene Programmiersprache? </li><li>  Karriere als Performance Engineer </li><li>  Technische Herausforderungen </li><li>  Ein bisschen √ºber Registerzuordnung und Multicore </li><li>  Die gr√∂√üte Herausforderung im Leben </li></ul><br><p>  Interviews durchgef√ºhrt von: </p><br><ul><li>  <strong>Andrey Satarin</strong> von Amazon Web Services.  In seiner Karriere gelang es ihm, in v√∂llig anderen Projekten zu arbeiten: Er testete die verteilte NewSQL-Datenbank in Yandex, das Cloud-Erkennungssystem in Kaspersky Lab, das Mehrbenutzerspiel in Mail.ru und den Geldwechselberechnungsdienst in der Deutschen Bank.  Er ist daran interessiert, gro√üe Backend- und verteilte Systeme zu testen. </li><li>  <strong>Vladimir Sitnikov</strong> von Netcracker.  Seit zehn Jahren arbeitet er an der Leistung und Skalierbarkeit von NetCracker OS, einer Software, die von Telekommunikationsbetreibern zur Automatisierung von Netzwerk- und Netzwerkger√§teverwaltungsprozessen verwendet wird.  Er interessiert sich f√ºr Leistungsprobleme bei Java- und Oracle-Datenbanken.  Der Autor von mehr als einem Dutzend Leistungsverbesserungen im offiziellen PostgreSQL JDBC-Treiber. <a name="habracut"></a></li></ul><br><h1 id="perehod-k-nizkourovnevym-optimizaciyam">  √úbergang zu Optimierungen auf niedriger Ebene </h1><br><p>  <strong>Andrei</strong> : Sie sind eine ber√ºhmte Person in der Welt der JIT-Kompilierung in Java und arbeiten an der Leistung im Allgemeinen, oder? </p><br><p>  <strong>Cliff</strong> : Das war's! </p><br><p>  <strong>Andrew</strong> : Beginnen wir mit allgemeinen Fragen zur Arbeit an der Leistung.  Was halten Sie von der Wahl zwischen Optimierungen auf hoher und niedriger Ebene wie Arbeiten auf CPU-Ebene? </p><br><p> <strong>Cliff</strong> : Es ist einfach.  Der schnellste Code wird niemals ausgef√ºhrt.  Daher m√ºssen Sie immer von einer hohen Ebene ausgehen und an Algorithmen arbeiten.  Eine bessere O-Notation schl√§gt eine schlechtere O-Notation, es sei denn, einige ziemlich gro√üe Konstanten greifen ein.  Low-Level-Dinge sind die neuesten.  Wenn Sie den Rest des Stapels gut genug optimiert haben und noch etwas Interessantes √ºbrig ist, ist dies normalerweise das niedrige Niveau.  Aber wie fange ich von einem hohen Niveau an?  Wie kann man herausfinden, dass auf hohem Niveau genug Arbeit geleistet wurde?  Nun ... auf keinen Fall.  Es gibt keine vorgefertigten Rezepte.  Sie m√ºssen das Problem verstehen, entscheiden, was Sie tun m√∂chten (um in Zukunft keine unn√∂tigen Schritte zu unternehmen), und dann k√∂nnen Sie einen Profiler aufdecken, der etwas N√ºtzliches sagen kann.  Irgendwann verstehen Sie selbst, dass Sie unn√∂tige Dinge losgeworden sind und es Zeit ist, den niedrigen Pegel zu optimieren.  Dies ist definitiv eine besondere Art von Kunst.  Viele Menschen tun unn√∂tige Dinge, bewegen sich aber so schnell, dass sie keine Zeit haben, sich um die Leistung zu k√ºmmern.  Dies gilt jedoch, solange die Frage nicht aufrecht steht.  Normalerweise k√ºmmert sich in 99% der F√§lle niemand darum, was ich tue, bis eine wichtige Sache, die jemandem wichtig ist, nicht auf den kritischen Pfad gelangt.  Und hier f√§ngt jeder an, Sie √ºber das Thema "Warum es von Anfang an nicht perfekt funktioniert hat" zu nerven.  Im Allgemeinen gibt es immer etwas zu verbessern.  Aber 99% der Zeit haben Sie keine Leads!  Sie versuchen nur, etwas zum Laufen zu bringen, und dabei verstehen Sie, worauf es ankommt.  Man kann nie im Voraus wissen, dass dieses St√ºck perfekt gemacht werden muss, daher muss man im Wesentlichen in allem perfekt sein.  Und das ist unm√∂glich, und das tust du nicht.  Es gibt immer eine Menge Dinge zu reparieren - und das ist v√∂llig normal. </p><br><h1 id="kak-delat-bolshoy-refaktoring">  Wie man viel Refactoring macht </h1><br><p>  <strong>Andrew</strong> : Wie arbeitest du an der Leistung?  Dies ist ein Querschnittsthema.  Mussten Sie beispielsweise an Problemen arbeiten, die sich aus der √úberschneidung einer gro√üen Menge vorhandener Funktionen ergeben? </p><br><p>  <strong>Cliff</strong> : Ich versuche das zu vermeiden.  Wenn ich wei√ü, dass die Leistung zu einem Problem wird, denke ich dar√ºber nach, bevor ich mit dem Codieren beginne, insbesondere bei Datenstrukturen.  Aber oft entdeckt man das alles viel sp√§ter.  Und dann m√ºssen Sie extreme Ma√ünahmen ergreifen und das tun, was ich als ‚Äûumschreiben und erobern‚Äú bezeichne: Sie m√ºssen sich an einem ziemlich gro√üen St√ºck festhalten.  Ein Teil des Codes muss aufgrund von Leistungsproblemen oder etwas anderem noch neu geschrieben werden.  Was auch immer der Grund f√ºr das Umschreiben des Codes ist, es ist fast immer besser, einen gr√∂√üeren Block als einen kleineren Block neu zu schreiben.  In diesem Moment beginnen alle vor Angst zu zittern: "Oh mein Gott, du kannst nicht so viel Code anfassen!"  Tats√§chlich funktioniert dieser Ansatz jedoch fast immer viel besser.  Sie m√ºssen das gro√üe Problem sofort aufgreifen, einen gro√üen Kreis darum zeichnen und sagen: Ich werde alles innerhalb des Kreises neu schreiben.  Der Rand ist viel kleiner als der Inhalt, der ersetzt werden muss.  Und wenn eine solche Abgrenzung der Grenzen es Ihnen erm√∂glicht, die Arbeit im Inneren perfekt zu erledigen - Sie haben Ihre H√§nde gel√∂st, tun, was Sie wollen.  Sobald Sie das Problem verstanden haben, ist der Umschreibvorgang viel einfacher. Bei√üen Sie also einen gro√üen Teil ab! <br>  Wenn Sie in gro√üen Bl√∂cken umschreiben und verstehen, dass die Leistung zu einem Problem wird, k√∂nnen Sie sich sofort Sorgen machen.  Normalerweise werden daraus einfache Dinge wie ‚ÄûDaten nicht kopieren, Daten so einfach wie m√∂glich verwalten, verkleinern‚Äú.  Bei gro√üen Umschreibungen gibt es Standardmethoden zur Verbesserung der Leistung.  Und sie drehen sich fast immer um Daten. </p><br><h1 id="model-stoimosti">  Kostenmodell </h1><br><p>  <strong>Andrew</strong> : In einem der Podcasts haben Sie √ºber Kostenmodelle im Kontext der Produktivit√§t gesprochen.  K√∂nnen Sie erkl√§ren, was damit gemeint war? </p><br><p>  <strong>Cliff</strong> : Nat√ºrlich.  Ich wurde in einer Zeit geboren, in der die Prozessorleistung extrem wichtig war.  Und diese √Ñra kehrt wieder zur√ºck - das Schicksal ist nicht ohne Ironie.  Ich begann in den Tagen von Acht-Bit-Maschinen zu leben, mein erster Computer arbeitete mit 256 Bytes.  Es sind Bytes.  Alles war sehr klein.  Wir mussten die Anweisungen lesen und sobald wir anfingen, den Stapel der Programmiersprachen zu erweitern, nahmen die Sprachen immer mehr an.  Es gab Assembler, dann Basic, dann C, und C √ºbernahm den Job mit vielen Details, wie Registerzuweisung und Befehlsauswahl.  Aber dort war alles ziemlich klar, und wenn ich einen Zeiger auf eine Instanz einer Variablen gemacht habe, werde ich geladen, und die Kosten sind f√ºr diese Anweisung bekannt.  Eisen erzeugt eine bekannte Anzahl von Maschinenzyklen, sodass die Ausf√ºhrungsgeschwindigkeit verschiedener Teile einfach durch Hinzuf√ºgen aller Anweisungen berechnet werden kann, die Sie ausf√ºhren wollten.  Jeder Vergleich / Test / Zweig / Anruf / Laden / Speichern k√∂nnte gefaltet und gesagt werden: Hier haben Sie die Vorlaufzeit.  Wenn Sie die Leistung verbessern, achten Sie auf jeden Fall darauf, welche Zahlen kleinen hei√üen Zyklen entsprechen. <br>  Sobald Sie jedoch zu Java, Python und √§hnlichen Dingen wechseln, entfernen Sie sich sehr schnell von Low-Level-Eisen.  Was kostet ein Getter Call in Java?  Wenn die JIT in HotSpot korrekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">inline ist</a> , wird sie geladen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">andernfalls</a> handelt es sich um einen Funktionsaufruf.  Da die Herausforderung in der Hot-Loop liegt, werden alle anderen Optimierungen in dieser Loop r√ºckg√§ngig gemacht.  Daher wird der reale Wert viel gr√∂√üer sein.  Und Sie verlieren sofort die F√§higkeit, einen Code zu betrachten und zu verstehen, dass wir ihn in Bezug auf die Prozessortaktrate, den verwendeten Speicher und den Cache ausf√ºhren sollten.  All dies wird nur dann interessant, wenn Sie sich wirklich in der Leistung betrunken haben. <br>  Jetzt befinden wir uns in einer Situation, in der die Geschwindigkeit von Prozessoren seit einem Jahrzehnt fast nicht mehr gestiegen ist.  Alte Zeiten sind zur√ºck!  Sie k√∂nnen sich nicht mehr auf eine gute Single-Thread-Leistung verlassen.  Aber wenn Sie pl√∂tzlich parallel arbeiten - es ist wahnsinnig schwierig, sehen Sie alle als James Bond.  Die zehnfache Beschleunigung tritt hier normalerweise an den Stellen auf, an denen jemand etwas schl√§gt.  Parallelit√§t erfordert viel Arbeit.  Um die gleiche zehnfache Beschleunigung zu erhalten, m√ºssen Sie das Kostenmodell verstehen.  Was und wie viel es kostet.  Und daf√ºr m√ºssen Sie verstehen, wie die Zunge auf dem darunter liegenden Eisen liegt. <br>  Martin Thompson hat ein gro√üartiges Wort f√ºr seinen Blog √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mechanische Sympathie</a> !  Sie m√ºssen verstehen, was Eisen tun wird, wie genau es es tun wird und warum es im Allgemeinen das tut, was es tut.  Auf diese Weise k√∂nnen Sie ganz einfach Anweisungen lesen und herausfinden, wo die Ausf√ºhrungszeit flie√üt.  Wenn Sie nicht √ºber die entsprechende Ausbildung verf√ºgen, suchen Sie nur nach einer schwarzen Katze in einem dunklen Raum.  Ich sehe st√§ndig Leute, die die Leistung optimieren und keine Ahnung haben, was zum Teufel sie tun.  Sie sind sehr gequ√§lt und gehen nicht wirklich irgendwohin.  Und wenn ich den gleichen Code nehme, dort ein paar kleine Hacks abschalte und f√ºnf- oder zehnmal beschleunige, sind sie so: Nun, es ist so unehrlich, wir wussten bereits, dass Sie besser sind.  Es ist erstaunlich.  Wor√ºber spreche ich? Das Kostenmodell handelt davon, welchen Code Sie schreiben und wie schnell er im Gesamtbild durchschnittlich funktioniert. </p><br><p>  <strong>Andrew</strong> : Und wie h√§lt man so ein Volumen in deinem Kopf?  Wird dies durch mehr Erfahrung erreicht oder?  Wo werden solche Erfahrungen gesammelt? </p><br><p>  <strong>Cliff</strong> : Nun, meine Erfahrung war nicht der einfachste Weg.  Ich habe in Assembler zu einer Zeit programmiert, als es m√∂glich war, jede einzelne Anweisung zu verstehen.  Es klingt albern, aber seitdem ist in meinem Kopf, in meiner Erinnerung, der Z80-Befehlssatz f√ºr immer geblieben.  Ich erinnere mich eine Minute nach dem Gespr√§ch nicht an die Namen von Personen, aber ich erinnere mich an den Code, der vor 40 Jahren geschrieben wurde.  Komisch, es sieht aus wie ein " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Learned Idiot</a> " -Syndrom. </p><br><h1 id="obuchenie-nizkourovnevym-optimizaciyam">  Low-Level-Optimierungstraining </h1><br><p>  <strong>Andrew</strong> : Gibt es einen einfacheren Weg, um ins Gesch√§ft zu kommen? </p><br><p>  <strong>Cliff</strong> : Ja und nein.  Das Eisen, das wir alle verwenden, hat sich in dieser Zeit nicht so sehr ver√§ndert.  Mit Ausnahme von Arm-Smartphones verwendet jeder x86.  Wenn Sie keine Hardcore-Einbettung vornehmen, haben Sie das Gleiche.  Ok, als n√§chstes.  Auch die Anweisungen haben sich seit Jahrhunderten nicht ge√§ndert.  Sie m√ºssen etwas in Assembler schreiben.  Ein bisschen, aber genug, um zu verstehen.  Du l√§chelst, aber ich meine es absolut ernst.  Sie m√ºssen die Entsprechung von Sprache und Eisen verstehen.  Danach m√ºssen Sie gehen, ein wenig pinkeln und einen kleinen Spielzeug-Compiler f√ºr eine kleine Spielzeugsprache erstellen.  "Spielzeug" bedeutet, dass Sie es in angemessener Zeit schaffen m√ºssen.  Es kann sehr einfach sein, aber es muss Anweisungen generieren.  Durch das Generieren von Anweisungen k√∂nnen wir das Kostenmodell f√ºr die Br√ºcke zwischen dem Code auf hoher Ebene, auf den jeder schreibt, und dem Maschinencode, der auf Hardware ausgef√ºhrt wird, verstehen.  Diese Korrespondenz wird zum Zeitpunkt des Schreibens des Compilers im Gehirn verbrannt.  Selbst der einfachste Compiler.  Danach k√∂nnen Sie sich mit Java und der Tatsache befassen, dass es eine tiefere semantische L√ºcke aufweist, und es ist viel schwieriger, Br√ºcken dar√ºber zu bauen.  In Java ist es viel schwieriger zu verstehen, ob sich unsere Br√ºcke als gut oder schlecht herausgestellt hat, wodurch sie auseinander f√§llt und nicht.  Aber Sie brauchen einen Ausgangspunkt, wenn Sie sich den Code ansehen und verstehen: ‚ÄûJa, dieser Getter muss jedes Mal inline sein‚Äú.  Und dann stellt sich heraus, dass dies manchmal passiert, mit Ausnahme der Situation, in der die Methode zu gro√ü wird und die JIT beginnt, alles zu inline.  Die Leistung solcher Orte kann sofort vorhergesagt werden.  Normalerweise funktionieren Getter gut, aber dann sehen Sie sich die gro√üen Hot-Loops an und stellen fest, dass einige Funktionsaufrufe darin schweben, die nicht wissen, was sie tun.  Dies ist das Problem bei der weit verbreiteten Verwendung von Gettern, der Grund, warum sie nicht inline sind - es ist nicht klar, ob dies ein Getter ist.  Wenn Sie eine superkleine Codebasis haben, k√∂nnen Sie sich einfach daran erinnern und dann sagen: Dies ist ein Getter, aber dies ist ein Setter.  In einer gro√üen Codebasis lebt jede Funktion ihre eigene Geschichte, die im Allgemeinen niemandem bekannt ist.  Der Profiler sagt, dass wir 24% unserer Zeit in einem Zyklus verloren haben. Um zu verstehen, was dieser Zyklus bewirkt, m√ºssen wir uns jede Funktion im Inneren ansehen.  Es ist unm√∂glich, dies zu verstehen, ohne die Funktion zu studieren, und dies verlangsamt den Prozess des Verstehens ernsthaft.  Deshalb benutze ich keine Getter und Setter, ich bin auf ein neues Level gegangen! <br>  Woher bekommen Sie das Kostenmodell?  Nat√ºrlich k√∂nnen Sie etwas lesen ... Aber ich denke, der beste Weg ist zu handeln.  Erstellen Sie einen kleinen Compiler, und dies ist der beste Weg, um das Kostenmodell zu realisieren und in Ihren eigenen Kopf zu integrieren.  Ein kleiner Compiler, der f√ºr die Mikrowellenprogrammierung geeignet ist, ist eine Aufgabe f√ºr Anf√§nger.  Nun, ich meine, wenn Sie bereits Programmierkenntnisse haben, sollten diese ausreichen.  All diese Dinge sind wie das Parsen eines Strings, f√ºr den Sie eine Art algebraischen Ausdruck haben, die Anweisungen f√ºr mathematische Operationen in der richtigen Reihenfolge herausziehen und die richtigen Werte aus den Registern entnehmen - all dies wird gleichzeitig durchgef√ºhrt.  Und w√§hrend Sie es tun, wird es im Gehirn eingepr√§gt.  Ich denke, jeder wei√ü, was der Compiler macht.  Und dies gibt ein Verst√§ndnis f√ºr das Kostenmodell. </p><br><h1 id="prakticheskie-primery-uluchsheniya-proizvoditelnosti">  Fallstudien zur Produktivit√§tsverbesserung </h1><br><p>  <strong>Andrew</strong> : Worauf sollte man bei der Arbeit an der Leistung noch achten? </p><br><p>  <strong>Cliff</strong> : Datenstrukturen.  √úbrigens, ja, ich habe diese Klassen schon lange nicht mehr unterrichtet ... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rocket School</a> .  Es war lustig, aber es hat so viel M√ºhe gekostet, zu investieren, und ich habe auch Leben!  Okay.  In einer der gro√üen und interessanten Klassen, ‚ÄûWohin geht Ihre Leistung?‚Äú, Gab ich den Sch√ºlern ein Beispiel: Zweieinhalb Gigabyte Fintech-Daten wurden aus einer CSV-Datei gelesen, und dann mussten wir die Anzahl der verkauften Produkte berechnen.  Regelm√§√üige Zeckenmarktdaten.  UDP-Pakete wurden seit den 70er Jahren in das Textformat konvertiert.  Die Chicago Mercantile Exchange ist alles M√∂gliche wie Butter, Mais, Sojabohnen und dergleichen.  Es war notwendig, diese Produkte, die Anzahl der Transaktionen, das durchschnittliche Volumen der Bewegung von Geldern und Waren usw. zu z√§hlen.  Dies ist eine ziemlich einfache Handelsmathematik: Suchen Sie den Produktcode (dies sind 1-2 Zeichen in der Hash-Tabelle), ermitteln Sie den Betrag, f√ºgen Sie ihn zu einem der Deal-Sets hinzu, f√ºgen Sie Volumen, Mehrwert und einige andere Dinge hinzu.  Sehr einfache Mathematik.  Die Implementierung des Spielzeugs war sehr einfach: Alles liegt in der Datei, ich lese die Datei und bewege mich darin, trenne die einzelnen Eintr√§ge in Java-Strings, suche nach den notwendigen Dingen in ihnen und falte sie gem√§√ü der oben beschriebenen Mathematik.  Und es funktioniert mit niedriger Geschwindigkeit. </p><br><p> Bei diesem Ansatz ist alles offensichtlich, was passiert, und paralleles Rechnen hilft hier nicht weiter, oder?  Es stellt sich heraus, dass eine Verf√ºnffachung der Produktivit√§t nur durch Auswahl der richtigen Datenstrukturen erreicht werden kann.  Und das √ºberrascht sogar erfahrene Programmierer!  In meinem speziellen Fall bestand der Trick darin, dass Sie keine Speicherzuweisungen in einer Hot-Loop durchf√ºhren sollten.  Nun, das ist nicht die ganze Wahrheit, aber im Allgemeinen - Sie sollten "einmal in X" nicht hervorheben, wenn X gro√ü genug ist.  Wenn X zweieinhalb Gigabyte betr√§gt, sollten Sie nichts "einmal pro Buchstabe" oder "einmal pro Zeile" oder "einmal pro Feld" zuweisen, nichts dergleichen.  Genau das braucht Zeit.  Wie funktioniert es √ºberhaupt?  Stellen Sie sich vor, Sie rufen <code>String.split()</code> oder <code>BufferedReader.readLine()</code> .  <code>Readline</code> eine Zeile aus einer Reihe von Bytes, die √ºber das Netzwerk <code>Readline</code> , einmal f√ºr jede Zeile und f√ºr jede von Hunderten von Millionen Zeilen.  Ich nehme diese Zeile, analysiere und werfe sie weg.  Warum wegwerfen - nun, ich habe es bereits verarbeitet, das ist alles.  F√ºr jedes aus diesen 2.7G gelesene Byte werden also zwei Zeichen in die Zeile geschrieben, dh bereits 5.4G, und ich brauche sie nicht mehr, daher werden sie verworfen.  Wenn Sie sich die Speicherbandbreite ansehen, laden wir 2,7 G, die den Speicher und den Speicherbus im Prozessor durchlaufen, und dann wird doppelt so viel an die im Speicher liegende Zeile gesendet, und all dies wird beim Erstellen jeder neuen Zeile gerieben.  Aber ich muss es lesen, das Eisen liest es, auch wenn dann alles gerieben wird.  Und ich muss es aufschreiben, weil ich die Zeile erstellt habe und die Caches voll waren - der Cache passt nicht f√ºr 2.7G.  Insgesamt lese ich f√ºr jedes gelesene Byte zwei weitere Bytes und schreibe zwei zus√§tzliche Bytes. Infolgedessen haben sie ein Verh√§ltnis von 4: 1 - in diesem Verh√§ltnis verschwenden wir Speicherbandbreite.  Und dann stellt sich heraus, dass, wenn ich <code>String.split()</code> mache, dies nicht das letzte Mal mache, m√∂glicherweise weitere 6-7 Felder darin sind.  Daher f√ºhrt der klassische CSV-Lesecode, gefolgt von Zeilenanalyse, zu einem Verlust der Speicherbandbreite im Bereich von 14: 1 im Vergleich zu dem, was Sie wirklich gerne h√§tten.  Wenn Sie diese Sekrete wegwerfen, k√∂nnen Sie eine f√ºnffache Beschleunigung erzielen. </p><br><p>  Und das ist nicht sehr schwierig.  Wenn Sie den Code aus dem richtigen Winkel betrachten, wird alles ganz einfach, sobald Sie die Essenz des Problems erkennen.  H√∂ren Sie nicht einmal auf, Speicher zuzuweisen: Das einzige Problem besteht darin, dass Sie etwas zuweisen, das sofort stirbt und eine wichtige Ressource auf dem Weg verbrennt, in diesem Fall die Speicherbandbreite.  All dies f√ºhrt zu einem R√ºckgang der Produktivit√§t.  Unter x86 m√ºssen Sie normalerweise die Prozessortakte aktiv brennen, und hier haben Sie den gesamten Speicher viel fr√ºher gebrannt.  L√∂sung - Sie m√ºssen die Entladungsmenge reduzieren. <br>  Ein weiterer Teil des Problems besteht darin, dass Sie, wenn Sie den Profiler nach Beendigung des Speicherstreifens starten, in dem Moment, in dem dies geschieht, normalerweise auf die R√ºckkehr des Caches warten, da er voller M√ºll ist, den Sie gerade mit all diesen Zeilen erzeugt haben.  Daher wird jede Lade- oder Speicheroperation langsam, da sie zu Fehlern im Cache f√ºhrt - der gesamte Cache wurde langsam und wartet darauf, dass der M√ºll ihn verl√§sst.  Daher zeigt der Profiler nur warmes, zuf√§lliges Rauschen an, das w√§hrend des gesamten Zyklus verschmiert ist - es gibt keine separate Hot-Anweisung oder Stelle im Code.  Nur der L√§rm.  Und wenn Sie sich die GC-Zyklen ansehen, sind sie alle Young Generation und superschnell - maximal Mikrosekunden oder Millisekunden.  Immerhin stirbt all diese Erinnerung sofort.  Sie weisen Milliarden von Gigabyte zu, und es schneidet sie und schneidet und schneidet sie erneut.  All dies geschieht sehr schnell.  Es stellt sich heraus, dass es billige GC-Zyklen gibt, warmes Rauschen w√§hrend des gesamten Zyklus, aber wir wollen eine 5-fache Beschleunigung.  In diesem Moment sollte sich etwas in meinem Kopf schlie√üen und klingen: "Warum so ?!"  Der Bandbreiten√ºberlauf wird im klassischen Debugger nicht angezeigt. Sie m√ºssen den Debugger f√ºr den Hardware-Leistungsindikator ausf√ºhren und ihn selbst und direkt anzeigen.  Und nicht direkt, es kann von diesen drei Symptomen vermutet werden.  Das dritte Symptom ist, wenn Sie sich ansehen, was Sie hervorheben, den Profiler fragen und er antwortet: "Sie haben eine Milliarde Zeilen erstellt, aber der GC hat kostenlos funktioniert."  Sobald dies passiert ist, stellen Sie fest, dass Sie zu viele Objekte erzeugt und den gesamten Speicherstreifen verbrannt haben.  Es gibt einen Weg, dies herauszufinden, aber es ist nicht offensichtlich. </p><br><p>  Das Problem liegt in der Datenstruktur: Die blo√üe Struktur hinter allem, was passiert, ist zu gro√ü, es ist 2,7 G auf der Festplatte, daher ist das Erstellen einer Kopie dieses Dings sehr unerw√ºnscht - ich m√∂chte es sofort aus dem Netzwerkbytepuffer in die Register laden, um nicht in die Zeichenfolge zu lesen und zu schreiben f√ºnfmal hin und her.  Leider bietet Ihnen Java standardm√§√üig keine solche Bibliothek als Teil des JDK.  Aber das ist trivial, oder?  Tats√§chlich sind dies 5-10 Codezeilen, die zum Implementieren Ihres eigenen gepufferten Zeilenladers verwendet werden, der das Verhalten der Zeilenklasse wiederholt und gleichzeitig einen Wrapper um den zugrunde liegenden Bytepuffer darstellt.  Infolgedessen stellt sich heraus, dass Sie fast wie mit Zeichenfolgen arbeiten, aber tats√§chlich gibt es bewegliche Zeiger auf den Puffer, und Rohbytes werden nirgendwo kopiert, und daher werden dieselben Puffer immer wieder verwendet, und das Betriebssystem √ºbernimmt dies gerne Dinge, f√ºr die es bestimmt ist, wie das versteckte doppelte Puffern dieser Bytepuffer, und Sie selbst mahlen keinen endlosen Strom unn√∂tiger Daten mehr.  √úbrigens, Sie verstehen, wenn Sie mit dem GC arbeiten, ist garantiert, dass nicht jede Speicherzuordnung f√ºr den Prozessor nach dem letzten GC-Zyklus sichtbar ist?  Daher kann sich all dies in keiner Weise im Cache befinden, und dann tritt ein zu 100% garantierter Fehler auf.  Wenn Sie mit einem Zeiger auf x86 arbeiten, dauert das Subtrahieren eines Registers vom Speicher 1-2 Zyklen. Sobald dies geschieht, zahlen Sie, zahlen, zahlen, da sich der Speicher ausschlie√ülich in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NEUN Caches befindet</a> - und dies sind die Kosten f√ºr die Zuweisung von Speicher.  Barwert. </p><br><p>  Mit anderen Worten, Datenstrukturen sind am schwierigsten zu √§ndern.  Und sobald Sie feststellen, dass Sie die falsche Datenstruktur gew√§hlt haben, die die Produktivit√§t in Zukunft beeintr√§chtigen wird, m√ºssen Sie normalerweise die wesentlichen Arbeiten ankurbeln. Wenn Sie dies jedoch nicht tun, wird es schlimmer.  Zun√§chst m√ºssen Sie √ºber Datenstrukturen nachdenken, dies ist wichtig.  Die Hauptkosten liegen hier bei den fett gedruckten Datenstrukturen, die sie im Stil von "Ich habe die Datenstruktur X in die Datenstruktur Y kopiert, weil mir die Form besser gef√§llt" verwenden.  Aber der Kopiervorgang (der billig erscheint) verbraucht tats√§chlich einen Speicherstreifen und hier ist die gesamte verlorene Laufzeit begraben.  Wenn ich einen riesigen String mit JSON habe und ihn in einen strukturierten DOM-Baum von POJO oder √§hnlichem verwandeln m√∂chte, wird sich das Parsen dieses Strings und das Erstellen eines POJO und ein neuer Aufruf von POJO in Zukunft als wertlos herausstellen - das ist keine billige Sache.  Au√üer wenn Sie viel h√§ufiger mit POJO als mit einer Leitung arbeiten.  Stattdessen k√∂nnen Sie sofort versuchen, die Zeichenfolge zu entschl√ºsseln und nur das herauszuholen, was Sie ben√∂tigen, ohne sie in POJOs umzuwandeln.  Wenn all dies auf dem Pfad geschieht, von dem aus maximale Leistung erforderlich ist, keine POJOs f√ºr Sie - Sie m√ºssen sich irgendwie direkt in die Leitung graben. </p><br><h1 id="zachem-sozdavat-svoy-yazyk-programmirovaniya">  Warum erstellen Sie Ihre eigene Programmiersprache? </h1><br><p>  <strong>Andrei</strong> : Sie sagten, um das Kostenmodell zu verstehen, m√ºssen Sie Ihre eigene kleine Sprache schreiben ... </p><br><p>  <strong>Cliff</strong> : Keine Sprache, sondern ein Compiler.  Sprache und Compiler sind zwei verschiedene Dinge.  Der wichtigste Unterschied liegt in Ihrem Kopf. </p><br><p>  <strong>Andrei</strong> : √úbrigens, soweit ich wei√ü, experimentieren Sie damit, Ihre eigenen Sprachen zu erstellen.  Warum? </p><br><p>  <strong>Cliff</strong> : Weil ich kann!  Ich bin halb im Ruhestand, das ist also mein Hobby.  Ich habe mein ganzes Leben lang die Sprachen anderer implementiert.  Ich habe auch hart am Codierungsstil gearbeitet.  Und auch, weil ich Probleme in anderen Sprachen sehe.  Ich sehe, dass es bessere M√∂glichkeiten gibt, die √ºblichen Dinge zu tun.  Und ich w√ºrde sie benutzen.  Ich habe es einfach satt, Probleme in mir selbst, in Java, in Python und in jeder anderen Sprache zu sehen.  Ich schreibe √ºber React Native, JavaScript und Elm als Hobby, bei dem es nicht um Ruhestand geht, sondern um aktive Arbeit.  Au√üerdem schreibe ich in Python und werde h√∂chstwahrscheinlich weiterhin am maschinellen Lernen f√ºr Java-Backends arbeiten.  Es gibt viele beliebte Sprachen und alle haben interessante Funktionen.  Jeder kann etwas f√ºr sich und Sie k√∂nnen versuchen, all diese Chips zusammenzubringen.  Also studiere ich die Dinge, die f√ºr mich interessant sind, das Verhalten der Sprache und versuche, eine vern√ºnftige Semantik zu finden.  Und bis jetzt mache ich es!  Im Moment habe ich Probleme mit der Semantik des Speichers, weil ich sie sowohl in C als auch in Java haben m√∂chte und ein starkes Speichermodell und eine starke Speichersemantik f√ºr Ladevorg√§nge und Speicher erhalten m√∂chte.  Haben Sie gleichzeitig eine automatische Typinferenz wie in Haskell.  Hier versuche ich, Haskell-√§hnliche Typinferenz mit Speicher zu mischen, der sowohl in C als auch in Java funktioniert.  Ich mache das zum Beispiel seit 2-3 Monaten. </p><br><p>  <strong>Andrei</strong> : Wenn Sie eine Sprache bauen, die bessere Aspekte aus anderen Sprachen √ºbernimmt, haben Sie gedacht, dass jemand das Gegenteil tun w√ºrde: Nehmen Sie Ihre Ideen und verwenden Sie sie? </p><br><p>  <strong>Cliff</strong> : So erscheinen neue Sprachen!  Warum √§hnelt Java C?  Weil C eine gute Syntax hatte, die jeder verstand, und Java von dieser Syntax inspiriert war, die Typensicherheit hinzuf√ºgte, die Grenzen von Arrays und GC √ºberpr√ºfte und einige Dinge gegen√ºber C verbesserte. Sie f√ºgten ihre eigene hinzu.  Aber sie waren ziemlich inspiriert, oder?  Jeder steht auf den Schultern der Riesen, die vor Ihnen kamen - so werden Fortschritte erzielt. </p><br><p>  <strong>Andrew</strong> : Soweit ich wei√ü, ist Ihre Sprache in Bezug auf die Speichernutzung sicher.  Haben Sie jemals daran gedacht, so etwas wie einen Leihpr√ºfer von Rust zu implementieren?  Du hast ihn angesehen, wie hat er dich gemocht? </p><br><p>  <strong>Cliff</strong> : Nun, ich schreibe seit Ewigkeiten C, mit all diesen Malloc und Free, und ich verwalte die Lebensdauer manuell.  Sie wissen, dass 90-95% einer manuell verwalteten Lebenszeit dieselbe Struktur haben.  Und es ist sehr, sehr schmerzhaft, dies manuell zu tun.  Ich m√∂chte, dass der Compiler einfach sagt, was dort passiert und was Sie mit Ihren Aktionen erreicht haben.  F√ºr einige Dinge erledigt ein Kreditpr√ºfer dies sofort.  Und er sollte automatisch Informationen anzeigen, alles verstehen und mich nicht einmal belasten, um dieses Verst√§ndnis auszudr√ºcken.  Er sollte mindestens eine lokale Escape-Analyse durchf√ºhren. Nur wenn dies nicht gelingt, m√ºssen Sie Typanmerkungen hinzuf√ºgen, die die Lebensdauer beschreiben. Ein solches Schema ist viel komplizierter als ein Leihpr√ºfer oder ein vorhandener Speicherpr√ºfer.  Die Wahl zwischen "alles ist in Ordnung" und "ich habe nichts verstanden" - nein, es muss etwas Besseres geben. <br>  Als Person, die viel C-Code geschrieben hat, denke ich, dass die Unterst√ºtzung der automatischen Lebensdauerkontrolle das Wichtigste ist.  Und ich habe es satt, wie viel Java Speicher verwendet, und die Hauptbeschwerde liegt in GC.  Wenn Sie Speicher in Java zuweisen, geben Sie nicht den Speicher zur√ºck, der in der letzten GC-Schleife lokal war.  In Sprachen mit genauerer Speicherverwaltung ist dies nicht der Fall.  Wenn Sie malloc aufrufen, erhalten Sie sofort den Speicher, der normalerweise nur verwendet wurde.  Normalerweise machen Sie einige vor√ºbergehende Dinge mit Ihrem Ged√§chtnis und bringen es sofort zur√ºck.  Und sie kehrt sofort zum Malloc-Pool zur√ºck und der n√§chste Malloc-Zyklus zieht sie wieder heraus.  Daher wird die tats√§chliche Speichernutzung zu einem bestimmten Zeitpunkt auf eine Reihe lebender Objekte sowie auf Lecks reduziert.  Und wenn nicht alles auf Ihre unanst√§ndige Weise flie√üt, wird der gr√∂√üte Teil des Speichers in Caches und im Prozessor gespeichert und funktioniert schnell.  Aber es erfordert viel manuelle Speicherverwaltung mit malloc und free, aufgerufen in der richtigen Reihenfolge, am richtigen Ort.  Rust selbst kann dies korrekt handhaben und bietet in vielen F√§llen eine noch h√∂here Leistung, da der Speicherverbrauch nur auf die aktuellen Berechnungen beschr√§nkt wird - anstatt auf den n√§chsten GC-Zyklus zu warten, um Speicher freizugeben.  Als Ergebnis haben wir einen sehr interessanten Weg gefunden, um die Leistung zu verbessern.  Und ziemlich m√§chtig - in dem Sinne, dass ich solche Dinge bei der Verarbeitung von Daten f√ºr die Fintech getan habe, und dies erm√∂glichte mir, f√ºnfmal zu beschleunigen.  Dies ist eine ziemlich gro√üe Beschleunigung, insbesondere in einer Welt, in der Prozessoren nicht schneller werden und wir alle weiterhin auf Verbesserungen warten. </p><br><h1 id="karera-performans-inzhenera">  Karriere als Performance Engineer </h1><br><p>  <strong>Andrew</strong> : Ich m√∂chte auch nach der Karriere als Ganzes fragen.  Sie wurden ber√ºhmt daf√ºr, dass Sie bei JIT bei HotSpot gearbeitet haben und dann zu Azul gewechselt sind - und dies ist auch eine JVM-Firma.  Aber sie besch√§ftigten sich bereits mehr mit Eisen als mit Software.  Und dann pl√∂tzlich auf Big Data und maschinelles Lernen umgestellt und dann auf Betrugserkennung.  Wie ist es passiert?  Dies sind sehr unterschiedliche Entwicklungsbereiche. </p><br><p>  <strong>Cliff</strong> : Ich programmiere schon seit einiger Zeit und habe es geschafft, in sehr unterschiedlichen Klassen einzuchecken.  Und wenn Leute sagen: "Oh, du bist derjenige, der JIT f√ºr Java gemacht hat!", Ist das immer lustig.  Zuvor besch√§ftigte ich mich jedoch mit dem PostScript-Klon - der Sprache, die Apple einst f√ºr seine Laserdrucker verwendete.  Und davor hat er die Forth-Sprache implementiert.  Ich denke, das gemeinsame Thema f√ºr mich ist die Entwicklung von Werkzeugen.  Mein ganzes Leben lang habe ich Werkzeuge entwickelt, mit denen andere Leute ihre coolen Programme schreiben.  Ich war aber auch an der Entwicklung von Betriebssystemen, Treibern, Debuggern auf Kernel-Ebene und Sprachen f√ºr die Entwicklung des Betriebssystems beteiligt, die trivial begannen, aber im Laufe der Zeit wurde alles kompliziert und kompliziert.  Das Hauptthema ist jedoch die Entwicklung von Werkzeugen.  Ein gro√üer Teil des Lebens ging zwischen Azul und Sun, und es ging um Java.  Aber als ich mit Big Data und maschinellem Lernen anfing, setzte ich meinen Hut wieder auf und sagte: ‚ÄûOh, und jetzt haben wir ein nicht triviales Problem, und hier passieren viele interessante Dinge und Leute, die etwas tun.‚Äú  Dies ist ein gro√üartiger Entwicklungspfad, der sich lohnt. </p><br><p>  Ja, ich mag verteiltes Rechnen wirklich.  Mein erster Job war als Student in C bei einem Werbeprojekt.  Diese wurden auf Zilog Z80-Chips verteilt, die Daten f√ºr die analoge optische Texterkennung sammelten, die von einem echten analogen Analysator erzeugt wurden.  Es war ein cooles und v√∂llig anormales Thema.  Aber es gab Probleme, ein Teil wurde nicht richtig erkannt, so dass es notwendig war, ein Bild zu machen und es einer Person zu zeigen, die bereits mit den Augen las und informierte, was dort gesagt wurde, und daher gab es Datenjugger, und dieser Job hatte seine eigene Sprache .  Es gab ein Backend, das all dies erledigte - parallel zum Z80 mit vt100-Terminals - eines pro Person, und es gab ein paralleles Programmiermodell auf dem Z80.  Ein bestimmtes gemeinsames St√ºck Speicher, das von allen Z80 innerhalb einer Sternkonfiguration gemeinsam genutzt wird.  Die R√ºckwandplatine wurde gemeinsam genutzt, und die H√§lfte des Arbeitsspeichers wurde im Netzwerk gemeinsam genutzt, und die andere H√§lfte war privat oder wurde f√ºr etwas anderes ausgegeben.  Ein sinnvoll komplexes parallel verteiltes System mit gemeinsam genutztem ... semi-gemeinsam genutztem Speicher.  Als es war ... Schon nicht zu erinnern, irgendwo Mitte der 80er Jahre.  Vor ziemlich langer Zeit. <br>  Ja, wir gehen davon aus, dass 30 Jahre eine ziemlich lange Zeit sind. Aufgaben im Zusammenhang mit verteiltem Computing gibt es schon seit langer Zeit, Menschen haben lange mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beowulf-</a> Clustern gek√§mpft.  Solche Cluster sehen aus wie ... Zum Beispiel: Es gibt Ethernet und Ihr schnelles x86 ist mit diesem Ethernet verbunden, und jetzt m√∂chten Sie gef√§lschten gemeinsamen Speicher erhalten, da dann niemand das Codieren von verteiltem Computing durchf√ºhren konnte. Es war zu kompliziert und daher gef√§lschter gemeinsamer Speicher mit Schutz x86-Speicherseiten, und wenn Sie auf diese Seite geschrieben haben, haben wir den anderen Prozessoren mitgeteilt, dass sie von Ihnen heruntergeladen werden m√ºssen, wenn sie Zugriff auf denselben gemeinsam genutzten Speicher haben. Daher wird so etwas wie ein Protokoll zur Unterst√ºtzung der Cache-Koh√§renz angezeigt und Software daf√ºr.  Interessantes Konzept.  Das eigentliche Problem war nat√ºrlich anders.  All dies hat funktioniert, aber Sie haben schnell Leistungsprobleme bekommen, weil niemand die Leistungsmodelle gut genug verstanden hat - welche Speicherzugriffsmuster gibt es, wie Sie sicherstellen k√∂nnen, dass die Knoten sich nicht endlos anpingen und so weiter. </p><br><p>  In H2O habe ich mir Folgendes ausgedacht: Die Entwickler selbst sind daf√ºr verantwortlich zu bestimmen, wo die Parallelit√§t verborgen ist und wo nicht.  Ich habe mir ein solches Codierungsmodell ausgedacht, dass das Schreiben von Hochleistungscode einfach und unkompliziert war.  Das Schreiben von langsam laufendem Code ist jedoch schwierig, es wird schlecht aussehen.  Sie m√ºssen ernsthaft versuchen, langsamen Code zu schreiben, Sie m√ºssen nicht standardm√§√üige Methoden verwenden.  Der Bremscode ist auf einen Blick sichtbar.  Infolgedessen wird normalerweise Code geschrieben, der schnell funktioniert. Sie m√ºssen jedoch herausfinden, was bei gemeinsamem Speicher zu tun ist.  All dies ist an gro√üe Arrays gebunden und das Verhalten dort ist √§hnlich wie bei nichtfl√ºchtigen gro√üen Arrays in parallelem Java.  Ich meine, stellen Sie sich vor, zwei Threads schreiben in ein paralleles Array, einer gewinnt und der andere verliert, und Sie wissen nicht, welcher von ihnen wer ist.  Wenn sie nicht volatil sind, kann die Reihenfolge alles sein - und es funktioniert wirklich gut.  Die Leute k√ºmmern sich wirklich um die Reihenfolge der Operationen, sie stellen die Volatilit√§t richtig ein und sie erwarten Speicherprobleme an den richtigen Stellen.  Andernfalls w√ºrden sie einfach Code in Form von Zyklen von 1 bis N schreiben, wobei N einige Billionen betr√§gt, in der Hoffnung, dass alle komplexen F√§lle automatisch parallel werden - und dort funktioniert es nicht.  In H2O ist dies jedoch weder Java noch Scala. Sie k√∂nnen es als "Java minus minus" betrachten, wenn Sie m√∂chten.  Dies ist ein sehr verst√§ndlicher Programmierstil, der dem Schreiben von einfachem C- oder Java-Code mit Schleifen und Arrays √§hnelt.  Gleichzeitig kann der Speicher mit Terabyte verarbeitet werden.  Ich benutze immer noch H2O.        ‚Äì        ,     .    Big Data   ,    H2O. </p><br><h1 id="tehnicheskie-chellenzhi">   </h1><br><p> <strong></strong> :          ? </p><br><p> <strong></strong> :        ?   ,    ‚Äì  . <br>    .    .    ,     ,     ,      ,  .     Sun,   ,    ,      ,       .      ,      ,   .     ,   C1,      ,    ‚Äì      .                   ,         . ,         x86-    ,    ,      5-10    ,       50 . </p><br><p>  ,       ,        ,        ,    C.  , ,   - ,   C  .       C,       C    .   ,    ,     C,      - ‚Ä¶    ,      .     ,      .     ,           ,     .      ,    ,        5% .          -    ‚Äì     ,         ¬´     ¬ª,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ,    .     :               ,  ,    .     .  ,     ‚Äì    ,       .    ,        .       -  ‚Äì    .   ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>   ,    (   ,   ),  ,     ,       .       ,    ,     ,      . </p><br><p>   , ,    ,  ,     ,       ,   .    ,   ,        ,   -   .     ,     ,     ,          .    ,      ,       ,  ,    . ,     :     ,           . ,   ,  - : ,   ,   -   ,    .      ‚Äì  , ,    ‚Äì   ! ‚Äì     ,      .       Java. Java    ,         ,   ,   ,       ‚Äì   ,       ¬´  ¬ª.           , ,   .            ,   Java  C    .    ‚Äì      Java,       C   ,   ,    ,   . ,    ‚Äì  ,      .    ,  .    ,    ,       .     :      . </p><br><h1 id="nemnogo-pro-allokaciyu-registrov-i-mnogoyadernost">       </h1><br><p> <strong></strong> :      -   . ,   ,  -   ,     ? </p><br><p> <strong></strong> : !   ‚Äì  ,     NP-     - .        , ?   . , Ahead of Time  ‚Äì    .     -  .   ,       ,       ‚Äì   ,      !   ‚Äì  ,   .       ,      ,    .    .   ?    ,       : ,   ,   -  !  -  ,             .   .     ,       ,       .      : - , - .        ,      ,   .  ,     ,  ,      ,     - .    !      ,     ,  ,   ‚Äì        .    .      NP- . </p><br><p> <strong></strong> :  ,       ‚Äì    . ,   ,   ,   ,     ‚Ä¶ </p><br><p> <strong></strong> :     .       ¬´¬ª.       .   ,     .        ‚Äì  ,  ,  ,             ( , ).   ,  -  .    ,   ,   ,        . , ,   .            ,     .   ,             ,     .     ,   ,   .          ,     ,  -       ,     ‚Äì .      ‚Äì              . ,     GC,    , ,  ,     ‚Äì  ,     .    ,  .              ,     ,         . ,   ‚Äì    , ?       ,       . </p><br><p> <strong></strong> :     ,    ?   ? </p><br><p> <strong></strong> :  GPU ,   ! </p><br><p> <strong></strong> :   .      ? </p><br><p> <strong></strong> : ,   - Azul.     ,      .      .   H2O  ,       .     ,    GPU.            ? ,     Azul,  :   ‚Äì  . </p><br><h1 id="samyy-bolshoy-chellenzh-v-zhizni">      </h1><br><p> <strong></strong> :    ? </p><br><p> <strong></strong> :      ,   ‚Ä¶     .   ,       . ,    ,    ,   ,             .   ,   ,    . ,   Java   C1  C2 ‚Äì   . ,   Java        ‚Äì   . ,      ,    ‚Äì    .       ‚Ä¶   . - ,      Sun,  ‚Ä¶ ,   ,        .     ,           .  ,        .       ‚Ä¶        ‚Ä¶  ,        .   , , .       .     - ,      :   .  , , ,   ,  ,    ,     .   ,        .          .      ,    . ¬´    ,   ,   ¬ª.   : ¬´!¬ª.    ,  , , : ,           . </p><br><p>  ‚Äì    ,    ,       ,     .      .      ,        ,            ,  ,    .  ,      Java JIT,  C2.       ,  ‚Äì         .       ,   ‚Äì   !    .  ,   ,  ,     ,    ,       ,    .        .    .        ,   . ,      ,       ,      ,        :      ,     ,     .   ,           ‚Äì      .       ,     ,      -   .     : ¬´     ?¬ª.  ,          .      ,     ,      : ,    ,        ‚Äì     ?       ,  .  ,   ,  ,  ,         ,    ,     - . </p><br><p> <strong></strong> :         ,    -.     ? </p><br><p> <strong></strong> : ,     ,       .      ‚Äì   .      . ,    .        .          .   :    ,   ,   - ‚Äì          .      .  ,       ,      ‚Äì   ,       . ,    ,    ,          ,  -  ,        .       ,       .       ,       ,     - .   ,    ,     ‚Äì   ,  . <br>       ,    .   ,    ‚Äì   ,   ,    .  ,   .     ,       ‚Äì   .     ,       .   ,     ,     ¬´  ¬ª,      ,  ‚Äì   ,   ,       ,     ,        .     ,  ,    ¬´  ¬ª. </p><br><p>       .   .   - ,      ,        ¬´¬ª:    ,    ‚Äì .  ‚Äì     .         ,  ,    . ¬´,     -,     ,    ¬ª.       ,     : ,  .  ,     ,     .  Das ist schlecht.   ‚Äì ,     . , ?  ,     ?    ? ,          ?        .       ,  .    ‚Äì   .     .  ,     .     ‚Äì    ‚Äì  ,        .        ,   ¬´ ¬ª   .    : ¬´--¬ª,  : ¬´, !¬ª   .   .   ,       ,   ,    ,        .     ,      .        ,         .    ,         ‚Äì      ,    .    ‚Äì   ,            .      ,    ,   ,   . </p><br><p> ,           ‚Äì   , .          ,        , .    ,   .         ,    ,    ,    ,      .        ,      ,       . ,       ,      ,          ,      .          .     ,      ,     ,      .    ,     ,    ,        ,    .      , ,    ,   .   ,       ‚Äì  , ,    ,      .     ,     . </p><br><p> <strong></strong> :  ‚Ä¶ . ,          .          .   Hydra! </p><br><blockquote>         Hydra 2019,   11-12  2019   -.     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">¬´The Azul Hardware Transactional Memory experience¬ª</a> .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458718/">https://habr.com/ru/post/de458718/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458704/index.html">Implementierung eines DLP-Systems am Beispiel des Einzelhandels</a></li>
<li><a href="../de458706/index.html">Gopniks sind jetzt auf ausl√§ndischen M√§rkten oder "Warum ist es so schwierig, einen normalen Programmierer zu finden?"</a></li>
<li><a href="../de458708/index.html">M√∂chten Sie <s> abnehmen </ s>, um IT selbst zu lernen? Frag mich wie</a></li>
<li><a href="../de458710/index.html">Whitespace Obfuscator f√ºr PHP</a></li>
<li><a href="../de458716/index.html">Schauen Sie sich zuerst die Delta Amplon RT USV an</a></li>
<li><a href="../de458720/index.html">Die Programmierschule hh.ru er√∂ffnet zum 10. Mal eine Reihe von IT-Spezialisten</a></li>
<li><a href="../de458724/index.html">Neuronale Netze und tiefes Lernen, Kapitel 3, Teil 1: Verbesserung des Trainings neuronaler Netze</a></li>
<li><a href="../de458726/index.html">Habr Special // Podcast mit Autor von Invasion. Eine kurze Geschichte russischer Hacker</a></li>
<li><a href="../de458728/index.html">Was sind Elektrofahrr√§der (Gruppenbewertung von f√ºnf Modellen zweier Hersteller), Teil 2</a></li>
<li><a href="../de458730/index.html">Bek√§mpfung der Komplexit√§t in der Softwareentwicklung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>