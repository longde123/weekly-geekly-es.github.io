<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚨 🖐🏻 💳 JavaScript-Handbuch Teil 6: Ausnahmen, Semikolons, Vorlagenliterale 🤦🏾 👳🏿 ❗️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Themen in diesem Teil der Übersetzung des JavaScript-Lernprogramms sind Ausnahmebehandlung, automatische Semikolonfunktionen und Vorlagenliterale....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript-Handbuch Teil 6: Ausnahmen, Semikolons, Vorlagenliterale</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/430376/">  Die Themen in diesem Teil der Übersetzung des JavaScript-Lernprogramms sind Ausnahmebehandlung, automatische Semikolonfunktionen und Vorlagenliterale. <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1: Erstes Programm, Sprachfunktionen, Standards</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2: Codestil und Programmstruktur</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3: Variablen, Datentypen, Ausdrücke, Objekte</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 4: Funktionen</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 5: Arrays und Loops</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 6: Ausnahmen, Semikolons, Platzhalterliterale</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 7: Strict Mode, dieses Schlüsselwort, Ereignisse, Module, mathematische Berechnungen</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 8: Übersicht über die ES6-Funktionen</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 9: Übersicht über die ES7-, ES8- und ES9-Standards</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/jf/eo/1s/jfeo1s-pygp9g5pazca5kjwvwoa.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Ausnahmebehandlung</font> </h2><br>  Wenn während der Codeausführung ein Problem auftritt, wird es in JavaScript als Ausnahme ausgedrückt.  Wenn Sie keine Maßnahmen zur Behandlung von Ausnahmen ergreifen, wird die Programmausführung bei Auftreten gestoppt und eine Fehlermeldung in der Konsole angezeigt. <br><br>  Betrachten Sie das folgende Code-Snippet. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj = {<span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">'message text'</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> notObj <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fn = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) =&gt;</span></span> a.value <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn(obj)) <span class="hljs-comment"><span class="hljs-comment">//message text console.log('Before') //Before console.log(fn(notObj)) //,    console.log('After')</span></span></code> </pre> <br>  Hier haben wir eine Funktion, mit der wir Objekte mit der Eigenschaft <code>value</code> möchten.  Sie gibt diese Eigenschaft zurück.  Wenn Sie diese Funktion für den beabsichtigten Zweck verwenden, dh um ein Objekt zu übertragen, mit dem sie arbeiten soll, werden bei der Ausführung keine Fehler generiert.  Wenn Sie jedoch etwas Unangemessenes übergeben, in unserem Fall eine deklarierte, aber nicht initialisierte Variable, tritt ein Fehler auf, wenn Sie versuchen, auf die <code>value</code> Eigenschaft eines <code>undefined</code> Werts zuzugreifen.  In der Konsole wird eine Fehlermeldung angezeigt, die Programmausführung wird gestoppt. <br><br>  So sieht es aus, wenn Sie diesen Code in Node.js ausführen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42d/eec/eaa/42deeceaad05edd38b8581f65b4de563.png"></div><br>  <i><font color="#999999">TypeError-Ausnahme in Node.js.</font></i> <br><br>  Wenn im JS-Code einer Webseite so etwas vorkommt, wird eine ähnliche Nachricht an die Browserkonsole gesendet.  Wenn dies beispielsweise in einem realen Programm geschieht, ist dieses Verhalten im Webserver-Code äußerst unerwünscht.  Es wäre schön, einen Mechanismus zu haben, der es ermöglicht, ohne das Programm zu stoppen, den Fehler abzufangen und dann Maßnahmen zu ergreifen, um ihn zu korrigieren.  Ein solcher Mechanismus existiert in JavaScript und wird durch das Konstrukt <code>try...catch</code> . <br><br><h3>  <font color="#3AC1EF">Konstruktionsversuch ... fangen</font> </h3><br>  Mit dem Konstrukt <code>try...catch</code> können Sie Ausnahmen abfangen und behandeln.  Es enthält nämlich einen <code>try</code> Block, der Code enthält, der einen Fehler verursachen kann, und einen <code>catch</code> , in dem die Steuerung übertragen wird, wenn ein Fehler auftritt.  <code>try</code> Blöcke enthalten nicht den gesamten Programmcode.  Dort werden die Teile platziert, die Laufzeitfehler verursachen können.  Zum Beispiel Aufrufe von Funktionen, die mit bestimmten Daten arbeiten müssen, die von externen Quellen empfangen wurden.  Wenn sich die Struktur solcher Daten von den Erwartungen der Funktion unterscheidet, kann ein Fehler auftreten.  So sieht das Designdiagramm <code>try...catch</code> aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,     } catch (e) { //  }</span></span></code> </pre> <br>  Wenn der Code fehlerfrei ausgeführt wird, wird der <code>catch</code> (Exception-Handler) nicht ausgeführt.  Wenn ein Fehler auftritt, wird das Fehlerobjekt dorthin übertragen und es werden einige Maßnahmen ergriffen, um diesen Fehler zu bekämpfen. <br><br>  Wir wenden diese Konstruktion in unserem Beispiel an und schützen mit ihrer Hilfe gefährliche Abschnitte des Programms - diejenigen, in denen die Funktion <code>fn()</code> aufgerufen wird. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj = {<span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">'message text'</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> notObj <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fn = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) =&gt;</span></span> a.value <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn(obj)) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(e.message) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Before'</span></span>) <span class="hljs-comment"><span class="hljs-comment">//Before try {   console.log(fn(notObj)) } catch (e) {   console.log(e.message) //Cannot read property 'value' of undefined } console.log('After') //After</span></span></code> </pre> <br>  Schauen wir uns die Ergebnisse der Ausführung dieses Codes in Node.js an. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b8b/5f7/e5e/b8b5f7e5e4745ec45d69bd9f642cef70.png"></div><br>  <i><font color="#999999">Fehlerbehandlung in Node.js.</font></i> <br><br>  Wenn Sie dieses Beispiel mit dem vorherigen vergleichen, wird, wie Sie sehen, der gesamte Code ausgeführt, und der Code, der sich vor der Problemzeile befindet, und der Code, der sich danach befindet.  Wir "verarbeiten" den Fehler, indem wir einfach die Werte der <code>message</code> des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehlerobjekts</a> auf die Konsole drucken.  Wie mit dem Fehler umgegangen wird, der im tatsächlich verwendeten Code aufgetreten ist, hängt vom Fehler ab. <br><br>  Wir haben den <code>try...catch</code> Block oben besprochen, aber tatsächlich enthält dieses Konstrukt einen weiteren Block - <code>finally</code> . <br><br><h3>  <font color="#3AC1EF">▍ endlich blockieren</font> </h3><br>  Der <code>finally</code> Block enthält Code, der ausgeführt wird, unabhängig davon, ob im Code, der im <code>try</code> Block ausgeführt wird, ein Fehler aufgetreten ist.  So sieht es aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  } catch (e) { //  } finally { //  }</span></span></code> </pre> <br>  Der <code>finally</code> Block kann auch verwendet werden, wenn der <code>try...catch...finally</code> Block keinen <code>catch</code> .  Bei diesem Ansatz wird es auf die gleiche Weise wie bei der Konstruktion mit dem <code>catch</code> , um beispielsweise die im <code>try</code> Block belegten Ressourcen freizugeben. <br><br><h3>  <font color="#3AC1EF">▍ Verschachtelte Versuchsblöcke</font> </h3><br>  Versuchsblöcke können zusammen verschachtelt werden.  In diesem Fall wird die Ausnahme im nächsten <code>catch</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  try {   //   } finally {   // -  } } catch (e) { }</span></span></code> </pre> <br>  In diesem Fall wird eine Ausnahme, die im internen <code>try</code> Block auftritt, im externen <code>catch</code> . <br><br><h3>  <font color="#3AC1EF">▍ Selbst generierte Ausnahme</font> </h3><br>  Ausnahmen können Sie selbst mit der <code>throw</code> Anweisung <code>throw</code> .  So sieht es aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> value</code> </pre> <br>  Nachdem dieser Befehl ausgeführt wurde, wird die Steuerung an den nächsten <code>catch</code> , oder wenn ein solcher Block nicht gefunden werden kann, stoppt das Programm.  Der Ausnahmewert kann beliebig sein.  Zum Beispiel ein benutzerdefiniertes Fehlerobjekt. <br><br><h2>  <font color="#3AC1EF">Über Semikolons</font> </h2><br>  Die Verwendung von Semikolons in JavaScript ist optional.  Einige Programmierer verzichten auf sie, verlassen sich auf ein automatisches Anordnungssystem und platzieren sie nur dort, wo es unbedingt erforderlich ist.  Manche Leute ziehen es vor, sie wo immer möglich zu platzieren.  Der Autor dieses Materials bezieht sich auf die Kategorie der Programmierer, die auf Semikolons verzichten möchten.  Er sagte, er habe beschlossen, im Herbst 2017 auf sie zu verzichten, indem er Prettier so eingestellt habe, dass sie gelöscht werden, wo immer Sie ohne ihre explizite Einfügung auskommen können.  Code ohne Semikolons sieht seiner Meinung nach natürlicher und leichter zu lesen aus. <br><br>  Vielleicht können wir sagen, dass die Community der JS-Entwickler in Bezug auf Semikolons in zwei Lager unterteilt ist.  Gleichzeitig gibt es auch JavaScript-Styleguides, die explizite Semikolons vorschreiben, und Guides, die empfehlen, auf diese zu verzichten. <br><br>  All dies ist möglich, weil JavaScript über ein System für automatische Semikolons (Automatic Semicolon Insertion, ASI) verfügt.  Die Tatsache, dass Sie in JS-Code in vielen Situationen auf diese Zeichen verzichten können, und die Tatsache, dass die Semikolons automatisch platziert werden, wenn der Code für die Ausführung vorbereitet wird, bedeutet jedoch nicht, dass der Programmierer die Regeln, nach denen dies geschieht, nicht kennen muss.  Das Ignorieren dieser Regeln führt zu Fehlern. <br><br><h3>  <font color="#3AC1EF">▍ Regeln für automatische Semikolons</font> </h3><br>  Der JavaScript-Parser fügt beim Parsen von Programmtext in den folgenden Situationen automatisch Semikolons hinzu: <br><br><ol><li>  Wenn die nächste Zeile mit einem Code beginnt, der den aktuellen Code unterbricht (der Code eines bestimmten Befehls kann sich in mehreren Zeilen befinden). </li><li>  Wenn die nächste Zeile mit dem Zeichen <code>}</code> beginnt, wird der aktuelle Block geschlossen. </li><li>  Wenn das Ende der Datei mit dem Programmcode erkannt wird. </li><li>  In der Zeile mit dem <code>return</code> . </li><li>  In der Zeile mit dem Befehl <code>break</code> . </li><li>  In der Zeile mit dem <code>throw</code> . </li><li>  In der Zeile mit dem Befehl <code>continue</code> . </li></ol><br><h3>  <font color="#3AC1EF">▍ Beispiele für Code, der nicht wie erwartet funktioniert</font> </h3><br>  Hier sind einige Beispiele, die die obigen Regeln veranschaulichen.  Was wird Ihrer Meinung nach beispielsweise als Ergebnis der Ausführung des folgenden Codefragments angezeigt? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hey = <span class="hljs-string"><span class="hljs-string">'hey'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> you = <span class="hljs-string"><span class="hljs-string">'hey'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> heyYou = hey + <span class="hljs-string"><span class="hljs-string">' '</span></span> + you [<span class="hljs-string"><span class="hljs-string">'h'</span></span>, <span class="hljs-string"><span class="hljs-string">'e'</span></span>, <span class="hljs-string"><span class="hljs-string">'y'</span></span>].forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">letter</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(letter))</code> </pre> <br>  Beim Versuch, diesen Code auszuführen, wird ein nicht <code>Uncaught TypeError: Cannot read property 'forEach' of undefined</code> Fehler <code>Uncaught TypeError: Cannot read property 'forEach' of undefined</code> Systems <code>Uncaught TypeError: Cannot read property 'forEach' of undefined</code> werden, basierend auf Regel Nr. 1. Es wird versucht, den Code wie folgt zu interpretieren. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hey = <span class="hljs-string"><span class="hljs-string">'hey'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> you = <span class="hljs-string"><span class="hljs-string">'hey'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> heyYou = hey + <span class="hljs-string"><span class="hljs-string">' '</span></span> + you[<span class="hljs-string"><span class="hljs-string">'h'</span></span>, <span class="hljs-string"><span class="hljs-string">'e'</span></span>, <span class="hljs-string"><span class="hljs-string">'y'</span></span>].forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">letter</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(letter))</code> </pre> <br>  Das Problem kann gelöst werden, indem nach der vorletzten Zeile des ersten Beispiels ein Semikolon eingefügt wird. <br><br>  Hier ist ein weiterer Code. <br><br><pre> <code class="javascript hljs">(<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>).toString()</code> </pre> <br>  Das Ergebnis seiner Ausführung ist die Ausgabe der Zeichenfolge <code>"3"</code> .  Aber was passiert, wenn so etwas im nächsten Code-Snippet erscheint? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c = a + b (a + b).toString()</code> </pre> <br>  In dieser Situation wird ein <code>TypeError: b is not a function</code> Fehler <code>TypeError: b is not a function</code> da der obige Code wie folgt interpretiert wird. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c = a + b(a + b).toString()</code> </pre> <br>  Schauen wir uns nun ein Beispiel an, das auf Regel 4 basiert. <br><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {   <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">'white'</span></span> } })()</code> </pre> <br>  Sie könnten denken, dass dieses IIFE ein Objekt zurückgibt, das die <code>color</code> , aber tatsächlich ist dies nicht der Fall.  Stattdessen gibt die Funktion <code>undefined</code> da das System nach dem Befehl <code>return</code> ein Semikolon hinzufügt. <br><br>  Um ein ähnliches Problem zu lösen, muss die öffnende Klammer des Objektliteral in derselben Zeile wie der <code>return</code> . <br><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {   <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">'white'</span></span> } })()</code> </pre> <br>  Wenn Sie sich das folgende Codefragment ansehen, denken Sie möglicherweise, dass im Meldungsfeld <code>0</code> angezeigt wird. <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> === <span class="hljs-number"><span class="hljs-number">0</span></span> ? alert(<span class="hljs-number"><span class="hljs-number">0</span></span>) : alert(<span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br>  Es wird jedoch 2 ausgegeben, da dieser Code gemäß Regel Nr. 1 wie folgt dargestellt wird. <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> === <span class="hljs-number"><span class="hljs-number">0</span></span> ? alert(<span class="hljs-number"><span class="hljs-number">0</span></span>) : alert(<span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br>  Sie sollten vorsichtig sein, wenn Sie Semikolons in JavaScript verwenden.  Sie können sowohl begeisterte Anhänger von Semikolons als auch deren Gegner treffen.  Wenn Sie entscheiden, ob Semikolons in Ihrem Code benötigt werden, können Sie sich darauf verlassen, dass JS die automatische Ersetzung unterstützt. Jeder muss jedoch selbst entscheiden, ob sie in seinem Code benötigt werden oder nicht.  Die Hauptsache ist, den gewählten Ansatz konsequent und vernünftig anzuwenden.  In Bezug auf die Platzierung von Semikolons und die Struktur des Codes können wir die folgenden Regeln empfehlen: <br><br><ul><li>  Ordnen Sie mit dem Befehl return in derselben Zeile wie der Befehl an, was von der Funktion zurückgegeben werden soll.  Das gleiche gilt für die Befehle <code>break</code> , <code>throw</code> , <code>continue</code> . </li><li>  Achten Sie besonders auf Situationen, in denen eine neue Codezeile mit einer Klammer beginnt, da diese Zeile automatisch mit der vorherigen kombiniert und vom System als Versuch dargestellt werden kann, eine Funktion aufzurufen oder auf ein Array-Element zuzugreifen. </li></ul><br>  Im Allgemeinen kann gesagt werden, dass Sie den Code testen müssen, um sicherzustellen, dass er genau wie erwartet funktioniert, unabhängig davon, ob Sie selbst Semikolons einfügen oder sich auf deren automatische Platzierung verlassen. <br><br><h2>  <font color="#3AC1EF">Anführungszeichen und Platzhalterliterale</font> </h2><br>  Lassen Sie uns über die Funktionen der Verwendung von Anführungszeichen in JavaScript sprechen.  Wir sprechen nämlich über die folgenden Arten von Anführungszeichen, die in JS-Programmen zulässig sind: <br><br><ul><li>  Einfache Anführungszeichen. </li><li>  Doppelte Anführungszeichen. </li><li>  Zurück Zitate. </li></ul><br>  Einfache und doppelte Anführungszeichen können im Allgemeinen als gleich angesehen werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> test = <span class="hljs-string"><span class="hljs-string">'test'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bike = <span class="hljs-string"><span class="hljs-string">"bike"</span></span></code> </pre> <br>  Es gibt praktisch keinen Unterschied zwischen ihnen.  Möglicherweise besteht der einzige merkliche Unterschied darin, dass Sie in Zeichenfolgen in einfachen Anführungszeichen das Zeichen eines einfachen Anführungszeichens umgehen müssen und in Zeichenfolgen in doppelten Anführungszeichen das Zeichen doppelt ist. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> test = <span class="hljs-string"><span class="hljs-string">'test'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> test = <span class="hljs-string"><span class="hljs-string">'te\'st'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> test = <span class="hljs-string"><span class="hljs-string">'te"st'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> test = <span class="hljs-string"><span class="hljs-string">"te\"st"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> test = <span class="hljs-string"><span class="hljs-string">"te'st"</span></span></code> </pre> <br>  In verschiedenen Styleguides finden Sie sowohl eine Empfehlung für die Verwendung von einfachen Anführungszeichen als auch eine Empfehlung für die Verwendung von doppelten Anführungszeichen.  Der Autor dieses Materials sagt, dass er im JS-Code ausschließlich einfache Anführungszeichen verwendet und doppelte Anführungszeichen nur im HTML-Code verwendet. <br><br>  Backticks wurden mit der Veröffentlichung des ES6-Standards im Jahr 2015 in JavaScript veröffentlicht.  Sie ermöglichen unter anderem die bequeme Beschreibung von mehrzeiligen Zeichenfolgen.  Solche Zeichenfolgen können auch mit regulären Anführungszeichen angegeben werden - mithilfe der Escape-Sequenz <code>\n</code> .  Es sieht so aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> multilineString = <span class="hljs-string"><span class="hljs-string">'A string\non multiple lines'</span></span></code> </pre> <br>  Anführungszeichen (normalerweise befindet sich die Schaltfläche zur Eingabe links von der Zifferntaste 1 auf der Tastatur) verzichten auf <code>\n</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> multilineString = <span class="hljs-string"><span class="hljs-string">`A string on multiple lines`</span></span></code> </pre> <br>  Die Möglichkeiten von Backquotes sind jedoch nicht darauf beschränkt.  Wenn also eine Zeichenfolge mit Anführungszeichen beschrieben wird, können Werte aus der Berechnung von JS-Ausdrücken mithilfe der Konstruktion <code>${}</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> multilineString = <span class="hljs-string"><span class="hljs-string">`A string on </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst">+</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string"> lines`</span></span></code> </pre> <br>  Solche Zeichenfolgen werden Vorlagenliterale genannt. <br><br>  Vorlagenliterale weisen die folgenden Funktionen auf: <br><br><ul><li>  Sie unterstützen mehrzeiligen Text. </li><li>  Sie ermöglichen die Interpolation von Zeichenfolgen, in die integrierte Ausdrücke verwendet werden können. </li><li>  Mit ihnen können Sie mit getaggten Vorlagen arbeiten und so Ihre eigenen domänenspezifischen Sprachen (DSL, domänenspezifische Sprache) erstellen. </li></ul><br>  Lassen Sie uns über diese Funktionen sprechen. <br><br><h3>  <font color="#3AC1EF">▍Multilinischer Text</font> </h3><br>  Wenn Sie mehrzeilige Texte mit Anführungszeichen setzen, müssen Sie berücksichtigen, dass Leerzeichen in solchen Texten genauso wichtig sind wie andere Zeichen.  Betrachten Sie beispielsweise den folgenden mehrzeiligen Text. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> string = <span class="hljs-string"><span class="hljs-string">`First               Second`</span></span></code> </pre> <br>  Seine Schlussfolgerung wird ungefähr Folgendes ergeben. <br><br><pre> <code class="javascript hljs">First               Second</code> </pre> <br>  Das heißt, es stellt sich heraus, dass der Programmierer bei der Eingabe dieses Textes im Editor möglicherweise erwartet hat, dass die Wörter <code>First</code> und <code>Second</code> bei der Ausgabe streng untereinander erscheinen, aber tatsächlich ist dies nicht der Fall.  Um dieses Problem zu umgehen, können Sie mehrzeiligen Text mit einem Zeilenvorschub starten und unmittelbar nach dem Schließen des hinteren Anführungszeichens die Methode <code>trim()</code> aufrufen, mit der Leerzeichen am Anfang oder Ende der Zeile entfernt werden.  Zu diesen Zeichen gehören insbesondere Leerzeichen und Tabulatoren.  Die Zeilenendezeichen werden ebenfalls gelöscht. <br><br>  Es sieht so aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> string = <span class="hljs-string"><span class="hljs-string">` First Second`</span></span>.trim()</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Interpolation</font> </h3><br>  Mit Interpolation meinen wir hier die Umwandlung von Variablen und Ausdrücken in Strings.  Dies erfolgt mit dem Konstrukt <code>${}</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> variable = <span class="hljs-string"><span class="hljs-string">'test'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> string = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ variable }</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-comment"><span class="hljs-comment">//something test</span></span></code> </pre> <br>  Sie können dem <code>${}</code> -Block alles hinzufügen - sogar Ausdrücke. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> string = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">2</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">3</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> string2 = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${foo() ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'x'</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'y'</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> }</span></span></span><span class="hljs-string">`</span></span></code> </pre> <br>  Der Text <code>something 6</code> wird in die <code>string</code> , entweder der Text <code>something x</code> oder der Text <code>something y</code> wird in die Konstante <code>string2</code> .  Es hängt davon ab, ob die Funktion <code>foo()</code> true oder false zurückgibt (hier wird der ternäre Operator verwendet, der, wenn das, was vor dem Fragezeichen steht, wahr ist, das zurückgibt, was nach dem Fragezeichen kommt, andernfalls was zurückgibt kommt nach dem Doppelpunkt). <br><br><h3>  <font color="#3AC1EF">▍Tagged Templates</font> </h3><br>  Mit Tags versehene Vorlagen werden in vielen gängigen Bibliotheken verwendet.  Unter ihnen sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Styled Components</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apollo</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GraphQL</a> . <br><br>  Welche solchen Muster ausgegeben werden, unterliegt einer durch die Funktion definierten Logik.  Hier ist ein leicht überarbeitetes Beispiel in einer unserer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Veröffentlichungen, das</a> zeigt, wie mit markierten Vorlagenzeichenfolgen gearbeitet wird. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> esth = <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">helper</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">strs, ...keys</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str1 = strs[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-comment"><span class="hljs-comment">//ES const str2 = strs[1] //is let additionalPart = '' if (keys[0] == 8) { //8   additionalPart = 'awesome' } else {   additionalPart = 'good' } return `${str1}${keys[0]}${str2}${additionalPart}.` } const es = helper`ES ${esth} is ` console.log(es) //ES 8 is awesome.</span></span></code> </pre> <br>  Wenn hier die Zahl <code>8</code> in die <code>esth</code> Konstante geschrieben ist, wird die Zeile <code>ES 8 is awesome</code> sein.  Andernfalls wird es eine andere Zeile geben.  Wenn <code>esth</code> beispielsweise <code>esth</code> Nummer <code>6</code> <code>esth</code> , <code>esth</code> es so aus, als wäre <code>ES 6 is good</code> . <br><br>  Styled Components verwendet markierte Vorlagen, um CSS-Zeichenfolgen zu definieren. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Button = styled.button<span class="hljs-string"><span class="hljs-string">` font-size: 1.5em; background-color: black; color: white; `</span></span>;</code> </pre> <br>  Bei Apollo werden sie zum Definieren von GraphQL-Abfragen verwendet. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> query = gql<span class="hljs-string"><span class="hljs-string">` query {   ... } `</span></span></code> </pre> <br>  Wenn Sie wissen, wie getaggte Vorlagen funktionieren, ist es leicht zu verstehen, dass <code>styled.button</code> und <code>gql</code> aus den vorherigen Beispielen nur Funktionen sind. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gql</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">literals, ...expressions</span></span></span><span class="hljs-function">) </span></span>{ }</code> </pre> <br>  Beispielsweise gibt die Funktion <code>gql()</code> eine Zeichenfolge zurück, die das Ergebnis einer Berechnung sein kann.  Der <code>literals</code> Parameter dieser Funktion ist ein Array, das den Inhalt eines Vorlagenliterals enthält, das in Teile unterteilt ist. <code>expresions</code> enthalten die Ergebnisse der Auswertung von Ausdrücken. <br><br>  Lassen Sie uns die nächste Zeile analysieren. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> string = helper<span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">2</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">3</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string"> `</span></span></code> </pre> <br>  Die <code>helper</code> ruft das <code>literals</code> Array ab, das zwei Elemente enthält.  Im ersten wird ein Text mit einem Leerzeichen dahinter stehen, im zweiten wird eine leere Zeile angezeigt, dh zwischen dem Ausdruck <code>${1 + 2 + 3}</code> und dem Ende der Zeile.  Es wird ein Element im <code>espressions</code> Array geben - <code>6</code> . <br>  Hier ist ein komplexeres Beispiel. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> string = helper<span class="hljs-string"><span class="hljs-string">`something another </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'x'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string"> new line </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">2</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">3</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string"> test`</span></span></code> </pre> <br>  Hier wird in der <code>helper</code> das nächste Array als erster Parameter abgerufen. <br><br><pre> <code class="javascript hljs">[ <span class="hljs-string"><span class="hljs-string">'something\nanother '</span></span>, <span class="hljs-string"><span class="hljs-string">'\nnew line '</span></span>, <span class="hljs-string"><span class="hljs-string">'\ntest'</span></span> ]</code> </pre> <br>  Das zweite Array sieht folgendermaßen aus. <br><br><pre> <code class="javascript hljs">[ <span class="hljs-string"><span class="hljs-string">'x'</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span> ]</code> </pre> <br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Heute haben wir über die Ausnahmebehandlung, über die automatische Substitution von Semikolons und über Vorlagenliterale in JavaScript gesprochen.  Das nächste Mal werden wir uns einige wichtigere Konzepte der Sprache ansehen.  Insbesondere - Arbeiten im strengen Modus, Timer, mathematische Berechnungen. <br><br>  <b>Liebe Leser!</b>  Verwenden Sie die Funktionen von getaggten Vorlagen in JavaScript? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430376/">https://habr.com/ru/post/de430376/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430362/index.html">Wir stellen vor: Amazon Corretto, ein kostenloses OpenJDK mit langfristiger Unterstützung</a></li>
<li><a href="../de430364/index.html">„Es scheint mir, dass wir uns der Zeit nähern, in der jeder in der Lage sein wird, zu codieren. Code ist Freiheit. “</a></li>
<li><a href="../de430366/index.html">VR-Küche: Was im Helm nicht sichtbar ist</a></li>
<li><a href="../de430372/index.html">Wasserstoffauto. Ist es Zeit, sich vom Benzin zu verabschieden?</a></li>
<li><a href="../de430374/index.html">Data Engineering und mehr: Wrike-Videobänder und -Dias aus dem Meeting</a></li>
<li><a href="../de430378/index.html">J2CL - Besser spät als nie</a></li>
<li><a href="../de430380/index.html">JavaScript-Handbuch Teil 5: Arrays und Loops</a></li>
<li><a href="../de430382/index.html">JavaScript-Handbuch Teil 4: Funktionen</a></li>
<li><a href="../de430384/index.html">Erstellen von Karten aus Rauschfunktionen</a></li>
<li><a href="../de430386/index.html">Festkörperspeicherkraftwerk in Indien gebaut werden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>