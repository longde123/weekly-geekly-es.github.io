<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🎓 ⛷️ ♐️ Wir erstellen die vierte Etage von C ++ - Vorlagen in RESTinio. Warum und wie? 🏳️‍🌈 🏅 👨🏿‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="RESTinio ist ein relativ kleines Projekt, bei dem es sich um einen asynchronen HTTP-Server handelt, der in C ++ - Anwendungen integriert ist. Sein cha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir erstellen die vierte Etage von C ++ - Vorlagen in RESTinio. Warum und wie?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456632/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RESTinio</a> ist ein relativ kleines Projekt, bei dem es sich um einen asynchronen HTTP-Server handelt, der in C ++ - Anwendungen integriert ist.  Sein charakteristisches Merkmal ist die weit verbreitete, man könnte sagen, weit verbreitete Verwendung von C ++ - Vorlagen.  Sowohl in der Implementierung als auch in der öffentlichen API. </p><br><p>  C ++ - Vorlagen in RESTinio werden so aktiv verwendet, dass der erste Artikel, der sich mit RESTinio auf Habr befasste, "Dreistöckige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ - Vorlagen bei der Implementierung eines eingebetteten asynchronen HTTP-Servers mit menschlichem Gesicht</a> " hieß. </p><br><p>  Dreistöckige Vorlagen.  Und dies war im Allgemeinen keine Redewendung. </p><br><p>  Und kürzlich haben wir RESTinio erneut aktualisiert. Um Version 0.5.1 um neue Funktionen zu erweitern, mussten wir die "Anzahl der Stockwerke" der Vorlagen noch erhöhen.  Stellenweise sind C ++ - Vorlagen in RESTinio also bereits vierstöckig. </p><br><p><img src="https://habrastorage.org/webt/vz/t3/vw/vzt3vwbp8snyu3y7hhrcr6crela.jpeg"></p><br><p>  Und wenn sich jemand fragt, warum wir das gebraucht haben und wie wir die Vorlagen verwendet haben, dann bleiben Sie bei uns, es werden ein paar Details unter dem Schnitt sein.  Es ist unwahrscheinlich, dass eingefleischte C ++ - Gurus etwas Neues für sich finden, aber weniger fortgeschrittene C ++ - Spitznamen können sehen, wie Vorlagen zum Einfügen / Entfernen von Funktionen verwendet werden.  Fast in freier Wildbahn. </p><a name="habracut"></a><br><h1 id="slushatel-sostoyaniya-podklyucheniy">  Verbindungsstatus-Listener </h1><br><p>  Die Hauptfunktion, für die Version 0.5.1 erstellt wurde, ist die Möglichkeit, den Benutzer darüber zu informieren, dass sich der Status der Verbindung zum HTTP-Server geändert hat.  Beispielsweise ist der Client "abgefallen", und dies machte es unnötig, Anforderungen von diesem Client zu verarbeiten, die noch in der Schlange stehen. </p><br><p>  Wir wurden manchmal nach dieser Funktion gefragt und jetzt haben unsere Hände ihre Implementierung erreicht.  Aber seitdem  Nicht jeder fragte nach dieser Funktion, es wurde angenommen, dass sie optional sein sollte: Wenn ein Benutzer sie benötigt, lassen Sie sie explizit einschließen, und der Rest sollte nichts für ihre Existenz in RESTinio bezahlen. </p><br><p>  Und da die Hauptmerkmale des HTTP-Servers in RESTinio über "Merkmale" festgelegt werden, wurde beschlossen, das Abhören des Verbindungsstatus über die Servereigenschaften zu aktivieren / deaktivieren. </p><br><h2 id="kak-polzovatel-zadaet-sobstvennogo-slushatelya-sostoyaniya-podklyucheniy">  Wie legt ein Benutzer seinen eigenen Listener für den Verbindungsstatus fest? </h2><br><p>  Um Ihren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Listener auf den Status von Verbindungen</a> einzustellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> muss <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der</a> Benutzer drei Schritte ausführen. </p><br><p>  Schritt 1: Definieren Sie Ihre eigene Klasse, die eine nicht statische state_changed-Methode der folgenden Form haben sollte: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">state_changed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> restinio::connection_state::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">notice_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; notice)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>;</code> </pre> <br><p>  Zum Beispiel könnte es so etwas sein wie: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_state_listener</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex lock_; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">state_changed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> restinio::connection_state::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">notice_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; notice)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; l{lock_}; .... } ... };</code> </pre> <br><p>  Schritt 2: In den Eigenschaften des Servers müssen Sie ein typedef mit dem Namen <code>connection_state_listener_t</code> , das sich auf den Namen des in Schritt 1 erstellten Typs beziehen soll: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_traits</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> = my_state_listener; };</code> </pre> <br><p>  Dementsprechend sollten diese Eigenschaften beim Starten des HTTP-Servers verwendet werden: </p><br><pre> <code class="cpp hljs">restinio::run(restinio::on_thread_pool&lt;my_traits&gt;(<span class="hljs-number"><span class="hljs-number">8</span></span>)...);</code> </pre> <br><p>  Schritt 3: Der Benutzer muss eine Instanz seines Listeners erstellen und diesen Zeiger über shared_ptr in den Serverparametern übergeben: </p><br><pre> <code class="cpp hljs">restinio::run( restinio::on_thread_pool&lt;my_traits&gt;(<span class="hljs-number"><span class="hljs-number">8</span></span>) .port(<span class="hljs-number"><span class="hljs-number">8080</span></span>) .address(<span class="hljs-string"><span class="hljs-string">"localhost"</span></span>) .request_handler(...) .connection_state_listener(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;my_state_listener&gt;(...)) ) );</code> </pre> <br><p>  Wenn der Benutzer die Methode <code>connection_state_listener</code> aufruft, wird beim Starten des HTTP-Servers eine Ausnahme ausgelöst: Der Norden kann nicht funktionieren, wenn der Benutzer den Statuslistener verwenden möchte, diesen Listener jedoch nicht angibt. </p><br><h3 id="a-esli-ne-zadavat-connection_state_listener_t">  Und wenn Sie connection_state_listener_t nicht setzen? </h3><br><p>  Wenn der Benutzer den Namen <code>connection_state_listener_t</code> in den Servereigenschaften festlegt, muss er die Methode <code>connection_state_listener</code> aufrufen, um die Serverparameter festzulegen.  Aber wenn der Benutzer <code>connection_state_listener_t</code> nicht angibt? </p><br><p>  In diesem Fall ist der Name <code>connection_state_listener_t</code> weiterhin in den <code>restinio::connection_state::noop_listener_t</code> vorhanden, dieser Name <code>restinio::connection_state::noop_listener_t</code> auf den speziellen Typ <code>restinio::connection_state::noop_listener_t</code> . </p><br><p>  Tatsächlich passiert Folgendes: In RESTinio wird beim Definieren regulärer Merkmale der Wert <code>connection_state_listener_t</code> festgelegt.  So etwas wie: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> restinio { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">default_traits_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">time_manager_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">asio_time_manager_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">logger_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">null_logger_t</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> = connection_state::<span class="hljs-keyword"><span class="hljs-keyword">noop_listener_t</span></span>; }; } <span class="hljs-comment"><span class="hljs-comment">/* namespace restinio */</span></span></code> </pre> <br><p>  Und wenn der Benutzer von <code>restinio::default_traits_t</code> erbt, wird auch die Standarddefinition von <code>connection_state_listener_t</code> geerbt.  Wenn jedoch der neue Name <code>connection_state_listener_t</code> in der Nachfolgeklasse definiert <code>connection_state_listener_t</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_traits</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> = my_state_listener; ... };</code> </pre> <br><p>  dann verbirgt der neue Name die geerbte Definition für <code>connection_state_listener_t</code> .  Und wenn es keine neue Definition gibt, bleibt die alte Definition sichtbar. </p><br><p>  Wenn der Benutzer keinen eigenen Wert für <code>connection_state_listener_t</code> , verwendet RESTinio den Standardwert <code>noop_listener_t</code> , der von RESTinio auf besondere Weise verarbeitet wird.  Zum Beispiel: </p><br><ul><li>  RESTinio speichert in diesem Fall shared_ptr überhaupt nicht für <code>connection_state_listener_t</code> .  Dementsprechend ist ein Aufruf der Methode <code>connection_state_listener</code> verboten (ein solcher Aufruf führt zu einem Fehler bei der Kompilierung). </li><li>  RESTinio führt keine zusätzlichen Anrufe im Zusammenhang mit der Änderung des Verbindungsstatus durch. </li></ul><br><p>  Und wie all dies erreicht wird und weiter unten diskutiert wird. </p><br><h2 id="kak-eto-realizovano-v-restinio">  Wie ist dies in RESTinio implementiert? </h2><br><p>  Im RESTinio-Code müssen Sie also überprüfen, welchen Wert die Definition von <code>connection_state_listener_t</code> in den Servereigenschaften hat, und abhängig von diesem Wert: </p><br><ul><li>  Speichern oder Nicht-Speichern der shared_ptr-Instanz für ein Objekt vom Typ <code>connecton_state_listener_t</code> ; </li><li>  Zulassen oder Verbieten von Aufrufen von <code>connection_state_listener</code> Methoden zum Festlegen von HTTP-Serverparametern; </li><li>  Überprüfen Sie, ob ein aktueller Zeiger auf ein Objekt vom Typ <code>connection_state_listener_t</code> bevor Sie den Betrieb des HTTP-Servers starten. </li><li>  Rufen Sie die Methode <code>state_changed</code> oder nicht, wenn sich der Status der Verbindung zum Client ändert. </li></ul><br><p>  Es wird auch zu den Randbedingungen hinzugefügt, die RESTinio noch als Bibliothek für C ++ 14 entwickelt. Daher können Sie die Funktionen von C ++ 17 in der Implementierung nicht verwenden (dasselbe gilt, wenn constexpr). </p><br><p>  All dies wird durch einfache Tricks implementiert: Vorlagenklassen und ihre Spezialisierungen für den Typ <code>restinio::connection_state::noop_listener_t</code> .  Im Folgenden wird beispielsweise beschrieben, wie der Speicher von shared_ptr für ein Objekt vom Typ <code>connection_state_listener_t</code> in Serverparametern ausgeführt wird.  Erster Teil: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Listener &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">connection_state_listener_holder_t</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-comment"><span class="hljs-comment">//  compile-time . std::shared_ptr&lt; Listener &gt; m_connection_state_listener; static constexpr bool has_actual_connection_state_listener = true; void check_valid_connection_state_listener_pointer() const { if( !m_connection_state_listener ) throw exception_t{ "connection state listener is not specified" }; } }; template&lt;&gt; struct connection_state_listener_holder_t&lt; connection_state::noop_listener_t &gt; { static constexpr bool has_actual_connection_state_listener = false; void check_valid_connection_state_listener_pointer() const { // Nothing to do. } };</span></span></code> </pre> <br><p>  Hier wird eine Vorlagenstruktur definiert, die entweder einen nützlichen Inhalt hat oder nicht.  Nur für den Typ <code>noop_listener_t</code> hat es keinen nützlichen Inhalt. </p><br><p>  Und Teil zwei: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Derived, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">basic_server_settings_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">socket_type_dependent_settings_t</span></span>&lt; Derived, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">stream_socket_t</span></span> &gt; , <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_holder_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> &gt; , <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ip_blocker_holder_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">ip_blocker_t</span></span> &gt; { ... };</code> </pre> <br><p>  Die Klasse, die die Parameter für den HTTP-Server enthält, wird von <code>connection_state_listener_holder_t</code> geerbt.  Daher zeigen die Serverparameter entweder shared_ptr für ein Objekt vom Typ <code>connection_state_listener_t</code> an oder nicht. </p><br><p>  Ich muss sagen, dass das Speichern oder Nicht-Speichern von shared_ptr in den Parametern Blumen sind.  Die Beeren gingen jedoch verloren, als versucht wurde, die Methoden für die Arbeit mit dem <code>basic_server_settings_t</code> in <code>basic_server_settings_t</code> nur verfügbar zu machen, wenn <code>connection_state_listener_t</code> sich von <code>noop_listener_t</code> . </p><br><p>  Idealerweise wollte ich den Compiler dazu bringen, sie überhaupt nicht zu sehen.  Aber ich wurde gefoltert, um Bedingungen für <code>std::enable_if</code> zu schreiben, um diese Methoden zu verbergen.  Daher war es einfach auf das Hinzufügen von static_asser beschränkt: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Derived &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connection_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Traits::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">connection_state_listener_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &gt; listener )</span></span></span><span class="hljs-function"> &amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( has_actual_connection_state_listener, <span class="hljs-string"><span class="hljs-string">"connection_state_listener(listener) can't be used "</span></span> <span class="hljs-string"><span class="hljs-string">"for the default connection_state::noop_listener_t"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;m_connection_state_listener = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(listener); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reference_to_derived(); } <span class="hljs-function"><span class="hljs-function">Derived &amp;&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connection_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Traits::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">connection_state_listener_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &gt; listener )</span></span></span><span class="hljs-function"> &amp;&amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;connection_state_listener(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(listener))); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> &gt; &amp; connection_state_listener() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( has_actual_connection_state_listener, <span class="hljs-string"><span class="hljs-string">"connection_state_listener() can't be used "</span></span> <span class="hljs-string"><span class="hljs-string">"for the default connection_state::noop_listener_t"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;m_connection_state_listener; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ensure_valid_connection_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;check_valid_connection_state_listener_pointer(); }</code> </pre> <br><p>  Es gab nur einen weiteren Moment, in dem ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das in C ++ bereute, wenn constexpr nicht dasselbe ist wie statisch, wenn in D.</a>  Und im Allgemeinen gibt es in C ++ 14 nichts Ähnliches :( </p><br><p>  Hier können Sie auch die Verfügbarkeit der Methode <code>ensure_valid_connection_state_listener</code> .  Diese Methode wird im Konstruktor <code>http_server_t</code> , um zu überprüfen, ob die <code>http_server_t</code> alle erforderlichen Werte enthalten: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> D&gt; <span class="hljs-keyword"><span class="hljs-keyword">http_server_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">io_context_holder_t</span></span> io_context, <span class="hljs-keyword"><span class="hljs-keyword">basic_server_settings_t</span></span>&lt; D, Traits &gt; &amp;&amp; settings ) : m_io_context{ io_context.giveaway_context() } , m_cleanup_functor{ settings.giveaway_cleanup_func() } { <span class="hljs-comment"><span class="hljs-comment">// Since v.0.5.1 the presence of custom connection state // listener should be checked before the start of HTTP server. settings.ensure_valid_connection_state_listener(); ...</span></span></code> </pre> <br><p>  Gleichzeitig wird innerhalb des <code>ensure_valid_connection_state_listener</code> geerbte Methode <code>ensure_valid_connection_state_listener</code> <code>check_valid_connection_state_listener_pointer</code> , die aufgrund der Spezialisierung <code>connection_state_listener_holder_t</code> entweder eine tatsächliche Prüfung durchführt oder nichts unternimmt. </p><br><p>  Ähnliche Tricks wurden verwendet, um entweder den aktuellen <code>state_changed</code> wenn der Benutzer den <code>state_changed</code> wollte, oder nichts anderes aufzurufen. </p><br><p>  Zuerst benötigen wir eine weitere Option <code>state_listener_holder_t</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> connection_settings_details { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Listener &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">state_listener_holder_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; Listener &gt; m_connection_state_listener; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Settings &gt; <span class="hljs-keyword"><span class="hljs-keyword">state_listener_holder_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Settings &amp; settings ) : m_connection_state_listener{ settings.connection_state_listener() } {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Lambda &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Lambda &amp;&amp; lambda )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ m_connection_state_listener-&gt;state_changed( lambda() ); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">state_listener_holder_t</span></span></span><span class="hljs-class">&lt; connection_state::noop_listener_t &gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Settings &gt; <span class="hljs-keyword"><span class="hljs-keyword">state_listener_holder_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Settings &amp; ) { <span class="hljs-comment"><span class="hljs-comment">/* nothing to do */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Lambda &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Lambda &amp;&amp; </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*lambda*/</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* nothing to do */</span></span> } }; } <span class="hljs-comment"><span class="hljs-comment">/* namespace connection_settings_details */</span></span></code> </pre> <br><p>  Im Gegensatz zu <code>connection_state_listener_holder_t</code> , das zuvor gezeigt wurde und zum Speichern des Verbindungsstatus-Listeners in den Parametern des gesamten Servers (d. H. In Objekten vom Typ <code>basic_server_settings_t</code> ) verwendet wurde, wird dieser <code>state_listener_holder_t</code> für ähnliche Zwecke verwendet, jedoch nicht in den Parametern des gesamten Servers, sondern eines separaten Verbindung: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">connection_settings_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::enable_shared_from_this&lt; <span class="hljs-keyword"><span class="hljs-keyword">connection_settings_t</span></span>&lt; Traits &gt; &gt; , <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> connection_settings_details::<span class="hljs-keyword"><span class="hljs-keyword">state_listener_holder_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> &gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_holder_t</span></span> = connection_settings_details::<span class="hljs-keyword"><span class="hljs-keyword">state_listener_holder_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> &gt;; ...</code> </pre> <br><p>  Hier gibt es zwei Funktionen. </p><br><p>  Initialisieren Sie zunächst <code>state_listener_holder_t</code> .  Es wird entweder benötigt oder nicht.  Aber nur <code>state_listener_holder_t</code> weiß davon.  Daher "zieht" der Konstruktor " <code>state_listener_holder_t</code> " einfach den Konstruktor " <code>state_listener_holder_t</code> , wie sie sagen, nur für den Fall: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Settings &gt; <span class="hljs-keyword"><span class="hljs-keyword">connection_settings_t</span></span>( Settings &amp;&amp; settings, http_parser_settings parser_settings, <span class="hljs-keyword"><span class="hljs-keyword">timer_manager_handle_t</span></span> timer_manager ) : <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_holder_t</span></span>{ settings } , m_request_handler{ settings.request_handler() }</code> </pre> <br><p>  Und der Konstruktor <code>state_listener_holder_t</code> führt entweder die erforderlichen Aktionen aus oder führt überhaupt nichts aus (im letzteren Fall generiert der mehr oder weniger sinnvolle Compiler keinen Code, um <code>state_listener_holder_t</code> zu initialisieren). </p><br><p>  Zweitens ist es die <code>state_listner_holder_t::call_state_listener</code> , die den <code>state_changed</code> Aufruf an den state Listener <code>state_changed</code> .  Oder nicht, wenn es keinen Statuslistener gibt.  Dieser <code>call_state_listener</code> an Stellen <code>call_state_listener</code> an denen RESTinio eine Änderung des Verbindungsstatus diagnostiziert.  Wenn beispielsweise festgestellt wird, dass die Verbindung geschlossen wurde: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_logger.trace( [&amp;]{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt::format( <span class="hljs-string"><span class="hljs-string">"[connection:{}] close"</span></span>, connection_id() ); } ); ... <span class="hljs-comment"><span class="hljs-comment">// Inform state listener if it used. m_settings-&gt;call_state_listener( [this]() noexcept { return connection_state::notice_t{ this-&gt;connection_id(), this-&gt;m_remote_endpoint, connection_state::cause_t::closed }; } ); }</span></span></code> </pre> <br><p>  Ein <code>call_state_listener</code> wird an <code>call_state_listener</code> , von dem ein <code>notice_t</code> Objekt mit Verbindungsstatusinformationen zurückgegeben wird.  Wenn es einen tatsächlichen Listener gibt, wird dieses Lambda tatsächlich aufgerufen und der von ihm zurückgegebene Wert wird an <code>state_changed</code> . </p><br><p>  Wenn jedoch kein Listener vorhanden ist, ist <code>call_state_listener</code> leer und dementsprechend wird kein Lambda aufgerufen.  Tatsächlich wirft der normale Compiler einfach alle Aufrufe an einen leeren <code>call_state_listener</code> .  In diesem Fall gibt es im generierten Code überhaupt nichts, was mit dem Verbindungsstatus zusammenhängt, auf den der Listener zugreift. </p><br><h1 id="esche-i-ip-blocker">  Auch IP-Blocker </h1><br><p>  In RESTinio-0.5.1 wurde zusätzlich zum Verbindungsstatus-Listener ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IP-Blocker</a> hinzugefügt.  Das heißt,  Der Benutzer kann ein Objekt angeben, das RESTinio für jede neue eingehende Verbindung "zieht".  Wenn der IP-Blocker angibt, dass Sie mit der Verbindung arbeiten können, startet RESTinio die übliche Wartung der neuen Verbindung (es liest und analysiert die Anforderung, ruft den Anforderungshandler auf, steuert Zeitüberschreitungen usw.).  Aber wenn der IP-Blocker das Arbeiten mit der Verbindung verbietet, schließt RESTinio diese Verbindung dumm und macht nichts mehr damit. </p><br><p>  Wie der Status-Listener ist der IP-Blocker eine optionale Funktion.  Um den IP-Blocker verwenden zu können, müssen Sie ihn explizit aktivieren.  Über die Eigenschaften des HTTP-Servers.  Genau wie beim Verbindungsstatus-Listener.  Die Implementierung der IP-Blocker-Unterstützung in RESTinio verwendet dieselben Techniken, die oben bereits beschrieben wurden.  Daher werden wir uns nicht mit der Verwendung des IP-Blockers in RESTinio befassen.  Stellen Sie sich stattdessen ein Beispiel vor, in dem sowohl der IP-Blocker als auch der Status-Listener dasselbe Objekt sind. </p><br><h2 id="razbor-shtatnogo-primera-ip_blocker">  Analyse des Standardbeispiels ip_blocker </h2><br><p>  In Version 0.5.1 ist ein weiteres Beispiel in den Standard-RESTinio-Beispielen enthalten: <a href="">ip_blocker</a> .  Dieses Beispiel zeigt, wie Sie die Anzahl gleichzeitiger Verbindungen zum Server von einer einzelnen IP-Adresse aus begrenzen können. </p><br><p>  Dies erfordert nicht nur einen IP-Blocker, der das Akzeptieren von Verbindungen zulässt oder verbietet.  Aber auch ein Listener für den Verbindungsstatus.  Ein Listener wird benötigt, um die Momente des Erstellens und Schließens von Verbindungen zu verfolgen. </p><br><p>  Gleichzeitig benötigen sowohl der IP-Blocker als auch der Listener denselben Datensatz.  Daher besteht die einfachste Lösung darin, den IP-Blocker und den Listener zum selben Objekt zu machen. </p><br><p>  Kein Problem, wir können dies leicht tun: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blocker_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex m_lock; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connections_t</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt; restinio::asio_ns::ip::address, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; restinio::<span class="hljs-keyword"><span class="hljs-keyword">connection_id_t</span></span> &gt; &gt;; <span class="hljs-keyword"><span class="hljs-keyword">connections_t</span></span> m_connections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//   IP-blocker-. restinio::ip_blocker::inspection_result_t inspect( const restinio::ip_blocker::incoming_info_t &amp; info ) noexcept {...} //     . void state_changed( const restinio::connection_state::notice_t &amp; notice ) noexcept {...} };</span></span></code> </pre> <br><p>  Hier haben wir keine Vererbung von Schnittstellen oder Überschreibungen von geerbten virtuellen Methoden.  Die einzige Voraussetzung für den Listener ist das Vorhandensein der Methode <code>state_changed</code> .  Diese Anforderung ist erfüllt. </p><br><p>  Ebenso mit der einzigen Anforderung für einen IP-Blocker: Gibt es eine <code>inspect</code> mit der erforderlichen Signatur?  Da ist!  Also ist alles in Ordnung. </p><br><p>  Dann müssen noch die richtigen Eigenschaften für den HTTP-Server ermittelt werden: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_traits_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">logger_t</span></span> = restinio::<span class="hljs-keyword"><span class="hljs-keyword">shared_ostream_logger_t</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      . using connection_state_listener_t = blocker_t; using ip_blocker_t = blocker_t; };</span></span></code> </pre> <br><p>  Danach muss nur noch eine Instanz von <code>blocker_t</code> und in den Parametern an den HTTP-Server übergeben werden: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> blocker = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;<span class="hljs-keyword"><span class="hljs-keyword">blocker_t</span></span>&gt;(); restinio::run( ioctx, restinio::on_thread_pool&lt;<span class="hljs-keyword"><span class="hljs-keyword">my_traits_t</span></span>&gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::hardware_concurrency() ) .port( <span class="hljs-number"><span class="hljs-number">8080</span></span> ) .address( <span class="hljs-string"><span class="hljs-string">"localhost"</span></span> ) .connection_state_listener( blocker ) .ip_blocker( blocker ) .max_pipelined_requests( <span class="hljs-number"><span class="hljs-number">4</span></span> ) .handle_request_timeout( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::seconds{<span class="hljs-number"><span class="hljs-number">20</span></span>} ) .request_handler( [&amp;ioctx](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> handler( ioctx, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req) ); } ) );</code> </pre> <br><h1 id="zaklyuchenie">  Fazit </h1><br><h2 id="o-cnyh-shablonah">  Informationen zu C ++ - Vorlagen </h2><br><p>  Meiner Meinung nach sind C ++ - Vorlagen sogenannte Big Guns.  Das heißt,  Eine so leistungsstarke Funktion, dass Sie unwillkürlich darüber nachdenken müssen, wie und wie ihre Verwendung gerechtfertigt ist.  Daher ist die moderne C ++ - Community wie in mehrere kriegführende Lager unterteilt. </p><br><p>  Vertreter eines von ihnen halten sich lieber von Vorlagen fern.  Da die Vorlagen komplex sind, erzeugen sie unlesbare Längen unlesbarer Fehlermeldungen, wodurch die Kompilierungszeit erheblich verlängert wird.  Ganz zu schweigen von urbanen Legenden über das Aufblähen von Code und das Reduzieren der Leistung. </p><br><p>  Vertreter eines anderen Lagers (wie ich) glauben, dass Vorlagen einer der mächtigsten Aspekte von C ++ sind.  Es ist sogar möglich, dass Vorlagen einer der wenigen schwerwiegendsten Wettbewerbsvorteile von C ++ in der modernen Welt sind.  Daher sind meiner Meinung nach die Zukunft von C ++ genau die Vorlagen.  Einige der aktuellen Unannehmlichkeiten, die mit der weit verbreiteten Verwendung von Vorlagen verbunden sind (z. B. langwierige und ressourcenintensive Kompilierung oder nicht informative Fehlermeldungen), werden im Laufe der Zeit auf die eine oder andere Weise beseitigt. </p><br><p>  Daher scheint es mir persönlich, dass sich der bei der Implementierung von RESTinio gewählte Ansatz, nämlich die weit verbreitete Verwendung von Vorlagen und die Angabe der Eigenschaften eines HTTP-Servers durch Eigenschaften, immer noch auszahlt.  Dank dessen erhalten wir eine gute Anpassung an spezifische Bedürfnisse.  Gleichzeitig zahlen wir im wahrsten Sinne des Wortes nicht für das, was wir nicht verwenden. </p><br><p>  Andererseits scheint die Programmierung in C ++ - Vorlagen immer noch unangemessen kompliziert zu sein.  Sie spüren es besonders, wenn Sie nicht ständig programmieren müssen, sondern zwischen verschiedenen Aktivitäten wechseln.  Sie werden für ein paar Wochen vom Codieren abgelenkt, dann kehren Sie zurück und beginnen offen und spezifisch dumm zu sein, wenn nötig, eine Methode mit SFINAE auszublenden oder zu prüfen, ob eine Methode mit einer bestimmten Signatur auf dem Objekt vorhanden ist. </p><br><p>  Es ist also gut, dass es in C ++ Vorlagen gibt.  Es wäre sogar noch besser, wenn sie in einen Zustand versetzt würden, in dem selbst Starter wie ich problemlos C ++ - Vorlagen verwenden könnten, ohne alle 10 bis 15 Minuten die Referenz und den Stapelüberlauf untersuchen zu müssen. </p><br><h2 id="o-tekuschem-sostoyanii-restinio-i-buduschey-funkcionalnosti-restinio-i-ne-tolko-restinio">  Informationen zum aktuellen Status von RESTinio und zur zukünftigen Funktionalität von RESTinio.  Und nicht nur RESTinio </h2><br><p>  Im Moment entwickelt sich RESTinio nach dem Prinzip "Wenn es Zeit gibt und es einen Wunsch gibt".  Zum Beispiel hatten wir im Herbst 2018 und im Winter 2019 nicht viel Zeit für die Entwicklung von RESTinio.  Sie beantworteten die Fragen der Benutzer, nahmen geringfügige Änderungen vor, aber für etwas mehr reichten unsere Ressourcen nicht aus. </p><br><p>  Im späten Frühjahr 2019 war jedoch Zeit für RESTinio, und wir haben zuerst RESTinio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">0.5.0</a> und dann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">0.5.1 erstellt</a> .  Gleichzeitig war der Vorrat an Wunschliste für uns und andere erschöpft.  Das heißt,  Was wir selbst in RESTinio sehen wollten und was uns Benutzer erzählt haben, ist bereits in RESTinio. </p><br><p>  Natürlich kann RESTinio mit viel mehr gefüllt werden.  Aber was genau? </p><br><p>  Und hier ist die Antwort sehr einfach: Nur das, was wir von RESTinio erwarten.  Wenn Sie also etwas sehen möchten, das Sie in RESTinio benötigen, nehmen Sie sich Zeit, um uns davon zu erzählen (z. B. durch Probleme mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BitBucket</a> , entweder über die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google-Gruppe</a> oder direkt in den Kommentaren hier auf Habré). .  Du wirst nichts sagen - du wirst nichts erhalten;) </p><br><p>  Tatsächlich ist die gleiche Situation bei unseren anderen Projekten, insbesondere bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SObjectizer</a> .  Ihre neuen Versionen werden nach Erhalt der verständlichen Wunschliste veröffentlicht. </p><br><p>  Nun, und zum Schluss möchte ich allen anbieten, die RESTinio noch nicht ausprobiert haben: Probieren Sie es aus <del>  kostenlos </del>  nicht verletzt.  Plötzlich mag es.  Und wenn es Ihnen nicht gefällt, teilen Sie was genau mit.  Dies wird uns helfen, RESTinio noch komfortabler und funktionaler zu gestalten. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456632/">https://habr.com/ru/post/de456632/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456616/index.html">3 Millionen Rubel für diejenigen, die codieren können</a></li>
<li><a href="../de456618/index.html">Larabeer Moskau - 21. Juni</a></li>
<li><a href="../de456622/index.html">So erstellen Sie ein Betriebssystem, das gemäß dem Schutz der Klasse I zertifiziert ist</a></li>
<li><a href="../de456624/index.html">Nützliche Python-Tools</a></li>
<li><a href="../de456630/index.html">Einführung von Airflow zur Verwaltung von Spark-Jobs in ivi: Hoffnungen und Krücken</a></li>
<li><a href="../de456634/index.html">Nginx-Rezepte: CAS (Central Authorization Service)</a></li>
<li><a href="../de456638/index.html">Vergleichen des gleichen Projekts in Rust, Haskell, C ++, Python, Scala und OCaml</a></li>
<li><a href="../de456640/index.html">Analyse des Competitive Intelligence Contest an PHDays 9</a></li>
<li><a href="../de456642/index.html">Der erste Abschluss des JetBrains Corporate Master-Programms und der ITMO University</a></li>
<li><a href="../de456644/index.html">Auf Kickstarter wird ein längerer kostengünstiger 3D-Fotopolymerdrucker angezeigt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>