<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆖 👨🏼‍🔬 🏜️ Toda a verdade sobre o RTOS. Artigo # 33 Usando o sistema operacional Nucleus SE em tempo real 👩🏿‍🎓 👶🏿 🛷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Até agora, nesta série de artigos, examinamos quais recursos o Nucleus SE oferece. Agora é hora de ver como ele pode ser usado em um aplicativo de fir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toda a verdade sobre o RTOS. Artigo # 33 Usando o sistema operacional Nucleus SE em tempo real</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467763/">  Até agora, nesta série de artigos, examinamos quais recursos o Nucleus SE oferece.  Agora é hora de ver como ele pode ser usado em um aplicativo de firmware real. <br><br><img src="https://habrastorage.org/webt/8y/ch/3t/8ych3tyabi2vdvohugo65t3uekk.png"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Artigos anteriores da série:</b> <div class="spoiler_text"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 32.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Migração do Nucleus SE: recursos e compatibilidade não realizados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 31.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Diagnósticos e verificação de erros RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 30.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Procedimentos de inicialização e inicialização do Núcleo SE</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 29.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Interrupções no Núcleo SE</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 28.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Temporizadores de software</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo # 27</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hora do sistema</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 26.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Canais: serviços auxiliares e estruturas de dados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 25.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Canais de Dados: Introdução e Serviços Básicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Filas: serviços auxiliares e estruturas de dados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Filas: introdução e serviços básicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Caixas de correio: serviços auxiliares e estruturas de dados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Caixas de correio: Introdução e serviços básicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Semáforos: Serviços Auxiliares e Estruturas de Dados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Semáforos: introdução e serviços básicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo # 18</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Grupos de Sinalizadores de Eventos: Serviços Auxiliares e Estruturas de Dados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Grupos de Sinalizadores de Eventos: Introdução e Serviços Básicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Signals</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partições de memória: serviços e estruturas de dados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Seções de memória: introdução e serviços básicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Estruturas de dados da tarefa e chamadas de API não suportadas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Serviços para trabalhar com tarefas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tarefas: configuração e introdução à API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Agendador: recursos avançados e preservação de contexto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Agendador: implementação</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Núcleo SE: Projeto Interno e Implantação</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo # 7</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Núcleo SE: Introdução</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Outros serviços RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Interação e sincronização de tarefas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tarefas, alternância de contexto e interrupções</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo # 3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tarefas e planejamento</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RTOS: estrutura e modo em tempo real</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RTOS: introdução.</a> <br></div></div><br><h2>  O que é o Nucleus SE? </h2><br>  Sabemos que o Nucleus SE é o núcleo de um sistema operacional em tempo real, mas você precisa entender como ele se encaixa no restante do aplicativo.  E apenas se encaixa, porque, diferentemente de um sistema operacional de desktop (por exemplo, Windows), o aplicativo não inicia no Nucleus SE;  o kernel é simplesmente parte de um programa em execução em um dispositivo incorporado.  Este é o caso de uso mais comum para o RTOS. <br><br>  Do ponto de vista de alto nível, um aplicativo incorporado é algum tipo de código iniciado quando a CPU é iniciada.  Nesse caso, o ambiente de hardware e software é inicializado e a função <b>main ()</b> é chamada, que inicia o código principal do aplicativo. <br><br>  Ao usar o Nucleus SE (e muitos outros kernels semelhantes), a diferença é que a função <b>main ()</b> faz parte do código do kernel.  Essa função simplesmente inicializa as estruturas de dados do kernel e depois chama o agendador, o que leva ao lançamento do código do aplicativo (tarefas).  O usuário pode adicionar qualquer código de inicialização nativo à função <b>main ()</b> . <br><br>  O Nucleus SE também inclui um conjunto de funções - uma interface de programação de aplicativos (API) que fornece um conjunto de funções como comunicação e sincronização de tarefas, trabalhando com temporizadores, alocação de memória, etc.  Todas as funções da API foram descritas anteriormente nos artigos desta série. <br><br>  Todo o software Nucleus SE é fornecido como código fonte (principalmente em C).  Para configurar o código de acordo com os requisitos de um aplicativo específico, é usada a compilação condicional.  Isso é descrito em detalhes neste artigo na seção Configuração. <br><br>  Após a compilação do código, os módulos de objeto Nucleus SE resultantes são associados aos módulos de código do aplicativo, resultando em uma única imagem binária, que geralmente é colocada na memória flash do dispositivo incorporado.  O resultado dessa ligação estática é que todas as informações simbólicas permanecem disponíveis no código do aplicativo e no código do kernel.  Isso é útil para depuração; no entanto, é necessário cuidado para evitar o uso indevido dos dados do Nucleus SE. <br><br><h2>  Suporte de CPU e ferramenta </h2><br>  Como o Nucleus SE vem como código-fonte, ele deve ser portátil.  No entanto, o código em execução em um nível tão baixo (ao usar agendadores em que a alternância de contexto é necessária, ou seja, qualquer coisa que não seja Executar para Conclusão), não pode ser completamente independente da linguagem assembly.  Minimizei essa dependência e quase não é necessário migrar para uma nova programação de baixo nível da CPU.  O uso de um novo conjunto de ferramentas de desenvolvimento (compilador, montador, vinculador etc.) também pode levar a problemas de portabilidade. <br><br><h2>  Configurando o aplicativo Nucleus SE </h2><br>  A chave para o uso eficiente do Nucleus SE é a configuração adequada.  Pode parecer complicado, mas, de fato, tudo é bastante lógico e requer apenas uma abordagem sistemática.  Quase toda a configuração é feita editando dois arquivos: <b>nuse_config.he</b> <b>nuse_config.c</b> . <br><br><h3>  Configuração Nuse_config.h </h3><br>  Este arquivo é apenas um conjunto de caracteres da diretiva <b>#define</b> , que recebe os valores apropriados para obter a configuração necessária do kernel.  No arquivo <b>nuse_config.h,</b> por padrão, todos os caracteres estão presentes, mas eles recebem as configurações mínimas. <br><br>  <b><i>Contadores de Objetos</i></b> <br>  O número de objetos do kernel de cada tipo é definido pelos valores dos símbolos no formato <b>NUSE_SEMAPHORE_NUMBER</b> .  Para a maioria dos objetos, esse valor pode variar de 0 a 15. As tarefas são uma exceção, deve haver pelo menos uma.  Os sinais, na verdade, não são objetos independentes, pois estão associados a tarefas e são <b>ativados configurando NUSE_SIGNAL_SUPPOR</b> T como <b>TRUE</b> . <br><br>  <b><i>Ativadores de função API</i></b> <br>  Cada função da API do Nucleus SE pode ser ativada separadamente, atribuindo um símbolo cujo nome corresponde ao nome da função (por exemplo, <b>NUSE_PIPE_JAM</b> ) como <b>TRUE</b> .  Isso leva à inclusão do código de função no aplicativo. <br><br>  <b><i>Seleção e configurações do agendador</i></b> <br>  O Nucleus SE suporta quatro tipos de agendadores, conforme descrito em um artigo anterior.  O planejador usado é definido atribuindo <b>NUSE_SCHEDULER_TYPE a</b> um dos seguintes valores: <b>NUSE_RUN_TO_COMPLETION_SCHEDULER</b> , <b>NUSE_TIME_SLICE_SCHEDULER</b> , <b>NUSE_ROUND_ROBIN_SCHEDULER</b> ou <b>NUSE_PRIORITY_SCHEDULER</b> . <br><br>  Você pode configurar outros parâmetros do planejador: <br>  <b>NUSE_TIME_SLICE_TICKS</b> indica o número de ticks por slot para o planejador de Time Slice.  Se outro agendador for usado, esse parâmetro deverá ser definido como 0. <br>  <b>NUSE_SCHEDULE_COUNT_SUPPORT</b> pode ser definido como <b>TRUE</b> ou <b>FALSE</b> para ativar / desativar o mecanismo do contador do planejador. <br>  <b>NUSE_SUSPEND_ENABLE</b> ativa o bloqueio de tarefas (suspensão) para muitas funções da API.  Isso significa que uma chamada para essa função pode levar à suspensão da tarefa de chamada até que o recurso seja liberado.  Para selecionar esta opção, <b>NUSE_SUSPEND_ENABLE</b> também <b>deve</b> ser definido como <b>TRUE</b> . <br><br>  <b><i>Outras opções</i></b> <br>  Vários outros parâmetros também podem receber valores <b>TRUE</b> ou <b>FALSE</b> para ativar / desativar outras funções do kernel: <br>  <b>NUSE_API_PARAMETER_CHECKING</b> adiciona um código de verificação de parâmetro de chamada de função da API.  Comumente usado para depuração. <br>  <b>NUSE_INITIAL_TASK_STATE_SUPPORT</b> define o estado inicial de todas as tarefas como <b>NUSE_READY</b> ou <b>NUSE_PURE_SUSPEND</b> .  Se esse parâmetro estiver desativado, todas as tarefas terão o estado inicial <b>NUSE_READY</b> . <br>  <b>NUSE_SYSTEM_TIME_SUPPORT</b> - suporte para horário do sistema. <br>  <b>NUSE_INCLUDE_EVERYTHING</b> - um parâmetro que adiciona o número máximo de funções à configuração do Nucleus SE.  Isso leva à ativação de toda a funcionalidade opcional e de cada função da API dos objetos configurados.  Usado para criar rapidamente uma configuração do Nucleus SE para verificar uma nova portabilidade do código do kernel. <br><br><h3>  Definindo nuse_config.c </h3><br>  Após especificar a configuração do kernel em <b>nuse_config.h,</b> é necessário inicializar as várias estruturas de dados armazenadas na ROM.  Isso é feito no arquivo <b>nuse_config.c</b> .  A definição de estruturas de dados é controlada pela compilação condicional, portanto, todas as estruturas estão contidas em uma cópia do arquivo <b>nuse_config.c</b> padrão. <br><br>  <b><i>Dados da tarefa</i></b> <br>  A matriz <b>NUSE_Task_Start_Address []</b> deve ser inicializada com o valor dos endereços iniciais de cada tarefa.  Geralmente, isso é apenas uma lista de nomes de funções, sem parênteses.  Protótipos de funções de entrada de tarefas também devem estar visíveis.  No arquivo padrão, a tarefa é configurada com o nome <b>NUSE_Idle_Task ()</b> , isso pode ser alterado para a tarefa do aplicativo. <br><br>  Se você usar qualquer agendador, exceto Executar até a conclusão, cada tarefa exigirá sua própria pilha.  Para cada pilha de tarefas, você deve criar uma matriz na RAM.  Essas matrizes devem ser do tipo <b>ADDR</b> e o endereço de cada uma delas deve ser armazenado em <b>NUSE_Task_Stack_Base []</b> .  É difícil prever o tamanho da matriz, portanto, é melhor usar medições (consulte a seção "Depuração" mais adiante neste artigo).  O tamanho de cada matriz (ou seja, o número de palavras na pilha) deve ser armazenado em <b>NUSE_Task_Stack_Size []</b> . <br><br>  Se uma função tiver sido ativada para indicar o estado inicial da tarefa (usando o parâmetro <b>NUSE_INITIAL_TASK_STATE_SUPPORT</b> ), a matriz <b>NUSE_Task_Initial_State [] []</b> deverá ser inicializada com o <b>estado NUSE_READY ou NUSE_PURE_SUSPEND</b> . <br><br>  <b><i>Dados do Conjunto de Partições</i></b> <br>  Se pelo menos um conjunto de partições estiver configurado, uma matriz (do tipo <b>U8</b> ) deverá ser criada para cada um deles na ROM.  O tamanho dessas matrizes é calculado da seguinte forma: (número de partições * (tamanho da partição + 1)).  Os endereços dessas seções (ou seja, seus nomes) devem ser atribuídos aos elementos <b>NUSE_Partition_Pool_Data_Address []</b> correspondentes.  Para cada pool, o número de partições e seu tamanho devem ser colocados em <b>NUSE_Partition_Pool_Partition_Number []</b> e <b>NUSE_Partition_Message_Size []</b> , respectivamente. <br><br>  <b><i>Dados da fila</i></b> <br>  Se pelo menos uma fila estiver configurada, uma matriz (do tipo <b>ADDR</b> ) deverá ser criada para cada um deles na RAM.  O tamanho dessas matrizes é o número de elementos em cada fila.  Os endereços dessas matrizes (ou seja, seus nomes) devem ser atribuídos aos elementos <b>NUSE_Queue_Data []</b> correspondentes.  O tamanho de cada fila deve ser atribuído ao elemento <b>NUSE_Queue_Size []</b> correspondente. <br><br>  <b><i>Dados do Link de Dados</i></b> <br>  Se pelo menos um canal de dados estiver configurado, uma matriz (do tipo <b>U8</b> ) deverá ser criada na RAM para ele (ou para cada um deles).  O tamanho dessas matrizes é calculado da seguinte forma: (tamanho do canal * tamanho da mensagem no canal).  Os endereços dessas matrizes (ou seja, seus nomes) devem ser atribuídos aos elementos <b>NUSE_Pipe_Data []</b> correspondentes.  Para cada canal, seu tamanho e tamanho da mensagem devem ser atribuídos aos elementos <b>NUSE_Pipe_Size []</b> e <b>NUSE_Pipe_Message_Size []</b> correspondentes, respectivamente. <br><br>  <b><i>Dados do semáforo</i></b> <br>  Se pelo menos um semáforo estiver configurado, a matriz <b>NUSE_Semaphore_Initial_Value []</b> deverá ser inicializada com os valores iniciais da contagem regressiva. <br><br>  <b><i>Dados do temporizador do aplicativo</i></b> <br>  Se pelo menos um timer estiver configurado, a matriz <b>NUSE_Timer_Initial_Time []</b> deve ser inicializada com os valores iniciais dos contadores.  Além disso, <b>NUSE_Timer_Reschedule_Time []</b> deve receber valores de reinicialização.  Esses valores do timer serão usados ​​após o término do primeiro ciclo do timer.  Se os valores de reinicialização estiverem definidos como 0, o contador irá parar após um ciclo. <br><br>  Se o suporte para mecanismos de conclusão de conta estiver configurado (configurando o parâmetro <b>NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT</b> como <b>TRUE</b> ), mais duas matrizes deverão ser criadas.  Endereços de mecanismos de conclusão (apenas uma lista de nomes de funções, sem parênteses) devem ser colocados em <b>NUSE_Timer_Expiration_Routine_Address []</b> .  A matriz <b>NUSE_Timer_Expiration_Routine_Parameter []</b> deve ser inicializada com os valores dos parâmetros de conclusão. <br><br><h2>  Qual API? </h2><br>  Todos os sistemas operacionais, de uma forma ou de outra, possuem uma API (interface de programação de aplicativos).  O Nucleus SE não é exceção, e as funções que compõem a API foram descritas em detalhes nesta série de artigos. <br><br>  Pode parecer óbvio que, ao escrever um aplicativo usando o Nucleus SE, você precisará usar a API conforme descrito nos artigos anteriores.  No entanto, esse nem sempre é o caso. <br><br>  Para a maioria dos usuários, a API do Nucleus SE será algo novo, talvez até a primeira experiência no uso da API do sistema operacional.  E, como é bastante simples, pode servir como uma boa introdução ao tópico.  Nesse caso, o procedimento é claro. <br><br>  Para alguns usuários, uma API alternativa pode ser uma opção mais atraente.  Existem três situações óbvias em que isso é possível. <br><ol><li>  O Nucleus SE é apenas parte de um sistema que usa outros sistemas operacionais para outros componentes.  Portanto, a portabilidade do código e, mais importante, a experiência de usar vários sistemas operacionais parecem muito tentadoras. </li><li>  O usuário tem uma vasta experiência no uso da API de outro sistema operacional.  Usar essa experiência também é muito recomendável. </li><li>  O usuário deseja reutilizar o código escrito para a API de outro sistema operacional.  É possível alterar as chamadas à API, mas demorado. </li></ol><br><br>  Como o código-fonte completo do Nucleus SE está disponível para todos, não há nada que o impeça de editar cada função da API para que pareça equivalente a outro sistema operacional.  No entanto, levará muito tempo e será muito improdutivo.  Uma abordagem mais correta seria escrever um "invólucro".  Existem várias maneiras de fazer isso, mas a maneira mais fácil é criar um arquivo de cabeçalho ( <b>#include</b> ) contendo um conjunto de <b>#define</b> macros que mapeará funções da API de terceiros para as funções da API do Nucleus SE. <br><br>  Um wrapper que transfere as funções da API Nucleus RTOS (parcialmente) para o Nucleus SE é distribuído com o Nucleus SE.  Pode ser útil para desenvolvedores com experiência no uso do Nucleus RTOS ou onde, no futuro, é possível mudar para esse RTOS.  Esse wrapper também pode servir como exemplo ao desenvolver coisas semelhantes. <br><br><h2>  Depurando aplicativos Nucleus SE </h2><br>  Escrever um aplicativo incorporado usando um kernel multitarefa é uma tarefa complexa.  Garantir que o código funcione e detectar erros pode ser uma tarefa assustadora.  Apesar de ser apenas um código executado em um processador, a execução simultânea de várias tarefas dificulta o foco em um encadeamento específico de execução.  Isso é ainda mais complicado quando várias tarefas compartilham um código comum.  O pior de tudo é quando duas tarefas têm exatamente o mesmo código (mas funcionam com dados diferentes).  Também é complicado o desenrolar das estruturas de dados que são usadas para implementar objetos do kernel, a fim de ver informações significativas. <br><br>  Para depurar aplicativos criados usando o Nucleus SE, nenhuma biblioteca adicional ou outros serviços são necessários.  Todo o código do kernel é legível pelo depurador.  Portanto, todas as informações simbólicas estão disponíveis para estudo.  Ao trabalhar com aplicativos Nucleus SE, qualquer ferramenta moderna de depuração pode ser usada. <br><br><h3>  Usando um depurador </h3><br>  As ferramentas de depuração projetadas especificamente para sistemas embarcados tornaram-se muito poderosas nos 30 anos em que existiram.  A principal característica de um aplicativo incorporado, em comparação com um programa de desktop, é que todos os sistemas incorporados são diferentes (e todos os computadores pessoais são bastante parecidos entre si).  Um bom depurador incorporado deve ser flexível e ter configurações suficientes para corresponder à variedade de sistemas incorporados e aos requisitos do usuário.  A capacidade de personalização do depurador é expressa de várias formas, mas geralmente existe a possibilidade de criar scripts.  É esse recurso que permite que o depurador funcione bem com um aplicativo no nível do kernel.  Abaixo, discutirei alguns casos de uso do depurador. <br><br>  Vale a pena notar que geralmente um depurador é uma família de ferramentas, não apenas um programa.  O depurador pode ter vários modos de operação, através dos quais ajuda no desenvolvimento de código em um sistema virtual ou em hardware real. <br><br><h3>  Pontos de interrupção sensíveis à tarefa </h3><br>  Se o programa tiver um código comum a várias tarefas, o uso de pontos de interrupção convencionais durante a depuração é complicado.  Provavelmente, você precisa que o código seja interrompido apenas quando um ponto de interrupção for atingido no contexto de uma tarefa específica que você está depurando no momento.  Para fazer isso, você precisa de um ponto de interrupção que leve em consideração a tarefa. <br><br>  Felizmente, a capacidade de criar scripts nos depuradores modernos e a disponibilidade dos dados de caracteres do Nucleus SE tornam a implementação de pontos de interrupção específicos da tarefa uma coisa bastante simples.  Tudo o que é necessário é escrever um script simples que será associado a um ponto de interrupção que você deseja ensinar a distinguir entre tarefas.  Este script utilizará o parâmetro: index (ID) da tarefa em que você está interessado.  O script simplesmente compara esse valor com o índice da tarefa atual ( <i>NUSE_Task_Active</i> ).  Se os valores corresponderem, o programa fará uma pausa.  Se eles são diferentes, a execução continua.  Vale ressaltar que a execução desse script afetará a execução do aplicativo em tempo real ( <i>nota do tradutor: significa que a execução do programa diminuirá a velocidade em relação à sua operação normal</i> ).  No entanto, se o script não estiver em um loop que será executado com muita frequência, esse efeito será mínimo. <br><br><h3>  Informações sobre o objeto do kernel </h3><br>  A necessidade óbvia de depurar o aplicativo Nucleus SE é a capacidade de obter informações sobre os objetos do kernel: quais são suas características e qual é seu status atual.  Isso permite que você obtenha respostas para perguntas como: "Qual é o tamanho dessa fila e quantas mensagens estão agora?" <br><br>  Isso pode ser usado adicionando código de depuração adicional ao seu aplicativo, que usará as chamadas de API "informativas" (como <b>NUSE_Queue_Information</b> ).  Obviamente, isso significa que seu aplicativo agora contém código adicional, que não será necessário após a implementação do aplicativo.  Usar <b>#define</b> para ativar e desativar esse código usando compilação condicional seria uma decisão lógica. <br><br>  Alguns depuradores podem fazer uma chamada de função direcionada, ou seja, chamar diretamente uma função de API para recuperar informações.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso elimina a necessidade de código adicional, mas essa função da API deve ser configurada para o depurador usá-lo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma abordagem alternativa, mais flexível, mas menos "não envelhecida" é o acesso direto às estruturas de dados dos objetos do kernel. </font><font style="vertical-align: inherit;">Provavelmente, é melhor fazer isso usando scripts de depuração. </font><font style="vertical-align: inherit;">Em nosso exemplo, o tamanho da fila pode ser obtido em </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_Queue_Size []</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e seu uso atual em </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_Queue_Data []</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Além disso, as mensagens na fila podem ser exibidas usando o endereço da área de dados da fila (de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_Queue_Data []</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Valores de retorno de chamada da API </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muitas funções da API retornam um valor de status indicando com que êxito a chamada foi concluída. Seria útil acompanhar esses valores e marcar casos nos quais eles não são iguais a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_SUCCESS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ou seja, eles têm um valor zero). Como esse rastreamento é apenas para depuração, a compilação condicional é bastante apropriada. A definição de uma variável global (por exemplo, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_API_Call_Status</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) pode ser compilada condicionalmente (sob o controle do símbolo de diretiva #define). Então, parte da definição de chamadas de API, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_API_Call_Status =</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , também pode ser compilada condicionalmente. Por exemplo, para fins de depuração, uma chamada que se parece com isso: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_Mailbox_Send (mbox, msg, NUSE_SUSPSEND);</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> assumirá o seguinte formato:</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_API_Call_Status = NUSE_Mailbox_Send (mbox, msg, NUSE_SUSPEND); </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o bloqueio de tarefas estiver ativado, muitas chamadas de função da API poderão retornar apenas informações sobre a conclusão de uma chamada bem-sucedida ou que o objeto foi redefinido. </font><font style="vertical-align: inherit;">No entanto, se a verificação de parâmetro da API estiver ativada, as chamadas da API poderão retornar muitos outros valores.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Configurando o tamanho da pilha de tarefas e do estouro da pilha </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O tópico sobre proteção contra sobrecarga de pilha foi discutido em um artigo anterior (# 31). Existem várias outras possibilidades durante a depuração. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A área de memória da pilha pode ser preenchida com um valor característico: algo além de todos os ou zeros. Depois disso, o depurador pode ser usado para monitorar as áreas de memória e quanto os valores serão alterados, o que nos permitirá entender o grau de plenitude da pilha. Se todas as áreas de memória foram alteradas, isso não significa que a pilha estava cheia, mas pode significar que seu tamanho é insuficiente, o que é perigoso. Deve ser aumentado e o teste continuado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conforme descrito no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo # 31</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ao implementar diagnósticos, áreas adicionais, “palavras de proteção”, podem ser localizadas em qualquer uma das bordas da área de memória da pilha. </font><font style="vertical-align: inherit;">O depurador pode ser usado para rastrear o acesso a essas palavras, já que qualquer tentativa de gravá-las significa um estouro ou exaustão da pilha.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lista de verificação de configuração do Nucleus SE </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o Nucleus SE foi projetado como um sistema altamente flexível e personalizável para atender aos requisitos da aplicação, requer um número significativo de parâmetros personalizáveis. </font><font style="vertical-align: inherit;">É por isso que todo este artigo é dedicado à configuração do Nucleus SE. </font><font style="vertical-align: inherit;">Para garantir que não perdemos nada, a seguir, é apresentada uma lista de verificação de todas as etapas principais que você precisa seguir para criar o aplicativo incorporado Nucleus SE.</font></font><br><ol><li> <b> Nucleus SE.</b>   ,     Nucleus SE       ,        Nucleus SE     . </li><li> <b>  CPU/.</b>             . </li><li> <b>  .</b>     ,       ,    . </li><li> <b>  .</b>        .       .  ,     .      16 . </li><li> <b> .</b>     -   <b>main()</b> ? </li><li> <b> .</b>     4 ,       . </li><li> <b>   </b> ,     . </li><li> <b>    .</b> </li><li> <b>.</b>   ,     . </li><li> <b> .</b>    ,    . </li><li> <b>  .</b> ,      .     .  —  16   . </li><li> <b>  .</b>        ,   . </li><li> <b>  .</b>        ,    (,      ). </li><li> <b> API.</b>    API,   . </li></ol><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O próximo artigo (o último desta série) resumirá toda a história com o Nucleus SE e também fornecerá informações que ajudarão na criação das implementações do Nucleus SE e seu uso. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobre o autor:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colin Walls trabalha na indústria eletrônica há mais de trinta anos, dedicando a maior parte de seu tempo ao firmware. </font><font style="vertical-align: inherit;">Ele agora é engenheiro de firmware na Mentor Embedded (uma divisão da Mentor Graphics). </font><font style="vertical-align: inherit;">Colin Walls frequentemente fala em conferências e seminários, autor de vários artigos técnicos e dois livros sobre firmware. </font><font style="vertical-align: inherit;">Vive no Reino Unido. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blog</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> profissional </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">de Colin</font></a><font style="vertical-align: inherit;"> , e-mail: colin_walls@mentor.com.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt467763/">https://habr.com/ru/post/pt467763/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt467751/index.html">Como um mensageiro descentralizado na blockchain</a></li>
<li><a href="../pt467753/index.html">Recorde mundial de transmissão de dados sem fio: 40 Gb / s por 11 quilômetros</a></li>
<li><a href="../pt467755/index.html">Príons, cálcio, microbiota, hormônios alimentares e Alzheimer</a></li>
<li><a href="../pt467759/index.html">Design de SO semelhante ao Unix - Espaço de Endereço Virtual (6)</a></li>
<li><a href="../pt467761/index.html">Energia, calor e água, parte três: vá ao rádio</a></li>
<li><a href="../pt467765/index.html">Wi-Fi e muitas outras abreviações. Como obter dados em nós Wi-Fi em um aplicativo Android e não aumentar</a></li>
<li><a href="../pt467767/index.html">Mais facilidades para seguidores JSON-RPC</a></li>
<li><a href="../pt467769/index.html">Em um único recurso de informação federal que contém informações da população</a></li>
<li><a href="../pt467771/index.html">Como um auto-reloader júnior verde, escreveu o seu <s> quente </s>. Parte 2. CSS</a></li>
<li><a href="../pt467773/index.html">Fornecimento de recursos incomuns e primeiro contato</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>