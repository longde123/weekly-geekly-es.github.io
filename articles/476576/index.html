<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ¢Ô∏è ü§üüèΩ üë©üèæ‚Äçü§ù‚Äçüë©üèº JSON-RPC? Toma el complicado RESTO üë©üèº‚ÄçüöÄ üôÅ üíú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Estoy seguro de que el titular caus√≥ una reacci√≥n saludable: "Bueno, comenz√≥ de nuevo ..." Pero perm√≠tame captar su atenci√≥n durante 5 a 10 minutos e ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JSON-RPC? Toma el complicado RESTO</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476576/"><p><img src="https://habrastorage.org/webt/q0/at/ek/q0atekvadeakqoxlbkht27oxt8c.jpeg"></p><br><p>  Estoy seguro de que el titular caus√≥ una reacci√≥n saludable: "Bueno, comenz√≥ de nuevo ..." Pero perm√≠tame captar su atenci√≥n durante 5 a 10 minutos e intentar√© no enga√±ar a las expectativas. </p><br><p> La estructura del art√≠culo ser√° la siguiente: se toma una declaraci√≥n estereot√≠pica y se revela la "naturaleza" de la aparici√≥n de este estereotipo.  Espero que esto le permita ver la elecci√≥n del paradigma de intercambio de datos en sus proyectos desde un nuevo √°ngulo. </p><br><p>  Para dejar en claro qu√© es RPC, propongo considerar el est√°ndar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JSON-RPC 2.0</a> .  No hay claridad con REST.  Y no deber√≠a ser.  Todo lo que necesita saber sobre REST es indistinguible de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HTTP</a> . </p><a name="habracut"></a><br><h2 id="rpc-zaprosy-bystree-i-effektivnee-potomu-chto-pozvolyayut-delat-batch-zaprosy">  Las solicitudes RPC son m√°s r√°pidas y m√°s eficientes porque permiten solicitudes por lotes. </h2><br><p>  El punto es que en RPC es posible hacer una llamada a varios procedimientos en una sola solicitud.  Por ejemplo, cree un usuario, agr√©guele un avatar y, en la misma solicitud, firme sobre algunos temas.  ¬°Solo una solicitud, y cu√°nto bien! </p><br><p>  De hecho, si solo tiene un nodo de fondo, esto parecer√° m√°s r√°pido con una solicitud por lotes.  Porque tres solicitudes REST requerir√°n el triple de recursos de un nodo para establecer conexiones. </p><br><p><img src="https://habrastorage.org/webt/wd/o9/yy/wdo9yyuiainix3lto2vtfwl4jtu.jpeg"></p><br><p>  Tenga en cuenta que la primera solicitud en el caso de REST debe devolver el ID de usuario para solicitudes posteriores.  Lo que tambi√©n afecta negativamente el resultado general. </p><br><p>  Pero tales infraestructuras se pueden encontrar, quiz√°s, en soluciones internas y Enterprise.  Como √∫ltimo recurso, en peque√±os proyectos WEB.  Pero las soluciones WEB completas, y tambi√©n llamadas HighLoad, no deber√≠an construirse as√≠.  Su infraestructura debe cumplir con los criterios de alta disponibilidad y carga de trabajo.  Y la imagen est√° cambiando. </p><br><p><img src="https://habrastorage.org/webt/q5/x_/js/q5x_js3bh9se9vzjejgpyqfeexq.jpeg"></p><br><p>  El verde indica canales de actividad de infraestructura en el mismo escenario.  Observe c√≥mo se comporta RPC ahora.  La solicitud utiliza la infraestructura solo un hombro desde el equilibrador hasta el backend.  Mientras que REST todav√≠a pierde en la primera solicitud, compensa el tiempo perdido usando toda la infraestructura. </p><br><p>  Es suficiente ingresar en el gui√≥n no dos solicitudes de enriquecimiento, sino, digamos, cinco o diez ... y la respuesta a la pregunta "¬øqui√©n gana ahora?" Se vuelve obvia. </p><br><p>  Propongo mirar a√∫n m√°s el problema.  El diagrama muestra c√≥mo se utilizan los canales de infraestructura, pero la infraestructura no se limita a los canales.  Un componente importante de una infraestructura muy cargada son las cach√©s.  Consigamos algunos artefactos de usuario ahora.  Varias veces  Dilo 32 veces. </p><br><p><img src="https://habrastorage.org/webt/vp/ts/es/vptseszry2ujpaxxlorxj5dk3gu.jpeg"></p><br><p>  Vea c√≥mo la infraestructura en el RPC se ha "recuperado" visiblemente para satisfacer las demandas de alta carga.  La cuesti√≥n es que REST usa toda la potencia del protocolo HTTP, a diferencia de RPC.  En el diagrama anterior, esta potencia se realiza a trav√©s del m√©todo de solicitud: GET. </p><br><p>  Los m√©todos HTTP, entre otras cosas, tienen estrategias de almacenamiento en cach√©.  Puede conocerlos en la documentaci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HTTP</a> .  Para RPC, se utilizan solicitudes POST que no se consideran idempotentes, es decir, la repetici√≥n repetida de las mismas solicitudes POST puede devolver resultados diferentes (por ejemplo, despu√©s de que se env√≠e cada comentario, aparecer√° otra copia de este comentario) ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fuente</a> ). </p><br><p>  En consecuencia, los RPC no pueden usar eficientemente cach√©s de infraestructura.  Esto lleva al hecho de que tiene que "importar" cach√©s de software.  El diagrama muestra a Redis en este rol.  La memoria cach√© flexible, a su vez, requiere que el desarrollador tenga una capa de c√≥digo adicional y cambios significativos en la arquitectura. </p><br><p>  Ahora calculemos cu√°ntas solicitudes "dieron a luz" a REST y RPC en la infraestructura en consideraci√≥n. </p><br><div class="scrollable-table"><table><thead><tr><th>  Consultas </th><th>  Bandeja de entrada </th><th>  backend </th><th>  a DBMS </th><th>  al cach√© de software (Redis) </th><th>  TOTAL </th></tr></thead><tbody><tr><td>  DESCANSO </td><td>  1/32 * </td><td>  1 </td><td>  1 </td><td>  0 0 </td><td>  3/35 </td></tr><tr><td>  Rpc </td><td>  32 </td><td>  32 </td><td>  1 </td><td>  31 </td><td>  96 </td></tr></tbody></table></div><br><p>  [*] en el mejor de los casos (si se usa el cach√© local) 1 solicitud (¬°una!), en las peores 32 solicitudes entrantes. </p><br><p>  En comparaci√≥n con el primer esquema, la diferencia es sorprendente.  La victoria REST ahora es evidente.  Pero propongo no detenerse all√≠.  La infraestructura desarrollada incluye CDN.  A menudo, tambi√©n resuelve el problema de contrarrestar los ataques DDoS y DoS.  Obtenemos: </p><br><p><img src="https://habrastorage.org/webt/k2/9f/ky/k29fkywcpnld_poisd1s7g9oxhs.jpeg"></p><br><p>  Aqu√≠ para RPC, todo se vuelve muy deplorable.  RPC simplemente no puede delegar el trabajo con la carga de CDN.  Uno solo puede confiar en los sistemas para contrarrestar los ataques. </p><br><p>  ¬øEs posible terminar esto?  Y de nuevo, no.  Los m√©todos HTTP, como se mencion√≥ anteriormente, tienen su propia "magia".  Y por una buena raz√≥n, el m√©todo GET se usa totalmente en Internet.  Tenga en cuenta que este m√©todo puede acceder a parte del contenido, puede establecer condiciones que pueden interpretar los elementos de la infraestructura antes de transferir el control a su c√≥digo, etc.  Todo esto le permite crear infraestructuras flexibles y manejables que pueden digerir flujos de solicitudes realmente grandes.  Y en RPC, este m√©todo ... se ignora. </p><br><p>  Entonces, ¬øpor qu√© el mito es tan persistente que las solicitudes por lotes (RPC) son m√°s r√°pidas?  Personalmente, me parece que la mayor√≠a de los proyectos simplemente no alcanzan ese nivel de desarrollo cuando REST puede demostrar su fortaleza.  Adem√°s, en proyectos peque√±os, es m√°s probable que muestre su debilidad. </p><br><p>  La elecci√≥n de REST o RPC no es una elecci√≥n voluntaria de un individuo en el proyecto.  Esta elecci√≥n debe cumplir con los requisitos del proyecto.  Si el proyecto es capaz de exprimir de REST todo lo que realmente puede, y realmente es necesario, entonces REST ser√° una excelente opci√≥n. </p><br><p>  Pero si para obtener todas las ganancias de REST, necesitar√° contratar desarrolladores para escalar r√°pidamente la infraestructura, administradores para administrar la infraestructura, un arquitecto para dise√±ar todas las capas del servicio WEB ... y el proyecto vender√° tres paquetes de margarina por d√≠a ... I se detendr√≠a en RPC desde  Este protocolo es m√°s utilitario.  No requiere un conocimiento profundo de la operaci√≥n de cach√©s e infraestructura, pero enfoca al desarrollador en llamadas simples y comprensibles a los procedimientos necesarios.  El negocio estar√° complacido. </p><br><h2 id="rpc-zaprosy-nadezhnee-potomu-chto-mogut-vypolnyat-batch-zaprosy-v-ramkah-odnoy-tranzakcii">  Las solicitudes RPC son m√°s confiables porque pueden ejecutar solicitudes por lotes en una sola transacci√≥n </h2><br><p>  Esta propiedad de RPC es una ventaja definitiva, ya que  Es f√°cil mantener la base de datos en un estado coherente.  Pero con REST, todo es m√°s complicado.  Las solicitudes pueden llegar de manera inconsistente a diferentes nodos de fondo. </p><br><p>  Este "inconveniente" de REST es el otro lado de sus ventajas descritas anteriormente: la capacidad de utilizar de manera efectiva todos los recursos de infraestructura.  Si la infraestructura est√° mal dise√±ada, y m√°s a√∫n si la arquitectura del proyecto y la base de datos en particular est√°n mal dise√±adas, entonces esto es realmente un gran dolor. </p><br><p>  Pero, ¬ølas solicitudes por lotes son tan confiables como parecen?  Veamos el caso: cree un usuario, enriquezca su perfil con alguna descripci√≥n y env√≠ele un SMS con un secreto para completar el registro.  Es decir  Tres llamadas en una solicitud de lote. </p><br><p><img src="https://habrastorage.org/webt/i5/ry/4k/i5ry4k9evunfpvdeowewzqkpmkm.jpeg"></p><br><p>  Consideremos el esquema.  Presenta la infraestructura con elementos de alta disponibilidad.  Hay dos canales de comunicaci√≥n independientes con pasarelas SMS.  Pero ... ¬øqu√© vemos?  Al enviar SMS, se produce el error 503: el servicio no est√° disponible temporalmente.  Porque  el env√≠o de SMS se empaqueta en una solicitud por lotes, luego toda la solicitud debe revertirse.  Las acciones en el DBMS se cancelan.  El cliente recibe un error. </p><br><p>  El siguiente intento es una loter√≠a.  O la solicitud va al mismo nodo nuevamente y devuelve un error, o tiene suerte y se ejecutar√°.  Pero lo principal es que al menos una vez nuestra infraestructura ya ha funcionado en vano.  Hab√≠a una carga, pero ninguna ganancia. </p><br><p>  Bueno, imaginemos que nos tensamos (!) Y pensamos en la opci√≥n donde la solicitud podr√≠a completarse parcialmente con √©xito.  Y el resto, trataremos de cumplir nuevamente despu√©s de un intervalo de tiempo (¬øCu√°l? ¬øDecide el frente?).  Pero la loter√≠a se mantuvo.  Una solicitud para enviar un SMS con una probabilidad de 50/50 fallar√° nuevamente. </p><br><p>  De acuerdo, del lado del cliente, el servicio no parece tan confiable como nos gustar√≠a ... pero ¬øqu√© pasa con REST? </p><br><p><img src="https://habrastorage.org/webt/yu/ol/yy/yuolyyficausbg8c3jgzmddc1kk.jpeg"></p><br><p>  REST usa magia HTTP nuevamente, pero ahora con c√≥digos de respuesta.  Si se produce un error 503 en la puerta de enlace de SMS, el backend transmite este error al equilibrador.  El equilibrador que recibe este error, y sin interrumpir la conexi√≥n con el cliente, env√≠a la solicitud a otro nodo que procesa la solicitud con √©xito.  Es decir  el cliente recibe el resultado esperado y la infraestructura confirma su alto rango de "altamente accesible".  El usuario esta contento. </p><br><p>  Y de nuevo, esto no es todo.  El equilibrador no solo recibi√≥ el c√≥digo de respuesta 503. Es recomendable proporcionar este c√≥digo con el encabezado "Reintentar despu√©s" al responder. El encabezado deja claro al equilibrador que no debe perturbar este nodo en esta ruta durante un tiempo espec√≠fico. Y las siguientes solicitudes de env√≠o de SMS se enviar√° de inmediato a un nodo que no tenga problemas con la puerta de enlace de SMS. </p><br><p>  Como podemos ver, la confiabilidad de JSON-RPC est√° sobrevalorada.  De hecho, es m√°s f√°cil organizar la consistencia de la base de datos.  Pero la v√≠ctima, en este caso, ser√° la fiabilidad del sistema en su conjunto. </p><br><p>  La conclusi√≥n es muy similar a la anterior.  Cuando la infraestructura es simple, lo obvio de JSON-RPC es sin duda su ventaja.  Si un proyecto implica una alta disponibilidad con una gran carga, REST parece una soluci√≥n m√°s precisa, aunque m√°s compleja. </p><br><h2 id="porog-vhoda-v-rest-nizhe">  Umbral de entrada REST por debajo </h2><br><p>  Creo que el an√°lisis anterior, desacreditando los estereotipos establecidos sobre RPC, mostr√≥ claramente que el umbral para ingresar a REST es indudablemente m√°s alto que en RPC.  Esto se debe a la necesidad de una comprensi√≥n profunda de HTTP, as√≠ como a la necesidad de tener un conocimiento suficiente sobre los elementos de infraestructura existentes que pueden y deben usarse en proyectos WEB. </p><br><p>  Entonces, ¬øpor qu√© muchas personas piensan que REST ser√° m√°s f√°cil?  Mi opini√≥n personal es que esta aparente simplicidad proviene del REST que se manifiesta.  Es decir  REST no es un protocolo, sino un concepto ... REST no tiene un est√°ndar, hay algunas recomendaciones ... REST no es m√°s complicado que HTTP.  La aparente libertad y anarqu√≠a atrae a los "artistas libres". </p><br><p>  Sin lugar a dudas, REST no es m√°s complicado que HTTP.  Pero HTTP en s√≠ es un protocolo bien dise√±ado que ha sido probado durante d√©cadas.  Si no hay una comprensi√≥n profunda de HTTP en s√≠, REST no puede ser juzgado. </p><br><p>  Pero sobre RPC, puedes.  Es suficiente para tomar su especificaci√≥n.  Entonces, ¬ønecesitas un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tonto JSON-RPC</a> ?  ¬øO es astuto REST?  Depende de usted. </p><br><p>  Sinceramente espero no haber perdido su tiempo en vano. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/476576/">https://habr.com/ru/post/476576/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../476554/index.html">Transmisi√≥n webRTC basada en la nube en DigitalOcean</a></li>
<li><a href="../476556/index.html">Narrativa y "mazmorras": c√≥mo un dise√±ador de juegos asocia las ubicaciones con una trama</a></li>
<li><a href="../476558/index.html">Revisi√≥n de ONYX BOOX Max 3: lector de pantalla m√°ximo</a></li>
<li><a href="../476566/index.html">¬øC√≥mo entender si los activos digitales son valores? Instrucci√≥n SEC</a></li>
<li><a href="../476570/index.html">Opini√≥n privada sobre Yandex.Turbo</a></li>
<li><a href="../476578/index.html">9 beneficios clave de la tecnolog√≠a Blockchain en software deportivo</a></li>
<li><a href="../476580/index.html">Horizontal vs. Crecimiento vertical del desarrollador. Opiniones de ivi y Yandex</a></li>
<li><a href="../476582/index.html">Contador DWT</a></li>
<li><a href="../476590/index.html">C√≥mo empacar la aplicaci√≥n VueJS + NodeJS + MongoDB en Docker</a></li>
<li><a href="../476592/index.html">CLRium # 6: faltan 9 d√≠as</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>