<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游빃游낖 游붊 游끦游낖 Zenject: c칩mo un contenedor de IoC puede matar la inyecci칩n de dependencia en su proyecto 游 丘쐞잺 游늼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="쮻칩nde comienza el peligro? Suponga que est치 firmemente decidido a desarrollar un proyecto, adhiri칠ndose a un concepto o enfoque espec칤fico. En nuestr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zenject: c칩mo un contenedor de IoC puede matar la inyecci칩n de dependencia en su proyecto</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420235/">  쮻칩nde comienza el peligro?  Suponga que est치 firmemente decidido a desarrollar un proyecto, adhiri칠ndose a un concepto o enfoque espec칤fico.  En nuestra situaci칩n, esto es DI, aunque la programaci칩n reactiva, por ejemplo, tambi칠n puede estar en su lugar.  Es l칩gico que para lograr su objetivo, recurra a soluciones preparadas (en nuestro ejemplo, el contenedor DI Zenject).  Se familiarizar치 con la documentaci칩n y comenzar치 a construir el marco de la aplicaci칩n utilizando la funcionalidad principal.  Si en las primeras etapas del uso de la soluci칩n no tiene sensaciones desagradables, lo m치s probable es que permanezca en su proyecto durante toda su vida.  A medida que trabaje con las funciones b치sicas de la soluci칩n (contenedor), es posible que tenga preguntas o deseos para hacer que alguna funcionalidad sea m치s bella o efectiva.  Seguramente, en primer lugar, recurrir치 a las "caracter칤sticas" m치s avanzadas de la soluci칩n (contenedor) para esto.  Y en esta etapa, puede surgir la siguiente situaci칩n: ya conoce bien y conf칤a en la soluci칩n elegida, por lo que muchos pueden no pensar en cu치n ideol칩gicamente correcto puede ser el uso de uno u otro funcional en la soluci칩n, o la transici칩n a otra soluci칩n ya es bastante costosa e inapropiada ( por ejemplo, se acerca la fecha l칤mite).  Es en esta etapa que puede surgir la situaci칩n m치s peligrosa: la funcionalidad de la soluci칩n se utiliza con poco cuidado o, en casos excepcionales, simplemente en la m치quina (sin pensar). <br><a name="habracut"></a><br><h3>  쯈ui칠n podr칤a estar interesado en esto? </h3><br>  Este art칤culo ser치 칰til tanto para quienes est치n familiarizados con la DI como para los principiantes.  Para comprender suficiente conocimiento b치sico sobre qu칠 patrones utiliza DI, el prop칩sito de DI y las funciones que realiza un contenedor de IoC.  No se trata de las complejidades de la implementaci칩n de Zenject, sino de la aplicaci칩n de parte de su funcionalidad.  El art칤culo se basa 칰nicamente en la documentaci칩n oficial de Zenject y ejemplos de c칩digo, as칤 como en el libro de Mark Siman "Inyecci칩n de dependencias en .NET", que es un trabajo exhaustivo cl치sico sobre el tema de la teor칤a DI.  Todas las citas en este art칤culo son extractos del libro de Mark Siman.  A pesar del hecho de que hablaremos sobre un contenedor espec칤fico, el art칤culo puede ser 칰til para aquellos que usan otros contenedores. <br><br>  El prop칩sito de este art칤culo es mostrar c칩mo una herramienta cuyo prop칩sito es ayudarlo a implementar DI en su proyecto puede guiarlo en una direcci칩n completamente diferente, empuj치ndolo a cometer errores que vinculan su c칩digo, reducen la capacidad de prueba del c칩digo y, en general, lo privan de todas las ventajas que pueden brindarle usted DI. <br><br>  <i><b>Descargo de responsabilidad</b></i> : El prop칩sito de este art칤culo no es criticar a Zenject ni a sus autores.  Zenject se puede utilizar para el prop칩sito previsto y servir como una excelente herramienta para implementar DI, siempre que no utilice un conjunto completo de sus funciones, ya que ha definido algunas limitaciones para usted. <br><br><h3>  Introduccion </h3><br>  <i>Zenject</i> es un contenedor de inyecci칩n de dependencia de c칩digo abierto destinado a usar el motor de juego Unity3D, que funciona en la mayor칤a de las plataformas compatibles con Unity3D.  Vale la pena se침alar que Zenject tambi칠n se puede usar para aplicaciones C # desarrolladas sin Unity3D.  Este contenedor es bastante popular entre los desarrolladores de Unity, est치 activamente respaldado y desarrollado.  Adem치s, Zenject tiene toda la funcionalidad necesaria del contenedor DI. <br><br>  Us칠 Zenject en 3 grandes proyectos de Unity, y tambi칠n me comuniqu칠 con una gran cantidad de desarrolladores que lo usaron.  La raz칩n para escribir este art칤culo son las preguntas frecuentes: <br><br><ul><li>  쯋sar Zenject es una buena soluci칩n? </li><li>  쯈u칠 le pasa a Zenject? </li><li>  쯈u칠 dificultades surgen al usar Zenject? </li></ul><br>  Y tambi칠n algunos proyectos en los que el uso de Zenject no condujo a la soluci칩n de problemas de conectividad de c칩digo fuerte y arquitectura fallida, sino que exacerb칩 la situaci칩n. <br><br>  Veamos por qu칠 los desarrolladores tienen tales preguntas y problemas.  Puede responder de la siguiente manera: <br><blockquote>  Ir칩nicamente, los contenedores DI en s칤 tienden a ser dependencias estables.  ... Cuando decide desarrollar su aplicaci칩n en funci칩n de un contenedor DI particular, corre el riesgo de limitarse a esta opci칩n durante todo el ciclo de vida de la aplicaci칩n. </blockquote>  Vale la pena se침alar que con el uso adecuado y limitado del contenedor, cambiar a usar otro contenedor en la aplicaci칩n (o negarse a usar el contenedor a favor de la " <i>implementaci칩n para los pobres</i> ") es bastante posible y no tomar치 mucho tiempo.  Es cierto que en tal situaci칩n, es poco probable que lo necesite. <br><br>  Antes de comenzar a desmontar la funcionalidad potencialmente peligrosa de Zenject, tiene sentido actualizar superficialmente varios aspectos b치sicos de DI. <br><br>  El primer aspecto es el <i>prop칩sito de los contenedores DI.</i>  Mark Siman escribe lo siguiente en su libro sobre este tema: <br><blockquote>  Un contenedor DI es una biblioteca de software que puede automatizar muchas de las tareas que se realizan al ensamblar objetos y administrar su ciclo de vida. </blockquote><blockquote>  No espere que el contenedor DI convierta m치gicamente el c칩digo fuertemente acoplado en c칩digo d칠bilmente acoplado.  Un contenedor puede mejorar la eficiencia del uso de DI, pero el 칠nfasis en la aplicaci칩n debe colocarse principalmente en el uso de patrones y trabajar con DI. </blockquote>  El segundo aspecto son los <i>patrones DI</i> .  Mark Siman identifica cuatro patrones principales, ordenados por frecuencia y la necesidad de su uso: <br><br><ol><li>  Implementaci칩n del constructor: 쯖칩mo podemos garantizar que la dependencia requerida siempre estar치 disponible para la clase que se est치 desarrollando? </li><li>  Implementaci칩n de propiedad: 쯖칩mo puedo habilitar DI como una opci칩n en la clase si hay un valor predeterminado local adecuado? </li><li>  Implementaci칩n del m칠todo: 쯖칩mo puedo inyectar dependencias en una clase si son diferentes para cada operaci칩n? </li><li>  Contexto ambiental: 쯖칩mo podemos hacer que una dependencia est칠 disponible en cada m칩dulo sin incluir aspectos transversales de la aplicaci칩n en cada componente API? </li></ol><br>  Las preguntas indicadas junto al nombre de los patrones describen completamente su alcance.  Al mismo tiempo, el art칤culo no discutir치 la Implementaci칩n del Constructor (ya que pr치cticamente no hay quejas sobre su implementaci칩n en Zenject) y el Contexto Ambiental (su implementaci칩n no est치 en el contenedor, pero puede implementarlo f치cilmente en funci칩n de la funcionalidad existente). <br>  Ahora puede ir directamente a la funcionalidad potencialmente peligrosa de Zenject. <br><br><h3>  Funcionalidad peligrosa. </h3><br><h4>  Implementar propiedades </h4><br>  Este es el segundo patr칩n DI m치s com칰n, despu칠s de la implementaci칩n del constructor, pero se usa con mucha menos frecuencia.  Implementado en Zenject de la siguiente manera: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Foo</span></span> { [Inject] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IBar Bar { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br>  Adem치s, Zenject tambi칠n tiene un concepto como "Inyecci칩n de campo".  Veamos por qu칠 en todos los Zenject esta funcionalidad es la m치s peligrosa. <br><br><ul><li>  Se utiliza un atributo para mostrar al contenedor qu칠 campo incrustar.  Esta es una soluci칩n completamente comprensible, desde el punto de vista de la simplicidad y la l칩gica de implementaci칩n del contenedor en s칤.  Sin embargo, vemos un atributo (as칤 como un espacio de nombres) en el c칩digo de la clase.  Es decir, al menos indirectamente, pero la clase comienza a saber de d칩nde obtiene la dependencia.  Adem치s, estamos comenzando a ajustar el c칩digo de clase en el contenedor.  En otras palabras, ya no podemos negarnos a usar Zenject sin manipular el c칩digo de clase. </li><li>  El patr칩n en s칤 se usa en situaciones en las que la dependencia tiene un valor predeterminado local.  Es decir, esta es una dependencia opcional, y si el contenedor no puede proporcionarla, entonces no habr치 errores en el proyecto y todo funcionar치.  Sin embargo, con Zenject, siempre obtienes esta dependencia: la dependencia no se convierte en opcional. </li><li>  Dado que la dependencia en este caso no es opcional, comienza a estropear toda la l칩gica de la implementaci칩n del constructor, porque solo las dependencias requeridas deben introducirse all칤.  Al implementar dependencias no opcionales a trav칠s de propiedades, tiene la oportunidad de crear dependencias circulares en el c칩digo.  No ser치n tan obvios, porque en Zenject, la implementaci칩n del constructor se cumple primero, y luego la implementaci칩n de la propiedad, y no recibir치 una advertencia del contenedor. </li><li>  El uso del contenedor DI implica la implementaci칩n del patr칩n de ra칤z de composici칩n, sin embargo, el uso del atributo para configurar la implementaci칩n de la propiedad lleva al hecho de que configura el c칩digo no solo en la ra칤z de composici칩n, sino tambi칠n seg칰n sea necesario en cada clase. </li></ul><br><h4>  F치bricas (y MemoryPool) </h4><br>  La documentaci칩n de Zenject tiene una <a href="">secci칩n</a> completa sobre f치bricas.  Esta funcionalidad se implementa a nivel del contenedor en s칤, y tambi칠n es posible crear sus propias f치bricas personalizadas.  Echemos un vistazo al primer ejemplo de la documentaci칩n: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Enemy</span></span> { DiContainer Container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enemy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DiContainer container</span></span></span><span class="hljs-function">)</span></span> { Container = container; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> player = Container.Resolve&lt;Player&gt;(); WalkTowards(player.Position); ... etc. } }</code> </pre> <br>  Ya en este ejemplo hay una violaci칩n grave de DI.  Pero este es m치s bien un ejemplo de c칩mo hacer una f치brica totalmente personalizada.  쮺u치l es el principal problema aqu칤? <br><blockquote>  Un contenedor DI puede considerarse err칩neamente como un localizador de servicios, pero solo debe usarse como un mecanismo para vincular gr치ficos de objetos.  Si consideramos el contenedor desde este punto de vista, tiene sentido limitar su uso solo a la ra칤z del dise침o.  Este enfoque tiene la ventaja importante de que elimina cualquier enlace entre el contenedor y el resto del c칩digo de la aplicaci칩n. </blockquote>  Veamos c칩mo funcionan las f치bricas "integradas" de Zenject.  Hay una interfaz IFactory para esto, cuya implementaci칩n nos lleva a la clase PlaceholderFactory: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PlaceholderFactory</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TValue</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IPlaceholderFactory</span></span> { [Inject] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Construct</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IProvider provider, InjectContext injectContext</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br>  En 칠l vemos el par치metro InjectContext que tiene muchos constructores, de la forma: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InjectContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DiContainer container, Type memberType</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Container = container; MemberType = memberType; }</code> </pre> <br>  Y nuevamente, obtenemos la transferencia del contenedor en s칤 como una dependencia de la clase.  Este enfoque es una violaci칩n grave de DI y una transformaci칩n parcial del contenedor en un Localizador de servicios. <br>  Adem치s, la desventaja de esta soluci칩n es que el contenedor se usa para crear dependencias a corto plazo, y solo debe crear dependencias a largo plazo. <br><br>  Para evitar tales violaciones, los autores del contenedor podr칤an excluir por completo la posibilidad de pasar el contenedor como una dependencia a todas las clases registradas.  No ser칤a dif칤cil implementar esto, dado que todo el contenedor funciona mediante la reflexi칩n y el an치lisis de los par치metros de m칠todos y constructores para crear y dise침ar el gr치fico de los objetos de la aplicaci칩n. <br><br><h4>  Implementaci칩n del m칠todo </h4><br>  La l칩gica de la implementaci칩n del M칠todo en Zenject es la siguiente: primero, en todas las clases, se implementa el constructor, luego se implementan las propiedades y finalmente se implementa el m칠todo.  Considere el ejemplo de implementaci칩n proporcionado en la documentaci칩n: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Foo</span></span> { [Inject] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IBar bar, Qux qux</span></span></span><span class="hljs-function">)</span></span> { _bar = bar; _qux = qux; } }</code> </pre> <br>  쮺u치les son las desventajas aqu칤: <br><br><ul><li>  Puede escribir cualquier n칰mero de m칠todos que se implementar치n dentro del marco de una clase.  Por lo tanto, como en el caso de la implementaci칩n de la propiedad, tenemos la oportunidad de hacer tantas dependencias c칤clicas como sea posible. </li><li>  Al igual que la implementaci칩n de una propiedad, la implementaci칩n de un m칠todo se implementa mediante un atributo, que asocia su c칩digo con el c칩digo del contenedor en s칤. </li><li>  La implementaci칩n del m칠todo en Zenject se usa solo como una alternativa a los constructores, lo cual es conveniente en el caso de las clases MonoBehavior, pero contradice absolutamente la teor칤a descrita por Mark Siman.  El ejemplo cl치sico de la implementaci칩n can칩nica del m칠todo puede considerarse el uso de f치bricas (m칠todos de f치brica). </li><li>  Si hay varios m칠todos introducidos en la clase, o adem치s del m칠todo tambi칠n hay un constructor, resulta que las dependencias necesarias para la clase se dispersar치n en diferentes lugares, lo que interferir치 con la imagen como un todo.  Es decir, si la clase 1 tiene un constructor, entonces el n칰mero de sus par치metros puede mostrar claramente si hay errores de dise침o en la clase y si se viola el principio de responsabilidad exclusiva, y si las dependencias se dispersan por varios m칠todos, por el constructor, o tal vez por un par de propiedades, entonces la imagen no ser치 tan obvia como podr칤a ser. </li></ul><br>  Se deduce que la presencia de tal implementaci칩n de la implementaci칩n del m칠todo en el contenedor, que contradice la teor칤a DI, no tiene una sola ventaja.  Con una gran advertencia, un plus solo puede considerarse la posibilidad de utilizar el m칠todo implementado, como un constructor para MonoBehaviour.  Pero este es un momento bastante controvertido, ya que desde el punto de vista de la l칩gica del contenedor, los patrones DI y el dispositivo de memoria interna Unity3D, todos los objetos MonoBehaviour en su aplicaci칩n pueden considerarse administrados por recursos, y en este caso, ser치 mucho m치s eficiente delegar la administraci칩n del ciclo de vida de dichos objetos. no un contenedor DI, sino una clase auxiliar (ya sea Wrapper, ViewModel, Fasade u otra cosa). <br><br><h4>  Enlaces globales </h4><br>  Esta es una funcionalidad auxiliar bastante conveniente que le permite establecer carpetas globales que pueden vivir independientemente de la transici칩n entre escenas.  Puedes leer m치s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en la documentaci칩n</a> .  Esta funcionalidad es extremadamente conveniente y bastante 칰til.  Vale la pena se침alar que no viola los patrones y principios de DI, sin embargo, tiene una implementaci칩n fea y obvia.  La conclusi칩n es que crea un tipo especial de prefabricado, adjunta un script con la configuraci칩n del contenedor (instalador) y lo guarda en una carpeta de proyecto estrictamente definida, sin la capacidad de moverse a ning칰n lado y sin ning칰n enlace.  La desventaja de esta herramienta radica 칰nicamente en su car치cter impl칤cito.  Cuando se trata de instaladores normales, todo es bastante simple: tienes un objeto en el escenario, el script del instalador se cuelga de 칠l.  Si un nuevo desarrollador llega al proyecto, el instalador se convierte en un excelente punto de inmersi칩n en el proyecto.  Basado en un 칰nico instalador, un desarrollador puede hacerse una idea de en qu칠 m칩dulos consiste un proyecto y c칩mo se construye un gr치fico de objetos.  Pero con el uso de carpetas globales, el instalador en el escenario deja de ser una fuente suficiente de esta informaci칩n.  No hay un solo enlace al enlace global en el c칩digo de otros instaladores (presente en las escenas) y, por lo tanto, no ve el gr치fico completo de los objetos.  Y solo durante el an치lisis de las clases entiendes que algunos de los ligantes no son suficientes en el instalador en el escenario.  Una vez m치s, har칠 una reserva de que este inconveniente es puramente cosm칠tico. <br><br><h4>  Identificadores </h4><br>  La capacidad de establecer un enlace espec칤fico para un identificador con el fin de obtener una cierta dependencia de un conjunto de dependencias similares en una clase.  Un ejemplo: <br><br><pre> <code class="cs hljs">Container.Bind&lt;IFoo&gt;().WithId(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>).To&lt;Foo1&gt;().AsSingle(); Container.Bind&lt;IFoo&gt;().To&lt;Foo2&gt;().AsSingle(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Bar1</span></span> { [Inject(Id = <span class="hljs-string"><span class="hljs-string">"foo"</span></span>)] IFoo _foo; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Bar2</span></span> { [Inject] IFoo _foo; }</code> </pre> <br>  Esta funcionalidad puede ser realmente 칰til situacionalmente, y es una opci칩n adicional para la implementaci칩n de propiedades.  Sin embargo, junto con la conveniencia, hereda todos los problemas identificados en el p치rrafo "Implementando propiedades", agregando a칰n m치s coherencia al c칩digo al introducir una cierta constante que debe recordar al configurar su c칩digo.  Si elimina accidentalmente este identificador, puede obtener f치cilmente uno que no funciona de la aplicaci칩n de trabajo. <br><br><h4>  Se침ales e ITickable </h4><br>  Las se침ales son un an치logo del mecanismo del Agregador de eventos integrado en el contenedor.  La idea de implementar esta funcionalidad es indudablemente noble, ya que tiene como objetivo reducir el n칰mero de conexiones entre objetos que se comunican a trav칠s del mecanismo de eventos-suscripciones.  Un ejemplo bastante voluminoso se puede encontrar en la <a href="">documentaci칩n</a> , sin embargo, no estar치 en el art칤culo, porque la implementaci칩n espec칤fica no importa. <br><br>  Soporte para la interfaz ITickable: reemplaza los m칠todos est치ndar Update, LateUpdate y FixedUpdate en Unity al delegar las llamadas a los m칠todos de actualizaci칩n de objetos con la interfaz ITickable en el contenedor.  Tambi칠n hay un ejemplo en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci칩n</a> , y su implementaci칩n en el contexto del art칤culo tampoco importa. <br><br>  El problema de Signals and ITickable no se refiere a aspectos de su implementaci칩n, su ra칤z radica en el uso de efectos secundarios del contenedor.  En esencia, el contenedor conoce casi todas las clases y sus instancias dentro del proyecto, pero su responsabilidad es crear un gr치fico de objetos y administrar su ciclo de vida.  Al agregar mecanismos como Signals, ITickable, etc., agregamos m치s responsabilidades al contenedor, y cada vez m치s le adjuntamos el c칩digo de la aplicaci칩n, convirti칠ndolo en la parte exclusiva e irremplazable del c칩digo, pr치cticamente un "objeto divino". <br><br><h3>  En lugar de salida </h3><br><blockquote>  Lo m치s importante acerca de los contenedores es entender que el uso de DI es independiente del uso de un contenedor de DI.  Se puede construir una aplicaci칩n a partir de muchas clases y m칩dulos poco acoplados, y ninguno de estos m칩dulos debe saber nada sobre el contenedor. </blockquote>  Tenga cuidado al usar soluciones listas para usar (en caja) o peque침os complementos.  칔salos cuidadosamente.  De hecho, incluso cosas m치s grandiosas en las que conf칤a (por ejemplo, motores de juego de la escala de Unity3D) pueden pecar con tales errores te칩ricos y borrones.  Y esto, en 칰ltima instancia, afectar치 no el trabajo de la soluci칩n que usa, sino la sostenibilidad, el trabajo y la calidad de su producto final.  Espero que todos los que hayan le칤do hasta el final, el art칤culo les sea 칰til o, al menos, no se arrepientan del tiempo dedicado a leerlo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420235/">https://habr.com/ru/post/es420235/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420223/index.html">Algunos consejos simples: c칩mo evitar da침os al dron</a></li>
<li><a href="../es420225/index.html">Melod칤a algor칤tmica infinita basada en n칰meros primos</a></li>
<li><a href="../es420227/index.html">El presidente turco anuncia la prohibici칩n de importar productos electr칩nicos en EE. UU.</a></li>
<li><a href="../es420229/index.html">쯇ueden los ni침os de las aldeas convertirse en programadores si en las cercan칤as solo ense침an trabajadores ferroviarios? Conversaci칩n con el "C칤rculo"</a></li>
<li><a href="../es420233/index.html">UE4 | Equipo para multijugador # 5 | Transferencia de informaci칩n entre servidor y cliente</a></li>
<li><a href="../es420237/index.html">Qt wrapper alrededor del marco gRPC en C ++</a></li>
<li><a href="../es420239/index.html">Desarrollo m칩vil. Swift: el misterio de los protocolos</a></li>
<li><a href="../es420243/index.html">Filantrop칤a revolucionaria: proyectos humanitarios innovadores</a></li>
<li><a href="../es420245/index.html">C칩mo evitar el desbordamiento de memoria al usar colecciones Java</a></li>
<li><a href="../es420251/index.html">Apple afirma que el complejo de la sede de la compa침칤a cuesta solo $ 200</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>