<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧝🏼 🦋 🏇🏼 Zenject: cómo un contenedor de IoC puede matar la inyección de dependencia en su proyecto 🎲 ⚱️ 📑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¿Dónde comienza el peligro? Suponga que está firmemente decidido a desarrollar un proyecto, adhiriéndose a un concepto o enfoque específico. En nuestr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zenject: cómo un contenedor de IoC puede matar la inyección de dependencia en su proyecto</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420235/">  ¿Dónde comienza el peligro?  Suponga que está firmemente decidido a desarrollar un proyecto, adhiriéndose a un concepto o enfoque específico.  En nuestra situación, esto es DI, aunque la programación reactiva, por ejemplo, también puede estar en su lugar.  Es lógico que para lograr su objetivo, recurra a soluciones preparadas (en nuestro ejemplo, el contenedor DI Zenject).  Se familiarizará con la documentación y comenzará a construir el marco de la aplicación utilizando la funcionalidad principal.  Si en las primeras etapas del uso de la solución no tiene sensaciones desagradables, lo más probable es que permanezca en su proyecto durante toda su vida.  A medida que trabaje con las funciones básicas de la solución (contenedor), es posible que tenga preguntas o deseos para hacer que alguna funcionalidad sea más bella o efectiva.  Seguramente, en primer lugar, recurrirá a las "características" más avanzadas de la solución (contenedor) para esto.  Y en esta etapa, puede surgir la siguiente situación: ya conoce bien y confía en la solución elegida, por lo que muchos pueden no pensar en cuán ideológicamente correcto puede ser el uso de uno u otro funcional en la solución, o la transición a otra solución ya es bastante costosa e inapropiada ( por ejemplo, se acerca la fecha límite).  Es en esta etapa que puede surgir la situación más peligrosa: la funcionalidad de la solución se utiliza con poco cuidado o, en casos excepcionales, simplemente en la máquina (sin pensar). <br><a name="habracut"></a><br><h3>  ¿Quién podría estar interesado en esto? </h3><br>  Este artículo será útil tanto para quienes están familiarizados con la DI como para los principiantes.  Para comprender suficiente conocimiento básico sobre qué patrones utiliza DI, el propósito de DI y las funciones que realiza un contenedor de IoC.  No se trata de las complejidades de la implementación de Zenject, sino de la aplicación de parte de su funcionalidad.  El artículo se basa únicamente en la documentación oficial de Zenject y ejemplos de código, así como en el libro de Mark Siman "Inyección de dependencias en .NET", que es un trabajo exhaustivo clásico sobre el tema de la teoría DI.  Todas las citas en este artículo son extractos del libro de Mark Siman.  A pesar del hecho de que hablaremos sobre un contenedor específico, el artículo puede ser útil para aquellos que usan otros contenedores. <br><br>  El propósito de este artículo es mostrar cómo una herramienta cuyo propósito es ayudarlo a implementar DI en su proyecto puede guiarlo en una dirección completamente diferente, empujándolo a cometer errores que vinculan su código, reducen la capacidad de prueba del código y, en general, lo privan de todas las ventajas que pueden brindarle usted DI. <br><br>  <i><b>Descargo de responsabilidad</b></i> : El propósito de este artículo no es criticar a Zenject ni a sus autores.  Zenject se puede utilizar para el propósito previsto y servir como una excelente herramienta para implementar DI, siempre que no utilice un conjunto completo de sus funciones, ya que ha definido algunas limitaciones para usted. <br><br><h3>  Introduccion </h3><br>  <i>Zenject</i> es un contenedor de inyección de dependencia de código abierto destinado a usar el motor de juego Unity3D, que funciona en la mayoría de las plataformas compatibles con Unity3D.  Vale la pena señalar que Zenject también se puede usar para aplicaciones C # desarrolladas sin Unity3D.  Este contenedor es bastante popular entre los desarrolladores de Unity, está activamente respaldado y desarrollado.  Además, Zenject tiene toda la funcionalidad necesaria del contenedor DI. <br><br>  Usé Zenject en 3 grandes proyectos de Unity, y también me comuniqué con una gran cantidad de desarrolladores que lo usaron.  La razón para escribir este artículo son las preguntas frecuentes: <br><br><ul><li>  ¿Usar Zenject es una buena solución? </li><li>  ¿Qué le pasa a Zenject? </li><li>  ¿Qué dificultades surgen al usar Zenject? </li></ul><br>  Y también algunos proyectos en los que el uso de Zenject no condujo a la solución de problemas de conectividad de código fuerte y arquitectura fallida, sino que exacerbó la situación. <br><br>  Veamos por qué los desarrolladores tienen tales preguntas y problemas.  Puede responder de la siguiente manera: <br><blockquote>  Irónicamente, los contenedores DI en sí tienden a ser dependencias estables.  ... Cuando decide desarrollar su aplicación en función de un contenedor DI particular, corre el riesgo de limitarse a esta opción durante todo el ciclo de vida de la aplicación. </blockquote>  Vale la pena señalar que con el uso adecuado y limitado del contenedor, cambiar a usar otro contenedor en la aplicación (o negarse a usar el contenedor a favor de la " <i>implementación para los pobres</i> ") es bastante posible y no tomará mucho tiempo.  Es cierto que en tal situación, es poco probable que lo necesite. <br><br>  Antes de comenzar a desmontar la funcionalidad potencialmente peligrosa de Zenject, tiene sentido actualizar superficialmente varios aspectos básicos de DI. <br><br>  El primer aspecto es el <i>propósito de los contenedores DI.</i>  Mark Siman escribe lo siguiente en su libro sobre este tema: <br><blockquote>  Un contenedor DI es una biblioteca de software que puede automatizar muchas de las tareas que se realizan al ensamblar objetos y administrar su ciclo de vida. </blockquote><blockquote>  No espere que el contenedor DI convierta mágicamente el código fuertemente acoplado en código débilmente acoplado.  Un contenedor puede mejorar la eficiencia del uso de DI, pero el énfasis en la aplicación debe colocarse principalmente en el uso de patrones y trabajar con DI. </blockquote>  El segundo aspecto son los <i>patrones DI</i> .  Mark Siman identifica cuatro patrones principales, ordenados por frecuencia y la necesidad de su uso: <br><br><ol><li>  Implementación del constructor: ¿cómo podemos garantizar que la dependencia requerida siempre estará disponible para la clase que se está desarrollando? </li><li>  Implementación de propiedad: ¿cómo puedo habilitar DI como una opción en la clase si hay un valor predeterminado local adecuado? </li><li>  Implementación del método: ¿cómo puedo inyectar dependencias en una clase si son diferentes para cada operación? </li><li>  Contexto ambiental: ¿cómo podemos hacer que una dependencia esté disponible en cada módulo sin incluir aspectos transversales de la aplicación en cada componente API? </li></ol><br>  Las preguntas indicadas junto al nombre de los patrones describen completamente su alcance.  Al mismo tiempo, el artículo no discutirá la Implementación del Constructor (ya que prácticamente no hay quejas sobre su implementación en Zenject) y el Contexto Ambiental (su implementación no está en el contenedor, pero puede implementarlo fácilmente en función de la funcionalidad existente). <br>  Ahora puede ir directamente a la funcionalidad potencialmente peligrosa de Zenject. <br><br><h3>  Funcionalidad peligrosa. </h3><br><h4>  Implementar propiedades </h4><br>  Este es el segundo patrón DI más común, después de la implementación del constructor, pero se usa con mucha menos frecuencia.  Implementado en Zenject de la siguiente manera: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Foo</span></span> { [Inject] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IBar Bar { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br>  Además, Zenject también tiene un concepto como "Inyección de campo".  Veamos por qué en todos los Zenject esta funcionalidad es la más peligrosa. <br><br><ul><li>  Se utiliza un atributo para mostrar al contenedor qué campo incrustar.  Esta es una solución completamente comprensible, desde el punto de vista de la simplicidad y la lógica de implementación del contenedor en sí.  Sin embargo, vemos un atributo (así como un espacio de nombres) en el código de la clase.  Es decir, al menos indirectamente, pero la clase comienza a saber de dónde obtiene la dependencia.  Además, estamos comenzando a ajustar el código de clase en el contenedor.  En otras palabras, ya no podemos negarnos a usar Zenject sin manipular el código de clase. </li><li>  El patrón en sí se usa en situaciones en las que la dependencia tiene un valor predeterminado local.  Es decir, esta es una dependencia opcional, y si el contenedor no puede proporcionarla, entonces no habrá errores en el proyecto y todo funcionará.  Sin embargo, con Zenject, siempre obtienes esta dependencia: la dependencia no se convierte en opcional. </li><li>  Dado que la dependencia en este caso no es opcional, comienza a estropear toda la lógica de la implementación del constructor, porque solo las dependencias requeridas deben introducirse allí.  Al implementar dependencias no opcionales a través de propiedades, tiene la oportunidad de crear dependencias circulares en el código.  No serán tan obvios, porque en Zenject, la implementación del constructor se cumple primero, y luego la implementación de la propiedad, y no recibirá una advertencia del contenedor. </li><li>  El uso del contenedor DI implica la implementación del patrón de raíz de composición, sin embargo, el uso del atributo para configurar la implementación de la propiedad lleva al hecho de que configura el código no solo en la raíz de composición, sino también según sea necesario en cada clase. </li></ul><br><h4>  Fábricas (y MemoryPool) </h4><br>  La documentación de Zenject tiene una <a href="">sección</a> completa sobre fábricas.  Esta funcionalidad se implementa a nivel del contenedor en sí, y también es posible crear sus propias fábricas personalizadas.  Echemos un vistazo al primer ejemplo de la documentación: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Enemy</span></span> { DiContainer Container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enemy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DiContainer container</span></span></span><span class="hljs-function">)</span></span> { Container = container; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> player = Container.Resolve&lt;Player&gt;(); WalkTowards(player.Position); ... etc. } }</code> </pre> <br>  Ya en este ejemplo hay una violación grave de DI.  Pero este es más bien un ejemplo de cómo hacer una fábrica totalmente personalizada.  ¿Cuál es el principal problema aquí? <br><blockquote>  Un contenedor DI puede considerarse erróneamente como un localizador de servicios, pero solo debe usarse como un mecanismo para vincular gráficos de objetos.  Si consideramos el contenedor desde este punto de vista, tiene sentido limitar su uso solo a la raíz del diseño.  Este enfoque tiene la ventaja importante de que elimina cualquier enlace entre el contenedor y el resto del código de la aplicación. </blockquote>  Veamos cómo funcionan las fábricas "integradas" de Zenject.  Hay una interfaz IFactory para esto, cuya implementación nos lleva a la clase PlaceholderFactory: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PlaceholderFactory</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TValue</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IPlaceholderFactory</span></span> { [Inject] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Construct</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IProvider provider, InjectContext injectContext</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br>  En él vemos el parámetro InjectContext que tiene muchos constructores, de la forma: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InjectContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DiContainer container, Type memberType</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Container = container; MemberType = memberType; }</code> </pre> <br>  Y nuevamente, obtenemos la transferencia del contenedor en sí como una dependencia de la clase.  Este enfoque es una violación grave de DI y una transformación parcial del contenedor en un Localizador de servicios. <br>  Además, la desventaja de esta solución es que el contenedor se usa para crear dependencias a corto plazo, y solo debe crear dependencias a largo plazo. <br><br>  Para evitar tales violaciones, los autores del contenedor podrían excluir por completo la posibilidad de pasar el contenedor como una dependencia a todas las clases registradas.  No sería difícil implementar esto, dado que todo el contenedor funciona mediante la reflexión y el análisis de los parámetros de métodos y constructores para crear y diseñar el gráfico de los objetos de la aplicación. <br><br><h4>  Implementación del método </h4><br>  La lógica de la implementación del Método en Zenject es la siguiente: primero, en todas las clases, se implementa el constructor, luego se implementan las propiedades y finalmente se implementa el método.  Considere el ejemplo de implementación proporcionado en la documentación: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Foo</span></span> { [Inject] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IBar bar, Qux qux</span></span></span><span class="hljs-function">)</span></span> { _bar = bar; _qux = qux; } }</code> </pre> <br>  ¿Cuáles son las desventajas aquí: <br><br><ul><li>  Puede escribir cualquier número de métodos que se implementarán dentro del marco de una clase.  Por lo tanto, como en el caso de la implementación de la propiedad, tenemos la oportunidad de hacer tantas dependencias cíclicas como sea posible. </li><li>  Al igual que la implementación de una propiedad, la implementación de un método se implementa mediante un atributo, que asocia su código con el código del contenedor en sí. </li><li>  La implementación del método en Zenject se usa solo como una alternativa a los constructores, lo cual es conveniente en el caso de las clases MonoBehavior, pero contradice absolutamente la teoría descrita por Mark Siman.  El ejemplo clásico de la implementación canónica del método puede considerarse el uso de fábricas (métodos de fábrica). </li><li>  Si hay varios métodos introducidos en la clase, o además del método también hay un constructor, resulta que las dependencias necesarias para la clase se dispersarán en diferentes lugares, lo que interferirá con la imagen como un todo.  Es decir, si la clase 1 tiene un constructor, entonces el número de sus parámetros puede mostrar claramente si hay errores de diseño en la clase y si se viola el principio de responsabilidad exclusiva, y si las dependencias se dispersan por varios métodos, por el constructor, o tal vez por un par de propiedades, entonces la imagen no será tan obvia como podría ser. </li></ul><br>  Se deduce que la presencia de tal implementación de la implementación del método en el contenedor, que contradice la teoría DI, no tiene una sola ventaja.  Con una gran advertencia, un plus solo puede considerarse la posibilidad de utilizar el método implementado, como un constructor para MonoBehaviour.  Pero este es un momento bastante controvertido, ya que desde el punto de vista de la lógica del contenedor, los patrones DI y el dispositivo de memoria interna Unity3D, todos los objetos MonoBehaviour en su aplicación pueden considerarse administrados por recursos, y en este caso, será mucho más eficiente delegar la administración del ciclo de vida de dichos objetos. no un contenedor DI, sino una clase auxiliar (ya sea Wrapper, ViewModel, Fasade u otra cosa). <br><br><h4>  Enlaces globales </h4><br>  Esta es una funcionalidad auxiliar bastante conveniente que le permite establecer carpetas globales que pueden vivir independientemente de la transición entre escenas.  Puedes leer más <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en la documentación</a> .  Esta funcionalidad es extremadamente conveniente y bastante útil.  Vale la pena señalar que no viola los patrones y principios de DI, sin embargo, tiene una implementación fea y obvia.  La conclusión es que crea un tipo especial de prefabricado, adjunta un script con la configuración del contenedor (instalador) y lo guarda en una carpeta de proyecto estrictamente definida, sin la capacidad de moverse a ningún lado y sin ningún enlace.  La desventaja de esta herramienta radica únicamente en su carácter implícito.  Cuando se trata de instaladores normales, todo es bastante simple: tienes un objeto en el escenario, el script del instalador se cuelga de él.  Si un nuevo desarrollador llega al proyecto, el instalador se convierte en un excelente punto de inmersión en el proyecto.  Basado en un único instalador, un desarrollador puede hacerse una idea de en qué módulos consiste un proyecto y cómo se construye un gráfico de objetos.  Pero con el uso de carpetas globales, el instalador en el escenario deja de ser una fuente suficiente de esta información.  No hay un solo enlace al enlace global en el código de otros instaladores (presente en las escenas) y, por lo tanto, no ve el gráfico completo de los objetos.  Y solo durante el análisis de las clases entiendes que algunos de los ligantes no son suficientes en el instalador en el escenario.  Una vez más, haré una reserva de que este inconveniente es puramente cosmético. <br><br><h4>  Identificadores </h4><br>  La capacidad de establecer un enlace específico para un identificador con el fin de obtener una cierta dependencia de un conjunto de dependencias similares en una clase.  Un ejemplo: <br><br><pre> <code class="cs hljs">Container.Bind&lt;IFoo&gt;().WithId(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>).To&lt;Foo1&gt;().AsSingle(); Container.Bind&lt;IFoo&gt;().To&lt;Foo2&gt;().AsSingle(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Bar1</span></span> { [Inject(Id = <span class="hljs-string"><span class="hljs-string">"foo"</span></span>)] IFoo _foo; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Bar2</span></span> { [Inject] IFoo _foo; }</code> </pre> <br>  Esta funcionalidad puede ser realmente útil situacionalmente, y es una opción adicional para la implementación de propiedades.  Sin embargo, junto con la conveniencia, hereda todos los problemas identificados en el párrafo "Implementando propiedades", agregando aún más coherencia al código al introducir una cierta constante que debe recordar al configurar su código.  Si elimina accidentalmente este identificador, puede obtener fácilmente uno que no funciona de la aplicación de trabajo. <br><br><h4>  Señales e ITickable </h4><br>  Las señales son un análogo del mecanismo del Agregador de eventos integrado en el contenedor.  La idea de implementar esta funcionalidad es indudablemente noble, ya que tiene como objetivo reducir el número de conexiones entre objetos que se comunican a través del mecanismo de eventos-suscripciones.  Un ejemplo bastante voluminoso se puede encontrar en la <a href="">documentación</a> , sin embargo, no estará en el artículo, porque la implementación específica no importa. <br><br>  Soporte para la interfaz ITickable: reemplaza los métodos estándar Update, LateUpdate y FixedUpdate en Unity al delegar las llamadas a los métodos de actualización de objetos con la interfaz ITickable en el contenedor.  También hay un ejemplo en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación</a> , y su implementación en el contexto del artículo tampoco importa. <br><br>  El problema de Signals and ITickable no se refiere a aspectos de su implementación, su raíz radica en el uso de efectos secundarios del contenedor.  En esencia, el contenedor conoce casi todas las clases y sus instancias dentro del proyecto, pero su responsabilidad es crear un gráfico de objetos y administrar su ciclo de vida.  Al agregar mecanismos como Signals, ITickable, etc., agregamos más responsabilidades al contenedor, y cada vez más le adjuntamos el código de la aplicación, convirtiéndolo en la parte exclusiva e irremplazable del código, prácticamente un "objeto divino". <br><br><h3>  En lugar de salida </h3><br><blockquote>  Lo más importante acerca de los contenedores es entender que el uso de DI es independiente del uso de un contenedor de DI.  Se puede construir una aplicación a partir de muchas clases y módulos poco acoplados, y ninguno de estos módulos debe saber nada sobre el contenedor. </blockquote>  Tenga cuidado al usar soluciones listas para usar (en caja) o pequeños complementos.  Úsalos cuidadosamente.  De hecho, incluso cosas más grandiosas en las que confía (por ejemplo, motores de juego de la escala de Unity3D) pueden pecar con tales errores teóricos y borrones.  Y esto, en última instancia, afectará no el trabajo de la solución que usa, sino la sostenibilidad, el trabajo y la calidad de su producto final.  Espero que todos los que hayan leído hasta el final, el artículo les sea útil o, al menos, no se arrepientan del tiempo dedicado a leerlo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420235/">https://habr.com/ru/post/es420235/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420223/index.html">Algunos consejos simples: cómo evitar daños al dron</a></li>
<li><a href="../es420225/index.html">Melodía algorítmica infinita basada en números primos</a></li>
<li><a href="../es420227/index.html">El presidente turco anuncia la prohibición de importar productos electrónicos en EE. UU.</a></li>
<li><a href="../es420229/index.html">¿Pueden los niños de las aldeas convertirse en programadores si en las cercanías solo enseñan trabajadores ferroviarios? Conversación con el "Círculo"</a></li>
<li><a href="../es420233/index.html">UE4 | Equipo para multijugador # 5 | Transferencia de información entre servidor y cliente</a></li>
<li><a href="../es420237/index.html">Qt wrapper alrededor del marco gRPC en C ++</a></li>
<li><a href="../es420239/index.html">Desarrollo móvil. Swift: el misterio de los protocolos</a></li>
<li><a href="../es420243/index.html">Filantropía revolucionaria: proyectos humanitarios innovadores</a></li>
<li><a href="../es420245/index.html">Cómo evitar el desbordamiento de memoria al usar colecciones Java</a></li>
<li><a href="../es420251/index.html">Apple afirma que el complejo de la sede de la compañía cuesta solo $ 200</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>