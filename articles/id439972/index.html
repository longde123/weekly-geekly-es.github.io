<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêè ü§ù üë®üèΩ‚Äç‚öñÔ∏è io_submit: alternatif untuk epoll yang belum pernah Anda dengar üôÄ ü§≤üèΩ ‚§¥Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baru-baru ini, perhatian penulis tertarik pada artikel di LWN tentang antarmuka kernel baru untuk polling. Ini membahas mekanisme polling baru di Linu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>io_submit: alternatif untuk epoll yang belum pernah Anda dengar</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/439972/"><img src="https://habrastorage.org/webt/sq/pn/nd/sqpnnd88db_ax0ark-6wxrqkobc.jpeg"><br><br>  Baru-baru ini, perhatian penulis tertarik pada artikel di LWN tentang antarmuka kernel baru untuk polling.  Ini membahas mekanisme polling baru di Linux AIO API (sebuah antarmuka untuk penanganan file asinkron), yang ditambahkan ke versi kernel 4.18.  Idenya cukup menarik: penulis tambalan menyarankan menggunakan Linux AIO API untuk bekerja dengan jaringan. <br><br>  Tapi tunggu sebentar!  Bagaimanapun, Linux AIO diciptakan untuk bekerja dengan I / O asinkron dari disk ke disk!  File pada disk tidak sama dengan koneksi jaringan.  Apakah mungkin menggunakan Linux AIO API untuk jaringan? <br><br>  Ternyata, ya, itu mungkin!  Artikel ini menjelaskan cara menggunakan kekuatan Linux AIO API untuk membuat server jaringan yang lebih cepat dan lebih baik. <br><br>  Tetapi mari kita mulai dengan menjelaskan apa itu Linux AIO. <br><a name="habracut"></a><br><h1>  Pengantar Linux AIO </h1><br>  Linux AIO menyediakan I / O disk-ke-disk asinkron untuk perangkat lunak pengguna. <br><br>  Secara historis, di Linux, semua operasi disk diblokir.  Jika Anda memanggil <code>open()</code> , <code>read()</code> , <code>write()</code> atau <code>fsync()</code> , maka streaming berhenti sampai metadata muncul di cache disk.  Ini biasanya bukan masalah.  Jika Anda tidak memiliki banyak operasi I / O dan memori yang cukup, panggilan sistem secara bertahap akan mengisi cache, dan semuanya akan bekerja cukup cepat. <br><br>  Kinerja operasi I / O berkurang ketika jumlahnya cukup besar, misalnya, dalam kasus dengan basis data dan proxy.  Untuk aplikasi seperti itu, tidak dapat diterima untuk menghentikan seluruh proses demi menunggu satu panggilan sistem <code>read()</code> . <br><br>  Untuk mengatasi masalah ini, aplikasi dapat menggunakan tiga metode: <br><br><ol><li>  Gunakan kumpulan utas dan fungsi pemblokiran panggilan pada utas terpisah.  Inilah cara kerja POSIX AIO di glibc (jangan bingung dengan Linux AIO).  Untuk informasi lebih lanjut, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi IBM</a> .  Inilah cara kami memecahkan masalah di Cloudflare: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kami menggunakan kumpulan utas</a> untuk memanggil <code>read()</code> dan <code>open()</code> . <br></li><li>  Lakukan pemanasan cache disk dengan <code>posix_fadvise(2)</code> dan berharap yang terbaik. <br></li><li>  Gunakan Linux AIO bersamaan dengan sistem file XFS, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buka file dengan flag O_DIRECT</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hindari masalah yang tidak terdokumentasi</a> . <br></li></ol><br>  Namun, tidak satupun dari metode ini yang ideal.  Bahkan Linux AIO, ketika digunakan tanpa berpikir, dapat diblokir dalam panggilan <code>io_submit()</code> .  Ini baru-baru ini disebutkan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> lain <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di LWN</a> : <br><blockquote>  ‚ÄúAntarmuka I / O asinkron Linux memiliki banyak kritik dan sedikit pendukung, tetapi kebanyakan orang berharap setidaknya tidak ada sinkronisasi dari itu.  Bahkan, operasi AIO dapat diblokir di kernel karena sejumlah alasan dalam situasi di mana utas panggilan tidak mampu. ‚Äù </blockquote>  Sekarang kita tahu kelemahan dari API AIO Linux, mari kita lihat kelebihannya. <br><br><h2>  Program sederhana menggunakan Linux AIO </h2><br>  Untuk menggunakan Linux AIO, pertama-tama Anda harus <a href="">menentukan sendiri lima panggilan sistem yang diperlukan</a> - glibc tidak menyediakannya. <br><br><ol><li>  Pertama, Anda perlu memanggil <code>io_setup()</code> untuk menginisialisasi struktur <code>aio_context</code> .  Kernel akan mengembalikan pointer buram ke struktur. <br></li><li>  Setelah itu, Anda dapat memanggil <code>io_submit()</code> untuk menambahkan vektor "blok kontrol I / O" ke antrian pemrosesan dalam bentuk struktur struct iocb. <br></li><li>  Sekarang, akhirnya, kita dapat memanggil <code>io_getevents()</code> dan menunggu jawaban darinya dalam bentuk vektor struktur struct <code>io_event</code> - hasil dari masing-masing blok iocb. <br></li></ol><br>  Ada delapan perintah yang bisa Anda gunakan di iocb.  Dua perintah untuk membaca, dua untuk menulis, dua opsi fsync, dan perintah POLL, yang ditambahkan dalam versi kernel 4.18 (perintah kedelapan adalah NOOP): <br><br><pre> <code class="plaintext hljs">IOCB_CMD_PREAD = 0, IOCB_CMD_PWRITE = 1, IOCB_CMD_FSYNC = 2, IOCB_CMD_FDSYNC = 3, IOCB_CMD_POLL = 5,   /* from 4.18 */ IOCB_CMD_NOOP = 6, IOCB_CMD_PREADV = 7, IOCB_CMD_PWRITEV = 8,</code> </pre> <br>  <a href=""><code> iocb</code></a> , yang diteruskan ke fungsi <code>io_submit</code> , cukup besar dan dirancang untuk bekerja dengan disk.  Berikut ini versinya yang disederhanakan: <br><br><pre> <code class="plaintext hljs">struct iocb { __u64 data;           /* user data */ ... __u16 aio_lio_opcode; /* see IOCB_CMD_ above */ ... __u32 aio_fildes;     /* file descriptor */ __u64 aio_buf;        /* pointer to buffer */ __u64 aio_nbytes;     /* buffer size */ ... }</code> </pre> <br>  Struktur lengkap <code>io_event</code> yang dikembalikan <code>io_getevents</code> : <br><br><pre> <code class="plaintext hljs">struct io_event { __u64  data; /* user data */ __u64  obj; /* pointer to request iocb */ __s64  res; /* result code for this event */ __s64  res2; /* secondary result */ };</code> </pre><br>  <b>Sebuah contoh</b>  Program sederhana yang membaca file / etc / passwd menggunakan Linux AIO API: <br><br><pre> <code class="plaintext hljs">fd = open("/etc/passwd", O_RDONLY); aio_context_t ctx = 0; r = io_setup(128, &amp;ctx); char buf[4096]; struct iocb cb = {.aio_fildes = fd,                 .aio_lio_opcode = IOCB_CMD_PREAD,                 .aio_buf = (uint64_t)buf,                 .aio_nbytes = sizeof(buf)}; struct iocb *list_of_iocb[1] = {&amp;cb}; r = io_submit(ctx, 1, list_of_iocb); struct io_event events[1] = {{0}}; r = io_getevents(ctx, 1, 1, events, NULL); bytes_read = events[0].res; printf("read %lld bytes from /etc/passwd\n", bytes_read);</code> </pre> <br>  Sumber lengkap, tentu saja, <a href="">tersedia di GitHub</a> .  Berikut adalah keluaran strace dari program ini: <br><br><pre> <code class="plaintext hljs">openat(AT_FDCWD, "/etc/passwd", O_RDONLY) io_setup(128, [0x7f4fd60ea000]) io_submit(0x7f4fd60ea000, 1, [{aio_lio_opcode=IOCB_CMD_PREAD, aio_fildes=3, aio_buf=0x7ffc5ff703d0, aio_nbytes=4096, aio_offset=0}]) io_getevents(0x7f4fd60ea000, 1, 1, [{data=0, obj=0x7ffc5ff70390, res=2494, res2=0}], NULL)</code> </pre> <br>  Semuanya berjalan dengan baik, tetapi membaca dari disk tidak sinkron: panggilan io_submit diblokir dan melakukan semua pekerjaan, fungsi <code>io_getevents</code> dijalankan secara instan.  Kita dapat mencoba membaca secara tidak sinkron, tetapi ini membutuhkan flag O_DIRECT, yang dengannya operasi disk mem-bypass cache. <br><br>  Mari kita ilustrasikan bagaimana <code>io_submit</code> mengunci file biasa.  Berikut adalah contoh serupa yang menunjukkan output dari strace sebagai hasil dari membaca blok 1 GB dari <code>/dev/zero</code> : <br><br><pre> <code class="plaintext hljs">io_submit(0x7fe1e800a000, 1, [{aio_lio_opcode=IOCB_CMD_PREAD, aio_fildes=3, aio_buf=0x7fe1a79f4000, aio_nbytes=1073741824, aio_offset=0}]) \   = 1 &lt;0.738380&gt; io_getevents(0x7fe1e800a000, 1, 1, [{data=0, obj=0x7fffb9588910, res=1073741824, res2=0}], NULL) \   = 1 &lt;0.000015&gt;</code> </pre> <br>  Kernel menghabiskan 738 ms pada panggilan <code>io_submit</code> dan hanya 15 ns pada <code>io_getevents</code> .  Berperilaku sama dengan koneksi jaringan - semua pekerjaan dilakukan oleh <code>io_submit</code> . <br><br><img src="https://habrastorage.org/webt/e6/kw/kf/e6kwkfffjb-qvsfqgfdyl2ibmaq.jpeg"><br>  <a href="">Foto</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Helix84</a> CC / BY-SA / 3.0 <br><br><h2>  Linux AIO dan Jaringan </h2><br>  Implementasi <code>io_submit</code> cukup konservatif: jika deskriptor file yang dikirimkan tidak dibuka dengan flag O_DIRECT, maka fungsinya cukup memblokir dan melakukan tindakan yang ditentukan.  Dalam hal koneksi jaringan, ini berarti bahwa: <br><br><ul><li>  untuk memblokir koneksi, IOCV_CMD_PREAD akan menunggu paket respons; <br></li><li>  untuk koneksi yang tidak memblokir, IOCB_CMD_PREAD akan mengembalikan kode -11 (EAGAIN). <br></li></ul><br>  Semantik yang sama juga digunakan dalam panggilan sistem <code>read()</code> , jadi kita dapat mengatakan bahwa io_submit ketika bekerja dengan koneksi jaringan tidak lebih pintar daripada panggilan <code>read() / write()</code> . <br><br>  Penting untuk dicatat bahwa permintaan <code>iocb</code> dieksekusi oleh kernel secara berurutan. <br><br>  Terlepas dari kenyataan bahwa Linux AIO tidak akan membantu kami dengan operasi asinkron, Linux AIO dapat digunakan untuk menggabungkan panggilan sistem ke dalam batch. <br><br>  Jika server web perlu mengirim dan menerima data dari ratusan koneksi jaringan, maka menggunakan <code>io_submit</code> mungkin ide yang bagus, karena menghindari ratusan panggilan kirim dan terima.  Ini akan meningkatkan kinerja - beralih dari ruang pengguna ke kernel dan sebaliknya tidak gratis, terutama setelah pengenalan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">langkah</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">langkah untuk memerangi Specter dan Meltdown</a> . <br><br><table><tbody><tr><td></td><td align="center">  <b>Satu buffer</b> <br></td><td align="center">  <b>Banyak buffer</b> <br></td></tr><tr><td>  Satu file deskriptor <br></td><td>  baca () <br></td><td>  readv () <br></td></tr><tr><td>  Penjelasan File Berganda <br></td><td>  io_mengirimkan + IOCB_CMD_PREAD <br></td><td>  io_mengirimkan + IOCB_CMD_PREADV <br></td></tr></tbody></table><br>  Untuk mengilustrasikan pengelompokan panggilan sistem ke dalam paket menggunakan <code>io_submit</code> mari kita menulis sebuah program kecil yang mengirim data dari satu koneksi TCP ke yang lain.  Dalam bentuknya yang paling sederhana (tanpa Linux AIO), tampilannya seperti ini: <br><br><pre> <code class="plaintext hljs">while True: d = sd1.read(4096) sd2.write(d)</code> </pre> <br>  Kami dapat mengekspresikan fungsionalitas yang sama melalui Linux AIO.  Kode dalam hal ini akan seperti ini: <br><br><pre> <code class="plaintext hljs">struct iocb cb[2] = {{.aio_fildes = sd2,                     .aio_lio_opcode = IOCB_CMD_PWRITE,                     .aio_buf = (uint64_t)&amp;buf[0],                     .aio_nbytes = 0},                    {.aio_fildes = sd1,                    .aio_lio_opcode = IOCB_CMD_PREAD,                    .aio_buf = (uint64_t)&amp;buf[0],                    .aio_nbytes = BUF_SZ}}; struct iocb *list_of_iocb[2] = {&amp;cb[0], &amp;cb[1]}; while(1) { r = io_submit(ctx, 2, list_of_iocb); struct io_event events[2] = {}; r = io_getevents(ctx, 2, 2, events, NULL); cb[0].aio_nbytes = events[1].res; }</code> </pre> <br>  Kode ini menambahkan dua pekerjaan ke <code>io_submit</code> : pertama permintaan tulis ke <code>sd2</code> , dan kemudian permintaan baca dari sd1.  Setelah membaca, kode memperbaiki ukuran buffer tulis dan mengulangi loop dari awal.  Ada satu trik: pertama kali menulis terjadi dengan buffer ukuran 0. Ini diperlukan karena kami memiliki kemampuan untuk menggabungkan tulis + baca dalam satu panggilan <code>io_submit</code> (tetapi tidak membaca + tulis). <br><br>  Apakah kode ini lebih cepat daripada <code>read()</code> biasa <code>read()</code> / <code>write()</code> ?  Belum.  Kedua versi menggunakan dua panggilan sistem: read + write dan io_submit + io_getevents.  Tapi, untungnya, kodenya bisa diperbaiki. <br><br><h2>  Menyingkirkan io_getevents </h2><br>  Saat runtime <code>io_setup()</code> kernel mengalokasikan beberapa halaman memori untuk proses tersebut.  Beginilah tampilan blok memori ini di / proc // maps: <br><br><pre> <code class="plaintext hljs">marek:~$ cat /proc/`pidof -s aio_passwd`/maps ... 7f7db8f60000-7f7db8f63000 rw-s 00000000 00:12 2314562     /[aio] (deleted) ...</code> </pre> <br>  Blok memori [aio] (12 Kb dalam kasus ini) dialokasikan <code>io_setup</code> .  Ini digunakan untuk buffer melingkar tempat acara disimpan.  Dalam kebanyakan kasus, tidak ada alasan untuk memanggil <code>io_getevents</code> - data penyelesaian acara dapat diperoleh dari buffer cincin tanpa perlu beralih ke mode kernel.  Ini adalah versi kode yang diperbaiki: <br><br><pre> <code class="plaintext hljs">int io_getevents(aio_context_t ctx, long min_nr, long max_nr,                struct io_event *events, struct timespec *timeout) {   int i = 0;   struct aio_ring *ring = (struct aio_ring*)ctx;   if (ring == NULL || ring-&gt;magic != AIO_RING_MAGIC) {       goto do_syscall;   }   while (i &lt; max_nr) {       unsigned head = ring-&gt;head;       if (head == ring-&gt;tail) {           /* There are no more completions */           break;       } else {           /* There is another completion to reap */           events[i] = ring-&gt;events[head];           read_barrier();           ring-&gt;head = (head + 1) % ring-&gt;nr;           i++;       }   }   if (i == 0 &amp;&amp; timeout != NULL &amp;&amp; timeout-&gt;tv_sec == 0 &amp;&amp; timeout-&gt;tv_nsec == 0) {       /* Requested non blocking operation. */       return 0;   }   if (i &amp;&amp; i &gt;= min_nr) {       return i;   } do_syscall:   return syscall(__NR_io_getevents, ctx, min_nr-i, max_nr-i, &amp;events[i], timeout); }</code> </pre> <br>  Versi lengkap kode tersedia <a href="">di GitHub</a> .  Antarmuka buffer cincin ini tidak terdokumentasi dengan baik, penulis mengadaptasi kode dari proyek <a href="">axboe / fio</a> . <br><br>  Setelah perubahan ini, versi kode kami menggunakan Linux AIO hanya membutuhkan satu panggilan sistem dalam satu lingkaran, yang membuatnya sedikit lebih cepat daripada kode asli menggunakan baca + tulis. <br><br><img src="https://habrastorage.org/webt/xq/er/7t/xqer7tve9zpg23gh2zfjjl_bb-i.jpeg"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kereta Foto Foto</a> CC / BY-SA / 2.0 <br><br><h2>  Alternatif epoll </h2><br>  Dengan tambahan IOCB_CMD_POLL ke kernel versi 4.18, menjadi mungkin untuk menggunakan <code>io_submit</code> sebagai pengganti select / poll / epoll.  Misalnya, kode ini akan mengharapkan data dari koneksi jaringan: <br><br><pre> <code class="plaintext hljs">struct iocb cb = {.aio_fildes = sd,                 .aio_lio_opcode = IOCB_CMD_POLL,                 .aio_buf = POLLIN}; struct iocb *list_of_iocb[1] = {&amp;cb}; r = io_submit(ctx, 1, list_of_iocb); r = io_getevents(ctx, 1, 1, events, NULL);</code> </pre><br>  <a href="">Kode lengkap</a> .  Ini adalah output strace-nya: <br><br><pre> <code class="plaintext hljs">io_submit(0x7fe44bddd000, 1, [{aio_lio_opcode=IOCB_CMD_POLL, aio_fildes=3}]) \   = 1 &lt;0.000015&gt; io_getevents(0x7fe44bddd000, 1, 1, [{data=0, obj=0x7ffef65c11a8, res=1, res2=0}], NULL) \   = 1 &lt;1.000377&gt;</code> </pre> <br>  Seperti yang Anda lihat, kali ini sinkronisasi tidak berfungsi: io_submit dieksekusi secara instan, dan <code>io_getevents</code> diblokir selama satu detik, menunggu data.  Ini dapat digunakan sebagai pengganti panggilan sistem <code>epoll_wait()</code> . <br><br>  Selain itu, bekerja dengan <code>epoll</code> biasanya membutuhkan penggunaan panggilan sistem epoll_ctl.  Dan pengembang aplikasi mencoba menghindari panggilan yang sering ke fungsi ini - untuk memahami alasannya, cukup <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">baca</a> flag EPOLLONESHOT dan EPOLLET <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di manual</a> .  Menggunakan io_submit untuk menanyakan koneksi, Anda dapat menghindari kesulitan ini dan panggilan sistem tambahan.  Cukup tambahkan koneksi ke vektor iocb, panggil io_submit sekali dan tunggu eksekusi.  Semuanya sangat sederhana. <br><br><h2>  Ringkasan </h2><br>  Dalam posting ini, kami membahas Linux AIO API.  API ini awalnya dirancang untuk bekerja dengan disk, tetapi juga berfungsi dengan koneksi jaringan.  Namun, tidak seperti panggilan read () + write () biasa, menggunakan io_submit memungkinkan Anda untuk mengelompokkan panggilan sistem dan dengan demikian meningkatkan kinerja. <br><br>  Dimulai dengan kernel versi 4.18, <code>io_submit  io_getevents</code> dalam hal koneksi jaringan dapat digunakan untuk acara dari formulir POLLIN dan POLLOUT.  Ini adalah alternatif untuk <code>epoll()</code> . <br><br>  Saya bisa membayangkan layanan jaringan yang hanya menggunakan <code>io_submit  io_getevents</code> daripada set standar baca, tulis, epoll_ctl dan epoll_wait.  Dalam hal ini, pengelompokan panggilan sistem di <code>io_submit</code> dapat memberikan keuntungan besar, server seperti itu akan jauh lebih cepat. <br><br>  Sayangnya, bahkan setelah perbaikan terbaru untuk Linux AIO API, diskusi tentang kegunaannya berlanjut.  Sudah diketahui bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Linus membencinya</a> : <br><br><blockquote>  "AIO adalah contoh mengerikan dari desain setinggi lutut, di mana alasan utamanya adalah:" orang lain yang kurang berbakat muncul dengan ini, jadi kami harus mematuhi kompatibilitas sehingga pengembang database (yang jarang berselera) dapat menggunakannya. "  Tapi AIO selalu sangat, sangat bengkok. " </blockquote><br>  Beberapa upaya telah dilakukan untuk membuat antarmuka yang lebih baik untuk pengelompokan panggilan dan sinkronisasi, tetapi mereka tidak memiliki visi yang sama.  Misalnya, <a href="">penambahan sendto (MSG_ZEROCOPY) baru-baru ini</a> memungkinkan untuk transfer data yang benar-benar tidak sinkron, tetapi tidak menyediakan untuk pengelompokan.  <code>io_submit</code> menyediakan pengelompokan, tetapi tidak sinkron.  Lebih buruk lagi - saat ini ada tiga cara untuk mengirimkan peristiwa asinkron di Linux: sinyal, <code>io_getevents</code> dan MSG_ERRQUEUE. <br><br>  Bagaimanapun, sangat bagus bahwa ada cara baru untuk mempercepat pekerjaan layanan jaringan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439972/">https://habr.com/ru/post/id439972/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439962/index.html">Kami bekerja dengan Atlassian Service Desk, kami mendapatkan hasil maksimal dari plug-in Riada Insight - laporan dari pertemuan Grup Pengguna Atlassian</a></li>
<li><a href="../id439964/index.html">Runc CVE-2019-5736 Kerentanan dalam Host</a></li>
<li><a href="../id439966/index.html">Pengurai sederhana untuk operasi aritmatika</a></li>
<li><a href="../id439968/index.html">Ruang Generasi dan Ruang Peluang</a></li>
<li><a href="../id439970/index.html">Laporkan masalah dan aksesibilitas Internet pada 2018-2019</a></li>
<li><a href="../id439974/index.html">Transformasi Agile Pribadi: Perjalanan Fleksibel ke Produktivitas</a></li>
<li><a href="../id439976/index.html">Apakah Node.js selalu lebih lambat dari Golang?</a></li>
<li><a href="../id439978/index.html">Learning Docker, Bagian 2: Istilah dan Konsep</a></li>
<li><a href="../id439980/index.html">Belajar Docker, Bagian 3: File Dockerfile</a></li>
<li><a href="../id439982/index.html">React Tutorial, Bagian 16: Fase Keempat Bekerja pada Aplikasi TODO, Pemrosesan Acara</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>