<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤰🏾 🗝️ 👽 Datenstrukturen für Spielprogrammierer: Massendaten 📇 👨‍🎤 ⛺️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jeder Programmierer profitiert von einem Verständnis der verschiedenen Datenstrukturen und der Analyse ihrer Leistung. In der Praxis habe ich mich jed...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Datenstrukturen für Spielprogrammierer: Massendaten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469861/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e7/1d7/bb3/7e71d7bb314eaffe2d54f349cc854a5f.png" alt="Bild"></div><br>  Jeder Programmierer profitiert von einem Verständnis der verschiedenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenstrukturen</a> und der Analyse ihrer Leistung.  In der Praxis habe ich mich jedoch nie für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AVL-Bäume</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">rot-schwarze Bäume</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Präfixbäume</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Überspringlisten</a> usw. als nützlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erwiesen</a> .  Ich verwende einige Datenstrukturen nur für einen bestimmten Algorithmus und für nichts anderes (zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Heaps</a> zum Implementieren einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prioritätswarteschlange</a> im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">A * -Pfad-Suchalgorithmus</a> ). <br><br>  In der täglichen Arbeit mache ich normalerweise mit überraschend wenigen Datenstrukturen.  Meistens sind sie für mich nützlich: <br><br><ul><li>  Shared Data Arrays (Massendaten) - eine Möglichkeit, eine große Anzahl von Objekten effektiv zu speichern. </li><li>  Schwache Referenzen (oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Handles</a> ) - eine Möglichkeit, auf Objekte in Massendaten zuzugreifen, ohne dass ein Programm abstürzt, wenn das Objekt gelöscht wird. </li><li>  Indizes sind eine Möglichkeit, schnell auf einzelne Teilmengen in Massendaten zuzugreifen. </li><li>  Arrays von Arrays sind eine Möglichkeit, Massendatenobjekte mit dynamischen Größen zu speichern. </li></ul><br>  Ich werde einige Artikel darüber widmen, wie ich normalerweise all diese Strukturen implementiere.  Beginnen wir mit den einfachsten und nützlichsten Massendaten. <a name="habracut"></a><br><br><h2>  Massendaten </h2><br>  Es gibt keinen gemeinsamen Begriff für dieses Konzept (oder ich weiß nichts darüber).  Ich nenne eine " <em>Massendaten</em> " jede große Sammlung ähnlicher Objekte.  Zum Beispiel könnte es sein: <br><br><ul><li>  Alle Kugeln im Spiel. </li><li>  Alle Bäume im Spiel. </li><li>  Alle Münzen im Spiel. </li></ul><br>  Wenn Sie Code auf einer höheren Abstraktionsebene schreiben, kann dies Folgendes sein: <br><br><ul><li>  Alle Entitäten im Spiel. </li><li>  Alle Maschen im Spiel. </li><li>  Alle Sounds im Spiel. </li></ul><br>  Normalerweise verfügt jedes System (Rendering, Sound, Animation, Physik usw.) in einem Spiel über verschiedene Arten von Objekten, die verfolgt werden müssen.  Für ein Soundsystem könnte es beispielsweise sein: <br><br><ul><li>  Alle Soundressourcen, <em>die</em> gespielt werden können. </li><li>  Alle Sounds werden <em>gerade</em> abgespielt. </li><li>  Alle Effekte (Dämpfung, Tonänderungen usw.) werden auf Sounds angewendet. </li></ul><br>  Bei Massendaten gehe ich von Folgendem aus: <br><br><ul><li>  Die Speicherreihenfolge der Objekte ist nicht wichtig.  Das heißt,  Wir nehmen das Array als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viele</a> Objekte wahr. </li><li> Jedes Objekt wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einfache Datenstruktur (POD-Struktur)</a> fester Größe dargestellt, die mit <code>memcpy()</code> verschoben oder dupliziert werden kann. </li></ul><br>  Natürlich können Sie sich Situationen einfallen lassen, in denen die Reihenfolge <em>wichtig ist</em> .  Wenn Objekte beispielsweise Elemente zum Rendern bezeichnen, müssen sie möglicherweise vor dem Rendern von vorne nach hinten sortiert werden, um das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Neuzeichnen</a> zu reduzieren. <br><br>  Ich glaube jedoch, dass es in den meisten Fällen vorzuziehen ist, die Daten so zu sortieren, <em>wie sie verwendet werden</em> , anstatt sie in einem sortierten Container wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">rot-schwarzen Bäumen</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">B-Bäumen zu</a> speichern.  Beispielsweise können wir die gerenderten Objekte von vorne nach hinten sortieren, bevor sie an den Renderer übergeben werden, oder die Dateien alphabetisch sortieren, bevor sie in einer Liste angezeigt werden.  Das Sortieren der Daten in jedem Frame mag kostspielig erscheinen, wird jedoch in vielen Fällen in <em>O (n)</em> mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Radix-Sortierung durchgeführt</a> . <br><br>  Da ich nur einfache Datenstrukturen verwende, bevorzuge ich C ++ - Objekte gegenüber C ++ - Objekten, da es einfacher ist, die Vorgänge im Speicher zu verstehen und ihre Leistung zu bewerten.  Es gibt jedoch Situationen, in denen Sie Daten in Massendaten speichern müssen, die keine feste Größe haben.  Zum Beispiel der Name oder die Liste der untergeordneten Objekte.  Ich werde über diese Fälle in einem separaten Beitrag sprechen, in dem wir uns „Arrays of Arrays“ ansehen.  Nehmen wir zunächst an, dass alle Objekte einfache Datenstrukturen mit fester Größe sind. <br><br>  So sehen beispielsweise Massendatenstrukturen für unser hypothetisches Soundsystem aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">resource_t</span></span> *resource; <span class="hljs-comment"><span class="hljs-comment">// Resource manager data uint64_t bytes; // Size of data uint64_t format; // Data format identifier } sound_resource_t; typedef struct { sound_resource_t *resource; // Resource that's playing uint64_t samples_played; // Number of samples played float volume; // Volume of playing sound } playing_sound_t; typedef struct { playing_sound_t *sound; // Faded sound float fade_from; // Volume to fade from float fade_to; // Volume to fade to double fade_from_ts; // Time to start fade double fade_to_ts; // Time to end fade } playing_fade_t;</span></span></code> </pre> <br>  Bei der Überlegung, wie Massendaten gespeichert werden sollen, müssen einige Ziele berücksichtigt werden: <br><br><ul><li>  Das Hinzufügen und Entfernen von Objekten sollte schnell gehen. </li><li>  Die Daten sollten sich in einer <strong>für das Caching geeigneten</strong> Form befinden, damit Sie sie schnell durchlaufen können, um das System zu aktualisieren. </li><li>  Es muss <strong>den Verknüpfungsmechanismus unterstützen</strong> - es muss eine Möglichkeit geben, Informationen <em>über</em> bestimmte Objekte in Massendaten zu übertragen.  Im obigen Beispiel sollte Fade in der Lage sein, anzugeben, welcher Ton gedämpft wird.  Im Beispiel habe ich die Links als Zeiger geschrieben, aber ihre Implementierung hängt davon ab, wie die Massendaten angeordnet sind. </li><li>  Daten müssen <strong>allokatorfreundlich sein</strong> - sie müssen mehrere große Speicherzuordnungen verwenden und dürfen keine einzelnen Objekte auf dem Heap zuordnen. </li></ul><br>  Die zwei einfachsten Möglichkeiten zur Darstellung von Massendaten sind ein statisches Array oder ein C ++ - Vektor: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Static array #define MAX_PLAYING_SOUNDS 1024 uint32_t num_playing_sounds; playing_sound_t playing_sounds[MAX_PLAYING_SOUNDS]; // C++ vector std::vector&lt;playing_sound_t&gt; playing_sounds;</span></span></code> </pre> <br>  Das Arbeiten mit einem Array ist äußerst einfach und kann für Sie problemlos funktionieren, wenn Sie genau wissen, wie viele Objekte in der Anwendung benötigt werden.  Wenn Sie dies <em>nicht wissen</em> , verschwenden Sie entweder Ihr Gedächtnis oder es gehen Ihnen die Objekte aus. <br><br>  Der Vektor <code>std::vector</code> ist ebenfalls eine sehr wertvolle und einfache Lösung, aber hier müssen Sie einige Aspekte berücksichtigen: <br><br><ul><li>  Die Standardimplementierung von <code>std::vector</code> aus Visual Studio ist im Debug-Modus aufgrund des Debuggens von Iteratoren langsam.  Sie sollten auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">_ITERATOR_DEBUG_LEVEL = 0 gesetzt sein</a> . </li><li>  Zum Erstellen und Zerstören von Objekten verwendet <code>std::vector</code> Konstruktoren und Destruktoren. In einigen Fällen können sie viel langsamer als <code>memcpy()</code> . </li><li>  <code>std::vector</code> viel schwieriger zu analysieren als die Implementierung eines einfachen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Stretchy Buffer“</a> . </li></ul><br>  Darüber hinaus unterstützen ohne zusätzliche Maßnahmen weder reguläre Arrays noch Vektoren Verweise auf einzelne Objekte.  Schauen wir uns dieses Thema sowie andere wichtige Entwurfsentscheidungen an, die bei der Erstellung des Massendatensystems eine Rolle spielen. <br><br><h2>  Entfernungsstrategie </h2><br>  Die erste wichtige Entscheidung: Was ist beim Löschen des Objekts zu tun? <code>a[i]</code> .  Hier sind drei Hauptoptionen: <br><br><ul><li>  Sie können alle nachfolgenden Elemente <code>a[i+1]</code> → <code>a[i]</code> , <code>a[i+2]</code> → <code>a[i+1]</code> usw. verschieben, um einen leeren Steckplatz zu schließen. </li><li>  Sie können das letzte Element des Arrays in einen leeren Steckplatz verschieben: <code>a[i] = a[n-1]</code> . </li><li>  Oder Sie können den Steckplatz leer lassen, indem Sie ein Loch im Array erstellen.  Dieses Loch kann später verwendet werden, um ein neues Objekt zu platzieren. </li></ul><br>  Die erste Option ist schrecklich - <em>O (n)</em> wird für die Bewegung all dieser Elemente ausgegeben.  Der einzige Vorteil der ersten Methode besteht darin, dass beim Sortieren des Arrays die Reihenfolge darin beibehalten wird.  Aber wie oben erwähnt, stört uns die Bestellung nicht.  Beachten Sie, dass genau dies passieren wird, wenn Sie <code>a.erase()</code> , um das <code>std::vector</code> Element zu entfernen! <br><br>  Die zweite Option wird oft als "Swap-and-Pop" bezeichnet.  Warum?  Wenn Sie einen C ++ - Vektor verwenden, wird diese Option normalerweise implementiert, indem Sie das zu löschende Element gegen das letzte austauschen und anschließend das letzte Element löschen oder löschen: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap(a[i], a[a.size() - <span class="hljs-number"><span class="hljs-number">1</span></span>]); a.pop_back();</code> </pre> <br>  Warum ist das alles notwendig?  Wenn wir in C ++ <code>a[i] = a[n-1]</code> <em>zuweisen</em> , müssen wir zuerst <code>a[i]</code> entfernen, indem wir seinen Destruktor aufrufen, und dann den Kopierkonstruktor aufrufen, um eine Kopie <code>a[n-1]</code> an Position <code>i</code> und zu erstellen Schließlich nennen wir den Destruktor <code>a[n-1]</code> wenn wir den Vektor verschieben.  Wenn der Kopierkonstruktor Speicher zuweist und Daten kopiert, kann dies ziemlich schlecht sein.  Wenn wir <code>std::swap</code> anstelle von Zuweisung verwenden, können wir nur mit den Konstruktoren verschieben und sollten keinen Speicher zuweisen. <br><br>  Aus diesem Grund bevorzuge C ++ einfache Datenstrukturen und C-Operationen. C ++ weist viele Leistungsprobleme auf, in die Sie geraten können, wenn Sie nicht wissen, was im Inneren vor sich geht.  In C ist der Swap-Löschvorgang sehr einfach: <br><br><pre> <code class="cpp hljs">a.data[i] = a.data[--an];</code> </pre> <br>  Bei Verwendung von Swap-and-Pop bleiben Objekte dicht gepackt.  Um ein neues Objekt zu platzieren, hängen Sie es einfach an das Ende des Arrays an. <br><br>  Wenn wir die Option "Mit Löchern" I verwenden, müssen wir beim Platzieren eines neuen Objekts zunächst prüfen, ob freie "Löcher" verwendet werden können.  Es lohnt sich, das Array nur dann zu vergrößern, wenn keine freien „Löcher“ vorhanden sind.  Andernfalls wächst das Objekt beim Löschen und Erstellen von Objekten auf unbestimmte Zeit. <br><br>  Sie können einen separaten <code>std::vector&lt;uint32_t&gt;</code> , um die Lochpositionen zu verfolgen. Es gibt jedoch eine bessere Lösung, für die kein zusätzlicher Speicher erforderlich ist. <br><br>  Da die Daten des Objekts im „Loch“ für nichts verwendet werden, können Sie damit einen Zeiger auf das nächste freie Loch speichern.  Somit bilden alle Löcher im Array eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einfach verbundene Liste</a> , und bei Bedarf können wir Elemente hinzufügen und daraus entfernen. <br><br>  Diese Art von Datenstruktur, in der nicht verwendeter Speicher zum Binden freier Elemente verwendet wird, wird normalerweise als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">freie Liste bezeichnet</a> . <br><br>  In einer herkömmlichen verknüpften Liste zeigt ein spezielles <em>Listenkopfelement</em> auf den ersten Knoten in der Liste, und das letzte Listenelement zeigt auf NULL, was das Ende der Liste bedeutet.  Stattdessen bevorzuge ich eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zirkuläre verknüpfte Liste</a> , in der die Überschrift nur ein spezielles Listenelement ist und das letzte Listenelement auf ein Überschriftenelement verweist: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffe/fe0/a6b/ffefe0a6b6bd621b9362e84486db65e1.jpg" width="100%"></div><br>  <i>Traditionelle und ringgebundene Listen.</i> <br><br>  Der Vorteil dieses Ansatzes besteht darin, dass der Code viel einfacher wird, indem die Anzahl der Sonderfälle am Anfang und Ende der Liste verringert wird. <br><br>  Beachten Sie, dass sich Zeiger auf Objekte bei jeder Neuverteilung des Vektors ändern, wenn Sie <code>std::vector</code> zum Speichern von Objekten verwenden.  Dies bedeutet, dass wir keine regulären Zeiger auf eine verknüpfte Liste verwenden können, da sich die Zeiger ständig ändern.  Um dieses Problem zu umgehen, können Sie Indizes als „Zeiger“ auf die verknüpfte Liste verwenden, da der Index auch bei der Neuverteilung des Arrays ständig auf einen bestimmten Slot verweist.  Wir werden im nächsten Abschnitt mehr über die Neuzuweisung sprechen. <br><br>  Sie können einem speziellen Element des Listentitels Platz zuweisen, indem Sie es immer im Array-Slot 0 speichern. <br><br>  Der Code sieht ungefähr so ​​aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// The objects that we want to store: typedef struct {...} object_t; // An item in the free list points to the next one. typedef struct { uint32_t next_free; } freelist_item_t; // Each item holds either the object data or the free list pointer. typedef union { object_t; freelist_item_t; } item_t; typedef struct { std::vector&lt;item_t&gt; items; } bulk_data_t; void delete_item(bulk_data_t *bd, uint32_t i) { // Add to the freelist, which is stored in slot 0. bd-&gt;items[i].next = bd-&gt;items[0].next; bd-&gt;items[0].next = i; } uint32_t allocate_slot(bulk_data_t *bd) { const uint32_t slot = bd-&gt;items[0].next; bd-&gt;items[0].next = bd-&gt;items[slot].next; // If the freelist is empty, slot will be 0, because the header // item will point to itself. if (slot) return slot; bd-&gt;items.resize(bd-&gt;items.size() + 1); return bd-&gt;items.size() - 1; }</span></span></code> </pre> <br>  Was ist die beste Entfernungsstrategie?  Verschieben Sie das letzte Element in einen leeren Steckplatz, stellen Sie sicher, dass das Array dicht gepackt ist, oder halten Sie alle Elemente an ihrem Platz, indem Sie anstelle des gelöschten Elements „Löcher“ im Array erstellen. <br><br>  Bei der Entscheidung müssen zwei Aspekte berücksichtigt werden: <br><br><ul><li>  Das Iterieren über ein dicht gepacktes Array ist schneller, da wir weniger Speicher umgehen und nicht zu viel Zeit damit verbringen müssen, leere Slots zu überspringen. </li><li>  Wenn wir ein dicht gepacktes Array verwenden, bewegen sich die Elemente.  Dies bedeutet, dass wir den Index eines Elements nicht als konstante Kennung für externe Verweise auf Elemente verwenden können.  Wir müssen jedem Element einen anderen Bezeichner zuweisen und die Nachschlagetabelle verwenden, um diese konstanten IDs mit den aktuellen Objektindizes abzugleichen.  Diese Nachschlagetabelle kann eine Hash-Tabelle oder ein <code>std::vector</code> mit Löchern sein, wie oben beschrieben (die zweite Option ist schneller).  Wie auch immer, wir benötigen zusätzlichen Speicher für diese Tabelle und einen zusätzlichen indirekten Schritt für Bezeichner. </li></ul><br>  Die Auswahl der besten Option hängt von Ihrem Projekt ab. <br><br>  Sie können sagen, dass das Speichern eines dicht gepackten Arrays besser ist, da Iterationen über alle Elemente (um das System zu aktualisieren) häufiger auftreten als das Abgleichen externer Links.  Andererseits können wir sagen, dass die Leistung eines „Arrays mit Löchern“ nur bei einer großen Anzahl von Löchern schlechter ist, und bei der Spieleentwicklung ist uns normalerweise die Leistung im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schlimmsten Fall wichtig</a> (wir möchten eine Bildrate von 60 Hz haben, selbst wenn die maximalen Operationen im Spiel ausgeführt werden). .  Im schlimmsten Fall haben wir die maximale Anzahl realer Objekte, und in diesem Fall <em>gibt es keine Löcher</em> im Array.  Löcher treten nur auf, wenn die Anzahl der Objekte abnimmt und wir einige dieser Objekte löschen. <br><br>  Es gibt auch Strategien, mit denen die Verarbeitung von Arrays mit vielen Löchern beschleunigt werden kann.  Zum Beispiel können wir die Länge kontinuierlicher Lochsequenzen verfolgen, um ganze Lochsequenzen gleichzeitig zu überspringen, anstatt Element für Element.  Da diese Daten nur für "Löcher" und nicht für gewöhnliche Elemente benötigt werden, können Sie sie zusammen mit dem Zeiger der Freigabeliste im nicht zugewiesenen Speicher von Objekten speichern und keinen zusätzlichen Speicher verschwenden. <br><br>  Wenn Sie den Code für schnelle Iterationen nicht optimieren müssen, ist es meiner Meinung nach wahrscheinlich am besten, die Option "Array mit Löchern" zu verwenden.  Es ist einfacher, erfordert keine zusätzlichen Suchstrukturen und Sie können den Index des Objekts als ID verwenden, was sehr praktisch ist.  Darüber hinaus werden durch das Fehlen beweglicher Objekte mögliche Fehler beseitigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/781/6e3/91f/7816e391f0b8c68dede02d95dffa304f.jpg" width="100%"></div><br>  <i>Strategien zum Entfernen von Massendaten.</i> <br><br><h2>  Schwache Zeiger </h2><br>  Als Hinweis möchte ich sagen, dass es einfach ist, die Unterstützung für "schwache Zeiger" oder "Deskriptoren" für Massendatenobjekte zu implementieren. <br><br>  <em>Ein schwacher Zeiger</em> ist ein Verweis auf ein Objekt, der auf irgendeine Weise feststellen kann, dass das Objekt, auf das er verweist, gelöscht wurde.  Bei schwachen Zeigern ist es praktisch, dass Sie damit Objekte löschen können, ohne sich Gedanken darüber machen zu müssen, wer auf sie verweisen kann.  Ohne schwache Zeiger zum Entfernen eines Objekts müssten wir nach jedem einzelnen Link suchen und ihn für ungültig erklären.  Dies kann besonders schwierig sein, wenn die Links im Skriptcode, auf anderen Computern im Netzwerk usw. gespeichert sind. <br><br>  Denken Sie daran, dass wir bereits eine ID haben, die <em>vorhandene</em> Objekte eindeutig identifiziert.  Bei der Option "mit Löchern" ist diese ID einfach der Index des Elements (da sich die Elemente niemals bewegen).  Bei dicht gepackten Arrays ist dieser Objektindex ein Datensatz im <em>Sucharray</em> . <br><br>  Die ID selbst kann nicht als schwacher Zeiger verwendet werden, da IDs wiederverwendet werden können.  Wenn ein Element gelöscht und ein neues Element im selben Slot erstellt wird, können wir es nicht allein anhand der ID ermitteln.  Um einen schwachen Zeiger zu erhalten, müssen Sie die ID mit dem <code>generation</code> kombinieren: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> generation; } <span class="hljs-keyword"><span class="hljs-keyword">weak_pointer_t</span></span>;</code> </pre> <br>  Das <code>generation</code> ist ein Feld in der Objektstruktur, das verfolgt, wie oft der Steckplatz im Massendatenarray wiederverwendet wurde.  (Bei dichtem Packen wird nachverfolgt, wie oft der Steckplatz im <em>Suchfeld</em> wiederverwendet wurde.) <br><br>  Wenn Sie einen Artikel löschen, erhöhen wir die Generierungsnummer in seinem Steckplatz.  Um zu überprüfen, ob der schwache Zeiger noch gültig ist, prüfen wir, ob die <code>generation</code> in der Struktur des schwachen Zeigers mit der Generierung des durch seine <code>id</code> angegebenen Slots übereinstimmt.  Wenn sie übereinstimmen, ist das Quellobjekt, auf das wir verweisen, noch vorhanden.  Wenn nicht, bedeutet dies, dass es gelöscht wird und der Steckplatz entweder auf der Versionsliste steht oder wiederverwendet wurde. <br><br>  Beachten Sie, dass das <code>generation</code> sowohl für Löcher als auch für vorhandene Objekte erforderlich ist und Sie es außerhalb der Union speichern müssen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> generation; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">object_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">freelist_item_t</span></span>; }; } <span class="hljs-keyword"><span class="hljs-keyword">item_t</span></span>;</code> </pre> <br><h2>  Vertriebsstrategie </h2><br>  Wenn Sie <code>std::vector</code> zum Speichern von Elementdaten verwenden, wird das gesamte Array von Elementen neu verteilt, wenn das Array voll ist und vergrößert werden muss.  Vorhandene Elemente werden in das neue Array kopiert. <br><br>  <code>std::vector</code> wächst <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>geometrisch</em></a> .  Dies bedeutet, dass jedes Mal, wenn ein Vektor erhöht werden muss, die Anzahl der verteilten Elemente mit einem Faktor multipliziert wird (normalerweise mit × 2).  Das geometrische (exponentielle) Wachstum ist wichtig, da es die Kosten für die Erhöhung des Arrays konstant hält. <br><br>  Bei der Neuverteilung des Arrays müssen alle Elemente verschoben werden, was <em>O (n)</em> erfordert.  Wenn das Array jedoch wächst, fügen wir Platz für weitere <em>n</em> Elemente hinzu, da wir die Größe verdoppeln.  Dies bedeutet, dass wir das Array erst wieder vergrößern müssen, wenn wir <em>n</em> weitere Elemente hinzufügen.  Das heißt, die Erhöhungskosten sind gleich <em>O (n)</em> , aber wir führen sie nur * n (n) * zum n-ten Mal des Schreibens in das Array aus, dh die Kosten für das Schreiben eines Elements betragen im Durchschnitt <em>O (n) / O (n) = O (1)</em> . <br><br>  Die Kosten für die Erfassung eines Artikels werden als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>amortisierte Konstante bezeichnet</em></a> . Wenn Sie alle ausgeführten Datensätze mitteln, werden die Kosten festgelegt.  Wir sollten jedoch nicht vergessen, dass sich die Kosten vor dem Durchschnitt als sehr krampfhaft herausstellen.  Nach jedem <em>O (n)</em> -Datensatz erhalten wir einen Peak der Höhe <em>O (n)</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d0/331/5be/1d03315be5a0c1ad8096ac05f11c7893.jpg" width="100%"></div><br>  <i>Die Kosten für das Schreiben in <code>std::vector</code> .</i> <br><br>  Mal sehen, was passiert, wenn wir kein geometrisches Wachstum verwenden.  Angenommen, anstatt den Speicher während des Wachstums zu verdoppeln, fügen wir einfach weitere 128 Slots hinzu.  Das Verschieben alter Daten kostet uns immer noch <em>O (n)</em> , aber jetzt müssen wir dies alle 128 hinzugefügten Elemente tun, dh die durchschnittlichen Kosten betragen jetzt <em>O (n) / O (128) = O (n)</em> .  Die Kosten für das Schreiben eines Elements in ein Array sind proportional zur Größe des Arrays. Wenn das Array also groß wird, beginnt es mit einer Schildkrötengeschwindigkeit zu arbeiten.  Ups! <br><br>  Die Verteilungsstrategie <code>std::vector</code> ist eine gute Standardoption, die in den meisten Fällen gut funktioniert, jedoch einige Probleme aufweist: <br><br><ul><li>  Amortized Constant ist für Echtzeitsoftware nicht gut geeignet.  Wenn Sie ein sehr großes Array haben, z. B. Hunderte Millionen Elemente, kann das Erhöhen dieses Arrays und das Verschieben aller Elemente zu einer spürbaren Verlangsamung der Bildrate führen.  Dies ist aus demselben Grund problematisch, aus dem die Speicherbereinigung in Spielen problematisch ist.  Es spielt keine Rolle, wie niedrig die durchschnittlichen Kosten sind, wenn in einigen Frames die Kosten steigen können, was zu Spielfehlern führt. </li><li>  In ähnlicher Weise kann diese Zuordnungsstrategie bei großen Arrays viel Speicher verschwenden.  Nehmen wir an, wir haben ein Array von 16 Millionen Elementen und müssen ein weiteres darin schreiben.  Dadurch wächst das Array auf 32 Millionen.  Jetzt haben wir 16 Millionen Elemente im Array, die wir nicht verwenden.  Für eine Plattform mit wenig Speicher ist dies viel. </li><li>  Schließlich verschiebt die Neuzuweisung Objekte im Speicher, wodurch alle Zeiger auf Objekte ungültig werden.  Dies kann eine Quelle von Fehlern sein, die schwer zu verfolgen sind. </li></ul><br>  Der folgende Code ist ein Beispiel für Fehler, die beim Verschieben von Objekten auftreten können: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Create two items and return the sum of their costs. float f(bulk_data_t *bd) { const uint32_t slot_1 = allocate_slot(bd); item_t *item_1 = &amp;bd-&gt;items[slot_1]; const uint32_t slot_2 = allocate_slot(bd); item_t *item_2 = &amp;bd-&gt;items[slot_2]; return item_1-&gt;cost + item_2-&gt;cost; }</span></span></code> </pre> <br>  Das Problem hierbei ist, dass die Funktion <code>allocate_slot()</code> möglicherweise das Array neu verteilen muss, um Platz für <code>item_2</code> zu schaffen.  In diesem Fall wird <code>item_1</code> in den Speicher verschoben und der Zeiger auf <code>item_1</code> ist nicht mehr gültig.  In diesem speziellen Fall können wir den Fehler beseitigen, indem wir das Zuweisungselement_1 <code>item_1</code> . Ähnliche Fehler können jedoch unmerklicher auftreten.  Persönlich haben sie mich oft gebissen. <br><br>  Eine solche Situation ist perfide durch die Tatsache, dass der Fehler nur dann <code>slot_2</code> , wenn das Array genau zum Zeitpunkt der <code>slot_2</code> .  Das Programm kann lange Zeit korrekt funktionieren, bis sich das Verteilungsmuster ändert. Danach funktioniert der Fehler. <br><br>  All diese Probleme können mit einer anderen Vertriebsstrategie gelöst werden.  Hier sind einige der Optionen: <br><br><ul><li>       : 16, 32, 64, …,  <em></em>     . ,  16     ,  32   ,  .…     ,         <code>std::vector</code> . </li><li>           ,     .       ,       .               . ,           <em>O(n)</em>  <code>push()</code> ,        . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">       </a> ,      ,   ,     ,   . </li></ul><br> ,       .   ,   -       ,      ,       .      ,      ,          . <br><br>         ,      —       ?    ,       . ,     16  ,      16 ,       .   ,            ,           50 %.        . <br><br>   ,         <em> </em> ,           ,       .          *16 K * n*,  <em>n</em> —    bulk data  ,    ,        (      ). <br><br>        . -,         ,    <code>blocks\[i / elements_per_block\][i % elements_per_block]</code> . -,        ,      (heap allocator),   . <br><br>    ,         « »,  -       <code>std::vector</code> ,     ,    .         ,       ,          . <br><br> ,         ,     ID          .    ,        ,    .   ,   64  ,      32  (4   —  ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98e/f31/c3d/98ef31c3d3388db45f0897c9a390ce5d.jpg" width="100%"></div><br> <i> </i> <br><br><h2>      </h2><br>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> (Array of Structures, AoS)  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> (Structure of Arrays, SoA).     . ,      ,      , ,   : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> pos; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> vel; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> col; } <span class="hljs-keyword"><span class="hljs-keyword">particle_t</span></span>;</code> </pre> <br>           struct  .      « ».  : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> num_particles; <span class="hljs-keyword"><span class="hljs-keyword">particle_t</span></span> *particles;</code> </pre> <br> ,          . <br><br>     (SoA)        struct: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> num_particles; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *t; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> *pos; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> *vel; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> *col; } particles;</code> </pre> <br>   ,     ,  <code>vec3_t</code>     struct: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> num_particles; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *t; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *pos_x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *pos_y; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *pos_z; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *vel_x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *vel_y; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *vel_z; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *col_r; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *col_g; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *col_b; } particles;</code> </pre> <br>     ,     AoS,      ?       : <br><br><ul><li>       . ,  <code>tick()</code>    <code>t</code> .  <code>simulate_physics()</code>    <code>pos</code>  <code>vel</code> .   SoA       struct.   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> (     ),      . ,  <code>tick()</code>    1/10  ,  ,    10 . </li><li>  SoA        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SIMD</a>  .     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FPU</a> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AVX</a>       float  ,     8 . </li></ul><br>   ,     <code>tick()</code>   80 ?  Nein.      10 ,      ,      , SIMD      . <br><br>   SoA: <br><br><ul><li>   . </li><li>    ,           . </li><li>           <code>particle_t *</code> ,         .      . </li><li>           ,            </li><li>             ( ),  <em></em>   .     <em>  </em> ,     . </li></ul><br>    ,      ,    struct   ,        VM (       ). -    10  struct       .   8- -,   ,          .  Ups! <br><br>       —      SIMD.     : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> num_particles; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> position_x[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> position_y[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> position_z[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> velocity_x[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> velocity_y[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> velocity_z[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> color_r[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> color_g[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> color_b[<span class="hljs-number"><span class="hljs-number">8</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">eight_particles_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">eight_particles_t</span></span> *particles;</code> </pre> <br>     -    SIMD-     ,                  -,   .      ,            . <br><br>     <code>tick()</code>  32 ,  288 ,  32   ..  ,      10- ,       <code>t</code> . -, -    64 ,      ,     ,   5 .    ,    ,       -,   100%     . <br><br>    ,     . ,      <code>[16]</code> ,    float  - . ,       ,        ,   : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df8/7a2/558/df87a25586d4afb93a536585a84defef.png" width="100%"></div><br> <i>AoS  SoA.</i> <br><br>    ,  SoA —      « »,      SIMD     ,         (       «»). <br><br>   SIMD-  «»  ,    ,   ,    «» . ,   ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">     </a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ,  .        <code>next</code>     ,   SIMD-  .      struct. <br><br>       ,      ,        ,    struct  .       ,  ,     . <br><br>  AoS  SoA,  ,              .      «»     AoS    SoA   ,   SIMD-, ,    .              . <br><br>       —    AoS     SoA   - . ,        AoS       SoA,   ,       AoS ( ).        ,     ,       . <br><br> ,        « ».    16-   ,    SoA,      .       scratch buffer  16  . <br><br><h2>  Fazit </h2><br>        ,  « »    bulk data     : <br><br><blockquote>    «»   ,         VM (  ),       ( 16    ,     ). </blockquote><br>  ,        : <br><br><blockquote>     ,   8   SIMD         VM      . </blockquote><br>         . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469861/">https://habr.com/ru/post/de469861/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469837/index.html">Erstes Flutter-Treffen in St. Petersburg: Videoberichte</a></li>
<li><a href="../de469839/index.html">Sicherheitsanfälligkeit in Pikabu-Spam</a></li>
<li><a href="../de469843/index.html">"Wo sind diese jungen Punks, die uns vom Erdboden abwischen werden?"</a></li>
<li><a href="../de469849/index.html">Das Spiel „Attack 51%“: Schreiben eines einfachen eigenständigen Spiels auf der Obyte-Plattform</a></li>
<li><a href="../de469855/index.html">Gradle + LLVM</a></li>
<li><a href="../de469867/index.html">Wie wird daraus ein Schüler (und was haben Brettspiele damit zu tun)</a></li>
<li><a href="../de469871/index.html">Als Tastaturen Tische waren</a></li>
<li><a href="../de469875/index.html">So schützen Sie Ihre Passwörter im Jahr 2019</a></li>
<li><a href="../de469877/index.html">Oh diese Newtonsche Methode</a></li>
<li><a href="../de469879/index.html">Doppel-VPN mit einem Klick. So teilen Sie einfach die IP-Adresse eines Ein- und Ausstiegspunkts</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>