<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∞üèæ üóùÔ∏è üëΩ Datenstrukturen f√ºr Spielprogrammierer: Massendaten üìá üë®‚Äçüé§ ‚õ∫Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jeder Programmierer profitiert von einem Verst√§ndnis der verschiedenen Datenstrukturen und der Analyse ihrer Leistung. In der Praxis habe ich mich jed...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Datenstrukturen f√ºr Spielprogrammierer: Massendaten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469861/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e7/1d7/bb3/7e71d7bb314eaffe2d54f349cc854a5f.png" alt="Bild"></div><br>  Jeder Programmierer profitiert von einem Verst√§ndnis der verschiedenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenstrukturen</a> und der Analyse ihrer Leistung.  In der Praxis habe ich mich jedoch nie f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AVL-B√§ume</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">rot-schwarze B√§ume</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pr√§fixb√§ume</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úberspringlisten</a> usw. als n√ºtzlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erwiesen</a> .  Ich verwende einige Datenstrukturen nur f√ºr einen bestimmten Algorithmus und f√ºr nichts anderes (zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Heaps</a> zum Implementieren einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Priorit√§tswarteschlange</a> im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">A * -Pfad-Suchalgorithmus</a> ). <br><br>  In der t√§glichen Arbeit mache ich normalerweise mit √ºberraschend wenigen Datenstrukturen.  Meistens sind sie f√ºr mich n√ºtzlich: <br><br><ul><li>  Shared Data Arrays (Massendaten) - eine M√∂glichkeit, eine gro√üe Anzahl von Objekten effektiv zu speichern. </li><li>  Schwache Referenzen (oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Handles</a> ) - eine M√∂glichkeit, auf Objekte in Massendaten zuzugreifen, ohne dass ein Programm abst√ºrzt, wenn das Objekt gel√∂scht wird. </li><li>  Indizes sind eine M√∂glichkeit, schnell auf einzelne Teilmengen in Massendaten zuzugreifen. </li><li>  Arrays von Arrays sind eine M√∂glichkeit, Massendatenobjekte mit dynamischen Gr√∂√üen zu speichern. </li></ul><br>  Ich werde einige Artikel dar√ºber widmen, wie ich normalerweise all diese Strukturen implementiere.  Beginnen wir mit den einfachsten und n√ºtzlichsten Massendaten. <a name="habracut"></a><br><br><h2>  Massendaten </h2><br>  Es gibt keinen gemeinsamen Begriff f√ºr dieses Konzept (oder ich wei√ü nichts dar√ºber).  Ich nenne eine " <em>Massendaten</em> " jede gro√üe Sammlung √§hnlicher Objekte.  Zum Beispiel k√∂nnte es sein: <br><br><ul><li>  Alle Kugeln im Spiel. </li><li>  Alle B√§ume im Spiel. </li><li>  Alle M√ºnzen im Spiel. </li></ul><br>  Wenn Sie Code auf einer h√∂heren Abstraktionsebene schreiben, kann dies Folgendes sein: <br><br><ul><li>  Alle Entit√§ten im Spiel. </li><li>  Alle Maschen im Spiel. </li><li>  Alle Sounds im Spiel. </li></ul><br>  Normalerweise verf√ºgt jedes System (Rendering, Sound, Animation, Physik usw.) in einem Spiel √ºber verschiedene Arten von Objekten, die verfolgt werden m√ºssen.  F√ºr ein Soundsystem k√∂nnte es beispielsweise sein: <br><br><ul><li>  Alle Soundressourcen, <em>die</em> gespielt werden k√∂nnen. </li><li>  Alle Sounds werden <em>gerade</em> abgespielt. </li><li>  Alle Effekte (D√§mpfung, Ton√§nderungen usw.) werden auf Sounds angewendet. </li></ul><br>  Bei Massendaten gehe ich von Folgendem aus: <br><br><ul><li>  Die Speicherreihenfolge der Objekte ist nicht wichtig.  Das hei√üt,  Wir nehmen das Array als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viele</a> Objekte wahr. </li><li> Jedes Objekt wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einfache Datenstruktur (POD-Struktur)</a> fester Gr√∂√üe dargestellt, die mit <code>memcpy()</code> verschoben oder dupliziert werden kann. </li></ul><br>  Nat√ºrlich k√∂nnen Sie sich Situationen einfallen lassen, in denen die Reihenfolge <em>wichtig ist</em> .  Wenn Objekte beispielsweise Elemente zum Rendern bezeichnen, m√ºssen sie m√∂glicherweise vor dem Rendern von vorne nach hinten sortiert werden, um das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Neuzeichnen</a> zu reduzieren. <br><br>  Ich glaube jedoch, dass es in den meisten F√§llen vorzuziehen ist, die Daten so zu sortieren, <em>wie sie verwendet werden</em> , anstatt sie in einem sortierten Container wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">rot-schwarzen B√§umen</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">B-B√§umen zu</a> speichern.  Beispielsweise k√∂nnen wir die gerenderten Objekte von vorne nach hinten sortieren, bevor sie an den Renderer √ºbergeben werden, oder die Dateien alphabetisch sortieren, bevor sie in einer Liste angezeigt werden.  Das Sortieren der Daten in jedem Frame mag kostspielig erscheinen, wird jedoch in vielen F√§llen in <em>O (n)</em> mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Radix-Sortierung durchgef√ºhrt</a> . <br><br>  Da ich nur einfache Datenstrukturen verwende, bevorzuge ich C ++ - Objekte gegen√ºber C ++ - Objekten, da es einfacher ist, die Vorg√§nge im Speicher zu verstehen und ihre Leistung zu bewerten.  Es gibt jedoch Situationen, in denen Sie Daten in Massendaten speichern m√ºssen, die keine feste Gr√∂√üe haben.  Zum Beispiel der Name oder die Liste der untergeordneten Objekte.  Ich werde √ºber diese F√§lle in einem separaten Beitrag sprechen, in dem wir uns ‚ÄûArrays of Arrays‚Äú ansehen.  Nehmen wir zun√§chst an, dass alle Objekte einfache Datenstrukturen mit fester Gr√∂√üe sind. <br><br>  So sehen beispielsweise Massendatenstrukturen f√ºr unser hypothetisches Soundsystem aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">resource_t</span></span> *resource; <span class="hljs-comment"><span class="hljs-comment">// Resource manager data uint64_t bytes; // Size of data uint64_t format; // Data format identifier } sound_resource_t; typedef struct { sound_resource_t *resource; // Resource that's playing uint64_t samples_played; // Number of samples played float volume; // Volume of playing sound } playing_sound_t; typedef struct { playing_sound_t *sound; // Faded sound float fade_from; // Volume to fade from float fade_to; // Volume to fade to double fade_from_ts; // Time to start fade double fade_to_ts; // Time to end fade } playing_fade_t;</span></span></code> </pre> <br>  Bei der √úberlegung, wie Massendaten gespeichert werden sollen, m√ºssen einige Ziele ber√ºcksichtigt werden: <br><br><ul><li>  Das Hinzuf√ºgen und Entfernen von Objekten sollte schnell gehen. </li><li>  Die Daten sollten sich in einer <strong>f√ºr das Caching geeigneten</strong> Form befinden, damit Sie sie schnell durchlaufen k√∂nnen, um das System zu aktualisieren. </li><li>  Es muss <strong>den Verkn√ºpfungsmechanismus unterst√ºtzen</strong> - es muss eine M√∂glichkeit geben, Informationen <em>√ºber</em> bestimmte Objekte in Massendaten zu √ºbertragen.  Im obigen Beispiel sollte Fade in der Lage sein, anzugeben, welcher Ton ged√§mpft wird.  Im Beispiel habe ich die Links als Zeiger geschrieben, aber ihre Implementierung h√§ngt davon ab, wie die Massendaten angeordnet sind. </li><li>  Daten m√ºssen <strong>allokatorfreundlich sein</strong> - sie m√ºssen mehrere gro√üe Speicherzuordnungen verwenden und d√ºrfen keine einzelnen Objekte auf dem Heap zuordnen. </li></ul><br>  Die zwei einfachsten M√∂glichkeiten zur Darstellung von Massendaten sind ein statisches Array oder ein C ++ - Vektor: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Static array #define MAX_PLAYING_SOUNDS 1024 uint32_t num_playing_sounds; playing_sound_t playing_sounds[MAX_PLAYING_SOUNDS]; // C++ vector std::vector&lt;playing_sound_t&gt; playing_sounds;</span></span></code> </pre> <br>  Das Arbeiten mit einem Array ist √§u√üerst einfach und kann f√ºr Sie problemlos funktionieren, wenn Sie genau wissen, wie viele Objekte in der Anwendung ben√∂tigt werden.  Wenn Sie dies <em>nicht wissen</em> , verschwenden Sie entweder Ihr Ged√§chtnis oder es gehen Ihnen die Objekte aus. <br><br>  Der Vektor <code>std::vector</code> ist ebenfalls eine sehr wertvolle und einfache L√∂sung, aber hier m√ºssen Sie einige Aspekte ber√ºcksichtigen: <br><br><ul><li>  Die Standardimplementierung von <code>std::vector</code> aus Visual Studio ist im Debug-Modus aufgrund des Debuggens von Iteratoren langsam.  Sie sollten auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">_ITERATOR_DEBUG_LEVEL = 0 gesetzt sein</a> . </li><li>  Zum Erstellen und Zerst√∂ren von Objekten verwendet <code>std::vector</code> Konstruktoren und Destruktoren. In einigen F√§llen k√∂nnen sie viel langsamer als <code>memcpy()</code> . </li><li>  <code>std::vector</code> viel schwieriger zu analysieren als die Implementierung eines einfachen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûStretchy Buffer‚Äú</a> . </li></ul><br>  Dar√ºber hinaus unterst√ºtzen ohne zus√§tzliche Ma√ünahmen weder regul√§re Arrays noch Vektoren Verweise auf einzelne Objekte.  Schauen wir uns dieses Thema sowie andere wichtige Entwurfsentscheidungen an, die bei der Erstellung des Massendatensystems eine Rolle spielen. <br><br><h2>  Entfernungsstrategie </h2><br>  Die erste wichtige Entscheidung: Was ist beim L√∂schen des Objekts zu tun? <code>a[i]</code> .  Hier sind drei Hauptoptionen: <br><br><ul><li>  Sie k√∂nnen alle nachfolgenden Elemente <code>a[i+1]</code> ‚Üí <code>a[i]</code> , <code>a[i+2]</code> ‚Üí <code>a[i+1]</code> usw. verschieben, um einen leeren Steckplatz zu schlie√üen. </li><li>  Sie k√∂nnen das letzte Element des Arrays in einen leeren Steckplatz verschieben: <code>a[i] = a[n-1]</code> . </li><li>  Oder Sie k√∂nnen den Steckplatz leer lassen, indem Sie ein Loch im Array erstellen.  Dieses Loch kann sp√§ter verwendet werden, um ein neues Objekt zu platzieren. </li></ul><br>  Die erste Option ist schrecklich - <em>O (n)</em> wird f√ºr die Bewegung all dieser Elemente ausgegeben.  Der einzige Vorteil der ersten Methode besteht darin, dass beim Sortieren des Arrays die Reihenfolge darin beibehalten wird.  Aber wie oben erw√§hnt, st√∂rt uns die Bestellung nicht.  Beachten Sie, dass genau dies passieren wird, wenn Sie <code>a.erase()</code> , um das <code>std::vector</code> Element zu entfernen! <br><br>  Die zweite Option wird oft als "Swap-and-Pop" bezeichnet.  Warum?  Wenn Sie einen C ++ - Vektor verwenden, wird diese Option normalerweise implementiert, indem Sie das zu l√∂schende Element gegen das letzte austauschen und anschlie√üend das letzte Element l√∂schen oder l√∂schen: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap(a[i], a[a.size() - <span class="hljs-number"><span class="hljs-number">1</span></span>]); a.pop_back();</code> </pre> <br>  Warum ist das alles notwendig?  Wenn wir in C ++ <code>a[i] = a[n-1]</code> <em>zuweisen</em> , m√ºssen wir zuerst <code>a[i]</code> entfernen, indem wir seinen Destruktor aufrufen, und dann den Kopierkonstruktor aufrufen, um eine Kopie <code>a[n-1]</code> an Position <code>i</code> und zu erstellen Schlie√ülich nennen wir den Destruktor <code>a[n-1]</code> wenn wir den Vektor verschieben.  Wenn der Kopierkonstruktor Speicher zuweist und Daten kopiert, kann dies ziemlich schlecht sein.  Wenn wir <code>std::swap</code> anstelle von Zuweisung verwenden, k√∂nnen wir nur mit den Konstruktoren verschieben und sollten keinen Speicher zuweisen. <br><br>  Aus diesem Grund bevorzuge C ++ einfache Datenstrukturen und C-Operationen. C ++ weist viele Leistungsprobleme auf, in die Sie geraten k√∂nnen, wenn Sie nicht wissen, was im Inneren vor sich geht.  In C ist der Swap-L√∂schvorgang sehr einfach: <br><br><pre> <code class="cpp hljs">a.data[i] = a.data[--an];</code> </pre> <br>  Bei Verwendung von Swap-and-Pop bleiben Objekte dicht gepackt.  Um ein neues Objekt zu platzieren, h√§ngen Sie es einfach an das Ende des Arrays an. <br><br>  Wenn wir die Option "Mit L√∂chern" I verwenden, m√ºssen wir beim Platzieren eines neuen Objekts zun√§chst pr√ºfen, ob freie "L√∂cher" verwendet werden k√∂nnen.  Es lohnt sich, das Array nur dann zu vergr√∂√üern, wenn keine freien ‚ÄûL√∂cher‚Äú vorhanden sind.  Andernfalls w√§chst das Objekt beim L√∂schen und Erstellen von Objekten auf unbestimmte Zeit. <br><br>  Sie k√∂nnen einen separaten <code>std::vector&lt;uint32_t&gt;</code> , um die Lochpositionen zu verfolgen. Es gibt jedoch eine bessere L√∂sung, f√ºr die kein zus√§tzlicher Speicher erforderlich ist. <br><br>  Da die Daten des Objekts im ‚ÄûLoch‚Äú f√ºr nichts verwendet werden, k√∂nnen Sie damit einen Zeiger auf das n√§chste freie Loch speichern.  Somit bilden alle L√∂cher im Array eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einfach verbundene Liste</a> , und bei Bedarf k√∂nnen wir Elemente hinzuf√ºgen und daraus entfernen. <br><br>  Diese Art von Datenstruktur, in der nicht verwendeter Speicher zum Binden freier Elemente verwendet wird, wird normalerweise als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">freie Liste bezeichnet</a> . <br><br>  In einer herk√∂mmlichen verkn√ºpften Liste zeigt ein spezielles <em>Listenkopfelement</em> auf den ersten Knoten in der Liste, und das letzte Listenelement zeigt auf NULL, was das Ende der Liste bedeutet.  Stattdessen bevorzuge ich eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zirkul√§re verkn√ºpfte Liste</a> , in der die √úberschrift nur ein spezielles Listenelement ist und das letzte Listenelement auf ein √úberschriftenelement verweist: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffe/fe0/a6b/ffefe0a6b6bd621b9362e84486db65e1.jpg" width="100%"></div><br>  <i>Traditionelle und ringgebundene Listen.</i> <br><br>  Der Vorteil dieses Ansatzes besteht darin, dass der Code viel einfacher wird, indem die Anzahl der Sonderf√§lle am Anfang und Ende der Liste verringert wird. <br><br>  Beachten Sie, dass sich Zeiger auf Objekte bei jeder Neuverteilung des Vektors √§ndern, wenn Sie <code>std::vector</code> zum Speichern von Objekten verwenden.  Dies bedeutet, dass wir keine regul√§ren Zeiger auf eine verkn√ºpfte Liste verwenden k√∂nnen, da sich die Zeiger st√§ndig √§ndern.  Um dieses Problem zu umgehen, k√∂nnen Sie Indizes als ‚ÄûZeiger‚Äú auf die verkn√ºpfte Liste verwenden, da der Index auch bei der Neuverteilung des Arrays st√§ndig auf einen bestimmten Slot verweist.  Wir werden im n√§chsten Abschnitt mehr √ºber die Neuzuweisung sprechen. <br><br>  Sie k√∂nnen einem speziellen Element des Listentitels Platz zuweisen, indem Sie es immer im Array-Slot 0 speichern. <br><br>  Der Code sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// The objects that we want to store: typedef struct {...} object_t; // An item in the free list points to the next one. typedef struct { uint32_t next_free; } freelist_item_t; // Each item holds either the object data or the free list pointer. typedef union { object_t; freelist_item_t; } item_t; typedef struct { std::vector&lt;item_t&gt; items; } bulk_data_t; void delete_item(bulk_data_t *bd, uint32_t i) { // Add to the freelist, which is stored in slot 0. bd-&gt;items[i].next = bd-&gt;items[0].next; bd-&gt;items[0].next = i; } uint32_t allocate_slot(bulk_data_t *bd) { const uint32_t slot = bd-&gt;items[0].next; bd-&gt;items[0].next = bd-&gt;items[slot].next; // If the freelist is empty, slot will be 0, because the header // item will point to itself. if (slot) return slot; bd-&gt;items.resize(bd-&gt;items.size() + 1); return bd-&gt;items.size() - 1; }</span></span></code> </pre> <br>  Was ist die beste Entfernungsstrategie?  Verschieben Sie das letzte Element in einen leeren Steckplatz, stellen Sie sicher, dass das Array dicht gepackt ist, oder halten Sie alle Elemente an ihrem Platz, indem Sie anstelle des gel√∂schten Elements ‚ÄûL√∂cher‚Äú im Array erstellen. <br><br>  Bei der Entscheidung m√ºssen zwei Aspekte ber√ºcksichtigt werden: <br><br><ul><li>  Das Iterieren √ºber ein dicht gepacktes Array ist schneller, da wir weniger Speicher umgehen und nicht zu viel Zeit damit verbringen m√ºssen, leere Slots zu √ºberspringen. </li><li>  Wenn wir ein dicht gepacktes Array verwenden, bewegen sich die Elemente.  Dies bedeutet, dass wir den Index eines Elements nicht als konstante Kennung f√ºr externe Verweise auf Elemente verwenden k√∂nnen.  Wir m√ºssen jedem Element einen anderen Bezeichner zuweisen und die Nachschlagetabelle verwenden, um diese konstanten IDs mit den aktuellen Objektindizes abzugleichen.  Diese Nachschlagetabelle kann eine Hash-Tabelle oder ein <code>std::vector</code> mit L√∂chern sein, wie oben beschrieben (die zweite Option ist schneller).  Wie auch immer, wir ben√∂tigen zus√§tzlichen Speicher f√ºr diese Tabelle und einen zus√§tzlichen indirekten Schritt f√ºr Bezeichner. </li></ul><br>  Die Auswahl der besten Option h√§ngt von Ihrem Projekt ab. <br><br>  Sie k√∂nnen sagen, dass das Speichern eines dicht gepackten Arrays besser ist, da Iterationen √ºber alle Elemente (um das System zu aktualisieren) h√§ufiger auftreten als das Abgleichen externer Links.  Andererseits k√∂nnen wir sagen, dass die Leistung eines ‚ÄûArrays mit L√∂chern‚Äú nur bei einer gro√üen Anzahl von L√∂chern schlechter ist, und bei der Spieleentwicklung ist uns normalerweise die Leistung im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schlimmsten Fall wichtig</a> (wir m√∂chten eine Bildrate von 60 Hz haben, selbst wenn die maximalen Operationen im Spiel ausgef√ºhrt werden). .  Im schlimmsten Fall haben wir die maximale Anzahl realer Objekte, und in diesem Fall <em>gibt es keine L√∂cher</em> im Array.  L√∂cher treten nur auf, wenn die Anzahl der Objekte abnimmt und wir einige dieser Objekte l√∂schen. <br><br>  Es gibt auch Strategien, mit denen die Verarbeitung von Arrays mit vielen L√∂chern beschleunigt werden kann.  Zum Beispiel k√∂nnen wir die L√§nge kontinuierlicher Lochsequenzen verfolgen, um ganze Lochsequenzen gleichzeitig zu √ºberspringen, anstatt Element f√ºr Element.  Da diese Daten nur f√ºr "L√∂cher" und nicht f√ºr gew√∂hnliche Elemente ben√∂tigt werden, k√∂nnen Sie sie zusammen mit dem Zeiger der Freigabeliste im nicht zugewiesenen Speicher von Objekten speichern und keinen zus√§tzlichen Speicher verschwenden. <br><br>  Wenn Sie den Code f√ºr schnelle Iterationen nicht optimieren m√ºssen, ist es meiner Meinung nach wahrscheinlich am besten, die Option "Array mit L√∂chern" zu verwenden.  Es ist einfacher, erfordert keine zus√§tzlichen Suchstrukturen und Sie k√∂nnen den Index des Objekts als ID verwenden, was sehr praktisch ist.  Dar√ºber hinaus werden durch das Fehlen beweglicher Objekte m√∂gliche Fehler beseitigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/781/6e3/91f/7816e391f0b8c68dede02d95dffa304f.jpg" width="100%"></div><br>  <i>Strategien zum Entfernen von Massendaten.</i> <br><br><h2>  Schwache Zeiger </h2><br>  Als Hinweis m√∂chte ich sagen, dass es einfach ist, die Unterst√ºtzung f√ºr "schwache Zeiger" oder "Deskriptoren" f√ºr Massendatenobjekte zu implementieren. <br><br>  <em>Ein schwacher Zeiger</em> ist ein Verweis auf ein Objekt, der auf irgendeine Weise feststellen kann, dass das Objekt, auf das er verweist, gel√∂scht wurde.  Bei schwachen Zeigern ist es praktisch, dass Sie damit Objekte l√∂schen k√∂nnen, ohne sich Gedanken dar√ºber machen zu m√ºssen, wer auf sie verweisen kann.  Ohne schwache Zeiger zum Entfernen eines Objekts m√ºssten wir nach jedem einzelnen Link suchen und ihn f√ºr ung√ºltig erkl√§ren.  Dies kann besonders schwierig sein, wenn die Links im Skriptcode, auf anderen Computern im Netzwerk usw. gespeichert sind. <br><br>  Denken Sie daran, dass wir bereits eine ID haben, die <em>vorhandene</em> Objekte eindeutig identifiziert.  Bei der Option "mit L√∂chern" ist diese ID einfach der Index des Elements (da sich die Elemente niemals bewegen).  Bei dicht gepackten Arrays ist dieser Objektindex ein Datensatz im <em>Sucharray</em> . <br><br>  Die ID selbst kann nicht als schwacher Zeiger verwendet werden, da IDs wiederverwendet werden k√∂nnen.  Wenn ein Element gel√∂scht und ein neues Element im selben Slot erstellt wird, k√∂nnen wir es nicht allein anhand der ID ermitteln.  Um einen schwachen Zeiger zu erhalten, m√ºssen Sie die ID mit dem <code>generation</code> kombinieren: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> generation; } <span class="hljs-keyword"><span class="hljs-keyword">weak_pointer_t</span></span>;</code> </pre> <br>  Das <code>generation</code> ist ein Feld in der Objektstruktur, das verfolgt, wie oft der Steckplatz im Massendatenarray wiederverwendet wurde.  (Bei dichtem Packen wird nachverfolgt, wie oft der Steckplatz im <em>Suchfeld</em> wiederverwendet wurde.) <br><br>  Wenn Sie einen Artikel l√∂schen, erh√∂hen wir die Generierungsnummer in seinem Steckplatz.  Um zu √ºberpr√ºfen, ob der schwache Zeiger noch g√ºltig ist, pr√ºfen wir, ob die <code>generation</code> in der Struktur des schwachen Zeigers mit der Generierung des durch seine <code>id</code> angegebenen Slots √ºbereinstimmt.  Wenn sie √ºbereinstimmen, ist das Quellobjekt, auf das wir verweisen, noch vorhanden.  Wenn nicht, bedeutet dies, dass es gel√∂scht wird und der Steckplatz entweder auf der Versionsliste steht oder wiederverwendet wurde. <br><br>  Beachten Sie, dass das <code>generation</code> sowohl f√ºr L√∂cher als auch f√ºr vorhandene Objekte erforderlich ist und Sie es au√üerhalb der Union speichern m√ºssen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> generation; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">object_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">freelist_item_t</span></span>; }; } <span class="hljs-keyword"><span class="hljs-keyword">item_t</span></span>;</code> </pre> <br><h2>  Vertriebsstrategie </h2><br>  Wenn Sie <code>std::vector</code> zum Speichern von Elementdaten verwenden, wird das gesamte Array von Elementen neu verteilt, wenn das Array voll ist und vergr√∂√üert werden muss.  Vorhandene Elemente werden in das neue Array kopiert. <br><br>  <code>std::vector</code> w√§chst <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>geometrisch</em></a> .  Dies bedeutet, dass jedes Mal, wenn ein Vektor erh√∂ht werden muss, die Anzahl der verteilten Elemente mit einem Faktor multipliziert wird (normalerweise mit √ó 2).  Das geometrische (exponentielle) Wachstum ist wichtig, da es die Kosten f√ºr die Erh√∂hung des Arrays konstant h√§lt. <br><br>  Bei der Neuverteilung des Arrays m√ºssen alle Elemente verschoben werden, was <em>O (n)</em> erfordert.  Wenn das Array jedoch w√§chst, f√ºgen wir Platz f√ºr weitere <em>n</em> Elemente hinzu, da wir die Gr√∂√üe verdoppeln.  Dies bedeutet, dass wir das Array erst wieder vergr√∂√üern m√ºssen, wenn wir <em>n</em> weitere Elemente hinzuf√ºgen.  Das hei√üt, die Erh√∂hungskosten sind gleich <em>O (n)</em> , aber wir f√ºhren sie nur * n (n) * zum n-ten Mal des Schreibens in das Array aus, dh die Kosten f√ºr das Schreiben eines Elements betragen im Durchschnitt <em>O (n) / O (n) = O (1)</em> . <br><br>  Die Kosten f√ºr die Erfassung eines Artikels werden als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>amortisierte Konstante bezeichnet</em></a> . Wenn Sie alle ausgef√ºhrten Datens√§tze mitteln, werden die Kosten festgelegt.  Wir sollten jedoch nicht vergessen, dass sich die Kosten vor dem Durchschnitt als sehr krampfhaft herausstellen.  Nach jedem <em>O (n)</em> -Datensatz erhalten wir einen Peak der H√∂he <em>O (n)</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d0/331/5be/1d03315be5a0c1ad8096ac05f11c7893.jpg" width="100%"></div><br>  <i>Die Kosten f√ºr das Schreiben in <code>std::vector</code> .</i> <br><br>  Mal sehen, was passiert, wenn wir kein geometrisches Wachstum verwenden.  Angenommen, anstatt den Speicher w√§hrend des Wachstums zu verdoppeln, f√ºgen wir einfach weitere 128 Slots hinzu.  Das Verschieben alter Daten kostet uns immer noch <em>O (n)</em> , aber jetzt m√ºssen wir dies alle 128 hinzugef√ºgten Elemente tun, dh die durchschnittlichen Kosten betragen jetzt <em>O (n) / O (128) = O (n)</em> .  Die Kosten f√ºr das Schreiben eines Elements in ein Array sind proportional zur Gr√∂√üe des Arrays. Wenn das Array also gro√ü wird, beginnt es mit einer Schildkr√∂tengeschwindigkeit zu arbeiten.  Ups! <br><br>  Die Verteilungsstrategie <code>std::vector</code> ist eine gute Standardoption, die in den meisten F√§llen gut funktioniert, jedoch einige Probleme aufweist: <br><br><ul><li>  Amortized Constant ist f√ºr Echtzeitsoftware nicht gut geeignet.  Wenn Sie ein sehr gro√ües Array haben, z. B. Hunderte Millionen Elemente, kann das Erh√∂hen dieses Arrays und das Verschieben aller Elemente zu einer sp√ºrbaren Verlangsamung der Bildrate f√ºhren.  Dies ist aus demselben Grund problematisch, aus dem die Speicherbereinigung in Spielen problematisch ist.  Es spielt keine Rolle, wie niedrig die durchschnittlichen Kosten sind, wenn in einigen Frames die Kosten steigen k√∂nnen, was zu Spielfehlern f√ºhrt. </li><li>  In √§hnlicher Weise kann diese Zuordnungsstrategie bei gro√üen Arrays viel Speicher verschwenden.  Nehmen wir an, wir haben ein Array von 16 Millionen Elementen und m√ºssen ein weiteres darin schreiben.  Dadurch w√§chst das Array auf 32 Millionen.  Jetzt haben wir 16 Millionen Elemente im Array, die wir nicht verwenden.  F√ºr eine Plattform mit wenig Speicher ist dies viel. </li><li>  Schlie√ülich verschiebt die Neuzuweisung Objekte im Speicher, wodurch alle Zeiger auf Objekte ung√ºltig werden.  Dies kann eine Quelle von Fehlern sein, die schwer zu verfolgen sind. </li></ul><br>  Der folgende Code ist ein Beispiel f√ºr Fehler, die beim Verschieben von Objekten auftreten k√∂nnen: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Create two items and return the sum of their costs. float f(bulk_data_t *bd) { const uint32_t slot_1 = allocate_slot(bd); item_t *item_1 = &amp;bd-&gt;items[slot_1]; const uint32_t slot_2 = allocate_slot(bd); item_t *item_2 = &amp;bd-&gt;items[slot_2]; return item_1-&gt;cost + item_2-&gt;cost; }</span></span></code> </pre> <br>  Das Problem hierbei ist, dass die Funktion <code>allocate_slot()</code> m√∂glicherweise das Array neu verteilen muss, um Platz f√ºr <code>item_2</code> zu schaffen.  In diesem Fall wird <code>item_1</code> in den Speicher verschoben und der Zeiger auf <code>item_1</code> ist nicht mehr g√ºltig.  In diesem speziellen Fall k√∂nnen wir den Fehler beseitigen, indem wir das Zuweisungselement_1 <code>item_1</code> . √Ñhnliche Fehler k√∂nnen jedoch unmerklicher auftreten.  Pers√∂nlich haben sie mich oft gebissen. <br><br>  Eine solche Situation ist perfide durch die Tatsache, dass der Fehler nur dann <code>slot_2</code> , wenn das Array genau zum Zeitpunkt der <code>slot_2</code> .  Das Programm kann lange Zeit korrekt funktionieren, bis sich das Verteilungsmuster √§ndert. Danach funktioniert der Fehler. <br><br>  All diese Probleme k√∂nnen mit einer anderen Vertriebsstrategie gel√∂st werden.  Hier sind einige der Optionen: <br><br><ul><li>       : 16, 32, 64, ‚Ä¶,  <em></em>     . ,  16     ,  32   ,  .‚Ä¶     ,         <code>std::vector</code> . </li><li>           ,     .       ,       .               . ,           <em>O(n)</em>  <code>push()</code> ,        . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">       </a> ,      ,   ,     ,   . </li></ul><br> ,       .   ,   -       ,      ,       .      ,      ,          . <br><br>         ,      ‚Äî       ?    ,       . ,     16  ,      16 ,       .   ,            ,           50 %.        . <br><br>   ,         <em> </em> ,           ,       .          *16 K * n*,  <em>n</em> ‚Äî    bulk data  ,    ,        (      ). <br><br>        . -,         ,    <code>blocks\[i / elements_per_block\][i % elements_per_block]</code> . -,        ,      (heap allocator),   . <br><br>    ,         ¬´ ¬ª,  -       <code>std::vector</code> ,     ,    .         ,       ,          . <br><br> ,         ,     ID          .    ,        ,    .   ,   64  ,      32  (4   ‚Äî  ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98e/f31/c3d/98ef31c3d3388db45f0897c9a390ce5d.jpg" width="100%"></div><br> <i> </i> <br><br><h2>      </h2><br>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> (Array of Structures, AoS)  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> (Structure of Arrays, SoA).     . ,      ,      , ,   : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> pos; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> vel; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> col; } <span class="hljs-keyword"><span class="hljs-keyword">particle_t</span></span>;</code> </pre> <br>           struct  .      ¬´ ¬ª.  : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> num_particles; <span class="hljs-keyword"><span class="hljs-keyword">particle_t</span></span> *particles;</code> </pre> <br> ,          . <br><br>     (SoA)        struct: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> num_particles; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *t; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> *pos; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> *vel; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> *col; } particles;</code> </pre> <br>   ,     ,  <code>vec3_t</code>     struct: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> num_particles; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *t; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *pos_x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *pos_y; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *pos_z; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *vel_x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *vel_y; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *vel_z; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *col_r; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *col_g; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *col_b; } particles;</code> </pre> <br>     ,     AoS,      ?       : <br><br><ul><li>       . ,  <code>tick()</code>    <code>t</code> .  <code>simulate_physics()</code>    <code>pos</code>  <code>vel</code> .   SoA       struct.   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> (     ),      . ,  <code>tick()</code>    1/10  ,  ,    10 . </li><li>  SoA        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SIMD</a>  .     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FPU</a> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AVX</a>       float  ,     8 . </li></ul><br>   ,     <code>tick()</code>   80 ?  Nein.      10 ,      ,      , SIMD      . <br><br>   SoA: <br><br><ul><li>   . </li><li>    ,           . </li><li>           <code>particle_t *</code> ,         .      . </li><li>           ,            </li><li>             ( ),  <em></em>   .     <em>  </em> ,     . </li></ul><br>    ,      ,    struct   ,        VM (       ). -    10  struct       .   8- -,   ,          .  Ups! <br><br>       ‚Äî      SIMD.     : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> num_particles; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> position_x[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> position_y[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> position_z[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> velocity_x[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> velocity_y[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> velocity_z[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> color_r[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> color_g[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> color_b[<span class="hljs-number"><span class="hljs-number">8</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">eight_particles_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">eight_particles_t</span></span> *particles;</code> </pre> <br>     -    SIMD-     ,                  -,   .      ,            . <br><br>     <code>tick()</code>  32 ,  288 ,  32   ..  ,      10- ,       <code>t</code> . -, -    64 ,      ,     ,   5 .    ,    ,       -,   100%     . <br><br>    ,     . ,      <code>[16]</code> ,    float  - . ,       ,        ,   : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df8/7a2/558/df87a25586d4afb93a536585a84defef.png" width="100%"></div><br> <i>AoS  SoA.</i> <br><br>    ,  SoA ‚Äî      ¬´ ¬ª,      SIMD     ,         (       ¬´¬ª). <br><br>   SIMD-  ¬´¬ª  ,    ,   ,    ¬´¬ª . ,   ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">     </a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ,  .        <code>next</code>     ,   SIMD-  .      struct. <br><br>       ,      ,        ,    struct  .       ,  ,     . <br><br>  AoS  SoA,  ,              .      ¬´¬ª     AoS    SoA   ,   SIMD-, ,    .              . <br><br>       ‚Äî    AoS     SoA   - . ,        AoS       SoA,   ,       AoS ( ).        ,     ,       . <br><br> ,        ¬´ ¬ª.    16-   ,    SoA,      .       scratch buffer  16  . <br><br><h2>  Fazit </h2><br>        ,  ¬´ ¬ª    bulk data     : <br><br><blockquote>    ¬´¬ª   ,         VM (  ),       ( 16    ,     ). </blockquote><br>  ,        : <br><br><blockquote>     ,   8   SIMD         VM      . </blockquote><br>         . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469861/">https://habr.com/ru/post/de469861/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469837/index.html">Erstes Flutter-Treffen in St. Petersburg: Videoberichte</a></li>
<li><a href="../de469839/index.html">Sicherheitsanf√§lligkeit in Pikabu-Spam</a></li>
<li><a href="../de469843/index.html">"Wo sind diese jungen Punks, die uns vom Erdboden abwischen werden?"</a></li>
<li><a href="../de469849/index.html">Das Spiel ‚ÄûAttack 51%‚Äú: Schreiben eines einfachen eigenst√§ndigen Spiels auf der Obyte-Plattform</a></li>
<li><a href="../de469855/index.html">Gradle + LLVM</a></li>
<li><a href="../de469867/index.html">Wie wird daraus ein Sch√ºler (und was haben Brettspiele damit zu tun)</a></li>
<li><a href="../de469871/index.html">Als Tastaturen Tische waren</a></li>
<li><a href="../de469875/index.html">So sch√ºtzen Sie Ihre Passw√∂rter im Jahr 2019</a></li>
<li><a href="../de469877/index.html">Oh diese Newtonsche Methode</a></li>
<li><a href="../de469879/index.html">Doppel-VPN mit einem Klick. So teilen Sie einfach die IP-Adresse eines Ein- und Ausstiegspunkts</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>