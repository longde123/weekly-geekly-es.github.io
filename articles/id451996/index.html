<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè≥Ô∏è üßëüèª üë®üèª‚Äç‚úàÔ∏è Pengalaman saya tentang kesalahan ü§µüèº ‚ùå üòª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pengalaman saya tentang kesalahan 
 Daftar kesalahan 


1. MCManager kelas Mahakuasa 
2. Menciptakan navigasi kami di antara layar 
3. Tidak pernah ad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengalaman saya tentang kesalahan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451996/"><h3>  Pengalaman saya tentang kesalahan </h3><br><h4>  Daftar kesalahan </h4><br><ol><li>  MCManager kelas Mahakuasa </li><li>  Menciptakan navigasi kami di antara layar </li><li>  Tidak pernah ada banyak warisan </li><li>  Arsitektur produksi kami sendiri atau terus membuat sepeda </li><li>  MVVM dengan soul MVP </li><li>  Upaya kedua dengan navigasi atau Router dan kelengkungan navigasi </li><li>  Manajer yang gigih </li></ol><br>  Banyak orang, termasuk saya, menulis bagaimana melakukan hal yang benar dalam situasi tertentu, bagaimana menulis kode dengan benar, bagaimana menerapkan solusi arsitektur, dll. Tetapi saya ingin berbagi pengalaman saya tentang bagaimana hal itu dilakukan secara tidak benar dan kesimpulan yang saya dapat dibuat berdasarkan kesalahannya.  Kemungkinan besar ini akan menjadi kesalahan umum semua orang yang mengikuti jalur pengembang, atau mungkin sesuatu akan baru.  Saya hanya ingin berbagi pengalaman dan membaca komentar orang lain. <br><a name="habracut"></a><br><h4>  MCManager kelas Mahakuasa </h4><br>  Setelah tahun pertama bekerja di IT, dan lebih khusus lagi pengembangan iOS, saya memutuskan bahwa saya sudah menjadi seorang arsitek yang cukup dan cukup siap untuk dibuat.  Bahkan kemudian, saya secara intuitif memahami bahwa perlu memisahkan logika bisnis dari lapisan presentasi.  Tetapi kualitas ide saya tentang bagaimana melakukan ini jauh dari kenyataan. <br><br>  Saya pindah ke tempat kerja baru, di mana saya ditugaskan untuk secara mandiri mengembangkan fitur baru untuk proyek yang ada.  Itu analog dengan merekam video di Instagram, di mana perekaman dilakukan saat pengguna memegang jarinya pada tombol, dan kemudian beberapa fragmen video terhubung bersama.  Awalnya, diputuskan untuk menjadikan fitur ini sebagai proyek terpisah, atau lebih tepatnya dalam bentuk sampel.  Ini, seperti yang saya pahami, memulai sumber masalah arsitektur saya, yang berlangsung lebih dari setahun. <br><br>  Di masa depan, sampel ini tumbuh menjadi aplikasi lengkap untuk merekam dan mengedit video.  Lucu bahwa awalnya sampel memiliki nama, dari singkatan yang dikumpulkan awalan MC.  Meskipun proyek itu segera diganti namanya, tetapi awalan seperti yang disyaratkan oleh konvensi nama di Objective-C, MC tetap.  Jadi kelas MCManager yang maha kuasa lahir. <br><br><img src="https://habrastorage.org/webt/sz/jw/m_/szjwm_hbfvtxjbovprczya2jyca.jpeg"><br><br>  Karena ini adalah sampel dan pada awalnya fungsinya sederhana, saya memutuskan bahwa satu kelas manajer sudah cukup.  Fungsionalitas, seperti yang saya sebutkan sebelumnya, termasuk merekam fragmen video dengan opsi mulai / hentikan dan selanjutnya menggabungkan fragmen-fragmen ini ke dalam keseluruhan video.  Dan pada saat itu saya dapat menyebutkan kesalahan pertama saya - nama kelas MCManager.  Manajer MC, Karl!  Apa yang harus dikatakan nama kelas kepada pengembang lain tentang tujuan, kemampuannya, dan cara menggunakannya?  Benar, sama sekali tidak ada!  Dan ini ada dalam lampiran, nama yang bahkan tidak mengandung huruf M dan, ibunya, C. Meskipun, ini bukan kesalahan utama saya, karena kelas dengan nama partisan melakukan segalanya, segala sesuatu dari kata itu benar-benar segalanya, yang merupakan kesalahan utama. <br><br>  Rekaman video adalah satu layanan kecil, mengelola penyimpanan file video dalam sistem file adalah layanan kedua dan tambahan untuk menggabungkan beberapa video menjadi satu.  Pekerjaan tiga layanan independen ini, diputuskan untuk bergabung dalam satu manajer.  Idenya adalah mulia, menggunakan pola fasad, untuk membuat antarmuka sederhana untuk logika bisnis dan menyembunyikan semua detail yang tidak perlu pada interaksi berbagai komponen.  Pada tahap awal, bahkan nama kelas fasad seperti itu tidak menimbulkan kecurigaan, terutama dalam sampel. <br>  Tetapi pelanggan menyukai demo dan segera sampel berubah menjadi aplikasi yang lengkap.  Anda dapat membenarkan bahwa tidak ada cukup waktu untuk refactoring, bahwa pelanggan tidak ingin mengulang kode kerja, tetapi terus terang, pada saat itu saya sendiri berpikir bahwa saya telah meletakkan arsitektur yang sangat baik.  Sebenarnya, ide untuk memisahkan logika bisnis dan presentasi adalah sukses.  Arsitekturnya adalah satu kelas MCManager singleton, yang merupakan fasad untuk beberapa lusin layanan dan manajer lainnya.  Ya, itu juga singleton, yang tersedia dari semua penjuru aplikasi. <br><br>  Orang sudah bisa memahami skala seluruh bencana.  Kelas dengan beberapa ribu baris kode yang sulit dibaca dan sulit dipertahankan.  Saya sudah bungkam tentang kemungkinan menyoroti fitur individual untuk mentransfernya ke aplikasi lain, yang sangat umum dalam pengembangan ponsel. <br>  Kesimpulan yang saya buat untuk diri saya setelah beberapa saat bukanlah untuk membuat kelas universal dengan nama yang tidak jelas.  Saya menyadari bahwa logika perlu dipecah-pecah dan tidak membuat antarmuka universal untuk semuanya.  Bahkan, ini adalah contoh dari apa yang akan terjadi jika Anda tidak mematuhi salah satu prinsip SOLID, Prinsip Segregasi Antarmuka. <br><br><h4>  Menciptakan navigasi kami di antara layar </h4><br>  Pemisahan logika dan antarmuka bukan satu-satunya masalah yang membuat saya khawatir tentang proyek di atas.  Saya tidak akan mengatakan bahwa pada saat itu saya akan memisahkan kode layar dan kode navigasi, tetapi ternyata saya datang dengan sepeda saya untuk navigasi. <br><br><img src="https://habrastorage.org/webt/ab/dt/j1/abdtj1sogyy-j7ppjfbk9uhshge.jpeg"><br><br>  Sampel hanya memiliki tiga layar: menu dengan tabel video yang direkam, layar perekaman dan layar pasca pemrosesan.  Agar tidak peduli bahwa tumpukan navigasi mengandung duplikat ViewControllers, saya memutuskan untuk tidak menggunakan UINavigationController.  Saya menambahkan RootViewcontroller, pembaca yang penuh perhatian telah menebak bahwa itu adalah MCRootViewController, yang ditetapkan sebagai yang utama dalam pengaturan proyek.  Pada saat yang sama, pengontrol root bukan salah satu layar aplikasi, ia hanya menyajikan UIViewController yang diinginkan.  Seolah-olah ini tidak cukup, jadi root controller juga merupakan delegasi dari semua pengendali yang diwakili.  Akibatnya, pada setiap saat dalam waktu hanya ada dua vc dalam hierarki, dan semua navigasi diimplementasikan menggunakan pola delegasi. <br><br>  Bagaimana kelihatannya: setiap layar memiliki protokol delegasi sendiri, di mana metode navigasi ditunjukkan, dan pengendali root menerapkan metode ini dan mengubah layar.  RootViewController dissmisil current controller, membuat yang baru dan mempresentasikannya, sementara itu dimungkinkan untuk mentransfer informasi dari satu layar ke yang lain.  Untungnya, logika bisnis berada di kelas tunggal paling keren, sehingga tidak ada layar yang menyimpan apa pun dan dapat dengan mudah dihancurkan.  Sekali lagi, niat yang baik terwujud, meskipun realisasi tertatih-tatih di kedua kaki, dan kadang-kadang tersandung. <br><br>  Seperti yang Anda duga, jika Anda harus kembali dari layar perekaman video ke menu utama, metode itu disebut: <br><br><pre><code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)cancel;</code> </pre> <br>  atau sesuatu seperti itu, dan pengontrol root sudah melakukan semua pekerjaan kotor. <br>  Akibatnya, MCRootViewController, menjadi analog MCManager, tetapi dalam navigasi antar layar, seiring dengan pertumbuhan aplikasi dan penambahan fungsi baru, layar baru ditambahkan. <br><br>  Pabrik sepeda bekerja dengan sangat baik, dan saya terus mengabaikan artikel tentang arsitektur aplikasi seluler.  Tapi saya tidak pernah menyerah untuk memisahkan navigasi dari layar. <br><br>  Keuntungannya adalah bahwa layarnya independen dan dapat digunakan kembali, tetapi ini tidak akurat.  Namun kerugiannya termasuk kesulitan dalam mempertahankan kelas-kelas tersebut.  Masalah dengan kurangnya tumpukan layar ketika Anda harus kembali dengan menggulir layar yang dipilih sebelumnya.  Logika transisi yang rumit antara layar, pengontrol root mempengaruhi bagian dari logika bisnis untuk menampilkan layar baru dengan benar. <br><br>  Secara umum, Anda tidak boleh menerapkan semua navigasi dalam aplikasi dengan cara ini, karena MCRootViewController saya melanggar prinsip Prinsip Terbuka-Tertutup.  Hampir mustahil untuk berkembang, dan semua perubahan harus dilakukan secara konstan ke kelas itu sendiri. <br>  Saya mulai membaca lebih lanjut tentang navigasi antar layar dalam aplikasi seluler, berkenalan dengan pendekatan seperti Router dan Koordinator.  Saya akan menulis tentang Router sedikit kemudian, karena ada sesuatu untuk dibagikan. <br><br><h4>  Tidak pernah ada banyak warisan </h4><br>  Saya juga ingin membagikan tidak hanya mutiara saya, tetapi juga pendekatan dan solusi lucu orang lain yang harus saya tangani. Di tempat yang sama di mana saya menciptakan karya besar saya, mereka mempercayakan saya dengan tugas sederhana.  Tugasnya adalah menambahkan layar dari proyek lain ke proyek saya.  Seperti yang kami tentukan dengan PM, setelah analisis yang dangkal dan sedikit pemikiran, ini seharusnya memakan waktu dua atau tiga jam dan tidak lebih, karena apa yang salah dengan ini, Anda hanya perlu menambahkan kelas layar yang sudah jadi ke aplikasi Anda.  Memang, semuanya sudah dilakukan untuk kita, kita perlu melakukan ctrl + c dan ctrl + v.  Ini hanya sedikit nuansa, pengembang yang menulis aplikasi ini sangat menyukai warisan. <br><br><img src="https://habrastorage.org/webt/bv/e7/h8/bve7h8vugtvsjzyw_ml4esh5vbe.jpeg"><br><br>  Saya segera menemukan ViewController yang saya butuhkan, saya beruntung tidak ada pemisahan logika dan presentasi.  Itu adalah pendekatan lama yang baik, ketika controller berisi semua kode yang diperlukan.  Saya menyalinnya ke proyek saya dan mulai mencari cara untuk membuatnya bekerja.  Dan hal pertama yang saya temukan adalah bahwa pengontrol yang saya butuhkan mewarisi dari pengontrol lain.  Suatu hal yang umum, acara yang sangat diharapkan.  Karena saya tidak punya banyak waktu, saya hanya menemukan kelas yang saya butuhkan dan menyeretnya ke proyek saya.  Nah sekarang itu seharusnya bekerja, pikirku, dan aku tidak pernah salah! <br><br>  Tidak hanya kelas yang saya butuhkan memiliki banyak variabel kelas kustom yang juga perlu disalin ke proyek saya, sehingga masing-masing dari mereka mewarisi sesuatu.  Pada gilirannya, kelas dasar adalah bidang yang diwariskan atau berisi dengan tipe khusus yang, seperti yang mungkin ditebak banyak orang, mewarisi sesuatu, dan sayangnya, ini bukan NSObject, UIViewController atau UIView.  Dengan demikian, sepertiga dari proyek yang tidak perlu bermigrasi ke saya dalam proyek. <br><br>  Karena tidak banyak waktu yang diharapkan untuk menyelesaikan tugas ini, saya tidak melihat jalan keluar lain dari cara menambahkan kelas yang diperlukan yang dibutuhkan xCode hanya untuk meluncurkan proyek saya tanpa rasa sakit.  Akibatnya, dua atau tiga jam berjalan sedikit, karena pada akhirnya saya harus mempelajari seluruh jaringan hierarki warisan, seperti pematung sejati, memotong kelebihannya. <br><br>  Sebagai hasilnya, saya sampai pada kesimpulan bahwa semua hal baik harus secukupnya, bahkan hal yang "luar biasa" sebagai warisan.  Kemudian saya mulai memahami kerugian warisan.  Saya menyimpulkan sendiri, jika saya ingin membuat modul yang dapat digunakan kembali, saya harus membuatnya lebih mandiri. <br><br><h4>  Arsitektur produksi kami sendiri atau terus membuat sepeda </h4><br>  Pindah ke tempat kerja baru dan memulai proyek baru, saya memperhitungkan semua pengalaman yang tersedia dalam desain arsitektur dan terus menciptakan.  Secara alami, saya terus mengabaikan arsitektur yang sudah ditemukan, tetapi pada saat yang sama saya tetap berpegang pada prinsip "memecah belah dan menaklukkan". <br><br>  Tidak lama sebelum kedatangan Swift, jadi saya menyelidiki kemungkinan Objective-c.  Saya memutuskan untuk melakukan injeksi Ketergantungan menggunakan fitur bahasa.  Saya terinspirasi oleh alat ekspansi Lib, saya bahkan tidak dapat mengingat namanya. <br><br>  Intinya adalah: di kelas dasar BaseViewController, saya menambahkan bidang kelas BaseViewModel.  Dengan demikian, untuk setiap layar saya membuat pengontrol saya sendiri, yang mewarisi yang dasar, dan menambahkan protokol agar pengontrol berinteraksi dengan viewModel.  Kemudian muncullah keajaiban.  Saya mendefinisikan kembali properti viewModel dan menambahkan dukungan untuk protokol yang diinginkan.  Pada gilirannya, saya membuat kelas ViewModel baru untuk layar tertentu yang menerapkan protokol ini.  Akibatnya, dalam BaseViewController dalam metode viewDidLoad, saya memeriksa jenis protokol model, memeriksa daftar semua keturunan BaseViewModel, menemukan kelas yang saya butuhkan dan membuat viewModel dari tipe yang saya butuhkan. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh Dasar ViewController</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><span class="hljs-meta"> // MVC model #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"BaseMVCModel.h"</span></span></span><span class="hljs-meta"> @class BaseViewController; @protocol BaseViewControllerDelegate </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;NSObject&gt;</span></span></span><span class="hljs-meta"> @required - (void)backFromNextViewController:(BaseViewController *)aNextViewController withOptions:(NSDictionary *)anOptionsDictionary; @end @interface BaseViewController : UIViewController </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;BaseViewControllerDelegate&gt;</span></span></span><span class="hljs-meta"> @property (nonatomic, weak) BaseMVCModel *model; @property (nonatomic, assign) id</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;BaseViewControllerDelegate&gt;</span></span></span><span class="hljs-meta"> prevViewController; - (void)backWithOptions:(NSDictionary *)anOptionsDictionary; + (void)setupUIStyle; @end import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"BaseViewController.h"</span></span></span><span class="hljs-meta"> // Helpers #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"RuntimeHelper.h"</span></span></span><span class="hljs-meta"> @interface BaseViewController () @end @implementation BaseViewController + (void)setupUIStyle { } #pragma mark - #pragma mark Life cycle - (void)viewDidLoad { [super viewDidLoad]; self.model = [BaseMVCModel getModel:FindPropertyProtocol(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"model"</span></span></span><span class="hljs-meta">, [self class])]; } #pragma mark - #pragma mark Navigation - (void)backWithOptions:(NSDictionary *)anOptionsDictionary { if (self.prevViewController) { [self.prevViewController performSelector:@selector(backFromNextViewController:withOptions:) withObject:self withObject:anOptionsDictionary]; } } #pragma mark - #pragma mark Seque - (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender { if ([segue.destinationViewController isKindOfClass:[BaseViewController class]] { ((BaseViewController *)segue.destinationViewController).prevViewController = self; } } #pragma mark - #pragma mark BaseViewControllerDelegate - (void)backFromNextViewController:(BaseViewController *)aNextViewController withOptions:(NSDictionary *)anOptionsDictionary { [self doesNotRecognizeSelector:_cmd]; } @end</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Contoh ViewModel Dasar</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><span class="hljs-meta"> @interface BaseMVCModel : NSObject @property (nonatomic, assign) id delegate; + (id)getModel:(NSString *)someProtocol; @end #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"BaseMVCModel.h"</span></span></span><span class="hljs-meta"> // IoC #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"IoCContainer.h"</span></span></span><span class="hljs-meta"> @implementation BaseMVCModel + (id)getModel:(NSString *)someProtocol { return [[IoCContainer sharedIoCContainer] getModel:NSProtocolFromString(someProtocol)]; } @end</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Kelas pembantu</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><span class="hljs-meta"> @interface IoCContainer : NSObject + (instancetype)sharedIoCContainer; - (id)getModel:(Protocol *)someProtocol; @end #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"IoCContainer.h"</span></span></span><span class="hljs-meta"> // Helpers #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"RuntimeHelper.h"</span></span></span><span class="hljs-meta"> // Models #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"BaseMVCModel.h"</span></span></span><span class="hljs-meta"> @interface IoCContainer () @property (nonatomic, strong) NSMutableSet *models; @end @implementation IoCContainer #pragma mark - #pragma mark Singleton + (instancetype)sharedIoCContainer { static IoCContainer *_sharedIoCContainer = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ _sharedIoCContainer = [IoCContainer new]; }); return _sharedIoCContainer; } - (id)getModel:(Protocol *)someProtocol { if (!someProtocol) { return [BaseMVCModel new]; } NSArray *modelClasses = ClassGetSubclasses([BaseMVCModel class]); __block Class currentClass = NULL; [modelClasses enumerateObjectsUsingBlock:^(Class class, NSUInteger idx, BOOL *stop) { if ([class conformsToProtocol:someProtocol]) { currentClass = class; } }]; if (currentClass == nil) { return [BaseMVCModel new]; } __block BaseMVCModel *currentModel = nil; [self.models enumerateObjectsUsingBlock:^(id model, BOOL *stop) { if ([model isKindOfClass:currentClass]) { currentModel = model; } }]; if (!currentModel) { currentModel = [currentClass new]; [self.models addObject:currentModel]; } return currentModel; } - (NSMutableSet *)models { if (!_models) { _models = [NSMutableSet set]; } return _models; } @end #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><span class="hljs-meta"> NSString * FindPropertyProtocol(NSString *propertyName, Class class); NSArray * ClassGetSubclasses(Class parentClass); #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"RuntimeHelper.h"</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;objc/runtime.h&gt;</span></span></span><span class="hljs-meta"> #pragma mark - #pragma mark Functions NSString * FindPropertyProtocol(NSString *aPropertyName, Class class) { unsigned int propertyCount; objc_property_t *properties = class_copyPropertyList(class, &amp;propertyCount); for (unsigned int i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; propertyCount; i++) { objc_property_t property = properties[i]; const char *propertyName = property_getName(property); if ([@(propertyName) isEqualToString:aPropertyName]) { const char *attrs = property_getAttributes(property); NSString* propertyAttributes = @(attrs); NSScanner *scanner = [NSScanner scannerWithString: propertyAttributes]; [scanner scanUpToString:@"&lt;" intoString:NULL]; [scanner scanString:@"&lt;" intoString:NULL]; NSString* protocolName = nil; [scanner scanUpToString:@"&gt;</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" intoString: &amp;protocolName]; return protocolName; } } return nil; } NSArray * ClassGetSubclasses(Class parentClass) { int numClasses = objc_getClassList(NULL, 0); Class *classes = NULL; classes = (Class *)malloc(sizeof(Class) * numClasses); numClasses = objc_getClassList(classes, numClasses); NSMutableArray *result = [NSMutableArray array]; for (NSInteger i = 0; i &lt; numClasses; i++) { Class superClass = classes[i]; do { superClass = class_getSuperclass(superClass); } while(superClass &amp;&amp; superClass != parentClass); if (superClass == nil) { continue; } [result addObject:classes[i]]; } free(classes); return result; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Contoh layar masuk</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"BaseViewController.h"</span></span></span><span class="hljs-meta"> @protocol LoginProtocol </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;NSObject&gt;</span></span></span><span class="hljs-meta"> @required - (void)login:(NSString *)aLoginString password:(NSString *)aPasswordString completionBlock:(DefaultCompletionBlock)aCompletionBlock; @end @interface LoginVC : BaseViewController @end #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"LoginVC.h"</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"UIViewController+Alert.h"</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"UIViewController+HUD.h"</span></span></span><span class="hljs-meta"> @interface LoginVC () @property id</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;LoginProtocol&gt;</span></span></span><span class="hljs-meta"> model; @property (weak, nonatomic) IBOutlet UITextField *emailTF; @property (weak, nonatomic) IBOutlet UITextField *passTF; @end @implementation LoginVC @synthesize model = _model; #pragma mark - #pragma mark IBActions - (IBAction)loginAction:(id)sender { [self login]; } #pragma mark - #pragma mark UITextFieldDelegate - (BOOL)textFieldShouldReturn:(UITextField *)textField { if (textField == self.emailTF) { [self.passTF becomeFirstResponder]; } else { [self login]; } return YES; } #pragma mark - #pragma mark Login - (void)login { NSString *email = self.emailTF.text; NSString *pass = self.passTF.text; if (email.length == 0 || pass.length == 0) { [self showAlertOkWithMessage:@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Please, input info!"</span></span></span><span class="hljs-meta">]; return; } __weak __typeof(self)weakSelf = self; [self showHUD]; [self.model login:self.emailTF.text password:self.passTF.text completionBlock:^(BOOL isDone, NSError *anError) { [weakSelf hideHUD]; if (isDone) { [weakSelf backWithOptions:nil]; } }]; } @end</span></span></code> </pre> <br></div></div><br>  Sedemikian mudahnya, saya melakukan inisialisasi malas pada viewModel dan menghubungkannya dengan model melalui protokol.  Dengan semua ini, pada saat itu saya masih tidak tahu apa-apa tentang arsitektur MVP, meskipun sesuatu yang serupa membayangi saya. <br>  Navigasi antara layar diserahkan kepada kebijaksanaan "viewModel", karena saya menambahkan tautan yang lemah ke controller. <br><br>  Mengingat implementasi ini sekarang, saya tidak dapat mengatakan dengan pasti bahwa semuanya buruk.  Gagasan memisahkan lapisan berhasil, momen membuat dan menetapkan model ke controller disederhanakan. <br>  Tetapi bagi saya sendiri, saya memutuskan untuk mempelajari lebih banyak pendekatan dan arsitektur yang sudah jadi, karena selama pengembangan aplikasi dengan arsitektur saya sendiri, saya harus berurusan dengan banyak nuansa.  Misalnya, penggunaan kembali layar dan model, pewarisan, transisi kompleks antar layar.  Pada saat itu, tampak bagi saya bahwa viewModel adalah bagian dari logika bisnis, walaupun sekarang saya mengerti bahwa itu masih merupakan lapisan presentasi.  Saya mendapat pengalaman hebat selama percobaan ini. <br><br><h4>  MVVM dengan soul MVP </h4><br>  Setelah mendapatkan pengalaman, saya memutuskan untuk memilih arsitektur khusus untuk diri saya dan mengikutinya, daripada menciptakan sepeda.  Saya mulai membaca lebih banyak tentang arsitektur, untuk belajar secara mendetail populer pada waktu itu dan menetap di MVVM.  Terus terang, saya tidak segera mengerti esensinya, tetapi saya memilihnya karena saya suka namanya. <br><br>  Saya tidak segera memahami esensi arsitektur dan hubungan antara ViewModel dan View (ViewController), tetapi mulai melakukan seperti yang saya mengerti.  Mata takut, dan tangan mengetik kode dengan panik. <br><br>  Dalam pembelaan saya, saya akan menambahkan bahwa pada waktu itu waktu dan waktu untuk berpikir dan menganalisis penciptaan yang saya buat sangat ketat.  Oleh karena itu, alih-alih binder, saya membuat tautan langsung di ViewModel ke View yang sesuai.  Dan sudah di ViewModel sendiri, saya melakukan pengaturan presentasi. <br><br>  Tentang MVP, saya memiliki ide yang sama seperti tentang arsitektur lain, jadi saya sangat percaya bahwa itu adalah MVVM, di mana ViewModel ternyata menjadi presenter paling nyata. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh arsitektur "MVVM" saya dan ya, saya menyukai gagasan itu dengan RootViewController, yang bertanggung jawab atas navigasi tingkat tertinggi dalam aplikasi.</b>  <b class="spoiler_title">Tentang router ditulis di bawah ini.</b> <div class="spoiler_text"><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class RootViewController: UIViewController { var viewModel: RootViewModel? override func viewDidLoad() { super.viewDidLoad() let router = (UIApplication.shared.delegate as? AppDelegate)!.router viewModel = RootViewModel(with: self, router: router) viewModel?.setup() } } <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit protocol ViewModelProtocol: class { func setup() func backAction() } class RootViewModel: NSObject, ViewModelProtocol { unowned var router : RootRouter unowned var view: RootViewController init(with view: RootViewController, router: RootRouter) { self.view = view self.router = router } <span class="hljs-comment"><span class="hljs-comment">// MARK: - ViewModelProtocol func setup() { if AccountManager.shared.isLoggedIn() { router.route(to: RootRoutes.launch.rawValue, from: view, parameters: nil) } else { router.route(to: RootRoutes.loginregistartion.rawValue, from: view, parameters: nil) } } func backAction() { } }</span></span></code> </pre> <br></div></div><br>  Ini tidak secara khusus mempengaruhi kualitas proyek, karena urutan dan pendekatan tunggal dihormati.  Tapi pengalaman itu sangat berharga.  Setelah sepeda yang saya buat, saya akhirnya mulai melakukan sesuai dengan arsitektur yang diterima secara umum.  Kecuali presenter dipanggil presenter, yang bisa membingungkan pengembang pihak ketiga. <br><br>  Saya memutuskan bahwa di masa depan ada baiknya melakukan proyek uji kecil, untuk menggali esensi dari pendekatan tertentu dalam desain secara lebih rinci.  Jadi untuk berbicara, rasakan terlebih dahulu dalam latihan, dan kemudian masuk ke pertempuran.  Demikian kesimpulan yang saya buat untuk diri saya sendiri. <br><br><h4>  Upaya kedua dengan navigasi atau Router dan kelengkungan navigasi </h4><br>  Pada proyek yang sama, di mana saya dengan gagah dan naif mengimplementasikan MVVM, saya memutuskan untuk mencoba pendekatan baru dalam navigasi antar layar.  Seperti yang saya sebutkan sebelumnya, saya masih menganut gagasan memisahkan layar dan logika transisi di antara mereka. <br><br>  Membaca tentang MVVM, saya tertarik dengan pola seperti Router.  Setelah meninjau kembali deskripsinya, saya mulai mengimplementasikan solusi dalam proyek saya. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh router</b> <div class="spoiler_text"><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit protocol Router: class { func route(to routeID: String, from view: UIViewController, parameters: Any?) func back(from view: UIViewController, parameters: Any?) } extension Router { func back(from view: UIViewController, parameters: Any?) { let navigationController: UINavigationController = checkNavigationController(for: view) navigationController.popViewController(animated: false) } } enum RootRoutes: String { case launch = "Launch" case loginregistartion = "LoginRegistartionRout" case mainmenu = "MainMenu" } class RootRouter: Router { var loginRegistartionRouter: LoginRegistartionRouter? var mainMenuRouter: MainMenuRouter? <span class="hljs-comment"><span class="hljs-comment">// MARK: Router func route(to routeID: String, from view: UIViewController, parameters: Any?) { var rootView = view if view is EPLaunchViewController { rootView = (view.navigationController?.viewControllers.first)! view.navigationController?.popViewController(animated: false) } if routeID == RootRoutes.loginregistartion.rawValue { loginRegistartionRouter = LoginRegistartionRouter(with: self) loginRegistartionRouter?.route(to: LRRouteID.phoneNumber.rawValue, from: rootView, parameters: nil) } else if routeID == RootRoutes.mainmenu.rawValue { if mainMenuRouter == nil { mainMenuRouter = MainMenuRouter(with: self) } mainMenuRouter?.route(to: MMRouteID.start.rawValue, from: rootView, parameters: nil) } else if routeID == RootRoutes.launch.rawValue { let storyboard = UIStoryboard(name: "RootStoryboard", bundle: nil) let launchView = storyboard.instantiateViewController(withIdentifier: "LaunchViewController") as! LaunchViewController let navigationController: UINavigationController = checkNavigationController(for: view) launchView.viewModel = LaunchViewModel(with: launchView, router: self) navigationController.pushViewController(launchView, animated: false) } } }</span></span></code> </pre><br></div></div><br>  Kurangnya pengalaman dalam menerapkan pola semacam itu telah membuatnya terasa.  Semuanya tampak rapi dan jelas, router menciptakan kelas UIViewController baru, menciptakan ViewModel untuk itu dan mengeksekusi logika untuk beralih ke layar ini.  Namun tetap saja, banyak kekurangan membuat diri mereka terasa. <br>  Kesulitan mulai timbul ketika itu perlu untuk membuka aplikasi dengan layar tertentu setelah pemberitahuan push.  Akibatnya, di beberapa tempat kami mendapat logika yang membingungkan untuk memilih layar yang tepat dan kesulitan lebih lanjut dalam mendukung pendekatan semacam itu. <br><br>  Saya tidak meninggalkan ide untuk mengimplementasikan Router, tetapi melanjutkan ke arah ini, mendapatkan lebih banyak pengalaman.  Jangan menyerah sesuatu setelah upaya pertama gagal. <br><br><h4>  Manajer yang gigih </h4><br>  Kelas manajer lain yang menarik dalam praktik saya.  Tapi yang ini relatif muda.  Semua sama, proses pengembangan terdiri dari coba-coba, dan karena kita semua, baik, atau kebanyakan dari kita, terus-menerus dalam proses pengembangan, kesalahan selalu muncul. <br><br>  Inti dari masalahnya adalah ini, aplikasi memiliki layanan yang harus digantung terus-menerus dan pada saat yang sama harus tersedia di banyak tempat. <br><br>  Contoh: menentukan status Bluetooth.  Dalam aplikasi saya, dalam beberapa layanan saya perlu memahami apakah bluetooth dihidupkan atau dimatikan dan berlangganan pembaruan status.  Karena ada beberapa tempat seperti itu: beberapa layar, beberapa manajer logika bisnis tambahan, dll., Masing-masing dari mereka perlu berlangganan delegasi CBPeripheralManager (atau CBCentralManager). <br><br>  Solusinya tampaknya jelas, kami membuat kelas terpisah yang memonitor status bluetooth dan memberi tahu semua orang yang membutuhkannya melalui pola Observer.  Tetapi kemudian muncul pertanyaan, siapa yang akan secara permanen menyimpan layanan ini?  Hal pertama yang terlintas dalam pikiran saat ini adalah menjadikannya singleton!  Segalanya tampak baik-baik saja! <br><br>  Tapi inilah saatnya bahwa lebih dari satu layanan tersebut telah terakumulasi dalam aplikasi saya.  Saya juga tidak ingin membuat 100500 singletones dalam proyek ini. <br><br>  Dan kemudian cahaya lain muncul di atas kepala kecilku yang sudah terang.  Buat satu singleton yang akan menyimpan semua layanan tersebut dan menyediakan akses ke mereka di seluruh aplikasi.  Maka lahirlah "manajer permanen".  Dengan nama itu, saya tidak berpikir lama dan menyebutnya, karena semua orang sudah bisa menebak, PersistentManager. <br><br>  Seperti yang Anda lihat, saya juga memiliki pendekatan yang sangat orisinal untuk penamaan kelas.  Saya pikir saya perlu menambahkan sedikit tentang nama kelas dalam rencana pengembangan saya. <br><br>  Masalah utama dalam implementasi ini adalah singleton, yang tersedia di mana saja dalam proyek ini.  Dan ini mengarah pada fakta bahwa manajer yang menggunakan salah satu layanan permanen mengaksesnya di dalam metode mereka, yang tidak jelas.  Untuk pertama kalinya, saya menemukan ini ketika saya membuat fitur kompleks besar dalam proyek demo terpisah dan mentransfer bagian dari logika bisnis dari proyek utama.  Kemudian saya mulai menerima pesan dengan kesalahan tentang layanan yang hilang. <br><br>  Kesimpulan yang saya buat setelah ini adalah bahwa Anda perlu mendesain kelas Anda sedemikian rupa sehingga tidak ada dependensi tersembunyi.  Layanan yang diperlukan harus diberikan sebagai parameter saat menginisialisasi kelas, tetapi tidak menggunakan singleton, yang dapat diakses dari mana saja.  Dan yang lebih indah, perlu dilakukan dengan menggunakan protokol. <br>  Ini ternyata merupakan konfirmasi lain dari kurangnya pola tunggal. <br><br><h4>  Ringkasan </h4><br>  Dan itu, saya tidak berdiri diam, tetapi bergerak maju, menguasai pendekatan baru dalam pemrograman.  Hal utama adalah bergerak, mencari, dan bereksperimen.  Kesalahan akan selalu terjadi, tidak ada jalan keluar dari ini.  Tetapi hanya karena pengakuan kesalahan seseorang, seseorang dapat berkembang secara kualitatif. <br><br><img src="https://habrastorage.org/webt/xe/xr/wf/xexrwfhf0_i5cpoxtv3kjrqxsne.gif"><br><br>  Dalam kebanyakan kasus, masalahnya adalah kelas super yang melakukan banyak hal, atau ketergantungan yang salah antar kelas.  Yang menunjukkan bahwa perlu untuk menguraikan logika lebih kompeten. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451996/">https://habr.com/ru/post/id451996/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451974/index.html">Sejarah AMD: 50 Tahun Perkembangan Pesat</a></li>
<li><a href="../id451976/index.html">Berapa harga Runet "berdaulat"?</a></li>
<li><a href="../id451982/index.html">Semakin cepat Anda melupakan OOP, semakin baik untuk Anda dan program Anda.</a></li>
<li><a href="../id451986/index.html">Mengambil data dengan ORM itu mudah! Atau tidak?</a></li>
<li><a href="../id451990/index.html">FAQ tentang transfer dan penerbangan lanjutan: apa perbedaan yang bisa dan tidak bisa dilakukan penumpang</a></li>
<li><a href="../id451998/index.html">Masalah pertanian presisi dan cara hidup bersama mereka</a></li>
<li><a href="../id452000/index.html">Bagaimana di Leroy Merlin Anda dapat membeli barang-barang dari gudang pemasok yang tidak ada dalam bermacam-macam toko</a></li>
<li><a href="../id452004/index.html">Menemukan lokasi jatuhnya perangkat "Bereshit" ke bulan</a></li>
<li><a href="../id452006/index.html">Epic Metaverse: Mengapa Penulis Fortnite Harus Mendapatkannya</a></li>
<li><a href="../id452008/index.html">Pendekatan teknik dan daftar periksa: bagaimana tidak menjadi gila dalam kekacauan tugas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>