<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤸🏽 🌇 🕉️ 没有SMS和注册的C测试 🖕🏿 🌥️ 🧘🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最近， zerocost发表了一篇有趣的文章， “没有宏和动态内存的C ++测试” ，其中讨论了用于测试C ++代码的简约框架。 作者（几乎）设法避免使用宏来注册测试，但代替它们的是，代码中出现了“魔术”模板，对我个人而言，对不起，这很难想象。 看完这篇文章后，我感到不满意，因为我知道可以做得更好。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>没有SMS和注册的C测试</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435028/"><p><img src="https://habrastorage.org/webt/lg/12/b3/lg12b3c-s5uuok0_nialgfngc9e.png" alt="屏幕截图刀具" align="right"> 最近， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">zerocost</a>发表了一篇有趣的文章， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“没有宏和动态内存的C ++测试”</a> ，其中讨论了用于测试C ++代码的简约框架。 作者（几乎）设法避免使用宏来注册测试，但代替它们的是，代码中出现了“魔术”模板，对我个人而言，对不起，这很难想象。 看完这篇文章后，我感到不满意，因为我<em>知道</em>可以做得更好。 我不立即记得在哪里，但是我<em>肯定看到</em>了测试代码，该代码不包含用于注册它们的单个额外字符： </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_object_addition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ensure_equals(<span class="hljs-string"><span class="hljs-string">"2 + 2 = ?"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); }</code> </pre> <br><p> 最后，我记得该框架称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>Cutter</strong></a> ，它使用一种天才方法以自己的方式识别测试功能。 </p><a name="habracut"></a><br><p>  （KDPV来自C BY网站SA的Cutter网站。） </p><br><h2 id="v-chyom-zhe-tryuk"> 诀窍是什么？ </h2><br><p> 测试代码在单独的共享库中汇编。 测试函数是从导出的库符号中提取的，并通过名称进行标识。 测试由特殊的外部实用程序执行。 智人坐着。 </p><br><pre> <code class="cpp hljs">$ cat test_addition.c <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cutter.h&gt; void test_addition() { cut_assert_equal_int(2 + 2, 5); }</span></span></span></span></code> </pre> <br><pre> <code class="plaintext hljs">$ cc -shared -o test_addition.so \ -I/usr/include/cutter -lcutter \ test_addition.c</code> </pre> <br><pre> <code class="plaintext hljs">$ cutter . F ========================================================================= Failure: test_addition &lt;2 + 2 == 5&gt; expected: &lt;4&gt; actual: &lt;5&gt; test_addition.c:5: void test_addition(): cut_assert_equal_int(2 + 2, 5, ) ========================================================================= Finished in 0.000943 seconds (total: 0.000615 seconds) 1 test(s), 0 assertion(s), 1 failure(s), 0 error(s), 0 pending(s), 0 omission(s), 0 notification(s) 0% passed</code> </pre> <br><p> 这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Cutter文档中的示例</a> 。 您可以安全地滚动与Autotools相关的所有内容，而仅查看代码。 框架有点奇怪，是的，就像日语一样。 </p><br><p> 我不会过多地介绍实现功能。 我也没有完整（甚至至少是草稿）的代码，因为我个人并不真正需要它（在Rust中，一切都是开箱即用的）。 但是，对于有兴趣的人，这可能是一个很好的练习。 </p><br><h2 id="detali-i-vozmozhnosti-realizacii"> 详细信息和实施选项 </h2><br><p> 考虑在编写使用Cutter方法进行测试的框架时需要解决的一些任务。 </p><br><h3 id="poluchenie-eksportiruemyh-funkciy"> 获取导出功能 </h3><br><p> 首先，您需要以某种方式使用测试功能。 当然，C ++标准根本没有描述共享库。  Windows最近已收购了Linux子系统，该子系统可将所有三个主要操作系统都简化为POSIX。 如您所知，POSIX系统提供了函数<code>dlopen()</code> ， <code>dlsym()</code> ， <code>dlclose()</code> ，借助它们，您可以获取功能的地址，知道其符号的名称，然后就可以了。  POSIX未公开所加载库中包含的功能列表。 </p><br><p> 不幸的是（尽管很幸运），没有标准的，可移植的方法来发现从库中导出的所有功能。 也许， <em>库</em>概念并非在所有平台上都存在（阅读：嵌入式），这一事实在某种程度上涉及到这一点。 但这不是重点。 最主要的是您必须使用特定<em>于</em>平台的功能。 </p><br><p> 作为初始近似值，您可以简单地调用<strong>nm</strong>实用程序： </p><br><pre> <code class="cpp hljs">$ cat test.<span class="hljs-function"><span class="hljs-function">cpp </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_object_addition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br><pre> <code class="plaintext hljs">$ clang -shared test.cpp</code> </pre> <br><pre> <code class="plaintext hljs">$ nm -gj ./a.out __Z20test_object_additionv dyld_stub_binder</code> </pre> <br><p> 解析其输出并使用<code>dlsym()</code> 。 </p><br><p> 对于更深入的自省，像<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">libelf</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">libMachO</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pe-parse之类的库</a>很有用，它允许您以编程方式解析您感兴趣的可执行文件和平台库。 实际上， <strong>nm</strong>和公司只是使用它们。 </p><br><h3 id="filtraciya-testovyh-funkciy"> 测试功能过滤 </h3><br><p> 您可能已经注意到，这些库包含一些奇怪的字符： </p><br><pre> <code class="plaintext hljs">__Z20test_object_additionv dyld_stub_binder</code> </pre> <br><p> 这就是<code>__Z20test_object_additionv</code>是什么，当我们仅<code>test_object_addition</code>函数<code>test_object_addition</code> ？ 剩下的<code>dyld_stub_binder</code>什么？ </p><br><p>  “ <code>__Z20...</code> ”字符<code>__Z20...</code>是所谓的<em>名称修饰</em> （名称<em>修饰</em> ）。  C ++编译功能，无法解决，请耐心等待。 从系统的角度来看，这就是所谓的函数（和<code>dlsym()</code> ）。 为了将它们以正常形式显示给某个人，您可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">libdemangle之</a>类的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">库</a> 。 当然，您需要的库取决于您使用的编译器，但是在平台框架内装饰格式通常是相同的。 </p><br><p> 至于像<code>dyld_stub_binder</code>这样的奇怪功能，这些也是必须考虑的平台功能。 在开始测试时，您不需要调用任何函数，因为那里没有鱼。 </p><br><p> 这种想法的逻辑延续是按名称过滤功能。 例如，您只能运行名称中带有<code>test</code>函数。 或者只是来自<code>tests</code>名称空间的功能。 并且还使用嵌套名称空间对测试进行分组。 您的想象力没有限制。 </p><br><h3 id="peredacha-konteksta-ispolnyaemogo-testa"> 通过可执行测试的上下文 </h3><br><p> 带有测试的目标文件收集在一个共享的库中，其代码的执行完全由外部实用程序驱动程序<code>cutter</code>的cuter控制。 因此，内部测试功能可以使用此功能。 </p><br><p> 例如，可执行测试的上下文（原始文章中的<code>IRuntime</code> ）可以安全地通过全局（线程局部）变量传递。 驱动程序负责管理和传递上下文。 </p><br><p> 在这种情况下，测试函数不需要参数，但保留所有高级功能，例如，对测试用例进行任意命名： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_vector_add_element</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ testing::description(<span class="hljs-string"><span class="hljs-string">"vector size grows after push_back()"</span></span>); }</code> </pre> <br><p>  <code>description()</code>函数通过全局变量访问条件<code>IRuntime</code> ，因此可以将注释传递<code>IRuntime</code>的框架。 框架保证使用全局上下文的安全性，而不是测试编写者的责任。 </p><br><p> 通过这种方法，将上下文传递给比较语句和内部测试函数时，可能需要从主函数中调用这些代码，从而减少了代码中的噪音。 </p><br><h3 id="konstruktory-i-destruktory"> 构造函数和析构函数 </h3><br><p> 由于测试的执行完全由驱动程序控制，因此它可以<em>在</em>测试<em>周围</em>执行其他代码。 </p><br><p>  Cutter库为此使用以下功能： </p><br><ul><li>  <code>cut_setup()</code> -每次单独测试之前 </li><li>  <code>cut_teardown()</code> -每次单独测试后 </li><li>  <code>cut_startup()</code> -运行所有测试之前 </li><li>  <code>cut_shutdown()</code> -完成所有测试之后 </li></ul><br><p> 仅在测试文件中定义了这些函数。 您可以在其中放置测试环境（夹具）的准备和清理：创建必要的临时文件，测试对象的复杂设置以及其他测试反模式。 </p><br><p> 对于C ++，可以提出一个更惯用的界面： </p><br><ul><li> 更面向对象和类型安全 </li><li> 具有更好的RAII概念支持 </li><li> 使用Lambda推迟执行 </li><li> 涉及测试执行上下文 </li></ul><br><p> 但现在，我现在再次详细考虑这一点。 </p><br><h3 id="samodostatochnye-ispolnimye-fayly-s-testami"> 独立的测试可执行文件 </h3><br><p> 为了方便起见，Cutter使用共享库方法。 各种测试被编译到一组库中，一个单独的测试实用程序可以找到并执行这些库。 当然，如果需要，可以将测试驱动程序的整个代码直接嵌入到可执行文件中，从而获得通常的单独文件。 但是，这将需要与构建系统进行协作，以便以正确的方式组织这些可执行文件的布局：无需删除“未使用”的功能，具有正确的依存关系等。 </p><br><h3 id="prochee"> 其他 </h3><br><p>  Cutter和其他框架还具有许多其他有用的功能，可以简化编写测试时的工作： </p><br><ul><li> 灵活且<em>可扩展的</em>测试语句 </li><li> 从文件构建和获取测试数据 </li><li> 堆栈跟踪研究，异常和丢弃处理 </li><li> 可自定义的测试“细分级别” </li><li> 在多个流程中运行测试 </li></ul><br><p> 编写自行车时，值得回顾一下现有的框架。  UX是一个更深层次的话题。 </p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p>  Cutter框架使用的方法允许以最小的程序员负担来识别测试功能，而只需编写测试功能即可。 该代码不需要使用任何特殊的模板或宏，从而提高了其可读性。 </p><br><p> 组装和运行测试的功能可以隐藏在用于Makefile，CMake等组装系统的可重用模块中。关于单独组装测试的问题仍然必须以另一种方式提出。 </p><br><p> 这种方法的缺点包括难以将测试放置在与主代码相同的文件（相同的转换单元）中。 不幸的是，在这种情况下，没有其他提示，就不再可能确定需要启动哪些功能，而哪些不需要。 幸运的是，在C ++中，通常习惯将测试和实现分发到不同的文件中。 </p><br><p> 至于宏的最终处理，在我看来， <em>原则上不</em>应丢弃它们。 宏允许例如编写较短的比较语句，从而避免代码重复： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_object_addition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ensure_equals(<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); }</code> </pre> <br><p> 但是在出现错误的情况下，同时保留该问题的相同信息内容： </p><br><pre> <code class="plaintext hljs">Failure: test_object_addition &lt;ensure_equals(2 + 2, 5)&gt; expected: &lt;5&gt; actual: &lt;4&gt; test.c:5: test_object_addition()</code> </pre> <br><p> 可以从收集的库中包含的调试信息中提取理论上要测试的功能的名称，文件名以及该功能开始的行号。  <code>ensure_equals()</code>函数知道比较表达式的期望值和实际值。 宏允许您“恢复”测试语句的原始拼写，从中可以更清楚地看出为什么期望值<code>4</code> 。 </p><br><p> 但是，这并不适合所有人。 宏对测试代码的好处到此为止吗？ 我还没有真正考虑过这一刻，这可能是进一步发展的一个好领域 <del> 变态 </del> 研究。 一个更有趣的问题：是否可以以某种方式为C ++创建没有宏的<em>模拟框架</em> ？ </p><br><p> 细心的读者还指出，实施过程中实际上没有SMS和石棉，这对于地球的生态和经济而言无疑是有利的。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN435028/">https://habr.com/ru/post/zh-CN435028/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN435014/index.html">Dart与Node.js：比较HTTP服务器实现的性能</a></li>
<li><a href="../zh-CN435016/index.html">拉里·埃里森将带给特斯拉什么</a></li>
<li><a href="../zh-CN435018/index.html">在2018年，我们终于开始认真对待在智能手机上花费的时间</a></li>
<li><a href="../zh-CN435020/index.html">消费电子产品名人堂：最近50年最佳产品的故事，第2部分</a></li>
<li><a href="../zh-CN435026/index.html">我们制造了一个即使在电梯中也能工作的信使*</a></li>
<li><a href="../zh-CN435032/index.html">e娥四号飞船成功降落在月球的另一侧并发送了第一张照片</a></li>
<li><a href="../zh-CN435036/index.html">关于现代C ++和游戏开发的思考</a></li>
<li><a href="../zh-CN435038/index.html">2018年世界核电</a></li>
<li><a href="../zh-CN435040/index.html">十年前的比特币</a></li>
<li><a href="../zh-CN435044/index.html">上古：迷你碟片在其自然栖息地</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>