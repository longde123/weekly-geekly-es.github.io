<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÖüèæ üï¥üèº üì§ N√≥s escrevemos nosso pr√≥prio mecanismo voxel üë®üèø‚Äçüöí üö£ üë®‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nota: o c√≥digo fonte completo para este projeto est√° dispon√≠vel aqui: [ fonte ]. 

 Quando o projeto em que estou trabalhando come√ßa a ficar sem vapor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>N√≥s escrevemos nosso pr√≥prio mecanismo voxel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474414/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a53/e5f/dea/a53e5fdeab8992f2b647feb66ccf126b.png" alt="imagem"></div><br>  <em><strong>Nota: o</strong> c√≥digo fonte completo para este projeto est√° dispon√≠vel aqui: [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fonte</a> ].</em> <br><br>  Quando o projeto em que estou trabalhando come√ßa a ficar sem vapor, adiciono novas visualiza√ß√µes que me motivam a seguir em frente. <br><br>  Ap√≥s o lan√ßamento do conceito original do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Task-Bot</a> [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tradu√ß√£o</a> para Habr√©], senti que estava limitado pelo espa√ßo bidimensional em que trabalhava.  Parecia que estava escondendo as possibilidades para o comportamento emergente dos bots. <br><br>  Tentativas mal sucedidas anteriores de aprender o OpenGL moderno colocaram diante de mim uma barreira mental, mas no final de julho de alguma forma eu finalmente a rompi.  Hoje, no final de outubro, eu j√° tenho uma compreens√£o bastante confiante dos conceitos, ent√£o lancei meu pr√≥prio mecanismo voxel simples, que ser√° o ambiente para a vida e a prosperidade dos meus Task-Bots. <br><br>  Decidi criar meu pr√≥prio mecanismo, porque precisava de controle total sobre os gr√°ficos;  al√©m disso, eu queria me testar.  De certa forma, eu estava inventando uma bicicleta, mas gostei muito desse processo! <br><br>  O objetivo final de todo o projeto era uma simula√ß√£o completa do ecossistema, onde bots no papel de agentes manipulam o ambiente e interagem com ele. <br><br>  Como o mecanismo j√° avan√ßou bastante e passarei a programar bots novamente, decidi escrever um post sobre o mecanismo, suas fun√ß√µes e implementa√ß√£o, a fim de focar em tarefas de n√≠vel superior no futuro. <br><a name="habracut"></a><br><h2>  Conceito de motor </h2><br>  O mecanismo √© completamente escrito do zero em C ++ (com algumas exce√ß√µes, como encontrar um caminho).  Uso SDL2 para renderizar contexto e processar entradas, OpenGL para renderizar uma cena 3D e DearImgui para controlar a simula√ß√£o. <br><br>  Decidi usar voxels principalmente porque queria trabalhar com uma grade com muitas vantagens: <br><br><ul><li>  Criar malhas para renderiza√ß√£o √© bem compreendido para mim. </li><li>  Os recursos de armazenamento de dados do mundo s√£o mais diversos e compreens√≠veis. </li><li>  J√° criei sistemas para gerar simula√ß√µes de terreno e clima com base em malhas. </li><li>  As tarefas dos bots na grade s√£o mais f√°ceis de parametrizar. </li></ul><br>  O mecanismo consiste em um sistema de dados mundiais, um sistema de renderiza√ß√£o e v√°rias classes auxiliares (por exemplo, para processamento de som e entrada). <br><br>  No artigo, falarei sobre a lista atual de recursos, al√©m de examinar mais de perto os subsistemas mais complexos. <br><br><h3>  Classe mundial </h3><br>  A classe mundial serve como a classe base para armazenar todas as informa√ß√µes do mundo.  Ele lida com a gera√ß√£o, carregamento e armazenamento de dados em bloco. <br><br>  Os dados do bloco s√£o armazenados em peda√ßos de tamanho constante (16 ^ 3) e o mundo armazena o vetor de fragmento carregado na mem√≥ria virtual.  Nos mundos grandes, √© praticamente necess√°rio lembrar apenas uma certa parte do mundo, raz√£o pela qual escolhi essa abordagem. <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">World</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: World(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> _saveFile){ saveFile = _saveFile; loadWorld(); } <span class="hljs-comment"><span class="hljs-comment">//Data Storage std::vector&lt;Chunk&gt; chunks; //Loaded Chunks std::stack&lt;int&gt; updateModels; //Models to be re-meshed void bufferChunks(View view); //Generation void generate(); Blueprint blueprint; bool evaluateBlueprint(Blueprint &amp;_blueprint); //File IO Management std::string saveFile; bool loadWorld(); bool saveWorld(); //other... int SEED = 100; int chunkSize = 16; int tickLength = 1; glm::vec3 dim = glm::vec3(20, 5, 20); //...</span></span></code> </pre> <br>  Fragmentos armazenam dados de bloco, bem como alguns outros metadados, em uma matriz plana.  Inicialmente, implementei minha pr√≥pria √°rvore de octree esparsa para armazenar fragmentos, mas o tempo de acesso aleat√≥rio √© muito alto para criar malhas.  E, embora uma matriz plana n√£o seja ideal do ponto de vista da mem√≥ria, ela oferece a capacidade de criar malhas e manipula√ß√µes muito rapidamente com blocos, al√©m de acessar o caminho de pesquisa. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Chunk</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//Position information and size information glm::vec3 pos; int size; BiomeType biome; //Data Storage Member int data[16*16*16] = {0}; bool refreshModel = false; //Get the Flat-Array Index int getIndex(glm::vec3 _p); void setPosition(glm::vec3 _p, BlockType _type); BlockType getPosition(glm::vec3 _p); glm::vec4 getColorByID(BlockType _type); };</span></span></code> </pre> <br>  Se alguma vez eu implementar fragmentos de salvamento e carregamento com v√°rios threads, converter uma matriz plana em uma √°rvore octree esparsa e vice-versa pode ser uma op√ß√£o completamente poss√≠vel para economizar mem√≥ria.  Ainda h√° espa√ßo para otimiza√ß√£o! <br><br>  Minha implementa√ß√£o da √°rvore octree esparsa √© armazenada no c√≥digo, para que voc√™ possa us√°-la com seguran√ßa. <br><br><h4>  Armazenamento de fragmentos e manipula√ß√£o de mem√≥ria </h4><br>  Os fragmentos s√£o vis√≠veis apenas quando est√£o dentro da dist√¢ncia de renderiza√ß√£o da posi√ß√£o atual da c√¢mera.  Isso significa que, quando a c√¢mera se move, voc√™ precisa carregar e compor dinamicamente fragmentos nas malhas. <br><br>  Os fragmentos s√£o serializados usando a biblioteca de refor√ßo, e os dados mundiais s√£o armazenados como um arquivo de texto simples, no qual cada fragmento √© uma linha do arquivo.  Eles s√£o gerados em uma ordem espec√≠fica para que possam ser "ordenados" em um arquivo mundial.  Isso √© importante para novas otimiza√ß√µes. <br><br>  No caso de um mundo grande, o principal gargalo √© a leitura do arquivo mundial e o carregamento / grava√ß√£o de fragmentos.  Idealmente, precisamos apenas baixar e transferir o arquivo mundial. <br><br>  Para fazer isso, o m√©todo <code>World::bufferChunks()</code> remove fragmentos que est√£o na mem√≥ria virtual, mas s√£o invis√≠veis, e carrega de forma inteligente novos fragmentos do arquivo mundial. <br><br>  Por intelig√™ncia entende-se que ele simplesmente decide quais novos fragmentos carregar, classificando-os por sua posi√ß√£o no arquivo salvo e, em seguida, fazendo uma passagem.  Tudo √© muito simples. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> World::bufferChunks(View view){ <span class="hljs-comment"><span class="hljs-comment">//Load / Reload all Visible Chunks evaluateBlueprint(blueprint); //Chunks that should be loaded glm::vec3 a = glm::floor(view.viewPos/glm::vec3(chunkSize))-view.renderDistance; glm::vec3 b = glm::floor(view.viewPos/glm::vec3(chunkSize))+view.renderDistance; //Can't exceed a certain size a = glm::clamp(a, glm::vec3(0), dim-glm::vec3(1)); b = glm::clamp(b, glm::vec3(0), dim-glm::vec3(1)); //Chunks that need to be removed / loaded std::stack&lt;int&gt; remove; std::vector&lt;glm::vec3&gt; load; //Construct the Vector of chunks we should load for(int i = ax; i &lt;= bx; i ++){ for(int j = ay; j &lt;= by; j ++){ for(int k = az; k &lt;= bz; k ++){ //Add the vector that we should be loading load.push_back(glm::vec3(i, j, k)); } } } //Loop over all existing chunks for(unsigned int i = 0; i &lt; chunks.size(); i++){ //Check if any of these chunks are outside of the limits if(glm::any(glm::lessThan(chunks[i].pos, a)) || glm::any(glm::greaterThan(chunks[i].pos, b))){ //Add the chunk to the erase pile remove.push(i); } //Don't reload chunks that remain for(unsigned int j = 0; j &lt; load.size(); j++){ if(glm::all(glm::equal(load[j], chunks[i].pos))){ //Remove the element from load load.erase(load.begin()+j); } } //Flags for the Viewclass to use later updateModels = remove; //Loop over the erase pile, delete the relevant chunks. while(!remove.empty()){ chunks.erase(chunks.begin()+remove.top()); remove.pop(); } //Check if we want to load any guys if(!load.empty()){ //Sort the loading vector, for single file-pass std::sort(load.begin(), load.end(), [](const glm::vec3&amp; a, const glm::vec3&amp; b) { if(ax &gt; bx) return true; if(ax &lt; bx) return false; if(ay &gt; by) return true; if(ay &lt; by) return false; if(az &gt; bz) return true; if(az &lt; bz) return false; return false; }); boost::filesystem::path data_dir( boost::filesystem::current_path() ); data_dir /= "save"; data_dir /= saveFile; std::ifstream in((data_dir/"world.region").string()); Chunk _chunk; int n = 0; while(!load.empty()){ //Skip Lines (this is dumb) while(n &lt; load.back().x*dim.z*dim.y+load.back().y*dim.z+load.back().z){ in.ignore(1000000,'\n'); n++; } //Load the Chunk { boost::archive::text_iarchive ia(in); ia &gt;&gt; _chunk; chunks.push_back(_chunk); load.pop_back(); } } in.close(); } }</span></span></code> </pre> <br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Seu navegador n√£o suporta v√≠deo HTML5. <source src="http://weigert.vsos.ethz.ch/wp-content/uploads/2019/10/chunkload.mp4" type="video/mp4"></video></div></div></div><br>  <i>Um exemplo de carregamento de fragmentos com uma pequena dist√¢ncia de renderiza√ß√£o.</i>  <i>Os artefatos de distor√ß√£o da tela s√£o causados ‚Äã‚Äãpelo software de grava√ß√£o de v√≠deo.</i>  <i>√Äs vezes ocorrem picos vis√≠veis nos downloads, causados ‚Äã‚Äãprincipalmente por malhas</i> <br><br>  Al√©m disso, defino um sinalizador indicando que o renderizador deve recriar a malha do fragmento carregado. <br><br><h4>  Classe Blueprint e editBuffer </h4><br>  O editBuffer √© um cont√™iner bufferObjects classific√°vel que cont√©m informa√ß√µes sobre edi√ß√£o no espa√ßo do mundo e no espa√ßo do fragmento. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//EditBuffer Object Struct struct bufferObject { glm::vec3 pos; glm::vec3 cpos; BlockType type; }; //Edit Buffer! std::vector&lt;bufferObject&gt; editBuffer;</span></span></code> </pre> <br>  Se, ao fazer altera√ß√µes no mundo, grav√°-las em um arquivo imediatamente ap√≥s a altera√ß√£o, teremos que transferir o arquivo de texto inteiro e escrever TODAS as altera√ß√µes.  Isso √© terr√≠vel em termos de desempenho. <br><br>  Ent√£o, primeiro escrevo todas as altera√ß√µes que precisam ser feitas no editBuffer usando o m√©todo addEditBuffer (que tamb√©m calcula a posi√ß√£o das altera√ß√µes no espa√ßo do fragmento).  Antes de grav√°-las em um arquivo, classifico as altera√ß√µes na ordem dos fragmentos aos quais eles pertencem, de acordo com a localiza√ß√£o no arquivo. <br><br>  A grava√ß√£o de altera√ß√µes em um arquivo consiste em uma transfer√™ncia de arquivo, o carregamento de cada linha (ou seja, fragmento), para o qual h√° altera√ß√µes no editBuffer, fazendo todas as altera√ß√µes e gravando-o em um arquivo tempor√°rio at√© o editBuffer ficar vazio.  Isso √© feito na fun√ß√£o <code>evaluateBlueprint()</code> , que √© r√°pida o suficiente. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> World::evaluateBlueprint(Blueprint &amp;_blueprint){ <span class="hljs-comment"><span class="hljs-comment">//Check if the editBuffer isn't empty! if(_blueprint.editBuffer.empty()){ return false; } //Sort the editBuffer std::sort(_blueprint.editBuffer.begin(), _blueprint.editBuffer.end(), std::greater&lt;bufferObject&gt;()); //Open the File boost::filesystem::path data_dir(boost::filesystem::current_path()); data_dir /= "save"; data_dir /= saveFile; //Load File and Write File std::ifstream in((data_dir/"world.region").string()); std::ofstream out((data_dir/"world.region.temp").string(), std::ofstream::app); //Chunk for Saving Data Chunk _chunk; int n_chunks = 0; //Loop over the Guy while(n_chunks &lt; dim.x*dim.y*dim.z){ if(in.eof()){ return false; } //Archive Serializers boost::archive::text_oarchive oa(out); boost::archive::text_iarchive ia(in); //Load the Chunk ia &gt;&gt; _chunk; //Overwrite relevant portions while(!_blueprint.editBuffer.empty() &amp;&amp; glm::all(glm::equal(_chunk.pos, _blueprint.editBuffer.back().cpos))){ //Change the Guy _chunk.setPosition(glm::mod(_blueprint.editBuffer.back().pos, glm::vec3(chunkSize)), _blueprint.editBuffer.back().type); _blueprint.editBuffer.pop_back(); } //Write the chunk back oa &lt;&lt; _chunk; n_chunks++; } //Close the fstream and ifstream in.close(); out.close(); //Delete the first file, rename the temp file boost::filesystem::remove_all((data_dir/"world.region").string()); boost::filesystem::rename((data_dir/"world.region.temp").string(),(data_dir/"world.region").string()); //Success! return true; }</span></span></code> </pre> <br>  A classe blueprint cont√©m editBuffer, bem como v√°rios m√©todos que permitem criar editBuffers para objetos espec√≠ficos (√°rvores, cactos, cabanas etc.).  Em seguida, o blueprint pode ser convertido para a posi√ß√£o em que voc√™ deseja colocar o objeto e, em seguida, basta grav√°-lo na mem√≥ria do mundo. <br><br>  Uma das maiores dificuldades ao trabalhar com fragmentos √© que altera√ß√µes em v√°rios blocos entre os limites dos fragmentos podem se tornar um processo mon√≥tono com muito m√≥dulo aritm√©tico e dividir as altera√ß√µes em v√°rias partes.  Esse √© o principal problema que a classe blueprint trata de maneira brilhante. <br><br>  Eu o uso ativamente no est√°gio de gera√ß√£o mundial para expandir o "gargalo" de gravar altera√ß√µes em um arquivo. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> World::generate(){ <span class="hljs-comment"><span class="hljs-comment">//Create an editBuffer that contains a flat surface! blueprint.flatSurface(dim.x*chunkSize, dim.z*chunkSize); //Write the current blueprint to the world file. evaluateBlueprint(blueprint); //Add a tree Blueprint _tree; evaluateBlueprint(_tree.translate(glm::vec3(x, y, z))); }</span></span></code> </pre> <br>  A classe mundial armazena seu pr√≥prio modelo de altera√ß√µes feitas no mundo, de modo que, quando bufferChunks () √© chamado, todas as altera√ß√µes s√£o gravadas no disco r√≠gido de uma s√≥ vez e exclu√≠das da mem√≥ria virtual. <br><br><h3>  Renderiza√ß√£o </h3><br>  O renderizador em sua estrutura n√£o √© muito complicado, mas requer conhecimento do OpenGL para entender.  Nem todas as partes s√£o interessantes, principalmente s√£o wrappers de funcionalidade OpenGL.  Eu experimentei a visualiza√ß√£o por algum tempo para obter o que eu gosto. <br><br>  Como a simula√ß√£o n√£o √© da primeira pessoa, escolhi a proje√ß√£o ortogr√°fica.  Ele poderia ser implementado no formato pseudo-3D (ou seja, para pr√©-projetar blocos e sobrepor-los em um renderizador de software), mas me pareceu tolo.  Estou feliz por ter mudado para o OpenGL. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/61e/923/40e/61e92340e2801dc8f6dd63b54badc438.png"></div><br>  A classe base para renderiza√ß√£o √© chamada View, cont√©m a maioria das vari√°veis ‚Äã‚Äãimportantes que controlam a visualiza√ß√£o da simula√ß√£o: <br><br><ul><li>  Tamanho da tela e textura de sombra </li><li>  Objetos shader, c√¢mera, matriz, etc. fatores de zoom </li><li>  Valores booleanos para quase todas as fun√ß√µes do renderizador <ul><li>  Menu, neblina, profundidade de campo, textura de gr√£o, etc. </li></ul></li><li>  Cores para ilumina√ß√£o, nevoeiro, c√©u, sele√ß√£o de janelas, etc. </li></ul><br>  Al√©m disso, existem v√°rias classes auxiliares que executam a renderiza√ß√£o e o empacotamento do pr√≥prio OpenGL! <br><br><ul><li>  Sombreador de classe <ul><li>  Carrega, compila, compila e usa sombreadores GLSL </li></ul></li><li>  Classe de modelo <ul><li>  Cont√©m fragmentos de dados VAO (Vertex Arrays Object) para renderiza√ß√£o, a fun√ß√£o de cria√ß√£o de malhas e o m√©todo de renderiza√ß√£o. </li></ul></li><li>  Quadro de avisos da classe <ul><li>  Cont√©m o FBO (FrameBuffer Object) para renderizar como √∫til para criar efeitos de p√≥s-processamento e sombreamento. </li></ul></li><li>  Classe Sprite <ul><li>  Desenha uma orienta√ß√£o quadrilateral em rela√ß√£o √† c√¢mera, carregada de um arquivo de textura (para bots e objetos).  Tamb√©m pode lidar com anima√ß√µes! </li></ul></li><li>  Classe de interface <ul><li>  Para trabalhar com o ImGUI </li></ul></li><li>  Aula de √°udio <ul><li>  Suporte de som muito rudimentar (se voc√™ compilar o mecanismo, pressione "M") </li></ul></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e5/0f3/ef6/6e50f3ef66d7d71dd5ae76b94b3c168a.png"></div><br>  <i>Profundidade de campo alta (DOF).</i>  <i>Em grandes dist√¢ncias de renderiza√ß√£o, pode ser lento, mas fiz tudo isso no meu laptop.</i>  <i>Talvez em um bom computador os freios sejam invis√≠veis.</i>  <i>Entendo que isso estressa meus olhos e o fez apenas por divers√£o.</i> <br><br>  A imagem acima mostra alguns par√¢metros que podem ser alterados durante a manipula√ß√£o.  Tamb√©m implementei a mudan√ßa para o modo de tela cheia.  A imagem mostra um exemplo de um sprite de rob√¥ renderizado como um quadril√°tero texturizado direcionado para a c√¢mera.  As casas e cactos na imagem s√£o constru√≠dos usando o blueprint. <br><br><h4>  Criando malhas de fragmentos </h4><br>  Inicialmente, usei a vers√£o ing√™nua da cria√ß√£o de malhas: simplesmente criei um cubo e descartei v√©rtices que n√£o tocavam no espa√ßo vazio.  No entanto, essa solu√ß√£o foi lenta e, ao carregar novos fragmentos, a cria√ß√£o de malhas acabou sendo "gargalos" ainda mais estreitos do que o acesso ao arquivo. <br><br>  O principal problema foi a cria√ß√£o eficiente de VBOs renderizados a partir de fragmentos, mas consegui implementar em C ++ minha pr√≥pria vers√£o do ‚Äúgreedy meshing‚Äù, compat√≠vel com o OpenGL (sem estruturas estranhas com loops).  Voc√™ pode usar meu c√≥digo com a consci√™ncia limpa. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Model::fromChunkGreedy(Chunk chunk){ <span class="hljs-comment"><span class="hljs-comment">//... (this is part of the model class - find on github!) }</span></span></code> </pre> <br>  Em geral, a transi√ß√£o para a malha gananciosa reduziu o n√∫mero de quadr√¢ngulos desenhados em uma m√©dia de 60%.  Depois, ap√≥s outras otimiza√ß√µes menores (indexa√ß√£o VBO), o n√∫mero foi reduzido em mais 1/3 (de 6 v√©rtices at√© a aresta para 4 v√©rtices). <br><br>  Ao renderizar uma cena de fragmentos 5x1x5 em uma janela que n√£o √© maximizada, recebo uma m√©dia de cerca de 140 FPS (com o VSYNC desativado). <br><br>  Embora eu esteja bastante satisfeito com esse resultado, ainda gostaria de criar um sistema para renderizar modelos n√£o-c√∫bicos a partir de dados mundiais.  N√£o √© t√£o f√°cil integrar-se com malhas gananciosas, por isso vale a pena considerar. <br><br><h4>  Shaders e destaque em voxel </h4><br>  A implementa√ß√£o dos shaders GLSL √© uma das partes mais interessantes e ao mesmo tempo as mais irritantes de escrever o mecanismo devido √† complexidade da depura√ß√£o na GPU.  Como n√£o sou especialista em GLSL, tive que aprender muito em qualquer lugar. <br><br>  Os efeitos que eu implementei usam ativamente o FBO e a amostragem de textura (por exemplo, desfoque, sombreamento e uso de informa√ß√µes de profundidade). <br><br>  Ainda n√£o gosto do modelo de ilumina√ß√£o atual, porque ele n√£o lida muito bem com o ‚Äúescuro‚Äù.  Espero que isso seja corrigido no futuro quando eu trabalhar no ciclo de mudan√ßa do dia e da noite. <br><br>  Tamb√©m implementei uma fun√ß√£o simples de sele√ß√£o de voxel usando o algoritmo de Bresenham modificado (essa √© outra vantagem do uso de voxels).  √â √∫til para obter informa√ß√µes espaciais durante a simula√ß√£o.  Minha implementa√ß√£o funciona apenas para proje√ß√µes ortogr√°ficas, mas voc√™ pode us√°-lo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c60/020/f2c/c60020f2cd1b4507152fdee4ef16e0ea.png"></div><br>  <i>Ab√≥bora "em destaque".</i> <br><br><h3>  Classes de jogo </h3><br>  V√°rias classes auxiliares foram criadas para processar entradas, mensagens de depura√ß√£o e tamb√©m uma classe Item separada com funcionalidade b√°sica (que ser√° expandida ainda mais). <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">eventHandler</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-comment"><span class="hljs-comment">/* This class handles user input, creates an appropriate stack of activated events and handles them so that user inputs have continuous effect. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//Queued Inputs std::deque&lt;SDL_Event*&gt; inputs; //General Key Inputs std::deque&lt;SDL_Event*&gt; scroll; //General Key Inputs std::deque&lt;SDL_Event*&gt; rotate; //Rotate Key Inputs SDL_Event* mouse; //Whatever the mouse is doing at a moment SDL_Event* windowevent; //Whatever the mouse is doing at a moment bool _window; bool move = false; bool click = false; bool fullscreen = false; //Take inputs and add them to stack void input(SDL_Event *e, bool &amp;quit, bool &amp;paused); //Handle the existing stack every tick void update(World &amp;world, Player &amp;player, Population &amp;population, View &amp;view, Audio &amp;audio); //Handle Individual Types of Events void handlePlayerMove(World &amp;world, Player &amp;player, View &amp;view, int a); void handleCameraMove(World &amp;world, View &amp;view); };</span></span></code> </pre> <br>  Meu manipulador de eventos √© feio, mas funcional.  Terei prazer em aceitar recomenda√ß√µes para sua melhoria, especialmente no uso do SDL Poll Event. <br><br><h2>  √öltimas notas </h2><br>  O mecanismo em si √© apenas um sistema no qual coloco meus bots de tarefas (falarei sobre eles em detalhes no pr√≥ximo post).  Mas se voc√™ achou meus m√©todos interessantes e deseja saber mais, escreva para mim. <br><br>  Ent√£o eu enviei o sistema de bot de tarefas (o verdadeiro cora√ß√£o deste projeto) para o mundo 3D e ampliei significativamente seus recursos, mas mais sobre isso mais tarde (no entanto, o c√≥digo j√° foi publicado online)! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt474414/">https://habr.com/ru/post/pt474414/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt474400/index.html">Mitos sobre a disponibilidade do contraste de cores</a></li>
<li><a href="../pt474402/index.html">Guia da API de cole√ß√µes do Vavr</a></li>
<li><a href="../pt474404/index.html">An√°lise dos problemas resolvidos do campeonato de programa√ß√£o da Yandex (desenvolvimento front-end) 2019</a></li>
<li><a href="../pt474406/index.html">Primeira apari√ß√£o do BlueKeep na natureza gravada</a></li>
<li><a href="../pt474408/index.html">Revolu√ß√£o ou evolu√ß√£o do Modelo de Objetos de P√°gina?</a></li>
<li><a href="../pt474418/index.html">Confer√™ncia DEFCON 27. Beneficiando-se de produtos de hackers para o macOS. Parte 1</a></li>
<li><a href="../pt474420/index.html">Forma√ß√£o do termostato: como aconteceu</a></li>
<li><a href="../pt474422/index.html">Plataformas de c√≥digo aberto fascinantes para o desenvolvimento de aplicativos m√≥veis</a></li>
<li><a href="../pt474424/index.html">Treinamento combinado - o que √© e como funciona</a></li>
<li><a href="../pt474426/index.html">A s√©rie animada "C√≠rculo Matem√°tico"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>