<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖨️ 🤷🏻 🌻 从零开始开发六脚架（第4部分）-数学轨迹和序列 🌯 ⛴️ 🏩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好！ 六足动物的发展又向前迈了一步。 这次，肢体运动的轨迹得以实现和测试-运动数学的下一部分。 在本文中，我将讨论这些轨迹和运动的基本顺序。 我希望这会很有趣。 

 发展阶段： 
 第1部分-设计 
 第2部分-组装 
 第3部分-运动学 
 第4部分-数学轨迹和序列 
 第5部分-电子产品 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>从零开始开发六脚架（第4部分）-数学轨迹和序列</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444070/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ft/93/m5/ft93m5szh_bfaxkmnxialxpkoiu.png"></div><br> 大家好！ 六足动物的发展又向前迈了一步。 这次，肢体运动的轨迹得以实现和测试-运动数学的下一部分。 在本文中，我将讨论这些轨迹和运动的基本顺序。 我希望这会很有趣。 <br><br>  <b>发展阶段：</b> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1部分-设计</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2部分-组装</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第3部分-运动学</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b>第4部分-数学轨迹和序列</b></a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第5部分-电子产品</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第6部分-过渡到3D打印</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第7部分-新外壳，应用软件和通信协议</a> <br><a name="habracut"></a><br><h2> 弹道 </h2><br> 该机制的本质是，当您设置两个点时，可以选择肢体的轨迹。 从一个点移动到另一个点时，坐标将根据某些参数方程式发生变化。 该机制非常强大，可以让您获得有趣的运动曲线。 它还可以通过更改参数t的步长来实现运动的平滑-步长越小，中间点越多，分别具有较低的速度和较高的运动平滑度。 <br><br> 在某些地方设置轨迹参数的过程有些令人费解，您可能会感到困惑。 困难在于以下事实：当设置起点和终点的坐标时，并不总是设置空间中实点的坐标，即 一些坐标设置轨迹参数。 我必须编写一个显示给定路径的程序，同时检查该路径各点的可达性。 <br><br> 驱动程序支持以下运动路径： <br><br><ol><li>  <b>XYZ_LINAR</b>是所有轨迹中最简单的。 在向前，向后，向上和向下移动时使用该轨迹。 所有坐标都是线性变化的，计算如下： <br><br><pre><code class="cpp hljs">x = t * (x1 - x0) / <span class="hljs-number"><span class="hljs-number">180.0f</span></span> + x0; y = t * (y1 - y0) / <span class="hljs-number"><span class="hljs-number">180.0f</span></span> + y0; z = t * (z1 - z0) / <span class="hljs-number"><span class="hljs-number">180.0f</span></span> + z0;</code> </pre> <br> 在这里我们知道没有问题。 坐标指定平行六面体角度，并且它们与真实坐标重合。 移动沿着盒子的对角线进行。 <br><br><div class="spoiler">  <b class="spoiler_title">轨迹可视化</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/t5/55/uy/t555uy9zum9cfwqa6hw4gwotdni.png"><br><img src="https://habrastorage.org/webt/bn/2n/p-/bn2np-sm7n7onhmvariez7_0jy4.png"><br><img src="https://habrastorage.org/webt/5p/g6/yw/5pg6yw_fpcqdxnr4lotb-n0so4u.png"><br></div></div><br></li><li>  <b>YZ_ARC_Y_LINEAR-</b>此轨迹允许您实现沿弧的移动。 当您需要在地面上移动肢体时，会使用该轨迹。 坐标计算如下： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> R = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(x0 * x0 + z0 * z0); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> atan0 = RAD_TO_DEG(<span class="hljs-built_in"><span class="hljs-built_in">atan2</span></span>(x0, z0)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> atan1 = RAD_TO_DEG(<span class="hljs-built_in"><span class="hljs-built_in">atan2</span></span>(x1, z1)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t_mapped_rad = DEG_TO_RAD(t * (atan1 - atan0) / <span class="hljs-number"><span class="hljs-number">180.0f</span></span> + atan0); x = R * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(t_mapped_rad); <span class="hljs-comment"><span class="hljs-comment">// Circle Y y = t * (y1 - y0) / 180.0f + y0; z = R * cos(t_mapped_rad); // Circle X</span></span></code> </pre><br> 这就是乐趣的开始。 坐标指定了射线的方向以限制电弧，并且它们可能与实际坐标不一致。 光线在同一平面上，而圆的半径等于到起点的向量的长度。 <br><br><div class="spoiler">  <b class="spoiler_title">轨迹可视化</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ky/p0/dw/kyp0dwzfg-0t_qsrmwvstiwlweq.png"><br><br><img src="https://habrastorage.org/webt/ak/ng/ey/akngeyx2imiyht44jebbuydxyaw.png"><br></div></div><br></li><li>  <b>XZ_ARC_Y_SINUS-</b>此轨迹还允许您实现沿弧的移动，但比YZ_ARC_Y_LINEAR复杂。 当需要在空中移动肢体时，会使用该轨迹。 坐标计算如下： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> R = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(x0 * x0 + z0 * z0); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> atan0 = RAD_TO_DEG(<span class="hljs-built_in"><span class="hljs-built_in">atan2</span></span>(x0, z0)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> atan1 = RAD_TO_DEG(<span class="hljs-built_in"><span class="hljs-built_in">atan2</span></span>(x1, z1)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t_mapped_rad = DEG_TO_RAD(t * (atan1 - atan0) / <span class="hljs-number"><span class="hljs-number">180.0f</span></span> + atan0); x = R * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(t_mapped_rad); <span class="hljs-comment"><span class="hljs-comment">// circle Y y = (y1 - y0) * sin(DEG_TO_RAD(t)) + y0; z = R * cos(t_mapped_rad); // circle X</span></span></code> </pre><br> 乐趣继续。 坐标还指定了射线的方向以限制圆弧，但它们与实际坐标不一致。 目标点的Y坐标设置正弦高度。 <br><br><div class="spoiler">  <b class="spoiler_title">轨迹可视化</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/t6/2g/tf/t62gtfnlk7nwgibcchhawz2ug4e.png"><br></div></div><br></li><li>  <b>XZ_ELLIPTICAL_Y_SINUS-</b>此轨迹允许您实现沿椭圆的运动。 当需要在空中移动肢体时，可使用轨迹进行前后移动。 该轨迹是XZ_ARC_Y_SINUS的复杂部分，仅由于使用XZ_ARC_Y_SINUS时视觉上步态难看（步长太大）而需要使用。 坐标计算如下： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = (z1 - z0) / <span class="hljs-number"><span class="hljs-number">2.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = (x1 - x0); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> c = (y1 - y0); x = b * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(DEG_TO_RAD(<span class="hljs-number"><span class="hljs-number">180.0f</span></span> - t)) + x0; <span class="hljs-comment"><span class="hljs-comment">// circle Y y = c * sin(DEG_TO_RAD(t)) + y0; z = a * cos(DEG_TO_RAD(180.0f - t)) + z0 + a;</span></span></code> </pre><br> 坐标指定平行六面体角度，它们与真实坐标不重合。 移动发生在盒子的下角，位于与触摸部件顶部相同的平面上。 最好看一下扰流板中的图片，我不知道该如何简单地用文字来描述。 <br><br><div class="spoiler">  <b class="spoiler_title">轨迹可视化</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/pn/3x/4w/pn3x4wot6ajk1ofy4wl7rtjyp1y.png"><br></div></div></li></ol><br> 这样就完成了六脚架运动的基本数学运算。 在我的项目中，这是几乎所有动作实施的必要最低要求。 <br><br><h2> 顺序 </h2><br><h3> 一点理论 </h3><br> 顺序是构成步态的基本动作。 它们分为周期性和非周期性。 <br><br><ul><li> 循环序列可以执行多次，并且在每个循环结束时应使肢体返回其原始位置（运动和旋转）； </li><li> 非循环序列仅执行一次（上升和下降）。 </li></ul><br> 每个序列具有三个迭代块：准备块，主块，完成块。 <br><br><ul><li> 训练块-包含将肢体移动到序列的起始位置的迭代。 就我而言，向前移动需要在开始移动之前将双脚置于一定位置。 转换到序列后执行一次； </li><li> 主块-包含序列的主迭代。 它可以循环执行； </li><li> 块完成-包含将肢体移动到基本位置（举起后肢体放置的位置）的迭代； </li></ul><br> 下图显示了前进的顺序。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yt/yf/vw/ytyfvwd1slowqjmordig0qenioa.png"></div><br><ul><li> 红点表示四肢开始运动之前的初始位置 </li><li> 蓝线表示地面上肢体的轨迹 </li><li> 黑线表示空中肢体的运动轨迹 </li><li> 箭头指示顺序 </li></ul><br> 点的坐标是根据外壳的配置选择的。 我选择了尽可能靠近身体的点以减少杠杆的长度。 在该序列的一个周期中，六脚架移动了18厘米（在1个周期中，执行2步-3个肢体中执行1步）。 如果使距离更大，则四肢将开始相互紧贴。 此参数仅受案例配置限制。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/67/hs/0b/67hs0bhvmyfefjvvxyb0qh0lojy.png"></div><br> 该序列由每个肢体的两个点（1、2）定义，并使用两个路径：XYZ_LINEAR（蓝线）和XZ_ELLIPTICAL_Y_SINUS（黑线）。  XZ_ELLIPTICAL_Y_SINUS轨迹使用点1来设置正弦高度，并相应地设置脚的上升高度。 点2和3是肢体在移动时到达的真实点。 <br><br> 点的位置仅取决于您的想象力和六足动物的能力。 也许这一切都变得有点复杂，并且有一个更简单的选择，但是显然我还没有达到目标。 <br><br><h3> 实作 </h3><br> 现在，让我们看看所有这些幸福的实现。 具有序列参数的结构如下： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">point_3d_t</span></span> point_list[SUPPORT_LIMB_COUNT]; <span class="hljs-keyword"><span class="hljs-keyword">path_type_t</span></span> path_list[SUPPORT_LIMB_COUNT]; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> smooth_point_count; } <span class="hljs-keyword"><span class="hljs-keyword">sequence_iteration_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_sequence_looped; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> main_sequence_begin; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> finalize_sequence_begin; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> total_iteration_count; <span class="hljs-keyword"><span class="hljs-keyword">sequence_iteration_t</span></span> iteration_list[<span class="hljs-number"><span class="hljs-number">15</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">sequence_id_t</span></span> available_sequences[SUPPORT_SEQUENCE_COUNT]; } <span class="hljs-keyword"><span class="hljs-keyword">sequence_info_t</span></span>;</code> </pre> <br>  <b>sequence_iteration_t-</b>包含有关序列迭代的信息： <br><br><ul><li>  point_list-XYZ格式的每个肢体的点数组； </li><li>  path_list-每个肢体的轨迹数组； </li><li>  smooth_point_count-设置路径点的数量（参数步骤t）； </li></ul><br>  <b>sequence_info_t-</b>包含有关整个序列的信息： <br><br><ul><li>  is_sequence_looped-设置序列类型：循环或非循环； </li><li>  main_sequence_begin-设置迭代列表数组中主块的起始索引； </li><li>  finalize_sequence_begin-设置eration_list数组中完成块的起始索引； </li><li>  total_iteration_count-设置序列中的迭代次数； </li><li>  eration_list-迭代数组； </li><li>  available_sequences-设置可用于从当前序列过渡的序列列表（例如，我们必须先从地板上站起来才能开始行走）； </li></ul><br>  <i>注意：没有有意指示准备块的索引；它始终位于迭代数组的开头。</i> <i><br></i> <br> 不幸的是，我在这里无法想象序列定义代码，因为 它很宽，传输后看起来很糟糕。 我只在此处保留指向<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">定义文件</a>的链接。 <br><br><h3> 运动处理方案 </h3><br> 找出序列在运行时经历的所有地狱是值得的。 处理方案如下： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hz/bd/h-/hzbdh-sihkvi9t9lmxn73igosv8.png"></div><br><ol><li>  <b>运动引擎</b> -组织处理和序列之间的切换。 在那里不执行任何计算。 如果得到简化，则在当前处理完成后，该模块会将下一个点滑至LIBMS DRIVER模块。 <br>  <i>模块输入：目标点的坐标数组。</i> <i><br></i>  <i>模块输出：序列当前迭代的目标点。</i> </li><li>  <b>LIBMS DRIVER</b>是所有模块中最复杂的模块。 运动的所有数学都在这里占主导地位：逆运动学，轨迹计算和运动平滑。 该模块与PWM模块具有严格的同步。 计算分别以150Hz的频率进行，驱动器的控制脉冲也以150Hz的频率提供。 <br>  <i>模块输入：目标点的坐标。</i> <i><br></i>  <i>模块输出：伺服旋转角度。</i> </li><li>  <b>伺服驱动器</b> 。 除了一堆用于设置和调整驱动器的参数外，它没有什么特别的。 <br>  <i>模块输入：伺服旋转角度。</i> <i><br></i>  <i>模块输出：控制脉冲宽度。</i> </li><li>  <b>PWM驱动器</b> 。 用于驱动器控制的PWM驱动器软件。 在这里，针脚仅在适当的时间抽搐。  PWM同步同步变量在每个PWM周期增加。 <br>  <i>模块输入：控制脉冲宽度。</i> <i><br></i>  <i>模块输出：控制引脚上的脉冲。</i> </li></ol><br> 我试图使模块彼此独立，我成功了。 这样，您就可以在该电路中插入任何中间模块（例如，景观的适配模块），并且不会有任何东西同时中断，而实现只需很少的代码更改即可完成。 <br><br><h2> 发现最新消息和项目小龙虾 </h2><br><div class="spoiler">  <b class="spoiler_title">最新消息</b> <div class="spoiler_text"><ol><li> 案例的新测试版本问世了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">（带有图纸存档）</a> ，我画了一点点。 将六脚架与驱动喷嘴固定在中间位置的完整组装需要7-8个小时的连续组装，并且考虑到我已经多次进行了此程序。 <br><br><div class="spoiler">  <b class="spoiler_title">照片</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/rj/ux/k0/rjuxk0f6rfsfinjvlr9j8elgpna.jpeg"><br><br><img src="https://habrastorage.org/webt/53/nk/it/53nkit0njb3bc_tslbr8ql2utwe.jpeg"><br><br><img src="https://habrastorage.org/webt/1p/kj/cs/1pkjcsdujiutmq5ueqgtaeqjvxk.jpeg"><br><br><img src="https://habrastorage.org/webt/yw/ll/_0/ywll_0aat4jlvvx-ayq1byjbkz0.jpeg"><br></div></div></li><li> 我在上面放了一个OLED显示器来显示某种信息，结果非常好。 <br><div class="spoiler">  <b class="spoiler_title">照片</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/gf/g8/q1/gfg8q1mn_1brvu8vlbl84uj2d4s.jpeg"><br><br><img src="https://habrastorage.org/webt/pb/6n/gl/pb6ngln4uduzi3ivvdea5bda4gs.jpeg"><br></div></div></li><li> 通过WIFI开始通讯。 现在可以通过电话进行控制（工具必须自己编写） </li><li> 由于电源板过热问题，电源电压从12V降低到7V </li><li> 在开发的第5部分发布时，我将发布到资源的链接，他们最终获得了一个不以羞辱向人们展示的状态 </li></ol><br></div></div><br><div class="spoiler">  <b class="spoiler_title">发现小龙虾</b> <div class="spoiler_text"><ol><li>  HC-SR04。 我知道这个传感器不好，但是我不这么认为。 通常，您需要使用其他测距仪 </li><li>  MG996R不符合声明的规格。 他们承诺12kg \ cm-实际上在300Hz的PWM频率下为5kg \ cm，在50Hz时甚至更糟，而且除了模拟以外（他们承诺提供一个数字）。 仅适用于转弯。 我不得不改用20公斤/厘米的更昂贵的数字驱动器DS3218-实际上是23公斤/厘米 </li><li> 我每隔10度就编制一个角动量表，并注意到MG996R的控制脉冲宽度彼此之间的距离不同。 我必须为每个驱动器制作校准表，并分别计算脉冲。 <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ez/9e/my/ez9emybwzomnlc0vxeslvl0l_im.png"></div><br> 如您所见，每个驱动器的脉冲间距都不同，这对我来说是一个意外的发现。 </li><li> 脉冲的最小，最大和中心值因驱动器的喷嘴而异（无论怎么说，它仍然不平滑）。 该图显示了对其施加1500us脉冲的驱动器，可以看出一个喷嘴不在中心，因此必须调节脉冲，以使所有喷嘴都位于同一位置。 <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qv/md/bs/qvmdbsnasfavacafddclxdbug4o.jpeg"></div><br></li></ol><br> 顺便说一下，我使用此设备进行了校准： <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/vx/de/pbvxdeg2clwcwtnh3ynnb9zg-d8.jpeg"></div><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN444070/">https://habr.com/ru/post/zh-CN444070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN444058/index.html">当孩子们知道他们的一生已经在线时</a></li>
<li><a href="../zh-CN444060/index.html">从Nagios迁移到澳大利亚的Icinga2</a></li>
<li><a href="../zh-CN444062/index.html">点亮！ 拉赫塔中心的夜间改造</a></li>
<li><a href="../zh-CN444064/index.html">崭新的未来的新思路</a></li>
<li><a href="../zh-CN444068/index.html">谁在看？</a></li>
<li><a href="../zh-CN444072/index.html">Android购物-Play帐单库</a></li>
<li><a href="../zh-CN444074/index.html">物联网：四个技术故事</a></li>
<li><a href="../zh-CN444076/index.html">我如何击败TP4056</a></li>
<li><a href="../zh-CN444078/index.html">Linux 5.1内核-有关更改的已知信息</a></li>
<li><a href="../zh-CN444082/index.html">290号移动开发人员的有趣材料摘要（3月11日至3月17日）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>