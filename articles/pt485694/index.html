<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüè´ üé∏ üíª Embox no processador Elbrus. Ou nunca esque√ßa o que voc√™ obteve em intelig√™ncia üåº ü§∞üèΩ üèµÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo √© a conclus√£o l√≥gica de uma s√©rie de artigos sobre "escalada Elbrus" sobre a introdu√ß√£o da arquitetura de processador Embox √† Elbrus (E2K)...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Embox no processador Elbrus. Ou nunca esque√ßa o que voc√™ obteve em intelig√™ncia</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/embox/blog/485694/"><img src="https://habrastorage.org/webt/ic/4z/5o/ic4z5olelesc04boln85goculk4.png" align="right" width="320">  Este artigo √© a conclus√£o l√≥gica de uma <a href="https://habr.com/ru/company/embox/blog/447704/">s√©rie de</a> <a href="https://habr.com/ru/company/embox/blog/447744/">artigos</a> sobre <a href="https://habr.com/ru/company/embox/blog/421441/">"escalada Elbrus"</a> <a href="https://habr.com/ru/company/embox/blog/447744/">sobre</a> a introdu√ß√£o da <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BB%25D1%258C%25D0%25B1%25D1%2580%25D1%2583%25D1%2581_2000">arquitetura de processador</a> <a href="http://embox.github.io/">Embox</a> √† <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BB%25D1%258C%25D0%25B1%25D1%2580%25D1%2583%25D1%2581_2000">Elbrus (E2K)</a> .  Por que uma conclus√£o l√≥gica, porque, como resultado, foi poss√≠vel executar atrav√©s do telnet um aplicativo que exibe a imagem na tela, ou seja, para obter a opera√ß√£o completa da Embox nessa arquitetura.  Pesquisas posteriores dificilmente podem ser chamadas de introdu√ß√£o, embora, √© claro, muito permane√ßa incerto.  E a arquitetura em si tem muitos recursos interessantes, que tamb√©m n√£o s√£o atualmente compreendidos.  Neste artigo, focaremos na organiza√ß√£o da mem√≥ria virtual, abordaremos o PCI, falaremos um pouco sobre uma placa de rede e abordaremos uma placa de v√≠deo em um hardware espec√≠fico que possu√≠mos. <a name="habracut"></a><br><br>  Para quem tem pregui√ßa de ler o artigo, darei imediatamente um pequeno v√≠deo com os resultados. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/FqOSFJ36B48" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  E agora, para quem estiver interessado, revelaremos os detalhes t√©cnicos que pudemos entender no processo. <br><br><h3>  Mem√≥ria virtual </h3><br><h4>  Nosso erro de pilha </h4><br>  Vamos come√ßar com a mem√≥ria virtual.  Na verdade, foi nisso que decidimos no <a href="https://habr.com/ru/company/embox/blog/447744/">artigo</a> anterior <a href="https://habr.com/ru/company/embox/blog/447744/">da</a> s√©rie.  Vale lembrar imediatamente por que precis√°vamos de mem√≥ria virtual, porque a Embox pode funcionar sem ela.  √â simples: a coisa √© fazer cache.  Vidyaha funcionou, mas eu tive que gravar a mesma coisa duas vezes na mem√≥ria de v√≠deo para obter uma recupera√ß√£o de imagem confi√°vel.  Obviamente, era poss√≠vel lidar com o cache, mas nossos exemplos envolvem o uso de mem√≥ria de v√≠deo diretamente de um aplicativo do usu√°rio, sem nenhum material nuclear, como gerenciamento de cache, por isso foi correto aprender como mapear a mem√≥ria como n√£o armazen√°vel em cache.  O mesmo pode ser feito no Linux, mapeando fb ( <a href="http://dmilvdv.narod.ru/Translate/ELSDD/elsdd_sample_frame_buffer_example.html">exemplo</a> ). <br><br>  Vale ressaltar que, embora n√£o escrevamos sobre Elbrus por um longo tempo e possa parecer que o MMU nessa arquitetura seja algum tipo de super complicado, mas a coisa √© diferente.  De fato, adicionamos apoio no ver√£o, simplesmente n√£o chegamos a nossas m√£os para escrever sobre isso.  Passamos muito tempo (v√°rios meses) devido ao nosso erro est√∫pido.  Este erro foi cometido no t√≠tulo do artigo ("Ou nunca esque√ßa o que voc√™ obteve durante a intelig√™ncia").  Estamos falando de pilhas com as quais lidamos muito bem e descrevemos isso no artigo Climbing <a href="https://habr.com/ru/company/embox/blog/447704/">Elbrus - Reconnaissance.</a>  <a href="https://habr.com/ru/company/embox/blog/447704/">Parte t√©cnica 1. Registros, pilhas e outros detalhes t√©cnicos</a> . <a href="https://habr.com/ru/company/embox/blog/447704/">"</a>  Sofremos por muito tempo, perdendo de vista estupidamente o fato de pegar a pilha inicial (na qual o sistema √© inicializado) de algum lugar externo e mapear tudo.  do que precisamos para a Embox funcionar, n√£o mapeamos esses dados. <br><br>  Abaixo do gato, darei uma nova fun√ß√£o e2k_entry, descrita no segundo artigo do <a href="https://habr.com/ru/company/embox/blog/447744/">artigo da s√©rie</a> . <br><br>  Se desejar, voc√™ pode comparar. <br><br><pre><code class="cpp hljs">__attribute__ ((__section__(<span class="hljs-string"><span class="hljs-string">".e2k_entry"</span></span>))) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e2k_entry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct pt_regs *regs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Since we enable exceptions only when all CPUs except the main one * reached the idle state (cpu_idle), we can rely that order and can * guarantee exceptions happen strictly after all CPUS entries. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entries_count &gt;= CPU_COUNT) { <span class="hljs-comment"><span class="hljs-comment">/* Entering here because of exception or interrupt */</span></span> e2k_trap_handler(regs); RESTORE_COMMON_REGS(regs); E2K_DONE; } <span class="hljs-comment"><span class="hljs-comment">/* It wasn't exception, so we decide this usual program execution, * that is, Embox started on CPU0 or CPU1 */</span></span> e2k_wait_all(); entries_count = __e2k_atomic32_add(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;entries_count); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entries_count &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* XXX currently we support only single core */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Run cpu_idle on 2nd CPU */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* it's just needed if log_debug enabled in e2k_context module * else output will be wrong because 2 cpu printing at the same time */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!sync_count); context_init(&amp;cpu_ctx[<span class="hljs-number"><span class="hljs-number">0</span></span>], CONTEXT_PRIVELEGED | CONTEXT_IRQDISABLE, cpu_idle, idle_stack, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(idle_stack)); context_switch(&amp;cpu_ctx_prev[<span class="hljs-number"><span class="hljs-number">0</span></span>], &amp;cpu_ctx[<span class="hljs-number"><span class="hljs-number">0</span></span>]); } <span class="hljs-comment"><span class="hljs-comment">/* Run e2k_kernel_start on 1st CPU */</span></span> context_init(&amp;cpu_ctx[<span class="hljs-number"><span class="hljs-number">1</span></span>], CONTEXT_PRIVELEGED | CONTEXT_IRQDISABLE, e2k_kernel_start, &amp;_stack_top, KERNEL_STACK_SZ); sync_count = __e2k_atomic32_add(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;sync_count); context_switch(&amp;cpu_ctx_prev[<span class="hljs-number"><span class="hljs-number">1</span></span>], &amp;cpu_ctx[<span class="hljs-number"><span class="hljs-number">1</span></span>]); }</code> </pre> <br>  Vou apenas explicar que agora usamos as fun√ß√µes context_init () e context_switch () apenas para mudar a pilha para a mem√≥ria no espa√ßo Embox.  E fazemos isso para todos os n√∫cleos, incluindo aqueles que n√£o s√£o usados. <br><br><h3>  Organiza√ß√£o da MMU </h3><br>  Agora vou falar um pouco sobre a organiza√ß√£o da MMU na arquitetura E2k. <br><br>  Em geral, a arquitetura MMU √© bastante comum e possui tabelas de quatro n√≠veis (ou tr√™s ao usar uma p√°gina de 4 MB). <br><br>  Existem v√°rios registros de servi√ßo na arquitetura E2k, que s√£o acessados ‚Äã‚Äãusando comandos de acesso a espa√ßos alternativos, bem como ao espa√ßo de E / S descrito brevemente no artigo <a href="https://habr.com/ru/company/embox/blog/421441/">"Embox come√ßa a escalar o Elbrus"</a> . <br><br>  Vamos precisar desses registros: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MMU_REG_CR 0x00 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Control register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MMU_REG_CONT 0x10 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Context register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MMU_REG_CR3_RG 0x20 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* CR3 register for INTEL only */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MMU_REG_ELB_PTB 0x30 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ELBRUS page table virtual base */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MMU_REG_ROOT_PTB 0x40 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Root Page Table Base register */</span></span></span><span class="hljs-meta">/</span></span></code> </pre> <br>  Na verdade, este √© um registro de controle, um registro de n√∫mero de contexto, um registro raiz de tabelas e um pouco obscuro MMU_REG_ELB_PTB.  Vamos come√ßar: esse registro deve ser definido com algum valor, os pr√≥ximos 512 GB ser√£o usados ‚Äã‚Äãpelo processador para as necessidades do equipamento e esses endere√ßos n√£o estar√£o dispon√≠veis para o programador.  Fornecerei explica√ß√µes da carta do especialista em ICST, mal posso explicar melhor: <br><br><blockquote>  No Linux, configuramos MMU_ELB_PTB para 0xff1 &lt;&lt; 39 e, em seguida, <br>  √°rea superior da mem√≥ria virtual (0xff8000000000 - 0xffffffffffff) <br>  reservado para as necessidades de equipamentos, ou seja, TLB.  Cada p√°gina <br>  A tabela de p√°ginas (TS) obt√©m seu endere√ßo exclusivo nessa √°rea, <br>  al√©m disso, esses endere√ßos s√£o facilmente obtidos no endere√ßo em que o programa <br>  apelou para a mem√≥ria.  E desde  TLB armazena mapeamentos de endere√ßos virtuais <br>  f√≠sico, isso permite armazenar em cache no mesmo buffer TLB <br>  transmite n√£o apenas para endere√ßos de usu√°rios, mas tamb√©m para o pr√≥prio ve√≠culo. <br><br>  Nos processadores / arquiteturas em que TLBs separados s√£o feitos para diferentes <br>  n√≠veis da tabela de p√°ginas, esse truque se torna desnecess√°rio. <br><br>  Assim, quando voc√™ perde o TLB, torna-se poss√≠vel n√£o iniciar a pesquisa <br>  do n√≠vel zero (pgd *) e verifique imediatamente o √∫ltimo n√≠vel do ve√≠culo (pte *). <br>  N√£o h√° nenhum requisito de hardware para mapear essa √°rea em si, Wirth.  endere√ßos de <br>  √© necess√°rio apenas como √≠ndices para pesquisa TLB.  No entanto, no cerne da <br>  o √∫ltimo pgd no n√≠vel zero da tabela de p√°ginas √© escrito nat.  o endere√ßo deste <br>  n√≠vel mais zero.  Como resultado, apenas <br>  os √∫ltimos 4 KB da √°rea ff80'0000'0000 - ffff'ffff'ffff - ou seja,  apenas certo <br>  n√≠vel zero do ve√≠culo.  Isso permite que o pgd * seja acessado por <br>  ler / escrever instru√ß√µes trabalhando em endere√ßos virtuais. </blockquote><br>  Como resultado, decidiu-se simplesmente colocar neste registro um grande valor, o que n√£o nos incomodar√°.  Afinal, a solu√ß√£o proposta nos permite otimizar a pesquisa de p√°ginas, mas ainda n√£o estamos envolvidos na otimiza√ß√£o.  Entregue o mesmo que no Linux. <br><br>  Agora, o registro de controle.  Voc√™ precisa habilitar o MMU atrav√©s dele.  Os bits conhecidos s√£o assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _MMU_CR_TLB_EN 0x0000000000000001 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* translation enable */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _MMU_CR_CD_MASK 0x0000000000000006 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* cache disable bits */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _MMU_CR_SET1 0x0000000000000008 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* set #1 enable for 4 MB pages */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _MMU_CR_SET2 0x0000000000000010 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* set #2 enable for 4 MB pages */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _MMU_CR_SET3 0x0000000000000020 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* set #3 enable for 4 MB pages */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* paging enable for second space INTEL */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _MMU_CR_CR0_PG 0x0000000000000040 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* page size 4Mb enable for second space INTEL */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _MMU_CR_CR4_PSE 0x0000000000000080 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* cache disable for secondary space INTEL */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _MMU_CR_CR0_CD 0x0000000000000100 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* TLU enable for secondary space INTEL */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _MMU_CR_TLU2_EN 0x0000000000000200 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* memory protection table enable for LD from secondary space INTEL */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _MMU_CR_LD_MPT 0x0000000000000400 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _MMU_CR_IPD_MASK 0x0000000000000800 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Instruction Prefetch Depth */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _MMU_CR_UPT_EN 0x0000000000001000 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* enable UPT */</span></span></span></span></code> </pre> <br>  Estamos interessados ‚Äã‚Äãno primeiro bit, que inclui a tradu√ß√£o de endere√ßos. <br><br>  Tamb√©m definimos _MMU_CR_SET3, mas ainda n√£o descobrimos em quais casos espec√≠ficos isso deve ser feito. <br><br>  Registo no concurso  Bem, se simples, esse √© o PID do processo ou espa√ßo de endere√ßo.  Mais tecnicamente, essa √© uma extens√£o de endere√ßo de 11 bits.  No nosso caso, tornamos todas as p√°ginas nucleares, definindo o pouco de globalidade em todas as nossas p√°ginas, usamos o mesmo espa√ßo de endere√ßo e, portanto, podemos usar zero nesse registro. <br><br>  No registro da tabela raiz, h√° um ponteiro para o endere√ßo f√≠sico do in√≠cio da tabela de convers√£o.  Voc√™ pode simplesmente fazer uma fraude mapeando a tabela tamb√©m para o endere√ßo especificado no registro MMU_REG_ELB_PTB, mas como eu disse, n√£o est√°vamos focados na otimiza√ß√£o. <br><br>  O que mais posso dizer, a estrutura das tabelas √© bastante comum, os sinalizadores s√£o os seguintes: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_P 0x0000000000000001ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Page Present bit */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_W 0x0000000000000002ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Writable (0 - only read) */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_UU2 0x0000000000000004ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* unused bit # 2 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_PWT 0x0000000000000008ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Write Through */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_CD1 0x0000000000000010ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Cache disable (right bit) */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_A 0x0000000000000020ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Accessed Page */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_D 0x0000000000000040ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Page Dirty */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_HUGE 0x0000000000000080ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Page Size */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_G 0x0000000000000100ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Global Page */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_CD2 0x0000000000000200ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Cache disable (left bit) */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_NWA 0x0000000000000400ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Prohibit address writing */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_AVAIL 0x0000000000000800ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Available page */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_PFN 0x000000fffffff000ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Physical Page Number */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_VALID 0x0000010000000000ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Valid Page */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_PV 0x0000020000000000ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* PriVileged Page */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_INT_PR 0x0000040000000000ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Integer address access Protection */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_NON_EX 0x0000080000000000ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Non Executable Page */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_RES 0x0000f00000000000ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Reserved bits */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_C_UNIT 0xffff000000000000ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Compilation Unit */</span></span></span></span></code> </pre> <br>  Para a tabela de quatro n√≠veis, as mudan√ßas de endere√ßo s√£o as seguintes: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __MMU_PGD_SHIFT (PAGE_SHIFT + 3 * (PAGE_SHIFT-3)) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* 39 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __MMU_PUD_SHIFT (PAGE_SHIFT + 2 * (PAGE_SHIFT-3)) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* 30 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __MMU_PMD_SHIFT (PAGE_SHIFT + 1 * (PAGE_SHIFT-3)) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* 21 */</span></span></span></span></code> </pre><br><h3>  Um pouco sobre PCI </h3><br><h4>  Comunica√ß√£o atrav√©s de espa√ßos de endere√ßo alternativos </h4><br>  Antes de passar para o vidyaha e a placa de rede, voltemos brevemente ao PCI.  J√° conversamos um pouco sobre isso na primeira parte de <a href="https://habr.com/ru/company/embox/blog/421441/">"A Embox come√ßa a escalar o Monte Elbrus"</a> .  Ele mostrou macros para comunica√ß√£o com espa√ßos de endere√ßo alternativos: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _E2K_READ_MAS(addr, mas, type, size_letter, chan_letter) \ ({ \ register type res; \ asm volatile (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ld"</span></span></span><span class="hljs-meta"> #size_letter </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">","</span></span></span><span class="hljs-meta"> #chan_letter </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" \t0x0, [%1] %2, %0"</span></span></span><span class="hljs-meta"> \ : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=r"</span></span></span><span class="hljs-meta"> (res) \ : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r"</span></span></span><span class="hljs-meta"> ((__e2k_ptr_t) (addr)), \ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"i"</span></span></span><span class="hljs-meta"> (mas)); \ res; \ }) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _E2K_WRITE_MAS(addr, val, mas, type, size_letter, chan_letter) \ ({ \ asm volatile (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"st"</span></span></span><span class="hljs-meta"> #size_letter </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">","</span></span></span><span class="hljs-meta"> #chan_letter </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" \t0x0, [%0] %2, %1"</span></span></span><span class="hljs-meta"> \ : \ : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r"</span></span></span><span class="hljs-meta"> ((__e2k_ptr_t) (addr)), \ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r"</span></span></span><span class="hljs-meta"> ((type) (val)), \ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"i"</span></span></span><span class="hljs-meta"> (mas) \ : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"memory"</span></span></span><span class="hljs-meta">); \ })</span></span></code> </pre> <br>  E havia uma refer√™ncia ao princ√≠pio dos espa√ßos de endere√ßo.  Diferentes espa√ßos de endere√ßo s√£o definidos usando o MAS (especificador de endere√ßo de mem√≥ria).  E, por exemplo, para acessar o IO, atrav√©s do qual o PCI √© acessado, voc√™ precisa usar 6 e o ‚Äã‚ÄãMMU 7. <br><br>  Mas com um estudo mais aprofundado da macro, voc√™ pode notar algum tipo de carta_de_ chan.  E se voc√™ olhar para a descri√ß√£o dos comandos e2k, encontramos <br><blockquote>  LDD ddd leitura de duas palavras <br>  ldd [address] mas, dst </blockquote><br>  Ou seja, √† primeira vista, n√£o h√° canais.  Mas, se voc√™ seguir os links, o c√≥digo para a opera√ß√£o ldd especificada √© 67. Mas 67 √© o c√≥digo para ldd apenas para os canais AL0 / AL3 e AL2 / AL5, e para os canais AL1 / AL4, esse c√≥digo corresponde √† opera√ß√£o POPCNTd. <br><br>  Portanto, n√£o foi poss√≠vel entender completamente quais canais est√£o na terminologia de Elbrus.  Atrevo-me a sugerir que isso j√° est√° conectado ao princ√≠pio vliw, quando voc√™ pode especificar qual alu √© usada, porque nesse tipo de arquitetura um dos recursos √© a presen√ßa de v√°rios dispositivos de computa√ß√£o independentes.  √â claro que posso estar enganado, mas o fato √© que, para acessar o PCI ou MMU, √© necess√°rio usar o segundo ou o quinto canal.  Assim, o comando ser√° algo como isto: <br><blockquote>  ldd, 2 0x0, [addr_in_mas] mas_id,% reg </blockquote><br><h4>  lspci </h4><br>  Agora vou dar o resultado da sa√≠da do comando lspci no dispositivo que temos: <br><blockquote>  root @ embox: (nulo) #lspci <br>  00: 0.0 (PCI dev E3E3: ABCD) [6 4] <br>  Ponte PCI-to-PCI: (nula) ponte Elbrus PCIe (rev 01) <br>  00: 1.0 (PCI dev 8086: E3E3) [6 4] <br>  Ponte PCI-to-PCI: ponte Intel Corporation Elbrus Virt PCI (rev 01) <br>  01: 0.0 (PCI dev 1FFF: 8000) [6 4] <br>  Ponte PCI-para-PCI: (nula) Ponte PCI Elbrus (rev 05) <br>  01: 1.0 (PCI dev 8086: 4D45) [2 0] <br>  Controlador Ethernet: Intel Corporation MCST ETH1000 Gigabit Ethernet (rev 01) <br>  01: 2.0 (PCI dev 8086: 4D49) [1 1] <br>  Controlador IDE: Intel Corporation MCST IDE (rev 128) <br>  01: 2.1 (PCI dev 8086: 0002) [7 2] <br>  Comunica√ß√£o simples.  controlador: Intel Corporation (nulo) (rev 05) <br>  01: 2.2 (PCI dev 8086: 8000) [7128] <br>  Comunica√ß√£o simples.  controlador: ponte PCI Intel Corporation Elbrus (rev 00) <br>  01: 2.3 (PCI dev 1013: 6005) [4 1] <br>  Dispositivo multim√≠dia: Cirrus Logic Crystal CS4281 PCI Audio (rev 01) <br>  01: 3.0 (dev 8086: 4748 do PCI) [1 6] <br>  Controlador de armazenamento em massa: Intel Corporation MCST SATA (rev 00) <br>  01: 4.0 (PCI dev 8086: 554F) [12 3] <br>  Dispositivo USB: Intel Corporation OHCI para Elbrus (rev 00) <br>  01: 4.1 (PCI dev 8086: 5545) [12 3] <br>  Dispositivo USB: Intel Corporation EHCI para Elbrus (rev 00) <br>  02: 1.0 (PCI dev 126F: 0718) [3 0] <br>  Controlador compat√≠vel com VGA: Silicon Motion, Inc.  SM718 LynxSE + (rev 160) <br>  root @ embox: (nulo) # </blockquote><br>  Nota <br><blockquote>  01: 2.2 (PCI dev 8086: 8000) [7128] <br>  Comunica√ß√£o simples.  controlador: ponte PCI Intel Corporation Elbrus (rev 00) </blockquote><br>  De fato, √© uma porta serial do MCST semelhante √† am85c30, pelo menos atrav√©s deste dispositivo que nos comunicamos atrav√©s do minicom. <br><br><h3>  Placa de rede </h3><br><h4>  Estrutura geral </h4><br>  Agora vamos para a placa de rede. <br><br>  Se bem entendi, essa √© a placa de rede original, um pouco semelhante em opera√ß√£o ao e1000, mas apenas em opera√ß√£o (como a presen√ßa de descritores nas filas de recebimento e transmiss√£o). <br><br>  Agora, mais sobre os pontos importantes que encontramos. <br><br>  Placa de rede PCI VID: PID 0x8086: 0x4D45.  N√£o se surpreenda que o VID seja o mesmo da Intel, o MCST geralmente usa esse VID em particular; veja pelo menos o dispositivo da porta serial mencionado acima. <br><br>  BAR0 cont√©m uma base de registro.  Os registros s√£o os seguintes: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> L_E1000_E_CSR 0x00 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Ethernet Control/Status Register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> L_E1000_MGIO_CSR 0x04 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* MGIO Control/Status Register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> L_E1000_MGIO_DATA 0x08 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* MGIO Data Register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> L_E1000_E_BASE_ADDR 0x0c </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* EthernetBase Address Register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> L_E1000_DMA_BASE_ADDR 0x10 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* DMA Base Address Register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> L_E1000_PSF_CSR 0x14 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pause Frame Control/Status Register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> L_E1000_PSF_DATA 0x18 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pause Frame Data Register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> L_E1000_INT_DELAY 0x1c </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Interrupt Delay Register */</span></span></span></span></code> </pre> <br>  Os tr√™s √∫ltimos (L_E1000_PSF_CSR, L_E1000_PSF_DATA, L_E1000_INT_DELAY) que n√£o usamos, portanto n√£o falaremos sobre eles.  Vamos come√ßar com o MGIO, tudo √© simples: leitura e grava√ß√£o usando o protocolo MII, ou seja, comunica√ß√£o com o chip PHY.  Especificamente, temos um chip DP83865. <br><br>  Os procedimentos n√£o s√£o particularmente not√°veis, simplesmente os listarei. <br><br>  Leitura: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e1000_mii_readreg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct net_device *dev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> phy_id, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reg_num)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l_e1000_priv</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ep</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">netdev_priv</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> rd; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> val_out = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; rd = <span class="hljs-number"><span class="hljs-number">0</span></span>; rd |= <span class="hljs-number"><span class="hljs-number">0x2</span></span> &lt;&lt; MGIO_CS_OFF; rd |= <span class="hljs-number"><span class="hljs-number">0x1</span></span> &lt;&lt; MGIO_ST_OF_F_OFF; rd |= <span class="hljs-number"><span class="hljs-number">0x2</span></span> &lt;&lt; MGIO_OP_CODE_OFF; <span class="hljs-comment"><span class="hljs-comment">/* Read */</span></span> rd |= (phy_id &amp; <span class="hljs-number"><span class="hljs-number">0x1f</span></span>) &lt;&lt; MGIO_PHY_AD_OFF; rd |= (reg_num &amp; <span class="hljs-number"><span class="hljs-number">0x1f</span></span>) &lt;&lt; MGIO_REG_AD_OFF; e1000_write_mgio_data(ep, rd); rd = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i != <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e1000_read_mgio_csr(ep) &amp; MGIO_CSR_RRDY) { rd = (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>)e1000_read_mgio_data(ep); val_out = rd &amp; <span class="hljs-number"><span class="hljs-number">0xffff</span></span>; log_debug(<span class="hljs-string"><span class="hljs-string">"reg 0x%x &gt;&gt;&gt; 0x%x"</span></span>, reg_num, val_out); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val_out; } usleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); } log_error(<span class="hljs-string"><span class="hljs-string">"mdio_read: Unable to read from MGIO_DATA reg\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val_out; }</code> </pre> <br>  Registro: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e1000_mii_writereg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct net_device *dev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> phy_id, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reg_num, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l_e1000_priv</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ep</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">netdev_priv</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> wr; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; wr = <span class="hljs-number"><span class="hljs-number">0</span></span>; wr |= <span class="hljs-number"><span class="hljs-number">0x2</span></span> &lt;&lt; MGIO_CS_OFF; wr |= <span class="hljs-number"><span class="hljs-number">0x1</span></span> &lt;&lt; MGIO_ST_OF_F_OFF; wr |= <span class="hljs-number"><span class="hljs-number">0x1</span></span> &lt;&lt; MGIO_OP_CODE_OFF; <span class="hljs-comment"><span class="hljs-comment">/* Write */</span></span> wr |= (phy_id &amp; <span class="hljs-number"><span class="hljs-number">0x1f</span></span>) &lt;&lt; MGIO_PHY_AD_OFF; wr |= (reg_num &amp; <span class="hljs-number"><span class="hljs-number">0x1f</span></span>) &lt;&lt; MGIO_REG_AD_OFF; wr |= val &amp; <span class="hljs-number"><span class="hljs-number">0xffff</span></span>; log_debug(<span class="hljs-string"><span class="hljs-string">"reg 0x%x &lt;&lt;&lt; 0x%x"</span></span>, reg_num, val); e1000_write_mgio_data(ep, wr); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i != <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e1000_read_mgio_csr(ep) &amp; MGIO_CSR_RRDY) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } usleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); } log_error(<span class="hljs-string"><span class="hljs-string">"Unable to write MGIO_DATA reg: val = 0x%x"</span></span>, wr); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br>  Agora L_E1000_DMA_BASE_ADDR e L_E1000_E_BASE_ADDR, na verdade, eles descrevem um par√¢metro, o endere√ßo do bloco de descri√ß√£o da placa de rede.  Ou seja, o endere√ßo no Elbrus √© de 64 bits e os registros s√£o de 32 bits. <br><br>  Na verdade codifique: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* low 32 bits */</span></span> init_block_addr_part = (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)((<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>)ep-&gt;init_block &amp; <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>); e1000_write_e_base_addr(ep, init_block_addr_part); log_debug(<span class="hljs-string"><span class="hljs-string">"Init Block Low DMA addr: 0x%x"</span></span>, init_block_addr_part); <span class="hljs-comment"><span class="hljs-comment">/* high 32 bits */</span></span> init_block_addr_part = (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)(((<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>)(ep-&gt;init_block) &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>); e1000_write_dma_base_addr(ep, init_block_addr_part); log_debug(<span class="hljs-string"><span class="hljs-string">"Init Block High DMA addr: 0x%x"</span></span>, init_block_addr_part); <span class="hljs-comment"><span class="hljs-comment">/************************************************************************/</span></span></code> </pre><br>  A partir do qual √© poss√≠vel ver que L_E1000_DMA_BASE_ADDR √© a parte superior e L_E1000_DMA_BASE_ADDR √© a parte inferior do endere√ßo de um determinado bloco de inicializa√ß√£o (na verdade, um bloco de descri√ß√£o de cart√µes). <br><br>  A estrutura da descri√ß√£o √© a seguinte: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l_e1000_init_block</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> mode; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> paddr[<span class="hljs-number"><span class="hljs-number">6</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> laddrf; <span class="hljs-comment"><span class="hljs-comment">/* 31:4 = addr of rx desc ring (16 bytes align) + * 3:0 = number of descriptors (the power of two) * 0x09 is max value (desc number = 512 if [3:0] &gt;= 0x09) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> rdra; <span class="hljs-comment"><span class="hljs-comment">/* 31:4 = addr of tx desc ring (16 bytes align) + * 3:0 = number of descriptors (the power of two) * 0x09 is max value (desc number = 512 if [3:0] &gt;= 0x09) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> tdra; } __attribute__((packed));</code> </pre> <br>  C laddrf - n√£o entendi, por algum motivo, √© colocado a zero, fizemos o mesmo. <br><br>  paddr - como voc√™ pode imaginar, mac √© o endere√ßo da placa de rede. <br><br>  rdra e tdra cont√™m os endere√ßos dos an√©is dos descritores de mem√≥ria, os 4 bits inferiores s√£o alocados ao tamanho do anel e esse √© o logaritmo do tamanho.  Ou seja, se houver 8, o n√∫mero de descritores no anel ser√° 2 ^ 8 (1 &lt;&lt; 8 == 256). <br><br>  mode √© o modo de opera√ß√£o do cart√£o, os bits s√£o os seguintes: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRX (1 &lt;&lt; 0) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Receiver disable */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DTX (1 &lt;&lt; 1) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Transmitter disable */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LOOP (1 &lt;&lt; 2) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* loopback */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DTCR (1 &lt;&lt; 3) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* disable transmit crc */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> COLL (1 &lt;&lt; 4) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* force collision */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRTY (1 &lt;&lt; 5) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* disable retry */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> INTL (1 &lt;&lt; 6) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Internal loopback */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EMBA (1 &lt;&lt; 7) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* enable modified back-off algorithm */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EJMF (1 &lt;&lt; 8) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* enable jambo frame */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EPSF (1 &lt;&lt; 9) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* enable pause frame */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FULL (1 &lt;&lt; 10) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* full packet mode */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PROM (1 &lt;&lt; 15) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* promiscuous mode */</span></span></span></span></code> </pre> <br>  Ou seja, quando tudo estiver configurado, voc√™ precisar√° definir o bit 10. Se desejar um modo prom√≠scuo, tamb√©m 15. <br><br><h4>  Descritores de pacotes </h4><br>  Agora, sobre o formato dos descritores de pacotes. <br><br>  Na recep√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l_e1000_rx_desc</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> base; <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> buf_length; <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> status; <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> msg_length; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> reserved1; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> etmr; } __attribute__((packed));</code> </pre> <br>  base - provavelmente entenda que este √© o endere√ßo do buffer para o pacote <br>  buf_length - tamanho do buffer <br>  msg_length - depois de receber, cont√©m o comprimento do pacote recebido <br>  status - status do descritor.  Quando o pacote √© preparado e entregue ao DMA (cart√£o), voc√™ precisa definir o bit 15 (RD_OWN).  Se tudo estiver bem, depois de receber o pacote neste descritor, esse bit ser√° redefinido e 9 (RD_STP) e 8 (RD_ENP) ser√£o configurados. <br><br>  Todos os bits de status s√£o os seguintes: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* RX Descriptor status bits */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RD_OWN (1 &lt;&lt; 15) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RD_ERR (1 &lt;&lt; 14) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RD_FRAM (1 &lt;&lt; 13) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RD_OFLO (1 &lt;&lt; 12) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RD_CRC (1 &lt;&lt; 11) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RD_BUFF (1 &lt;&lt; 10) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RD_STP (1 &lt;&lt; 9) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RD_ENP (1 &lt;&lt; 8) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RD_PAM (1 &lt;&lt; 6) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RD_LAFM (1 &lt;&lt; 4) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RD_BAM (1 &lt;&lt; 3)</span></span></code> </pre> <br>  Na transfer√™ncia: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l_e1000_tx_desc</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> base; <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> buf_length; <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> status; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> misc; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> etmr; } __attribute__((packed));</code> </pre><br>  Quase o mesmo que receber, os bits de status s√£o os seguintes: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* TX Descriptor status bits */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TD_OWN (1 &lt;&lt; 15) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TD_ERR (1 &lt;&lt; 14) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TD_AFCS (1 &lt;&lt; 13) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TD_NOINTR (1 &lt;&lt; 13) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TD_MORE (1 &lt;&lt; 12) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TD_ONE (1 &lt;&lt; 11) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TD_DEF (1 &lt;&lt; 10) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TD_STP (1 &lt;&lt; 9) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TD_ENP (1 &lt;&lt; 8)</span></span></code> </pre> <br>  Quando um pacote √© enviado, √© necess√°rio definir 15 (TD_OWN), 9 (TD_STP) e 8 (TD_ENP) de acordo.  O bit 8 significa que este √© o √∫ltimo pacote a ser processado; portanto, se um pacote for enviado, voc√™ precisar√° instalar apenas o √∫ltimo. <br><br>  Tamb√©m esqueci um recurso importante, o tamanho do buffer nos descritores √© escrito com um sinal de menos, provavelmente em c√≥digo adicional.  Mesmo em little-endian, mas como a Elbrus tem a mesma ordem de bytes, isso provavelmente n√£o √© importante. <br><br><h4>  Registo de gest√£o </h4><br>  Agora descrevemos o √∫ltimo registro desmontado L_E1000_E_CSR: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* E_CSR register bits */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 31:21 unused, readed as 0 */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_ATME (1 &lt;&lt; 24) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW, Add Timer Enable */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_TMCE (1 &lt;&lt; 23) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW, Timer Clear Enable */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_DRIN (1 &lt;&lt; 22) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW, Disable RX Interrupt */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_DTIN (1 &lt;&lt; 21) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW, Disable TX Interrupt */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_ESLE (1 &lt;&lt; 20) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW, Enable Slave Error */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_SLVE (1 &lt;&lt; 19) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW1c, Slave Error */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_PSFI (1 &lt;&lt; 18) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW1c, Pause Frame Interrupt */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* 17 unused, read as 0 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_SINT (1 &lt;&lt; 16) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* R, Status Interrupt */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_ERR (1 &lt;&lt; 15) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* R, Error */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_BABL (1 &lt;&lt; 14) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW1c, Babble */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_CERR (1 &lt;&lt; 13) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW1c, Collision Error */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_MISS (1 &lt;&lt; 12) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW1c, Missed Packet */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_MERR (1 &lt;&lt; 11) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW1c, Memory Error */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_RINT (1 &lt;&lt; 10) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW1c, Receiver Interrupt */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_TINT (1 &lt;&lt; 9) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW1c, Transmiter Interrupt */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_IDON (1 &lt;&lt; 8) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW1c, Initialization Done */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_INTR (1 &lt;&lt; 7) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* R, Interrupt Flag */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_INEA (1 &lt;&lt; 6) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW, Interrupt Enable */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_RXON (1 &lt;&lt; 5) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* R, Receiver On */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_TXON (1 &lt;&lt; 4) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* R, Transmiter On */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_TDMD (1 &lt;&lt; 3) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW1, Transmit Demand */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_STOP (1 &lt;&lt; 2) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW1, Stop */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_STRT (1 &lt;&lt; 1) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW1, Start */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_INIT (1 &lt;&lt; 0) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW1, Initialize */</span></span></span></span></code> </pre><br><h4>  Inicializa√ß√£o </h4><br>  H√° uma sequ√™ncia de inicializa√ß√£o um tanto incomum: <br><blockquote>  PARAR-&gt; INIT-&gt; IDON-&gt; STRT </blockquote><br>  Nesse caso, os bits RXON e TXON aumentam independentemente. <br>  Mais detalhes podem ser encontrados em nosso driver. <br><br><h2>  Placa de v√≠deo </h2><br>  Como j√° observado, nosso dispositivo usa um vidyah da Silicon Motion chamado SM718 LynxSE +.  Portanto, tudo √© simples, existem <a href="https://github.com/torvalds/linux/tree/master/drivers/staging/sm750fb">fontes de driver no Linux</a> e n√£o h√° nada para descrever realmente. <br><br>  Bem, exceto pelo fato de o v√≠deo mostrar que ficou muito baixo em fps, parece um acesso lento √† mem√≥ria.  Mas isso n√£o tem otimiza√ß√£o do compilador e, em geral, talvez esse seja o nosso problema associado ao uso incorreto da arquitetura e2k. <br><br><h3>  Bem, o que mais dizer sobre <s>Sakhalin</s> Elbrus? </h3><br>  Em princ√≠pio, o tempo est√° normal :) <br><br>  Aparentemente, Elbrus existe, trabalha.  Pessoalmente, vejo o principal problema do desenvolvimento dessa arquitetura interessante como sua proximidade.  √â dif√≠cil acreditar que uma empresa relativamente pequena possa criar um processador, um compilador, fornecer suporte e tudo mais.  Sim, come√ßaram a aparecer desenvolvedores de software de terceiros, o mesmo Basalt-SPO suporta o <a href="https://www.altlinux.org/%25D0%25AD%25D0%25BB%25D1%258C%25D0%25B1%25D1%2580%25D1%2583%25D1%2581">Alt-Linux, que pode ser instalado no Elbrus</a> . <br><br>  Sim, houve relatos de que desenvolvedores de terceiros est√£o fabricando hardware baseado no processador Elbrus, por exemplo, <a href="https://m.vk.com/wall-71796881_858">Fastwel</a> .  Mas todos esses s√£o apenas pequenos avan√ßos em dire√ß√£o √† abertura.  Um exemplo muito simples, para reproduzir o que dissemos e mostramos aqui, precisamos de um compilador, e somente o <a href="http://www.mcst.ru/">MCST o possui</a> , as informa√ß√µes fornecidas no artigo s√£o um complemento √†s informa√ß√µes recebidas do <a href="http://www.mcst.ru/">MCST</a> , e ainda n√£o digo que √© improv√°vel que um peda√ßo de ferro seja encontrado mesmo no MCST.  √â bastante antigo e o <a href="http://www.mcst.ru/">ICST</a> oferece modelos mais recentes. <br><br>  PS Naturalmente, voc√™ pode ver tudo no <a href="https://github.com/embox/embox">reposit√≥rio Embox</a> . <br><br>  PPS Venha para o canal de telegrama russo via Embox ( <a href="https://t.me/embox_chat">https://t.me/embox_chat</a> ). <br><br>  O PPS Embox atualizou o segundo componente da vers√£o, agora o atual <a href="">0.4.0</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt485694/">https://habr.com/ru/post/pt485694/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt485664/index.html">Criando par√¢metros din√¢micos em um trabalho Jenkins ou como tornar sua tarefa f√°cil de usar</a></li>
<li><a href="../pt485672/index.html">Melhores pr√°ticas do Redis, parte 1</a></li>
<li><a href="../pt485682/index.html">A administra√ß√£o do tempo n√£o ajudar√°: a procrastina√ß√£o √© o problema de regular emo√ß√µes, n√£o o tempo</a></li>
<li><a href="../pt485688/index.html">Myapp estende f√©rias</a></li>
<li><a href="../pt485692/index.html">Conselho do especialista em TI para o cliente ou como automatizar a bagun√ßa</a></li>
<li><a href="../pt485702/index.html">FunCorp iOS meetup # 2</a></li>
<li><a href="../pt485704/index.html">Pixel art para iniciantes: corrigindo erros comuns</a></li>
<li><a href="../pt485706/index.html">Convidamos voc√™ para a reuni√£o "Transforma√ß√£o digital e novos pap√©is na ci√™ncia de dados"</a></li>
<li><a href="../pt485708/index.html">Blockchain est√° mudando a maneira como a ind√∫stria ferrovi√°ria funciona</a></li>
<li><a href="../pt485710/index.html">Solu√ß√£o simples para teste de regress√£o visual em Java + Selenium Webdriver + aShot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>