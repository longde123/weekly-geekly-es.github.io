<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐉 🤞🏽 👩‍🔬 Caractéristiques de l'établissement d'une connexion entre les participants à un jeu en réseau peer-to-peer 🏇🏻 👋🏼 👙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il s'agit d'une collection d'informations dont j'avais besoin pour implémenter l'étape d'établissement d'une connexion entre les participants à un jeu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Caractéristiques de l'établissement d'une connexion entre les participants à un jeu en réseau peer-to-peer</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485576/"> Il s'agit d'une collection d'informations dont j'avais besoin pour implémenter l'étape d'établissement d'une connexion entre les participants à un jeu en réseau peer-to-peer utilisant le protocole UDP. <br><br>  L'article est conçu pour les développeurs de jeux débutants.  J'ai essayé d'écrire un article que j'aimerais moi-même lire à un moment où je commençais à peine à comprendre ce sujet: pour que toutes les nuances nécessaires soient rassemblées en un seul endroit, mais en même temps il n'y a rien de superflu, dans un langage simple, et avec des images visuelles.  Peut-être que quelqu'un vous sera utile. <br><br>  Les développeurs de jeux expérimentés ne trouveront probablement rien de nouveau ici.  Mais je serai reconnaissant pour les commentaires et commentaires. <br><br><div style="text-align:center;"> <a href="https://habr.com/ru/post/485576/"><img src="https://habrastorage.org/webt/pg/wy/7h/pgwy7h2hgc0rws8_5-btx0brno8.png"></a> </div><br><a name="habracut"></a><br><h2>  Jeu en réseau avec architecture peer-to-peer </h2><br><ul><li>  Chaque joueur stocke la totalité de l'état du monde du jeu et le traite de manière synchrone avec les autres joueurs.  Chaque joueur transmet les actions de l'utilisateur à tous les autres joueurs.  Le joueur principal qui récupère les autres joueurs est appelé le serveur et les autres sont des clients.  Le serveur n'est le principal qu'au stade de la collecte des joueurs.  Et pendant le jeu, il n'y a pas d'ordinateur principal. <br></li><li>  Cette approche présente les caractéristiques suivantes: <br><ul><li>  Le trafic ne dépend pas de la complexité du monde du jeu, mais uniquement du nombre de joueurs.  Dans ce mode, <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2582%25D1%2580%25D0%25B0%25D1%2582%25D0%25B5%25D0%25B3%25D0%25B8%25D1%258F_%25D0%25B2_%25D1%2580%25D0%25B5%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D0%25BC_%25D0%25B2%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B5%25D0%25BD%25D0%25B8" rel="nofollow">les stratégies en temps réel</a> fonctionnent généralement, où vous devez traiter des milliers d'unités. <br></li><li>  Le volume de trafic est de l'ordre de N², où N est le nombre de joueurs.  Par conséquent, cette approche n'est applicable que pour les jeux avec un petit nombre de joueurs. <br></li><li>  Comme les données sont transmises directement entre les joueurs sans serveur intermédiaire, les retards de transmission (décalages) sont minimes.  Mais si au moins l'un des joueurs a des problèmes de communication, cela affectera tous les joueurs. <br></li><li>  Il est nécessaire d'établir des canaux de communication entre tous les acteurs.  Mais si les joueurs sont sur des réseaux locaux différents, ce n'est pas toujours possible. <br></li></ul></li><li>  Vous pouvez utiliser TCP ou UDP pour transférer des données dans le jeu. <br><ul><li>  <a href="https://ru.wikipedia.org/wiki/Transmission_Control_Protocol" rel="nofollow">TCP (Transmission Control Protocol)</a> fournit une livraison de flux d'octets fiable.  Cela simplifie la mise en œuvre du jeu, mais il n'y a aucun contrôle sur les délais de transmission des données. <br></li><li>  <a href="https://ru.wikipedia.org/wiki/UDP" rel="nofollow">UDP (User Datagram Protocol)</a> est un simple protocole de transfert de paquets sans garantie de leur livraison.  Mais en raison de sa simplicité, UDP est utilisé dans les systèmes en temps réel lorsqu'il est inacceptable d'attendre des paquets retardés ou perdus.  L'utilisation d'UDP peut réduire les retards dans le jeu, mais complique la mise en œuvre du jeu. <br></li></ul>  Cet article décrit l'utilisation d'UDP. <br></li></ul><br><h2>  Etablissement d'une connexion sur le réseau local </h2><br><ul><li>  Pour établir une connexion entre les joueurs, le client doit connaître l'adresse IP du serveur et le port que le programme de jeu écoute. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n3/di/2u/n3di2usgoz4bj4cyqcmbk3txocy.png"></div><br><ul><li>  Par exemple, l'ordinateur du joueur A a une adresse IP de 192.168.1.2 sur le réseau local.  Le joueur A lance le programme de jeu sur son ordinateur en mode serveur et le programme écoute sur le port 50120. Le joueur A communique en quelque sorte ces informations au joueur B. <br></li><li>  L'ordinateur du joueur B a une adresse IP de 192.168.1.5 sur le réseau local.  Le joueur B lance le programme de jeu sur son ordinateur en mode client et le programme occupe le port 50150. Le joueur B entre l'adresse du serveur 192.168.1.2►0120 dans le programme de jeu et le programme envoie une demande au serveur à l'adresse spécifiée. <br></li><li>  Le serveur est en mode veille, et après avoir reçu une demande du joueur B, il trouvera son adresse 192.168.1.5►0150.  Ainsi, le client et le serveur ont établi une connexion et peuvent démarrer le jeu. <br></li></ul></li><li>  Si plusieurs clients sont connectés au serveur, le serveur doit envoyer à chacun d'eux les adresses des autres clients. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/f9/zu/zg/f9zuzgexmd5bqe8fxgypsynspyu.png"></div><br>  Dans l'exemple de l'image, le serveur A envoie au client B l'adresse du client C (192.168.1.6►0160) et au client C envoie l'adresse du client B (192.168.1.5►0150).  Ainsi, tous les joueurs pourront établir des connexions "chacun avec chacun". <br></li><li>  Chaque fois que le jeu démarre, le serveur peut demander n'importe quel port libre au système d'exploitation.  Mais il est plus pratique d'utiliser le même port à chaque fois afin que le client n'ait pas à entrer un nouveau port à chaque fois. <br><br>  Tous les ports sont divisés en trois plages: <br><ul><li>  [0, 1023] - bien connu (systémique). <br></li><li>  [1024, 49151] - enregistré (utilisateur).  Le port du serveur doit être sélectionné dans cette plage. <br></li><li>  [49152, 65535] - dynamique (privé).  Ici, le système d'exploitation alloue des ports temporaires aux programmes. <br></li></ul><br>  Sur Wikipédia, vous pouvez voir une liste des <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BF%25D0%25B8%25D1%2581%25D0%25BE%25D0%25BA_%25D0%25BF%25D0%25BE%25D1%2580%25D1%2582%25D0%25BE%25D0%25B2_TCP_%25D0%25B8_UDP" rel="nofollow">ports réservés</a> .  Ensuite, par exemple, le port 49094 pour le serveur de jeu est sélectionné. <br></li><li>  Un ordinateur peut avoir plusieurs interfaces réseau, à la fois réelles (Ethernet, WiFi) et virtuelles (VPN).  Chaque interface réseau a sa propre adresse IP.  Le programme peut fournir à l'utilisateur du serveur la possibilité de sélectionner l'interface réseau par laquelle il attendra les demandes des clients.  Mais il est pratique d'utiliser une adresse IP générique spéciale <a href="https://en.wikipedia.org/wiki/0.0.0.0" rel="nofollow">0.0.0.0</a> .  Si le programme ouvre un socket avec cette adresse IP, il écoutera le port spécifié pour toutes les interfaces réseau de cet ordinateur.  Ainsi, le joueur n'a pas à penser quelle interface réseau choisir. <br></li><li>  Vous pouvez également aider le client et déterminer automatiquement l'adresse IP du serveur.  Si le client envoie une demande à une <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B8%25D1%2580%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25B2%25D0%25B5%25D1%2589%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D0%25B4%25D1%2580%25D0%25B5%25D1%2581" rel="nofollow">adresse IP de diffusion</a> spéciale <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B8%25D1%2580%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25B2%25D0%25B5%25D1%2589%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D0%25B4%25D1%2580%25D0%25B5%25D1%2581" rel="nofollow">(diffusion)</a> , tous les ordinateurs du réseau local la recevront. <br><br>  Par exemple, si l'adresse réseau est 192.168.1.0, le masque de sous-réseau est 255.255.255.0, alors l'adresse IP de diffusion sera 192.168.1.255. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4y/yj/ot/4yyjotxuzbtirqk2pewwm_npmd8.png"></div><br>  Si tous les serveurs de jeu écoutent sur le port 49094, le paquet envoyé à l'adresse 192.168.1.255-00-009094 sera reçu par tous les serveurs de jeu sur ce réseau.  Chaque serveur enverra une confirmation à l'expéditeur.  Ainsi, le client recevra une liste de tous les serveurs de jeu sur son réseau et pourra sélectionner le serveur dont il a besoin. <br></li><li>  Si tous les joueurs sont sur le même réseau local, établir des connexions «chacun avec chacun» est assez simple.  Il peut y avoir des problèmes avec l'accès client au port du serveur en raison du pare-feu.  Mais cela dépend du système d'exploitation et des paramètres de sécurité. <br></li></ul><br><h2>  Établir une connexion d'un réseau local à un serveur sur Internet </h2><br><ul><li>  En règle générale, les ordinateurs ne sont pas connectés à Internet directement, mais via un routeur.  Et, en règle générale, le routeur effectue la <a href="https://ru.wikipedia.org/wiki/NAT" rel="nofollow">traduction d'adresses réseau (NAT, Network Address Translation)</a> . <br><br>  Par exemple, le client C est sur le réseau local et a accès à Internet via le routeur B, tandis que le serveur A a une adresse IP publique sur Internet.  Donnez-leur les adresses suivantes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gq/cf/qt/gqcfqtu-vneghva8qq7v2do7lxo.png"></div><br><ul><li>  L'adresse Internet du serveur A est 203.0.113.2.  Le programme serveur écoute sur le port 49094. <br></li><li>  L'adresse du routeur B sur Internet est 203.0.113.5.  L'adresse du routeur B sur le réseau local est 192.168.1.1. <br></li><li>  L'adresse du client C sur le réseau local est 192.168.1.5.  Le programme client occupe le port 50150 et envoie un paquet au serveur au 203.0.113.2-00-009094. <br></li><li>  Le routeur B est la <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25BB%25D1%258E%25D0%25B7_%25D0%25BF%25D0%25BE_%25D1%2583%25D0%25BC%25D0%25BE%25D0%25BB%25D1%2587%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258E" rel="nofollow">passerelle par défaut</a> sur son réseau local.  Autrement dit, tous les paquets dont les adresses ne proviennent pas du réseau local actuel lui sont envoyés. <br></li><li>  Le routeur possède une table de traduction d'adresses: (adresse interne: port interne) - (adresse externe: port externe).  Après avoir reçu un paquet du client vers le serveur 203.0.113.2-00-009094, le routeur sélectionne n'importe quel port externe libre, par exemple 52050, et crée une entrée dans la table de traduction des adresses: 192.168.1.5►0150 - 203.0.113.5►2050. <br></li><li>  Le routeur remplace l'adresse interne de l'expéditeur 192.168.1.5/100150 dans le paquet par l'adresse externe 203.0.113.5/102050 et transfère le paquet modifié au serveur. <br></li><li>  Le serveur reçoit un paquet avec l'adresse de l'expéditeur 203.0.113.5► 2020 et envoie une réponse à cette adresse, c'est-à-dire au routeur. <br></li><li>  Après avoir reçu le paquet du serveur, le routeur recherche l'adresse du destinataire dans sa table de traduction d'adresse, effectue le remplacement inverse de l'adresse externe du destinataire 203.0.113.5►2050 par l'adresse interne 192.168.1.5►0150 et envoie le paquet à cette adresse, c'est-à-dire le client. <br></li><li>  Si le client envoie des paquets ultérieurs au serveur, le routeur examine l'adresse de l'expéditeur pour voir si un tel enregistrement existe déjà dans la table et, dans l'affirmative, il utilise le port externe précédemment alloué, dans ce cas 52050. <br></li><li>  Ainsi, le client et le serveur ont établi une connexion via NAT et peuvent démarrer le jeu.  Mais le serveur ne connaît pas l'adresse interne du client dans son réseau local et considère que le client est un routeur. <br></li><li>  L'entrée dans la table de traduction d'adresses est valide pendant une certaine période de temps, généralement 1 à 3 minutes.  Par conséquent, le client et le serveur doivent périodiquement échanger des paquets afin que l'enregistrement qui les connecte ne soit pas supprimé.  Si le client envoie un nouveau paquet au serveur après avoir supprimé l'enregistrement, alors un port externe différent peut être alloué pour le nouvel enregistrement sur le routeur, et pour le serveur, ce sera un autre client avec une adresse différente. <br></li></ul></li><li>  En règle générale, le routeur de l'utilisateur n'est pas connecté directement à Internet, mais se trouve sur le réseau interne du fournisseur Internet.  Autrement dit, le client est derrière deux NAT. <br><br>  Par exemple, comme ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7u/ht/cw/7uhtcwvuy-lojgg6_sxifcd_ucc.png"></div><br>  C'est-à-dire qu'une double traduction des adresses réseau est effectuée. <br></li><li>  Il existe différents types de NAT: <br><ul><li>  NAT à cône plein <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gn/ar/8u/gnar8u7m0xlyigrhgihadyqe0d0.png"></div><br><ul><li>  Après la création d'une entrée dans la table de traduction d'adresses (adresse interne: port interne) - (adresse externe: port externe), tous les paquets de l'expéditeur (adresse interne: port interne) sont transmis via (adresse externe: port externe) à n'importe quelle adresse de destinataire. <br></li><li>  Tout serveur externe peut envoyer des paquets à (adresse interne: port interne), envoyer des paquets à (adresse externe: port externe). <br></li></ul>  Par exemple, le client C envoie des paquets aux serveurs A et D en utilisant la même adresse externe 203.0.113.5► 202050.  Si le serveur E envoie un paquet à cette adresse 203.0.113.5► 202050, le routeur le transmettra au client C. <br></li><li>  NAT à cône à adresse restreinte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i6/on/ao/i6onaojluqotmemktgufswzg-ia.png"></div><br><ul><li>  Après la création d'une entrée dans la table de traduction d'adresses (adresse interne: port interne) - (adresse externe: port externe), tous les paquets de l'expéditeur (adresse interne: port interne) sont transmis via (adresse externe: port externe) à n'importe quelle adresse de destinataire. <br></li><li>  Un serveur externe (adresse du serveur: port du serveur) peut envoyer des paquets à (adresse interne: port interne), en envoyant des paquets à (adresse externe: port externe) uniquement si (adresse interne: port interne) précédemment envoyé des paquets à (adresse du serveur: tout port). <br></li></ul>  Par exemple, le client C envoie des paquets aux serveurs A et D en utilisant la même adresse externe 203.0.113.5► 202050.  Le serveur D peut envoyer un paquet au client C via l'adresse de routeur 203.0.113.5► 202050 depuis n'importe lequel de ses ports.  Mais le routeur ne transmettra pas les paquets du serveur E. <br></li><li>  NAT à cône restreint au port. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kr/6v/di/kr6vdi2regppcywwajtz-1basdy.png"></div><br><ul><li>  Après la création d'une entrée dans la table de traduction d'adresses (adresse interne: port interne) - (adresse externe: port externe), tous les paquets de l'expéditeur (adresse interne: port interne) sont transmis via (adresse externe: port externe) à n'importe quelle adresse de destinataire. <br></li><li>  Un serveur externe (adresse du serveur: port du serveur) peut envoyer des paquets à (adresse interne: port interne), en envoyant des paquets à (adresse externe: port externe) uniquement si (adresse interne: port interne) précédemment envoyé des paquets à (adresse du serveur: port serveur). <br></li></ul>  Par exemple, le client C envoie des paquets aux serveurs A et D en utilisant la même adresse externe 203.0.113.5► 202050.  Le routeur ne transmettra pas les paquets du serveur E ou d'un autre port de serveur D. <br></li><li>  NAT symétrique (NAT symétrique). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/98/ha/lr/98halr7veiq_ibj_irj2lxixcec.png"></div><br><ul><li>  Si le même expéditeur interne (adresse interne: port interne) envoie des paquets à différents destinataires (adresse de serveur: port de serveur), un port externe distinct sera alloué pour chaque adresse de destinataire et une entrée distincte sera utilisée dans la table de traduction des adresses. <br></li><li>  Seul le serveur externe (adresse du serveur: port du serveur) qui a reçu le paquet de l'expéditeur interne (adresse interne: port interne) peut renvoyer le paquet. <br></li></ul>  Par exemple, le client C envoie des paquets au serveur A en utilisant une adresse externe 203.0.113.5► 202050, et au serveur D en utilisant une autre adresse externe 203.0.113.5.20201.  Le routeur ne transmettra pas les paquets du serveur E ou d'un autre port de serveur D. <br></li></ul></li><li>  Si plusieurs clients sont connectés au serveur de jeu, pour un jeu d'égal à égal, vous devez établir une connexion directement entre chaque paire de clients contournant le serveur. <br><br>  Par exemple, deux clients C et E connectés au serveur A: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ai/if/ym/aiifymcc-epffu0da8rkksj_4es.png"></div><br><ul><li>  Le client C a une adresse interne de 192.168.1.5/100150 et une adresse externe de 203.0.113.5/102050. <br></li><li>  Le client E a une adresse interne de 192.168.2.5:50250 et une adresse externe de 203.0.113.6-062060. <br></li><li>  Le serveur doit indiquer à chaque client l'adresse externe de l'autre client. <br></li><li>  En règle générale, les routeurs utilisent un NAT de type NAT à cône restreint au port.  Le routeur transmet les paquets au client uniquement à partir de l'expéditeur (adresse IP et port) auquel le client a envoyé les paquets plus tôt.  Et si le client C envoie un paquet au client E, le routeur D ne manquera pas ce paquet. <br></li><li>  Dans ce cas, la méthode de <a href="https://en.wikipedia.org/wiki/UDP_hole_punching" rel="nofollow">perforation UDP</a> est utilisée.  Les deux clients doivent s’envoyer des paquets UDP.  Dès que le client C envoie un paquet au client E, alors le routeur B sera prêt à recevoir des paquets du client E. De même, dès que le client E envoie un paquet au client C, alors le routeur D sera prêt à recevoir des paquets du client C. Les premiers paquets du client qui a démarré transmettre en premier sera perdu.  Mais dès que le deuxième client commence également à envoyer des paquets vers, les deux clients pourront échanger des paquets. <br></li><li>  Mais si le routeur utilise NAT symétrique, un nouveau port externe sera alloué à chaque destinataire.  Et, en règle générale, il n'y a aucun moyen de savoir quel port le routeur a alloué.  Par conséquent, si au moins l'un des routeurs utilise NAT symétrique, il sera impossible d'établir une connexion entre les clients. <br></li></ul></li><li>  Si deux clients sont sur le même réseau local, ils ne connaîtront que les adresses externes de l'autre. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jj/si/a4/jjsia4y7k50gk3esxa_5hvzx3ks.png"></div><br>  Par exemple, le client C envoie un paquet au client D à son adresse externe 203.0.113.5Point2051.  Le routeur B doit traiter ce paquet comme s'il était reçu d'un réseau externe, remplacer l'adresse du destinataire 203.0.113.5► 20201 par l'adresse interne du client D 192.168.1.6►0060 et renvoyer le paquet au client D vers le réseau local.  Cette fonction de routeur est appelée <a href="https://ru.wikipedia.org/wiki/NAT" rel="nofollow">boucle de</a> <a href="https://en.wikipedia.org/wiki/Hairpinning" rel="nofollow">NAT</a> ( <a href="https://en.wikipedia.org/wiki/Hairpinning" rel="nofollow">épingle à cheveux NAT</a> ).  Si le bouclage NAT est désactivé sur le routeur, il sera impossible d'établir une connexion entre les clients. <br></li><li>  Les clients peuvent être situés dans différents réseaux locaux, mais ont accès à Internet via un fournisseur Internet commun. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/q8/dj/yo/q8djyoaqbhaq6z3_wxc7_afbphk.png"></div><br>  Si le bouclage NAT est désactivé sur l'équipement du fournisseur de services Internet, il sera impossible d'établir une connexion entre les clients. <br></li><li>  Que dois-je faire si le NAT symétrique est utilisé sur le routeur ou si le bouclage NAT est désactivé? <br><br>  Si je comprends bien, le seul moyen fiable de résoudre ces problèmes est de transférer les paquets non pas directement entre les clients, mais via un serveur.  Il est nécessaire soit d'implémenter cette fonction dans le programme de jeu dans le cadre de l'architecture peer-to-peer, soit d'implémenter l'architecture client-serveur. <br><br>  Ou vous pouvez utiliser des programmes tiers pour créer un VPN, par exemple <a href="https://ru.wikipedia.org/wiki/LogMeIn_Hamachi" rel="nofollow">LogMeIn Hamachi</a> . <br></li></ul><br><h2>  Établir une connexion entre des LAN sur Internet </h2><br><ul><li>  En règle générale, aucun des joueurs n'a d'adresse IP publique et les joueurs se trouvent sur différents réseaux locaux derrière NAT. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/56/cr/up/56crup-geun05fnbtaokha2vqia.png"></div><br>  Par exemple, dans ce schéma, le client C enverra des paquets au serveur A à son adresse externe 203.0.113.2-022020, dans laquelle le port est sélectionné par le routeur B.Par conséquent, le choix du port interne du serveur A n'a pas d'importance et vous pouvez sélectionner n'importe quel port.  Dans ce cas, au lieu du port 49094, le serveur A peut demander n'importe quel port libre au système d'exploitation, par exemple 50120. <br></li><li>  Pour que le serveur A et le client C établissent une connexion, tout d'abord, chacun d'eux doit en quelque sorte trouver son adresse externe. <br><br>  Pour cela, vous pouvez utiliser le protocole <a href="https://ru.wikipedia.org/wiki/STUN" rel="nofollow">STUN (Session Traversal Utilities for NAT)</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sk/lj/cm/skljcmi1c5ztbt6law8nf_ylsy0.png"></div><br>  Le protocole STUN permet au client situé derrière NAT de déterminer son adresse IP externe et son port. <br><br>  Les messages STUN sont envoyés dans des paquets UDP. <br><br>  Le client peut accéder à n'importe lequel des serveurs STUN publics.  Une liste de serveurs STUN publics peut être trouvée sur <a href="https://ru.wikipedia.org/wiki/STUN" rel="nofollow">Wikipedia</a> .  Ou recherchez <a href="https://www.google.com/search%3Fq%3Dpublic%2BSTUN%2Bservers%2Blist" rel="nofollow">«liste des serveurs STUN publics»</a> . <br><br>  Cette méthode n'est pas applicable si au moins un des lecteurs du routeur utilise «NAT symétrique». <br></li><li>  Après que chacun des joueurs a appris son adresse externe, il doit en quelque sorte donner son adresse à tous les autres joueurs. <br><br>  Pour que les joueurs puissent échanger leurs adresses, vous pouvez utiliser votre serveur public.  Dans le diagramme, il est appelé serveur d'adresses. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ev/e_/fi/eve_fiqezp76wwmjfexsb0vlzka.png"></div><br>  Cela ne nécessite pas nécessairement un serveur dédié.  Vous pouvez utiliser n'importe quel hébergement avec un <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B5%25D0%25B1-%25D1%2581%25D0%25B5%25D1%2580%25D0%25B2%25D0%25B5%25D1%2580" rel="nofollow">serveur Web</a> et avec le support de tout langage de script, tel que PHP.  En utilisant le <a href="https://ru.wikipedia.org/wiki/HTTP" rel="nofollow">protocole HTTP,</a> chaque joueur doit envoyer son adresse externe au serveur d'adresses.  Et puis demandez les adresses de tous les autres joueurs. <br></li><li>  Par exemple, chaque serveur de jeux peut enregistrer son identifiant unique (game-id) sur le serveur d'adresses.  Vous pouvez utiliser n'importe quelle chaîne comme identifiant de jeu, par exemple, le surnom (alias) de l'utilisateur du serveur.  L'utilisateur du serveur indique en quelque sorte l'ID de jeu aux joueurs qu'il souhaite inviter à sa partie.  Et ces joueurs pourront rejoindre le jeu en demandant par game-id au serveur d'adresse les adresses externes de tous les participants à ce jeu. <br></li><li>  Une fois que chaque joueur a reçu les adresses externes de tous les autres joueurs, ils peuvent établir des connexions entre eux en utilisant la <a href="https://en.wikipedia.org/wiki/UDP_hole_punching" rel="nofollow">méthode de perforation UDP</a> . <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr485576/">https://habr.com/ru/post/fr485576/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr485556/index.html">Il a fallu 12 ans pour créer une section de la carte du cerveau de la drosophile, les efforts de 250 personnes et 40 millions de dollars</a></li>
<li><a href="../fr485558/index.html">Pas de moustiques! Aperçu des moustiques "phyto-munitions"</a></li>
<li><a href="../fr485562/index.html">Surfer sur Internet avec une manette de jeu (Javascript)</a></li>
<li><a href="../fr485564/index.html">Ingénierie inverse du protocole Ngrok v2</a></li>
<li><a href="../fr485570/index.html">Agrégation des routes pour les listes ILV et comment elle menace des services respectables</a></li>
<li><a href="../fr485578/index.html">Mahjong avec enfants: pour quoi, quand et comment</a></li>
<li><a href="../fr485582/index.html">Paul Graham: «Un investisseur comme un troupeau d'animaux» (2013)</a></li>
<li><a href="../fr485584/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 399 (20-26 janvier 2020)</a></li>
<li><a href="../fr485586/index.html">Paul Graham: Idées pour les startups (Idées pour les startups, 2005)</a></li>
<li><a href="../fr485592/index.html">PHP Digest n ° 172 (14-27 janvier 2020)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>