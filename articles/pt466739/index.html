<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïµÔ∏è üßëüèº‚Äçü§ù‚Äçüßëüèº üôÖüèΩ O melhor √© o inimigo do bem üë¥ üë®üèª‚Äç‚úàÔ∏è üöà</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo √© a hist√≥ria de como decidimos melhorar nossa ferramenta interna de Autoteste que aplicamos para testar a qualidade do analisador PVS-Stud...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O melhor √© o inimigo do bem</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/466739/"><p><img src="https://habrastorage.org/getpro/habr/post_images/982/355/890/982355890903cccb9e35a693d48d72cf.png" alt="Quadro 6" align="left"></p>  Este artigo √© a hist√≥ria de como decidimos melhorar nossa ferramenta interna de Autoteste que aplicamos para testar a qualidade do analisador PVS-Studio.  A melhoria foi simples e parecia √∫til, mas nos meteu em alguns problemas.  Mais tarde, descobrimos que √© melhor desistirmos da ideia. <br><a name="habracut"></a><br><h2>  Selftester </h2><br>  Desenvolvemos e promovemos o analisador de c√≥digo est√°tico PVS-Studio para C, C ++, C # e Java.  Para testar a qualidade do nosso analisador, usamos ferramentas internas, chamadas genericamente de SelfTester.  Criamos uma vers√£o separada do SelfTester para cada idioma suportado.  Isso se deve a especificidades dos testes e √© apenas mais conveniente.  Portanto, no momento, temos tr√™s ferramentas internas do SelfTester em nossa empresa para C \ C ++, C # e Java, respectivamente.  Al√©m disso, vou falar sobre a vers√£o Windows do SelfTester para projetos do Visual Studio em C \ C ++, chamando-a simplesmente SelfTester.  Este testador foi o primeiro da linha de ferramentas internas semelhantes, √© o mais avan√ßado e complexo de todos. <br><br>  Como o SelfTester funciona?  A id√©ia √© simples: pegue um conjunto de projetos de teste (estamos usando projetos reais de c√≥digo aberto) e analise-os usando o PVS-Studio.  Como resultado, um log do analisador √© gerado para cada projeto.  Este log √© comparado com o log de <i>refer√™ncia</i> do mesmo projeto.  Ao comparar logs, o SelfTester cria um <i>resumo</i> dos logs comparando de uma maneira conveniente para o desenvolvedor. <br><br>  Depois de estudar o resumo, um desenvolvedor conclui sobre altera√ß√µes no comportamento do analisador de acordo com o n√∫mero e tipo de avisos, velocidade de trabalho, erros internos do analisador, etc.  Toda essa informa√ß√£o √© muito importante: permite que voc√™ esteja ciente de como o analisador lida com seu trabalho. <br><br>  Com base no resumo da compara√ß√£o de logs, um desenvolvedor introduz altera√ß√µes no n√∫cleo do analisador (por exemplo, ao criar uma nova regra de diagn√≥stico) e controla imediatamente o resultado de suas edi√ß√µes.  Se um desenvolvedor n√£o tiver mais problemas na compara√ß√£o regular de logs, ele far√° uma <i>refer√™ncia</i> <i>atual do</i> log de avisos para um projeto.  Caso contr√°rio, o trabalho continua. <br><br>  Portanto, a tarefa do SelfTester √© trabalhar com um conjunto de projetos de teste (a prop√≥sito, existem mais de 120 deles para C / C ++).  Projetos para o pool s√£o selecionados na forma de solu√ß√µes do Visual Studio.  Isso √© feito para verificar adicionalmente o trabalho do analisador em v√°rias vers√µes do Visual Studio, que suportam o analisador (neste momento, do Visual Studio 2010 ao Visual Studio 2019). <br><br>  <i>Nota:</i> al√©m disso, separarei os conceitos <i>solu√ß√£o</i> e <i>projeto</i> , considerando um projeto como parte de uma solu√ß√£o. <br><br>  A interface do SelfTester tem a seguinte apar√™ncia: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d0/627/355/1d0627355eb338938aa789d33aedec83.png" alt="Quadro 3"></div><br>  √Ä esquerda, h√° uma lista de solu√ß√µes, √† direita - resultados de uma verifica√ß√£o para cada vers√£o do Visual Studio. <br><br>  R√≥tulos em cinza "N√£o suportado" indicam que uma solu√ß√£o n√£o suporta uma vers√£o escolhida do Visual Studio ou n√£o foi convertida para esta vers√£o.  Algumas solu√ß√µes t√™m uma configura√ß√£o em um pool, que indica uma vers√£o espec√≠fica do Visual Studio para uma verifica√ß√£o.  Se uma vers√£o n√£o for especificada, uma solu√ß√£o ser√° atualizada para todas as vers√µes subseq√ºentes do Visual Studio.  Um exemplo dessa solu√ß√£o est√° na captura de tela - "smart_ptr_check.sln" (√© feita uma verifica√ß√£o para todas as vers√µes do Visual Studio). <br><br>  Um r√≥tulo verde "OK" indica que uma verifica√ß√£o regular n√£o detectou diferen√ßas com o log de refer√™ncia.  Um r√≥tulo vermelho "Dif." Indica sobre diferen√ßas.  Esses r√≥tulos devem receber aten√ß√£o especial.  Depois de clicar duas vezes no r√≥tulo necess√°rio, a solu√ß√£o escolhida ser√° aberta em uma vers√£o relacionada do Visual Studio.  Uma janela com um log de avisos tamb√©m ser√° aberta l√°.  Os bot√µes de controle na parte inferior permitem executar novamente a an√°lise das solu√ß√µes selecionadas ou de todas as solu√ß√µes, fazer a refer√™ncia do log escolhido (ou de uma s√≥ vez), etc. <br><br>  Os resultados do SelfTester s√£o sempre duplicados no relat√≥rio html (relat√≥rio diffs) <br><br>  Al√©m da GUI, o SelfTester tamb√©m possui modos automatizados para execu√ß√µes noturnas.  No entanto, o padr√£o de uso usual que o desenvolvedor repetido executa por um desenvolvedor durante o dia de trabalho.  Portanto, uma das caracter√≠sticas mais importantes do SelfTester √© a velocidade do trabalho. <br><br>  Por que a velocidade √© importante: <br><br><ol><li> O desempenho de cada etapa √© bastante crucial em termos de testes noturnos.  Obviamente, quanto mais r√°pido os testes forem aprovados, melhor.  No momento, o tempo m√©dio de desempenho do SelfTester excede 2 horas; </li><li>  Ao executar o SelfTester durante o dia, um desenvolvedor precisa esperar menos pelo resultado, o que aumenta a produtividade de sua for√ßa de trabalho. </li></ol><br>  Foi a acelera√ß√£o do desempenho que se tornou o motivo de aprimoramentos dessa vez. <br><br><h2>  Multiencadeamento no SelfTester </h2><br>  O SelfTester foi criado inicialmente como um aplicativo multithread, com a capacidade de testar simultaneamente v√°rias solu√ß√µes.  A √∫nica limita√ß√£o era que voc√™ n√£o podia verificar simultaneamente a mesma solu√ß√£o para diferentes vers√µes do Visual Studio, porque muitas solu√ß√µes precisam ser atualizadas para determinadas vers√µes do Visual Studio antes do teste.  Durante o curso, as altera√ß√µes s√£o introduzidas diretamente nos arquivos dos projetos <i>.vcxproj</i> , o que gera erros durante a execu√ß√£o paralela. <br><br>  Para tornar o trabalho mais eficiente, o SelfTester usa um agendador de tarefas inteligente para definir e manter um valor estritamente limitado de encadeamentos paralelos. <br><br>  O planejador √© usado em dois n√≠veis.  A primeira √© o n√≠vel de <i>solu√ß√µes</i> , √© usada para come√ßar a testar a solu√ß√£o <i>.sln</i> usando o utilit√°rio <i>PVS-Studio_Cmd.exe</i> .  O mesmo agendador, mas com outra configura√ß√£o de <i>grau</i> de <i>paralelismo</i> , √© usado dentro do <i>PVS-Studio_Cmd.exe</i> (no n√≠vel de teste dos <i>arquivos de</i> origem). <br><br>  O grau de paralelismo √© um par√¢metro que indica quantos encadeamentos paralelos precisam ser executados simultaneamente.  <i>Quatro</i> e <i>oito</i> valores padr√£o foram escolhidos para o grau de paralelismo do n√≠vel de solu√ß√µes e arquivos, respectivamente.  Portanto, o n√∫mero de threads paralelos nesta implementa√ß√£o deve ser 32 (4 solu√ß√µes testadas simultaneamente e 8 arquivos).  Essa configura√ß√£o nos parece √≥tima para o trabalho do analisador em um processador de oito n√∫cleos. <br><br>  Um desenvolvedor pode definir outros valores do grau de paralelismo, de acordo com o desempenho do computador ou as tarefas atuais.  Se um desenvolvedor n√£o especificar esse par√¢metro, o n√∫mero de processadores do sistema l√≥gico ser√° escolhido por padr√£o. <br><br>  <i>Nota:</i> vamos supor que lidamos com o grau padr√£o de paralelismo. <br><br>  O planejador <i>LimitedConcurrencyLevelTaskScheduler</i> √© herdado de <i>System.Threading.Tasks.TaskScheduler</i> e refinado para fornecer o n√≠vel m√°ximo de paralelismo ao trabalhar sobre o <i>ThreadPool</i> .  Hierarquia de heran√ßa: <br><br><pre><code class="cs hljs">LimitedConcurrencyLevelTaskScheduler : PausableTaskScheduler { .... } PausableTaskScheduler: TaskScheduler { .... }</code> </pre> <br>  <i>PausableTaskScheduler</i> permite pausar o desempenho da tarefa e, al√©m disso, o <i>LimitedConcurrencyLevelTaskScheduler</i> fornece controle intelectual da fila de tarefas e agende seu desempenho, levando em considera√ß√£o o grau de paralelismo, o escopo das tarefas agendadas e outros fatores.  Um planejador √© usado ao executar tarefas <i>LimitedConcurrencyLevelTaskScheduler</i> . <br><br><h2>  Raz√µes para refinamentos </h2><br>  O processo descrito acima tem uma desvantagem: n√£o √© ideal quando se lida com solu√ß√µes de tamanhos diferentes.  E o tamanho das solu√ß√µes no pool de teste √© <i>muito</i> diversificado: de 8 KB a 4 GB - o tamanho de uma pasta com uma solu√ß√£o e de 1 a v√°rios milhares de arquivos de c√≥digo-fonte em cada um. <br><br>  O planejador coloca solu√ß√µes na fila simplesmente uma ap√≥s a outra, sem nenhum componente inteligente.  Deixe-me lembr√°-lo de que, por padr√£o, n√£o mais de quatro solu√ß√µes podem ser testadas simultaneamente.  Se quatro solu√ß√µes grandes forem testadas atualmente (o n√∫mero de arquivos em cada uma √© superior a oito), presume-se que trabalhemos efetivamente porque usamos o maior n√∫mero poss√≠vel de threads (32). <br><br>  Mas vamos imaginar uma situa√ß√£o bastante frequente, quando v√°rias pequenas solu√ß√µes s√£o testadas.  Por exemplo, uma solu√ß√£o √© grande e cont√©m 50 arquivos (o n√∫mero m√°ximo de threads ser√° usado), enquanto outras tr√™s solu√ß√µes cont√™m tr√™s, quatro, cinco arquivos cada.  Nesse caso, usaremos apenas 20 threads (8 + 3 + 4 + 5).  Temos subutiliza√ß√£o do tempo do processador e reduzimos o desempenho geral. <br><br>  <i>Nota</i> : na verdade, o gargalo √© geralmente o subsistema de disco, n√£o o processador. <br><br><h2>  Melhorias </h2><br>  A melhoria que √© evidente neste caso √© a classifica√ß√£o da lista de solu√ß√µes testadas.  Precisamos obter o uso ideal do n√∫mero definido de threads executados simultaneamente (32), passando para testar projetos com o n√∫mero correto de arquivos. <br><br>  Vamos considerar novamente nosso exemplo de teste de quatro solu√ß√µes com o seguinte n√∫mero de arquivos em cada um: 50, 3, 4 e 5. A tarefa que verifica uma solu√ß√£o de <i>tr√™s</i> arquivos provavelmente funcionar√° mais rapidamente.  Seria melhor adicionar uma solu√ß√£o com oito ou mais arquivos em vez dela (para usar o m√°ximo dos threads dispon√≠veis para esta solu√ß√£o).  Dessa forma, utilizaremos 25 threads de uma s√≥ vez (8 + <b>8</b> + 4 + 5).  Nada mal.  No entanto, sete threads ainda n√£o est√£o envolvidos.  E aqui vem a id√©ia de outro refinamento, que √© remover o limite de quatro threads nas solu√ß√µes de teste.  Porque agora podemos adicionar n√£o uma, mas v√°rias solu√ß√µes, utilizando 32 threads.  Vamos imaginar que temos mais duas solu√ß√µes de tr√™s e quatro arquivos cada.  A adi√ß√£o dessas tarefas fechar√° completamente a "lacuna" de threads n√£o utilizados e haver√° 32 (8 + 8 + 4 + 5 + <b>3</b> + <b>4</b> ) deles. <br><br>  Espero que a ideia seja clara.  De fato, a implementa√ß√£o dessas melhorias tamb√©m n√£o exigiu muito esfor√ßo.  Tudo foi feito em um dia. <br><br>  Precis√°vamos refazer a classe de tarefa: herdar de <i>System.Threading.Tasks.Task</i> e atribuir o campo "peso".  Utilizamos um algoritmo simples para definir peso para uma solu√ß√£o: se o n√∫mero de arquivos for menor que oito, o peso ser√° igual a esse n√∫mero (por exemplo, 5).  Se o n√∫mero for maior ou igual a oito, o peso ser√° igual a oito. <br><br>  Tamb√©m tivemos que elaborar o agendador: ensin√°-lo a escolher solu√ß√µes com o peso necess√°rio para atingir o valor m√°ximo de 32 threads.  Tamb√©m tivemos que permitir mais de quatro threads para teste de solu√ß√µes simult√¢neas. <br><br>  Por fim, precis√°vamos de uma etapa preliminar para analisar todas as solu√ß√µes no pool (avalia√ß√£o usando a API do MSBuild) para avaliar e definir o peso das solu√ß√µes (obter n√∫meros de arquivos com o c√≥digo-fonte). <br><br><h2>  Resultado </h2><br>  Acho que depois de uma introdu√ß√£o t√£o longa, voc√™ j√° adivinhou que nada aconteceu. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91c/6c1/fca/91c6c1fca4017036c0fca83fd2113474.png" alt="Quadro 12"></div><br>  √â bom que as melhorias tenham sido simples e r√°pidas. <br><br>  A√≠ vem a parte do artigo, onde vou falar sobre o que "nos causou muitos problemas" e todas as coisas relacionadas a ele. <br><br><h2>  Efeitos colaterais </h2><br>  Portanto, um resultado negativo tamb√©m √© um resultado.  Verificou-se que o n√∫mero de solu√ß√µes grandes no pool <i>excede em muito</i> o n√∫mero de pequenas (menos de oito arquivos).  Nesse caso, essas melhorias n√£o t√™m um efeito muito percept√≠vel, pois s√£o quase invis√≠veis: testar pequenos projetos leva uma quantidade min√∫scula de tempo em compara√ß√£o ao tempo, necess√°ria para grandes projetos. <br><br>  No entanto, decidimos deixar o novo refinamento como "n√£o perturbador" e potencialmente √∫til.  Al√©m disso, o conjunto de solu√ß√µes de teste √© constantemente reabastecido; portanto, no futuro, talvez, a situa√ß√£o mude. <br><br>  E ent√£o ... <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdf/906/0ea/bdf9060ea6b9d1ce17ed820acc1468c7.png" alt="Quadro 5"></div><br>  Um dos desenvolvedores reclamou da queda do SelfTester.  Bem, a vida acontece.  Para evitar que esse erro seja perdido, criamos um incidente interno (ticket) com o nome "Exce√ß√£o ao trabalhar com o SelfTester".  O erro ocorreu ao avaliar o projeto.  Embora um grande n√∫mero de janelas com erros indique o problema de volta no manipulador de erros.  Mas isso foi rapidamente eliminado e, na semana seguinte, nada caiu.  De repente, outro usu√°rio reclamou do SelfTester.  Novamente, o erro de uma avalia√ß√£o de projeto: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0fa/1f3/bd5/0fa1f3bd596a2a4bdbbc0f9ace32664c.png" alt="Quadro 8"></div><br>  Desta vez, a pilha continha muitas informa√ß√µes √∫teis - o erro estava no formato xml.  √â prov√°vel que, ao manipular o arquivo do projeto <i>Proto_IRC.vcxproj</i> (sua representa√ß√£o xml), algo tenha acontecido com o pr√≥prio arquivo, por isso o <i>XmlTextReader</i> n√£o conseguiu lidar com isso. <br><br>  Ter dois erros em um per√≠odo bastante curto nos levou a olhar mais de perto o problema.  Al√©m disso, como eu disse acima, o SelfTester √© usado ativamente pelos desenvolvedores. <br><br>  Para come√ßar, analisamos a √∫ltima falha.  √â triste dizer que n√£o encontramos nada suspeito.  Para o caso de pedirmos aos desenvolvedores (usu√°rios do SelfTester) que estejam atentos e relatem poss√≠veis erros. <br><br>  Ponto importante: o c√≥digo incorreto foi reutilizado no SelfTester.  Foi originalmente usado para avaliar projetos no pr√≥prio analisador ( <i>PVS-Studio_Cmd.exe</i> ).  √â por isso que a aten√ß√£o ao problema aumentou.  No entanto, n√£o houve essas falhas no analisador. <br><br>  Enquanto isso, o ticket sobre problemas com o SelfTester foi complementado com novos erros: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b49/15a/0ae/b4915a0aecc426246419f4a26e62a233.png" alt="Quadro 9"></div><br>  <i>XmlException</i> novamente.  Obviamente, existem threads concorrentes em algum lugar que trabalham com a leitura e grava√ß√£o de arquivos de projeto.  O SelfTester trabalha com projetos nos seguintes casos: <br><br><ol><li>  Avalia√ß√£o de projetos no curso do c√°lculo preliminar dos pesos das solu√ß√µes: uma nova etapa que inicialmente despertou suspeitas; </li><li>  A atualiza√ß√£o de projetos para as vers√µes necess√°rias do Visual Studio: √© executada imediatamente antes do teste (os projetos n√£o interferem) e n√£o deve afetar o processo de trabalho. </li><li>  Avalia√ß√£o de projetos durante o teste: um mecanismo bem estabelecido para seguran√ßa de threads, reutilizado no <i>PVS-Studio_Cmd.exe</i> ; </li><li>  Restaurando arquivos de projeto (substituindo arquivos <i>.vcxproj</i> modificados <i>por</i> arquivos de refer√™ncia iniciais) ao sair do SelfTester, porque os arquivos de projeto podem ser atualizados para as vers√µes necess√°rias do Visual Studio durante o trabalho.  √â uma etapa final, que n√£o tem impacto em outros mecanismos. </li></ol><br>  A suspeita recaiu sobre o novo c√≥digo adicionado para otimiza√ß√£o (c√°lculo de peso).  Mas sua investiga√ß√£o de c√≥digo mostrou que, se um usu√°rio executa a an√°lise logo ap√≥s o in√≠cio do SelfTester, o testador sempre espera corretamente at√© o final da pr√©-avalia√ß√£o.  Este lugar parecia seguro. <br><br>  Mais uma vez, n√£o conseguimos identificar a fonte do problema. <br><br><h2>  Dor </h2><br>  Durante todo o m√™s seguinte, o SelfTester continuou travando repetidamente.  O ticket continuava sendo preenchido com dados, mas n√£o estava claro o que fazer com esses dados.  A maioria das falhas ocorreu com o mesmo <i>XmlException.</i>  Ocasionalmente, havia algo mais, mas no mesmo c√≥digo reutilizado do <i>PVS-Studio_Cmd.exe</i> . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c31/fbe/c11/c31fbec1152210e397b6d9d1ffdb5aa6.png" alt="Quadro 1"></div><br>  Tradicionalmente, as ferramentas internas n√£o s√£o impostas requisitos muito altos, por isso continuamos confundindo os erros do SelfTester com um princ√≠pio residual.  De tempos em tempos, pessoas diferentes se envolviam (durante todo o incidente, seis pessoas trabalhavam no problema, incluindo dois estagi√°rios).  No entanto, tivemos que nos distrair com essa tarefa. <br><br>  <i>Nosso primeiro erro.</i>  De fato, neste ponto, poder√≠amos ter resolvido esse problema de uma vez por todas.  Como  Ficou claro que o erro foi causado por uma nova otimiza√ß√£o.  Afinal, antes disso tudo funcionava bem, e o c√≥digo reutilizado claramente n√£o pode ser t√£o ruim.  Al√©m disso, essa otimiza√ß√£o n√£o trouxe nenhum benef√≠cio.  Ent√£o, o que tinha que ser feito?  <i>Remova essa otimiza√ß√£o.</i>  Como voc√™ provavelmente entende, isso n√£o foi feito.  Continuamos trabalhando no problema que criamos a n√≥s mesmos.  Continuamos procurando a resposta: "COMO ???"  Como ele falha?  Parecia estar escrito corretamente. <br><br>  <i>Nosso segundo erro.</i>  <i>Outras pessoas se envolveram</i> na solu√ß√£o do problema <i>.</i>  √â um erro muito, muito grande.  N√£o apenas resolveu o problema, mas tamb√©m exigiu recursos adicionais desperdi√ßados.  Sim, novas pessoas trouxeram novas id√©ias, mas demorou muito tempo para implementar (√† toa) essas id√©ias.  Em algum momento, nossos estagi√°rios escreveram programas de teste emulando a avalia√ß√£o de um e do mesmo projeto em threads diferentes, com modifica√ß√£o paralela de um projeto em outro projeto.  Isso n√£o ajudou.  Descobrimos apenas que a API do MSBuild era segura para threads por dentro, o que j√° sab√≠amos.  Tamb√©m adicionamos o salvamento autom√°tico de mini despejo quando ocorre a exce√ß√£o <i>XmlException</i> .  T√≠nhamos algu√©m que estava depurando tudo isso.  Pobre rapaz!  Houve discuss√µes, fizemos outras coisas desnecess√°rias. <br><br>  <i>Finalmente, terceiro erro.</i>  Voc√™ sabe quanto tempo se passou desde o momento em que o problema do SelfTester ocorreu at√© o momento em que foi resolvido?  Bem, voc√™ pode contar a si mesmo.  O ingresso foi criado em 17/09/2018 e encerrado em 20/02/2019.  Foram mais de 40 coment√°rios!  Gente, isso √© muito tempo!  N√≥s <i>nos permitimos</i> ficar ocupados por cinco meses com ISTO.  Ao mesmo tempo, est√°vamos ocupados dando suporte ao Visual Studio 2019, adicionando o suporte √† linguagem Java, introduzindo o padr√£o MISRA C / C ++, melhorando o analisador C #, participando ativamente de confer√™ncias, escrevendo v√°rios artigos, etc.  Todas essas atividades receberam menos tempo dos desenvolvedores devido a um erro est√∫pido no SelfTester. <br><br>  Gente, aprenda com nossos erros e nunca fa√ßa isso.  N√≥s tamb√©m n√£o. <br><br>  √â isso, eu terminei. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a8/a29/f94/3a8a29f94aeed35ddeaec17222a4f990.png" alt="Quadro 15"></div><br>  Ok, foi uma piada, eu vou te contar qual foi o problema com o SelfTester :) <br><br><h2>  Bingo! </h2><br>  Felizmente, havia uma pessoa entre n√≥s com vis√£o n√≠tida (meu colega Sergey Vasiliev), que apenas olhou o problema de um √¢ngulo muito diferente (e tamb√©m - ele teve um pouco de sorte).  E se estiver tudo bem dentro do SelfTester, mas algo externo trava os projetos?  Normalmente, n√£o lan√ßamos nada com o SelfTester; em alguns casos, controlamos rigorosamente o ambiente de execu√ß√£o.  Nesse caso, esse "algo" poderia ser o pr√≥prio SelfTester, mas uma inst√¢ncia diferente. <br><br>  Ao sair do SelfTester, o encadeamento que restaura os arquivos do projeto a partir de refer√™ncias continua trabalhando por um tempo.  Nesse ponto, o testador pode ser iniciado novamente.  A prote√ß√£o contra execu√ß√µes simult√¢neas de v√°rias inst√¢ncias do SelfTester foi adicionada <i>posteriormente</i> e agora tem a seguinte apar√™ncia: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a3/7bf/437/0a37bf4373e3beb9bbfe2542afb258a0.png" alt="Quadro 16"></div><br>  Mas naquele momento n√£o t√≠nhamos. <br><br>  Porcas, mas √© verdade - durante quase seis meses de tormento, ningu√©m prestou aten√ß√£o a isso.  Restaurar projetos a partir de refer√™ncias √© um procedimento em segundo plano bastante r√°pido, mas infelizmente n√£o √© r√°pido o suficiente para n√£o interferir no relan√ßamento do SelfTester.  E o que acontece quando o lan√ßamos?  √â isso mesmo, calculando os pesos das solu√ß√µes.  Um processo reescreve arquivos <i>.vcxproj</i> enquanto outro tenta l√™-los.  Diga oi para <i>XmlException</i> . <br><br>  Sergey descobriu tudo isso quando adicionou a capacidade de alternar para um conjunto diferente de logs de refer√™ncia no testador.  Tornou-se necess√°rio ap√≥s adicionar um conjunto de regras MISRA no analisador.  Voc√™ pode alternar diretamente na interface, enquanto o usu√°rio v√™ esta janela: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a5/9b0/87d/0a59b087d0e13688ab41a690ed490a3f.png" alt="Quadro 14"></div><br>  Depois disso, o <i>SelfTester √©</i> reiniciado.  E antes, aparentemente, os usu√°rios de alguma forma imitaram o problema, executando o testador novamente. <br><br><h2>  Blamestorming e conclus√µes </h2><br>  Obviamente, removemos (ou seja, desativamos) a otimiza√ß√£o criada anteriormente.  Al√©m disso, era muito mais f√°cil do que fazer algum tipo de sincroniza√ß√£o entre as reinicializa√ß√µes do testador por si s√≥.  E tudo come√ßou a funcionar perfeitamente, como antes.  E como uma medida adicional, adicionamos a prote√ß√£o acima contra o lan√ßamento simult√¢neo do testador. <br><br>  Eu j√° escrevi acima sobre nossos principais erros ao procurar o problema, o suficiente para auto-flagela√ß√£o.  Somos seres humanos, ent√£o podemos estar errados.  √â importante aprender com seus pr√≥prios erros e tirar conclus√µes.  As conclus√µes deste caso s√£o bastante simples: <br><br><ul><li>  Devemos monitorar e estimar a complexidade da tarefa; </li><li>  √Äs vezes, precisamos parar em algum momento; </li><li>  Tente analisar o problema de maneira mais ampla.  Com o tempo, √© poss√≠vel obter uma vis√£o em t√∫nel do caso, enquanto isso requer uma nova perspectiva. </li><li>  N√£o tenha medo de excluir c√≥digo antigo ou desnecess√°rio. </li></ul><br>  √â isso, desta vez eu definitivamente estou pronto.  Obrigado por ler at√© o fim.  Desejo-lhe c√≥digo sem erros! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt466739/">https://habr.com/ru/post/pt466739/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt466729/index.html">O livro "Minera√ß√£o de dados. Recuperando informa√ß√µes do Facebook, Twitter, LinkedIn, Instagram, GitHub ¬ª</a></li>
<li><a href="../pt466731/index.html">Extravag√¢ncia. Setembro sobe</a></li>
<li><a href="../pt466733/index.html">Bem-vindo ao DINS Java EVENTO 18 de setembro</a></li>
<li><a href="../pt466735/index.html">Uma maneira f√°cil de criar um alerta de voz no sistema de automa√ß√£o residencial (‚ÄúSmart Home‚Äù)</a></li>
<li><a href="../pt466737/index.html">Por que a rede social do Google+ falhou</a></li>
<li><a href="../pt466741/index.html">O melhor √© o inimigo do bem</a></li>
<li><a href="../pt466745/index.html">O primeiro local de trabalho ou como come√ßar a desenvolver API no Node.js</a></li>
<li><a href="../pt466747/index.html">Desenvolvedores Mitap iOS na Redmadrobot</a></li>
<li><a href="../pt466753/index.html">Administra√ß√£o de rede r√°pida e eficiente - Network MACMonitor</a></li>
<li><a href="../pt466755/index.html">O computador vai te deixar gostoso</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>