<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤙🏾 💔 👩🏽‍🎤 Vorbereitungen für C ++ 20. Coroutines TS Real Fallstudie ⛴️ 🍂 👨🏾‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In C ++ 20 wird die Möglichkeit angezeigt, sofort mit Coroutinen zu arbeiten. Dieses Thema ist für uns bei Yandex.Taxi nah und interessant (für unsere...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vorbereitungen für C ++ 20. Coroutines TS Real Fallstudie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/420861/">  In C ++ 20 wird die Möglichkeit angezeigt, sofort mit Coroutinen zu arbeiten.  Dieses Thema ist für uns bei Yandex.Taxi nah und interessant (für unsere eigenen Bedürfnisse entwickeln wir ein asynchrones Framework).  Daher werden wir heute den Lesern von Habr anhand eines realen Beispiels zeigen, wie man mit stapellosen C ++ - Coroutinen arbeitet. <br><br>  Nehmen wir als Beispiel etwas Einfaches: Ohne mit asynchronen Netzwerkschnittstellen zu arbeiten, asynchrone Timer, die aus einer Funktion bestehen.  Versuchen wir beispielsweise, diese „Nudel“ aus Rückrufen zu realisieren und neu zu schreiben: <br><br><img align="right" src="https://habrastorage.org/webt/za/0m/kp/za0mkphg8qyitvudyvv-dhunfae.jpeg"><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FuncToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); writerQueue.PushTask([=]() { InWriterThread1(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> finally = [=]() { InWriterThread2(); ShutdownAll(); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedNetwork()) { networkQueue.PushTask([=](){ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = InNetworkThread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v) { UIQueue.PushTask([=](){ InUIThread(); writerQueue.PushTask(finally); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { writerQueue.PushTask(finally); } }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { finally(); } }); }</code> </pre> <br><a name="habracut"></a><br><h2>  Einführung </h2><br>  Coroutinen oder Coroutinen sind die Fähigkeit, die Ausführung einer Funktion an einem vordefinierten Ort zu verhindern.  Übergeben Sie irgendwo den gesamten Status der gestoppten Funktion zusammen mit lokalen Variablen.  Führen Sie die Funktion an derselben Stelle aus, an der wir sie gestoppt haben. <br>  Es gibt verschiedene Arten von Coroutinen: stapellos und stapelbar.  Wir werden später darüber sprechen. <br><br><h2>  Erklärung des Problems </h2><br>  Wir haben mehrere Aufgabenwarteschlangen.  Jede Aufgabe enthält bestimmte Aufgaben: Es gibt eine Warteschlange zum Zeichnen von Grafiken, eine Warteschlange für Netzwerkinteraktionen und eine Warteschlange für die Arbeit mit einer Festplatte.  Alle Warteschlangen sind Instanzen der WorkQueue-Klasse mit der void PushTask-Methode (std :: function &lt;void ()&gt; task);  Warteschlangen leben länger als alle darin platzierten Aufgaben (die Situation, dass wir eine Warteschlange zerstört haben, wenn noch offene Aufgaben darin sind, sollte nicht auftreten). <br><br>  Die Funktion FuncToDealWith () aus dem Beispiel führt eine Logik in verschiedenen Warteschlangen aus und stellt abhängig von den Ergebnissen der Ausführung eine neue Aufgabe in die Warteschlange. <br><br>  Wir schreiben die „Nudeln“ von Rückrufen in Form eines linearen Pseudocodes neu und markieren, in welcher Warteschlange der zugrunde liegende Code ausgeführt werden soll: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CoroToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); <span class="hljs-comment"><span class="hljs-comment">// =&gt;   writerQueue InWriterThread1(); if (NeedNetwork()) { // =&gt;   networkQueue auto v = InNetworkThread(); if (v) { // =&gt;   UIQueue InUIThread(); } } // =&gt;   writerQueue InWriterThread2(); ShutdownAll(); }</span></span></code> </pre> <br>  Ungefähr dieses Ergebnis möchte ich erreichen. <br><br>  Es gibt Einschränkungen: <br><br><ul><li>  Warteschlangenschnittstellen können nicht geändert werden - sie werden in anderen Teilen der Anwendung von Drittentwicklern verwendet.  Sie können keinen Entwicklercode brechen oder neue Warteschlangeninstanzen hinzufügen. </li><li>  Sie können die Verwendung der Funktion FuncToDealWith nicht ändern.  Sie können nur den Namen ändern, aber keine Objekte zurückgeben, die der Benutzer zu Hause behalten muss. </li><li>  Der resultierende Code sollte genauso produktiv sein wie das Original (oder sogar noch produktiver). </li></ul><br><h2>  Lösung </h2><br><h3>  Schreiben Sie die Funktion FuncToDealWith neu </h3><br>  In Coroutines TS erfolgt die Coroutine-Optimierung durch Festlegen des Typs des Rückgabewerts der Funktion.  Wenn der Typ bestimmte Anforderungen erfüllt, können Sie im Funktionskörper die neuen Schlüsselwörter co_await / co_return / co_yield verwenden.  In diesem Beispiel verwenden wir co_yield, um zwischen Warteschlangen zu wechseln: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">CoroTask </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CoroToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); co_yield writerQueue; InWriterThread1(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedNetwork()) { co_yield networkQueue; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = InNetworkThread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v) { co_yield UIQueue; InUIThread(); } } co_yield writerQueue; InWriterThread2(); ShutdownAll(); }</code> </pre> <br>  Es stellte sich heraus, dass es dem Pseudocode aus dem letzten Abschnitt sehr ähnlich war.  Die gesamte „Magie“ für die Arbeit mit Coroutinen ist in der CoroTask-Klasse verborgen. <br><br><h3>  CoroTask </h3><br>  Im einfachsten (in unserem) Fall besteht der Inhalt der "Tuner" -Klasse der Coroutine nur aus einem Alias: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;experimental/coroutine&gt; struct CoroTask { using promise_type = PromiseType; };</span></span></span></span></code> </pre> <br><br>  versprechen_typ ist ein Datentyp, den wir selbst schreiben müssen.  Es enthält Logik, die beschreibt: <br><br><ul><li>  Was tun beim Verlassen von Coroutine? </li><li>  Was tun, wenn Sie Corutin zum ersten Mal eingeben? </li><li>  Wer befreit Ressourcen </li><li>  Was tun mit Ausnahmen, die aus der Coroutine herausfliegen? </li><li>  So erstellen Sie ein CoroTask-Objekt </li><li>  Was tun, wenn in Corutins co_yield genannt wird? </li></ul><br>  Der Alias ​​Versprechen_Typ muss so aufgerufen werden.  Wenn Sie den Aliasnamen in etwas anderes ändern, schwört der Compiler und sagt, dass Sie CoroTask falsch geschrieben haben.  Der Name CoroTask kann beliebig geändert werden. <br><br><div class="spoiler">  <b class="spoiler_title">Aber warum ist diese CoroTask notwendig, wenn alles in Versprechen_Typ beschrieben ist?</b> <div class="spoiler_text">  In komplexeren Fällen können Sie CoroTask erstellen, mit dem Sie mit einer gestoppten Coroutine kommunizieren, Daten von ihr senden und empfangen, sie wecken und zerstören können. <br></div></div><br><h3>  PromiseType </h3><br>  Zum lustigen Teil kommen.  Wir beschreiben das Verhalten von Corutin: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkQueue</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">// forward declaration class PromiseType { public: //      `co_return;`     , ... void return_void() const { /* ...    :) */ } //        ,  CoroTask, ... auto initial_suspend() const { // ...       . return std::experimental::suspend_never{}; } //      - , ... auto final_suspend() const { // ...        //      . return std::experimental::suspend_never{}; } //     , ... void unhandled_exception() const { // ...   (  ). std::terminate(); } //    CoroTask,    , ... auto get_return_object() const { // ...  CoroTask. return CoroTask{}; } //     co_yield, ... auto yield_value(WorkQueue&amp; wq) const; // ... &lt;  &gt; };</span></span></code> </pre> <br>  Im obigen Code können Sie den Datentyp std :: experimentelle :: suspend_never bemerken.  Dies ist ein spezieller Datentyp, der besagt, dass Corutin nicht gestoppt werden muss.  Es gibt auch das Gegenteil - den Typ std :: experimental :: suspend_always, der Sie auffordert, Corutin zu stoppen.  Diese Typen sind die sogenannten Wartbaren.  Wenn Sie an ihrer internen Struktur interessiert sind, machen Sie sich keine Sorgen, wir werden unsere Awaitables bald schreiben. <br><br>  Die nicht trivialste Stelle im obigen Code ist final_suspend ().  Die Funktion hat unerwartete Auswirkungen.  Wenn wir <b>die</b> Ausführung in dieser Funktion nicht stoppen, bereinigen die vom Compiler der Coroutine zugewiesenen Ressourcen den Compiler für uns.  Wenn wir in dieser Funktion die Ausführung von Coroutine stoppen (z. B. durch Rückgabe von std :: experimental :: suspend_always {}), müssen Sie Ressourcen manuell von außerhalb freigeben: Sie müssen einen intelligenten Zeiger auf Coroutine irgendwo speichern und explizit aufrufen zerstören ().  Glücklicherweise ist dies für unser Beispiel nicht erforderlich. <br><br><h3>  INCORRECT PromiseType ::ield_value </h3><br>  Es scheint, dass das Schreiben von PromiseType ::ield_value recht einfach ist.  Wir haben eine Linie;  Coroutine, die ausgesetzt und in diesem Zug gesetzt werden muss: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> PromiseType::yield_value(WorkQueue&amp; wq) { <span class="hljs-comment"><span class="hljs-comment">//        std::experimental::coroutine_handle&lt;&gt; this_coro = std::experimental::coroutine_handle&lt;&gt;::from_promise(*this); //    .  this_coro  operator(),    // wq      .   , //     ,  operator(),  //   . wq.PushTask(this_coro); //     . return std::experimental::suspend_always{}; }</span></span></code> </pre> <br>  Und hier stehen wir vor einem sehr großen und schwer zu erkennenden Problem.  Tatsache ist, dass wir die Coroutine zuerst in die Warteschlange stellen und erst dann aussetzen.  Es kann vorkommen, dass Coroutine aus der Warteschlange entfernt wird und bereits ausgeführt wird, bevor wir sie im aktuellen Thread anhalten.  Dies führt zu einer Rennbedingung, undefiniertem Verhalten und völlig verrückten Laufzeitfehlern. <br><br><h3>  <b>Korrigieren Sie</b> PromiseType ::ield_value </h3><br>  Wir müssen also zuerst Corutin stoppen und erst dann zur Warteschlange hinzufügen.  Dazu schreiben wir unser Awaitable und nennen es Schedule_for_execution: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> PromiseType::yield_value(WorkQueue&amp; wq) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">schedule_for_execution</span></span></span><span class="hljs-class"> {</span></span> WorkQueue&amp; wq; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_ready</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_suspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::experimental::coroutine_handle&lt;&gt; this_coro)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ wq.PushTask(this_coro); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_resume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> schedule_for_execution{wq}; }</code> </pre> <br>  Die Klassen std :: experimental :: suspend_always, std :: experimental :: suspend_never, Schedule_for_execution und andere Awaitables sollten 3 Funktionen enthalten.  await_ready wird aufgerufen, um zu überprüfen, ob die Coroutine gestoppt werden soll.  await_suspend wird aufgerufen, nachdem das Programm gestoppt wurde, und das Handle der gestoppten Coroutine wird an das Programm übergeben.  await_resume wird aufgerufen, wenn die Coroutine-Ausführung fortgesetzt wird. <br><div class="spoiler">  <b class="spoiler_title">Und was kann in dreieckigen skrabs std :: experimental :: coroutine_handle &lt;&gt; geschrieben werden?</b> <div class="spoiler_text">  Sie können dort den PromiseType-Typ angeben, und das Beispiel funktioniert genauso :) <br><br>  std :: experimental :: coroutine_handle &lt;&gt; (auch bekannt als std :: experimental :: coroutine_handle &lt;void&gt;) ist der Basistyp für alle std :: experimentellen :: coroutine_handle &lt;DataType&gt;, wobei der Datentyp der Versprechenstyp der aktuellen Coroutine sein muss.  Wenn Sie nicht auf den internen Inhalt von DataType zugreifen müssen, können Sie std :: experimentelle :: coroutine_handle &lt;&gt; schreiben.  Dies kann an Stellen nützlich sein, an denen Sie von einem bestimmten Typ von versprechen_Typ abstrahieren und den Typ Löschen verwenden möchten. <br></div></div><br><h3>  Fertig </h3><br>  Sie können <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Beispiel kompilieren, online ausführen und auf jede Weise experimentieren</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Und wenn ich co_yield nicht mag, kann ich es durch etwas ersetzen?</b> <div class="spoiler_text">  Kann durch co_await ersetzt werden.  Fügen Sie dazu PromiseType die folgende Funktion hinzu: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WorkQueue&amp; wq)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> yield_value(wq); }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Aber was ist, wenn ich co_await nicht mag?</b> <div class="spoiler_text">  Die Sache ist schlecht.  Nichts zu ändern. <br></div></div><br></div></div><br><h3>  Spickzettel </h3><br>  CoroTask ist eine Klasse, die das Verhalten einer Coroutine anpasst.  In komplexeren Fällen können Sie mit einer gestoppten Coroutine kommunizieren und Daten daraus entnehmen. <br><br>  CoroTask :: Versprechen_Typ beschreibt, wie und wann Coroutinen gestoppt werden, wie Ressourcen freigegeben werden und wie CoroTask erstellt wird. <br><br>  Awaitables (std :: experimental :: suspend_always, std :: experimental :: suspend_never, Schedule_for_execution und andere) teilen dem Compiler mit, was mit Coroutine an einem bestimmten Punkt zu tun ist (ob Corutin gestoppt werden soll, was mit gestopptem Corutin zu tun ist und was zu tun ist, wenn Corutin aufwacht). . <br><br><h3>  Optimierungen </h3><br>  Unser PromiseType weist einen Fehler auf.  Selbst wenn wir derzeit in der richtigen Task-Warteschlange ausgeführt werden, wird durch den Aufruf von co_yield die Coroutine angehalten und in dieselbe Task-Warteschlange verschoben.  Es wäre viel optimaler, die Ausführung der Coroutine nicht zu stoppen, sondern die Ausführung sofort fortzusetzen. <br><br>  Lassen Sie uns diesen Fehler beheben.  Fügen Sie dazu PromiseType ein privates Feld hinzu: <br><br><pre> <code class="cpp hljs">WorkQueue* current_queue_ = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>;</code> </pre> <br>  Darin halten wir einen Zeiger auf die Warteschlange, in der wir gerade ausführen. <br><br>  Als nächstes optimieren Sie PromiseType ::ield_value: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> PromiseType::yield_value(WorkQueue&amp; wq) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">schedule_for_execution</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> do_resume; WorkQueue&amp; wq; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_ready</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_resume; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_suspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::experimental::coroutine_handle&lt;&gt; this_coro)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ wq.PushTask(this_coro); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_resume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> do_not_suspend = (current_queue_ == &amp;wq); current_queue_ = &amp;wq; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> schedule_for_execution{do_not_suspend, wq}; }</code> </pre> <br>  Hier haben wir Schedule_for_execution :: await_ready () optimiert.  Diese Funktion teilt dem Compiler nun mit, dass die Coroutine nicht angehalten werden muss, wenn die aktuelle Task-Warteschlange mit der Warteschlange übereinstimmt, auf der wir starten möchten. <br><br>  Fertig.  Sie können <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf jede Weise experimentieren</a> . <br><br><h2>  Über die Leistung </h2><br>  Im ursprünglichen Beispiel haben wir bei jedem Aufruf von WorkQueue :: PushTask (std :: function &lt;void ()&gt; f) eine Instanz der Klasse std :: function &lt;void ()&gt; aus dem Lambda erstellt.  Im realen Code sind diese Lambdas oft recht groß, weshalb std :: function &lt;void ()&gt; gezwungen ist, dynamisch Speicher zum Speichern von Lambdas zuzuweisen. <br><br>  Im Coroutine-Beispiel erstellen wir Instanzen von std :: function &lt;void ()&gt; aus std :: experiment :: coroutine_handle &lt;&gt;.  Die Größe von std :: experiment :: coroutine_handle &lt;&gt; hängt von der Implementierung ab, aber die meisten Implementierungen versuchen, die Größe auf ein Minimum zu beschränken.  Bei Clang ist seine Größe also gleich sizeof (void *).  Beim Erstellen von std :: function &lt;void ()&gt; erfolgt keine dynamische Zuordnung von kleinen Objekten. <br>  Insgesamt - mit Coroutines haben wir einige unnötige dynamische Zuordnungen beseitigt. <br><br>  Aber!  Der Compiler kann oft nicht einfach die gesamte Coroutine auf dem Stapel speichern.  Aus diesem Grund ist bei der Eingabe von CoroToDealWith eine zusätzliche dynamische Zuordnung möglich. <br><br><h2>  Stapellos gegen stapelbar </h2><br>  Wir haben gerade mit stapellosen Coroutinen gearbeitet, für deren Arbeit der Compiler Unterstützung benötigt.  Es gibt auch stapelbare Coroutinen, die vollständig auf Bibliotheksebene implementiert werden können. <br><br>  Die ersten ermöglichen eine wirtschaftlichere Speicherzuweisung, möglicherweise werden sie vom Compiler besser optimiert.  Die zweiten sind einfacher in vorhandene Projekte zu implementieren, da sie weniger Codeänderungen erfordern.  In diesem Beispiel können Sie den Unterschied jedoch nicht spüren. Es werden kompliziertere Beispiele benötigt. <br><br><h2>  Zusammenfassung </h2><br>  Wir haben das grundlegende Beispiel untersucht und eine universelle Klasse CoroTask erhalten, mit der andere Coroutinen erstellt werden können. <br><br>  Der Code damit wird lesbarer und etwas produktiver als mit dem naiven Ansatz: <br><table><tbody><tr><th>  War </th><th>  Mit Coroutinen </th></tr><tr><td><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FuncToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); writerQueue.PushTask([=]() { InWriterThread1(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> fin = [=]() { InWriterThread2(); ShutdownAll(); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedNetwork()) { networkQueue.PushTask([=](){ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = InNetThread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v) { UIQueue.PushTask([=](){ InUIThread(); writerQueue.PushTask(fin); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { writerQueue.PushTask(fin); } }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fin(); } }); }</code> </pre></td><td><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">CoroTask </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CoroToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); co_yield writerQueue; InWriterThread1(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedNetwork()) { co_yield networkQueue; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = InNetThread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v) { co_yield UIQueue; InUIThread(); } } co_yield writerQueue; InWriterThread2(); ShutdownAll(); }</code> </pre> </td></tr></tbody></table><br>  Über Bord gab es Momente: <br><br><ul><li>  wie man eine andere Coroutine von Corutin aufruft und auf ihre Fertigstellung wartet </li><li>  Was für nützliche Dinge können Sie in CoroTask stopfen </li><li>  Ein Beispiel, das den Unterschied zwischen Stackless und Stackful ausmacht </li></ul><br><h2>  Andere </h2><br>  Wenn Sie mehr über andere Neuheiten der C ++ - Sprache erfahren oder persönlich mit Ihren Kollegen über die Vorteile kommunizieren möchten, schauen Sie sich die C ++ Russia-Konferenz an.  Der nächste findet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">am 6. Oktober in Nischni Nowgorod statt</a> . <br><br>  Wenn Sie Probleme mit C ++ haben und etwas in der Sprache verbessern möchten oder nur mögliche Innovationen diskutieren möchten, besuchen Sie bitte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://stdcpp.ru/</a> . <br><br>  Wenn es Sie überrascht, dass Yandex.Taxi eine Vielzahl von Aufgaben hat, die nicht mit Grafiken zusammenhängen, dann hoffe ich, dass dies eine angenehme Überraschung für Sie war :) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Besuchen Sie uns am 11. Oktober</a> , wir werden über C ++ und mehr sprechen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420861/">https://habr.com/ru/post/de420861/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420845/index.html">Die Zähmung des Hartnäckigen mit einer Krücke: das Loch des WLAN-Adapters WF2190 (Realtek8812AU Wireless LAN 802.11ac USB)</a></li>
<li><a href="../de420847/index.html">Einführung in die Shader-Programmierung für Layouts</a></li>
<li><a href="../de420853/index.html">Lernen Sie die Windows Pseudo Console (ConPTY) kennen</a></li>
<li><a href="../de420857/index.html">Nahtloses Wi-Fi-Roaming: Theorie in der Praxis</a></li>
<li><a href="../de420859/index.html">Zur Frage von Wirth und Ketten</a></li>
<li><a href="../de420863/index.html">Als wir das erste russische Smartphone machten, ging es weiter</a></li>
<li><a href="../de420865/index.html">Das Prinzip der geringsten Aktion. Teil 1</a></li>
<li><a href="../de420867/index.html">Berechnung bestimmter Integrale: grundlegende Algorithmen</a></li>
<li><a href="../de420869/index.html">Evakuierung, HAMR und MAMR - drei Möglichkeiten, um die Kapazität moderner Festplatten zu maximieren</a></li>
<li><a href="../de420871/index.html">Wie wir das Webstudio nach Bali verlegt haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>