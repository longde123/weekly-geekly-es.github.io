<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ôüèæ üíî üë©üèΩ‚Äçüé§ Vorbereitungen f√ºr C ++ 20. Coroutines TS Real Fallstudie ‚õ¥Ô∏è üçÇ üë®üèæ‚Äçüöí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In C ++ 20 wird die M√∂glichkeit angezeigt, sofort mit Coroutinen zu arbeiten. Dieses Thema ist f√ºr uns bei Yandex.Taxi nah und interessant (f√ºr unsere...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vorbereitungen f√ºr C ++ 20. Coroutines TS Real Fallstudie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/420861/">  In C ++ 20 wird die M√∂glichkeit angezeigt, sofort mit Coroutinen zu arbeiten.  Dieses Thema ist f√ºr uns bei Yandex.Taxi nah und interessant (f√ºr unsere eigenen Bed√ºrfnisse entwickeln wir ein asynchrones Framework).  Daher werden wir heute den Lesern von Habr anhand eines realen Beispiels zeigen, wie man mit stapellosen C ++ - Coroutinen arbeitet. <br><br>  Nehmen wir als Beispiel etwas Einfaches: Ohne mit asynchronen Netzwerkschnittstellen zu arbeiten, asynchrone Timer, die aus einer Funktion bestehen.  Versuchen wir beispielsweise, diese ‚ÄûNudel‚Äú aus R√ºckrufen zu realisieren und neu zu schreiben: <br><br><img align="right" src="https://habrastorage.org/webt/za/0m/kp/za0mkphg8qyitvudyvv-dhunfae.jpeg"><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FuncToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); writerQueue.PushTask([=]() { InWriterThread1(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> finally = [=]() { InWriterThread2(); ShutdownAll(); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedNetwork()) { networkQueue.PushTask([=](){ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = InNetworkThread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v) { UIQueue.PushTask([=](){ InUIThread(); writerQueue.PushTask(finally); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { writerQueue.PushTask(finally); } }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { finally(); } }); }</code> </pre> <br><a name="habracut"></a><br><h2>  Einf√ºhrung </h2><br>  Coroutinen oder Coroutinen sind die F√§higkeit, die Ausf√ºhrung einer Funktion an einem vordefinierten Ort zu verhindern.  √úbergeben Sie irgendwo den gesamten Status der gestoppten Funktion zusammen mit lokalen Variablen.  F√ºhren Sie die Funktion an derselben Stelle aus, an der wir sie gestoppt haben. <br>  Es gibt verschiedene Arten von Coroutinen: stapellos und stapelbar.  Wir werden sp√§ter dar√ºber sprechen. <br><br><h2>  Erkl√§rung des Problems </h2><br>  Wir haben mehrere Aufgabenwarteschlangen.  Jede Aufgabe enth√§lt bestimmte Aufgaben: Es gibt eine Warteschlange zum Zeichnen von Grafiken, eine Warteschlange f√ºr Netzwerkinteraktionen und eine Warteschlange f√ºr die Arbeit mit einer Festplatte.  Alle Warteschlangen sind Instanzen der WorkQueue-Klasse mit der void PushTask-Methode (std :: function &lt;void ()&gt; task);  Warteschlangen leben l√§nger als alle darin platzierten Aufgaben (die Situation, dass wir eine Warteschlange zerst√∂rt haben, wenn noch offene Aufgaben darin sind, sollte nicht auftreten). <br><br>  Die Funktion FuncToDealWith () aus dem Beispiel f√ºhrt eine Logik in verschiedenen Warteschlangen aus und stellt abh√§ngig von den Ergebnissen der Ausf√ºhrung eine neue Aufgabe in die Warteschlange. <br><br>  Wir schreiben die ‚ÄûNudeln‚Äú von R√ºckrufen in Form eines linearen Pseudocodes neu und markieren, in welcher Warteschlange der zugrunde liegende Code ausgef√ºhrt werden soll: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CoroToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); <span class="hljs-comment"><span class="hljs-comment">// =&gt;   writerQueue InWriterThread1(); if (NeedNetwork()) { // =&gt;   networkQueue auto v = InNetworkThread(); if (v) { // =&gt;   UIQueue InUIThread(); } } // =&gt;   writerQueue InWriterThread2(); ShutdownAll(); }</span></span></code> </pre> <br>  Ungef√§hr dieses Ergebnis m√∂chte ich erreichen. <br><br>  Es gibt Einschr√§nkungen: <br><br><ul><li>  Warteschlangenschnittstellen k√∂nnen nicht ge√§ndert werden - sie werden in anderen Teilen der Anwendung von Drittentwicklern verwendet.  Sie k√∂nnen keinen Entwicklercode brechen oder neue Warteschlangeninstanzen hinzuf√ºgen. </li><li>  Sie k√∂nnen die Verwendung der Funktion FuncToDealWith nicht √§ndern.  Sie k√∂nnen nur den Namen √§ndern, aber keine Objekte zur√ºckgeben, die der Benutzer zu Hause behalten muss. </li><li>  Der resultierende Code sollte genauso produktiv sein wie das Original (oder sogar noch produktiver). </li></ul><br><h2>  L√∂sung </h2><br><h3>  Schreiben Sie die Funktion FuncToDealWith neu </h3><br>  In Coroutines TS erfolgt die Coroutine-Optimierung durch Festlegen des Typs des R√ºckgabewerts der Funktion.  Wenn der Typ bestimmte Anforderungen erf√ºllt, k√∂nnen Sie im Funktionsk√∂rper die neuen Schl√ºsselw√∂rter co_await / co_return / co_yield verwenden.  In diesem Beispiel verwenden wir co_yield, um zwischen Warteschlangen zu wechseln: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">CoroTask </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CoroToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); co_yield writerQueue; InWriterThread1(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedNetwork()) { co_yield networkQueue; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = InNetworkThread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v) { co_yield UIQueue; InUIThread(); } } co_yield writerQueue; InWriterThread2(); ShutdownAll(); }</code> </pre> <br>  Es stellte sich heraus, dass es dem Pseudocode aus dem letzten Abschnitt sehr √§hnlich war.  Die gesamte ‚ÄûMagie‚Äú f√ºr die Arbeit mit Coroutinen ist in der CoroTask-Klasse verborgen. <br><br><h3>  CoroTask </h3><br>  Im einfachsten (in unserem) Fall besteht der Inhalt der "Tuner" -Klasse der Coroutine nur aus einem Alias: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;experimental/coroutine&gt; struct CoroTask { using promise_type = PromiseType; };</span></span></span></span></code> </pre> <br><br>  versprechen_typ ist ein Datentyp, den wir selbst schreiben m√ºssen.  Es enth√§lt Logik, die beschreibt: <br><br><ul><li>  Was tun beim Verlassen von Coroutine? </li><li>  Was tun, wenn Sie Corutin zum ersten Mal eingeben? </li><li>  Wer befreit Ressourcen </li><li>  Was tun mit Ausnahmen, die aus der Coroutine herausfliegen? </li><li>  So erstellen Sie ein CoroTask-Objekt </li><li>  Was tun, wenn in Corutins co_yield genannt wird? </li></ul><br>  Der Alias ‚Äã‚ÄãVersprechen_Typ muss so aufgerufen werden.  Wenn Sie den Aliasnamen in etwas anderes √§ndern, schw√∂rt der Compiler und sagt, dass Sie CoroTask falsch geschrieben haben.  Der Name CoroTask kann beliebig ge√§ndert werden. <br><br><div class="spoiler">  <b class="spoiler_title">Aber warum ist diese CoroTask notwendig, wenn alles in Versprechen_Typ beschrieben ist?</b> <div class="spoiler_text">  In komplexeren F√§llen k√∂nnen Sie CoroTask erstellen, mit dem Sie mit einer gestoppten Coroutine kommunizieren, Daten von ihr senden und empfangen, sie wecken und zerst√∂ren k√∂nnen. <br></div></div><br><h3>  PromiseType </h3><br>  Zum lustigen Teil kommen.  Wir beschreiben das Verhalten von Corutin: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkQueue</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">// forward declaration class PromiseType { public: //      `co_return;`     , ... void return_void() const { /* ...    :) */ } //        ,  CoroTask, ... auto initial_suspend() const { // ...       . return std::experimental::suspend_never{}; } //      - , ... auto final_suspend() const { // ...        //      . return std::experimental::suspend_never{}; } //     , ... void unhandled_exception() const { // ...   (  ). std::terminate(); } //    CoroTask,    , ... auto get_return_object() const { // ...  CoroTask. return CoroTask{}; } //     co_yield, ... auto yield_value(WorkQueue&amp; wq) const; // ... &lt;  &gt; };</span></span></code> </pre> <br>  Im obigen Code k√∂nnen Sie den Datentyp std :: experimentelle :: suspend_never bemerken.  Dies ist ein spezieller Datentyp, der besagt, dass Corutin nicht gestoppt werden muss.  Es gibt auch das Gegenteil - den Typ std :: experimental :: suspend_always, der Sie auffordert, Corutin zu stoppen.  Diese Typen sind die sogenannten Wartbaren.  Wenn Sie an ihrer internen Struktur interessiert sind, machen Sie sich keine Sorgen, wir werden unsere Awaitables bald schreiben. <br><br>  Die nicht trivialste Stelle im obigen Code ist final_suspend ().  Die Funktion hat unerwartete Auswirkungen.  Wenn wir <b>die</b> Ausf√ºhrung in dieser Funktion nicht stoppen, bereinigen die vom Compiler der Coroutine zugewiesenen Ressourcen den Compiler f√ºr uns.  Wenn wir in dieser Funktion die Ausf√ºhrung von Coroutine stoppen (z. B. durch R√ºckgabe von std :: experimental :: suspend_always {}), m√ºssen Sie Ressourcen manuell von au√üerhalb freigeben: Sie m√ºssen einen intelligenten Zeiger auf Coroutine irgendwo speichern und explizit aufrufen zerst√∂ren ().  Gl√ºcklicherweise ist dies f√ºr unser Beispiel nicht erforderlich. <br><br><h3>  INCORRECT PromiseType ::ield_value </h3><br>  Es scheint, dass das Schreiben von PromiseType ::ield_value recht einfach ist.  Wir haben eine Linie;  Coroutine, die ausgesetzt und in diesem Zug gesetzt werden muss: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> PromiseType::yield_value(WorkQueue&amp; wq) { <span class="hljs-comment"><span class="hljs-comment">//        std::experimental::coroutine_handle&lt;&gt; this_coro = std::experimental::coroutine_handle&lt;&gt;::from_promise(*this); //    .  this_coro  operator(),    // wq      .   , //     ,  operator(),  //   . wq.PushTask(this_coro); //     . return std::experimental::suspend_always{}; }</span></span></code> </pre> <br>  Und hier stehen wir vor einem sehr gro√üen und schwer zu erkennenden Problem.  Tatsache ist, dass wir die Coroutine zuerst in die Warteschlange stellen und erst dann aussetzen.  Es kann vorkommen, dass Coroutine aus der Warteschlange entfernt wird und bereits ausgef√ºhrt wird, bevor wir sie im aktuellen Thread anhalten.  Dies f√ºhrt zu einer Rennbedingung, undefiniertem Verhalten und v√∂llig verr√ºckten Laufzeitfehlern. <br><br><h3>  <b>Korrigieren Sie</b> PromiseType ::ield_value </h3><br>  Wir m√ºssen also zuerst Corutin stoppen und erst dann zur Warteschlange hinzuf√ºgen.  Dazu schreiben wir unser Awaitable und nennen es Schedule_for_execution: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> PromiseType::yield_value(WorkQueue&amp; wq) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">schedule_for_execution</span></span></span><span class="hljs-class"> {</span></span> WorkQueue&amp; wq; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_ready</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_suspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::experimental::coroutine_handle&lt;&gt; this_coro)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ wq.PushTask(this_coro); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_resume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> schedule_for_execution{wq}; }</code> </pre> <br>  Die Klassen std :: experimental :: suspend_always, std :: experimental :: suspend_never, Schedule_for_execution und andere Awaitables sollten 3 Funktionen enthalten.  await_ready wird aufgerufen, um zu √ºberpr√ºfen, ob die Coroutine gestoppt werden soll.  await_suspend wird aufgerufen, nachdem das Programm gestoppt wurde, und das Handle der gestoppten Coroutine wird an das Programm √ºbergeben.  await_resume wird aufgerufen, wenn die Coroutine-Ausf√ºhrung fortgesetzt wird. <br><div class="spoiler">  <b class="spoiler_title">Und was kann in dreieckigen skrabs std :: experimental :: coroutine_handle &lt;&gt; geschrieben werden?</b> <div class="spoiler_text">  Sie k√∂nnen dort den PromiseType-Typ angeben, und das Beispiel funktioniert genauso :) <br><br>  std :: experimental :: coroutine_handle &lt;&gt; (auch bekannt als std :: experimental :: coroutine_handle &lt;void&gt;) ist der Basistyp f√ºr alle std :: experimentellen :: coroutine_handle &lt;DataType&gt;, wobei der Datentyp der Versprechenstyp der aktuellen Coroutine sein muss.  Wenn Sie nicht auf den internen Inhalt von DataType zugreifen m√ºssen, k√∂nnen Sie std :: experimentelle :: coroutine_handle &lt;&gt; schreiben.  Dies kann an Stellen n√ºtzlich sein, an denen Sie von einem bestimmten Typ von versprechen_Typ abstrahieren und den Typ L√∂schen verwenden m√∂chten. <br></div></div><br><h3>  Fertig </h3><br>  Sie k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Beispiel kompilieren, online ausf√ºhren und auf jede Weise experimentieren</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Und wenn ich co_yield nicht mag, kann ich es durch etwas ersetzen?</b> <div class="spoiler_text">  Kann durch co_await ersetzt werden.  F√ºgen Sie dazu PromiseType die folgende Funktion hinzu: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WorkQueue&amp; wq)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> yield_value(wq); }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Aber was ist, wenn ich co_await nicht mag?</b> <div class="spoiler_text">  Die Sache ist schlecht.  Nichts zu √§ndern. <br></div></div><br></div></div><br><h3>  Spickzettel </h3><br>  CoroTask ist eine Klasse, die das Verhalten einer Coroutine anpasst.  In komplexeren F√§llen k√∂nnen Sie mit einer gestoppten Coroutine kommunizieren und Daten daraus entnehmen. <br><br>  CoroTask :: Versprechen_Typ beschreibt, wie und wann Coroutinen gestoppt werden, wie Ressourcen freigegeben werden und wie CoroTask erstellt wird. <br><br>  Awaitables (std :: experimental :: suspend_always, std :: experimental :: suspend_never, Schedule_for_execution und andere) teilen dem Compiler mit, was mit Coroutine an einem bestimmten Punkt zu tun ist (ob Corutin gestoppt werden soll, was mit gestopptem Corutin zu tun ist und was zu tun ist, wenn Corutin aufwacht). . <br><br><h3>  Optimierungen </h3><br>  Unser PromiseType weist einen Fehler auf.  Selbst wenn wir derzeit in der richtigen Task-Warteschlange ausgef√ºhrt werden, wird durch den Aufruf von co_yield die Coroutine angehalten und in dieselbe Task-Warteschlange verschoben.  Es w√§re viel optimaler, die Ausf√ºhrung der Coroutine nicht zu stoppen, sondern die Ausf√ºhrung sofort fortzusetzen. <br><br>  Lassen Sie uns diesen Fehler beheben.  F√ºgen Sie dazu PromiseType ein privates Feld hinzu: <br><br><pre> <code class="cpp hljs">WorkQueue* current_queue_ = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>;</code> </pre> <br>  Darin halten wir einen Zeiger auf die Warteschlange, in der wir gerade ausf√ºhren. <br><br>  Als n√§chstes optimieren Sie PromiseType ::ield_value: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> PromiseType::yield_value(WorkQueue&amp; wq) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">schedule_for_execution</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> do_resume; WorkQueue&amp; wq; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_ready</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_resume; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_suspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::experimental::coroutine_handle&lt;&gt; this_coro)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ wq.PushTask(this_coro); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_resume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> do_not_suspend = (current_queue_ == &amp;wq); current_queue_ = &amp;wq; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> schedule_for_execution{do_not_suspend, wq}; }</code> </pre> <br>  Hier haben wir Schedule_for_execution :: await_ready () optimiert.  Diese Funktion teilt dem Compiler nun mit, dass die Coroutine nicht angehalten werden muss, wenn die aktuelle Task-Warteschlange mit der Warteschlange √ºbereinstimmt, auf der wir starten m√∂chten. <br><br>  Fertig.  Sie k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf jede Weise experimentieren</a> . <br><br><h2>  √úber die Leistung </h2><br>  Im urspr√ºnglichen Beispiel haben wir bei jedem Aufruf von WorkQueue :: PushTask (std :: function &lt;void ()&gt; f) eine Instanz der Klasse std :: function &lt;void ()&gt; aus dem Lambda erstellt.  Im realen Code sind diese Lambdas oft recht gro√ü, weshalb std :: function &lt;void ()&gt; gezwungen ist, dynamisch Speicher zum Speichern von Lambdas zuzuweisen. <br><br>  Im Coroutine-Beispiel erstellen wir Instanzen von std :: function &lt;void ()&gt; aus std :: experiment :: coroutine_handle &lt;&gt;.  Die Gr√∂√üe von std :: experiment :: coroutine_handle &lt;&gt; h√§ngt von der Implementierung ab, aber die meisten Implementierungen versuchen, die Gr√∂√üe auf ein Minimum zu beschr√§nken.  Bei Clang ist seine Gr√∂√üe also gleich sizeof (void *).  Beim Erstellen von std :: function &lt;void ()&gt; erfolgt keine dynamische Zuordnung von kleinen Objekten. <br>  Insgesamt - mit Coroutines haben wir einige unn√∂tige dynamische Zuordnungen beseitigt. <br><br>  Aber!  Der Compiler kann oft nicht einfach die gesamte Coroutine auf dem Stapel speichern.  Aus diesem Grund ist bei der Eingabe von CoroToDealWith eine zus√§tzliche dynamische Zuordnung m√∂glich. <br><br><h2>  Stapellos gegen stapelbar </h2><br>  Wir haben gerade mit stapellosen Coroutinen gearbeitet, f√ºr deren Arbeit der Compiler Unterst√ºtzung ben√∂tigt.  Es gibt auch stapelbare Coroutinen, die vollst√§ndig auf Bibliotheksebene implementiert werden k√∂nnen. <br><br>  Die ersten erm√∂glichen eine wirtschaftlichere Speicherzuweisung, m√∂glicherweise werden sie vom Compiler besser optimiert.  Die zweiten sind einfacher in vorhandene Projekte zu implementieren, da sie weniger Code√§nderungen erfordern.  In diesem Beispiel k√∂nnen Sie den Unterschied jedoch nicht sp√ºren. Es werden kompliziertere Beispiele ben√∂tigt. <br><br><h2>  Zusammenfassung </h2><br>  Wir haben das grundlegende Beispiel untersucht und eine universelle Klasse CoroTask erhalten, mit der andere Coroutinen erstellt werden k√∂nnen. <br><br>  Der Code damit wird lesbarer und etwas produktiver als mit dem naiven Ansatz: <br><table><tbody><tr><th>  War </th><th>  Mit Coroutinen </th></tr><tr><td><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FuncToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); writerQueue.PushTask([=]() { InWriterThread1(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> fin = [=]() { InWriterThread2(); ShutdownAll(); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedNetwork()) { networkQueue.PushTask([=](){ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = InNetThread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v) { UIQueue.PushTask([=](){ InUIThread(); writerQueue.PushTask(fin); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { writerQueue.PushTask(fin); } }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fin(); } }); }</code> </pre></td><td><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">CoroTask </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CoroToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); co_yield writerQueue; InWriterThread1(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedNetwork()) { co_yield networkQueue; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = InNetThread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v) { co_yield UIQueue; InUIThread(); } } co_yield writerQueue; InWriterThread2(); ShutdownAll(); }</code> </pre> </td></tr></tbody></table><br>  √úber Bord gab es Momente: <br><br><ul><li>  wie man eine andere Coroutine von Corutin aufruft und auf ihre Fertigstellung wartet </li><li>  Was f√ºr n√ºtzliche Dinge k√∂nnen Sie in CoroTask stopfen </li><li>  Ein Beispiel, das den Unterschied zwischen Stackless und Stackful ausmacht </li></ul><br><h2>  Andere </h2><br>  Wenn Sie mehr √ºber andere Neuheiten der C ++ - Sprache erfahren oder pers√∂nlich mit Ihren Kollegen √ºber die Vorteile kommunizieren m√∂chten, schauen Sie sich die C ++ Russia-Konferenz an.  Der n√§chste findet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">am 6. Oktober in Nischni Nowgorod statt</a> . <br><br>  Wenn Sie Probleme mit C ++ haben und etwas in der Sprache verbessern m√∂chten oder nur m√∂gliche Innovationen diskutieren m√∂chten, besuchen Sie bitte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://stdcpp.ru/</a> . <br><br>  Wenn es Sie √ºberrascht, dass Yandex.Taxi eine Vielzahl von Aufgaben hat, die nicht mit Grafiken zusammenh√§ngen, dann hoffe ich, dass dies eine angenehme √úberraschung f√ºr Sie war :) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Besuchen Sie uns am 11. Oktober</a> , wir werden √ºber C ++ und mehr sprechen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420861/">https://habr.com/ru/post/de420861/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420845/index.html">Die Z√§hmung des Hartn√§ckigen mit einer Kr√ºcke: das Loch des WLAN-Adapters WF2190 (Realtek8812AU Wireless LAN 802.11ac USB)</a></li>
<li><a href="../de420847/index.html">Einf√ºhrung in die Shader-Programmierung f√ºr Layouts</a></li>
<li><a href="../de420853/index.html">Lernen Sie die Windows Pseudo Console (ConPTY) kennen</a></li>
<li><a href="../de420857/index.html">Nahtloses Wi-Fi-Roaming: Theorie in der Praxis</a></li>
<li><a href="../de420859/index.html">Zur Frage von Wirth und Ketten</a></li>
<li><a href="../de420863/index.html">Als wir das erste russische Smartphone machten, ging es weiter</a></li>
<li><a href="../de420865/index.html">Das Prinzip der geringsten Aktion. Teil 1</a></li>
<li><a href="../de420867/index.html">Berechnung bestimmter Integrale: grundlegende Algorithmen</a></li>
<li><a href="../de420869/index.html">Evakuierung, HAMR und MAMR - drei M√∂glichkeiten, um die Kapazit√§t moderner Festplatten zu maximieren</a></li>
<li><a href="../de420871/index.html">Wie wir das Webstudio nach Bali verlegt haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>