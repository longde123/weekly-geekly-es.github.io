<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👦 😹 🤜🏿 SwiftUI：熟人 🌯 👩‍⚖️ 🧑🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在本教程中，我们将学习如何使用View计划UI应用程序，并学习如何使用State变量来修改UI。 

 预计阅读时间：25分钟。 

 SwiftUI允许我们完全忘记Interface Builder（IB）和情节提要。 IB和Xcode在Xcode 4之前是分开的应用程序，但是当我们编辑名称IBA...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SwiftUI：熟人</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471918/"> 在本教程中，我们将学习如何使用View计划UI应用程序，并学习如何使用<b>State变量</b>来修改UI。 <br><br> 预计阅读时间：25分钟。 <br><a name="habracut"></a><br>  SwiftUI允许我们完全忘记Interface Builder（IB）和情节提要。  IB和Xcode在Xcode 4之前是分开的应用程序，但是当我们编辑名称IBAction或IBOutlet且应用程序崩溃时，它们之间的“停靠”仍然可见。因此，IB对代码的更改一无所知。 或者，当我们为脚本或表格单元格设置标识符时，Xcode无法检查它们，因为它们是字符串。 <br><br>  SwiftUI来解救！ 输入代码后，我们立即在视图中看到更改。 一方面的更改会导致另一方面的更新，因此它们总是相关的。 没有可能会误认的字符串标识符。 以上就是全部代码，但是比起我们使用UIKit编写的代码要小得多，因此更易于理解，编辑和调试。 告诉我，那不是很棒吗？ <br><br><h2> 走吧 </h2><br> 让我们在Xcode项目（ <b>Shift-Command-N</b> ）中开始一个新项目，选择iOS▸Single <b>View App</b> ，调用RGBullsEye，并确保选择<b>SwiftUI</b>作为界面。 <br><br> 现在， <b>AppDelegate.swift</b>分为两个文件： <b>AppDelegate.swift和SceneDelegate.swift</b> ，SceneDelegate包含一个窗口： <br><br><img src="https://habrastorage.org/webt/jc/kw/b2/jckwb27k-lv_t6aiwlqhe_-upi0.png"><br><br>  <b>SceneDelegate</b>几乎与SwiftUI不相关，但以下行除外： <br><br><pre><code class="swift hljs">window.rootViewController = <span class="hljs-type"><span class="hljs-type">UIHostingController</span></span>(rootView: <span class="hljs-type"><span class="hljs-type">ContentView</span></span>())</code> </pre> <br>  <b>UIHostingController</b>为SwiftUI-view <b>ContentView</b>创建一个视图控制器。 <br><blockquote> 注意： <b>UIHostingController</b>允许我们将SwiftUI-view集成到现有应用程序中。 将Hosting View Controller添加到我们的情节提要中，并通过UIViewController在其上创建序列。 然后，在视图控制器代码上使用带有segue的Control-drag来创建<b>IBSegueAction</b> ，在这里我们将托管控制器设置为<b>rootView</b> -SwiftUI-view。 </blockquote> 当应用程序启动时，窗口显示<b>ContentView</b>的实例，该实例在文件<b>ContentView.swift中</b>定义。 这是一个符合<b>View</b>协议的结构： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContentView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body: some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello World"</span></span>) } }</code> </pre> <br> 这是ContentUI（ <b>body</b> ）内容的SwiftUI声明。 现在有一个带有“ Hello World”文本的文本视图。 <br><br> 在ContentView_Previews的正下方，返回ContentView的实例。 <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContentView_Previews</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PreviewProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> previews: some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-type"><span class="hljs-type">ContentView</span></span>() } }</code> </pre> <br> 在这里，我们可以设置预览的测试数据。 但是，这个预览到底在哪里？ <br><br> 在代码之后，立即有一个上面的空白： <br><br><img src="https://habrastorage.org/webt/u3/iv/qu/u3ivquebtlhjhi0-vnbctvg49tw.png"><br><br> 单击<b>恢复</b> ，稍等片刻，然后... <br><br><img src="https://habrastorage.org/webt/7x/hl/kh/7xhlkhixvhssyu34vjnvxdz7hkq.png"><br><br><h2> 绘制我们的UI </h2><br> 熟悉的东西不可见-这是<b>Main.storyboard</b>文件。 在查看预览的过程中，我们将在代码中使用SwiftUI创建我们的UI：我们能到达那里吗？ 但是不用担心，我们不必编写数百行代码来创建视图。 <br><br>  SwiftUI是声明性的：声明您的UI应该是什么样的，SwiftUI会将所有这些转换为可以完成所有工作的高效代码。  Apple允许您创建尽可能多的视图，从而使代码简单明了。 尤其推荐带有参数的可重用视图-这类似于将代码分配到单独的函数中。 您稍后会自己做。 <br><br> 我们的应用程序将具有很多视图，因此一开始，我们将草绘文本视图作为存根。 <br><br> 用以下内容替换文本（“ Hello World”）： <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"Target Color Block"</span></span>)</code> </pre> <br> 如有必要，请单击“ <b>恢复”</b>以更新预览。 <br><br> 现在，在<b>预览中</b> <b>命令单击</b>此视图，然后选择<b>Embed in HStack</b> ： <br><br><img src="https://habrastorage.org/webt/s-/tm/dy/s-tmdyehpyekmyid1tdxsbfh_xy.png"><br><br> 请注意，您的代码也已更改： <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">HStack</span></span> { <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"Target Color Block"</span></span>) }</code> </pre> <br> 复制并粘贴Text运算符，然后在我们的HStack中对其进行编辑。 请注意：我们不会用逗号分隔运算符，而是将它们各自写在新行上： <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">HStack</span></span> { <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"Target Color Block"</span></span>) <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"Guess Color Block"</span></span>) }</code> </pre><br> 因此，它会在预览中显示： <br><br><img src="https://habrastorage.org/webt/pj/sp/n6/pjspn6qoeesvvhbvuhj59po64oe.png"><br><br> 现在，通过将<b>HStack</b>放在<b>VStack</b>上，为滑块存根准备一个位置。 这次我们将<b>在我们的代码中</b>对HStack进行<b>Command-Click</b> ： <br><br><img src="https://habrastorage.org/webt/wa/bo/fn/wabofnratyjqvqaprm0nyali_zq.png"><br><br> 选择“ <b>嵌入VStack”</b> ； 将出现一个新代码，但预览不会更改。 稍后，我们将在未来的色块下添加视图。 <br><br> 在HStack之后立即添加新行，单击工具栏上的<b>+</b>以打开库，然后将<b>Vertical Stack</b>拖动到新行： <br><br><img src="https://habrastorage.org/webt/rl/dd/pw/rlddpwk_2bjxsrmi7hudiymh3na.png"><br><br> 如预期的那样，代码和预览均已更改： <br><br><img src="https://habrastorage.org/webt/f-/aq/w1/f-aqw1b3zp5aunz2cqysubhysug.png"><br><br> 完成UI草案上的工作，以使一切看起来像这样： <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">VStack</span></span> { <span class="hljs-type"><span class="hljs-type">HStack</span></span> { <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"Target Color Block"</span></span>) <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"Guess Color Block"</span></span>) } <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"Hit me button"</span></span>) <span class="hljs-type"><span class="hljs-type">VStack</span></span> { <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"Red slider"</span></span>) <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"Green slider"</span></span>) <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"Blue slider"</span></span>) } }</code> </pre> <br> 在新的VStack中，稍后将出现三个滑块，以及滑块和色块之间的按钮。 <br><br><h2> 我们继续致力于UI </h2><br> 现在让我们在SwiftUI中练习填充包含彩色块的HStack： <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">HStack</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Target color block VStack { Rectangle() Text("Match this color") } // Guess color block VStack { Rectangle() HStack { Text("R: xxx") Text("G: xxx") Text("B: xxx") } } }</span></span></code> </pre> <br> 每个色块都有一个矩形。 目标（目标）颜色块在矩形下方具有一个“文本”视图，而选定的一个（“猜测”）具有三个“文本”视图。 稍后，我们将用滑块的实际值替换“ xxx”。 <br><br><h2> 使用变量'@State' </h2><br> 在SwiftUI中，我们可以使用常规变量，但是如果希望变量的更改影响UI，则可以将变量标记为<b>'@State'</b> 。 在我们的应用程序中，我们选择颜色，以便影响所选颜色的所有变量均为'@State'变量。 <br><br> 在<b>主体</b>声明之前，将以下<b>几</b>行添加到<b>struct ContentView</b>内部： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rTarget = <span class="hljs-type"><span class="hljs-type">Double</span></span>.random(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>..&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gTarget = <span class="hljs-type"><span class="hljs-type">Double</span></span>.random(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>..&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bTarget = <span class="hljs-type"><span class="hljs-type">Double</span></span>.random(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>..&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>) @<span class="hljs-type"><span class="hljs-type">State</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rGuess: <span class="hljs-type"><span class="hljs-type">Double</span></span> @<span class="hljs-type"><span class="hljs-type">State</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gGuess: <span class="hljs-type"><span class="hljs-type">Double</span></span> @<span class="hljs-type"><span class="hljs-type">State</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bGuess: <span class="hljs-type"><span class="hljs-type">Double</span></span></code> </pre> <br>  R，G和B的值介于0和1之间。我们使用随机值初始化所需的值。 我们还可以将选定的值初始化为0.5，但暂时不对其进行初始化，以显示在这种情况下需要执行的操作。 <br><br> 让我们再<b>深入</b>到<b>结构ContentView_Previews</b> ，该<b>结构</b> <b>将为Preview</b>初始化ContentView实例。 现在，初始化程序需要选定值的初始值。 像这样更改<b>ContentView（）</b> ： <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">ContentView</span></span>(rGuess: <span class="hljs-number"><span class="hljs-number">0.5</span></span>, gGuess: <span class="hljs-number"><span class="hljs-number">0.5</span></span>, bGuess: <span class="hljs-number"><span class="hljs-number">0.5</span></span>)</code> </pre> <br> 当我们制作滑块时，在预览中它们的值将在中间。 <br><br> 我们还应该在<b>SceneDelegate</b>中的<b>场景</b>函数<b>（_：willConnectTo：options :)中</b>修复<b>初始化</b>程序-用以下内容替换<b>ContentView（）</b> ： <br><br><pre> <code class="swift hljs">window.rootViewController = <span class="hljs-type"><span class="hljs-type">UIHostingController</span></span>(rootView: <span class="hljs-type"><span class="hljs-type">ContentView</span></span>(rGuess: <span class="hljs-number"><span class="hljs-number">0.5</span></span>, gGuess: <span class="hljs-number"><span class="hljs-number">0.5</span></span>, bGuess: <span class="hljs-number"><span class="hljs-number">0.5</span></span>))</code> </pre><br> 加载应用程序时，滑块指针将位于中间。 <br><br> 现在将颜色修改器添加到目标矩形： <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">Rectangle</span></span>() .foregroundColor(<span class="hljs-type"><span class="hljs-type">Color</span></span>(red: rTarget, green: gTarget, blue: bTarget, opacity: <span class="hljs-number"><span class="hljs-number">1.0</span></span>))</code> </pre> <br>  <b>.foregroundColor</b>修改器使用随机生成的RGB值指定的颜色创建一个新的Rectangle视图。 <br><br> 同样，修改猜测矩形： <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">Rectangle</span></span>() .foregroundColor(<span class="hljs-type"><span class="hljs-type">Color</span></span>(red: rGuess, green: gGuess, blue: bGuess, opacity: <span class="hljs-number"><span class="hljs-number">1.0</span></span>))</code> </pre> <br>  R，G和B的值为0.5时，我们将获得灰色。 <br><br> 单击恢复，请稍等。 <br><br><img src="https://habrastorage.org/webt/yl/nr/d5/ylnrd5lgrnbg2zgnqwapyzuwrhm.png"><br><br><h2> 使视图可重用 </h2><br> 首先，我们不会考虑重用，而只是为红色制作滑块。 在用于滑块的<b>VStack</b>中，将Text（“红色滑块”）插头替换为此<b>HStack</b> ： <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">HStack</span></span> { <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"0"</span></span>) .foregroundColor(.red) <span class="hljs-type"><span class="hljs-type">Slider</span></span>(value: $rGuess) <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"255"</span></span>) .foregroundColor(.red) }</code> </pre> <br> 我们将文本视图中的文本颜色设为红色。 并且他们为Slider添加了默认值。 滑块的默认范围是0到1，这非常适合我们。 <br><blockquote> 注意：我们知道滑块从0到1，文本标签为“ 255”，以方便习惯于表示0到255范围内的RGB值的用户。 </blockquote> 但是，变量具有哪种<b>$</b>图标？ 我们知道<b>吗？</b>  <b>和！</b> 当使用<b>可选选项时</b> ，现在还有<b>$</b> ？ <br><br> 尽管他是如此之小和不起眼，但他仍然非常重要。  <b>RGuess</b>本身只是一个<b>只读</b>值。 但是<b>$ rGuess是一个绑定</b> ，当用户移动滑块时，我们需要它来更新所选颜色的矩形。 <br><br> 要了解差异，请在可预测的矩形下设置三个文本视图的值： <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">HStack</span></span> { <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"R: \(Int(rGuess * 255.0))"</span></span>) <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"G: \(Int(gGuess * 255.0))"</span></span>) <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"B: \(Int(bGuess * 255.0))"</span></span>) }</code> </pre> <br> 在这里，我们仅使用值，而不更改它们，因此我们不需要$前缀。 <br><br> 等待预览更新： <br><br><img src="https://habrastorage.org/webt/yf/fi/fx/yffifxnmxgba3ghsjg8hwptqces.png"><br><br> 彩色矩形会略微收缩以适合滑块。 但是滑块的文本标签看起来很乱-它们太压在边缘了。 让我们向HStack添加另一个修饰符-填充： <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">HStack</span></span> { <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"0"</span></span>) .foregroundColor(.red) <span class="hljs-type"><span class="hljs-type">Slider</span></span>(value: $rGuess) <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"255"</span></span>) .foregroundColor(.red) } .padding()</code> </pre> <br> 现在好多了！ <br><br><img src="https://habrastorage.org/webt/rw/4d/mj/rw4dmjkhddr768hvcgfg3-fljqk.png"><br><br> 在HStack红色滑块上<b>单击命令</b>并选择<b>Extract Subview</b> ： <br><br><img src="https://habrastorage.org/webt/vr/ln/-q/vrln-q4ebzp3m5aubyaysixuu0u.png"><br><br> 这与“ <b>重构▸提取到函数”</b>的作用相同，但适用于SwiftUI视图。 <br><br> 此时，将出现几条错误消息，不用担心，现在我们将对其进行修复。 <br><br> 将结果命名为<b>ColorSlider</b>并将此代码添加到新视图主体前面的顶部： <br><br><pre> <code class="swift hljs">@<span class="hljs-type"><span class="hljs-type">Binding</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> textColor: <span class="hljs-type"><span class="hljs-type">Color</span></span></code> </pre> <br> 现在将<b>$ rGuess</b>替换<b>为$ value，并将.red</b>替换<b>为textColor</b> ： <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"0"</span></span>) .foregroundColor(textColor) <span class="hljs-type"><span class="hljs-type">Slider</span></span>(value: $value) <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"255"</span></span>) .foregroundColor(textColor)</code> </pre> <br> 让我们回到VStack中ColorSlider（）的定义并添加我们的参数： <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">ColorSlider</span></span>(value: $rGuess, textColor: .red)</code> </pre> <br> 使用红色滑块确保预览正常，并用绿色和蓝色滑块替换文本存根。 不要忘记在此处插入正确的参数： <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">ColorSlider</span></span>(value: $gGuess, textColor: .green) <span class="hljs-type"><span class="hljs-type">ColorSlider</span></span>(value: $bGuess, textColor: .blue)</code> </pre> <br> 单击<b>恢复</b>以更新预览： <br><br><img src="https://habrastorage.org/webt/nx/4c/1z/nx4c1zblb3lkvi123ucqt6gte5e.png"><br><blockquote> 注意：您可能已经注意到经常需要单击<b>Resume</b> 。 如果您喜欢快捷方式，则可能会喜欢<b>Option-Command-P</b> 。 </blockquote> 现在好东西！ 在预览的右下角，单击<b>实时预览</b>按钮： <br><br><img src="https://habrastorage.org/webt/76/er/wu/76erwudgdom32-amjikoa6lfiya.png"><br><br> 实时预览使我们可以与预览进行交互，就好像应用程序正在模拟器上运行一样！ <br><br> 尝试移动滑块： <br><br><img src="https://habrastorage.org/webt/9h/9e/pi/9h9epih_dde4yuduxpiu6lhdswg.png"><br><br> 太好了！ 我们进入最后阶段。 毕竟，我们想知道我们挑选颜色的程度如何？ <br><br><h2> 显示警报 </h2><br> 将滑块设置到所需位置后，用户按下“ <b>命中我”</b>按钮，此后将显示带有等级的<b>警报</b> 。 <br><br> 首先，向ContentView添加一种方法来计算分数。 在变量@State和之间 <br> 正文添加此方法： <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computeScore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rDiff = rGuess - rTarget <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gDiff = gGuess - gTarget <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bDiff = bGuess - bTarget <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> diff = sqrt(rDiff * rDiff + gDiff * gDiff + bDiff * bDiff) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span>((<span class="hljs-number"><span class="hljs-number">1.0</span></span> - diff) * <span class="hljs-number"><span class="hljs-number">100.0</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) }</code> </pre> <br>  <b>diff</b>值只是三维空间中两点之间的距离，即用户的误差值。 要获得估算值，请从1减去diff，然后将其值减小到0-100范围。diff越小，估算值就越高。 <br><br> 然后，用以下代码替换<b>Text（“命中按钮”）</b>存根： <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">Button</span></span>(action: { }) { <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"Hit Me!"</span></span>) }</code> </pre> <br>  Button具有动作和标签，例如UIButton。 我们想要采取行动来触发警报视图。 但是，如果我们在操作按钮中创建警报，那么什么也不会发生。 <br><br> 相反，我们将Alert设置为ContentView的一部分，并添加Bool类型的'@State'变量。 然后，在希望警报显示在操作按钮中的位置，将此变量设置为true。 当用户隐藏“警报”时，该值将重置为false-以隐藏警报。 <br><br> 添加此“ @State”变量： <br><br><pre> <code class="swift hljs">@<span class="hljs-type"><span class="hljs-type">State</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> showAlert = <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br> 然后将此代码添加为操作按钮： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.showAlert = <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br> 自我对我们来说是必需的，因为showAlert在闭包内部。 <br><br> 最后，将alert修饰符添加到按钮，因此我们的按钮看起来完全像这样： <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">Button</span></span>(action: { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.showAlert = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) { <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"Hit Me!"</span></span>) } .alert(isPresented: $showAlert) { <span class="hljs-type"><span class="hljs-type">Alert</span></span>(title: <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"Your Score"</span></span>), message: <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"\(computeScore())"</span></span>)) }</code> </pre><br> 我们将$ showAlert作为绑定传递，因为此变量的值将在用户隐藏警报时更改，并且此更改将导致视图更新。 <br><br>  SwiftUI具有用于Alert视图的简单初始化程序。 默认情况下，它具有“确定”按钮，因此我们甚至不需要将其设置为参数。 <br><br> 打开实时预览，移动滑块，然后按“命中我”按钮。 瞧！ <br><br><img src="https://habrastorage.org/webt/je/j2/lu/jej2lu5e6ookqthzdqvhz03lcqk.png"><br><br> 现在有了实时预览，您不再需要iOS模拟器。 尽管有了它，您可以水平测试应用程序： <br><br><img src="https://habrastorage.org/webt/m2/xe/np/m2xenpxqc1hzub85tqronv9ykwe.png"><br><br><h2> 结论 </h2><br> 您可以<a href="" rel="nofollow">在此处</a>下载完成的出版物草案。 <br><br> 本教程仅介绍了SwiftUI，但现在您对Xcode的用于创建UI和预览的新功能以及如何使用'@State'变量更新UI有了印象。 <br><br> 为了简单起见，我们没有为RGB创建数据模型。 但是大多数应用程序使用结构或类创建其数据模型。 如果要跟踪SwiftUI中模型的更改，则它必须符合<b>ObservableObject</b>协议并实现<b>willChange</b>属性，该属性将通知您更改。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">查看</a> Apple示例，尤其是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">通过SwiftUI的数据流</a> 。 <br><br> 为了使SwiftUI易于理解，您可以将SwiftUI视图添加到现有应用程序中。 查看有关如何快速轻松地执行此操作的示例。 <br><br> 请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我的出版物</a> ，了解如何使用SwiftUI实现折叠/下拉列表。 <br><br> 最后，研究<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">SwiftUI</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">文档</a> ，确实有很多有用的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">东西</a> ！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN471918/">https://habr.com/ru/post/zh-CN471918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN471904/index.html">HPE InfoSight的资源规划师</a></li>
<li><a href="../zh-CN471906/index.html">优化不当的危险</a></li>
<li><a href="../zh-CN471908/index.html">素数的意外之美</a></li>
<li><a href="../zh-CN471912/index.html">学习英语：扩大词汇量的7种实用方法</a></li>
<li><a href="../zh-CN471914/index.html">Sega Mega Drive图形系统如何工作：视频显示处理器</a></li>
<li><a href="../zh-CN471924/index.html">介绍Sass模块</a></li>
<li><a href="../zh-CN471928/index.html">自动还原Mikrotik路由器中最后保存的配置</a></li>
<li><a href="../zh-CN471930/index.html">原子设计mitap-字母，颜色，制服，团队和金钱</a></li>
<li><a href="../zh-CN471938/index.html">布局说明：2019年有用的Google Chrome扩展程序</a></li>
<li><a href="../zh-CN471940/index.html">如何减少延期结算中的违约风险：业务因素</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>