<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦃 😫 👩🏿‍🤝‍👩🏼 Application PentQL avec GraphQL 🍖 👩🏽‍🤝‍👨🏻 ⏱️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Récemment, GraphQL gagne de plus en plus en popularité et suscite de plus en plus l'intérêt des experts en sécurité de l'information. La technologie e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Application PentQL avec GraphQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/444708/"><img src="https://habrastorage.org/webt/nc/28/f2/nc28f2sderdsdwypyfdpksfbe6e.jpeg"><br><br>  Récemment, GraphQL gagne de plus en plus en popularité et suscite de plus en plus l'intérêt des experts en sécurité de l'information.  La technologie est utilisée par des entreprises telles que: Facebook, Twitter, PayPal, Github et autres, ce qui signifie qu'il est temps de comprendre comment tester une telle API.  Dans cet article, nous parlerons des principes de ce langage de requête et des instructions pour tester la pénétration des applications avec GraphQL. <br><a name="habracut"></a><br>  Pourquoi avez-vous besoin de connaître GraphQL?  Ce langage de requête se développe activement et de plus en plus d'entreprises y trouvent une utilisation pratique.  Dans le cadre des programmes Bug Bounty, la popularité de ce langage augmente également, des exemples intéressants peuvent être vus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  <b>La préparation</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un site de test</a> où vous trouverez la plupart des exemples dans cet article. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Une liste</a> avec des applications que vous pouvez également utiliser pour étudier. <br><br>  Pour interagir avec différentes API, il est préférable d'utiliser l'IDE GraphQL: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Aire de jeux Graphql</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Altair</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Insomnie</a> </li></ul><br>  Nous recommandons le dernier IDE: Insomnia a une interface simple et pratique, il existe de nombreux paramètres et l'auto-complétion des champs de requête. <br><br>  Avant de passer directement aux méthodes générales d'analyse de sécurité des applications avec GraphQL, nous rappelons les concepts de base. <br><br><h4>  Qu'est-ce que GraphQL? </h4><br>  GraphQL est un langage de requête API conçu pour fournir une alternative plus efficace, puissante et flexible à REST.  Il est basé sur un échantillonnage de données déclaratif, c'est-à-dire que le client peut spécifier exactement les données dont il a besoin à partir de l'API.  Au lieu de plusieurs points de terminaison, l'API (REST) ​​GraphQL représente un seul point de terminaison qui fournit au client les données demandées. <br><br><h4>  Différences clés entre REST et GraphQL </h4><br>  Généralement, dans l'API REST, vous devez obtenir des informations de différents points de terminaison.  Dans GraphQL, pour obtenir les mêmes données, vous devez effectuer une requête indiquant les données que vous souhaitez recevoir. <br><br><img src="https://habrastorage.org/webt/al/ci/gd/alcigdciygrluisjws8skolz7dk.png"><br><br>  L'API REST fournit les informations que le développeur mettra dans l'API, c'est-à-dire que si vous avez besoin d'obtenir plus ou moins d'informations que l'API ne le suggère, des actions supplémentaires seront nécessaires.  Encore une fois, GraphQL fournit exactement les informations demandées. <br>  Un ajout utile est que GraphQL a un schéma qui décrit comment et quelles données le client peut recevoir. <br><br><h4>  Types de requêtes </h4><br>  Il existe 3 principaux types de requêtes dans GraphQL: <br><br><ul><li>  Requête </li><li>  Mutation </li><li>  Abonnement </li></ul><br>  <b>Requête</b> <br><br>  Les requêtes de requête sont utilisées pour récupérer / lire des données dans un schéma. <br><br>  Un exemple d'une telle demande: <br><br><pre><code class="xml hljs">query { allPersons { name } }</code> </pre> <br>  Dans la demande, nous indiquons que nous voulons obtenir les noms de tous les utilisateurs.  En plus du nom, nous pouvons spécifier d'autres champs: <b>âge</b> , <b>identifiant</b> , <b>messages</b> , etc. Pour savoir quels champs nous pouvons obtenir, vous devez appuyer sur Ctrl + Espace.  Dans cet exemple, nous transmettons le paramètre avec lequel l'application renverra les deux premiers enregistrements: <br><br><pre> <code class="xml hljs">query { allPersons(first: 2) { name } }</code> </pre> <br>  <b>Mutation</b> <br><br>  Si le type de requête est nécessaire pour lire des données, le type de mutation est nécessaire pour écrire, supprimer et modifier des données dans GraphQL. <br><br>  Un exemple d'une telle demande: <br><br><pre> <code class="xml hljs">mutation { createPerson(name:"Bob", age: 37) { id name age } }</code> </pre> <br>  Dans cette demande, nous créons un utilisateur avec le nom Bob et âgé de 37 ans (ces paramètres sont passés comme arguments), dans la pièce jointe (accolades) nous indiquons quelles données nous voulons recevoir du serveur après avoir créé l'utilisateur.  Cela est nécessaire pour comprendre que la demande a abouti, ainsi que pour obtenir des données que le serveur génère indépendamment, telles que <b>id</b> . <br><br>  <b>Abonnement</b> <br><br>  Un autre type de requête dans GraphQL est l'abonnement.  Il est nécessaire d'informer les utilisateurs de tout changement survenu dans le système.  Cela fonctionne comme ceci: le client souscrit à un événement, après quoi une connexion est établie avec le serveur (généralement via WebSocket), et lorsque cet événement se produit, le serveur envoie une notification au client concernant la connexion établie. <br><br>  Un exemple: <br><br><pre> <code class="xml hljs">subscription { newPerson { name age id } }</code> </pre> <br>  Lorsqu'une nouvelle personne est créée, le serveur envoie des informations au client.  La présence de requêtes d'abonnement dans les schémas est moins courante que la requête et la mutation. <br><br>  Il convient de noter que toutes les capacités de requête, de mutation et d'abonnement sont créées et configurées par le développeur d'une API spécifique. <br><br><h4>  En option </h4><br>  En pratique, les développeurs utilisent souvent alias et OperationName dans les requêtes pour plus de clarté. <br><br>  <b>Alias</b> <br><br>  GraphQL pour les requêtes fournit la fonction d'alias, qui peut faciliter la compréhension de ce que le client demande. <br><br>  Supposons que nous ayons une requête du formulaire: <br><br><pre> <code class="xml hljs">{ Person(id: 123) { age } }</code> </pre> <br>  qui affichera le nom d'utilisateur avec l' <b>ID</b> 123. Que ce nom d'utilisateur soit Vasya. <br><br>  Pour que la prochaine fois vous ne vous demandiez pas ce que cette demande affichera, vous pouvez le faire comme ceci: <br><br><pre> <code class="xml hljs">{ Vasya: Person(id: 123) { age } }</code> </pre> <br>  <b>Nom de l'opération</b> <br><br>  En plus de l'alias, GraphQL utilise OperationName: <br><br><pre> <code class="xml hljs">query gettingAllPersons { allPersons { name age } }</code> </pre> <br>  OperationName est nécessaire pour expliquer exactement ce que fait la demande. <br><br><h3>  Pentest </h3><br>  Après avoir compris les bases, nous allons directement au pentest.  Comment comprendre qu'une application utilise GraphQL?  Voici un exemple de requête qui a une requête GraphQL: <br><br><pre> <code class="xml hljs">POST /simple/v1/cjp70ml3o9tpa0184rtqs8tmu/ HTTP/1.1 Host: api.graph.cool User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:65.0) Gecko/20100101 Firefox/65.0 Accept: */* Accept-Language: ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Referer: https://api.graph.cool/simple/v1/cjp70ml3o9tpa0184rtqs8tmu/ content-type: application/json Origin: https://api.graph.cool Content-Length: 139 Connection: close {"operationName":null,"variables":{},"query":"{\n __schema {\n mutationType {\n fields {\n name\n }\n }\n }\n}\n"}</code> </pre> <br>  Quelques paramètres par lesquels vous pouvez comprendre que c'est GraphQL, et pas autre chose: <br><br><ul><li>  dans le corps de la requête, il y a des mots: __schema, champs, operationName, mutation, etc.; </li><li>  dans le corps de la requête, il y a beaucoup de caractères "\ n".  Comme le montre la pratique, ils peuvent être supprimés pour faciliter la lecture de la demande; </li><li>  souvent le moyen d'envoyer une demande au serveur: ⁄graphql </li></ul><br>  Super, trouvé et identifié.  Mais <s>où insérer le guillemet</s> comment savoir avec quoi nous devons travailler?  L'introspection viendra à la rescousse. <br><br><h4>  Introspection </h4><br>  GraphQL fournit un schéma d'introspection, c'est-à-dire  un schéma décrivant les données que nous pouvons obtenir.  Grâce à cela, nous pouvons découvrir quelles demandes existent, quels arguments peuvent / doivent leur être transmis, et bien plus encore.  Notez que dans certains cas, les développeurs n'autorisent pas intentionnellement la possibilité d'introspection de leur application.  Cependant, la grande majorité laisse encore cette possibilité. <br><br>  Considérez les exemples de base des requêtes. <br><br>  <b>Exemple 1. Obtenir toutes sortes de demandes</b> <br><br><pre> <code class="xml hljs">query { __schema { types { name fields { name } } } }</code> </pre> <br>  Nous formons une requête de requête, indiquons que nous voulons recevoir des données sur __schema, et dans ce type, leurs noms et champs.  Dans GraphQL, il existe des noms de variables de service: __schema, __typename, __type. <br><br>  Dans la réponse, nous recevrons tous les types de demandes, leurs noms et champs qui existent dans le schéma. <br><br>  <b>Exemple 2. Obtention de champs pour un type de demande spécifique (requête, mutation, description)</b> <br><br><pre> <code class="xml hljs">query { __schema { queryType { fields { name args { name } } } } }</code> </pre> <br>  La réponse à cette demande sera toutes les demandes possibles que nous pouvons exécuter sur le schéma de réception des données (type de requête), et les arguments possibles / nécessaires pour celles-ci.  Pour certaines requêtes, la spécification du ou des arguments est requise.  Si vous exécutez une telle demande sans spécifier un argument requis, le serveur doit afficher un message d'erreur que vous devez le spécifier.  Au lieu de queryType, nous pouvons remplacer mutationType et subscriptionType pour obtenir toutes les demandes possibles de mutations et d'abonnements, respectivement. <br><br>  <b>Exemple 3. Obtention d'informations sur un type de demande spécifique</b> <br><br><pre> <code class="xml hljs">query { __type(name: "Person") { fields { name } } }</code> </pre> <br>  Grâce à cette requête, nous obtenons tous les champs pour le type Personne.  Comme argument, au lieu de Personne, nous pouvons transmettre tout autre nom de demande. <br><br>  Maintenant que nous pouvons comprendre la structure générale de l'application testée, déterminons ce que nous recherchons. <br><br>  <b>Divulgation d'informations</b> <br><br>  Le plus souvent, une application utilisant GraphQL se compose de nombreux champs et types de requêtes et, comme beaucoup de gens le savent, plus l'application est complexe et volumineuse, plus il est difficile de configurer et de surveiller sa sécurité.  C'est pourquoi, avec une introspection minutieuse, vous pouvez trouver quelque chose d'intéressant, par exemple: les noms complets des utilisateurs, leurs numéros de téléphone et d'autres données critiques.  Par conséquent, si vous souhaitez trouver quelque chose comme ça, nous vous recommandons de vérifier tous les champs et arguments possibles de l'application.  Ainsi, dans le cadre du pentest dans l'une des applications, des données utilisateur ont été trouvées: nom, numéro de téléphone, date de naissance, certaines données de carte, etc. <br><br>  Un exemple: <br><br><pre> <code class="xml hljs">query { User(id: 1) { name birth phone email password } }</code> </pre><br>  En parcourant les valeurs id, nous pouvons obtenir des informations sur les autres utilisateurs (et peut-être pas, si tout est correctement configuré). <br><br>  <b>Injections</b> <br><br>  Inutile de dire que presque partout où il y a du travail avec une grande quantité de données, il y a des bases de données?  Et là où il y a une base de données - il peut y avoir des injections SQL, des injections NoSQL et d'autres types d'injections. <br><br>  Un exemple: <br><br><pre> <code class="xml hljs">mutation { createPerson(name:"Vasya'--+") { name } }</code> </pre> <br>  Voici une injection SQL élémentaire dans l'argument de requête. <br><br>  <b>Contournement d'autorisation</b> <br>  Disons que nous pouvons créer des utilisateurs: <br><br><pre> <code class="xml hljs">mutation { createPerson(username:"Vasya", password: "Qwerty1") { } }</code> </pre> <br>  En supposant qu'il existe un certain paramètre isAdmin dans le gestionnaire sur le serveur, nous pouvons envoyer une demande du formulaire: <br><br><pre> <code class="xml hljs">mutation { createPerson(username:"Vasya", password: "Qwerty1", isAdmin: True) { } }</code> </pre> <br>  Et faites de l'utilisateur Vasya un administrateur. <br><br><h4>  Dos </h4><br>  En plus de la commodité déclarée, GraphQL a ses propres failles de sécurité. <br><br>  Prenons un exemple: <br><br><pre> <code class="xml hljs">query { Person { posts { author { posts { author { posts { author ... } } } } } } }</code> </pre> <br>  Comme vous pouvez le voir, nous avons créé une sous-requête en boucle.  Avec un grand nombre de tels investissements, par exemple 50 000, nous pouvons envoyer une demande qui sera traitée par le serveur pendant très longtemps ou la «supprimer» complètement.  Au lieu de traiter les demandes valides, le serveur sera occupé à déballer l'imbrication géante de la demande factice. <br><br>  En plus de l'imbrication importante, les requêtes elles-mêmes peuvent être «lourdes» - c'est quand une requête a beaucoup de champs et de pièces jointes internes.  Une telle demande peut également entraîner des difficultés de traitement sur le serveur. <br><br><h3>  Conclusion </h3><br>  Nous avons donc examiné les principes de base des tests de pénétration des applications avec GraphQL.  Nous espérons que vous avez appris quelque chose de nouveau et d'utile pour vous.  Si ce sujet vous intéresse et que vous souhaitez l'étudier plus en profondeur, nous vous recommandons les ressources suivantes: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.howtographql.com</a> est la principale ressource pour apprendre à partir de zéro.  En plus de la théorie, il contient également de la pratique. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.graphql.com</a> est également un bon site pour étudier cette technologie. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.howtographql.com/advanced/4-security</a> - Sécurité <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GraphQL</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AppSecCali 2019 - Vue d'un attaquant sur les applications sans serveur et GraphQL</a> - une bonne vidéo avec des exemples spécifiques. </li></ul><br>  Et n'oubliez pas: la pratique rend parfait.  Bonne chance </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444708/">https://habr.com/ru/post/fr444708/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444694/index.html">Comme nous l'avions prédit, la sortie comme une catastrophe naturelle</a></li>
<li><a href="../fr444696/index.html">Augmentez la densité des conteneurs sur un nœud à l'aide de la technologie PFCACHE</a></li>
<li><a href="../fr444700/index.html">Bases de données aléatoires. Oracle Enterprise Data Quality - Shield and Sword for Enterprise Storage</a></li>
<li><a href="../fr444704/index.html">Opportunités nanoCAD SPDS Chantier de construction dans des projets de construction et de reconstruction dans des conditions exiguës</a></li>
<li><a href="../fr444706/index.html">Photos Facebook 3D à l'intérieur: Shaders Parallax</a></li>
<li><a href="../fr444710/index.html">Comprendre le protocole de consensus stellaire</a></li>
<li><a href="../fr444712/index.html">«Attitude atypique à l'égard de la finance» - et si les employés géraient eux-mêmes leurs revenus. Conversation avec Flant</a></li>
<li><a href="../fr444714/index.html">Comment nous avons overclocké CAD COMPASS-3D → Partie 1</a></li>
<li><a href="../fr444716/index.html">Un téléphone Samsung avec un écran pliable pour 2000 $ affiche un pli</a></li>
<li><a href="../fr444718/index.html">Holographie amateur - le début du voyage</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>