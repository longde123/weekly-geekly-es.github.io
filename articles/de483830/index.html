<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äçüè≠ üï† üåô Routing f√ºr iOS: Universelle Navigation ohne Umschreiben der Anwendung üî≠ üö£üèæ üëåüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In jeder Anwendung, die aus mehr als einem Bildschirm besteht, muss die Navigation zwischen seinen Komponenten implementiert werden. Dies sollte ansch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Routing f√ºr iOS: Universelle Navigation ohne Umschreiben der Anwendung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/483830/">  In jeder Anwendung, die aus mehr als einem Bildschirm besteht, muss die Navigation zwischen seinen Komponenten implementiert werden.  Dies sollte anscheinend kein Problem sein, da es in UIKit recht komfortable Containerkomponenten wie UINavigationController und UITabBarController sowie flexible modale Methoden zur Bildschirmanzeige gibt: Verwenden Sie einfach die richtige Navigation zum richtigen Zeitpunkt. <br><img src="https://habrastorage.org/webt/h0/r3/vf/h0r3vfqvn3tlkotbyelqpy5jqjo.png"><br>  Sobald die Anwendung jedoch √ºber eine Push-Benachrichtigung oder einen Link auf einen Bildschirm wechselt, wird alles etwas komplizierter.  Ab sofort gibt es viele Fragen: <br><br><ul><li>  Was tun mit dem View-Controller, der jetzt auf dem Bildschirm angezeigt wird? </li><li>  Wie wechsle ich den Kontext (z. B. aktiver Tab in UITabBarController)? </li><li>  Hat der aktuelle Navigationsstapel den richtigen Bildschirm? </li><li>  Wann sollte die Navigation ignoriert werden? </li></ul><br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/rb/dr/zb/rbdrzb1qpjkgxw6zfclqjqtdstq.gif" width="300"><br><br>  Bei der iOS-Entwicklung sind wir bei Badoo auf all diese Probleme gesto√üen.  Aus diesem Grund haben wir unsere L√∂sungsmethoden in eine Bibliothek von Komponenten f√ºr die Navigation formalisiert, die wir in allen neuen Produkten verwenden.  In diesem Artikel werde ich genauer auf unseren Ansatz eingehen.  Ein Beispiel f√ºr die Anwendung der beschriebenen Praktiken ist in einem kleinen <a href="https://github.com/azatZul/NavigationDemo">Demo-Projekt zu sehen</a> . <br><br><h2>  Unser Problem </h2><br>  H√§ufig werden Navigationsprobleme durch Hinzuf√ºgen einer globalen Komponente gel√∂st, die die Struktur der Bildschirme in der Anwendung kennt und entscheidet, was in diesem oder jenem Fall zu tun ist.  Die Struktur der Bildschirme gibt Auskunft √ºber das Vorhandensein eines Containers in der aktuellen Hierarchie der Controller und Abschnitte der Anwendung. <br><br>  Badoo hatte eine √§hnliche Komponente.  √Ñhnlich funktionierte es mit der ziemlich alten Bibliothek von Facebook, die jetzt nicht mehr in ihrem √∂ffentlichen Repository zu finden ist.  Die Navigation basierte auf URLs, die mit Anwendungsbildschirmen verkn√ºpft waren.  Grunds√§tzlich war die gesamte Logik in einer Klasse enthalten, die an das Vorhandensein einer Tab-Leiste und an einige andere badoo-spezifische Funktionen gebunden war.  Die Komplexit√§t und Konnektivit√§t dieser Komponente war so hoch, dass die L√∂sung von Aufgaben, die eine √Ñnderung der Navigationslogik erforderten, ein Vielfaches l√§nger dauern konnte als geplant.  Die Testbarkeit dieser Klasse warf auch gro√üe Fragen auf. <br><br>  Diese Komponente wurde erstellt, als wir nur eine Anwendung hatten.  Wir konnten uns nicht vorstellen, dass wir in Zukunft mehrere Produkte entwickeln w√ºrden, die sich stark voneinander unterscheiden ( <a href="https://bumble.com/">Bumble</a> , <a href="https://lumenapp.com/">Lumen</a> und andere).  Aus diesem Grund war der Navigator aus unserer ausgereiftesten Anwendung - Badoo - nicht in anderen Produkten einsetzbar und jedes Team musste sich etwas Neues einfallen lassen. <br><br>  Leider wurden auch f√ºr bestimmte Anwendungen neue Ans√§tze gesch√§rft.  Mit der zunehmenden Anzahl von Projekten wurde das Problem offensichtlich und es entstand die Idee, eine Bibliothek zu erstellen, die bestimmte Komponenten, einschlie√ülich der universellen Navigationslogik, bereitstellt.  Dies w√ºrde dazu beitragen, die Implementierungszeit f√ºr √§hnliche Funktionen in neuen Produkten zu minimieren. <br><br><h2>  Wir implementieren einen universellen Router </h2><br>  Die Hauptaufgaben, die der globale Navigator l√∂st, sind nicht so viele: <br><br><ol><li>  Suchen Sie den aktuell aktiven Bildschirm. </li><li>  Vergleichen Sie irgendwie den Typ des aktiven Bildschirms und seinen Inhalt mit dem, was angezeigt werden muss. </li><li>  F√ºhren Sie den √úbergang nach Bedarf durch (Reihenfolge der √úberg√§nge). </li></ol><br>  Vielleicht sieht die Formulierung der Aufgaben etwas abstrakt aus, aber es ist diese Abstraktion, die es erm√∂glicht, die Logik zu universalisieren. <br><br><h3>  1. Aktive Bildschirmsuche </h3><br>  Die erste Aufgabe scheint ganz einfach zu sein: Sie m√ºssen nur die gesamte Hierarchie der Bildschirme <i>durchgehen</i> und den obersten <i>UIViewController finden</i> . <br><br><img src="https://habrastorage.org/webt/vw/dj/er/vwdjerugihaukbnwqjri1cd4wu0.png"><br><br>  Die Oberfl√§che unseres Objekts k√∂nnte ungef√§hr so ‚Äã‚Äãaussehen: <br><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopViewControllerProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> topViewController: <span class="hljs-type"><span class="hljs-type">UIViewController?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } }</code> </pre> <br>  Es ist jedoch nicht klar, wie das Stammelement der Hierarchie bestimmt werden soll und was mit Containerbildschirmen wie UIPageViewController und anwendungsspezifischen Containern zu tun ist. <br><br>  Die einfachste M√∂glichkeit, das Root-Element zu bestimmen, besteht darin, den Root-Controller vom aktiven Bildschirm aus abzurufen: <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">UIApplication</span></span>.shared.windows.first { $<span class="hljs-number"><span class="hljs-number">0</span></span>.isKeyWindow }?.rootViewController</code> </pre> <br>  Dieser Ansatz funktioniert m√∂glicherweise nicht immer mit Anwendungen, in denen mehrere Fenster vorhanden sind.  Dies ist jedoch ein eher seltener Fall, und das Problem kann gel√∂st werden, indem das gew√ºnschte Fenster explizit als Parameter √ºbergeben wird. <br><br>  Das Problem mit Containerbildschirmen kann gel√∂st werden, indem ein spezielles Protokoll erstellt wird, das eine Methode zum Abrufen eines aktiven Bildschirms enth√§lt, oder Sie k√∂nnen das oben angegebene Protokoll verwenden.  Alle in der Anwendung verwendeten Container-Controller m√ºssen dieses Protokoll implementieren.  F√ºr einen <i>UITabBarController</i> k√∂nnte <i>eine</i> Implementierung beispielsweise so aussehen: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITabBarController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopViewControllerProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> topViewController: <span class="hljs-type"><span class="hljs-type">UIViewController?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.selectedViewController } }</code> </pre> <br>  Es bleibt nur, die gesamte Hierarchie zu durchlaufen und den oberen Bildschirm zu erhalten.  Wenn der n√§chste Controller TopViewControllerProvider implementiert, wird der Bildschirm √ºber die deklarierte Methode angezeigt.  Andernfalls wird der Controller, der darauf angezeigt wird, modal √ºberpr√ºft (falls vorhanden). <br><br><h3>  2. Aktueller Kontext </h3><br>  Die Aufgabe, den aktuellen Kontext zu bestimmen, sieht viel komplizierter aus.  Wir wollen den Bildschirmtyp und m√∂glicherweise die darauf angezeigten Informationen bestimmen.  Es erscheint logisch, eine Struktur zu erstellen, die diese Informationen enth√§lt. <br><br>  Aber welche Typen sollten Objekteigenschaften haben?  Unser letztendliches Ziel ist es, den Kontext mit dem, was gezeigt werden muss, zu vergleichen, damit das <i>Equatable-</i> Protokoll implementiert <i>werden</i> kann.  Dies kann durch generische Typen implementiert werden: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerContext</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScreenType</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Equatable</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InfoType</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Equatable</span></span></span><span class="hljs-class">&gt;: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Equatable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> screenType: <span class="hljs-type"><span class="hljs-type">ScreenType</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> info: <span class="hljs-type"><span class="hljs-type">InfoType?</span></span> }</code> </pre> <br>  Aufgrund der Besonderheiten von Swift bestehen jedoch gewisse Einschr√§nkungen f√ºr die Verwendung dieses Typs.  Um Probleme zu vermeiden, sieht diese Struktur in unseren Anwendungen etwas anders aus: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerContextInfo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEqual</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to info: ViewControllerContextInfo?)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerContext</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Equatable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> screenType: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> info: <span class="hljs-type"><span class="hljs-type">ViewControllerContextInfo?</span></span> }</code> </pre> <br>  Eine weitere Option ist die Nutzung der neuen Swift-Funktion ‚Äû <a href="https://docs.swift.org/swift-book/LanguageGuide/OpaqueTypes.html">Undurchsichtige Typen‚Äú</a> . Sie ist jedoch erst ab iOS 13 verf√ºgbar, was f√ºr viele Produkte immer noch nicht akzeptabel ist. <br><br>  Die Implementierung des Kontextvergleichs ist ziemlich offensichtlich.  Um die isEqual-Funktion nicht f√ºr Typen zu schreiben, die Equatable bereits implementieren, k√∂nnen Sie einen einfachen Trick ausf√ºhren, diesmal mit den Vorteilen von Swift: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerContextInfo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Self</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Equatable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEqual</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to info: ViewControllerContextInfo?)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> info = info <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">Self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> == info } }</code> </pre> <br>  Toll, wir haben ein Objekt zum Vergleichen.  Aber wie kann man es einem <i>UIViewController zuordnen</i> ?  Eine M√∂glichkeit besteht darin, <a href="https://developer.apple.com/documentation/objectivec/1418509-objc_setassociatedobject%3Flanguage%3Dobjc">verkn√ºpfte Objekte zu verwenden</a> , die in einigen F√§llen eine n√ºtzliche Funktion der Sprache Objective C. Zum einen ist sie jedoch nicht sehr explizit, und zum anderen m√∂chten wir in der Regel nur den Kontext einiger Anwendungsbildschirme vergleichen.  Daher sieht das Erstellen eines Protokolls gut aus: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerContextHolder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentContext: <span class="hljs-type"><span class="hljs-type">ViewControllerContext?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } }</code> </pre> <br><br>  und seine Implementierung nur in den erforderlichen Bildschirmen.  Wenn der aktive Bildschirm dieses Protokoll nicht implementiert, kann sein Inhalt als unbedeutend betrachtet und bei der Anzeige eines neuen Protokolls nicht ber√ºcksichtigt werden. <br><br><h3>  3. Ausf√ºhrung des √úbergangs </h3><br>  Mal sehen, was wir schon haben.  Die M√∂glichkeit, jederzeit Informationen √ºber den aktiven Bildschirm in Form einer bestimmten Datenstruktur abzurufen.  Informationen, die extern √ºber eine offene URL, eine Push-Benachrichtigung oder eine andere Methode zum Starten der Navigation empfangen werden, k√∂nnen in eine Struktur desselben Typs konvertiert werden und als Navigationsabsicht dienen.  Wenn auf dem oberen Bildschirm bereits die erforderlichen Informationen angezeigt werden, k√∂nnen Sie die Navigation einfach ignorieren oder den Bildschirminhalt aktualisieren. <br><br><img src="https://habrastorage.org/webt/wl/wq/lx/wlwqlxy8knlnfjgy6sg-gmnycm4.png"><br><br>  Aber was ist mit dem √úbergang selbst? <br><br>  Es ist logisch, eine Komponente (nennen wir sie einen <b>Router</b> ) zu erstellen, die die anzuzeigenden Elemente aufnimmt, mit den bereits angezeigten Elementen vergleicht und einen √úbergang oder eine Abfolge von √úberg√§ngen ausf√ºhrt.  Der Router kann auch allgemeine Logik zum Verarbeiten und Validieren von Informationen und des Anwendungsstatus enthalten.  Hauptsache, Sie sollten keine dom√§nen- oder anwendungsspezifische Logik in diese Komponente aufnehmen.  Wenn Sie diese Regel einhalten, kann sie f√ºr verschiedene Anwendungen wiederverwendet und einfach gewartet werden. <br><br>  Die grundlegende Schnittstellendeklaration eines solchen Protokolls sieht folgenderma√üen aus: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerContextRouterProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">navigateToContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> context: ViewControllerContext, animated: Bool)</span></span></span></span> }</code> </pre> <br>  Sie k√∂nnen die obige Funktion verallgemeinern, indem Sie eine Folge von Kontexten √ºbergeben.  Dies wird keine wesentlichen Auswirkungen auf die Implementierung haben. <br><br>  Es ist ziemlich offensichtlich, dass der Router eine Controller-Fabrik ben√∂tigt, da nur Navigationsdaten an seinem Eingang empfangen werden.  Es ist notwendig, innerhalb der Fabrik separate Bildschirme und m√∂glicherweise sogar ganze Module zu erstellen, die auf dem √ºbertragenen Kontext basieren.  √úber das Feld <i>screenType</i> k√∂nnen <i>Sie</i> im <i>Infofeld</i> festlegen, welches Bild Sie erstellen m√∂chten - mit welchen Daten Sie es vorab f√ºllen m√ºssen: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllersByContextFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> context: ViewControllerContext)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIViewController?</span></span> }</code> </pre> <br>  Wenn es sich bei der Anwendung nicht um einen Snapchat-Klon handelt, ist die Anzahl der zum Anzeigen des neuen Controllers verwendeten Methoden h√∂chstwahrscheinlich gering.  Daher ist f√ºr die meisten Anwendungen die Aktualisierung des <i>UINavigationController-</i> Stacks und die Anzeige eines modalen Bildschirms ausreichend.  In diesem Fall k√∂nnen Sie eine Aufz√§hlung mit m√∂glichen Typen definieren, zum Beispiel: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NavigationType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> modal <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> navigationStack <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> rootScreen }</code> </pre> <br>  Die Art des Bildschirms h√§ngt davon ab, wie er angezeigt wird.  Wenn dies eine Sperrbenachrichtigung ist, muss sie modal angezeigt werden.  M√∂glicherweise muss √ºber den <i>UINavigationController</i> ein weiterer Bildschirm zu einem vorhandenen Navigationsstapel <i>hinzugef√ºgt werden</i> . <br><br>  Es ist besser, nicht im Router selbst zu entscheiden, wie ein bestimmter Bildschirm angezeigt werden soll.  Wenn wir eine Router-Abh√§ngigkeit unter dem <i>ViewControllerNavigationTypeProvider-</i> Protokoll <i>hinzuf√ºgen</i> und die gew√ºnschten anwendungsspezifischen Methoden implementieren, erreichen wir dieses Ziel: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerNavigationTypeProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">navigationType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> context: ViewControllerContext)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">NavigationType</span></span> }</code> </pre> <br>  Was aber, wenn wir in einer der Anwendungen eine neue Art der Navigation einf√ºhren wollen?  M√ºssen Sie eine neue Option zu enum hinzuf√ºgen, und alle anderen Anwendungen wissen davon?  M√∂glicherweise ist dies in einigen F√§llen genau das, wonach wir streben. Wenn Sie sich jedoch an das <a href="https://en.wikipedia.org/wiki/Open%25E2%2580%2593closed_principle">Open-Closed-Prinzip halten</a> , k√∂nnen Sie zur Erh√∂hung der Flexibilit√§t das Protokoll eines Objekts eingeben, das √úberg√§nge ausf√ºhren kann: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerContextTransition</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">navigate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(from source: UIViewController?, to destination: UIViewController, animated: Bool)</span></span></span></span> }</code> </pre> <br>  Dann wird <i>ViewControllerNavigationTypeProvider folgenderma√üen aussehen</i> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerContextTransitionProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> context: ViewControllerContext)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ViewControllerContextTransition</span></span> }</code> </pre> <br>  Jetzt sind wir nicht mehr auf einen festen Satz von Bildschirmanzeigetypen beschr√§nkt, sondern k√∂nnen die Navigationsfunktionen erweitern, ohne √Ñnderungen am Router selbst vorzunehmen. <br><br>  Manchmal m√ºssen Sie keinen neuen <i>UIViewController</i> erstellen, um zu einem <i>Bildschirm</i> zu wechseln - wechseln Sie einfach zu einem vorhandenen.  Das offensichtlichste Beispiel ist das Wechseln der Registerkarten in einem <i>UITabBarController</i> .  Ein weiteres Beispiel ist der √úbergang zu einem vorhandenen Element im angezeigten Controller-Stapel, anstatt einen neuen Bildschirm mit demselben Inhalt zu erstellen.  Dazu k√∂nnen Sie im Router vor dem Anlegen eines neuen <i>UIViewControllers</i> zun√§chst pr√ºfen, ob der Kontext einfach umgeschaltet werden kann. <br><br>  Wie kann man dieses Problem l√∂sen?  Mehr Abstraktionen! <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerContextSwitcher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canSwitch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to context: ViewControllerContext)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">switchContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to context: ViewControllerContext, animated: Bool)</span></span></span></span> }</code> </pre> <br>  Bei Registerkarten kann dieses Protokoll von einer Komponente implementiert werden, die wei√ü, was im <i>UITabBarViewController enthalten ist,</i> und kann <i>ViewControllerContext</i> einer bestimmten Registerkarte <i>zuordnen</i> und Registerkarten wechseln. <br><br><img src="https://habrastorage.org/webt/r_/do/yv/r_doyvigb9gfjp-i8afhu-btglk.gif" width="300"><br><br>  Eine Reihe solcher Objekte kann als Abh√§ngigkeit an den Router √ºbergeben werden. <br><br>  Zusammenfassend sieht der Kontextverarbeitungsalgorithmus folgenderma√üen aus: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">navigateToContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> context: ViewControllerContext, animated: Bool)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> topViewController = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.topViewControllerProvider.topViewController <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contextHolder = topViewController <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">ViewControllerContextHolder</span></span>, contextHolder.currentContext == context { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> switcher = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.contextSwitchers.first(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: { $<span class="hljs-number"><span class="hljs-number">0</span></span>.canSwitch(to: context) }) { switcher.switchContext(to: context, animated: animated) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> viewController = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.viewControllersFactory.viewController(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: context) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> navigation = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.transitionProvider.navigation(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: context) navigation.navigate(from: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.topViewControllerProvider.topViewController, to: viewController, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) }</code> </pre> <br><br>  Es ist praktisch, das Router-Abh√§ngigkeitsdiagramm in Form eines UML-Diagramms darzustellen: <br><br><img src="https://habrastorage.org/webt/jt/ic/gk/jticgkvmsmm5own334ql_uvq6mg.png"><br><br>  Der resultierende Router kann f√ºr √úberg√§nge verwendet werden, die automatisch oder durch Benutzeraktionen initiiert werden.  Wenn in unseren Produkten die Navigation nicht automatisch erfolgt, werden Standardsystemfunktionen verwendet und die meisten Module kennen die Existenz eines globalen Routers nicht.  Es ist nur wichtig, sich an die Implementierung des <i>ViewControllerContextHolder-</i> Protokolls zu erinnern, wenn dies erforderlich ist, damit der Router immer die Informationen herausfinden kann, die der Benutzer zum aktuellen Zeitpunkt sieht. <br><br><h2>  Vor- und Nachteile </h2><br>  Vor kurzem haben wir damit begonnen, die beschriebene Navigationsverwaltungsmethode in Badoo-Produkten einzuf√ºhren.  Obwohl sich herausstellte, dass die Implementierung etwas komplizierter war als die im <a href="https://github.com/azatZul/NavigationDemo">Demo-Projekt</a> vorgestellte Option, sind wir mit den Ergebnissen zufrieden.  Lassen Sie uns die Vor- und Nachteile des beschriebenen Ansatzes bewerten. <br><br>  Zu den Vorteilen geh√∂ren: <br><br><ul><li>  Universalit√§t </li><li>  Relativ einfache Implementierung im Vergleich zu den Optionen im Abschnitt "Alternativen". </li><li>  Mangel an Einschr√§nkungen f√ºr die Architektur der Anwendung und die Implementierung der konventionellen Navigation zwischen Bildschirmen. </li></ul><br>  Die Nachteile sind teilweise eine Folge der Vorteile. <br><br><ul><li>  Controller m√ºssen wissen, welche Informationen sie anzeigen.  Wenn wir die Architektur der Anwendung ber√ºcksichtigen, sollte der UIViewController der Anzeigeebene zugewiesen werden und die Gesch√§ftslogik sollte nicht in dieser Ebene gespeichert werden.  Die Datenstruktur, die den Navigationskontext enth√§lt, muss dort aus der Gesch√§ftslogikebene implementiert werden, die Controller speichern jedoch diese Informationen, was nicht sehr korrekt ist. </li><li>  Die Quelle der Wahrheit √ºber den Status der Anwendung ist die Hierarchie der angezeigten Bildschirme, die in einigen F√§llen eine Einschr√§nkung darstellen kann. </li></ul><br><br><h2>  Alternativen </h2><br>  Eine Alternative zu diesem Ansatz k√∂nnte darin bestehen, manuell eine Hierarchie der aktiven Module zu erstellen.  Ein Beispiel f√ºr eine solche L√∂sung ist die <a href="https://github.com/AndreyPanov/ApplicationCoordinator">Implementierung des</a> Koordinatormusters, bei dem die Koordinatoren eine Baumstruktur bilden, die als Wahrheitsquelle f√ºr die Bestimmung des aktiven Bildschirms dient, und die Logik der Entscheidung, diesen oder jenen Bildschirm anzuzeigen oder nicht, in den Koordinatoren selbst enthalten ist. <br><br>  √Ñhnliche Ideen finden Sie in der <a href="https://github.com/uber/RIBs">RIBs-</a> Architektur, die <a href="https://badootech.badoo.com/the-immense-benefits-of-not-thinking-in-screens-6c311e3344a0">von</a> unserem Android-Team verwendet wird. <br><br>  Solche Alternativen bieten eine flexiblere Abstraktion, erfordern jedoch eine einheitliche Architektur und k√∂nnen f√ºr viele Anwendungen zu umst√§ndlich sein. <br><br>  Wenn Sie einen anderen L√∂sungsansatz gew√§hlt haben, z√∂gern Sie nicht, in den Kommentaren dar√ºber zu sprechen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de483830/">https://habr.com/ru/post/de483830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de483820/index.html">Was beeinflusst die Kreditvergabe? Home Credit Default Risk Wettbewerbs√ºbersicht</a></li>
<li><a href="../de483822/index.html">5 JavaScript-Funktionen, ohne die ich keinen Code schreiben k√∂nnte</a></li>
<li><a href="../de483824/index.html">Wie Sie die Arbeit Ihrer Tr√§ume erreichen, positiv denken und vorankommen, nachdem Sie meine f√ºnf Regeln studiert haben ...</a></li>
<li><a href="../de483826/index.html">Anschlie√üen eines CO2-Sensors Modell MH-Z19B √ºber den analogen Vo-Ausgang</a></li>
<li><a href="../de483828/index.html">Glanz und Armut Atomtausch</a></li>
<li><a href="../de483832/index.html">RxJava nach Coroutines: End-to-End-Feature-Migration</a></li>
<li><a href="../de483834/index.html">Debian: einfach i386 in amd64 verwandeln</a></li>
<li><a href="../de483842/index.html">Die Entstehungsgeschichte einer Home Cloud. Teil 5. Aktualisierung 2019 - PHP 7.2, MariaDB 10.4 und Nextcloud 17</a></li>
<li><a href="../de483844/index.html">Analyse von Regulierungsdokumenten zum Informationsschutz im russischen Kredit- und Finanzsektor</a></li>
<li><a href="../de483846/index.html">Alternative Fensterverwaltung unter Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>