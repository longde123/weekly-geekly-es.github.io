<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§úüèø üë©üèæ‚Äç‚úàÔ∏è üí™üèº Mein Ansatz zur Implementierung von Delegaten in C ++: Aufruf einer Funktion mit unbekannten Parametern zur Laufzeit üÜò ‚ô®Ô∏è üêπ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hintergrund 
 Ich mag die C ++ Sprache. Ich w√ºrde sogar sagen, dass dies meine Lieblingssprache ist. Dar√ºber hinaus verwende ich f√ºr meine Entwicklung...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mein Ansatz zur Implementierung von Delegaten in C ++: Aufruf einer Funktion mit unbekannten Parametern zur Laufzeit</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457160/"><h2>  Hintergrund </h2><br>  Ich mag die C ++ Sprache.  Ich w√ºrde sogar sagen, dass dies meine Lieblingssprache ist.  Dar√ºber hinaus verwende ich f√ºr meine Entwicklung .NET-Technologien, und viele der darin enthaltenen Ideen sind meiner Meinung nach einfach erstaunlich.  Nachdem ich auf die Idee gekommen war, wie man Reflexionsmittel und dynamische Funktionsaufrufe in C ++ implementiert.  Ich wollte wirklich, dass C ++ einen solchen CLI-Vorteil hat, wie das Aufrufen eines Delegaten mit einer unbekannten Anzahl von Parametern und deren Typen.  Dies kann beispielsweise n√ºtzlich sein, wenn nicht im Voraus bekannt ist, welche Datentypen die Funktion aufgerufen werden muss. <br><br>  Nat√ºrlich ist eine vollst√§ndige Nachahmung der Delegierten zu kompliziert, daher zeigt dieser Artikel nur die allgemeine Architektur der Bibliothek und die L√∂sung einiger wichtiger Probleme, die auftreten, wenn es um etwas geht, das nicht direkt von der Sprache unterst√ºtzt wird. <br><a name="habracut"></a><br><h2>  Aufrufen von Funktionen mit einer unbestimmten Anzahl von Parametern und unbekannten Typen w√§hrend der Kompilierung </h2><br>  Dies ist nat√ºrlich das Hauptproblem bei C ++, das nicht so einfach zu l√∂sen ist.  Nat√ºrlich gibt es in C ++ ein Tool, das von C - <i>varargs geerbt wurde</i> , und h√∂chstwahrscheinlich ist dies das erste, was mir in den Sinn kommt ... Sie passen jedoch erstens aufgrund ihrer typunsicheren Natur (wie viele Dinge von C) nicht. Zweitens m√ºssen Sie bei der Verwendung solcher Argumente im Voraus wissen, um welche Arten von Argumenten es sich handelt.  Mit ziemlicher Sicherheit sind dies jedoch nicht alle Probleme mit <i>Varargs</i> .  Im Allgemeinen ist dieses Tool hier kein Assistent. <br><br>  Und jetzt werde ich die Tools auflisten, die mir bei der L√∂sung dieses Problems geholfen haben. <br><br><h3>  std :: any </h3><br>  Ab C ++ 17 hat die Sprache einen wunderbaren Container-Container f√ºr alles - eine entfernte √Ñhnlichkeit mit <i>System.Object</i> in der CLI ist <i>std :: any</i> .  Dieser Beh√§lter kann wirklich alles aufbewahren und sogar wie: effizient!  - Der Standard empfiehlt, dass Sie kleine Objekte direkt darin speichern. Gro√üe Objekte k√∂nnen bereits im dynamischen Speicher gespeichert werden (obwohl dieses Verhalten nicht obligatorisch ist, hat Microsoft dies in seiner C ++ - Implementierung getan, was eine gute Nachricht ist).  Und nur es kann als √Ñhnlichkeit bezeichnet werden, da System.Object an der Vererbungsbeziehung beteiligt ist ("is a") und std :: any an der Zugeh√∂rigkeitsbeziehung beteiligt ist ("has a").  Zus√§tzlich zu den Daten enth√§lt der Container einen Zeiger auf ein Objekt <i>std :: type_info</i> - RTTI √ºber den Typ, dessen Objekt im Container "liegt". <br><br>  Dem Container wird eine ganze Header-Datei <b>&lt;any&gt;</b> zugewiesen. <br><br>  Um ein Objekt aus dem Container zu ziehen, m√ºssen Sie die Vorlagenfunktion <i>std :: any_cast ()</i> verwenden, die einen Verweis auf das Objekt zur√ºckgibt. <br>  Anwendungsbeispiel: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;any&gt; void any_test() { std::any obj = 5; int from_any = std::any_cast&lt;int&gt;(obj); }</span></span></span></span></code> </pre> <br>  Wenn der angeforderte Typ nicht mit dem √ºbereinstimmt, was das Objekt im Container hat, wird eine Ausnahme <i>std :: bad_any_cast ausgel√∂st</i> . <br><br>  Zus√§tzlich zu den <i>Klassen</i> <i>std :: any</i> , <i>std :: bad_any_cast</i> und <i>std :: any_cast</i> gibt es in der Header-Datei eine Vorlagenfunktion <i>std :: make_any</i> , die <i>std :: make_shared</i> , <i>std :: make_pair</i> und anderen Funktionen dieser Art <i>√§hnelt</i> . <br><br><h3>  RTTI </h3><br>  Nat√ºrlich w√§re es in C ++ praktisch unrealistisch, einen dynamischen Funktionsaufruf ohne Typinformationen zur Laufzeit zu implementieren.  Schlie√ülich muss irgendwie √ºberpr√ºft werden, ob die richtigen Typen √ºbergeben werden oder nicht. <br><br>  Die primitive RTTI-Unterst√ºtzung in C ++ gibt es schon seit geraumer Zeit.  Das ist nur der Punkt, der primitiv ist - wir k√∂nnen wenig √ºber einen Typ lernen, es sei denn, dekorierte und nicht dekorierte Namen.  Au√üerdem k√∂nnen wir Typen miteinander vergleichen. <br><br>  Typischerweise wird der Begriff "RTTI" in Verbindung mit polymorphen Typen verwendet.  Hier werden wir diesen Begriff jedoch im weiteren Sinne verwenden.  Zum Beispiel werden wir die Tatsache ber√ºcksichtigen, dass jeder Typ zur Laufzeit Informationen √ºber den Typ enth√§lt (obwohl Sie diese im Gegensatz zu polymorphen Typen nur zur Kompilierungszeit statisch abrufen k√∂nnen).  Daher ist es m√∂glich (und notwendig), zur Laufzeit Typen auch nicht polymorpher Typen zu vergleichen (Entschuldigung f√ºr die Tautologie). <br>  Auf RTTI kann mit der <i>Klasse std :: type_info</i> zugegriffen werden.  Diese Klasse befindet sich in der Header-Datei <b>&lt;typeinfo&gt;</b> .  Ein Verweis auf ein Objekt dieser Klasse kann (zumindest <i>vorerst</i> ) nur mit dem Operator <i>typeid () abgerufen</i> werden. <br><br><h3>  Muster </h3><br>  Ein weiteres √§u√üerst wichtiges Merkmal der Sprache, das wir zur Verwirklichung unserer Ideen ben√∂tigen, sind Vorlagen.  Dieses Tool ist sehr leistungsf√§hig und √§u√üerst schwierig. Tats√§chlich k√∂nnen Sie beim Kompilieren Code generieren. <br><br>  Vorlagen sind ein sehr breites Thema, und es wird nicht m√∂glich sein, sie im Rahmen des Artikels zu ver√∂ffentlichen, und es ist nicht erforderlich.  Wir gehen davon aus, dass der Leser versteht, worum es geht.  Dabei werden einige dunkle Punkte aufgedeckt. <br><br><h3>  Argumentumbruch gefolgt von einem Aufruf </h3><br>  Wir haben also eine bestimmte Funktion, die mehrere Parameter als Eingabe verwendet. <br><br>  Ich zeige Ihnen eine Codeskizze, die meine Absichten erkl√§rt. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Variadic_args_binder.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;any&gt; int f(int a, std::string s) { std::cout &lt;&lt; "int: " &lt;&lt; a &lt;&lt; "\nstring: " &lt;&lt; s &lt;&lt; std::endl; return 1; } void demo() { std::vector&lt;std::any&gt; params; params.push_back(5); params.push_back(std::string{ "Hello, Delegates!" }); delegates::Variadic_args_binder&lt;int(*)(int, std::string), int, std::string&gt; binder{ f, params }; binder(); }</span></span></span></span></code> </pre> <br>  Sie fragen sich vielleicht, wie ist das m√∂glich?  Der Klassenname <i>Variadic_args_binder</i> gibt an, dass das Objekt die Funktion und die Argumente bindet, die Sie beim Aufrufen an das Objekt √ºbergeben m√ºssen.  Es bleibt also nur, diesen Binder als Funktion ohne Parameter aufzurufen! <br>  So sieht es drau√üen aus. <br><br>  Wenn Sie sofort ohne nachzudenken davon ausgehen, wie dies implementiert werden kann, kann es in den Sinn kommen, mehrere <i>Variadic_args_binder-</i> Spezialisierungen f√ºr eine andere Anzahl von Parametern zu schreiben.  Dies ist jedoch nicht m√∂glich, wenn eine unbegrenzte Anzahl von Parametern unterst√ºtzt werden muss.  Und hier ist das Problem: Die Argumente m√ºssen leider statisch in den Funktionsaufruf eingesetzt werden, dh letztendlich sollte f√ºr den Compiler der Aufrufcode darauf reduziert werden: <br><br><pre> <code class="cpp hljs">fun_ptr(param1, param2, ‚Ä¶, paramN);</code> </pre> <br>  So funktioniert C ++.  Und das alles erschwert das sehr. <br><br>  Nur Template Magic kann damit umgehen! <br><br>  Die Hauptidee besteht darin, rekursive Typen zu erstellen, die auf jeder Verschachtelungsebene eines der Argumente oder eine Funktion speichern. <br><br>  <i>Deklarieren Sie also die</i> Klasse <i>_Tagged_args_binder</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> delegates::impl { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tagged_args_binder</span></span></span><span class="hljs-class">;</span></span> }</code> </pre> <br>  Um Pakete vom Typ "bequem" zu "√ºbertragen", erstellen wir einen <i>Hilfstyp</i> , <i>Type_pack_tag</i> (warum dies ben√∂tigt wurde, wird bald klar): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Type_pack_tag</span></span></span><span class="hljs-class"> {</span></span> };</code> </pre> <br>  Jetzt erstellen wir Spezialisierungen der Klasse <i>_Tagged_args_binder</i> . <br><br><h4>  Erste Spezialisierungen </h4><br>  Wie Sie wissen, m√ºssen Grenzf√§lle definiert werden, damit die Rekursion nicht unendlich ist. <br>  Die folgenden Spezialisierungen sind initial.  Der Einfachheit halber werde ich Spezialisierungen nur f√ºr Nichtreferenztypen und rWert-Referenztypen zitieren. <br>  Spezialisierung f√ºr direkte Parameterwerte: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types_to_construct&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tagged_args_binder</span></span></span><span class="hljs-class">&lt;Func_type, Type_pack_tag&lt;T1, Types_to_construct...&gt;, Type_pack_tag&lt;&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same_v&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>, T1&gt;, <span class="hljs-string"><span class="hljs-string">"Void argument is not allowed"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Ret_type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">invoke_result_t</span></span>&lt;Func_type, T1, Types_to_construct...&gt;; _Tagged_args_binder(Func_type func, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::any&gt;&amp; args) : ap_arg{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(unihold::reference_any_cast&lt;T1&gt;(args.at(<span class="hljs-number"><span class="hljs-number">0</span></span>))) }, ap_caller_part{ func, args } { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_same_v&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Ret_type&gt;)</span></span></span><span class="hljs-function"> </span></span>{ ap_caller_part(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ap_arg)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Ret_type&gt;(ap_caller_part(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ap_arg))); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_same_v&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Ret_type&gt;)</span></span></span><span class="hljs-function"> </span></span>{ ap_caller_part(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ap_arg)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Ret_type&gt;(ap_caller_part(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ap_arg))); } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: _Tagged_args_binder&lt;Func_type, Type_pack_tag&lt;Types_to_construct...&gt;, Type_pack_tag&lt;T1&gt;&gt; ap_caller_part; T1 ap_arg; };</code> </pre> <br>  Das erste Argument f√ºr den Aufruf von <i>ap_arg</i> und der Rest des rekursiven Objekts <i>ap_caller_part</i> werden <i>hier gespeichert</i> .  Beachten Sie, dass der <i>T1-</i> Typ vom ersten Typpaket in diesem Objekt zum zweiten im "Ende" des rekursiven Objekts "verschoben" wurde. <br><br>  Spezialisierung f√ºr rvalue Links: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types_to_construct&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tagged_args_binder</span></span></span><span class="hljs-class">&lt;Func_type, Type_pack_tag&lt;T1&amp;&amp;, Types_to_construct...&gt;, Type_pack_tag&lt;&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> move_ref_T1 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">add_rvalue_reference_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">remove_reference_t</span></span>&lt;T1&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Ret_type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">invoke_result_t</span></span>&lt;Func_type, move_ref_T1, Types_to_construct&gt;; _Tagged_args_binder(Func_type func, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::any&gt;&amp; args) : ap_arg{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(unihold::reference_any_cast&lt;T1&gt;(args.at(<span class="hljs-number"><span class="hljs-number">0</span></span>))) }, ap_caller_part{ func, args } { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_same_v&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Ret_type&gt;)</span></span></span><span class="hljs-function"> </span></span>{ ap_caller_part(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(unihold::reference_any_cast&lt;T1&gt;(ap_arg))); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Ret_type&gt;(ap_caller_part(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(unihold::reference_any_cast&lt;T1&gt;(ap_arg)))); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_same_v&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Ret_type&gt;)</span></span></span><span class="hljs-function"> </span></span>{ ap_caller_part(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(unihold::reference_any_cast&lt;T1&gt;(ap_arg))); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Ret_type&gt;(ap_caller_part(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(unihold::reference_any_cast&lt;T1&gt;(ap_arg)))); } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: _Tagged_args_binder&lt;Func_type, Type_pack_tag&lt;Types_to_construct...&gt;, Type_pack_tag&lt;move_ref_T1&gt;&gt; ap_caller_part; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::any ap_arg; };</code> </pre> <br><br>  Vorlagen "rechtsh√§ndige" Links sind keine wirklich rechtsh√§ndigen Bedeutungen.  Dies sind die sogenannten "Universal Links", die je nach Typ von <i>T1</i> entweder zu <i>T1 &amp;</i> oder zu <i>T1 &amp;&amp; werden</i> .  Daher m√ºssen Sie Problemumgehungen verwenden: Erstens wird beim Instanziieren der Vorlage die erforderliche Spezialisierung ausgew√§hlt, auch wenn es sich um einen rechtsh√§ndigen Link handelt, da Spezialisierungen f√ºr beide Arten von Links definiert sind (dies wird aus den bereits genannten Gr√ºnden nicht ganz richtig gesagt) und f√ºr Nichtreferenzparameter, wenn Sie die Vorlage instanziieren.  Zweitens wird zum √úbertragen des <i>T1-</i> Typs von Paket zu Paket die korrigierte Version von <i>move_ref_T1 verwendet</i> , die in einen echten rvalue-Link umgewandelt wird. <br><br>  Die Spezialisierung mit einem normalen Link erfolgt auf die gleiche Weise mit den erforderlichen Korrekturen. <br><br><h4>  Ultimative Spezialisierung </h4><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Param_type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tagged_args_binder</span></span></span><span class="hljs-class">&lt;Func_type, Type_pack_tag&lt;&gt;, Type_pack_tag&lt;Param_type...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Ret_type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">invoke_result_t</span></span>&lt;Func_type, Param_type...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> _Tagged_args_binder(Func_type func, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::any&gt;&amp; args) : ap_func{ func } { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Param_type... param)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_same_v&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">decltype</span></span></span></span><span class="hljs-function"><span class="hljs-params">(ap_func(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::forward&lt;Param_type&gt;(param)...))&gt;)</span></span></span><span class="hljs-function"> </span></span>{ ap_func(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Param_type&gt;(param)...); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Ret_type&gt;(ap_func(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Param_type&gt;(param)...)); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Param_type... param)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_same_v&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Ret_type&gt;)</span></span></span><span class="hljs-function"> </span></span>{ ap_func(param...); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Ret_type&gt;(ap_func(param...)); } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Func_type ap_func; };</code> </pre> <br>  Diese Spezialisierung ist f√ºr die Speicherung eines Funktionsobjekts verantwortlich und ist in der Tat ein Wrapper dar√ºber.  Es ist der letzte rekursive Typ. <br><br>  Beachten Sie, wie <i>Type_pack_tag hier</i> verwendet wird.  Alle Parametertypen werden jetzt im linken Paket kompiliert.  Dies bedeutet, dass sie alle verarbeitet und verpackt werden. <br><br>  Jetzt, denke ich, wird klar, warum es notwendig war, <i>Type_pack_tag</i> zu verwenden.  Tatsache ist, dass die Sprache die Verwendung von zwei Arten von Paketen nebeneinander nicht zul√§sst, zum Beispiel wie folgt: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types_to_construct, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Param_type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tagged_args_binder</span></span></span><span class="hljs-class">&lt;Func_type, T1, Types_to_construct..., Param_type...&gt; {</span></span> };</code> </pre> <br>  Daher m√ºssen Sie sie in zwei separate Pakete innerhalb von zwei Typen aufteilen.  Au√üerdem m√ºssen Sie die verarbeiteten Typen irgendwie von denen trennen, die noch nicht verarbeitet wurden. <br><br><h4>  Fortgeschrittene Spezialisierungen </h4><br>  Von Zwischenspezialisierungen werde ich schlie√ülich noch einmal eine Spezialisierung f√ºr Werttypen geben, der Rest ist analog: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types_to_construct, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Param_type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tagged_args_binder</span></span></span><span class="hljs-class">&lt;Func_type, Type_pack_tag&lt;T1, Types_to_construct...&gt;, Type_pack_tag&lt;Param_type...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Ret_type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">invoke_result_t</span></span>&lt;Func_type, Param_type..., T1, Types_to_construct...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same_v&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>, T1&gt;, <span class="hljs-string"><span class="hljs-string">"Void argument is not allowed"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> _Tagged_args_binder(Func_type func, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::any&gt;&amp; args) : ap_arg{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(unihold::reference_any_cast&lt;T1&gt;(args.at(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>...(Param_type)))) }, ap_caller_part{ func, args } { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Param_type... param)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_same_v&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Ret_type&gt;)</span></span></span><span class="hljs-function"> </span></span>{ ap_caller_part(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Param_type&gt;(param)..., <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ap_arg)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Ret_type&gt;(ap_caller_part(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Param_type&gt;(param)..., <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ap_arg))); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Param_type... param)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_same_v&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Ret_type&gt;)</span></span></span><span class="hljs-function"> </span></span>{ ap_caller_part(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Param_type&gt;(param)..., <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ap_arg)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Ret_type&gt;(ap_caller_part(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Param_type&gt;(param)..., <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ap_arg))); } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: _Tagged_args_binder&lt;Func_type, Type_pack_tag&lt;Types_to_construct...&gt;, Type_pack_tag&lt;Param_type..., T1&gt;&gt; ap_caller_part; T1 ap_arg; };</code> </pre> <br>  Diese Spezialisierung soll alle Argumente au√üer dem ersten packen. <br><br><h4>  Binder Klasse </h4><br>  Die Klasse <i>_Tagged_args_binder ist</i> nicht f√ºr die direkte Verwendung vorgesehen, was ich am Anfang ihres Namens mit einem einzigen Unterstrich hervorheben wollte.  Daher werde ich den Code einer kleinen Klasse angeben, die eine Art ‚ÄûSchnittstelle‚Äú zu diesem h√§sslichen und unbequemen Typ darstellt (der jedoch meiner Meinung nach eher ungew√∂hnliche C ++ - Tricks verwendet, die ihm einen gewissen Charme verleihen): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> cutecpplib::delegates { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Functor_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Param_type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Variadic_args_binder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> binder_type = impl::_Tagged_args_binder&lt;Functor_type, Type_pack_tag&lt;Param_type...&gt;, Type_pack_tag&lt;&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Ret_type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">invoke_result_t</span></span>&lt;binder_type&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Variadic_args_binder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Functor_type function, Param_type... param)</span></span></span><span class="hljs-function"> : ap_tagged_binder</span></span>{ function, param... } { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Variadic_args_binder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Functor_type function, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::any&gt;&amp; args)</span></span></span><span class="hljs-function"> : ap_tagged_binder</span></span>{ function, args } { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ap_tagged_binder(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ap_tagged_binder(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: binder_type ap_tagged_binder; }; }</code> </pre><br><h4>  Unihold-Konvention - Weitergabe von Links innerhalb von <i>std :: any</i> </h4><br>  Ein aufmerksamer Leser muss bemerkt haben, dass der Code die Funktion <i>unihold :: reference_any_cast ()</i> verwendet.  Diese Funktion sowie ihr analoges <i>unihold :: pointer_any_cast () dienen</i> zur Implementierung der Bibliotheksvereinbarung: Die Argumente, die als Referenz √ºbergeben werden m√ºssen, werden per Zeiger an <i>std :: any √ºbergeben</i> . <br><br>  Die Funktion <i>reference_any_cast gibt</i> immer einen Verweis auf ein Objekt zur√ºck, unabh√§ngig davon, ob das Objekt selbst im Container gespeichert ist oder nur einen Zeiger darauf.  Wenn <i>std :: any</i> ein Objekt enth√§lt, wird im Container ein Verweis auf dieses Objekt zur√ºckgegeben.  Wenn es einen Zeiger enth√§lt, wird eine Referenz auf das Objekt zur√ºckgegeben, auf das der Zeiger zeigt. <br><br>  F√ºr jede Funktion gibt es Optionen f√ºr die Konstante <i>std :: any</i> und √ºberladene Versionen, um zu bestimmen, ob der Container <i>std :: any</i> ein Objekt besitzt oder nur einen Zeiger enth√§lt. <br><br>  Funktionen m√ºssen explizit auf den Typ des gespeicherten Objekts spezialisiert sein, genau wie C ++ - Typkonvertierungen und √§hnliche Vorlagenfunktionen. <br><br>  Der Code f√ºr diese Funktionen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">remove_reference_t</span></span>&lt;T&gt;&amp; unihold::reference_any_cast(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::any&amp; wrapper) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reference_any_cast&lt;T&gt;(wrapper, result); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">remove_reference_t</span></span>&lt;T&gt;&amp; unihold::reference_any_cast(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::any&amp; wrapper) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reference_any_cast&lt;T&gt;(wrapper, result); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">remove_reference_t</span></span>&lt;T&gt;&amp; unihold::reference_any_cast(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::any&amp; wrapper, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&amp; is_owner) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ptr = pointer_any_cast&lt;T&gt;(&amp;wrapper, is_owner); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ptr) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bad_any_cast{ }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *ptr; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">remove_reference_t</span></span>&lt;T&gt;&amp; unihold::reference_any_cast(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::any&amp; wrapper, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&amp; is_owner) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ptr = pointer_any_cast&lt;T&gt;(&amp;wrapper, is_owner); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ptr) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bad_any_cast{ }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *ptr; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">remove_reference_t</span></span>&lt;T&gt;* unihold::pointer_any_cast(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::any* wrapper, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&amp; is_owner) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> NR_T = <span class="hljs-keyword"><span class="hljs-keyword">remove_reference_t</span></span>&lt;T&gt;; <span class="hljs-comment"><span class="hljs-comment">// No_reference_T //     wrapper NR_T** double_ptr_to_original = any_cast&lt;NR_T*&gt;(wrapper); //      wrapper NR_T* ptr_to_copy; if (double_ptr_to_original) { // Wrapper      is_owner = false; return *double_ptr_to_original; } else if (ptr_to_copy = any_cast&lt;NR_T&gt;(wrapper)) { // Wrapper    is_owner = true; return ptr_to_copy; } else { throw bad_any_cast{}; } } template &lt;typename T&gt; const std::remove_reference_t&lt;T&gt;* unihold::pointer_any_cast(const std::any* wrapper, bool&amp; is_owner) { using namespace std; using NR_T = remove_reference_t&lt;T&gt;; // No_reference_T //     wrapper NR_T*const * double_ptr_to_original = any_cast&lt;NR_T*&gt;(wrapper); //      wrapper const NR_T* ptr_to_copy; //remove_reference_t&lt;T&gt;* ptr2 = any_cast&lt;remove_reference_t&lt;T&gt;&gt;(&amp;wrapper); if (double_ptr_to_original) { // Wrapper      is_owner = false; return *double_ptr_to_original; } else if (ptr_to_copy = any_cast&lt;NR_T&gt;(wrapper)) { // Wrapper    is_owner = true; return ptr_to_copy; } else { throw bad_any_cast{}; } } template &lt;typename T&gt; std::remove_reference_t&lt;T&gt;* unihold::pointer_any_cast(std::any* wrapper) { bool result; return pointer_any_cast&lt;T&gt;(wrapper, result); } template &lt;typename T&gt; const std::remove_reference_t&lt;T&gt;* unihold::pointer_any_cast(const std::any* wrapper) { bool result; return pointer_any_cast&lt;T&gt;(wrapper, result); }</span></span></code> </pre><br><h2>  Fazit </h2><br>  Ich habe versucht, einen der m√∂glichen Ans√§tze zur L√∂sung des Problems dynamischer Funktionsaufrufe in C ++ kurz zu beschreiben.  Anschlie√üend bildet dies die Grundlage f√ºr die C ++ - Delegatenbibliothek (tats√§chlich habe ich bereits die Grundfunktionalit√§t der Bibliothek geschrieben, n√§mlich polymorphe Delegaten, aber die Bibliothek muss noch so umgeschrieben werden, wie sie sollte, um den Code zu demonstrieren und einige nicht realisierte Funktionen hinzuzuf√ºgen).  In naher Zukunft plane ich, die Arbeit an der Bibliothek abzuschlie√üen und zu erkl√§ren, wie genau ich den Rest der Delegatenfunktionalit√§t in C ++ implementiert habe. <br><br>  PS Die Verwendung von RTTI wird im n√§chsten Teil demonstriert. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457160/">https://habr.com/ru/post/de457160/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457144/index.html">Wir schreiben einen Emulator, der von niemandem ben√∂tigt wird</a></li>
<li><a href="../de457150/index.html">Neues Windows-Terminal jetzt im Microsoft Store verf√ºgbar</a></li>
<li><a href="../de457152/index.html">DEFCON 25 Konferenz. Garry Kasparov. "Die letzte Schlacht des Gehirns." Teil 1</a></li>
<li><a href="../de457154/index.html">Responsive App-Design f√ºr jeden Benutzer</a></li>
<li><a href="../de457156/index.html">Was k√∂nnen die Computersysteme der Zukunft sein</a></li>
<li><a href="../de457164/index.html">Navigation in einer plattform√ºbergreifenden .NET Core-Anwendung mit Speicherstatus auf der Festplatte am Beispiel von ReactiveUI und Avalonia</a></li>
<li><a href="../de457168/index.html">Prototyp-Stimmungsanalyse mit Python und TextBlob</a></li>
<li><a href="../de457172/index.html">ScreenLogger - L√§cheln, Sie werden von einer versteckten Kamera gefilmt</a></li>
<li><a href="../de457178/index.html">Wie Prozessoren entworfen und hergestellt werden: CPU-Design</a></li>
<li><a href="../de457180/index.html">Die offizielle Seite Node.js ist jetzt in russischer Sprache</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>