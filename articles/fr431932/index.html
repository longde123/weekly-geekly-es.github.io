<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§î ‚è≠Ô∏è ü§¶üèæ Fort Byte Car (et plus) Native American ‚ôèÔ∏è üßû üë®üèø‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Oui, oui, c'est "l'octet" et c'est en indien (pas indien). Je vais commencer dans l'ordre. R√©cemment ici, sur Habr√©, des articles sur le bytecode ont ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fort Byte Car (et plus) Native American</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431932/"><img src="https://habrastorage.org/getpro/habr/post_images/dbb/a59/e93/dbba59e932ecdb4b0c28896a7e6fc3e3.jpg" alt="image"><br><br>  Oui, oui, c'est "l'octet" et c'est en indien (pas indien).  Je vais commencer dans l'ordre.  R√©cemment ici, sur Habr√©, des articles sur le bytecode ont commenc√© √† appara√Ætre.  Et il √©tait une fois, je me suis amus√© √† √©crire des syst√®mes Fort.  Bien s√ªr, en assembleur.  Ils √©taient en 16 bits.  Je n'ai jamais programm√© sur x86-64.  M√™me avec 32 ne pouvait pas jouer.  Alors la pens√©e est venue - pourquoi pas?  Pourquoi ne pas remuer le fort 64 bits, et m√™me avec le bytecode?  Oui, et sous Linux, o√π je n'ai pas non plus √©crit de syst√®me. <br><br>  J'ai un serveur domestique avec Linux.  En g√©n√©ral, j'ai googl√© un peu et d√©couvert que l'assembleur sous Linux s'appelle GAS et la commande as.  Je me connecte via SSH au serveur, en tapant - oui!  Je l'ai d√©j√† install√©.  Vous avez toujours besoin d'un √©diteur de liens, tapez ld - oui!  Alors, et essayez d'√©crire quelque chose d'int√©ressant dans l'assembleur.  Sans civilisation, seulement une for√™t, comme de vrais Indiens :) Sans environnement de d√©veloppement, seulement une ligne de commande et Midnight Commander.  L'√©diteur sera Nano, qui se bloque sur mon F4 en mc.  Comment chante le groupe ¬´Zero¬ª?  Un vrai Indien n'a besoin que d'une chose ... De quoi d'autre un vrai Indien a-t-il besoin?  Bien s√ªr, un d√©bogueur.  Nous tapons gdb - est!  Eh bien, appuyez sur Maj + F4, et c'est parti! <br><a name="habracut"></a><br><h2>  L'architecture </h2><br>  Pour commencer, d√©cidons de l'architecture.  Avec des profondeurs de bits d√©j√† d√©termin√©es, 64 bits.  Dans les impl√©mentations Fort classiques, les segments de donn√©es et de code sont identiques.  Mais nous essaierons de le faire correctement.  Nous aurons seulement le code dans le segment de code, les donn√©es dans le segment de donn√©es.  En cons√©quence, nous obtenons un noyau pour la plate-forme et un code d'octet compl√®tement ind√©pendant de la plate-forme. <br><br>  Essayons de cr√©er la machine √† octets empil√©s la plus rapide (mais sans JIT).  Ainsi, nous aurons une table contenant 256 adresses - une pour chaque commande d'octets.  Moins que tout - une v√©rification suppl√©mentaire, ce sont 1-2 instructions du processeur.  Et nous avons besoin rapidement, sans compromis. <br><br><h4>  Piles </h4><br>  Habituellement, dans les impl√©mentations Fort, la pile de retour du processeur (* SP) est utilis√©e comme une pile de donn√©es et la pile de retours du syst√®me fort est impl√©ment√©e en utilisant d'autres moyens.  En effet, notre machine sera empil√©e, et le travail principal est sur la pile de donn√©es.  Par cons√©quent, faisons de m√™me - RSP sera une pile de donn√©es.  Eh bien, laissez la pile de retour √™tre RBP, qui, par d√©faut, fonctionne √©galement avec le segment de pile.  Ainsi, nous aurons trois segments de m√©moire: un segment de code, un segment de donn√©es et un segment de pile (il aura √† la fois une pile de donn√©es et une pile de retour). <br><br><h4>  Registres </h4><br>  J'entre dans la description des registres x86-64, et oups!  Il y a jusqu'√† 8 registres √† usage g√©n√©ral suppl√©mentaires (R8 - R16), par rapport aux modes 32 ou 16 bits. <br><br>  D√©j√† d√©cid√© qu'ils auront besoin de RSP et de RBP.  Encore besoin d'un pointeur (compteur) des commandes de bytecode.  Des op√©rations sur ce registre, seule la lecture en m√©moire est n√©cessaire.  Les registres principaux (RAX, RBX, RCX, RDX, RSI, RDI) sont plus flexibles, universels, avec eux il y a beaucoup de commandes sp√©ciales.  Ils nous seront utiles pour diverses t√¢ches, et pour le compteur d'instructions bytecode nous prenons l'un des nouveaux registres pour moi, que ce soit R8. <br><br><h2>  Commen√ßons </h2><br>  Je n'ai aucune exp√©rience en programmation sous Linux en langage assembleur.  Par cons√©quent, pour commencer, nous trouverons le "Bonjour tout le monde" pour comprendre comment le programme d√©marre et affiche le texte.  De fa√ßon inattendue pour moi, j'ai trouv√© des options avec une √©trange syntaxe o√π m√™me la source et le r√©cepteur sont r√©organis√©s.  Il s'est av√©r√© que c'est la syntaxe AT&amp;T, et elle est principalement √©crite sous GAS dessus.  Mais une autre option de syntaxe est prise en charge, elle s'appelle la syntaxe Intel.  En r√©fl√©chissant, j'ai d√©cid√© de l'utiliser tout de m√™me.  Eh bien, √©crivez au d√©but de .intel_syntax noprefix. <br><br>  Compilez et ex√©cutez ¬´Hello, world¬ª pour vous assurer que tout fonctionne.  En lisant l'aide et les exp√©riences, j'ai commenc√© √† utiliser la commande suivante pour compiler: <br> <code>$ as fort.asm -o fort.o -g -ahlsm &gt;list.txt</code> <br>  Ici, le commutateur -o indique le fichier de r√©sultats, le commutateur -g indique de g√©n√©rer des informations de d√©bogage et le commutateur -ahlsm d√©finit le format de liste.  Et je garde la sortie dans la liste, vous y voyez beaucoup de choses utiles.  J'avoue qu'au d√©but du travail, je n'ai pas fait la liste et je n'ai m√™me pas sp√©cifi√© le commutateur -g.  J'ai commenc√© √† utiliser le commutateur -g apr√®s la premi√®re utilisation du d√©bogueur et j'ai commenc√© √† faire la liste apr√®s l'apparition des macros dans le code :) <br><br>  Apr√®s cela, nous utilisons l'√©diteur de liens, mais voici rien de plus simple: <br><br> <code>$ ld forth.o -o forth</code> <br>  Eh bien, cours! <br> <code>$ ./forth <br> Hello, world!</code> <br>  √áa marche. <br><br><div class="spoiler">  <b class="spoiler_title">Ce fut le premier quatri√®me.asm (en fait c'est ¬´Hellow, world!¬ª, Bien s√ªr)</b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix .section .data msg: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> len = . - msg #  len    .section .text .global _start #     _start: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, OFFSET FLAT:msg #     mov edx, len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit xor ebx, ebx #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #  </code> </pre> <br>  Soit dit en passant, j'ai d√©couvert plus tard qu'en x86-64, il est plus correct d'utiliser syscall pour un appel syst√®me, plut√¥t que int 0x80.  L'appel 0x80 est consid√©r√© comme obsol√®te pour cette architecture, bien qu'il soit pris en charge. <br></div></div><br>  Un d√©but a √©t√© fait, et maintenant ... <br><br><h2>  C'est parti! </h2><br>  Qu'il y ait au moins quelques d√©tails, nous allons √©crire le code d'une commande d'un octet.  Que ce soit le mot Fort "0", en mettant 0 en haut de la pile: <br><br><pre> <code class="cpp hljs">bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next</code> </pre><br>  Au moment o√π cette commande est ex√©cut√©e, R8 pointe d√©j√† vers la commande d'octet suivante.  Il est n√©cessaire de le lire, d'augmenter R8, de d√©terminer l'adresse ex√©cutable par le code de la commande d'octets, et de lui transf√©rer le contr√¥le. <br><br>  Mais ... quelle profondeur de bits sera la table d'adresses de commande d'octets?  Ensuite, j'ai d√ª fouiller dans le nouveau syst√®me de commande x86-64 pour moi.  H√©las, je n'ai pas trouv√© de commandes qui vous permettent d'aller √† l'offset en m√©moire.  Donc, calculez l'adresse ou l'adresse sera pr√™te - 64 bits.  Nous n'avons pas le temps de calculer, ce qui signifie - 64 bits.  Dans ce cas, la taille de la table sera de 256 * 8 = 4096 octets.  Enfin, encodez l'appel _next: <br><br><pre> <code class="cpp hljs">_next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-meta"><span class="hljs-meta"># bcmd -   -</span></span></code> </pre><br>  Pas mal, il me semble ... Il n'y a que trois instructions processeur, lors du passage d'une commande d'octet √† une autre. <br><br>  En fait, ces commandes n'√©taient pas si faciles pour moi.  J'ai d√ª plonger √† nouveau dans le syst√®me de commande 0x86-64 et trouver une nouvelle commande MOVZX pour moi.  En fait, cette commande convertit une valeur de 8, 16 ou 32 bits en un registre 64 bits.  Il existe deux variantes de cette commande: unsigned, o√π les chiffres sup√©rieurs sont remplis de z√©ros et celui sign√© est MOVSX.  Dans la version sign√©e, le signe se d√©veloppe, c'est-√†-dire que pour les nombres positifs, les z√©ros iront aux chiffres sup√©rieurs et pour les n√©gatifs, les uns.  Cette option nous est √©galement utile pour la commande lit byte. <br><br>  Au fait, cette option est-elle la plus rapide?  Peut-√™tre que quelqu'un sugg√©rera encore plus vite? <br><br>  Eh bien, nous avons maintenant une machine d'octets qui peut ex√©cuter une s√©quence de commandes d'octets et les ex√©cuter.  Il faut le tester en pratique, pour forcer √† ex√©cuter au moins une √©quipe.  Mais lequel?  Z√©ro sur la pile?  Mais ici, vous ne connaissez m√™me pas le r√©sultat, si vous ne regardez pas la pile sous le d√©bogueur ... Mais si le programme a commenc√©, il peut √™tre termin√© :) <br><br>  Nous √©crivons une commande bye qui termine le programme et √©crit √† ce sujet, d'autant plus que nous avons ¬´Hellow, world!¬ª. <br><br><pre> <code class="cpp hljs">bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #  </code> </pre><br>  La seule chose qui reste est de cr√©er une table d'adresses de commande d'octets, d'initialiser les registres et de d√©marrer la machine d'octets.  Donc ... il y a 256 valeurs dans le tableau, et il y a deux commandes.  Qu'y a-t-il dans les autres cellules? <br>  Le reste aura un code d'op√©ration invalide.  Mais, vous ne pouvez pas le v√©rifier, ce sont des √©quipes suppl√©mentaires, nous en avons trois maintenant, et avec le contr√¥le ce sera cinq.  Donc, nous allons faire une telle commande stub - une mauvaise √©quipe.  D'abord, nous remplissons tout le tableau pour cela, puis nous commen√ßons √† occuper les cellules avec des commandes utiles.  Laissez la mauvaise √©quipe avoir le code 0x00, l'√©quipe bye - 0x01 et le '0' aura le code 0x02, une fois qu'il est d√©j√† √©crit.  La mauvaise √©quipe pour l'instant fera la m√™me chose que bye, uniquement avec un code et un texte d'ach√®vement diff√©rents (je le mettrai dans le spoiler, presque comme Bye): <br><br><div class="spoiler">  <b class="spoiler_title">bcmd_bad</b> <div class="spoiler_text"><pre> <code class="cpp hljs">bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #  </code> </pre> </div></div>  Dessinez maintenant un tableau d'adresses.  Pour plus de commodit√©, nous en placerons huit dans chaque ligne, il y en aura 16. La table est assez grande: <br><br><div class="spoiler">  <b class="spoiler_title">Table d'adresses de commande d'octets</b> <div class="spoiler_text"><pre> <code class="cpp hljs">bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad</code> </pre> </div></div>  Nous √©crivons le corps du programme d'octets.  Pour ce faire, affectez des codes de commande aux variables assembleur.  Nous aurons les accords suivants: <br><br><ul><li>  Les adresses pour l'ex√©cution des commandes d'octets commenceront sur bcmd_ </li><li>  Les codes de commande eux-m√™mes seront stock√©s dans des variables commen√ßant par b_ </li></ul><br>  Ainsi, le corps du programme d'octets sera comme ceci: <br><br><pre> <code class="cpp hljs">start: .byte b_bye</code> </pre><br>  D√©clarez la taille de la pile de donn√©es en tant que stack_size.  Soit jusqu'√† pr√©sent 1024. Lors de l'initialisation, nous ferons RBP = RSP - stack_size. <br><br><div class="spoiler">  <b class="spoiler_title">En fait, nous obtenons un tel code de programme (coming.asm)</b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye msg_hello: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> msg_hello_len = . - msg_hello bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_bye .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start jmp _next _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_num0 = <span class="hljs-number"><span class="hljs-number">0x02</span></span> bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next</code> </pre><br></div></div><br>  Compiler, ex√©cuter: <br><br> <code>$ as fort.asm -o fort.o -g -ahlsm &gt;list.txt <br> $ ld forth.o -o forth <br> $ ./forth <br> bye! <br></code> <br>  √áa marche!  Notre premier programme de bytecode √† partir d'un octet a √©t√© lanc√© :) <br>  Bien s√ªr, ce sera le cas si tout est fait correctement.  Et sinon, le r√©sultat est probablement le suivant: <br><br> <code>$ ./forth <br>   <br></code> <br>  Bien s√ªr, d'autres options sont possibles, mais je les ai rencontr√©es le plus souvent.  Et nous avons besoin d'un d√©bogueur. <br><br><div class="spoiler">  <b class="spoiler_title">Paroles de Debugger</b> <div class="spoiler_text">  Comme d√©j√† mentionn√©, j'ai utilis√© GDB.  Il s'agit d'un d√©bogueur assez puissant, mais avec une interface de ligne de commande.  L'ex√©cuter est tr√®s simple: <br><br><pre> <code class="plaintext hljs">$ gdb ./forth GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1 Copyright (C) 2016 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type "show copying" and "show warranty" for details. This GDB was configured as "x86_64-linux-gnu". Type "show configuration" for configuration details. For bug reporting instructions, please see: &lt;http://www.gnu.org/software/gdb/bugs/&gt;. Find the GDB manual and other documentation resources online at: &lt;http://www.gnu.org/software/gdb/documentation/&gt;. For help, type "help". Type "apropos word" to search for commands related to "word"... Reading symbols from ./forth...done. (gdb)</code> </pre> <br>  Ensuite, en entrant des commandes, nous d√©boguons.  J'ai eu suffisamment d'heures pour trouver certaines commandes n√©cessaires et apprendre √† les utiliser pour le d√©bogage.  Les voici: <br>  b &lt;label&gt; - d√©finir un point d'arr√™t <br>  l &lt;label&gt; - afficher le code source <br>  r - d√©marrer ou red√©marrer le programme <br>  ir - afficher le statut des registres du processeur <br>  s - √©tape <br><br>  Soit dit en passant, rappelez-vous que vous devez compiler le programme avec le commutateur -g?  Sinon, les balises et le code source ne seront pas disponibles.  Dans ce cas, il ne sera possible de d√©boguer que par du code d√©sassembl√© et d'utiliser les adresses en m√©moire.  Nous sommes, bien s√ªr, des Indiens, mais pas dans la m√™me mesure ... </div></div><br>  Mais en quelque sorte, le programme fait tr√®s peu.  Nous lui disons seulement ¬´Bonjour¬ª et elle dit imm√©diatement ¬´Au revoir!¬ª.  Faisons le vrai "Bonjour tout le monde!"  sur bytecode.  Pour ce faire, placez l'adresse et la longueur de cha√Æne sur la pile, puis ex√©cutez la commande qui affiche la cha√Æne, puis la commande bye.  Pour faire tout cela, de nouvelles commandes sont n√©cessaires: tapez pour sortir la cha√Æne, et allum√©e pour mettre l'adresse et la longueur de la cha√Æne.  D'abord, nous √©crivons le type, que son code soit 0x80.  Nous avons encore besoin de ce morceau de code avec l'appel sys_write: <br><br><pre> <code class="cpp hljs">b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rcx push r8 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   pop r8 jmp _next</code> </pre><br>  Ici, nous prenons l'adresse et la longueur de cha√Æne de la pile de donn√©es √† l'aide des commandes POP.  Appeler int 0x80 peut changer le registre de R8, nous le sauvegardons donc.  Nous ne l'avons pas fait auparavant parce que le programme se terminait.  Le contenu de ces registres s'en fichait.  Il s'agit maintenant d'une commande d'octet standard, apr√®s quoi le code d'octet continue d'√™tre ex√©cut√©, et vous devez vous comporter. <br><br>  Maintenant √©crivons le lit.  Ce sera notre premi√®re √©quipe avec des param√®tres.  Apr√®s l'octet avec le code de cette commande, il y aura des octets contenant le num√©ro qu'il mettra sur la pile.  La question se pose imm√©diatement - quelle profondeur de bits est n√©cessaire ici?  Pour mettre n'importe quel nombre, vous avez besoin de 64 bits.  Mais, chaque fois que la commande occupera 9 octets, qu'est-ce qui mettrait un chiffre?  Nous perdons donc la compacit√©, l'une des principales propri√©t√©s du bytecode, et le code de fort aussi ... <br><br>  La solution est simple - nous ferons plusieurs commandes pour diff√©rentes profondeurs de bits.  Ceux-ci seront allum√©s8, allum√©s16, allum√©s32 et allum√©s64.  Pour les petits nombres, nous utiliserons lit8 et lit16, pour les plus grands - lit32 et lit64.  Les petits nombres sont le plus souvent utilis√©s, et pour eux, il y aura la commande la plus courte, qui prend deux octets.  Pas mal! .. On va faire les codes de ces commandes 0x08 - 0x0B. <br><br><pre> <code class="cpp hljs">b_lit8 = <span class="hljs-number"><span class="hljs-number">0x08</span></span> bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> bcmd_lit16: movsx rax, word ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> push rax jmp _next b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> bcmd_lit32: movsx rax, dword ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> push rax jmp _next b_lit64 = <span class="hljs-number"><span class="hljs-number">0x0B</span></span> bcmd_lit64: mov rax, [r8] add r8, <span class="hljs-number"><span class="hljs-number">8</span></span> push rax jmp _next</code> </pre> <br>  Ici, nous utilisons la commande MOVSX - il s'agit d'une version embl√©matique de la commande MOVZX que nous connaissons d√©j√†.  R8 nous avons un compteur de commande d'octets.  Nous chargeons la valeur de la taille d√©sir√©e dessus, la d√©pla√ßons √† la commande suivante et pla√ßons la valeur convertie en 64 bits sur la pile. <br><br>  <b>N'oubliez pas d'ajouter les adresses des nouvelles √©quipes dans le tableau aux postes souhait√©s.</b> <br><br>  C'est tout pr√™t pour √©crire votre premier programme "Bonjour, monde!"  sur notre bytecode.  Travaillons avec le compilateur!  :) <br><br><pre> <code class="cpp hljs">start: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_bye</code> </pre> <br>  Nous utilisons deux commandes allum√©es diff√©rentes: lit64 pour mettre l'adresse de la cha√Æne sur la pile, et lit8, avec lequel nous poussons la longueur sur la pile.  Ensuite, nous ex√©cutons deux commandes d'octets suppl√©mentaires: type et bye. <br>  Compiler, ex√©cuter: <br><br><pre> <code class="plaintext hljs">$ as fort.asm -o fort.o -g -ahlsm &gt;list.txt $ ld forth.o -o forth $ ./forth Hello, world! bye!</code> </pre><br>  A gagn√© notre bytecode!  C'est le r√©sultat qui devrait √™tre si tout est normal. <br><br><div class="spoiler">  <b class="spoiler_title">Source compl√®te</b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye msg_hello: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> msg_hello_len = . - msg_hello bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x00</span></span> .quad bcmd_lit8, bcmd_lit16, bcmd_lit32, bcmd_lit64, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x10</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x20</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x30</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x40</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x60</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_type, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x80</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_bye .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start jmp _next _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_num0 = <span class="hljs-number"><span class="hljs-number">0x02</span></span> bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next b_lit8 = <span class="hljs-number"><span class="hljs-number">0x08</span></span> bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> bcmd_lit16: movsx rax, word ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> push rax jmp _next b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> bcmd_lit32: movsx rax, dword ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> push rax jmp _next b_lit64 = <span class="hljs-number"><span class="hljs-number">0x0B</span></span> bcmd_lit64: mov rax, [r8] add r8, <span class="hljs-number"><span class="hljs-number">8</span></span> push rax jmp _next b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rcx push r8 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   pop r8 jmp _next</code> </pre> <br></div></div><br>  Mais les possibilit√©s sont encore tr√®s primitives, on ne peut pas faire une condition, un cycle. <br><br>  Comment ne pas le faire?  Vous pouvez, tout est entre nos mains!  Faisons 10 fois cette ligne dans la boucle.  Cela n√©cessitera une commande de branchement conditionnel, ainsi qu'un peu d'arithm√©tique de pile: une commande diminuant la valeur sur la pile de 1 (sur fort "1-") et une commande de duplication de sommets ("dup"). <br><br>  Avec l'arithm√©tique, tout est simple, je ne commenterai m√™me pas: <br><br><pre> <code class="cpp hljs">b_dup = <span class="hljs-number"><span class="hljs-number">0x18</span></span> bcmd_dup: push [rsp] jmp _next b_wm = <span class="hljs-number"><span class="hljs-number">0x20</span></span> bcmd_wm: decq [rsp] jmp _next</code> </pre> <br>  Maintenant, un saut conditionnel.  Pour commencer, simplifions la t√¢che - une transition inconditionnelle.  Il est clair qu'il suffit de modifier la valeur du registre R8.  La premi√®re chose qui me vient √† l'esprit est une commande d'octets, suivie d'un param√®tre - l'adresse de transition est de 64 bits.  Encore neuf octets.  Avons-nous besoin de ces neuf octets?  Les transitions se produisent g√©n√©ralement sur de courtes distances, souvent dans quelques centaines d'octets.  Donc, nous n'utiliserons pas l'adresse, mais l'offset! <br><br>  Profondeur de bits?  Dans de nombreux cas, 8 bits (127 avant / arri√®re) suffiront, mais parfois ce ne sera pas suffisant.  Par cons√©quent, nous ferons la m√™me chose qu'avec la commande allum√©e, nous ferons deux options - 8 et 16 chiffres, les codes de commande seront 0x10 et 0x11: <br><br><pre> <code class="cpp hljs">b_branch8 = <span class="hljs-number"><span class="hljs-number">0x10</span></span> bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_branch16 = <span class="hljs-number"><span class="hljs-number">0x11</span></span> bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next</code> </pre>  La transition conditionnelle est d√©sormais facile √† mettre en ≈ìuvre.  Si la pile vaut 0, passez √† _next, et sinon, allez √† la commande branch! <br><pre> <code class="cpp hljs">b_qbranch8 = <span class="hljs-number"><span class="hljs-number">0x12</span></span> bcmd_qbranch8: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch8 inc r8 jmp _next b_qbranch16 = <span class="hljs-number"><span class="hljs-number">0x13</span></span> bcmd_qbranch16: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch16 add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> jmp _next</code> </pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenant, nous avons tout pour faire une boucle: </font></font><pre> <code class="cpp hljs">start: .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">10</span></span> #  #  m0: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_wm .byte b_dup .byte b_qbranch8 .byte m0 - . .byte b_bye</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les deux premi√®res commandes - nous mettons le compteur de boucles sur la pile. </font><font style="vertical-align: inherit;">Ensuite, imprimez la cha√Æne Hello. </font><font style="vertical-align: inherit;">Ensuite, nous soustrayons 1 du compteur, le dupliquons et effectuons (ou n'effectuons pas) la transition. </font><font style="vertical-align: inherit;">La commande de duplication est n√©cessaire car la commande de branche conditionnelle prend la valeur en haut de la pile. </font><font style="vertical-align: inherit;">La transition ici est de huit bits, car la distance n'est que de quelques octets. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous mettons les adresses des nouvelles commandes dans une table, compilons et ex√©cutons.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je vais le mettre dans un spoiler, sinon notre programme est devenu verbeux)</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">$ as fort.asm -o fort.o -g -ahlsm &gt;list.txt $ ld forth.o -o forth $ ./forth Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! bye!</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eh bien, nous pouvons d√©j√† faire des conditions et des cycles! </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source compl√®te</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye msg_hello: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> msg_hello_len = . - msg_hello bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x00</span></span> .quad bcmd_lit8, bcmd_lit16, bcmd_lit32, bcmd_lit64, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_branch8, bcmd_branch16, bcmd_qbranch8, bcmd_qbranch16, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x10</span></span> .quad bcmd_dup, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_wm, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x20</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x30</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x40</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x60</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_type, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x80</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">10</span></span> #  #  m0: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_wm .byte b_dup .byte b_qbranch8 .byte m0 - . .byte b_bye .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start jmp _next _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_num0 = <span class="hljs-number"><span class="hljs-number">0x02</span></span> bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next b_lit8 = <span class="hljs-number"><span class="hljs-number">0x08</span></span> bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> bcmd_lit16: movsx rax, word ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> push rax jmp _next b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> bcmd_lit32: movsx rax, dword ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> push rax jmp _next b_lit64 = <span class="hljs-number"><span class="hljs-number">0x0B</span></span> bcmd_lit64: mov rax, [r8] add r8, <span class="hljs-number"><span class="hljs-number">8</span></span> push rax jmp _next b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rcx push r8 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   pop r8 jmp _next b_dup = <span class="hljs-number"><span class="hljs-number">0x18</span></span> bcmd_dup: push [rsp] jmp _next b_wm = <span class="hljs-number"><span class="hljs-number">0x20</span></span> bcmd_wm: decq [rsp] jmp _next b_branch8 = <span class="hljs-number"><span class="hljs-number">0x10</span></span> bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_branch16 = <span class="hljs-number"><span class="hljs-number">0x11</span></span> bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next b_qbranch8 = <span class="hljs-number"><span class="hljs-number">0x12</span></span> bcmd_qbranch8: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch8 inc r8 jmp _next b_qbranch16 = <span class="hljs-number"><span class="hljs-number">0x13</span></span> bcmd_qbranch16: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch16 add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> jmp _next</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais jusqu'√† ce que la machine d'octets termin√©e manque une autre fonction tr√®s importante. </font><font style="vertical-align: inherit;">Nous ne pouvons pas appeler un autre √† partir du bytecode. </font><font style="vertical-align: inherit;">Nous n'avons pas ce qu'on appelle des routines, des proc√©dures, etc. </font><font style="vertical-align: inherit;">Et dans le fort, sans cela, nous ne pouvons pas utiliser des mots autres que les mots du noyau dans certains mots. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous terminons le travail. </font><font style="vertical-align: inherit;">Ici, pour la premi√®re fois, nous avons besoin d'une pile de retours. </font><font style="vertical-align: inherit;">Deux commandes sont n√©cessaires - la commande d'appel et la commande de retour (appel et sortie).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La commande call, en principe, fait la m√™me chose que branch - transf√®re le contr√¥le √† un autre morceau de bytecode. </font><font style="vertical-align: inherit;">Mais, contrairement √† branch, vous devez toujours enregistrer l'adresse de retour dans la pile de retour afin de pouvoir retourner et poursuivre l'ex√©cution. </font><font style="vertical-align: inherit;">Il y a une autre diff√©rence - de tels appels peuvent se produire √† des distances beaucoup plus grandes. </font><font style="vertical-align: inherit;">Par cons√©quent, nous faisons la commande d'appel √† l'image de branche, mais en trois versions - 8, 16 et 32 ‚Äã‚Äãbits.</font></font><br><br><pre> <code class="cpp hljs">b_call8 = <span class="hljs-number"><span class="hljs-number">0x0C</span></span> bcmd_call8: movsx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 mov [rbp], r8 add r8, rax jmp _next b_call16 = <span class="hljs-number"><span class="hljs-number">0x0D</span></span> bcmd_call16: movsx rax, word ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> mov [rbp], r8 add r8, rax jmp _next b_call32 = <span class="hljs-number"><span class="hljs-number">0x0E</span></span> bcmd_call32: movsx rax, dword ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> mov [rbp], r8 add r8, rax jmp _next</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme vous pouvez le voir, ici, contrairement aux transitions, 3 √©quipes sont ajout√©es. L'un d'eux r√©organise R8 √† la commande d'octet suivante, et les deux autres stockent la valeur re√ßue dans la pile de retour. Au fait, ici, j'ai essay√© de ne pas mettre les instructions du processeur c√¥te √† c√¥te, afin que le convoyeur du processeur puisse ex√©cuter les commandes en parall√®le. Mais je ne sais pas √† quel point cela donne un effet. Si vous le souhaitez, vous pouvez v√©rifier les tests. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il convient de garder √† l'esprit que la formation d'un argument pour la commande d'appel est quelque peu diff√©rente de celle de la branche. Pour la branche, le d√©calage est calcul√© comme la diff√©rence entre l'adresse de branche et l'adresse de l'octet suivant la commande byte. Et pour la commande d'appel, c'est la diff√©rence entre l'adresse de saut et l'adresse de la commande suivante.</font></font> Pourquoi est-ce n√©cessaire?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela se traduit par moins d'instructions du processeur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, la commande de retour. </font><font style="vertical-align: inherit;">En fait, son travail consiste uniquement √† restaurer R8 √† partir de la pile de retour et √† transf√©rer le contr√¥le vers la machine d'octets:</font></font><br><br><pre> <code class="cpp hljs">b_exit = <span class="hljs-number"><span class="hljs-number">0x1F</span></span> bcmd_exit: mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> jmp _next</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ces commandes seront utilis√©es tr√®s souvent et doivent √™tre optimis√©es au maximum. </font><font style="vertical-align: inherit;">La commande exit byte occupe trois instructions machine. </font><font style="vertical-align: inherit;">Est-il possible de r√©duire quelque chose ici? </font><font style="vertical-align: inherit;">Il s'av√®re que vous le pouvez! </font><font style="vertical-align: inherit;">Vous pouvez simplement supprimer la commande de transition :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour ce faire, placez-la au-dessus du point d'entr√©e de la machine _next byte:</font></font><br><br><pre> <code class="cpp hljs">b_exit = <span class="hljs-number"><span class="hljs-number">0x1F</span></span> bcmd_exit: mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Soit dit en passant, les commandes les plus importantes et les plus fr√©quemment utilis√©es (par exemple, appel) doivent √™tre plac√©es plus pr√®s de la machine √† octets afin que le compilateur puisse former une commande de saut court. </font><font style="vertical-align: inherit;">Ceci est clairement visible dans la liste. </font><font style="vertical-align: inherit;">Voici un exemple.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-number"><span class="hljs-number">262</span></span> <span class="hljs-number"><span class="hljs-number">0084</span></span> <span class="hljs-number"><span class="hljs-number">490F</span></span>BE00 bcmd_lit8: movsx rax, byte ptr [r8] <span class="hljs-number"><span class="hljs-number">263</span></span> <span class="hljs-number"><span class="hljs-number">0088</span></span> <span class="hljs-number"><span class="hljs-number">49F</span></span>FC0 inc r8 <span class="hljs-number"><span class="hljs-number">264</span></span> <span class="hljs-number"><span class="hljs-number">008b</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> push rax <span class="hljs-number"><span class="hljs-number">265</span></span> <span class="hljs-number"><span class="hljs-number">008</span></span>c EB90 jmp _next <span class="hljs-number"><span class="hljs-number">266</span></span> <span class="hljs-number"><span class="hljs-number">267</span></span> b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> <span class="hljs-number"><span class="hljs-number">268</span></span> <span class="hljs-number"><span class="hljs-number">008</span></span>e <span class="hljs-number"><span class="hljs-number">490F</span></span>BF00 bcmd_lit16: movsx rax, word ptr [r8] <span class="hljs-number"><span class="hljs-number">269</span></span> <span class="hljs-number"><span class="hljs-number">0092</span></span> <span class="hljs-number"><span class="hljs-number">4983</span></span>C002 add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">270</span></span> <span class="hljs-number"><span class="hljs-number">0096</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> push rax <span class="hljs-number"><span class="hljs-number">271</span></span> <span class="hljs-number"><span class="hljs-number">0097</span></span> EB85 jmp _next <span class="hljs-number"><span class="hljs-number">272</span></span> <span class="hljs-number"><span class="hljs-number">273</span></span> b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> <span class="hljs-number"><span class="hljs-number">274</span></span> <span class="hljs-number"><span class="hljs-number">0099</span></span> <span class="hljs-number"><span class="hljs-number">496300</span></span> bcmd_lit32: movsx rax, dword ptr [r8] <span class="hljs-number"><span class="hljs-number">275</span></span> <span class="hljs-number"><span class="hljs-number">009</span></span>c <span class="hljs-number"><span class="hljs-number">4983</span></span>C004 add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">276</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>a0 <span class="hljs-number"><span class="hljs-number">50</span></span> push rax <span class="hljs-number"><span class="hljs-number">277</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>a1 E978FFFF jmp _next <span class="hljs-number"><span class="hljs-number">277</span></span> FF <span class="hljs-number"><span class="hljs-number">278</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, aux lignes 265 et 271, la commande jmp prend 2 octets chacune, et √† la ligne 277, la m√™me commande est d√©j√† compil√©e √† 5 octets, car la distance de saut a d√©pass√© la longueur de la commande courte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par cons√©quent, les commandes d'octet telles que bad, bye, type sont r√©organis√©es davantage, et telles que call, branch, lit sont plus proches. Malheureusement, il n'y a pas grand-chose qui puisse tenir dans une transition de 127 octets. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ajoutons de nouvelles commandes √† la table des adresses de commandes en fonction de leurs codes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Donc, nous avons maintenant un d√©fi et un retour, nous allons les tester! Pour ce faire, s√©lectionnez l'impression de ligne dans une proc√©dure distincte, et nous l'appellerons deux fois en boucle. Et le nombre de r√©p√©titions du cycle est r√©duit √† trois.</font></font><br><br><pre> <code class="cpp hljs">start: .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">3</span></span> #  #  m0: .byte b_call16 .word sub_hello - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word sub_hello - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_wm .byte b_dup .byte b_qbranch8 .byte m0 - . .byte b_bye sub_hello: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_exit</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Call8 pourrait √™tre utilis√© ici, mais j'ai d√©cid√© d'utiliser call16 comme le plus probablement utilis√©. </font><font style="vertical-align: inherit;">La valeur 2 est soustraite en raison des particularit√©s du calcul de l'adresse pour la commande d'octet d'appel sur laquelle j'ai √©crit. </font><font style="vertical-align: inherit;">Pour call8, 1 sera d√©duit ici, pour call32, respectivement, 4. Nous </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compilons et appelons:</font></font><br><br><pre> <code class="plaintext hljs">$ as forth.asm -o forth.o -g -ahlsm&gt;list.txt $ ld forth.o -o forth $ ./forth Hello, world! Bad byte code!</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oups ... comme on dit, quelque chose s'est mal pass√© :) Eh bien, nous lan√ßons GDB et voyons ce qui s'y passe. </font><font style="vertical-align: inherit;">J'ai d√©fini un point d'arr√™t imm√©diatement sur bcmd_exit, car il est clair que l'appel sub_hello passe, et le corps de la proc√©dure est en cours d'ex√©cution ... lanc√© ... et le programme n'a pas atteint le point d'arr√™t. </font><font style="vertical-align: inherit;">Imm√©diatement, il y avait une suspicion d'un code de commande octet. </font><font style="vertical-align: inherit;">Et, en effet, la raison √©tait en lui. </font><font style="vertical-align: inherit;">b_exit J'ai attribu√© la valeur 0x1f, et l'adresse elle-m√™me a √©t√© plac√©e dans le num√©ro de cellule du tableau 0x17. </font><font style="vertical-align: inherit;">Eh bien, je vais corriger la valeur de b_exit √† 0x17 et r√©essayer:</font></font><br><br><pre> <code class="plaintext hljs">$ as forth.asm -o forth.o -g -ahlsm&gt;list.txt $ ld forth.o -o forth $ ./forth Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! bye!</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exactement six fois le salut et une fois au revoir. </font><font style="vertical-align: inherit;">Comme il se doit :)</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source compl√®te</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye msg_hello: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> msg_hello_len = . - msg_hello bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x00</span></span> .quad bcmd_lit8, bcmd_lit16, bcmd_lit32, bcmd_lit64, bcmd_call8, bcmd_call16, bcmd_call32, bcmd_bad .quad bcmd_branch8, bcmd_branch16, bcmd_qbranch8, bcmd_qbranch16, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_exit # <span class="hljs-number"><span class="hljs-number">0x10</span></span> .quad bcmd_dup, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_wm, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x20</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x30</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x40</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x60</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_type, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x80</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">3</span></span> #  #  m0: .byte b_call16 .word sub_hello - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word sub_hello - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_wm .byte b_dup .byte b_qbranch8 .byte m0 - . .byte b_bye sub_hello: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_exit .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start jmp _next b_exit = <span class="hljs-number"><span class="hljs-number">0x17</span></span> bcmd_exit: mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] b_num0 = <span class="hljs-number"><span class="hljs-number">0x02</span></span> bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next b_lit8 = <span class="hljs-number"><span class="hljs-number">0x08</span></span> bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> bcmd_lit16: movsx rax, word ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> push rax jmp _next b_call8 = <span class="hljs-number"><span class="hljs-number">0x0C</span></span> bcmd_call8: movsx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 mov [rbp], r8 add r8, rax jmp _next b_call16 = <span class="hljs-number"><span class="hljs-number">0x0D</span></span> bcmd_call16: movsx rax, word ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> mov [rbp], r8 add r8, rax jmp _next b_call32 = <span class="hljs-number"><span class="hljs-number">0x0E</span></span> bcmd_call32: movsx rax, dword ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> mov [rbp], r8 add r8, rax jmp _next b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> bcmd_lit32: movsx rax, dword ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> push rax jmp _next b_lit64 = <span class="hljs-number"><span class="hljs-number">0x0B</span></span> bcmd_lit64: mov rax, [r8] add r8, <span class="hljs-number"><span class="hljs-number">8</span></span> push rax jmp _next b_dup = <span class="hljs-number"><span class="hljs-number">0x18</span></span> bcmd_dup: push [rsp] jmp _next b_wm = <span class="hljs-number"><span class="hljs-number">0x20</span></span> bcmd_wm: decq [rsp] jmp _next b_branch8 = <span class="hljs-number"><span class="hljs-number">0x10</span></span> bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_branch16 = <span class="hljs-number"><span class="hljs-number">0x11</span></span> bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next b_qbranch8 = <span class="hljs-number"><span class="hljs-number">0x12</span></span> bcmd_qbranch8: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch8 inc r8 jmp _next b_qbranch16 = <span class="hljs-number"><span class="hljs-number">0x13</span></span> bcmd_qbranch16: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch16 add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> jmp _next b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rcx push r8 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   pop r8 jmp _next</code> </pre><br></div></div><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quel est le r√©sultat </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons fait et test√© une machine d'octets de pile 64 bits compl√®te et assez rapide. En vitesse, cette machine √† octets sera peut-√™tre l'une des plus rapides de sa cat√©gorie (une machine √† octets empil√©s sans JIT). Elle sait comment ex√©cuter des commandes s√©quentiellement, effectuer des sauts conditionnels et inconditionnels, appeler des proc√©dures et en revenir. Dans le m√™me temps, le bytecode utilis√© est raisonnablement compact. Fondamentalement, les commandes d'octets prennent 1-3 octets, plus est tr√®s rare (seulement de grands nombres et des appels de proc√©dure tr√®s √©loign√©s). Un petit ensemble de commandes d'octets est √©galement esquiss√©, ce qui est facile √† d√©velopper. Supposons que toutes les commandes de base pour travailler avec la pile (drop, swap, over, root, etc. peuvent √™tre √©crites en 20 minutes, le m√™me montant ira aux commandes arithm√©tiques enti√®res).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un autre point important. Le bytecode, contrairement au code de fort cousu direct classique, ne contient pas d'instructions machine, il peut donc √™tre transf√©r√© sans recompilation sur une autre plate-forme. Il suffit de r√©√©crire le noyau une fois dans le syst√®me d'instructions du nouveau processeur, et cela peut se faire tr√®s rapidement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La version actuelle de la machine d'octets n'est pas sp√©cifique √† une langue particuli√®re. Mais je veux faire l'impl√©mentation du langage Fort dessus parce que j'ai de l'exp√©rience avec lui, et le compilateur peut √™tre fait tr√®s rapidement.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S'il y a un int√©r√™t pour cela, bas√© sur cette machine, dans le prochain article, je ferai des entr√©es-sorties de cha√Ænes et de nombres, un dictionnaire fort et un interpr√®te. Vous pouvez "toucher" l'√©quipe avec vos mains. Eh bien, dans le troisi√®me article, nous ferons un compilateur, et nous aurons un syst√®me de fortification presque complet. Ensuite, il sera possible d'√©crire et de compiler des algorithmes standard et de comparer les performances avec d'autres langages et syst√®mes. Vous pouvez utiliser, par exemple, le tamis d'Eratosth√®ne, et similaire.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est int√©ressant d'exp√©rimenter des options. </font><font style="vertical-align: inherit;">Par exemple, cr√©ez la table de commandes 16 bits et voyez comment cela affectera les performances. </font><font style="vertical-align: inherit;">Vous pouvez √©galement transformer le point d'entr√©e _next en macro, auquel cas le code machine de chaque commande d'octets augmentera de taille de deux commandes (moins la transition et plus trois commandes de _next). </font><font style="vertical-align: inherit;">Autrement dit, √† la fin, il n'y aura pas de transition vers _next, mais le contenu du point _next lui-m√™me (c'est 14 octets). </font><font style="vertical-align: inherit;">Il est int√©ressant de savoir comment cela affectera les performances. </font><font style="vertical-align: inherit;">Vous pouvez √©galement essayer de faire l'optimisation √† l'aide de registres. </font><font style="vertical-align: inherit;">Par exemple, une boucle standard avec un compteur dans le fort stocke le compteur sur la pile de retour. </font><font style="vertical-align: inherit;">Vous pouvez cr√©er une version de registre et √©galement la tester. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez √©galement cr√©er un compilateur d'expressions √©crites sous la forme classique (par exemple, A = 5 + (B + C * 4)).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En g√©n√©ral, il y a de la place pour l'exp√©rimentation! </font></font> :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suite: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Byte-machine pour le fort (et pas seulement) en am√©rindien (partie 2)</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr431932/">https://habr.com/ru/post/fr431932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr431920/index.html">Frontend Mix - rapports sur Node.js, l'√©volutivit√© et le Web natif</a></li>
<li><a href="../fr431922/index.html">Qu'est-ce que les descripteurs de m√©thode en Java</a></li>
<li><a href="../fr431924/index.html">Syst√®me de gestion d'entrep√¥t utilisant CQRS et Event Sourcing. Processus de d√©veloppement</a></li>
<li><a href="../fr431928/index.html">Fatigue due aux articles jetables. Ou ode A.S. Makarenko</a></li>
<li><a href="../fr431930/index.html">Meetup DevOps √† Saint-P√©tersbourg</a></li>
<li><a href="../fr431934/index.html">Comment l'intelligence artificielle aide-t-elle √† travailler avec des documents juridiques? Conf√©rence d'Egor Budnikov d'ABBYY</a></li>
<li><a href="../fr431936/index.html">R√©sultats du concours TechnoText</a></li>
<li><a href="../fr431938/index.html">Racine de cube entier dans Verilog</a></li>
<li><a href="../fr431940/index.html">Les gens s'√©puisent s'ils ne sentent pas leur valeur. Que faire √† ce sujet?</a></li>
<li><a href="../fr431942/index.html">Injection de d√©pendance hi√©rarchique dans React et MobX State Tree en tant que mod√®le de domaine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>