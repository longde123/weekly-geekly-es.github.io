<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéº ü§ê üë∞üèø Que signifie dangereux √† Rust? üîÄ üçÜ üîî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous pr√©sente la traduction de l'article "Qu'est-ce qui est dangereux pour Rust?" auteur Nora Codes. 


 J'ai vu beaucoup de malente...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Que signifie dangereux √† Rust?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460295/"><p> Bonjour, Habr!  Je vous pr√©sente la traduction de l'article "Qu'est-ce qui est dangereux pour Rust?"  auteur Nora Codes. </p><br><p>  J'ai vu beaucoup de malentendus quant √† ce que le mot-cl√© dangereux signifie pour l'utilit√© et l'exactitude du langage Rust et sa promotion en tant que ¬´langage de programmation de syst√®me s√ªr¬ª.  La v√©rit√© est beaucoup plus compliqu√©e que ce qui peut √™tre d√©crit dans un court tweet, malheureusement.  Voil√† comment je la vois. </p><br><p>  En g√©n√©ral, le <strong>mot cl√© unsafe ne d√©sactive pas le syst√®me de type qui maintient le code Rust correct</strong> .  Il ne permet d'utiliser que certains ¬´superpuissances¬ª, comme les pointeurs de d√©r√©f√©rencement.  unsafe est utilis√© pour impl√©menter des abstractions s√ªres bas√©es sur un monde fondamentalement dangereux afin que la plupart du code Rust puisse utiliser ces abstractions et √©viter l'acc√®s √† la m√©moire non s√©curis√©. <a name="habracut"></a></p><br><h1 id="garantiya-bezopasnosti">  Garantie de s√©curit√© </h1><br><p>  La rouille garantit la s√©curit√© comme l'un de ses principes fondamentaux.  On peut dire que c'est le <em>sens de l'existence du</em> langage.  Cependant, il n'assure pas la s√©curit√© au sens traditionnel, pendant l'ex√©cution du programme et l'utilisation du garbage collector.  Au lieu de cela, Rust utilise un syst√®me de type tr√®s avanc√© pour garder une trace du moment et des valeurs accessibles.  Le compilateur analyse ensuite statiquement chaque programme Rust pour s'assurer qu'il est toujours dans le bon √©tat. </p><br><h2 id="bezopasnost-v-python">  S√©curit√© Python </h2><br><p>  Prenons l'exemple de Python.  Le code Python pur ne peut pas corrompre la m√©moire.  L'acc√®s aux √©l√©ments de la liste a des contr√¥les pour d√©passer les fronti√®res;  les liens renvoy√©s par les fonctions sont compt√©s pour √©viter l'apparition de liens pendants;  Il n'y a aucun moyen de faire de l'arithm√©tique arbitraire avec des pointeurs. </p><br><p>  Cela a deux cons√©quences.  Premi√®rement, de nombreux types doivent √™tre ¬´sp√©ciaux¬ª.  Par exemple, il n'est pas possible d'impl√©menter une liste ou un dictionnaire efficace en Python pur.  Au lieu de cela, l'interpr√©teur CPython a leur impl√©mentation interne.  Deuxi√®mement, l'acc√®s aux fonctions externes (fonctions non impl√©ment√©es en Python), appel√©es l'interface d'une fonction externe, n√©cessite l'utilisation d'un module ctypes sp√©cial et viole les garanties de s√©curit√© du langage. </p><br><p>  Dans un sens, cela signifie que tout ce qui est √©crit en Python ne garantit pas un acc√®s s√©curis√© √† la m√©moire. </p><br><h2 id="bezopasnost-v-rust">  S√©curit√© √† Rust </h2><br><p>  Rust fournit √©galement la s√©curit√©, mais au lieu d'impl√©menter des structures dangereuses en C, il fournit une astuce: le mot cl√© unsafe.  Cela signifie que les structures de donn√©es fondamentales de Rust, telles que Vec, VecDeque, BTreeMap et String, sont impl√©ment√©es dans Rust. </p><br><p>  Vous pouvez demander: "Mais, si Rust fournit une astuce contre ses garanties de s√©curit√© de code, et que la biblioth√®que standard est impl√©ment√©e en utilisant cette astuce, tout dans Rust ne sera-t-il pas consid√©r√© comme dangereux?" </p><br><p>  En un mot, cher lecteur, <strong>oui</strong> , exactement comme c'√©tait en Python.  Examinons-le plus en d√©tail. </p><br><h1 id="chto-zaprescheno-v-bezopasnom-rust">  Qu'est-ce qui est interdit dans la rouille s√ªre? </h1><br><p>  La s√©curit√© √† Rust est bien d√©finie: nous y pensons beaucoup.  En bref, les programmes Rust s√ªrs ne peuvent pas: </p><br><ul><li>  <strong>D√©r√©f√©rencer un pointeur qui pointe vers un type diff√©rent de celui que le compilateur conna√Æt</strong> .  Cela signifie qu'il n'y a pas de pointeurs vers null (car ils ne pointent nulle part), pas d'erreurs de d√©passement de limites et / ou de segmentation (d√©fauts de segmentation), pas de d√©bordements de buffer.  Mais cela signifie √©galement qu'il n'y a aucune utilisation apr√®s avoir lib√©r√© la m√©moire ou re-lib√©r√© la m√©moire (car la lib√©ration de la m√©moire est consid√©r√©e comme un d√©r√©f√©rencement du pointeur) et aucun <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jeu de mots destin√© √† taper</a> . </li><li>  <strong>Avoir plusieurs r√©f√©rences mutables √† un objet ou des r√©f√©rences simultan√©ment mutables et immuables √† un objet</strong> .  Autrement dit, si vous avez une r√©f√©rence mutable √† un objet, vous ne pouvez que l'avoir, et si vous avez une r√©f√©rence immuable √† l'objet, elle ne changera pas tant que vous ne la conserverez pas.  Cela signifie que vous ne pouvez pas forcer une course aux donn√©es dans Safe Rust, ce qui est une garantie que la plupart des autres langues s√©curis√©es ne peuvent pas fournir. </li></ul><br><p>  Rust code ces informations dans un syst√®me de types ou √† l'aide de <strong>types de donn√©es alg√©briques</strong> , comme Option pour indiquer l'existence / absence d'une valeur et R√©sultat &lt;T, E&gt; pour indiquer l'erreur / le succ√®s, ou les <strong>r√©f√©rences et leur dur√©e de vie</strong> , par exemple, &amp; T vs &amp; mut T pour indiquer un lien commun (immuable) et un lien exclusif (mutable) et &amp; 'a T vs &amp;' b T pour distinguer les liens qui sont corrects dans diff√©rents contextes (ceci est g√©n√©ralement omis car le compilateur est assez intelligent pour le comprendre vous-m√™me) . <br></p><br><h2 id="primery">  Des exemples </h2><br><p>  Par exemple, le code suivant ne sera pas compil√© car il contient un lien pendant.  Plus pr√©cis√©ment, <em>my_struct ne vit pas assez</em> .  En d'autres termes, la fonction renverra un lien vers quelque chose qui n'existe plus, et donc le compilateur ne peut pas (et, en fait, ne sait m√™me pas comment) le compiler. </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dangling_reference</span></span></span></span>(v: &amp;<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; &amp;MyStruct { <span class="hljs-comment"><span class="hljs-comment">//     MyStruct   ,  v,   . let my_struct = MyStruct { value: v }; //      my_struct. return &amp;my_struct; //  - my_struct  (  ). }</span></span></code> </pre> <br><p>  Ce code fait de m√™me, mais il essaie de contourner ce probl√®me en pla√ßant la valeur sur le tas (Box est le nom du pointeur intelligent de base dans Rust). </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dangling_heap_reference</span></span></span></span>(v: &amp;<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;MyStruct&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_struct = MyStruct { value: v }; <span class="hljs-comment"><span class="hljs-comment">//    Box         . let my_box = Box::new(my_struct); //      my_box. return &amp;my_box; // my_box   .   "" my_struct       - , //    - MyStruct  . }</span></span></code> </pre> <br><p>  Le code correct est renvoy√© par Box lui-m√™me au lieu d'une r√©f√©rence √† celui-ci.  Cela encode le transfert de propri√©t√© - la responsabilit√© de lib√©rer de la m√©moire - dans la signature de la fonction.  En regardant la signature, il devient clair que le code appelant est responsable de ce qui se passe avec Box et, en effet, le compilateur le traite automatiquement. <br></p><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">no_dangling_reference</span></span></span></span>(v: &amp;<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;MyStruct&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_struct = MyStruct { value: v }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_box = <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(my_struct); <span class="hljs-comment"><span class="hljs-comment">//    my_box  . return my_box; //    .         , //    ;       //  Box&lt;MyStruct&gt;       ,      . }</span></span></code> </pre> <br><blockquote>  Certaines mauvaises choses ne sont pas interdites dans la rouille s√ªre.  Par exemple, il est autoris√© du point de vue du compilateur: <br><ul><li>  provoquer un blocage dans le programme </li><li>  fuite d'une quantit√© de m√©moire arbitrairement grande </li><li>  ne pas fermer les poign√©es de fichier, les connexions √† la base de donn√©es ou les couvercles d'arbre de missile </li></ul><br><br>  La force de l'√©cosyst√®me Rust est que de nombreux projets choisissent d'utiliser un syst√®me de type pour s'assurer que le code est aussi pr√©cis que possible, mais le compilateur ne n√©cessite pas une telle contrainte, sauf dans les cas o√π un acc√®s s√©curis√© √† la m√©moire est fourni. </blockquote><br><h1 id="chto-razresheno-v-nebezopasnom-rust">  Qu'est-ce qui est autoris√© dans la rouille dangereuse? </h1><br><p>  Le code Rust non s√©curis√© est un code Rust avec le mot cl√© unsafe.  dangereux peut √™tre appliqu√© √† une fonction ou √† un bloc de code.  Lorsqu'elle est appliqu√©e √† une fonction, cela signifie "cette fonction n√©cessite que le code appel√© fournisse manuellement l'invariant qui est g√©n√©ralement fourni par le compilateur".  Lorsqu'il est appliqu√© √† un bloc de code, cela signifie "ce bloc de code fournit manuellement l'invariant n√©cessaire pour emp√™cher l'acc√®s non s√©curis√© √† la m√©moire, et par cons√©quent il est autoris√© √† faire des choses dangereuses". </p><br><p>  <strong>En d'autres termes, dangereux pour la fonction signifie "vous devez tout v√©rifier", et sur le bloc de code - "J'ai d√©j√† tout v√©rifi√©".</strong> </p><br><p>  Comme indiqu√© dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">The Rust Programming Language</a> , le code dans un bloc marqu√© avec le mot cl√© unsafe peut: </p><br><ul><li>  <strong>D√©r√©f√©rencer un pointeur.</strong>  Il s'agit d'une "superpuissance" cl√© qui vous permet d'impl√©menter des listes doublement li√©es, une table de hachage et d'autres structures de donn√©es fondamentales. </li><li>  <strong>Appelez une fonction ou une m√©thode non s√©curis√©e.</strong>  Plus d'informations √† ce sujet ci-dessous. </li><li>  <strong>Acc√©dez ou modifiez une variable statique mutable.</strong>  Les variables statiques dont la port√©e n'est pas contr√¥l√©e ne peuvent pas √™tre v√©rifi√©es statiquement, donc leur utilisation n'est pas s√ªre. </li><li>  <strong>Mettre en ≈ìuvre un trait dangereux.</strong>  Des traits non s√©curis√©s sont utilis√©s pour signaler si des types particuliers garantissent certains invariants.  Par exemple, Send et Sync d√©terminent si un type peut √™tre envoy√© entre les limites de threads ou peut √™tre utilis√© par plusieurs threads en m√™me temps. </li></ul><br><p>  Rappelez-vous ces pointeurs suspendus ci-dessus?  Ajoutez le mot dangereux, et le compilateur jurera deux fois plus car il n'aime pas utiliser dangereux l√† o√π il n'est pas n√©cessaire. </p><br><p>  Au lieu de cela, le mot cl√© unsafe est utilis√© pour impl√©menter des abstractions s√ªres bas√©es sur des op√©rations de pointeur arbitraires.  Par exemple, le type Vec est impl√©ment√© en utilisant dangereux, mais il est s√ªr de l'utiliser, car il v√©rifie les tentatives d'acc√®s aux √©l√©ments et n'autorise pas les d√©bordements.  Bien qu'il fournisse des op√©rations telles que set_len, qui <em>peuvent</em> entra√Æner un acc√®s non s√©curis√© √† la m√©moire, elles sont marqu√©es comme non s√©curis√©es. </p><br><p>  Par exemple, nous pourrions faire la m√™me chose que dans l'exemple no_dangling_reference, mais avec une utilisation d√©raisonnable de dangereux: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">manual_heap_reference</span></span></span></span>(v: <span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> MyStruct { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_struct = MyStruct { value: v }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_box = <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(my_struct); <span class="hljs-comment"><span class="hljs-comment">//  Box    . let struct_pointer = Box::into_raw(my_box); return struct_pointer; //   ;     . // MyStruct     . }</span></span></code> </pre> <br><p>  Remarquez l'absence du mot dangereux.  La cr√©ation de pointeurs est absolument s√ªre.  Comme cela a √©t√© √©crit, il existe un risque de fuite de m√©moire, mais rien de plus, et les fuites de m√©moire sont s√ªres.  L'appel de cette fonction est √©galement s√ªr.  dangereux n'est requis que lorsque quelque chose tente de <strong>d√©r√©f√©rencer un</strong> pointeur.  En prime, le d√©r√©f√©rencement lib√©rera automatiquement la m√©moire allou√©e. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_pointer = manual_heap_reference(<span class="hljs-number"><span class="hljs-number">1337</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_boxed_struct = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::from_raw(my_pointer) }; <span class="hljs-comment"><span class="hljs-comment">//  "Value: 1337" println!("Value: {}", my_boxed_struct.value); // my_boxed_struct    .       ,  //    - MyStruct }</span></span></code> </pre> <br><p>  Apr√®s optimisation, ce code √©quivaut √† renvoyer simplement une Box.  Box est une abstraction s√©curis√©e bas√©e sur un pointeur car elle emp√™che la distribution de pointeurs partout.  Par exemple, la prochaine version de main <strong>entra√Ænera</strong> une double m√©moire libre (double libre). </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_pointer = manual_heap_reference(<span class="hljs-number"><span class="hljs-number">1337</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_boxed_struct_1 = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::from_raw(my_pointer) }; <span class="hljs-comment"><span class="hljs-comment">// DOUBLE FREE BUG! let my_boxed_struct_2 = unsafe { Box::from_raw(my_pointer) }; //  "Value: 1337" . println!("Value: {}", my_boxed_struct_1.value); println!("Value: {}", my_boxed_struct_2.value); // my_boxed_struct_2    .     ,  //    - MyStruct. //  my_boxed_struct_1    .      , //      - MyStruct.  double-free bug. }</span></span></code> </pre> <br><h2 id="tak-chto-takoe-bezopasnaya-abstrakciya">  Alors, quelle est l'abstraction s√ªre? </h2><br><p>  L'abstraction s√ªre est une abstraction qui utilise un syst√®me de type pour fournir une API qui ne peut pas √™tre utilis√©e pour violer les garanties de s√©curit√© mentionn√©es ci-dessus.  Box est plus s√ªr * mut T, car il ne peut pas conduire √† une double d√©sallocation de m√©moire, comme illustr√© ci-dessus. </p><br><p>  Un autre exemple est le type Rc dans Rust.  Il s'agit d'un pointeur de comptage de r√©f√©rence - une r√©f√©rence non modifiable aux donn√©es du tas.  Puisqu'il permet plusieurs acc√®s simultan√©s √† une zone de m√©moire, il <em>doit</em> emp√™cher le changement afin d'√™tre consid√©r√© comme s√ªr. </p><br><p>  De plus, il n'est pas s√ªr pour les threads.  Si vous avez besoin de la s√©curit√© des threads, vous devrez utiliser le type d'arc (comptage de r√©f√©rence atomique), qui pr√©sente une p√©nalit√© de performance en raison de l'utilisation de valeurs atomiques pour le comptage de liens et emp√™chant d'√©ventuelles courses de donn√©es dans des environnements multithreads. </p><br><p>  Le compilateur ne vous permettra pas d'utiliser Rc l√† o√π vous devriez utiliser Arc, car les cr√©ateurs comme Rc ne l'ont pas marqu√© comme thread-safe.  S'ils le faisaient, ce serait d√©raisonnable: une fausse promesse de s√©curit√©. </p><br><h2 id="kogda-neobhodim-nebezopasnyy-rust">  Quand faut-il utiliser la rouille dangereuse? </h2><br><p>  La rouille dangereuse est toujours n√©cessaire lorsqu'il est n√©cessaire d'effectuer une op√©ration qui viole l'une de ces deux r√®gles d√©crites ci-dessus.  Par exemple, dans une liste doublement li√©e, l'absence de liens mutables vers les m√™mes donn√©es (pour l'√©l√©ment suivant et l'√©l√©ment pr√©c√©dent) la prive compl√®tement de b√©n√©fice.  Avec unsafe, un impl√©menteur de liste doublement li√© peut √©crire du code √† l'aide des pointeurs * mut Node, puis l'encapsuler dans une abstraction s√ªre. <br></p><p>  Un autre exemple est de travailler avec des syst√®mes embarqu√©s.  Les microcontr√¥leurs utilisent souvent un ensemble de registres dont les valeurs sont d√©termin√©es par l'√©tat physique de l'appareil.  Le monde ne peut pas s'arr√™ter pendant que vous prenez &amp; mut u8 √† partir d'un tel registre, donc dangereux n'est pas n√©cessaire pour travailler avec des caisses de support d'appareil.  En r√®gle g√©n√©rale, ces caisses encapsulent l'√©tat dans des emballages transparents et s√©curis√©s qui copient les donn√©es chaque fois que possible, ou utilisent d'autres techniques qui fournissent des garanties de compilation. </p><br><p>  Parfois, il est n√©cessaire d'effectuer une op√©ration qui peut conduire √† une lecture et √† une √©criture simultan√©es, ou √† un acc√®s non s√©curis√© √† la m√©moire, et c'est l√† que la s√©curit√© est n√©cessaire.  Mais tant qu'il y a une possibilit√© de s'assurer que les invariants s√ªrs sont maintenus avant qu'un utilisateur touche quelque chose (c'est-√†-dire dangereux dangereux), tout va bien. </p><br><h1 id="na-chih-plechah-lezhit-eta-otvetstvennost">  Sur qui repose cette responsabilit√©? </h1><br><p>  Nous arrivons √† une d√©claration faite plus t√¥t - <strong>oui</strong> , l'utilit√© du code Rust est bas√©e sur un code dangereux.  Malgr√© le fait que cela soit fait d'une mani√®re l√©g√®rement diff√©rente de l'impl√©mentation non s√©curis√©e des structures de donn√©es de base en Python, l'impl√©mentation de Vec, Hashmap, etc., <strong>devrait</strong> utiliser des manipulations de pointeurs dans une certaine mesure. </p><br><p>  Nous disons que Rust est s√ªr, avec l'hypoth√®se fondamentale que le code dangereux que nous utilisons via nos d√©pendances sur la biblioth√®que standard ou le code d'autres biblioth√®ques est correctement √©crit et encapsul√©.  L'avantage fondamental de Rust est que le code non s√©curis√© est entra√Æn√© dans des blocs non s√©curis√©s qui doivent √™tre soigneusement v√©rifi√©s par leurs auteurs. </p><br><p>  En Python, la charge de v√©rifier la s√©curit√© des manipulations de m√©moire incombe uniquement aux d√©veloppeurs des interpr√®tes et aux utilisateurs des interfaces des fonctions externes.  En C, ce fardeau incombe √† chaque programmeur. </p><br><p>  Dans Rust, il appartient aux utilisateurs du mot-cl√© dangereux.  Cela est √©vident, car les invariants doivent √™tre maintenus manuellement √† l'int√©rieur de ce code, et il est donc n√©cessaire de rechercher la plus petite quantit√© de ce code dans la biblioth√®que ou le code d'application.  L'ins√©curit√© est d√©tect√©e, mise en √©vidence et indiqu√©e.  Par cons√©quent, si des erreurs de segmentation se produisent dans votre code Rust, vous trouvez une erreur dans le compilateur ou une erreur dans plusieurs lignes de votre code non s√©curis√©. </p><br><p>  Ce n'est pas un syst√®me parfait, mais si vous avez besoin de vitesse, de s√©curit√© et de multithreading en m√™me temps, c'est la seule option. </p><p></p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460295/">https://habr.com/ru/post/fr460295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460281/index.html">Comment UX Writer aide √† am√©liorer le produit</a></li>
<li><a href="../fr460283/index.html">Nouveau langage de programmation √† faire soi-m√™me</a></li>
<li><a href="../fr460285/index.html">Nous pr√©parons PHP. Comment sont while, foreach, array_walk et quelques autres mots effrayants</a></li>
<li><a href="../fr460287/index.html">Visualisation des nouvelles de Runet</a></li>
<li><a href="../fr460291/index.html">Probl√®mes de traitement par lots des demandes et leurs solutions (partie 1)</a></li>
<li><a href="../fr460297/index.html">WeakRef - proposition d'ajout √† la norme ECMAScript</a></li>
<li><a href="../fr460301/index.html">Lampes LED haute puissance nouvelle g√©n√©ration</a></li>
<li><a href="../fr460305/index.html">Moteur AERODISK: Catastrophique. Partie 2. Metrocluster</a></li>
<li><a href="../fr460307/index.html">Exp√©rience de mod√©lisation de l'√©quipe Computer Vision Mail.ru</a></li>
<li><a href="../fr460311/index.html">Il est temps pour une nouvelle th√©orie de l'argent</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>