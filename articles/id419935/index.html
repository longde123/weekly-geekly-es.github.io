<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸšµğŸ» ğŸ‘¨ğŸ¿â€ğŸ”¬ ğŸŒ Tepat sekali TIDAK persis sama: analisis artikel ğŸ•´ğŸ» ğŸ‘©ğŸ¼â€ğŸ¤â€ğŸ‘¨ğŸ¿ ğŸ˜“</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 


 Saya memutuskan untuk menganalisis artikel yang menjelaskan beberapa detail menarik dari pemrosesan streaming tepat sekali: tepat seka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tepat sekali TIDAK persis sama: analisis artikel</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419935/"><h2 id="vvedenie">  Pendahuluan </h2><br><p>  Saya memutuskan untuk menganalisis artikel yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menjelaskan beberapa detail menarik dari pemrosesan streaming tepat sekali: tepat sekali</a> .  Faktanya adalah bahwa beberapa penulis memahami istilah-istilah ini dengan sangat aneh.  Analisis artikel akan memungkinkan kami untuk mengklarifikasi banyak detail lebih dalam, karena  identifikasi ketidakkonsistenan dan keanehan memungkinkan Anda untuk lebih memahami konsep dan makna. </p><br><p>  Mari kita mulai. </p><br><h2 id="analiz">  Analisis </h2><br><p>  Semuanya dimulai dengan sangat baik: </p><a name="habracut"></a><br><blockquote> Pemrosesan stream peristiwa yang didistribusikan telah menjadi topik yang semakin panas di bidang Big Data.  Mesin Pemroses Aliran Penting (SPE) termasuk Apache Storm, Apache Flink, Heron, Apache Kafka (Kafka Streams), dan Apache Spark (Spark Streaming).  Salah satu fitur SPE yang paling terkenal dan dibahas secara luas adalah semantik pemrosesan mereka, dengan "tepat-sekali" menjadi salah satu yang paling dicari dan banyak SPE yang mengklaim menyediakan semantik pemrosesan "tepat-sekali". </blockquote><p>  Yaitu, pemrosesan data sangat penting, dll., Dan topik yang dibahas tepat-sekali.  Mari kita bahas. </p><br><blockquote>  Ada banyak kesalahpahaman dan ambiguitas, namun, seputar apa sebenarnya â€œtepat-sekaliâ€ itu, apa yang disyaratkan, dan apa artinya sebenarnya ketika masing-masing SPE mengklaim menyediakannya. </blockquote><p>  Memang, sangat penting untuk memahami apa itu.  Untuk melakukan ini, alangkah baiknya untuk memberikan definisi yang benar sebelum alasan yang panjang.  Dan siapakah saya untuk memberikan nasihat yang bagus? </p><br><blockquote>  Saya akan membahas perbedaan antara semantik pemrosesan "tepat-sekali" di banyak SPE populer dan mengapa "tepat-sekali" dapat lebih baik digambarkan sebagai efektif-sekali </blockquote><p>  Menemukan istilah baru tentu saja merupakan tugas penting.  Saya suka hal ini sendiri.  Hanya untuk ini, pembenaran diperlukan.  Mari kita coba menemukannya. </p><br><p>  Saya tidak akan menggambarkan hal-hal yang jelas sebagai grafik pemrosesan yang diarahkan dan sebagainya.  Pembaca dapat membaca artikel aslinya sendiri.  Apalagi untuk analisis detail-detail ini tidak relevan.  Saya hanya akan memberikan gambar: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/14b/024/a60/14b024a60f1b9403430bd43ff77cb50b.png"></p><br><p>  Selanjutnya, ada deskripsi tentang semantik: </p><br><ul><li>  Paling banyak sekali, yaitu  tidak lebih dari sekali.  Dengan kejelasan yang tampak, perilaku seperti itu sangat sulit untuk dijamin dalam skenario tingkat batas seperti kerusakan, gangguan konektivitas jaringan, dan banyak lagi.  Tetapi bagi penulis semuanya sederhana: </li></ul><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b12/02f/cb0/b1202fcb0c735e893daf0373ba23255e.png"></p><br><ul><li>  Setidaknya-sekali, yaitu  setidaknya sekali.  Skema ini lebih kompleks.  Dan rake dapat dikumpulkan lebih banyak: </li></ul><br><p><img src="https://habrastorage.org/getpro/habr/post_images/879/4cd/bd3/8794cdbd351ae965b267e7a3d51ae761.png"></p><br><ul><li>  Tepat sekali.  Apa itu sekali saja? </li></ul><br><blockquote>  Acara dijamin akan diproses "tepat sekali" oleh semua operator di aplikasi streaming, bahkan jika terjadi berbagai kegagalan. </blockquote><p>  Yaitu  jaminan pemrosesan tepat-sekali adalah ketika pemrosesan "tepat sekali" telah terjadi. </p><br><p>  Rasakan kekuatan tekad?  Untuk ulangi: proses sekali adalah saat proses terjadi â€œsekaliâ€.  Ya, itu juga mengatakan bahwa jaminan ini harus dipertahankan jika terjadi kegagalan.  Tetapi untuk sistem terdistribusi, ini adalah hal yang jelas.  Dan tanda kutip mengisyaratkan bahwa ada sesuatu yang salah di sini.  Mendefinisikan dengan tanda kutip tanpa menjelaskan apa artinya ini adalah tanda pendekatan yang mendalam dan bijaksana. </p><br><p>  Berikut ini adalah deskripsi cara menerapkan semantik tersebut.  Dan di sini saya ingin tinggal lebih detail. </p><br><blockquote>  Dua mekanisme populer biasanya digunakan untuk mencapai pemrosesan semantik "semantik". <br><ol><li>  Pemeriksaan pos kilat / keadaan terdistribusi </li><li>  Setidaknya pengiriman sekali peristiwa ditambah deduplikasi pesan </li></ol><br></blockquote><p>  Jika mekanisme pertama tentang snapshot dan pos pemeriksaan tidak menimbulkan pertanyaan, yah, kecuali untuk beberapa detail seperti efisiensi, maka ada masalah kecil dengan yang kedua yang diabaikan penulis. </p><br><p>  Untuk beberapa alasan, dipahami bahwa pawang hanya bisa deterministik.  Dalam kasus penangan non-deterministik, setiap restart berikutnya akan memberikan, secara umum, nilai-nilai output lain dan menyatakan, yang berarti bahwa deduplikasi tidak akan berfungsi, karena  nilai output akan berbeda.  Dengan demikian, mekanisme umum akan jauh lebih rumit daripada yang dijelaskan dalam artikel.  Atau, sejujurnya, mekanisme seperti itu tidak benar. </p><br><p>  Namun, kami beralih ke yang paling lezat: </p><br><blockquote><h2 id="is-exactly-once-really-exactly-once">  Apakah sekali-sekali benar-benar tepat sekali? </h2><br><br>  Sekarang mari kita periksa kembali apa yang benar-benar menjamin semantik pemrosesan benar-benar menjamin kepada pengguna akhir.  Label "tepat sekali" menyesatkan dalam menggambarkan apa yang dilakukan tepat sekali. </blockquote><p>  Dikatakan bahwa sudah waktunya untuk mempertimbangkan kembali konsep ini, sebagai  ada beberapa ketidakkonsistenan. </p><br><blockquote>  Beberapa orang mungkin berpikir bahwa "tepat sekali" menggambarkan jaminan untuk pemrosesan acara di mana setiap peristiwa dalam aliran diproses hanya sekali.  Pada kenyataannya, tidak ada SPE yang dapat menjamin pemrosesan tepat-sekali.  Untuk menjamin bahwa logika yang ditentukan pengguna di setiap operator hanya dijalankan sekali per peristiwa adalah mustahil dalam menghadapi kegagalan sewenang-wenang, karena eksekusi sebagian dari kode pengguna adalah kemungkinan yang selalu ada. </blockquote><p>  Penulis yang terhormat, perlu diingat cara kerja prosesor modern.  Setiap prosesor dalam pemrosesan melakukan sejumlah besar tahap paralel.  Selain itu, ada cabang di mana prosesor mulai melakukan tindakan yang salah jika prediktor cabang salah.  Dalam hal ini, tindakan dibatalkan.  Dengan demikian, prosesor dapat mengeksekusi potongan kode yang sama dua kali, bahkan jika tidak ada kegagalan yang terjadi! </p><br><p>  Pembaca yang penuh perhatian akan segera berseru: karena knalpot penting, dan bukan bagaimana kinerjanya.  Tepat!  Yang penting adalah apa yang terjadi sebagai akibatnya, bukan bagaimana itu sebenarnya terjadi.  Jika hasilnya seolah-olah itu terjadi tepat sekali, maka itu berarti itu terjadi tepat sekali.  Tidak menemukan?  Dan segala sesuatu yang lain adalah sekam, tidak relevan.  Sistemnya kompleks, dan abstraksi yang dihasilkan hanya menciptakan ilusi eksekusi dengan cara tertentu.  Tampaknya bagi kita bahwa kode dijalankan secara berurutan, instruksi demi instruksi, yang membaca pertama, lalu menulis, lalu instruksi baru.  Tapi tidak demikian, semuanya jauh lebih rumit.  Dan esensi dari abstraksi yang benar adalah untuk mempertahankan ilusi jaminan yang sederhana dan dapat dipahami, tanpa mengambil jauh ke dalam setiap kali, ketika Anda perlu menetapkan nilai ke variabel. </p><br><p>  Dan seluruh masalah dari artikel ini terletak pada fakta bahwa tepat sekali adalah abstraksi yang memungkinkan Anda untuk membangun aplikasi tanpa memikirkan duplikat dan nilai yang hilang.  Semuanya akan baik-baik saja, bahkan jika jatuh.  Dan tidak perlu menemukan istilah baru untuk ini. </p><br><p>  Contoh kode dalam artikel jelas menunjukkan kurangnya pemahaman tentang cara menulis penangan: </p><br><pre><code class="hljs cs">Map (Event <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>) { Print <span class="hljs-string"><span class="hljs-string">"Event ID: "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.getId() Return <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> }</code> </pre> <br><p>  Pembaca diundang untuk menulis ulang kode secara mandiri agar tidak mengulangi kesalahan penulis artikel. </p><br><blockquote>  Jadi apa yang dijamin oleh SPE ketika mereka mengklaim semantik pemrosesan "tepat sekali"?  Jika logika pengguna tidak dapat dijamin akan dieksekusi tepat sekali maka apa yang dieksekusi tepat sekali?  Ketika SPE mengklaim semantik pemrosesan "tepat", yang sebenarnya mereka katakan adalah bahwa mereka dapat menjamin bahwa pembaruan untuk negara yang dikelola oleh SPE hanya dilakukan satu kali ke backend store yang tahan lama. </blockquote><p>  Pengguna tidak perlu jaminan eksekusi fisik kode.  Mengetahui cara kerja prosesor, mudah untuk menyimpulkan bahwa ini tidak mungkin.  Yang utama adalah eksekusi logis tepat sekali, seolah-olah tidak ada kegagalan sama sekali.  Menarik konsep "berkomitmen untuk gudang data" hanya memperburuk kurangnya pemahaman penulis tentang hal-hal dasar, karena  ada implementasi semantik seperti itu tanpa perlu komit. </p><br><p>  Untuk informasi lebih lanjut, Anda dapat membaca secara singkat artikel saya: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemrosesan data kompetitif yang heterogen secara real time hanya sekali</a> . </p><br><blockquote>  Dengan kata lain, pemrosesan suatu peristiwa dapat terjadi lebih dari satu kali tetapi efek dari pemrosesan itu hanya tercermin sekali di toko backend state yang tahan lama. </blockquote><p>  Bahwa ada "toko backend negara tahan lama" bagi pengguna benar-benar ungu.  Hanya efek pemrosesan yang penting, mis.  nilai konsistensi dan output pada seluruh rentang pemrosesan data streaming.  Perlu dicatat bahwa untuk beberapa tugas tidak perlu memiliki toko negara backend tahan lama, dan akan menyenangkan untuk menjamin tepat sekali. </p><br><blockquote>  Di sini, di Streamlio, kami telah memutuskan bahwa secara efektif-sekali adalah istilah terbaik untuk menggambarkan semantik pemrosesan ini. </blockquote><p>  Contoh tipikal dari input konsep yang bodoh: kami akan menulis beberapa contoh dan argumen panjang untuk seluruh paragraf, dan pada akhirnya kami akan menambahkan bahwa "kami mendefinisikan konsep ini".  Keakuratan dan kejelasan definisi menyebabkan respons emosional yang benar-benar jelas. </p><br><h2 id="vyvody">  Kesimpulan </h2><br><p>  Kesalahpahaman tentang esensi abstraksi menyebabkan distorsi makna asli dari konsep yang ada dan penciptaan istilah baru berikutnya dari awal. </p><br><p>  [1] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tepat sekali TIDAK persis sama</a> . <br>  [2] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemrosesan data kompetitif real-time heterogen hanya dilakukan satu kali</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419935/">https://habr.com/ru/post/id419935/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419925/index.html">Kontrol versi file individual menggunakan GitHub Gist</a></li>
<li><a href="../id419927/index.html">[DotNetBook] Pengecualian: Jenis Arsitektur Sistem</a></li>
<li><a href="../id419929/index.html">[DotNetBook] Acara pengecualian dan cara mendapatkan StackOverflow dan ExecutionEngineException dari awal</a></li>
<li><a href="../id419931/index.html">[DotNetBook] Saatnya menghibur cerita: situasi yang sangat luar biasa</a></li>
<li><a href="../id419933/index.html">Cara melakukan pencarian pengguna di Github menggunakan Angular</a></li>
<li><a href="../id419939/index.html">Bagaimana saya membuat navigasi di Bereaksi Asli tidak begitu mengerikan</a></li>
<li><a href="../id419941/index.html">Tur Foto Kantor Audiomania: Bagian Satu</a></li>
<li><a href="../id419943/index.html">Apa yang kami baca di bulan Juli: bagaimana menemukan waktu untuk membaca, lima buku untuk memimpin tim dan beberapa artikel baru</a></li>
<li><a href="../id419945/index.html">Cara mempersiapkan wawancara di Google dan tidak meneruskannya. Dua kali</a></li>
<li><a href="../id419947/index.html">Terhubung ke PiZeroW dengan Raspbian Stretch Lite, tanpa adaptor tambahan dan monitor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>