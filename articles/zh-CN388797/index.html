<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🎓 🤜🏿 👩‍🎨 神经网络作为激活数据库 👯 🛀🏽 📆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="为了使神经网络上的AI通用，您需要了解神经网络不足以实现多功能性。为此，请尝试在神经网络上实现所有程序的完整执行。这将需要条件转换，条件，读写数据结构。之后，将有可能创建面向对象的神经网络。文章将必须分为几部分。
 
 
 
 考虑不同类型的神经簇。感觉和效应簇已经被提及。
 如果为And，则仅在所...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>神经网络作为激活数据库</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/388797/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了使神经网络上的AI通用，您需要了解神经网络不足以实现多功能性。</font><font style="vertical-align: inherit;">为此，请尝试在神经网络上实现所有程序的完整执行。</font></font><a name="habracut"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这将需要条件转换，条件，读写数据结构。之后，将有可能创建面向对象的神经网络。文章将必须分为几部分。</font></font><br>
<br>
<img src="https://habrastorage.org/files/2d5/e88/3a7/2d5e883a7409431d991dd172396c065a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考虑不同类型的神经簇。感觉和效应簇已经被提及。</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则</font><font style="vertical-align: inherit;">仅在所有条件都有效的情况下才激活它-即，信号已到达所有突触。</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-如果至少一项功能已激活则触发。</font><font style="vertical-align: inherit;">如果此群集是链的一部分，则必须进行反向链接-它通过And条件连接。</font><font style="vertical-align: inherit;">换句话说，仅当链中的上一个集群处于活动状态并且其自身的任何条件也有效时，集群才被激活。</font><font style="vertical-align: inherit;">与编程语言类似，链式通信在中央处理器中充当指令指针-信号“我允许执行集群的其余条件”。</font><font style="vertical-align: inherit;">让我们看一些代码。</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NC类; //神经簇</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
类链接{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	公开：</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
		NC＆_from;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
		NC＆_to;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
		...</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
};</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Class LinksO; / *传出链接的容器。</font><font style="vertical-align: inherit;">基于boost :: intrusive方便做</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -节省内存并提高性能* /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
class LinksI; //也基于boost :: intrusive</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结构NeuronA1 {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	qreal _activation = 0;</font></font><font></font>
	static const qreal _threashold = 1;//          ,   .<font></font>
	bool activated()const {<font></font>
		return _activation &gt;= _threshold;<font></font>
	}<font></font>
};<font></font>
struct NeuronAT {<font></font>
	qreal _activation = 0;<font></font>
	qreal _threashold = 1;//  <font></font>
	bool activated()const {<font></font>
		return _activation &gt;= _threshold;<font></font>
	}<font></font>
};<font></font>
class NC {<font></font>
	public:<font></font>
		LinksO _next;<font></font>
		LinksO _down;<font></font>
		<font></font>
		LinksI _prev;<font></font>
		LinksI _up;<font></font>
		<font></font>
		NeuronA1 _nrnSumPrev;<font></font>
		NeuronAT _nrnSumFromBottom;<font></font>
		...<font></font>
}<font></font>
//  ,     _nrnSumPrev:<font></font>
void NC::sendActivationToNext() {<font></font>
	for(Link&amp; link: _next) {<font></font>
		link._to._nrnSumPrev._activation += 1;<font></font>
	}<font></font>
}<font></font>
//      - and/or/not  :<font></font>
bool NC::allowedToActivateByPrevChain()const {<font></font>
	if(_prev.isEmpty())//    ,    ,    .<font></font>
		return true;//    ,     .<font></font>
	return _nrnSumPrev.activated();<font></font>
	//         ,         .<font></font>
	//      0    .<font></font>
	// -     ,   -     ,    .<font></font>
}<font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，在_prev中通常没有链接或只有一个链接。</font><font style="vertical-align: inherit;">这使前缀树脱离了内存链：在_next中，可以有任意数量的链接，而在_prev中，可以有不超过一个。</font><font style="vertical-align: inherit;">仅在普通的前缀树中，每个位置只有一个字母，而在神经网络中则存在任意数量的字符。</font><font style="vertical-align: inherit;">因此，即使存储Zalizniak的字典也不会占用太多内存。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，为了方便起见，我们将继续进行，以便以后不必重写此类代码，我们将立即消除神经元和激活。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果集群以某种方式保留了激活历史记录，并且没有将其激活发送给其他集群，我们可以这样重写该函数：</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bool NC :: allowedToActivateByPrevChain（）const {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	对于（链接和链接：_prev）{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
		NC＆nc = link._from;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
		if（！nc.wasActivated（））//检查最后一个周期</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
			返回false；</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	返回true；</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font><font></font>
</pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，许多问题将立即消失：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1）经过几个预测周期后，无需恢复神经网络的状态-集群既存储又存储有关相应周期的激活信息。</font><font style="vertical-align: inherit;">可以更频繁地包括更长的时间进行预测。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2）神经网络可以抵抗变化：如果将与集群的连接延迟地添加到集群中，则无需再次发送信号来总结目标集群上的激活-您可以立即检查条件。</font><font style="vertical-align: inherit;">该代码变得更加功能化-副作用最少。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3）可以引入任意信号延迟：如果激活缓存可以存储不同周期的数据，则可以检查N个周期之前的集群是否处于活动状态。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为此，向连接添加一个可变参数-延迟时间：</font></font><br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类链接{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	...</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	int _delay = 1;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
};</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后像下面这样修改函数：</font></font><br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bool NC :: allowedToActivateByPrevChain（）const {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	对于（链接和链接：_prev）{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
		NC＆nc = link._from;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
		if（！nc.wasActivated（link._delay））//检查N个循环</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
			返回false；</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	返回true；</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font><font></font>
</pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4）我们摆脱了口吃的“院子里的草，草上的柴草……”：来自新周期的信号不会覆盖旧周期，反之亦然。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5）没有激活会在需要时消失的危险（它本身会不时地消失）。您可以很早地检查条件。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6）最后，您无法撰写关于“通过有节奏的活动管理进行神经网络管理”，“脑电图控制信号的可视化方法”，“用于控制脑电图的特殊DSL”主题的十几篇文章，而仅此而已：</font></font><br>
<br>
<img src="https://habrastorage.org/files/336/ca1/603/336ca1603ec045669a4bee480b32544d.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，关于实现这种激活缓存：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1）ENS为我们提供了三个放置激活缓存的选项：当前神经团簇中其神经元的激活，激活（以识别波的形式？）在海马中（此处存储的时间长于簇本身的存储时间）以及长期记忆。事实证明，就像现代处理器一样，三级缓存也是如此。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2）在软件模型中，乍一看激活缓存位于每个集群中。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3）更具体地说，我们已经知道：该模型中的海马建立了一条记忆链，并且到该时刻处于活动状态且未被抑制的所有群集的链接都被输入到记忆链中。</font><font style="vertical-align: inherit;">每个连接作为传出存储在一个群集中，而作为传入存储在另一个群集中。</font><font style="vertical-align: inherit;">这表明“高速缓存”实际上不是高速缓存，而是长期存储器。</font><font style="vertical-align: inherit;">只有生物神经网络无法通过激活直接从长期记忆中提取信息，而人工神经网络则可以。</font><font style="vertical-align: inherit;">这是AI相对ENS的优势，这是不可使用的，这很愚蠢-如果我们需要语义信息，为什么还要打扰激活呢？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，要检查集群是否向后退了N个活动状态，可以使用以下（未优化的）伪代码：</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NC * Brain :: _ hippo; //当前事件已添加到的当前簇</font></font><font></font>
NC* NC::prevNC(int stepsBack)const {<font></font>
	//       _prev<font></font>
	//   link._delay,       .<font></font>
	// , () <font></font>
}<font></font>
bool NC::wasActivated(int stepsAgo)const {<font></font>
	NC* timeStamp = _brain._hippo-&gt;prevNC(stepsAgo);<font></font>
	if(!timeStamp)//       <font></font>
		return false;<font></font>
	return linkExists(timeStamp, this);<font></font>
//      ,   boost    intrusive ,<font></font>
//  ,    node    2  3 <font></font>
}<font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果不是必须取消激活，而不仅要保留连接的存在，而且还必须保持激活力，那么可以将相应的字段添加到连接本身。其他领域也可以用于此目的，而无需引入其他领域：例如，通信寿命所依赖的“重要性”。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，对于那些激活没有达到阈值但仍然有用的集群，例如对于模糊识别或概率的错误计算等，该怎么办？未优化的解决方案是使用所有相同的连接。为此，请在群集中创建其他链接容器，然后在其中添加它们（以免与正常工作的容器混合在一起），或者甚至干扰堆中的所有内容，并仅通过强制分离它们。由于此类连接比其他连接大一个数量级，因此需要更快地将其删除。一种更优化的解决方案：每个群集存储一个普通的激活缓存-例如，由16个元素组成的循环缓冲区（环形），其中每个元素都存储一个循环编号和该循环的激活力。有两级缓存：对于弱信号，亚阈值和最新缓存-集群中的缓冲区，否则，请进行长期记忆通信。不要忘记，在这些文章中仅显示了伪代码和朴素算法，并且优化问题会占用更多空间。</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN388797/">https://habr.com/ru/post/zh-CN388797/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN388785/index.html">自动将文章从Microsoft Word传输到Geektimes</a></li>
<li><a href="../zh-CN388787/index.html">Nvidia Drive PX 2自动驾驶汽车超级计算机</a></li>
<li><a href="../zh-CN388789/index.html">不粘手：在GStarCAD上安装AutoCAD-a插件</a></li>
<li><a href="../zh-CN388791/index.html">关于苹果iCar的创建的谣言变得更加合理</a></li>
<li><a href="../zh-CN388793/index.html">盲人选手度过了五年的时间陶笛</a></li>
<li><a href="../zh-CN388799/index.html">科学家发现恒星中的强磁场并不少见，但有规律可循</a></li>
<li><a href="../zh-CN388801/index.html">首次使用CRISPR技术可以对成年哺乳动物进行基因治疗</a></li>
<li><a href="../zh-CN388803/index.html">卡西尼号在一张照片中捕获了土星的三颗卫星</a></li>
<li><a href="../zh-CN388805/index.html">这是科学：微米枪和纳米核</a></li>
<li><a href="../zh-CN388807/index.html">对microSD存储卡的支持将返回至三星Galaxy S7和S7 Edge</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>