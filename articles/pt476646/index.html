<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>„Ä∞Ô∏è üòî üíº Mesclagem de 3 vias no werf: implanta√ß√£o no Kubernetes com Helm "on steroids" üò£ üõåüèΩ üöØ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aconteceu algo que n√≥s (e n√£o apenas n√≥s) est√°vamos esperando: werf , nosso utilit√°rio de c√≥digo aberto para criar aplicativos e entreg√°-los ao Kubern...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mesclagem de 3 vias no werf: implanta√ß√£o no Kubernetes com Helm "on steroids"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/476646/"> Aconteceu algo que n√≥s (e n√£o apenas n√≥s) est√°vamos esperando: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">werf</a> , nosso utilit√°rio de c√≥digo aberto para criar aplicativos e entreg√°-los ao Kubernetes, agora suporta a aplica√ß√£o de altera√ß√µes usando patches de mesclagem de 3 vias!  Al√©m disso, tornou-se poss√≠vel adotar os recursos existentes do K8s nas vers√µes Helm sem recriar esses recursos. <br><br><img src="https://habrastorage.org/webt/os/yc/op/osycopyy-kknbg7fnwuf8cjohxi.png"><br><br>  Se for muito curto, defina <code>WERF_THREE_WAY_MERGE=enabled</code> - obtemos a implanta√ß√£o "como no <code>kubectl apply</code> ", compat√≠vel com as instala√ß√µes existentes no Helm 2 e at√© um pouco mais. <br><br>  Mas vamos come√ßar com a teoria: o que s√£o patches de 3 vias em geral, como as pessoas chegaram √† abordagem com sua gera√ß√£o e por que elas s√£o importantes nos processos de CI / CD com infraestrutura baseada em Kubernetes?  E depois disso - vamos ver o que √© a fus√£o de tr√™s vias no werf, quais modos s√£o usados ‚Äã‚Äãpor padr√£o e como gerenci√°-lo. <a name="habracut"></a><br><br><h2>  O que √© um patch de 3 vias de mesclagem? </h2><br>  Ent√£o, vamos come√ßar com a tarefa de implantar os recursos descritos nos manifestos YAML no Kubernetes. <br><br>  Para trabalhar com recursos, a API do Kubernetes oferece as seguintes opera√ß√µes b√°sicas: criar, corrigir, substituir e excluir.  Sup√µe-se que, com a ajuda deles, seja necess√°rio construir uma implementa√ß√£o cont√≠nua e conveniente de recursos para o cluster.  Como <br><br><h3>  Equipas imperativas do kubectl </h3><br>  A primeira abordagem para gerenciar objetos no Kubernetes √© usar os comandos imperativos do kubectl para criar, modificar e excluir esses objetos.  Simplificando: <br><br><ul><li>  <code>kubectl run</code> comando <code>kubectl run</code> pode executar Deployment ou Job: <br><br><pre> <code class="bash hljs">kubectl run --generator=deployment/apps.v1 DEPLOYMENT_NAME --image=IMAGE</code> </pre> </li><li>  <code>kubectl scale</code> - altere o n√∫mero de r√©plicas: <br><br><pre> <code class="bash hljs">kubectl scale --replicas=3 deployment/mysql</code> </pre> </li><li>  etc. </li></ul><br>  Essa abordagem pode parecer conveniente √† primeira vista.  No entanto, existem problemas: <br><br><ol><li>  √â dif√≠cil de <b>automatizar</b> . </li><li>  Como <b>refletir a configura√ß√£o</b> no Git?  Como revisar as altera√ß√µes que ocorrem em um cluster? </li><li>  Como garantir a <b>reprodutibilidade da</b> configura√ß√£o na reinicializa√ß√£o? </li><li>  ... </li></ol><br>  √â claro que essa abordagem n√£o se encaixa bem em armazenar c√≥digo e infraestrutura de aplicativos como c√≥digo (IaC; ou mesmo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitOps</a> como uma op√ß√£o mais moderna, ganhando popularidade no ecossistema Kubernetes).  Portanto, essas equipes n√£o receberam mais desenvolvimentos no kubectl. <br><br><h3>  Criar, obter, substituir e excluir opera√ß√µes </h3><br>  Com a <b>cria√ß√£o</b> prim√°ria <b>,</b> tudo √© simples: enviamos o manifesto para a opera√ß√£o de cria√ß√£o do kube api e o recurso √© criado.  A representa√ß√£o YAML do manifesto pode ser armazenada no Git e, para criar, use o comando <code>kubectl create -f manifest.yaml</code> . <br><br>  <b>A exclus√£o</b> tamb√©m <b>√©</b> simples: substitu√≠mos o mesmo <code>manifest.yaml</code> do Git pelo comando <code>kubectl delete -f manifest.yaml</code> . <br><br>  A opera√ß√£o de <b><code>replace</code></b> permite substituir completamente a configura√ß√£o do recurso por uma nova, sem recriar o recurso.  Isso significa que, antes de fazer uma altera√ß√£o em um recurso, √© l√≥gico solicitar a vers√£o atual com a opera√ß√£o <code>get</code> , alter√°-la e atualizar com a opera√ß√£o de <code>replace</code> .  O bloqueio otimista √© incorporado ao kube apiserver e, se o objeto tiver sido alterado ap√≥s a opera√ß√£o <code>get</code> , a opera√ß√£o de <code>replace</code> falhar√°. <br><br>  Para armazenar a configura√ß√£o no Git e atualizar usando o replace, voc√™ precisa <code>get</code> uma opera√ß√£o <code>get</code> , manter a configura√ß√£o do Git com o que obtivemos e executar a <code>replace</code> .  Normalmente, o kubectl permite apenas usar o <code>kubectl replace -f manifest.yaml</code> , em que <code>manifest.yaml</code> √© o <code>manifest.yaml</code> totalmente preparado (no nosso caso, anexo) que voc√™ precisa instalar.  Acontece que o usu√°rio precisa implementar manifestos de mesclagem, mas isso n√£o √© uma quest√£o trivial ... <br><br>  Tamb√©m √© importante notar que, embora <code>manifest.yaml</code> esteja armazenado no Git, n√£o podemos saber antecipadamente se precisamos criar um objeto ou atualiz√°-lo - isso deve ser feito pelo software do usu√°rio. <br><br>  Conclus√£o: <b>podemos criar uma implementa√ß√£o cont√≠nua</b> apenas com criar, substituir e excluir, garantindo que a configura√ß√£o da infraestrutura seja armazenada no Git, juntamente com o c√≥digo e um CI / CD conveniente? <br><br>  Basicamente, podemos ... Para fazer isso, <b>precisamos implementar a opera√ß√£o de mesclagem dos</b> manifestos e algum tipo de liga√ß√£o que: <br><br><ul><li>  verifica a presen√ßa de um objeto no cluster, </li><li>  executa a cria√ß√£o inicial do recurso, </li><li>  atualiza ou exclui. </li></ul><br>  Ao atualizar, √© necess√°rio considerar que o <i>recurso pode ter sido alterado</i> desde a √∫ltima <code>get</code> e lidar automaticamente com o caso de bloqueio otimista - fa√ßa repetidas tentativas de atualiza√ß√£o. <br><br>  No entanto, por que reinventar a roda quando o kube-apiserver oferece outra maneira de atualizar os recursos: a opera√ß√£o de <code>patch</code> , que remove alguns dos problemas descritos pelo usu√°rio? <br><br><h3>  Patch </h3><br>  Ent√£o chegamos aos remendos. <br><br>  Os patches s√£o a principal maneira de aplicar altera√ß√µes aos objetos existentes no Kubernetes.  A opera√ß√£o de <code>patch</code> funciona para que: <br><br><ul><li>  O usu√°rio do kube-apiserver precisa enviar o patch no formato JSON e especificar o objeto, </li><li>  e o pr√≥prio apiserver ir√° lidar com o estado atual do objeto e traz√™-lo para a forma desejada. </li></ul><br>  O bloqueio otimista neste caso n√£o √© necess√°rio.  Essa opera√ß√£o √© mais declarativa em compara√ß√£o √† substitui√ß√£o, embora a princ√≠pio possa parecer o contr√°rio. <br><br>  Desta forma: <br><br><ul><li>  usando a opera√ß√£o <code>create</code> , criamos um objeto a partir do manifesto do Git, </li><li>  using <code>delete</code> - delete se o objeto n√£o for mais necess√°rio, </li><li>  using <code>patch</code> - modificamos o objeto, trazendo-o para o formul√°rio descrito no Git. </li></ul><br>  No entanto, para fazer isso, voc√™ deve criar o <i>patch correto</i> ! <br><br><h3>  Como os patches funcionam no Helm 2: mesclagem bidirecional </h3><br>  Na primeira vez que um release √© instalado, o Helm executa uma opera√ß√£o de <code>create</code> nos recursos do gr√°fico. <br><br>  Ao atualizar o release do Helm para cada recurso: <br><br><ul><li>  conta o patch entre a vers√£o do recurso do gr√°fico anterior e a vers√£o atual do gr√°fico, </li><li>  aplica esse patch. </li></ul><br>  Vamos chamar esse patch <b>de</b> patch <b>de mesclagem de 2 vias</b> , porque 2 manifestos participam de sua cria√ß√£o: <br><br><ul><li>  Manifesto de recursos da vers√£o anterior, </li><li>  O manifesto do recurso do recurso atual. </li></ul><br>  Ao excluir, a opera√ß√£o de <code>delete</code> no kube apiserver √© chamada para recursos que foram declarados no release anterior, mas n√£o declarados no atual. <br><br>  A abordagem com o patch de mesclagem bidirecional tem um problema: leva √† <b>dessincroniza√ß√£o do estado real do recurso no cluster e do manifesto no Git</b> . <br><br><h3>  Um exemplo de um problema </h3><br><ul><li>  No Git, um manifesto √© armazenado no gr√°fico no qual o campo <code>image</code> Implanta√ß√£o possui o valor do <code>ubuntu:18.04</code> . </li><li>  O usu√°rio atrav√©s do <code>kubectl edit</code> alterou o valor desse campo para <code>ubuntu:19.04</code> . </li><li>  Quando voc√™ reimplanta o gr√°fico, o Helm <i>n√£o gera um patch</i> , porque o campo de <code>image</code> na vers√£o anterior da libera√ß√£o e no gr√°fico atual √© o mesmo. </li><li>  Ap√≥s a implanta√ß√£o repetida da <code>image</code> , o <code>ubuntu:19.04</code> permanece, embora o <code>ubuntu:18.04</code> esteja escrito no gr√°fico. </li></ul><br>  Temos dessincroniza√ß√£o e perdemos a declaratividade. <br><br><h3>  O que √© um recurso sincronizado? </h3><br>  De um modo geral, √© imposs√≠vel obter uma correspond√™ncia <i>completa</i> entre um manifesto de recurso em um cluster em execu√ß√£o e um manifesto do Git.  Como no manifesto real, pode haver anota√ß√µes / r√≥tulos de servi√ßo, cont√™ineres adicionais e outros dados adicionados e exclu√≠dos dinamicamente por alguns controladores do recurso.  N√£o podemos e n√£o queremos manter esses dados no Git.  No entanto, queremos que, ao lan√ßar, os campos especificados explicitamente no Git tenham valores apropriados. <br><br>  Acontece esta <b>regra</b> geral <b>de um recurso sincronizado</b> : quando voc√™ lan√ßa um recurso, pode alterar ou excluir apenas os campos explicitamente especificados no manifesto do Git (ou foram registrados na vers√£o anterior, mas agora s√£o exclu√≠dos). <br><br><h3>  Patch de 3 vias para mesclagem </h3><br>  A ideia principal do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">patch de mesclagem de 3 vias</a> : geramos um patch entre a √∫ltima vers√£o aplicada do manifesto do Git e a vers√£o de destino do manifesto do Git, levando em considera√ß√£o a vers√£o atual do manifesto do cluster de trabalho.  O patch final deve estar em conformidade com a regra de recurso sincronizado: <br><br><ul><li>  novos campos adicionados √† vers√£o de destino s√£o adicionados usando o patch; </li><li>  campos anteriormente existentes na √∫ltima vers√£o aplicada e n√£o existentes no campo de destino s√£o redefinidos usando o patch; </li><li>  Os campos na vers√£o atual do objeto que diferem da vers√£o de destino do manifesto s√£o atualizados usando o patch. </li></ul><br>  √â por esse princ√≠pio que o <code>kubectl apply</code> patches √© gerado: <br><br><ul><li>  a √∫ltima vers√£o aplicada do manifesto √© armazenada na anota√ß√£o do pr√≥prio objeto, </li><li>  target - extra√≠do do arquivo YAML especificado, </li><li>  atual - de um cluster de trabalho. </li></ul><br>  Agora que descobrimos a teoria, √© hora de contar o que fizemos no werf. <br><br><h2>  Aplicar altera√ß√µes ao werf </h2><br>  Antes, o werf, como o Helm 2, usava patches de duas vias. <br><br><h3>  Patch de reparo </h3><br>  Para mudar para um novo tipo de patches - 3-way-merge - a primeira etapa, introduzimos os chamados <b>patches de reparo</b> . <br><br>  Ao implantar, o patch padr√£o de mesclagem bidirecional √© usado, mas o werf gera adicionalmente um patch que sincroniza o estado real do recurso com o que est√° escrito no Git (esse patch √© criado usando a mesma regra de recurso sincronizado descrita acima). <br><br>  No caso de um rassynchron, no final da implanta√ß√£o, o usu√°rio recebe um WARNING com a mensagem e o patch apropriados, que devem ser aplicados para levar o recurso a um formul√°rio sincronizado.  Al√©m disso, esse patch √© gravado em uma anota√ß√£o especial <code>werf.io/repair-patch</code> .  Sup√µe-se que o <b>pr√≥prio</b> usu√°rio aplicar√° esse patch com as m√£os: werf n√£o o aplicar√° em princ√≠pio. <br><br>  A gera√ß√£o de patches de reparo √© uma medida tempor√°ria que permite testar a cria√ß√£o de patches com base no princ√≠pio da mesclagem de 3 vias, mas n√£o os aplica automaticamente.  No momento, esse modo de opera√ß√£o est√° ativado por padr√£o. <br><br><h3>  Patch de 3 vias para mesclagem apenas para novos lan√ßamentos </h3><br>  A partir de 1¬∫ de dezembro de 2019, as vers√µes beta e alfa do werf come√ßam <b>por padr√£o a</b> usar patches completos de mesclagem de 3 vias para aplicar altera√ß√µes somente para novas vers√µes do Helm lan√ßadas via werf.  As vers√µes existentes continuar√£o a usar a abordagem de corre√ß√£o de mesclagem bidirecional + reparo. <br><br>  Voc√™ pode ativar esse modo de opera√ß√£o explicitamente, definindo <code>WERF_THREE_WAY_MERGE_MODE=onlyNewReleases</code> agora. <br><br>  <i><b>Nota</b> : o recurso apareceu no werf em v√°rias vers√µes: no canal alfa, ficou pronto a partir da vers√£o <a href="">v1.0.5-alpha.19</a> , e no canal beta com a <a href="">v1.0.4-beta.20</a> .</i> <br><br><h3>  Patch de 3 vias para todas as vers√µes </h3><br>  A partir de 15 de dezembro de 2019, as vers√µes beta e alfa do werf come√ßam a usar patches completos de 3 vias de mesclagem por padr√£o para aplicar altera√ß√µes em todas as vers√µes. <br><br>  Este modo de opera√ß√£o pode ser <code>WERF_THREE_WAY_MERGE_MODE=enabled</code> explicitamente <code>WERF_THREE_WAY_MERGE_MODE=enabled</code> definindo <code>WERF_THREE_WAY_MERGE_MODE=enabled</code> agora. <br><br><h3>  O que fazer com os recursos de dimensionamento autom√°tico? </h3><br>  O Kubernetes possui 2 tipos de dimensionamento autom√°tico: HPA (horizontal) e VPA (vertical). <br><br>  Horizontal seleciona automaticamente o n√∫mero de r√©plicas, vertical - o n√∫mero de recursos.  O n√∫mero de r√©plicas e os requisitos de recursos s√£o especificados no manifesto do recurso (consulte <code>spec.replicas</code> ou <code>spec.containers[].resources.limits.cpu</code> , <code>spec.containers[].resources.limits.memory</code> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">outros</a> ). <br><br>  Problema: se um usu√°rio configurar um recurso no gr√°fico para que ele exiba valores espec√≠ficos para recursos ou r√©plicas e auto-scalers sejam ativados para esse recurso, em cada implanta√ß√£o o werf redefinir√° esses valores para o que est√° escrito no manifesto do gr√°fico. <br><br>  Existem duas solu√ß√µes para o problema.  Para iniciantes, √© melhor descartar os valores de escala autom√°tica especificados explicitamente no manifesto do gr√°fico.  Se por algum motivo essa op√ß√£o n√£o se encaixar (por exemplo, porque √© conveniente definir os limites iniciais de recursos e o n√∫mero de r√©plicas no gr√°fico), o werf oferece as seguintes anota√ß√µes: <br><br><ul><li> <code>werf.io/set-replicas-only-on-creation=true</code> </li> <li> <code>werf.io/set-resources-only-on-creation=true</code> </li> </ul><br>  Se essa anota√ß√£o estiver presente, o werf n√£o redefinir√° os valores correspondentes em cada implementa√ß√£o, mas somente os definir√° na cria√ß√£o inicial do recurso. <br><br>  Para obter mais informa√ß√µes, consulte a documenta√ß√£o do projeto para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HPA</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">VPA</a> . <br><br><h3>  Negar o uso do patch de 3 vias </h3><br>  O usu√°rio ainda pode proibir o uso de novas corre√ß√µes no werf usando a vari√°vel de ambiente <code>WERF_THREE_WAY_MERGE_MODE=disabled</code> .  No entanto, a partir <b>de 1¬∫ de mar√ßo de 2020, essa proibi√ß√£o deixar√° de funcionar</b> e s√≥ ser√° poss√≠vel usar patches de 3 vias. <br><br><h2>  Ado√ß√£o de recursos no werf </h2><br>  O dom√≠nio do m√©todo de aplica√ß√£o de altera√ß√µes nos patches de mesclagem de 3 vias nos permitiu implementar imediatamente um recurso como a ado√ß√£o de recursos existentes no cluster no Helm-release. <br><br>  O leme 2 tem um problema: voc√™ n√£o pode adicionar a um manifesto de gr√°fico um recurso que j√° existe no cluster sem recriar esse recurso do zero (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="># 6031</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="># 3275</a> ).  Ensinamos o werf a aceitar os recursos existentes em um release.  Para fazer isso, voc√™ precisa definir uma anota√ß√£o na vers√£o atual do recurso de um cluster em execu√ß√£o (por exemplo, usando o <code>kubectl edit</code> ): <br><br><pre> <code class="plaintext hljs">"werf.io/allow-adoption-by-release": RELEASE_NAME</code> </pre> <br>  Agora, o recurso precisa ser descrito no gr√°fico e, na pr√≥xima implanta√ß√£o, pelo werf release do release com o nome correspondente, o recurso existente ser√° aceito neste release e permanecer√° sob seu controle.  Al√©m disso, no processo de aceita√ß√£o do recurso para libera√ß√£o, o werf levar√° o estado atual do recurso do cluster de trabalho para o estado descrito no gr√°fico usando os mesmos patches de mesclagem de 3 vias e a regra do recurso sincronizado. <br><br>  <i><b>Nota</b> : a configura√ß√£o de <code>WERF_THREE_WAY_MERGE_MODE</code> n√£o afeta a ado√ß√£o de recursos - no caso de ado√ß√£o, sempre √© usado um patch de mesclagem de 3 vias.</i> <br><br>  Os detalhes est√£o na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o</a> . <br><br><h2>  Conclus√µes e planos futuros </h2><br>  Espero que, ap√≥s este artigo, tenha ficado mais claro o que s√£o os patches de 3 vias e por que eles vieram para eles.  Do ponto de vista pr√°tico do desenvolvimento do projeto werf, sua implementa√ß√£o foi mais um passo no sentido de melhorar a implanta√ß√£o do tipo Helm.  Agora voc√™ pode esquecer os problemas com a sincroniza√ß√£o da configura√ß√£o, que costumavam ocorrer ao usar o Helm 2. Ao mesmo tempo, foi adicionado um novo recurso √∫til da ado√ß√£o dos recursos do Kubernetes j√° carregados na vers√£o do Helm. <br><br>  Ainda existem alguns problemas e dificuldades na implanta√ß√£o do Helm, como o uso de modelos Go, e continuaremos a resolv√™-los. <br><br>  Informa√ß√µes sobre m√©todos de atualiza√ß√£o de recursos e ado√ß√£o tamb√©m podem ser encontradas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nesta p√°gina de documenta√ß√£o</a> . <br><br><h3>  Elmo 3 </h3><br>  Uma observa√ß√£o especial √© digna da nova vers√£o principal do Helm - v3 - lan√ßada recentemente, que tamb√©m usa patches de 3 vias e se livra do Tiller.  A nova vers√£o do Helm requer a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">migra√ß√£o de</a> instala√ß√µes existentes para convert√™-las em um novo formato de armazenamento de release. <br><br>  A Werf, por sua vez, agora eliminou o uso do Tiller, mudou para a combina√ß√£o de tr√™s vias e adicionou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">muito mais</a> , mantendo-se compat√≠vel com as instala√ß√µes existentes no Helm 2 (nenhum script de migra√ß√£o √© necess√°rio).  Portanto, at√© que o werf seja alternado para o Helm 3, os usu√°rios do werf n√£o perdem as principais vantagens do Helm 3 sobre o Helm 2 (eles tamb√©m existem no werf). <br><br>  No entanto, a mudan√ßa do werf para a base de c√≥digo do Helm 3 √© inevit√°vel e ocorrer√° em um futuro pr√≥ximo.  Presumivelmente, ser√° werf 1.1 ou werf 1.2 (no momento, a vers√£o principal do werf √© 1.0; para mais detalhes sobre o dispositivo de vers√£o do werf, veja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ).  Durante esse per√≠odo, o Leme 3 ter√° tempo para se estabilizar. <br><br><h2>  PS </h2><br>  Leia tamb√©m em nosso blog: <br><br><ul><li>  Uma s√©rie de notas sobre inova√ß√µes no werf: <br><ul><li>  ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Usando o werf para implementar gr√°ficos Helm complexos</a> ‚Äù; </li><li>  ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Suporte para monorepo e multirepo no werf e o que o Docker Registry tem a ver com isso</a> ‚Äù; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Agora voc√™ pode criar imagens do Docker no werf usando o Dockerfile usual</a> ." </li></ul></li><li>  ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Werf √© a nossa ferramenta de CI / CD no Kubernetes (revis√£o e reportagem em v√≠deo)</a> ‚Äù; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Montagem e implanta√ß√£o do mesmo tipo de microsservi√ßos com werf e GitLab CI</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Apresentando o Helm 3.</a> " </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt476646/">https://habr.com/ru/post/pt476646/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt476626/index.html">PVS-Studio nas nuvens: GitLab CI / CD</a></li>
<li><a href="../pt476628/index.html">O PVS-Studio vai para as nuvens: GitLab CI / CD</a></li>
<li><a href="../pt476636/index.html">Ajustando Firebird e Linux para um banco de dados de 691 GB de tamanho com mais de 1000 usu√°rios</a></li>
<li><a href="../pt476640/index.html">Protegendo o Zimbra OSE da for√ßa bruta e ataques de DoS</a></li>
<li><a href="../pt476644/index.html">Camadas de idioma</a></li>
<li><a href="../pt476648/index.html">Lenovo na FINOPOLIS 2019</a></li>
<li><a href="../pt476650/index.html">Enum lugar no moderno mundo em mudan√ßa</a></li>
<li><a href="../pt476656/index.html">26 de novembro de Moscou - Alfa JS MeetUP # 3</a></li>
<li><a href="../pt476658/index.html">VPS com uma placa de v√≠deo (parte 2): recursos de computa√ß√£o</a></li>
<li><a href="../pt476664/index.html">oktech: Frontend Meetup # 2: mini entrevistas com oradores</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>