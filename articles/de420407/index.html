<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òπÔ∏è ‚ö†Ô∏è üåè C ist keine einfache Sprache üëÜüèæ üëΩ ü§∑üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ihr Computer ist keine schnelle Version von PDP-11 
 Hallo Habr! 

 Mein Name ist Anton Dovgal, ich bin ein C (und nicht nur) Entwickler bei Badoo. 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ist keine einfache Sprache</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/420407/"><img src="https://habrastorage.org/webt/8n/tg/og/8ntgogmuur_qld0ho0701jc83du.jpeg"><br><br><h3>  <i>Ihr Computer ist keine schnelle Version von PDP-11</i> </h3><br>  Hallo Habr! <br><br>  Mein Name ist Anton Dovgal, ich bin ein C (und nicht nur) Entwickler bei Badoo. <br><br>  Ich stie√ü auf einen Artikel von David Chiznell, einem Forscher an der Universit√§t Cambridge, in dem er die allgemein akzeptierte Meinung bestreitet, dass C eine einfache Sprache ist, und seine Argumente schienen mir interessant genug. <br><br>  Angesichts der k√ºrzlich entdeckten Sicherheitsl√ºcken sollten sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Meltdown und Spectre</a> die Zeit nehmen, um die Gr√ºnde f√ºr ihr Auftreten herauszufinden.  Diese beiden Sicherheitsl√ºcken nutzten die spekulative Ausf√ºhrung von Anweisungen durch Prozessoren und erm√∂glichten es einem Angreifer, Ergebnisse √ºber Kan√§le von Drittanbietern zu erhalten.  Sicherheitsl√ºcken in Prozessoren wurden zusammen mit mehreren anderen hinzugef√ºgt, so dass C-Programmierer weiterhin glauben, dass sie in einer einfachen Sprache programmieren, obwohl dies seit Jahrzehnten nicht mehr der Fall ist. <br><br>  Prozessorhersteller sind damit nicht allein.  C / C ++ - Compilerentwickler haben ebenfalls dazu beigetragen. <br><a name="habracut"></a><br><h2>  Was ist eine niedrige Sprache? </h2><br>  Der amerikanische Informatiker und erste Turing-Preistr√§ger Alan Perlis gab folgende Definition: <br><blockquote>  "Eine Programmiersprache ist auf niedrigem Niveau, wenn die darauf geschriebenen Programme das Unwesentliche beachten m√ºssen." </blockquote><br>  Obwohl sich diese Definition auf C bezieht, vermittelt sie kein Verst√§ndnis daf√ºr, was Menschen in einer niedrigen Sprache sehen wollen.  Verschiedene Eigenschaften lassen die Menschen die Sprache als niedrig betrachten.  Stellen Sie sich eine Skala von Programmiersprachen mit Assembler an einem Ende und einer Schnittstelle zu einem Enterprise-Computer am anderen Ende vor.  Niedrigstufige Sprachen sind n√§her an Eisen, w√§hrend h√∂herstufige Sprachen n√§her an der Denkweise der Menschen sind. <br><br>  Um ‚Äûn√§her an der Hardware‚Äú zu sein, muss die Sprache Abstraktionen bereitstellen, die mit den Abstraktionen der Zielplattform √ºbereinstimmen.  Es ist leicht zu beweisen, dass C in PDP-11 eine einfache Sprache war.  Die sequentielle Ausf√ºhrung von Programmen, ein flacher Adressraum, selbst Operatoren vor und nach dem Inkrementieren, fiel perfekt auf die PDP-11-Adressierungsmodi. <br><br><h2>  Schnelle PDP-11-Emulatoren </h2><br>  Der Hauptgrund f√ºr die Schwachstellen von Spectre und Meltdown ist, dass die Entwickler der Prozessoren nicht nur schnelle Prozessoren, sondern auch schnelle Prozessoren mit PDP-11-Schnittstelle hergestellt haben.  Dies ist wichtig, da C-Programmierer weiterhin glauben k√∂nnen, dass ihre Sprache der Hardware nahe kommt. <br><br>  C-Code bietet einen meist sequentiellen abstrakten Automaten (bis C11 ist er vollst√§ndig sequentiell, wenn nicht standardm√§√üige Erweiterungen ausgeschlossen sind).  Das Erstellen eines neuen Threads ist ein Aufruf einer Bibliotheksfunktion, eine Operation, die ziemlich teuer ist.  Daher verlassen sich Prozessoren, die weiterhin C-Code ausf√ºhren m√∂chten, auf Parallelit√§t auf Befehlsebene (ILP).  Sie analysieren benachbarte Operationen und f√ºhren parallel unabh√§ngige Operationen durch.  Dies verkompliziert die Prozessoren erheblich und f√ºhrt zu einem erh√∂hten Stromverbrauch, erm√∂glicht es Programmierern jedoch, haupts√§chlich sequentiellen Code zu schreiben.  Im Gegensatz dazu erzielen Grafikprozessoren (GPUs) auf andere Weise eine hohe Leistung: Sie erfordern das Schreiben paralleler Programme. <br><br>  Eine hohe Parallelit√§t auf Befehlsebene ist die direkte Ursache f√ºr Spectre und Meltdown.  Der moderne Intel-Prozessor f√ºhrt bis zu 180 Befehle gleichzeitig aus (im Gegensatz zur sequentiellen abstrakten C-Maschine, die erwartet, dass der vorherige Befehl ausgef√ºhrt wird, bevor der n√§chste startet).  Eine typische Heuristik des C-Codes zeigt, dass pro sieben Anweisungen durchschnittlich ein Zweig vorhanden ist.  Wenn Sie die Anweisungspipeline vollst√§ndig halten m√∂chten, m√ºssen Sie die n√§chsten 25 Zweige erraten.  Dies erh√∂ht wiederum die Komplexit√§t: Der Prozessor berechnet zuerst den falsch erratenen Zweig und gibt dann die Ergebnisse der Berechnungen aus, was sich negativ auf den Energieverbrauch auswirkt.  Diese geworfenen Daten haben sichtbare indirekte Ergebnisse, die bei den Spectre- und Meltdown-Angriffen verwendet wurden. <br><br>  Das Umbenennen von Registern verbraucht in modernen Prozessoren viel Energie und Chipfl√§che.  Es kann nicht ausgeschaltet oder sein Energieverbrauch reduziert werden, was es in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dunklen Silizium-</a> √Ñra unpraktisch macht, wenn die Transistoren niedrig sind, aber die beteiligten Transistoren sind eine wertvolle Ressource.  Dieses Ger√§t fehlt in der GPU, wo die Parallelit√§t durch die Verwendung von Threads erreicht wird, anstatt zu versuchen, anf√§nglich parallelen Code parallel auszuf√ºhren.  Wenn die Anweisungen keine Abh√§ngigkeiten aufweisen, die neu erstellt werden m√ºssen, m√ºssen die Register auch nicht umbenannt werden. <br><br>  Betrachten Sie einen weiteren grundlegenden Teil des C-Designs: den flachen Speicher.  Es existiert seit ein paar Jahrzehnten nicht mehr.  Ein moderner Prozessor verf√ºgt h√§ufig √ºber drei Caching-Ebenen zwischen Registern und Hauptspeicher, wodurch die Zeit f√ºr den Zugriff auf letztere reduziert wird. <br><br>  Der Cache ist vor dem Programmierer verborgen und daher f√ºr C nicht zug√§nglich. Die effektive Verwendung des Caches ist eine der M√∂glichkeiten, die Codeausf√ºhrung auf einem modernen Prozessor zu beschleunigen. Er ist jedoch vollst√§ndig vor der abstrakten Maschine verborgen, und Programmierer sind gezwungen, sich auf die Kenntnis der Details der Cache-Implementierung zu verlassen (z. B. diese zwei ausgerichteten 64-Bit-Dateien) Werte k√∂nnen in einer Zeile des Caches angezeigt werden, um effizienten Code zu schreiben. <br><br><h2>  C-Optimierung </h2><br>  Eine der gemeinsamen Eigenschaften von Low-Level-Sprachen ist die Geschwindigkeit.  Insbesondere sollten sie ohne einen komplizierten Compiler leicht in schnellen Code zu √ºbersetzen sein.  Das Argument, dass ein ausreichend intelligenter Compiler eine Sprache schnell machen kann, wird von C-Bef√ºrwortern h√§ufig ignoriert, wenn sie √ºber andere Sprachen sprechen. <br><br>  Leider k√∂nnen Sie mit einer einfachen √úbersetzung keinen schnellen Code von C erhalten. <br>  Prozessorarchitekten unternehmen heldenhafte Anstrengungen, um Chips zu erstellen, die C-Code schnell ausf√ºhren k√∂nnen.  Die von Programmierern erwarteten Leistungsniveaus werden jedoch nur mithilfe unglaublich komplexer Optimierungen erreicht, die vom Compiler durchgef√ºhrt werden. <br>  Der Clang-Compiler (einschlie√ülich der entsprechenden Teile von LLVM) besteht aus etwa 2 Millionen Codezeilen.  F√ºr die Analyse und Transformation des Codes, die zur Beschleunigung von C erforderlich sind, werden ca. 200.000 Codezeilen ben√∂tigt (ohne Kommentare und Leerzeilen). <br><br>  Um beispielsweise eine gro√üe Datenmenge in C zu verarbeiten, m√ºssen Sie eine Schleife schreiben, die jedes Element nacheinander verarbeitet.  F√ºr die optimale Ausf√ºhrung dieses Zyklus auf einem modernen Prozessor muss der Compiler bestimmen, dass die Iterationen des Zyklus unabh√§ngig voneinander sind.  Das Schl√ºsselwort "Einschr√§nken" kann in diesem Fall hilfreich sein. Es stellt sicher, dass das Schreiben in einen Zeiger das Lesen von einem anderen Zeiger nicht beeintr√§chtigt.  Diese Informationen in C sind viel eingeschr√§nkter als in einer Sprache wie Fortran, was der Hauptgrund daf√ºr ist, dass C sie nicht aus dem Hochleistungsrechnen herausholen konnte. <br><br>  Nachdem der Compiler festgestellt hat, dass die Iterationen unabh√§ngig voneinander sind, ist der n√§chste Schritt ein Versuch, das Ergebnis zu vektorisieren, da der Durchsatz moderner Prozessoren f√ºr vektorisierten Code vier- bis achtmal h√∂her ist als f√ºr skalaren Code.  Eine einfache Sprache f√ºr solche Prozessoren h√§tte ihre eigenen Vektortypen beliebiger L√§nge.  Solche Typen sind in der LLVM-Zwischendarstellung vorhanden, da es immer einfacher ist, gro√üe Operationen mit Vektoren in mehrere kleine aufzuteilen, als gr√∂√üere Vektoroperationen zu konstruieren. <br><br>  Zu diesem Zeitpunkt m√ºssen sich Optimierer mit den C-Speicherregeln auseinandersetzen. C stellt sicher, dass Strukturen mit demselben Pr√§fix austauschbar verwendet werden k√∂nnen, und bietet Zugriff auf versetzte Feldfelder von Strukturen in der Sprache.  Dies bedeutet, dass der Compiler die Reihenfolge der Felder in der Struktur nicht √§ndern oder keine Ausrichtung hinzuf√ºgen kann, um die Vektorisierung zu verbessern (z. B. Transformieren einer Struktur von Arrays in ein Array von Strukturen oder umgekehrt).  Dies ist normalerweise kein Problem in einfachen Sprachen, in denen es m√∂glich ist, die Position von Feldern in der Struktur zu steuern, aber es erschwert die Aufgabe, C. zu beschleunigen. <br><br>  C erfordert auch eine Ausrichtung am Ende der Struktur, da sichergestellt wird, dass in Arrays keine Ausrichtung erfolgt.  Die Ausrichtung ist ein ziemlich komplexer Teil der C-Spezifikation, der schlecht mit anderen Teilen der Sprache interagiert.  Beispielsweise sollten Sie in der Lage sein, zwei Strukturen mit der typenlosen Vergleichsmethode (dh der Funktion memcmp ()) zu vergleichen, sodass auch die Kopie der Struktur ausgerichtet werden muss.  In einigen F√§llen dauert das Kopieren der Ausrichtung sehr lange. <br><br>  Ber√ºcksichtigen Sie die beiden grundlegenden Optimierungen, die der C-Compiler erzeugt: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SROA</a> (skalares Ersetzen von Aggregaten, skalares Ersetzen von Aggregaten) und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schleifen√∂ffnung</a> . <br><br>  SROA versucht, Strukturen und Arrays mit fester Gr√∂√üe durch separate Variablen zu ersetzen.  Auf diese Weise kann der Compiler den Zugriff auf sie unabh√§ngig voneinander verarbeiten und die Operation ignorieren, wenn offensichtlich ist, dass das Ergebnis nicht verwendet wird.  In einigen F√§llen besteht der indirekte Effekt dieser Optimierung darin, die Ausrichtung zu entfernen. <br><br>  Die zweite Optimierung, das √ñffnen der Schleife, konvertiert die Schleife mit der Bedingung in eine Bedingung mit unterschiedlichen Schleifen in beiden Zweigen.  Dies √§ndert die Ausf√ºhrungsreihenfolge im Gegensatz zu der Behauptung, dass der Programmierer wei√ü, was in einer einfachen Sprache ausgef√ºhrt wird.  Dies f√ºhrt auch zu ernsthaften Problemen beim Umgang von C mit undefinierten Variablen und undefiniertem Verhalten. <br><br>  In C hat eine nicht initialisierte Variable einen undefinierten Wert, der bei jedem Aufruf unterschiedlich sein kann.  Dies ist wichtig, da Sie damit das verz√∂gerte Recycling von Speicherseiten implementieren k√∂nnen.  In FreeBSD teilt die malloc () - Implementierung dem System beispielsweise mit, dass die Seiten nicht mehr verwendet werden, und das System verwendet den ersten Eintrag auf der Seite als Beweis daf√ºr, dass dies nicht der Fall ist.  Das Aufrufen des neu zugewiesenen Speichers kann den alten Wert erhalten, dann kann das Betriebssystem die Speicherseite wiederverwenden und sie beim n√§chsten Schreiben an eine andere Stelle auf der Seite durch eine mit Null gef√ºllte Seite ersetzen.  Der zweite Aufruf an derselben Stelle auf der Seite erh√§lt den Wert Null. <br><br>  Wenn die Bedingung einen undefinierten Wert verwendet, ist das Ergebnis ebenfalls nicht definiert - alles kann passieren.  Stellen Sie sich eine Optimierung zum √ñffnen einer Schleife vor, bei der eine Schleife null Mal ausgef√ºhrt wird.  Im Original ist die gesamte Schleife toter Code.  In der offenen Version gibt es jetzt eine Bedingung mit einer Variablen, die m√∂glicherweise nicht initialisiert wird. <br>  Infolgedessen kann toter Code in undefiniertes Verhalten konvertiert werden.  Dies ist nur eine von vielen Optimierungen, die sich bei eingehenderer Untersuchung der Semantik von C als unzuverl√§ssig herausstellen. <br><br>  Am Ende k√∂nnen Sie den C-Code schnell laufen lassen, aber erst, nachdem Sie Tausende von Mannjahren damit verbracht haben, einen ausreichend intelligenten Compiler zu erstellen.  Dies ist jedoch nur m√∂glich, wenn bestimmte Regeln der Sprache verletzt werden.  Mit Compiler-Erstellern k√∂nnen sich C-Programmierer vorstellen, dass sie Code schreiben, der "der Hardware nahe kommt", aber sie m√ºssen Maschinencode generieren, der sich anders verh√§lt, damit Programmierer weiterhin glauben, dass sie in einer schnellen Sprache schreiben. <br><br><h2>  C verstehen </h2><br>  Eines der grundlegenden Attribute einer einfachen Sprache ist, dass Programmierer leicht verstehen k√∂nnen, wie eine Maschine mit abstrakter Sprache auf eine physische Maschine √ºbertragen wird.  Dies war definitiv bei PDP-11 der Fall, wo C-Ausdr√ºcke in eine oder zwei Anweisungen √ºbersetzt wurden.  In √§hnlicher Weise legte der Compiler Variablen in Stapelsteckpl√§tze und konvertierte einfache Typen in f√ºr PDP-11 verst√§ndliche. <br><br>  Seitdem sind C-Implementierungen viel komplizierter geworden - um die Illusion aufrechtzuerhalten, dass C leicht auf eine Hardwareplattform portiert werden kann und schnell l√§uft.  Im Jahr 2015 ergab eine Umfrage unter C-Programmierern, Compilerautoren und Mitgliedern des Standardisierungsausschusses, dass es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Probleme beim Verst√§ndnis von C gab.</a>  Mit dieser Sprache kann eine Implementierung beispielsweise Strukturen (aber nicht Arrays) ausrichten, um sicherzustellen, dass alle Felder f√ºr die Zielplattform korrekt ausgerichtet sind.  Wenn Sie diese Struktur mit Nullen f√ºllen und dann f√ºr einige Felder einen Wert angeben, werden die Ausrichtungsbits Nullen enthalten?  Laut der Umfrage waren sich 36% sicher, und 29% kannten die Antwort nicht.  Abh√§ngig vom Compiler und der Optimierungsstufe kann dies zutreffen (oder nicht). <br><br>  Dies ist ein ziemlich triviales Beispiel, aber viele Programmierer geben entweder die falsche Antwort oder k√∂nnen √ºberhaupt nicht antworten. <br><br>  Wenn Sie Zeiger hinzuf√ºgen, wird die Semantik von C noch verwirrender.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das BCPL-Modell</a> war ziemlich einfach: Alle Bedeutungen sind W√∂rter.  Jedes Wort ist entweder Daten oder eine Adresse im Speicher.  Der Speicher ist eine flache Anordnung von Zellen, die nach Adresse indiziert sind. <br><br>  Modell C erm√∂glicht die Implementierung f√ºr verschiedene Plattformen, einschlie√ülich segmentierter Architekturen, wobei der Zeiger aus Segment-IDs und Offsets sowie virtuellen Maschinen mit einem Garbage Collector bestehen kann.  Die C-Spezifikation schr√§nkt zul√§ssige Zeigeroperationen ein, um Probleme mit solchen Systemen zu vermeiden.  In der Antwort auf den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehlerbericht 260 wird</a> der Ursprung des Zeigers erw√§hnt: <br><blockquote>  ‚ÄûImplementierungen k√∂nnen dem Ursprung einer Reihe von Bits folgen und diejenigen, die einen undefinierten Wert enthalten, anders behandeln als diejenigen, die einen bestimmten Wert enthalten.  "Sie k√∂nnen Zeiger je nach Herkunft unterschiedlich behandeln, auch wenn sie hinsichtlich ihres Bitwerts gleich sind." </blockquote><br>  Leider fehlt das Wort "Ursprung" in der C11-Spezifikation, sodass die Compiler selbst entscheiden, was es bedeutet.  GCC und Clang unterscheiden sich beispielsweise darin, ob der Zeiger, der in die Ganzzahl und zur√ºck konvertiert wurde, seinen Ursprung beh√§lt.  Compiler k√∂nnen entscheiden, dass zwei Zeiger auf die Ergebnisse von malloc () beim Vergleich immer ein negatives Ergebnis liefern, selbst wenn sie auf dieselbe Adresse verweisen. <br><br>  Diese Missverst√§ndnisse sind nicht rein akademisch.  Beispielsweise wurden bereits Schwachstellen beobachtet, die auf das √úberlaufen einer vorzeichenbehafteten Ganzzahl (undefiniertes Verhalten in C) oder das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dereferenzieren eines Zeigers vor dem √úberpr√ºfen auf NULL zur√ºckzuf√ºhren sind</a> , obwohl dem Compiler mitgeteilt wurde, dass der Zeiger nicht NULL sein kann. <br><br>  Wenn es solche Probleme gibt, ist es schwierig zu erwarten, dass ein Programmierer vollst√§ndig versteht, wie ein C-Programm in die entsprechende Architektur √ºbersetzt wird. <br><br><h2>  Einf√ºhrung eines Prozessors nicht f√ºr C. </h2><br>  Die vorgeschlagenen Patches zum Schutz vor Spectre und Meltdown f√ºhren zu erheblichen Leistungseinbu√üen, wodurch alle Errungenschaften der Mikroarchitektur im letzten Jahrzehnt zunichte gemacht werden.  Vielleicht ist es an der Zeit, nicht mehr dar√ºber nachzudenken, wie C-Code schneller gemacht werden kann, sondern √ºber neue Programmiermodelle auf Prozessoren nachzudenken, die auf Geschwindigkeit ausgelegt sind. <br><br>  Es gibt viele Beispiele f√ºr Architekturen, die sich nicht auf traditionellen C-Code konzentriert haben und von denen man sich inspirieren lassen kann.  Multithreading-orientierte Prozessoren wie Sun / Oracle UltraSPARC Tx ben√∂tigen beispielsweise nicht so viel Cache, um ihre Aktoren zu besch√§ftigen.  Forschungsprozessoren haben dieses Konzept auf eine sehr gro√üe Anzahl von Hardware-geplanten Threads erweitert.  Die Schl√ºsselidee ist, dass der Prozessor mit gen√ºgend Threads die Threads anhalten kann, die auf Daten warten, und die Aktuatoren mit Anweisungen von anderen Threads f√ºllen kann.  Das Problem ist, dass C-Programme normalerweise nur sehr wenige Threads haben. <br><br>  ARMs SVE (Scalar Vector Extensions, Scalar Vector Extensions) ist eine weitere √§hnliche Arbeit von Berkeley, die einen Blick auf die verbesserte Schnittstelle zwischen Programm und Hardware bietet.  Regelm√§√üige Vektorisierungsbl√∂cke implementieren Operationen mit Vektoren fester Gr√∂√üe und erwarten, dass der Compiler den Algorithmus an die angegebene Gr√∂√üe anpasst.  Im Gegensatz dazu fordert die SVE-Schnittstelle den Programmierer auf, den Grad der Parallelit√§t unabh√§ngig zu beschreiben, und erwartet, dass die Hardware ihn an die verf√ºgbaren Aktuatoren anpasst.  Die Verwendung in C ist schwierig, da der Auto-Vektorisierer die Parallelit√§t basierend auf den Schleifen im Code berechnen muss. <br><br>  Caches sind gro√ü, aber dies ist nicht der einzige Grund f√ºr ihre Komplexit√§t.  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cache-Koh√§renz-</a> Unterst√ºtzungsprotokoll ist eine der komplexesten Komponenten eines modernen Prozessors.  Die gr√∂√üte Schwierigkeit besteht darin, eine Sprache zu pflegen, in der Daten gemeinsam genutzt und ver√§ndert werden k√∂nnen.  Als entgegengesetztes Beispiel k√∂nnen wir eine abstrakte Maschine im Erlang-Stil verwenden, bei der jedes Objekt entweder lokal oder unver√§nderlich ist.  Das Cache-Koh√§renzprotokoll f√ºr ein solches System h√§tte nur zwei F√§lle: ver√§nderbare Daten und gemeinsam genutzte Daten.  Der Cache des Programmstroms, der auf einen anderen Prozessor √ºbertragen wurde, muss explizit deaktiviert werden. Dies ist jedoch eine relativ seltene Operation. <br><br>  Unver√§nderliche Objekte k√∂nnen Caches noch weiter vereinfachen und einige Vorg√§nge billiger machen.  In einem Maxwell-Projekt von Sun Labs wurde festgestellt, dass Objekte im Cache und k√ºrzlich erstellte Objekte fast immer gleich sind.  Wenn Objekte sterben, bevor sie aus dem Cache ausgeschlossen werden, k√∂nnen Sie sie nicht in den Hauptspeicher schreiben und so Energie sparen.  Das Maxwell-Projekt schlug einen Garbage Collector vor, der im Cache funktioniert und es Ihnen erm√∂glicht, Speicher schnell wiederzuverwenden.  Mit unver√§nderlichen Objekten auf dem Heap und dem ver√§nderlichen Stapel wird der Garbage Collector zu einer sehr einfachen Zustandsmaschine, die leicht in die Hardware implementiert werden kann und es Ihnen erm√∂glicht, einen relativ kleinen Cache effizient zu verwenden. <br><br>  Ein Prozessor, der ausschlie√ülich auf Geschwindigkeit und nicht auf den Kompromiss zwischen Geschwindigkeit und C-Unterst√ºtzung ausgelegt ist, sollte wahrscheinlich eine gro√üe Anzahl von Threads unterst√ºtzen, gro√üe Vektorisierungsbl√∂cke und ein einfacheres Speichermodell aufweisen.  Es wird schwierig sein, C-Code auf einem solchen Prozessor auszuf√ºhren, daher ist es angesichts des Volumens des alten C-Codes in der Welt unwahrscheinlich, dass es kommerziellen Erfolg hat. <br><br>  Im Bereich der Softwareentwicklung gibt es einen Mythos, dass parallele Programmierung schwierig ist.  Alan Kay w√§re sehr √ºberrascht, dies zu h√∂ren: Er brachte den Kindern bei, das Schauspielermodell zu verwenden, mit dem sie Programme in mehr als 200 Streams schrieben.  Dies ist auch Erlang-Programmierern unbekannt, die h√§ufig Programme mit Tausenden von parallelen Komponenten schreiben.  Es ist richtiger zu sagen, dass parallele Programmierung in einer Sprache mit einer abstrakten Maschine wie C schwierig ist. Wenn Sie auf die Dominanz paralleler Hardware achten (von Mehrkernprozessoren bis zu Mehrkern-GPUs), ist dies nur eine andere M√∂glichkeit zu sagen, dass C f√ºr moderne Hardware nicht geeignet ist Bereitstellung. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420407/">https://habr.com/ru/post/de420407/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420391/index.html">IT-Geh√§lter Mitte 2018</a></li>
<li><a href="../de420393/index.html">PHP, YII2 und die Bildung gro√üer Excel-Dateien</a></li>
<li><a href="../de420395/index.html">"Kostenlose" Tabletten f√ºr Gefangene - √ºberhaupt nicht kostenlos</a></li>
<li><a href="../de420397/index.html">Wissenschaftler haben einen Weg gefunden, den Alterungsprozess von Zellen umzukehren</a></li>
<li><a href="../de420405/index.html">Untersuchung des IT-Verkaufsprozesses</a></li>
<li><a href="../de420409/index.html">Lerne OpenGL. Lektion 5.7 - HDR</a></li>
<li><a href="../de420413/index.html">SQLite und NW.js - Schritt-f√ºr-Schritt-Anleitungen zum Erstellen starker Freundschaften</a></li>
<li><a href="../de420415/index.html">Alles, was Sie √ºber das Testen von Wi-Fi-Adaptern wissen wollten, aber Angst hatten zu fragen</a></li>
<li><a href="../de420419/index.html">L√§ufer f√ºr diejenigen, die Dem√ºtigung m√∂gen oder wie wir PixJam ver√§ndert und modifiziert haben</a></li>
<li><a href="../de420423/index.html">Probleme mit der Schnittstelle zwischen Bodenkreuzung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>