<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤²ğŸ¾ ğŸ‘‹ğŸ½ ğŸ•º Langkah Pertama untuk Karat ğŸ‘¨ğŸ½â€ğŸ’» ğŸ’­ ğŸ“¡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya. Baru-baru ini saya bertemu dengan bahasa pemrograman baru Rust. Saya perhatikan bahwa dia berbeda dari yang lain yang pernah saya temui...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Langkah Pertama untuk Karat</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433302/"><p><img src="https://habrastorage.org/webt/ra/od/jn/raodjnsmyuf5nphvpqwkhcwliyi.jpeg" alt="gambar"></p><br><p>  Halo semuanya.  Baru-baru ini saya bertemu dengan bahasa pemrograman baru Rust.  Saya perhatikan bahwa dia berbeda dari yang lain yang pernah saya temui sebelumnya.  Karena itu, saya memutuskan untuk menggali lebih dalam.  Saya ingin membagikan hasil dan kesan saya: </p><br><ul><li>  Saya akan mulai dengan fitur utama, menurut saya, dari Rust </li><li>  Saya akan menjelaskan detail sintaks yang menarik </li><li>  Saya akan menjelaskan mengapa Rust tidak mungkin mengambil alih dunia </li></ul><br><p>  Saya akan segera menjelaskan bahwa saya telah menulis di Jawa selama sekitar sepuluh tahun, jadi saya akan berdebat dari menara lonceng saya. </p><a name="habracut"></a><br><h1 id="killer-feature">  Fitur pembunuh </h1><br><p> Rust sedang mencoba untuk mengambil posisi antara antara bahasa tingkat rendah seperti C / C ++ dan Java / C # / Python / Ruby tingkat tinggi ... Semakin dekat bahasa ke perangkat keras, semakin banyak kontrol, semakin mudah untuk memprediksi bagaimana kode akan dieksekusi.  Tetapi memiliki akses penuh ke memori jauh lebih mudah untuk menembak kaki Anda.  Berbeda dengan C / C ++, Python / Java dan semua yang lainnya muncul.  Mereka tidak perlu berpikir untuk membersihkan ingatan.  Yang terburuk adalah NPE, kebocorannya tidak terlalu umum.  Tetapi agar ini berhasil, Anda perlu, setidaknya, seorang pemulung, yang, pada gilirannya, mulai menjalani hidupnya sendiri, sejalan dengan kode pengguna, mengurangi kemungkinannya.  Mesin virtual masih memberikan kemandirian platform, tetapi berapa banyak yang dibutuhkan adalah titik diperdebatkan, saya tidak akan meningkatkannya sekarang. </p><br><p>  Karat adalah bahasa tingkat rendah, kompiler menghasilkan biner, yang tidak memerlukan trik tambahan untuk bekerja.  Semua logika untuk menghapus objek yang tidak perlu diintegrasikan ke dalam kode pada saat kompilasi, mis.  tidak ada pengumpul sampah saat runtime juga.  Rust juga tidak memiliki referensi nol dan tipe yang aman, yang membuatnya bahkan lebih dapat diandalkan daripada Java. </p><br><p>  Inti dari manajemen memori adalah gagasan memiliki referensi objek dan meminjam.  Jika hanya satu variabel yang memiliki masing-masing objek, maka segera setelah berakhir pada akhir blok, semua yang ditunjukkannya dapat dihapus secara rekursif.  Tautan juga dapat dipinjam untuk membaca atau menulis.  Di sini prinsip satu penulis dan banyak pembaca bekerja. </p><br><p>  Konsep ini dapat diperagakan dalam potongan kode berikut.  <em>Test</em> <em>()</em> dipanggil dari metode <em>main ()</em> , yang menciptakan struktur data rekursif <em>MyStruct</em> yang mengimplementasikan antarmuka destruktor.  <em>Drop</em> memungkinkan Anda untuk mengatur logika untuk dieksekusi sebelum objek dihancurkan.  Sesuatu yang mirip dengan finalizer di Jawa, hanya tidak seperti Java, saat pemanggilan metode <em>drop ()</em> cukup pasti. </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { test(); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"End of main"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = MyStruct { v: <span class="hljs-number"><span class="hljs-number">1</span></span>, s: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new( <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(MyStruct { v: <span class="hljs-number"><span class="hljs-number">2</span></span>, s: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(<span class="hljs-literal"><span class="hljs-literal">None</span></span>), }) ), }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"End of test"</span></span>) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyStruct</span></span></span></span> { v: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, s: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;MyStruct&gt;&gt;, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> MyStruct { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Cleaning {}"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.v) } }</code> </pre> <br><p>  Kesimpulannya adalah sebagai berikut: </p><br><pre> <code class="plaintext hljs">End of test Cleaning 1 Cleaning 2 End of main</code> </pre> <br><p>  Yaitu  sebelum keluar dari <em>tes (),</em> memori secara rekursif dihapus.  Kompilator menangani ini dengan memasukkan kode yang diperlukan.  Apa itu <em>Kotak</em> dan <em>Opsi</em> akan uraikan nanti. </p><br><p>  Dengan cara ini, Rust mengambil keamanan dari bahasa tingkat tinggi dan prediktabilitas dari bahasa pemrograman tingkat rendah. </p><br><h1 id="chto-esche-interesnogo">  Apa lagi yang menarik </h1><br><p>  Berikutnya, saya akan mencantumkan fitur-fitur bahasa dalam urutan pentingnya, menurut pendapat saya. </p><br><h2 id="oop">  Ups </h2><br><p>  Di sini, Karat umumnya di depan sisanya.  Jika sebagian besar bahasa sampai pada kesimpulan bahwa pewarisan berganda harus ditinggalkan, maka di Rust tidak ada warisan sama sekali.  Yaitu  suatu kelas hanya dapat mengimplementasikan antarmuka dalam jumlah berapa pun, tetapi tidak dapat mewarisi dari kelas lain.  Dalam hal Jawa, ini berarti membuat semua kelas final.  Secara umum, variasi sintaksis untuk mempertahankan OOP tidak begitu bagus.  Mungkin ini yang terbaik. </p><br><p>  Untuk menggabungkan data, ada struktur yang mungkin mengandung implementasi.  Antarmuka disebut sifat dan mungkin juga berisi implementasi standar.  Mereka tidak mencapai kelas abstrak, karena  tidak dapat berisi bidang, banyak yang mengeluh tentang pembatasan ini.  Sintaksnya adalah sebagai berikut, saya pikir komentar tidak diperlukan di sini: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { MyPrinter { value: <span class="hljs-number"><span class="hljs-number">10</span></span> }.print(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Printer</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Printer { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyPrinter</span></span></span></span> { value: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Printer <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> MyPrinter { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value) } }</code> </pre> <br><p>  Dari fitur-fitur yang saya perhatikan, perlu diperhatikan hal-hal berikut: </p><br><ul><li>  Kelas tidak memiliki konstruktor.  Hanya ada inisialisasi yang menentukan nilai untuk bidang melalui kurung kurawal.  Jika Anda memerlukan konstruktor, maka ini dilakukan melalui metode statis. </li><li>  Metode instance berbeda dari yang statis dengan memiliki <em>&amp;</em> referensi <em>diri</em> sebagai argumen pertama. </li><li>  Kelas, antarmuka, dan metode juga dapat digeneralisasi.  Tetapi tidak seperti Java, informasi ini tidak hilang pada saat kompilasi. </li></ul><br><h2 id="esche-nemnogo-bezopasnosti">  Beberapa keamanan lebih </h2><br><p>  Seperti yang saya katakan, Rust sangat memperhatikan keandalan kode dan mencoba mencegah sebagian besar kesalahan pada tahap kompilasi.  Untuk ini, kemampuan untuk membuat tautan kosong dikecualikan.  Itu mengingatkan saya pada jenis nullable dari Kotlin.  <em>Opsi</em> digunakan untuk membuat tautan kosong.  Sama seperti di Kotlin, ketika mencoba mengakses variabel seperti itu, kompiler akan memukul tangan, memaksa untuk memasukkan cek.  Mencoba menarik nilai keluar tanpa memeriksa dapat menyebabkan kesalahan.  Tetapi ini tentu saja tidak dapat dilakukan secara kebetulan, misalnya di Jawa. </p><br><p>  Saya juga menyukai kenyataan bahwa semua variabel dan bidang kelas tidak dapat diubah secara default.  Halo lagi Kotlin.  Jika nilainya dapat berubah, ini harus ditunjukkan secara eksplisit dengan kata kunci <em>mut</em> .  Saya pikir keinginan untuk tetap sangat meningkatkan keterbacaan dan prediktabilitas kode.  Meskipun <em>Opsi</em> untuk beberapa alasan bisa berubah, saya tidak mengerti ini, berikut adalah kode dari dokumentasi: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = x.take(); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(x, <span class="hljs-literal"><span class="hljs-literal">None</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(y, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>));</code> </pre> <br><h2 id="perechisleniya">  Transfer </h2><br><p>  Karat disebut <em>enum</em> .  Hanya di samping sejumlah nilai yang terbatas masih dapat berisi data dan metode sewenang-wenang.  Jadi, itu adalah sesuatu antara enum dan kelas di Jawa.  <em>Opsi enum</em> standar dalam contoh pertama saya hanya milik jenis ini: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Option</span></span></span></span>&lt;T&gt; { <span class="hljs-literal"><span class="hljs-literal">None</span></span>, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(T), }</code> </pre> <br><p>  Ada konstruksi khusus untuk memproses nilai-nilai tersebut: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> a { <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"empty"</span></span>), <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(v) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, v) } }</code> </pre> <br><h2 id="a-takzhe">  Juga </h2><br><p>  Saya tidak bermaksud untuk menulis buku teks tentang Rust, tetapi hanya ingin menekankan fitur-fiturnya.  Pada bagian ini saya akan menjelaskan apa lagi yang berguna, tetapi, menurut saya, tidak begitu unik: </p><br><ul><li>  Penggemar pemrograman fungsional tidak akan kecewa, ada lambda untuk mereka.  Iterator memiliki metode untuk memproses koleksi, misalnya, <em>filter</em> dan <em>for_each</em> .  Sesuatu seperti aliran Java. </li><li>  Konstruksi <em>korek</em> api juga dapat digunakan untuk hal-hal yang lebih kompleks daripada <em>enum</em> biasa, misalnya, untuk memproses pola. </li><li>  Ada sejumlah besar kelas <em>bawaan,</em> misalnya, koleksi: <em>Vec, LinkedList, HashMap</em> , dll. </li><li>  Anda dapat membuat makro </li><li>  Dimungkinkan untuk menambahkan metode ke kelas yang ada </li><li>  Inferensi tipe otomatis didukung </li><li>  Seiring dengan bahasa muncul kerangka pengujian standar </li><li>  Utilitas <em>kargo bawaan</em> digunakan untuk membangun dan mengelola dependensi </li></ul><br><h1 id="lozhki-degtya">  Terbang di salep </h1><br><p>  Bagian ini diperlukan untuk melengkapi gambar. </p><br><h2 id="killer-problem">  Masalah pembunuh </h2><br><p>  Kelemahan utama berasal dari fitur utama.  Anda harus membayar semuanya.  Dalam Rust, sangat tidak nyaman untuk bekerja dengan struktur data grafik yang bisa berubah, karena  objek apa pun harus memiliki tidak lebih dari satu tautan.  Untuk mengatasi keterbatasan ini, ada banyak kelas bawaan: </p><br><ul><li>  <em>Box</em> - nilai abadi pada heap, analog pembungkus untuk primitif di Jawa </li><li>  Nilai variabel <em>sel</em> </li><li>  <em>RefCell</em> - nilai variabel yang dapat diakses dengan referensi </li><li>  Penghitung referensi - <em>Rc</em> , untuk banyak referensi ke satu objek </li></ul><br><p>  Dan ini adalah daftar yang tidak lengkap.  Untuk sampel Rust pertama, saya dengan ceroboh memutuskan untuk menulis daftar yang terhubung sendiri dengan metode dasar.  Pada akhirnya, tautan ke simpul <em>menghasilkan Opsi &lt;Rc &lt;RefCell &lt;ListNode&gt; &gt;&gt; &gt;&gt; berikut</em> : </p><br><ul><li>  <em>Opsi</em> - untuk memproses tautan kosong </li><li>  <em>Rc</em> - untuk banyak tautan, seperti  simpul terakhir dirujuk oleh simpul sebelumnya dan lembar itu sendiri </li><li>  <em>RefCell</em> - untuk tautan yang bisa diubah </li><li>  <em>ListNode</em> - elemen berikutnya itu sendiri </li></ul><br><p>  Ini terlihat begitu-begitu, total tiga pembungkus di sekitar satu objek.  Kode untuk hanya menambahkan item ke akhir daftar sangat rumit, dan ada hal-hal yang tidak jelas di dalamnya, seperti kloning dan meminjam: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListNode</span></span></span></span> { val: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, next: Node, } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LinkedList</span></span></span></span> { root: Node, last: Node, } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span></span> = <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;Rc&lt;RefCell&lt;ListNode&gt;&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> LinkedList { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, val: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; LinkedList { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n = Rc::new(RefCell::new(ListNode { val: val, next: <span class="hljs-literal"><span class="hljs-literal">None</span></span> })); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.root.is_none()){ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.root = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(n.clone()); } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.last.map(|v| { v.borrow_mut().next = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(n.clone()) }); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.last = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(n); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> } ...</code> </pre> <br><p>  Di Kotlin, hal yang sama terlihat jauh lebih sederhana: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newNode = ListNode(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, value); root = root ?: newNode; last?.next = newNode last = newNode; }</code> </pre> <br><p>  Seperti yang saya ketahui kemudian, struktur seperti itu tidak tipikal untuk Rust, dan kode saya sepenuhnya non-idiomatis.  Orang-orang bahkan menulis seluruh artikel: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">10 cara untuk membuat daftar di Rust</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara lain</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Siksaan mirip dengan milikku</a> </li></ul><br><p>  Di sini Rust mengorbankan keterbacaan untuk keamanan.  Selain itu, latihan seperti itu masih dapat menyebabkan tautan melingkar yang menggantung di memori, karena  tidak ada pemulung yang akan membawanya pergi.  Saya tidak menulis kode yang berfungsi di Rust, jadi sulit bagi saya untuk mengatakan betapa sulitnya menyulitkan kehidupan.  Akan menarik untuk menerima komentar dari insinyur yang berlatih. </p><br><h2 id="slozhnost-izucheniya">  Kesulitan belajar </h2><br><p>  Proses panjang belajar Rust mengikuti sebagian besar dari bagian sebelumnya.  Sebelum menulis apa pun, Anda harus meluangkan waktu untuk menguasai konsep kunci kepemilikan memori  itu meresapi setiap baris.  Sebagai contoh, daftar paling sederhana membawa saya beberapa malam, sedangkan di Kotlin hal yang sama ditulis dalam 10 menit, meskipun ini bukan bahasa kerja saya.  Selain itu, banyak pendekatan akrab untuk menulis algoritma atau struktur data di Rust akan terlihat berbeda atau tidak akan berfungsi sama sekali.  Yaitu  ketika beralih ke hal itu, restrukturisasi pemikiran yang lebih dalam akan diperlukan, hanya menguasai sintaksis saja tidak akan cukup.  Ini jauh dari JavaScript, yang menelan dan menanggung semuanya.  Saya pikir Rust tidak akan pernah menjadi bahasa yang diajarkan anak-anak di sekolah pemrograman.  Bahkan C / C ++ memiliki lebih banyak peluang dalam hal ini. </p><br><h1 id="v-itoge">  Pada akhirnya </h1><br><p>  Saya menemukan ide mengelola memori pada tahap kompilasi sangat menarik.  Di C / C ++, saya tidak punya pengalaman, jadi saya tidak akan membandingkan dengan smart pointer.  Sintaks umumnya menyenangkan dan tidak ada yang berlebihan.  Saya mengkritik Rust karena kompleksitas penerapan struktur data grafik, tetapi saya menduga ini adalah fitur dari semua bahasa pemrograman non-GC.  Mungkin perbandingan dengan Kotlin tidak sepenuhnya jujur. </p><br><h1 id="todo">  Todo </h1><br><p>  Pada artikel ini, saya tidak menyentuh multithreading sama sekali, saya pikir ini adalah topik besar yang terpisah.  Masih ada rencana untuk menulis beberapa jenis struktur data atau algoritma yang lebih rumit daripada daftar, jika Anda punya ide, silakan berbagi di komentar.  Akan menarik untuk mengetahui jenis aplikasi apa yang umumnya ditulis dalam Rust. </p><br><h1 id="pochitat">  Baca </h1><br><p>  Jika Anda tertarik dengan Rust, berikut adalah beberapa tautan: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemrograman Karat: Cepat, Pengembangan Sistem Aman</a> - buku yang bagus, ada juga versi elektronik </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi Karat</a> - dokumentasi resmi, ada contohnya </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode Karat Idiomatik</a> - daftar artikel </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ruRust / mudah</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ruRust / umum</a> - saluran di Gitter </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">r / rust /</a> - Reddit </li></ul><br><p>  <strong>UPD: Terima kasih atas komentar Anda.</strong>  <strong>Saya belajar banyak hal berguna untuk diri saya sendiri.</strong>  <strong>Ketidakakuratan dan kesalahan ketik yang diperbaiki, tautan tambahan.</strong>  <strong>Saya pikir diskusi semacam itu sangat berkontribusi pada studi teknologi baru.</strong> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433302/">https://habr.com/ru/post/id433302/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433292/index.html">Intisari materi menarik untuk pengembang ponsel # 279 (pada 10 - 16 Desember)</a></li>
<li><a href="../id433294/index.html">Beberapa rekomendasi kerja tim yang sederhana</a></li>
<li><a href="../id433296/index.html">Manajemen keuangan di perusahaan IT</a></li>
<li><a href="../id433298/index.html">Network Digest: 17 bahan ahli tentang Wi-Fi dan 5G</a></li>
<li><a href="../id433300/index.html">Membuat pusat media rumah. Prolog</a></li>
<li><a href="../id433304/index.html">Muat pengujian dengan belalang. Bagian 3</a></li>
<li><a href="../id433306/index.html">Visual studio 2019</a></li>
<li><a href="../id433308/index.html">Mentransfer konfigurasi PBX ke layanan 3CX PBX Express</a></li>
<li><a href="../id433316/index.html">Intisari desain: orientasi, umpan balik, cari ide dan pengambilan keputusan</a></li>
<li><a href="../id433318/index.html">garbage.collect ()</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>