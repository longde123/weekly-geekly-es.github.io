<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📈 🎅🏿 🏇🏿 PHP asincrónico y la historia de una bicicleta 🐟 🔡 🧙🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Después del lanzamiento de PHP7, se hizo posible escribir aplicaciones de larga duración a un costo relativamente bajo. Para los programadores, se han...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PHP asincrónico y la historia de una bicicleta</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451916/"><p> Después del lanzamiento de PHP7, se hizo posible escribir aplicaciones de larga duración a un costo relativamente bajo.  Para los programadores, se han puesto a disposición proyectos como <code>prooph</code> , <code>broadway</code> , <code>tactician</code> , <code>messenger</code> , cuyos autores toman la solución a los problemas más comunes.  Pero, ¿qué pasa si das un pequeño paso adelante y profundizas en la pregunta? </p><br><p>  Intentemos averiguar el destino de otra bicicleta, que le permite implementar la aplicación Publicar / Suscribir. </p><a name="habracut"></a><br><p>  Para comenzar, trataremos de revisar brevemente las tendencias actuales en el mundo de PHP, así como un breve vistazo a la operación asincrónica. </p><br><h3 id="php-sozdan-chtoby-umirat">  PHP creado para morir </h3><br><p>  Durante mucho tiempo, PHP se utilizó principalmente en el flujo de trabajo de solicitud / respuesta.  Desde el punto de vista de los desarrolladores, esto es bastante conveniente, porque no hay necesidad de preocuparse por las pérdidas de memoria, monitorear las conexiones. </p><br><p>  Todas las consultas se ejecutarán de manera aislada, se liberarán los recursos utilizados y las conexiones, por ejemplo, a la base de datos se cerrarán cuando se complete el proceso. </p><br><p>  Como ejemplo, puede tomar una aplicación CRUD regular escrita sobre la base del marco de Symfony.  Para leer de la base de datos y devolver JSON, es necesario realizar una serie de pasos (para ahorrar espacio y tiempo, excluir los pasos para generar / ejecutar códigos de operación): </p><br><ul><li>  Análisis de la configuración; </li><li>  Compilación de contenedores; </li><li>  Solicitar enrutamiento </li><li>  Cumplimiento; </li><li>  Representando el resultado. </li></ul><br><p>  Como en el caso de PHP (que usa aceleradores), el marco utiliza activamente el almacenamiento en caché (algunas tareas no se completarán en la próxima solicitud), así como la inicialización retrasada.  A partir de la versión 7.4, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">precarga</a> estará disponible, lo que optimizará aún más la inicialización de la aplicación. </p><br><p>  Sin embargo, no es posible eliminar por completo todos los costos generales para la inicialización. </p><br><h3 id="pomozhem-php-vyzhit">  Ayudemos a PHP a sobrevivir </h3><br><p>  La solución al problema parece bastante simple: si ejecuta la aplicación cada vez que es demasiado costosa, debe inicializarla una vez y luego pasarle las solicitudes, controlando su ejecución. </p><br><p>  Hay proyectos en el ecosistema PHP como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">php-pm</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RoadRunner</a> .  Ambos conceptualmente hacen lo mismo: </p><br><ul><li>  Se crea un proceso principal que actúa como supervisor; </li><li>  Se crea un grupo de procesos secundarios; </li><li>  Cuando se recibe una solicitud, el maestro recupera el proceso del grupo y le pasa la solicitud.  El cliente está pendiente en este momento; </li><li>  Una vez que se completa la tarea, el maestro devuelve el resultado al cliente y el proceso secundario se envía de vuelta al grupo. </li></ul><br><p>  Si algún proceso secundario muere, el supervisor lo crea nuevamente y lo agrega al grupo.  Creamos un demonio desde nuestra aplicación con un único propósito: eliminar la sobrecarga de inicialización, aumentando significativamente la velocidad de procesamiento de solicitudes.  Esta es la forma más indolora de aumentar la productividad, pero no la única. </p><br><blockquote>  Nota: <br>  Muchos ejemplos de la serie "tomar ReactPHP y acelerar Laravel N veces" caminan por la red.  Es importante comprender la diferencia entre demonizar (y, como resultado, ahorrar tiempo en el arranque de la aplicación) y la multitarea. <br>  Cuando use php-pm o roadrunner, su código no se bloqueará.  Simplemente ahorra tiempo en la inicialización. <br>  La comparación de php-pm, roadrunner y ReactPHP / Amp / Swoole es incorrecta por definición. </blockquote><br><h5 id="php-i-io">  PHP y E / S </h5><br><p>  La interacción con E / S en PHP se ejecuta por defecto en modo de bloqueo.  Esto significa que si ejecutamos una solicitud para actualizar la información en la tabla, el flujo de ejecución se detendrá esperando una respuesta de la base de datos.  Cuantas más llamadas estén en proceso de procesar la solicitud, más tiempo estarán inactivos los recursos del servidor.  De hecho, en el proceso de procesamiento de la solicitud, tenemos que ir a la base de datos varias veces, escribir algo en el registro y devolver el resultado al cliente, al final, también una operación de bloqueo. </p><br><blockquote>  Imagine que es un operador de centro de llamadas y necesita llamar a 50 clientes en una hora. <br>  Marcas el primer número, y allí está ocupado (el suscriptor discute por teléfono la última serie del Juego de Tronos y en qué consiste la serie). <br>  Y ahora estás sentado y tratando de alcanzarlo antes de la victoria.  El tiempo pasa, el cambio está llegando a su fin.  Después de perder 40 minutos tratando de llegar al primer suscriptor, perdió la oportunidad de contactar a otros y, naturalmente, recibió del jefe. <br>  Pero puede hacerlo de otra manera: no espere hasta que el primer suscriptor esté libre y, tan pronto como escuche un pitido, cuelgue y comience a marcar el siguiente número.  Puedes volver al primero un poco más tarde. <br>  Con este enfoque, las posibilidades de llamar al número máximo de personas aumentan considerablemente, y la velocidad de su trabajo no descansa en la tarea más lenta. </blockquote><p>  El código que no bloquea el hilo de ejecución (no usa llamadas de bloqueo de E / S, así como funciones como <code>sleep()</code> ), se llama asíncrono. </p><br><p>  Volvamos a nuestra aplicación Symfony CRUD.  Es casi imposible que funcione en modo asíncrono debido a la abundancia del uso de funciones de bloqueo: todos funcionan con configuraciones, cachés, registros, representación de la respuesta, interacción con la base de datos. </p><br><p>  Pero todas estas son convenciones, intentemos lanzar Symfony y usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Amp</a> , que proporciona una implementación de Event Loop (incluyendo una serie de carpetas), Promesas y Corutinas, como una guinda para resolver nuestro problema. </p><br><p>  Promise es una forma de organizar el código asincrónico.  Por ejemplo, necesitamos acceder a algún recurso http. </p><br><p>  Creamos un objeto de solicitud y lo pasamos al transporte, que Promise nos devuelve con el estado actual.  Hay tres estados posibles: </p><br><ul><li>  Éxito: nuestra solicitud se completó con éxito; </li><li>  Error: durante la ejecución de la solicitud, algo salió mal (por ejemplo, el servidor devolvió una respuesta 500); </li><li>  En espera: el procesamiento de solicitudes aún no ha comenzado. </li></ul><br><p>  Cada Promesa tiene un método (en el ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Promise es</a> analizado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">por Amp</a> ): <code>onResolve()</code> , en el que se pasa una función de devolución de llamada con dos argumentos </p><br><pre> <code class="php hljs">$promise-&gt;onResolve( <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(?/Throwable $throwable, $result)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> !== $throwable) { <span class="hljs-comment"><span class="hljs-comment">/**   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/**  */</span></span> } );</code> </pre> <br><p>  Después de recibir Promise, surge la pregunta: ¿quién supervisará su estado y nos notificará el cambio de estado? </p><br><p>  Para esto, se usa Event Loop. </p><br><p>  En esencia, un bucle de eventos es un programador que supervisa la ejecución.  Tan pronto como se complete la tarea (no importa cómo), se llamará al invocable que pasamos a Promise. </p><br><p>  En cuanto a los matices, recomendaría leer un artículo de Nikita Popov: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Multitarea cooperativa utilizando corutinas</a> .  Ayudará a aportar algo de claridad sobre lo que está sucediendo y dónde están los generadores. </p><br><p>  Armados con nuevos conocimientos, intentemos volver a nuestra tarea de renderización JSON. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://github.com/amphp/">Un ejemplo de</a> procesamiento de una solicitud HTTP entrante usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://github.com/amphp/">amphp / http-server</a> . <br>  Tan pronto como recibamos la solicitud, se realiza una lectura asincrónica de la base de datos (obtenemos Promesa) y, una vez completada, el usuario recibirá el codiciado JSON, formado sobre la base de los datos recibidos. </p><br><blockquote>  Si necesitamos escuchar un puerto de varios procesos, podemos mirar hacia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">amphp / cluster</a> </blockquote><p>  La principal diferencia es que un solo proceso puede atender varias solicitudes a la vez debido al hecho de que el hilo de ejecución no está bloqueado.  El cliente recibirá su respuesta cuando se complete la lectura de la base de datos, y si bien no hay respuesta, puede comenzar a atender la siguiente solicitud. </p><br><h3 id="divnyy-mir-asinhronnogo-php">  El maravilloso mundo del PHP asincrónico </h3><br><blockquote>  Descargo de responsabilidad <br>  El PHP asincrónico se considera en el contexto de los exóticos y no se considera algo saludable / normal.  Básicamente, esperarán risas al estilo de "take GO / Kotlin, a tonto", etc.  No diría que estas personas están equivocadas, pero ... </blockquote><p>  Hay una serie de proyectos que ayudan a escribir código PHP sin bloqueo.  En el marco del artículo, no analizaré completamente todos los pros y los contras, pero trataré de examinar cada uno de ellos superficialmente. </p><br><h5 id="swoolehttpswwwswoolecouk">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Swoole</a> </h5><br><p>  Un marco asincrónico escrito en contraste con los demás en C y entregado como una extensión a PHP.  Posee quizás los mejores indicadores de rendimiento en este momento. </p><br><p>  Hay una implementación de canales, corutina y otras cosas sabrosas, pero tiene 1 gran inconveniente: la documentación.  Aunque está parcialmente en inglés, en mi opinión no es muy detallado, y la API en sí no es muy obvia. </p><br><p>  En cuanto a la comunidad, tampoco todo es simple e inequívoco.  Personalmente, no conozco a una sola persona viva que use Swoole en la batalla.  Quizás supere mis miedos y migre a él, pero esto no sucederá en un futuro cercano. </p><br><p>  A las desventajas, también puede agregar que contribuir con el proyecto (usando la solicitud de extracción) con cualquier cambio también es difícil si no conoce C en el nivel adecuado. </p><br><h5 id="workermanhttpsgithubcomwalkorworkerman">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trabajador</a> </h5><br><p>  Si pierde velocidad con respecto a su competidor (hablando de Swoole), entonces no es muy notable y la diferencia en varios escenarios puede ser descuidada. </p><br><p>  Tiene integración con ReactPHP, que a su vez expande el número de implementaciones de problemas de infraestructura.  Para ahorrar espacio, describiré las desventajas junto con ReactPHP. </p><br><h5 id="reactphphttpsreactphporg">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ReactPHP</a> </h5><br><p>  Las ventajas incluyen una comunidad bastante grande y una gran cantidad de ejemplos.  Los contras comienzan a aparecer en el proceso de uso: este es el concepto de Promesa. <br>  Si necesita realizar varias operaciones asincrónicas, el código se convierte en una papelera interminable de llamadas (aquí hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un ejemplo de una conexión simple a RabbiqMQ</a> sin crear intercambio / cola y sus carpetas). </p><br><p>  Con un poco de refinamiento con un archivo (considerado la norma), puede obtener una implementación de la rutina, que ayudará a deshacerse de Promise hell. </p><br><p>  Sin el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">proyecto recoilphp / recoil,</a> usar ReactPHP, en mi opinión, no es posible en una aplicación sensata. </p><br><p>  Además, además de todo lo demás, uno tiene la sensación de que su desarrollo se ha ralentizado mucho.  No es suficiente, por ejemplo, el trabajo normal con PostgreSQL. </p><br><h5 id="amphttpsamphporgamp">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Amplificador</a> </h5><br><p>  En mi opinión, la mejor de las opciones que existen en este momento. <br>  Además de la Promesa habitual, hay una implementación de Coroutine, que facilita enormemente el proceso de desarrollo y el código se ve más familiar para los programadores de PHP. </p><br><p>  Los desarrolladores complementan y mejoran constantemente el proyecto, con la retroalimentación tampoco hay problemas. </p><br><p>  Desafortunadamente, con todas las ventajas del marco, la comunidad es relativamente pequeña, pero al mismo tiempo hay implementaciones, por ejemplo, trabajando con PostgreSQL, así como todas las cosas básicas (sistema de archivos, cliente http, DNS, etc.). </p><br><p>  Todavía no entiendo muy bien el destino del proyecto ext-async, pero los chicos continúan con él.  Lo que saldrá de esto en la tercera versión, el tiempo lo dirá. </p><br><h3 id="pristupaem-k-realizacii">  Empezando </h3><br><p>  Entonces, resolvimos un poco la parte teórica, es hora de pasar a practicar y llenar los baches. </p><br><p>  Primero, formalizamos un poco los requisitos: </p><br><ul><li>  Mensajería asincrónica (el concepto de <code>message</code> sí puede dividirse en 2 tipos) <br><ul><li>  <code>command</code> : indica la necesidad de completar la tarea.  No devuelve un resultado (al menos en el caso de comunicación asincrónica); </li><li>  <code>event</code> : informa cualquier cambio de estado (por ejemplo, como resultado de un comando). </li></ul></li><li>  Formato sin bloqueo para trabajar con E / S; </li><li>  La capacidad de aumentar fácilmente el número de procesadores; </li><li>  Capacidad para escribir manejadores de mensajes en cualquier idioma. </li></ul><br><blockquote>  Cualquier mensaje es inherentemente una estructura simple y compartida solo por la semántica.  El nombramiento de mensajes es extremadamente importante desde el punto de vista de entender el tipo y el propósito (aunque este punto se ignora en el ejemplo). </blockquote><p>  Para obtener una lista de requisitos, una implementación simple del patrón <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Publicar / Suscribir</a> es la más adecuada. <br>  Para garantizar la ejecución distribuida, utilizaremos RabbitMQ como intermediario de mensajes. </p><br><p>  El prototipo fue escrito usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ReactPHP</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bunny</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DoctrineDBAL</a> . <br>  Un lector atento puede haber notado que Dbal usa llamadas de bloqueo pdo / mysqli internamente, pero en la etapa actual esto no era particularmente importante, ya que tenía que entender lo que debería suceder al final. </p><br><p>  Uno de los problemas fue la falta de bibliotecas para trabajar con PostgreSQL.  Hay algunos borradores, pero esto no es suficiente para el trabajo completo (más sobre esto a continuación). </p><br><p>  Después de una breve investigación, ReactPHP se eliminó a favor de Amp, ya que es relativamente simple y se desarrolla de manera muy activa. </p><br><h5 id="rabbitmq-transport">  RabbitMQ transport </h5><br><p>  Pero con todas las ventajas de Amp, hubo 1 problema: Amp no tiene un controlador para RabbitMQ ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bunny</a> solo es compatible con ReactPHP). </p><br><p>  En teoría, Amp te permite usar Promise de un competidor.  Parece que todo debería ser simple, pero ReactPHP usa Event Loop para trabajar con sockets en la biblioteca. <br>  En un momento dado, obviamente, no se pudieron iniciar dos bucles de eventos diferentes, por lo que no pude usar la función <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">adapt ()</a> . </p><br><p>  Desafortunadamente, la calidad del código en bunny dejó mucho que desear y no fue posible reemplazar adecuadamente una implementación con otra.  Para no detener el trabajo, se decidió reescribir un poco la biblioteca para que funcione con Amp y no conduzca a bloquear el flujo de ejecución. </p><br><p>  Esta adaptación parecía muy aterradora, todo el tiempo me daba mucha vergüenza, pero lo más importante, funcionó.  Bueno, dado que no hay nada más permanente que temporal, el adaptador se anticipó a una persona que no es demasiado perezosa para involucrarse en la implementación del controlador. </p><br><p>  Y tal hombre fue encontrado.  El proyecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PHPinnacle</a> , entre otras cosas, proporciona una implementación de un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">adaptador</a> adaptado para Amp. </p><br><blockquote>  El nombre del autor es Anton Shabovta, quien <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hablará sobre php asíncrono</a> en el marco de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PHP Rusia</a> y sobre el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desarrollo de controladores</a> para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PHP fwdays</a> . </blockquote><br><h5 id="postgresql">  PostgreSQL </h5><br><p>  La segunda característica del trabajo es la interacción con la base de datos.  En las condiciones de PHP "tradicional", todo es simple: tenemos una conexión y todas las solicitudes se ejecutan secuencialmente. </p><br><p>  En el caso de la ejecución asincrónica, debemos poder ejecutar simultáneamente varias solicitudes (por ejemplo, 3 transacciones).  Para poder hacer esto, se requiere una implementación de grupo de conexión. </p><br><p>  El mecanismo de trabajo es bastante simple: </p><br><ul><li>  abrimos <em>N</em> conexiones al inicio (o inicialización retrasada, no el punto); </li><li>  si es necesario, tomamos la conexión del grupo, asegurando que nadie más pueda usarla; </li><li>  Ejecutamos la solicitud y destruimos la conexión o la devolvemos al grupo (preferido). </li></ul><br><p>  En primer lugar, nos permite iniciar varias transacciones a la vez, y en segundo lugar, acelera el trabajo debido a la presencia de conexiones ya abiertas.  Amp tiene un componente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">amphp / postgres</a> .  Él se encarga de las conexiones: monitorea su número, vida útil y todo esto sin bloquear el flujo de ejecución. </p><br><p>  Por cierto, cuando utilice, por ejemplo, ReactPHP, deberá implementarlo usted mismo si desea trabajar con una base de datos. </p><br><h5 id="mutex">  Mutex </h5><br><p>  Para un funcionamiento efectivo y, lo más importante, adecuado de la aplicación, es necesario implementar algo similar a los mutexes.  Podemos distinguir 3 escenarios para su uso: </p><br><ul><li>  Dentro del marco de un proceso, un mecanismo simple en memoria es adecuado sin ningún excedente; </li><li>  Si queremos proporcionar el bloqueo en varios procesos, entonces podemos usar el sistema de archivos (por supuesto, en modo sin bloqueo); </li><li>  Si en el contexto de varios servidores, ya necesita pensar en algo como Zookeeper. </li></ul><br><p>  Se necesitan mutexes para resolver problemas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">condición de carrera</a> .  Después de todo, no sabemos (y no podemos saber) en qué orden se realizarán nuestras tareas, pero, sin embargo, debemos garantizar la integridad de los datos. </p><br><h5 id="logirovaniekonteksty">  Registro / Contextos </h5><br><p>  Para iniciar sesión, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Monolog</a> ya se ha convertido en estándar, pero con algunas advertencias: no podemos utilizar los controladores integrados, ya que conducirán a bloqueos. <br>  Para escribir en stdOut, puede tomar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">amphp / log</a> , o escribir un mensaje simple enviándolo a Graylog. </p><br><p>  Dado que en un momento dado, podemos procesar muchas tareas, y al grabar registros, debe comprender en qué contexto se escriben los datos.  Durante los experimentos, se decidió hacer <code>trace_id</code> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">rastreo distribuido</a> ).  La conclusión es que toda la cadena de llamadas debe ir acompañada de un identificador de transferencia que pueda rastrearse.  Además, en el momento de recibir el mensaje, <code>package_id</code> genera <code>package_id</code> , que indica exactamente el mensaje recibido. </p><br><p>  Por lo tanto, usando ambos identificadores, podemos rastrear fácilmente a qué se refiere un registro en particular.  La cuestión es que en PHP tradicional todos los registros que obtenemos en el registro están principalmente en el orden en que fueron escritos.  En el caso de ejecución asincrónica, no hay patrón en el orden de las entradas. </p><br><h5 id="terminating">  Terminando </h5><br><p>  Otro de los matices del desarrollo asincrónico es controlar el cierre de nuestro demonio.  Si acaba de matar el proceso, entonces no se completarán todas las tareas que están en progreso y se perderán los datos. En el enfoque habitual, también existe un problema, pero no es tan grande, porque solo se realiza una tarea a la vez. </p><br><p>  Para completar la ejecución correctamente, necesitamos: </p><br><ul><li>  Darse de baja de la cola.  En otras palabras, hacer imposible recibir nuevos mensajes; </li><li>  Complete todas las tareas restantes (espere a resolver las promesas); </li><li>  Y solo después de eso termina el guión. </li></ul><br><h5 id="utechki-otladka">  Fugas, depuración </h5><br><p>  Contrariamente a la creencia popular, en PHP moderno no es tan simple enfrentar situaciones en las que ocurre una pérdida de memoria.  Es necesario hacer algo absolutamente malo. </p><br><p>  Sin embargo, una vez enfrentado a esto, pero debido al descuido banal.  Durante la implementación de heartbeat, se agregó un nuevo temporizador cada 40 segundos para consultar la conexión.  No es difícil adivinar que después de un tiempo el uso de la memoria comenzó a aumentar progresivamente. </p><br><p>  Además, entre otras cosas, escribió un observador simple que opcionalmente comenzará cada 10 minutos y llamará a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gc_collect_cycles ()</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gc_mem_caches ()</a> . <br>  Pero el inicio forzado del recolector de basura no es algo necesario y fundamental. </p><br><p>  Para ver constantemente el uso de la memoria, se agregó un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MemoryUsageProcessor</a> estándar al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">registro</a> . </p><br><p>  Si tiene la idea de que Event Loop se está bloqueando con algo, esto también se puede verificar fácilmente: solo conecte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LoopBlockWatcher</a> . </p><br><p>   ,       production .       . </p><br><h3 id="rezultaty">  </h3><br><p>     : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">php-service-bus</a> ,    Message Based . </p><br><p>    ,         : </p><br><pre> <code class="plaintext hljs">composer create-project php-service-bus/skeleton pub-sub-example cd pub-sub-example docker-compose up --build -d</code> </pre> <br><p>   ,      ,   . </p><br><p>   <code>/bin/consumer</code>   ,    . <br>   <code>/src</code>  3 : <code>Ping</code>   ; <code>Pong</code> :    ; <code>PingService</code> : ,   . <br>     <code>PingService</code> ,      2 : </p><br><pre> <code class="php hljs"> <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@CommandHandler</span></span></span><span class="hljs-comment">() */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ping $command, KernelContext $context)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $context-&gt;delivery(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pong()); } <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@EventListener</span></span></span><span class="hljs-comment">() */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">whenPong</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Pong $event, KernelContext $context)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ $context-&gt;logContextMessage(<span class="hljs-string"><span class="hljs-string">'Pong message received'</span></span>); }</code> </pre> <br><ul><li> <code>handle</code>    (        1 ).      <code>@CommandHandler</code> ; <br><ul><li>   Promise ,        RabbitMQ (   <code>delivery()</code> ).       ,   RabbitMQ    . </li></ul></li><li> <code>whenPong</code> —   <code>Pong</code> .            .     <code>@EventListener</code> ; <br><blockquote>  ,     —   . , , ,     .     php-service-bus  , ,            . <br></blockquote></li></ul><br><p>     2 : ,   (  )  .          ,     ,     (, ). </p><br><p>     <code>Ping</code> ,      <code>Pong</code> .     . </p><br><p>    ,       RabbitMQ: </p><br><pre> <code class="plaintext hljs">tools/ping</code> </pre> <br><p>    ,  php-service-bus     ,  Message based . </p><br><p> Ping\Pong,    — ,  ,  <code>Hello, world</code>       . </p><br><p>     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . </p><br><p>     - ,    , , Saga pattern (Process manager)        . </p><br><h3 id="nu-i-kak-zhe-ne-pomeryatsya">       </h3><br><p>   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  symfony/messenger</a> . </p><br><p>    ,      ,      . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/451916/">https://habr.com/ru/post/451916/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../451902/index.html">Microsoft Azure Developer Camp Rusia</a></li>
<li><a href="../451904/index.html">A veces más es menos. Cuando una disminución en la carga conduce a un aumento en el retraso</a></li>
<li><a href="../451906/index.html">Vulnerabilidad de Exchange: cómo detectar la elevación de privilegios a un administrador de dominio</a></li>
<li><a href="../451908/index.html">La historia de las computadoras: una noche en el Museo Yandex</a></li>
<li><a href="../451912/index.html">La red neuronal profunda de MuseNet escribe música</a></li>
<li><a href="../451918/index.html">A la pregunta de TI</a></li>
<li><a href="../451920/index.html">Optimice el almacenamiento de correo en Zimbra Collaboration Suite</a></li>
<li><a href="../451922/index.html">Aritmética de punto fijo en C ++</a></li>
<li><a href="../451926/index.html">Acerca del código en vivo después de 130 transmisiones</a></li>
<li><a href="../451928/index.html">Cómo configurar análisis web en páginas AMP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>