<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöÑ üëÅ‚Äçüó® üë®üèø‚Äçüîß Programa√ß√£o funcional do ponto de vista do EcmaScript. Composi√ß√£o, Caril, Aplica√ß√£o Parcial üêç üïç üë©üèæ‚Äçü§ù‚Äçüë®üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Habr! 

 Hoje, continuamos nossa pesquisa sobre programa√ß√£o funcional no contexto do EcmaScript, cuja especifica√ß√£o √© baseada em JavaScript. No ar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programa√ß√£o funcional do ponto de vista do EcmaScript. Composi√ß√£o, Caril, Aplica√ß√£o Parcial</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475324/"> Ol√° Habr! <br><br>  Hoje, continuamos nossa pesquisa sobre programa√ß√£o funcional no contexto do EcmaScript, cuja especifica√ß√£o √© baseada em JavaScript.  No artigo anterior, examinamos os conceitos b√°sicos: fun√ß√µes puras, lambdas, o conceito de imunidade.  Hoje falaremos sobre t√©cnicas de FP um pouco mais complexas: composi√ß√£o, currying e fun√ß√µes puras.  O artigo foi escrito no estilo de "pseudo codreview", ou seja,  resolveremos um problema pr√°tico, enquanto estudamos os conceitos de transi√ß√µes de fase e o c√≥digo de refatora√ß√£o para aproximar o √∫ltimo dos ideais das transi√ß√µes de fase. <br><br>  Ent√£o, vamos come√ßar! <br><br>  Suponha que tenhamos uma tarefa: criar um conjunto de ferramentas para trabalhar com pal√≠ndromos. <br><blockquote>  Pal√≠ndromo <br>  Sexo masculino <br>  Uma palavra ou frase lida da esquerda para a direita e da direita para a esquerda. <br>  "P.  "Eu vou com a espada do juiz" <br></blockquote>  Uma das implementa√ß√µes poss√≠veis desta tarefa pode ser assim: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPalindrom</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> regexp = <span class="hljs-regexp"><span class="hljs-regexp">/[\.,\/#!$%\^&amp;\*;:{}=\-_`~()?\s]/g</span></span>; str = str.replace(regexp, <span class="hljs-string"><span class="hljs-string">''</span></span>).toLowerCase().split(<span class="hljs-string"><span class="hljs-string">''</span></span>).reverse().join(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-comment"><span class="hljs-comment">// -       ,       return str; } function isPalindrom (str) { const regexp = /[\.,\/#!$%\^&amp;\*;:{}=\-_`~()?\s]/g; str = str.replace(regexp, '').toLowerCase(); return str === str.split('').reverse().join(''); }</span></span></code> </pre> <a name="habracut"></a><br>  Obviamente, essa implementa√ß√£o funciona.  Podemos esperar que o getPalindrom funcione corretamente se a API retornar os dados corretos.  Uma chamada para isPalindrom ('eu vou com um juiz de espada') retornar√° verdadeiro e uma chamada para isPalindrom ('n√£o um pal√≠ndromo') retornar√° falso.  Essa implementa√ß√£o √© boa em termos de ideais de programa√ß√£o funcional?  Definitivamente n√£o √© bom! <br><br>  De acordo com a defini√ß√£o de Fun√ß√µes puras deste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> : <br><blockquote>  Fun√ß√µes puras (PF) - sempre retornam um resultado previsto. <br>  Propriedades PF <br><br>  O resultado da execu√ß√£o do PF depende apenas dos argumentos passados ‚Äã‚Äãe do algoritmo que implementa o PF <br>  N√£o use valores globais <br>  N√£o modifique valores externos ou argumentos passados <br>  N√£o grave dados em arquivos, bancos de dados ou em qualquer outro lugar <br></blockquote>  E o que vemos em nosso exemplo com pal√≠ndromos? <br><br>  Em primeiro lugar, h√° duplica√ß√£o de c√≥digo, ou seja,  o princ√≠pio de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DRY √©</a> violado.  Em segundo lugar, a fun√ß√£o getPalindrom acessa o banco de dados.  Terceiro, as fun√ß√µes modificam seus argumentos.  Total, nossas fun√ß√µes n√£o s√£o limpas. <br><br>  Lembre-se da defini√ß√£o: programa√ß√£o funcional √© uma maneira de escrever c√≥digo atrav√©s da compila√ß√£o de um conjunto de fun√ß√µes. <br><br>  N√≥s compomos um conjunto de fun√ß√µes para esta tarefa: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allNotWordSymbolsRegexpGlobal = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> /[\.,\/#!$%\^&amp;\*;:{}=\-_~<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">?\</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function">]/</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">g</span></span></span><span class="hljs-function">;//(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">replace</span></span></span><span class="hljs-function"> = (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">regexp, replacement, str</span></span></span><span class="hljs-function">) =&gt;</span></span> str.replace(regexp, replacement);<span class="hljs-comment"><span class="hljs-comment">//(2) const toLowerCase = str =&gt; str.toLowerCase();//(3) const stringReverse = str =&gt; str.split('').reverse().join('');//(4) const isStringsEqual = (strA, strB) =&gt; strA === strB;//(5)</span></span></code> </pre><br>  Na linha 1, declaramos a express√£o regular constante em forma funcional.  Este m√©todo de descri√ß√£o de constantes √© frequentemente usado no FP.  Na linha 2, encapsulamos o m√©todo String.prototype.replace em uma abstra√ß√£o de substitui√ß√£o funcional para que ele (a chamada de substitui√ß√£o) esteja em conformidade com o contrato de programa√ß√£o funcional.  Na linha 3, uma abstra√ß√£o para String.prototype.toLowerCase foi criada da mesma maneira.  No quarto, eles implementaram uma fun√ß√£o que cria uma nova string expandida a partir da passada.  5¬™ verifica a igualdade das strings. <br><br>  Observe que nossos recursos s√£o extremamente limpos!  Falamos sobre os benef√≠cios de fun√ß√µes puras em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> anterior. <br><br>  Agora precisamos implementar uma verifica√ß√£o para ver se a string √© um pal√≠ndromo.  Uma composi√ß√£o de fun√ß√µes vir√° em nosso aux√≠lio. <br><br>  <b>A composi√ß√£o de fun√ß√µes</b> √© a uni√£o de duas ou mais fun√ß√µes em uma determinada fun√ß√£o resultante que implementa o comportamento daquelas combinadas na sequ√™ncia algor√≠tmica desejada. <br><br>  A defini√ß√£o pode parecer complicada, mas, do ponto de vista pr√°tico, √© justa. <br><br>  N√≥s podemos fazer isso: <br><br><pre> <code class="javascript hljs">isStringsEqual(toLowerCase(replace(allNotWordSymbolsRegexpGlobal(), <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'    '</span></span>)), stringReverse(toLowerCase(replace(allNotWordSymbolsRegexpGlobal(), <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'    '</span></span>))));</code> </pre><br>  ou assim: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> strA = toLowerCase(replace(allNotWordSymbolsRegexpGlobal(), <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'    '</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> strB = stringReverse(toLowerCase(replace(allNotWordSymbolsRegexpGlobal(), <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'    '</span></span>))); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(isStringsEqual(strA, strB));</code> </pre><br>  ou insira outro conjunto de vari√°veis ‚Äã‚Äãexplicativas para cada etapa do algoritmo implementado.  Esse c√≥digo geralmente pode ser visto em projetos, e este √© um exemplo t√≠pico de composi√ß√£o - passar uma chamada para uma fun√ß√£o como argumento para outra.  No entanto, como vemos, em uma situa√ß√£o em que h√° muitas fun√ß√µes, essa abordagem √© ruim, porque  este c√≥digo n√£o √© leg√≠vel!  E agora?  Bem, sua programa√ß√£o funcional, discordamos? <br><br>  De fato, como √© geralmente o caso na programa√ß√£o funcional, s√≥ precisamos escrever outra fun√ß√£o. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> compose = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...fns</span></span></span><span class="hljs-function">) =&gt;</span></span> x =&gt; fns.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">acc, fn</span></span></span><span class="hljs-function">) =&gt;</span></span> fn(acc), x);</code> </pre><br>  A fun√ß√£o de composi√ß√£o pega uma lista de fun√ß√µes execut√°veis ‚Äã‚Äãcomo argumentos, as transforma em uma matriz, as armazena em um fechamento e retorna uma fun√ß√£o que espera um valor inicial.  Depois que o valor inicial √© passado, a execu√ß√£o seq√ºencial de todas as fun√ß√µes da matriz fns √© iniciada.  O argumento da primeira fun√ß√£o ser√° o valor inicial x passado, e os argumentos de todas as subsequentes ser√£o o resultado da anterior.  Assim, podemos criar composi√ß√µes de qualquer n√∫mero de fun√ß√µes. <br><br>  Ao criar composi√ß√µes funcionais, √© muito importante monitorar os tipos de par√¢metros de entrada e retornar valores de cada fun√ß√£o para que n√£o haja erros inesperados, porque  passamos o resultado da fun√ß√£o anterior para a pr√≥xima. <br><br>  No entanto, j√° agora vemos problemas com a aplica√ß√£o da t√©cnica de composi√ß√£o em nosso c√≥digo, porque a fun√ß√£o: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> replace = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">regexp, replacement, str</span></span></span><span class="hljs-function">) =&gt;</span></span> str.replace(regexp, replacement);</code> </pre><br>  espera aceitar tr√™s par√¢metros de entrada e enviamos apenas um para compor.  Outra t√©cnica de FP, Currying, nos ajudar√° a resolver esse problema. <br><br>  <b>Currying</b> √© a convers√£o de uma fun√ß√£o de muitos argumentos para uma fun√ß√£o de um argumento. <br><br>  Lembra da nossa fun√ß√£o de adi√ß√£o do primeiro artigo? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x,y</span></span></span><span class="hljs-function">) =&gt;</span></span> x+y;</code> </pre><br>  Pode ser curry assim: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> y =&gt; x+y;</code> </pre><br>  A fun√ß√£o pega x e retorna um lambda que espera y e executa a a√ß√£o. <br><br>  Benef√≠cios do curry: <br><br><ul><li>  o c√≥digo parece melhor; </li><li>  fun√ß√µes com curry est√£o sempre limpas. </li></ul><br>  Agora, transformamos nossa fun√ß√£o de substitui√ß√£o, para que seja necess√°rio apenas um argumento.  Como precisamos da fun√ß√£o para substituir caracteres na string por uma express√£o regular conhecida anteriormente, podemos criar uma fun√ß√£o parcialmente aplicada. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> replaceAllNotWordSymbolsGlobal = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">replacement</span></span></span><span class="hljs-function"> =&gt;</span></span> str =&gt; replace(allNotWordSymbolsRegexpGlobal(), replacement, str);</code> </pre><br>  Como voc√™ pode ver, corrigimos um dos argumentos com uma constante.  Isso se deve ao fato de que o curry √© realmente um caso especial de uso parcial. <br><br>  <b>Um aplicativo parcial</b> est√° agrupando uma fun√ß√£o com um inv√≥lucro que aceita menos argumentos do que a pr√≥pria fun√ß√£o; o inv√≥lucro deve retornar uma fun√ß√£o que aceita o restante dos argumentos. <br><br>  No nosso caso, criamos a fun√ß√£o replaceAllNotWordSymbolsGlobal, que √© uma op√ß√£o de substitui√ß√£o parcialmente aplicada.  Ele aceita substitui√ß√£o, armazena-o em um fechamento e espera uma linha de entrada para a qual chamar√° de substituir, e n√≥s regexp com uma constante. <br><br>  De volta aos pal√≠ndromos.  Crie uma composi√ß√£o de fun√ß√µes para o tempo do pal√≠ndromo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processFormPalindrom = compose( replaceAllNotWordSymbolsGlobal(<span class="hljs-string"><span class="hljs-string">''</span></span>), toLowerCase, stringReverse );</code> </pre><br>  e a composi√ß√£o das fun√ß√µes da linha com a qual compararemos o potencial pal√≠ndromo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processFormTestString = compose( replaceAllNotWordSymbolsGlobal(<span class="hljs-string"><span class="hljs-string">''</span></span>), toLowerCase, );</code> </pre><br>  Agora lembre-se do que dissemos acima: <br><blockquote>  um exemplo t√≠pico de composi√ß√£o est√° passando uma chamada para uma fun√ß√£o como argumento para outra </blockquote>  e escreva: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testString = <span class="hljs-string"><span class="hljs-string">'    '</span></span>;<span class="hljs-comment"><span class="hljs-comment">//          , .. ,    ,  ,   -   ,    const isPalindrom = isStringsEqual(processFormPalindrom(testString), processFormTestString(testString));</span></span></code> </pre><br>  Aqui temos uma solu√ß√£o funcional e bonita: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allNotWordSymbolsRegexpGlobal = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> /[\.,\/#!$%\^&amp;\*;:{}=\-_~<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">?\</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function">]/</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">g</span></span></span><span class="hljs-function">; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">replace</span></span></span><span class="hljs-function"> = (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">regexp, replacement, str</span></span></span><span class="hljs-function">) =&gt;</span></span> str.replace(regexp, replacement); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> toLowerCase = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function"> =&gt;</span></span> str.toLowerCase(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> stringReverse = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function"> =&gt;</span></span> str.split(<span class="hljs-string"><span class="hljs-string">''</span></span>).reverse().join(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isStringsEqual = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">strA, strB</span></span></span><span class="hljs-function">) =&gt;</span></span> strA === strB; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> replaceAllNotWordSymbolsGlobal = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">replacement</span></span></span><span class="hljs-function"> =&gt;</span></span> str =&gt; replace(allNotWordSymbolsRegexpGlobal(), replacement, str); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> compose = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...fns</span></span></span><span class="hljs-function">) =&gt;</span></span> x =&gt; fns.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">acc, fn</span></span></span><span class="hljs-function">) =&gt;</span></span> fn(acc), x); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processFormPalindrom = compose( replaceAllNotWordSymbolsGlobal(<span class="hljs-string"><span class="hljs-string">''</span></span>), toLowerCase, stringReverse ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processFormTestString = compose( replaceAllNotWordSymbolsGlobal(<span class="hljs-string"><span class="hljs-string">''</span></span>), toLowerCase, ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testString = <span class="hljs-string"><span class="hljs-string">'    '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isPalindrom = isStringsEqual(processFormPalindrom(testString), processFormTestString(testString));</code> </pre><br>  No entanto, n√£o queremos fazer curry a cada vez ou criar fun√ß√µes parcialmente aplicadas com as m√£os.  Claro que n√£o queremos, programadores s√£o pessoas pregui√ßosas.  Portanto, como geralmente acontece no FP, escreveremos mais algumas fun√ß√µes: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> curry = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function"> =&gt;</span></span> (...args) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fn.length &gt; args.length) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> f = fn.bind(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, ...args); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> curry(f); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(...args) } }</code> </pre><br>  A fun√ß√£o curry usa uma fun√ß√£o para ser curry, a armazena em um fechamento e retorna uma lambda.  O Lambda espera o restante dos argumentos da fun√ß√£o.  Cada vez que um argumento √© recebido, ele verifica se todos os argumentos declarados s√£o aceitos.  Se aceita, a fun√ß√£o √© chamada e seu resultado √© retornado.  Caso contr√°rio, a fun√ß√£o ser√° exibida novamente. <br><br>  Tamb√©m podemos criar uma fun√ß√£o parcialmente aplicada para substituir a express√£o regular necess√°ria por uma string vazia: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> replaceAllNotWordSymbolsToEmpltyGlobal = curry(replace)(allNotWordSymbolsRegexpGlobal(), <span class="hljs-string"><span class="hljs-string">''</span></span>);</code> </pre><br>  Tudo parece estar bem, mas somos perfeccionistas e n√£o gostamos de muitos colchetes, gostar√≠amos ainda melhor, ent√£o escreveremos outra fun√ß√£o ou talvez duas: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> party = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn, x</span></span></span><span class="hljs-function">) =&gt;</span></span> (...args) =&gt; fn(x, ...args);</code> </pre><br>  Esta √© uma implementa√ß√£o de abstra√ß√£o para criar fun√ß√µes parciais aplicadas.  Ele pega uma fun√ß√£o e o primeiro argumento, retorna um lambda que espera o resto e executa a fun√ß√£o. <br><br>  Agora, reescrevemos parte para que possamos criar uma fun√ß√£o parcialmente aplicada de v√°rios argumentos: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> party = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn, ...args</span></span></span><span class="hljs-function">) =&gt;</span></span> (...rest) =&gt; fn(...args.concat(rest));</code> </pre><br>  Vale a pena notar separadamente que as fun√ß√µes geradas dessa maneira podem ser chamadas com qualquer n√∫mero de argumentos menor que declarado (comprimento de fn.). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a,b,c,d</span></span></span><span class="hljs-function">) =&gt;</span></span> a+b+c+d; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fn = curry(sum); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r1 = fn(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>);<span class="hljs-comment"><span class="hljs-comment">//,   const r2 = fn(1, 2, 3)(4);//       const r3 = fn(1, 2)(3)(4); const r4 = fn(1)(2)(3)(4); const r5 = fn(1)(2, 3, 4); const r6 = fn(1)(2)(3, 4); const r7 = fn(1, 2)(3, 4);</span></span></code> </pre><br>  Vamos voltar aos nossos pal√≠ndromos.  Podemos reescrever nosso replaceAllNotWordSymbolsToEmpltyGlobal sem colchetes extras: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> replaceAllNotWordSymbolsToEmpltyGlobal = party(replace,allNotWordSymbolsRegexpGlobal(), <span class="hljs-string"><span class="hljs-string">''</span></span>);</code> </pre><br>  Vejamos o c√≥digo inteiro: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    -       const allNotWordSymbolsRegexpGlobal = () =&gt; /[\.,\/#!$%\^&amp;\*;:{}=\-_~()?\s]/g; const replace = (regexp, replacement, str) =&gt; str.replace(regexp, replacement); const toLowerCase = str =&gt; str.toLowerCase(); const stringReverse = str =&gt; str.split('').reverse().join(''); const isStringsEqual = (strA, strB) =&gt; strA === strB; //       const testString = '    '; //           -    rambda.js const compose = (...fns) =&gt; x =&gt; fns.reduce((acc, fn) =&gt; fn(acc), x); const curry = fn =&gt; (...args) =&gt; { if (fn.length &gt; args.length) { const f = fn.bind(null, ...args); return curry(f); } else { return fn(...args) } } const party = (fn, ...args) =&gt; (...rest) =&gt; fn(...args.concat(rest)); //       const replaceAllNotWordSymbolsToEmpltyGlobal = party(replace,allNotWordSymbolsRegexpGlobal(), ''); const processFormPalindrom = compose( replaceAllNotWordSymbolsToEmpltyGlobal, toLowerCase, stringReverse ); const processFormTestString = compose( replaceAllNotWordSymbolsToEmpltyGlobal, toLowerCase, ); const checkPalindrom = testString =&gt; isStringsEqual(processFormPalindrom(testString), processFormTestString(testString));</span></span></code> </pre><br>  Parece √≥timo, mas e se n√£o for uma string para n√≥s, mas houver uma matriz?  Portanto, adicionamos mais uma fun√ß√£o: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> map = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function"> =&gt;</span></span> (...args) =&gt; args.map(fn);</code> </pre><br>  Agora, se tivermos uma matriz para testar pal√≠ndromos, ent√£o: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> palindroms = [<span class="hljs-string"><span class="hljs-string">'    '</span></span>,<span class="hljs-string"><span class="hljs-string">'   '</span></span>,<span class="hljs-string"><span class="hljs-string">'   '</span></span>. <span class="hljs-string"><span class="hljs-string">' '</span></span>] map(checkPalindrom )(...palindroms ); <span class="hljs-comment"><span class="hljs-comment">// [true, true, true, false]  </span></span></code> </pre><br>  Foi assim que resolvemos a tarefa escrevendo conjuntos de recursos.  Preste aten√ß√£o ao estilo in√∫til de escrever c√≥digo - este √© um teste decisivo da pureza funcional. <br><br>  Agora um pouco mais de teoria.  Ao usar o curry, n√£o esque√ßa que, sempre que curry uma fun√ß√£o, voc√™ cria uma nova, ou seja,  selecione uma c√©lula de mem√≥ria para ela.  √â importante monitorar isso para evitar vazamentos. <br><br>  Bibliotecas funcionais como ramda.js t√™m fun√ß√µes de composi√ß√£o e canal.  compose implementa o algoritmo de composi√ß√£o da direita para a esquerda e canaliza da esquerda para a direita.  Nossa fun√ß√£o de composi√ß√£o √© um an√°logo de pipe da ramda.  Existem duas fun√ß√µes de composi√ß√£o diferentes na biblioteca desde  composi√ß√£o da direita para a esquerda e esquerda para a direita s√£o dois contratos diferentes de programa√ß√£o funcional.  Se um dos leitores encontrar um artigo que descreva todos os contratos existentes do PF, compartilhe-o nos coment√°rios, eu o leio com prazer e acrescentarei um coment√°rio ao coment√°rio! <br><br>  O n√∫mero de par√¢metros formais de uma fun√ß√£o √© chamado <b>arity</b> .  essa tamb√©m √© uma defini√ß√£o importante do ponto de vista da teoria das transi√ß√µes de fase. <br><br><h2>  Conclus√£o </h2><br>  No √¢mbito deste artigo, examinamos t√©cnicas de programa√ß√£o funcional como composi√ß√£o, currying e aplica√ß√£o parcial.  √â claro que, em projetos reais, voc√™ usar√° bibliotecas prontas com essas ferramentas, mas como parte do artigo, implementei tudo em JS nativo para que leitores com talvez pouca experi√™ncia no FP possam entender como essas t√©cnicas funcionam sob o cap√¥. <br><br>  Eu tamb√©m escolhi deliberadamente o m√©todo de narra√ß√£o - pseudo revis√£o de c√≥digo, para ilustrar minha l√≥gica de obter pureza funcional no c√≥digo. <br><br>  A prop√≥sito, voc√™ pode continuar o desenvolvimento deste m√≥dulo de trabalho com pal√≠ndromos e desenvolver suas id√©ias, por exemplo, baixar linhas por API, converter em conjuntos de letras e enviar para o servidor onde a linha ser√° gerada pelo pal√≠ndromo e muito mais ... A seu crit√©rio. <br><br>  Tamb√©m seria bom se livrar da duplica√ß√£o nos processos dessas linhas: <br><br><pre> <code class="javascript hljs"> replaceAllNotWordSymbolsToEmpltyGlobal, toLowerCase,</code> </pre><br>  Em geral, √© poss√≠vel e necess√°rio melhorar o c√≥digo constantemente! <br><br>  At√© artigos futuros. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt475324/">https://habr.com/ru/post/pt475324/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt475306/index.html">O processo: hist√≥ria e perspectivas</a></li>
<li><a href="../pt475308/index.html">Como passar para um bom programador</a></li>
<li><a href="../pt475314/index.html">Eco-fantasia para proteger o planeta</a></li>
<li><a href="../pt475320/index.html">Recomenda√ß√µes da Microsoft para desativar a expira√ß√£o de senha: consequ√™ncias e conclus√µes</a></li>
<li><a href="../pt475322/index.html">Osso de pr√≥ximo n√≠vel - Sound Aftershokz Aeropex Review</a></li>
<li><a href="../pt475326/index.html">Como os golpistas fazem isso. Ferramentas de trapa√ßa</a></li>
<li><a href="../pt475328/index.html">Opera√ß√£o TA505, parte quatro. G√™meos</a></li>
<li><a href="../pt475330/index.html">Concurso de plug-ins da plataforma Miro com pr√™mio de US $ 21.000</a></li>
<li><a href="../pt475332/index.html">3. Projeto de rede corporativa em switches extremos</a></li>
<li><a href="../pt475338/index.html">Se voc√™ n√£o possui Python, mas existe um modelo Keras e Java</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>