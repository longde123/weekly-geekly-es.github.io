<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>↕️ 💞 👎 朱莉娅 报告和文件生成器 🧕 🔄 👨🏼‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在任何时候，紧迫的问题之一就是准备报告的问题。 由于Julia是一门语言，其用户直接与数据分析任务联系在一起，使用计算和报告的结果编写文章和精美的演示文稿，因此无法忽略此主题。 


 最初，本文计划了一组用于生成报告的方法，但是在报告旁边是文档主题，与报告生成器有很多交集。 因此，这包括用于判断是...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>朱莉娅 报告和文件生成器</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439442/"><p><img src="https://habrastorage.org/webt/1z/xx/oe/1zxxoem9yjn-i2g-r6mi7g-9aco.png"></p><br><p> 在任何时候，紧迫的问题之一就是准备报告的问题。 由于Julia是一门语言，其用户直接与数据分析任务联系在一起，使用计算和报告的结果编写文章和精美的演示文稿，因此无法忽略此主题。 </p><br><p> 最初，本文计划了一组用于生成报告的方法，但是在报告旁边是文档主题，与报告生成器有很多交集。 因此，这包括用于判断是否可以将Julia可执行代码嵌入带有某些标记的模板中的标准的工具。 最后，我们注意到该评论包括均由Julia本身实现的报告生成器，以及用其他编程语言编写的工具。 好吧，当然，朱莉娅语言本身的一些关键点并没有被忽略，没有它们，在什么情况下以及应该使用什么手段可能不清楚。 </p><a name="habracut"></a><br><h2 id="jupyter-notebook">  Jupyter笔记本 </h2><br><p> 也许应该将此工具归因于参与数据分析的人员中最受欢迎的工具。 由于具有连接各种计算核心的能力，它受到习惯于特定编程语言的研究人员和数学家的欢迎，Julia是其中之一。  Julia语言的相应模块已为Jupyter Notebook完全实现。 这就是为什么在这里提到笔记本。 <br>  Jupyter Notebook的安装过程并不复杂。 有关顺序，请参见<a href="">https://github.com/JuliaLang/IJulia.jl。</a>如果已经安装了Jupyter Notebook，则只需安装Ijulia软件包并注册相应的计算核心。 </p><br><p> 由于Jupyter笔记本产品众所周知，因此没有详细介绍，因此我们仅提及几点。  Jupyter Notebook中的记事本（我们将使用记事本术语）由块组成，每个块可以包含各种形式的代码或标记（例如Markdown）。 处理的结果是标记的可视化（文本，公式等），或者是最后操作的结果。 如果将分号放在代码行的末尾，则不会显示结果。 </p><br><p> 例子 下图显示了执行之前的笔记本： </p><br><p><img src="https://habrastorage.org/webt/l_/2j/4g/l_2j4ggapx3gxwgz6mrqv46rfxw.png"></p><br><p> 下图显示了其实现的结果。 </p><br><p><img src="https://habrastorage.org/webt/zt/b0/lk/ztb0lku6kzxc7spuqbpnyn0xr0a.png"></p><br><p>记事本包含图形和一些文本。 请注意，要输出矩阵，可以使用<code>DataFrame</code>类型，对于该结果，结果将以带有明显边框和滚动条的html表的形式显示（如有必要）。 </p><br><p>  Jupyter笔记本可以将当前笔记本导出为html文件。 如果安装了转换工具，则可以转换为pdf。 </p><br><p> 要根据某些法规构建报告，可以使用<code>nbconvert</code>模块和以下命令，该命令根据计划在后台调用： <br> <code>jupyter nbconvert --to html --execute julia_filename.ipynb</code> </p> <br><p> 执行冗长的计算时，建议添加一个指示超时的选项--- <code>--ExecutePreprocessor.timeout=180</code> </p><br><p> 从该文件生成的html报告将出现在当前目录中。  <code>--execute</code>选项在这里意味着强制重新开始计数。 </p><br><p> 有关一整套<code>nbconvert</code>模块<code>nbconvert</code>请参见 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://nbconvert.readthedocs.io/en/latest/usage.html</a> </p><br><p> 转换为html的结果几乎与上图完全一致，不同之处在于它没有菜单栏或按钮。 </p><br><h2 id="jupytext"> 文字 </h2><br><p> 一个相当有趣的实用程序，可让您将以前创建的ipynb注释转换为Markdown文本或Julia代码。 </p><br><p> 我们可以使用以下命令转换先前考虑的示例 <br> <code>jupytext --to julia julia_filename.ipynb</code> </p> <br><p> 结果，我们获得了<code>julia_filename.jl</code>文件，带有Julia代码和注释形式的特殊标记。 </p><br><pre> <code class="plaintext hljs"># --- # jupyter: # jupytext: # text_representation: # extension: .jl # format_name: light # format_version: '1.3' # jupytext_version: 0.8.6 # kernelspec: # display_name: Julia 1.0.3 # language: julia # name: julia-1.0 # --- # # Report example using Plots, DataFrames # ### Drawing # Good time to show some plot plot(rand(5,5), linewidth=2, title="My Plot", size = (500, 200)) # ## Some computational results rand(2, 3) DataFrame(rand(2, 3))</code> </pre> <br><p> 注意块分隔符只是双换行。 </p><br><p> 我们可以使用以下命令进行逆变换： <br> <code>jupytext --to notebook julia_filename.jl</code> </p> <br><p> 结果，将生成一个ipynb文件，然后可以对其进行处理并将其转换为pdf或html。 </p><br><p> 查看详细信息<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/mwouts/jupytext</a> </p><br><p>  jupytext和jupyter笔记本的一般缺点是报告的“美观”受到这些工具功能的限制。 </p><br><h2 id="samostoyatelnaya-generaciya-html"> 自行生成的HTML </h2><br><p> 如果出于某种原因我们认为Jupyter Notebook太重了，需要安装大量的第三方软件包，这些软件包对于Julia的工作不是必需的，或者不够灵活来构建我们需要的报告表单，那么另一种方法是手动生成html页面。 但是，在这里您将不得不深入研究成像功能。 </p><br><p> 对于Julia，将某些内容输出到输出流的典型方法是使用<code>Base.write</code>函数，并<code>Base.show(io, mime, x)</code>进行装饰。 此外，对于请求的各种哑剧输出方法，可能会有各种显示选项。 例如， <code>DataFrame</code>在显示为文本时由伪图形表显示。 </p><br><pre> <code class="plaintext hljs">julia&gt; show(stdout, MIME"text/plain"(), DataFrame(rand(3, 2))) 3×2 DataFrame │ Row │ x1 │ x2 │ │ │ Float64 │ Float64 │ ├─────┼──────────┼───────────┤ │ 1 │ 0.321698 │ 0.939474 │ │ 2 │ 0.933878 │ 0.0745969 │ │ 3 │ 0.497315 │ 0.0167594 │</code> </pre> <br><p> 如果<code>mime</code>指定为<code>text/html</code> ，则结果为HTML标记。 </p><br><pre> <code class="plaintext hljs">julia&gt; show(stdout, MIME"text/html"(), DataFrame(rand(3, 2))) &lt;table class="data-frame"&gt; &lt;thead&gt; &lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;x1&lt;/th&gt;&lt;th&gt;x2&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;Float64&lt;/th&gt;&lt;th&gt;Float64&lt;/th&gt;&lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;&lt;p&gt;3 rows × 2 columns&lt;/p&gt; &lt;tr&gt;&lt;th&gt;1&lt;/th&gt;&lt;td&gt;0.640151&lt;/td&gt;&lt;td&gt;0.219299&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;2&lt;/th&gt;&lt;td&gt;0.463402&lt;/td&gt;&lt;td&gt;0.764952&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;3&lt;/th&gt;&lt;td&gt;0.806543&lt;/td&gt;&lt;td&gt;0.300902&lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;</code> </pre> <br><p> 也就是说，使用为相应的数据类型（第三个参数）和相应的输出格式定义的<code>show</code>函数的方法，可以确保以任何所需的数据格式形成文件。 </p><br><p> 图像的情况更加复杂。 如果需要创建一个单独的html文件，则图像应嵌入到页面代码中。 </p><br><p> 考虑实现它的示例。 该文件的输出将由<code>Base.write</code>函数执行，为此我们定义了适当的方法。 所以代码： </p><br><pre> <code class="plaintext hljs">#!/usr/bin/env julia using Plots using Base64 using DataFrames #        p = plot(rand(5,5), linewidth=2, title="My Plot", size = (500, 200)) #  ,  ,    @show typeof(p) # =&gt; typeof(p) = Plots.Plot{Plots.GRBackend} #    ,   3  #     abstract type Png end abstract type Svg end abstract type Svg2 end #  Base.write      #         #   —   ,  #   Base64-. #  HTML  img src="data:image/png;base64,..." function Base.write(file::IO, ::Type{Png}, p::Plots.Plot) local io = IOBuffer() local iob64_encode = Base64EncodePipe(io); show(iob64_encode, MIME"image/png"(), p) close(iob64_encode); write(file, string("&lt;img src=\"data:image/png;base64, ", String(take!(io)), "\" alt=\"fig.png\"/&gt;\n")) end #     Svg function Base.write(file::IO, ::Type{Svg}, p::Plots.Plot) local io = IOBuffer() show(io, MIME"image/svg+xml"(), p) write(file, replace(String(take!(io)), r"&lt;\?xml.*\?&gt;" =&gt; "" )) end #    XML-  ,  SVG Base.write(file::IO, ::Type{Svg2}, p::Plots.Plot) = show(file, MIME"image/svg+xml"(), p) #     DataFrame Base.write(file::IO, df::DataFrame) = show(file, MIME"text/html"(), df) #   out.html   HTML open("out.html", "w") do file write(file, """ &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;&lt;title&gt;Test report&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;Test html&lt;/h1&gt; """) write(file, Png, p) write(file, "&lt;br/&gt;") write(file, Svg, p) write(file, "&lt;br/&gt;") write(file, Svg2, p) write(file, DataFrame(rand(2, 3))) write(file, """ &lt;/body&gt; &lt;/html&gt; """) end</code> </pre> <br><p> 要创建图像，默认情况下使用<code>Plots.GRBackend</code>引擎，该引擎可以执行光栅或矢量图像输出。 根据<code>show</code>函数的<code>mime</code>参数中指定的类型，将生成相应的结果。  <code>MIME"image/png"()</code>形成<code>png</code>格式的图像。  <code>MIME"image/svg+xml"()</code>生成一个svg图像。 但是，在第二种情况下，您应注意形成了一个完全独立的xml文档的事实，该文档可以作为单独的文件编写。 同时，我们的目标是在HTML页面中嵌入图片，只需在HTML5中插入SVG标记即可完成。 这就是为什么<code>Base.write(file::IO, ::Type{Svg}, p::Plots.Plot)</code>方法<code>Base.write(file::IO, ::Type{Svg}, p::Plots.Plot)</code>切出xml标头的原因，否则会违反HTML文档的结构。 虽然，即使在这种情况下，大多数浏览器也能够正确显示图像。 </p><br><p> 关于<code>Base.write(file::IO, ::Type{Png}, p::Plots.Plot)</code> ，此处的实现功能是我们只能将二进制数据插入Base64格式的HTML中。 我们使用<code>&lt;img src="data:image/png;base64,"/&gt;</code>构造方法来执行此操作。 对于转码，我们使用<code>Base64EncodePipe</code> 。 </p><br><p>  <code>Base.write(file::IO, df::DataFrame)</code>方法<code>Base.write(file::IO, df::DataFrame)</code>以<code>DataFrame</code>对象的html表格式提供输出。 </p><br><p> 结果页面如下： </p><br><p><img src="https://habrastorage.org/webt/m8/5o/qg/m85oqgvazdnduuxy-6mrneujw5c.png"></p><br><p> 在图像中，所有三张图片看起来都大致相同，但是请记住，从HTML的角度来看，其中一张未正确插入（额外的xml标头）。 一种是栅格，这意味着在不损失细节的情况下不能增加栅格。 并且只有其中之一作为正确的svg片段插入HTML标记中。 而且可以轻松缩放，而不会丢失细节。 </p><br><p> 自然，该页面非常简单。 但是CSS可以进行任何视觉增强。 </p><br><p> 例如，当显示的表数是由实际数据而不是模板确定时，这种生成报告的方法很有用。 例如，您需要按某个字段对数据进行分组。 并为每个组形成单独的块。 由于形成页面时，结果取决于对<code>Base.write</code>的调用<code>Base.write</code> ，因此很明显，将所需的块包装到循环中，使输出依赖于数据等没有问题。 </p><br><p> 代码示例： </p><br><pre> <code class="plaintext hljs">using DataFrames #       ptable = DataFrame( Symbol = ["H", "He", "C", "O", "Fe" ], Room = [:Gas, :Gas, :Solid, :Gas, :Solid] ) res = groupby(ptable, [:Room]) #      open("out2.html", "w") do f for df in (groupby(ptable, [:Room])) write(f, "&lt;h2&gt;$(df[1, :Room])&lt;/h2&gt;\n") show(f, MIME"text/html"(), DataFrame(df)) write(f, "\n") end end</code> </pre> <br><p> 该脚本的结果是HTML页面的一部分。 </p><br><p><img src="https://habrastorage.org/webt/6m/-q/nh/6m-qnh-n8wa5v4rrdatbbpn1q-a.png"></p><br><p> 请注意，不需要装饰/格式转换的所有内容都直接通过<code>Base.write</code>函数显示。 同时，所有需要转换的内容都通过<code>Base.show</code>输出。 </p><br><h2 id="weavejl"> 编织 </h2><br><p>  Weave是由Julia实现的科学报告生成器。 使用生成器Pweave，Knitr，rmarkdown，Sweave的思想。 它的主要任务是以任何一种提议的语言（Noweb，Markdown，脚本格式）将源标记导出为LaTex，Panddoc，Github markdown，MultiMarkdown，Asciidoc，reStructuredText格式。 而且，即使在IJulia笔记本中，反之亦然。 在后一部分，它类似于Jupytext。 </p><br><p> 也就是说，Weave是一种工具，允许您编写包含各种标记语言的Julia代码的模板，并在输出时编写具有另一种语言的标记（但具有执行Julia代码的结果）。 这是专门针对研究人员的非常有用的工具。 例如，您可以准备一篇关于Latex的文章，该文章将在Julia上插入，并自动计算结果及其替换。  Weave将为最终文章生成一个文件。 </p><br><p> 使用相应的插件<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://atom.io/packages/language-weave</a>支持Atom编辑器。 这使您可以开发和调试标记中嵌入的Julia脚本，然后生成目标文件。 </p><br><p> 如前所述，Weave的基本原理是解析包含带有文本标记的模板（公式等），并将代码粘贴到Julia上。 代码执行的结果可以显示在最终报告中。 文本，代码的输出，结果的输出，图形的输出-所有这些都可以单独配置。 </p><br><p> 要处理模板，您需要运行一个外部脚本，该脚本会将所有内容收集到一个文档中，并将其转换为所需的输出格式。 也就是说，分别使用模板和处理程序。 </p><br><p> 这样的处理脚本的示例： </p><br><pre> <code class="plaintext hljs">#     : # Markdown weave("w_example.jmd", doctype="pandoc" out_path=:pwd) # HTML weave("w_example.jmd", out_path=:pwd, doctype = "md2html") # pdf weave("w_example.jmd", out_path=:pwd, doctype = "md2pdf")</code> </pre> <br><p> 文件名中的<code>jmd</code>是Julia Markdown。 </p><br><p> 采取与我们先前工具相同的示例。 但是，我们将插入一个标题，其中包含Weave可以理解的有关作者的信息。 </p><br><pre> <code class="markdown hljs">--- title : Intro to Weave.jl with Plots author : Anonymous date : 06th Feb 2019 --- # Intro ## Plot ` ``{julia;} using Plots, DataFrames plot(rand(5,5), linewidth=2, title="My Plot", size = (500, 200)) ` `` ## Some computational results ` ``julia rand(2, 3) ` `` ` ``julia DataFrame(rand(2, 3)) ` ``</code> </pre> <br><p> 转换为pdf的片段看起来像这样： </p><br><p><img src="https://habrastorage.org/webt/ga/_t/fh/ga_tfhgqqkfbofctlq6coym6unw.png"></p><br><p> 乳胶用户很好地认识了字体和布局。 </p><br><p> 对于每一段嵌入式代码，您都可以确定该代码的处理方式以及最终显示的内容。 </p><br><p> 例如： </p><br><ul><li>  echo = true-将显示代码 </li><li>  eval = true-将显示代码执行的结果 </li><li> 标签-添加标签。 如果使用Latex，则它将用作图：标签 </li><li>  fig_width，fig_height-图像大小 </li><li> 依此类推 </li></ul><br><p> 有关noweb和脚本格式以及有关此工具的更多信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http://weavejl.mpastell.com/stable/</a> </p><br><h2 id="literatejl">  Literate.jl </h2><br><p> 当该软件包的作者被问到为什么要使用Literate时，指的是Donald Knutt的Literate Programming范式。 该工具的任务是基于Julia代码生成文档，其中包含markdown格式的注释。 与之前检查过的Weave工具不同，他无法使用执行结果来制作文档。 但是，该工具是轻量级的，主要侧重于文档代码。 例如，帮助编写可以放在任何markdown平台上的漂亮示例。 通常在其他文档工具链中使用，例如，与<code>Documenter.jl</code>一起使用。 </p><br><p> 输出格式有三个可能的选项-降价，笔记本和脚本（纯Julia代码）。 它们都不执行已执行的代码。 </p><br><p> 带有Markdown注释（在第一个字符＃之后）的示例源文件： </p><br><pre> <code class="plaintext hljs">#!/usr/bin/env julia using Literate Literate.markdown(@__FILE__, pwd()) # documenter=true # # Intro # ## Plot using Plots, DataFrames plot(rand(5,5), linewidth=2, title="My Plot", size = (500, 200)) # ## Some computational results rand(2, 3) DataFrame(rand(2, 3))</code> </pre> <br><p> 如果未明确禁用它们的生成，那么他的工作结果将是Markdown文档和<code>Documenter</code>指令。 </p><br><pre> <code class="markdown hljs"><span class="hljs-code"><span class="hljs-code">` `</span></span><span class="hljs-code"><span class="hljs-code">`@meta EditURL = "https://github.com/TRAVIS_REPO_SLUG/blob/master/" `</span></span> <span class="hljs-code"><span class="hljs-code">`` `</span></span> <span class="hljs-code"><span class="hljs-code">``@example literate_example #!/usr/bin/env julia using Literate Literate.markdown(@__FILE__, pwd(), documenter=true) `</span></span> <span class="hljs-code"><span class="hljs-code">`` # Intro ## Plot `</span></span> <span class="hljs-code"><span class="hljs-code">``@example literate_example using Plots, DataFrames plot(rand(5,5), linewidth=2, title="My Plot", size = (500, 200)) `</span></span> <span class="hljs-code"><span class="hljs-code">`` ## Some computational results `</span></span> <span class="hljs-code"><span class="hljs-code">``@example literate_example rand(2, 3) DataFrame(rand(2, 3)) `</span></span> `` <span class="hljs-emphasis"><span class="hljs-emphasis">*This page was generated using [Literate.jl](https://github.com/fredrikekre/Literate.jl).*</span></span></code> </pre> <br><p> 故意在markdown内插入代码，在第一个和后续的撇号之间留一个空格，以免在文章发表时弄乱。 </p><br><p> 查看更多详细信息<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://fredrikekre.github.io/Literate.jl/stable/</a> </p><br><h2 id="documenterjl">  Documenter.jl </h2><br><p> 文档生成器。 其主要目的是为以Julia编写的软件包形成可读的文档。  Documenter转换带有Markdown标记和嵌入的Julia代码的html或pdf示例以及模块源文件，以提取Julia-docstrings（Julia自己的注释）。 </p><br><p> 典型文档的示例： </p><br><p><img src="https://habrastorage.org/webt/1b/wc/za/1bwczaoej_07sqjs1qfktzhnhr0.png"></p><br><p> 在本文中，我们将不讨论文档的原理，因为以一种好的方式，这应该作为有关模块开发的单独文章的一部分来完成。 但是，我们将在这里查看Documenter的某些方面。 </p><br><p> 首先，值得一提的是屏幕分为两部分-左侧包含一个交互式目录。 实际上，右侧是文档的文本。 </p><br><p> 具有示例和文档的典型目录结构如下： </p><br><pre> <code class="plaintext hljs"> docs/ src/ make.jl src/ Example.jl ...</code> </pre> <br><p>  <code>docs/src</code>目录是markdown文档。 在<code>src</code>共享源目录的某处可以找到示例。 </p><br><p>  Docuementer的密钥文件是<code>docs/make.jl</code> 该文件的内容适用于Documenter本身： </p><br><pre> <code class="plaintext hljs">using Documenter, DocumenterTools makedocs( modules = [Documenter, DocumenterTools], format = Documenter.HTML( # Use clean URLs, unless built as a "local" build prettyurls = !("local" in ARGS), canonical = "https://juliadocs.github.io/Documenter.jl/stable/", ), clean = false, assets = ["assets/favicon.ico"], sitename = "Documenter.jl", authors = "Michael Hatherly, Morten Piibeleht, and contributors.", analytics = "UA-89508993-1", linkcheck = !("skiplinks" in ARGS), pages = [ "Home" =&gt; "index.md", "Manual" =&gt; Any[ "Guide" =&gt; "man/guide.md", "man/examples.md", "man/syntax.md", "man/doctests.md", "man/latex.md", hide("man/hosting.md", [ "man/hosting/walkthrough.md" ]), "man/other-formats.md", ], "Library" =&gt; Any[ "Public" =&gt; "lib/public.md", hide("Internals" =&gt; "lib/internals.md", Any[ "lib/internals/anchors.md", "lib/internals/builder.md", "lib/internals/cross-references.md", "lib/internals/docchecks.md", "lib/internals/docsystem.md", "lib/internals/doctests.md", "lib/internals/documenter.md", "lib/internals/documentertools.md", "lib/internals/documents.md", "lib/internals/dom.md", "lib/internals/expanders.md", "lib/internals/mdflatten.md", "lib/internals/selectors.md", "lib/internals/textdiff.md", "lib/internals/utilities.md", "lib/internals/writers.md", ]) ], "contributing.md", ], ) deploydocs( repo = "github.com/JuliaDocs/Documenter.jl.git", target = "build", )</code> </pre> <br><p> 如您所见，此处的关键方法是<code>makedocs</code>和<code>deploydocs</code> ，它们确定未来文档的结构以及放置位置。  <code>makedocs</code>提供了从所有指定文件中形成markdown标记的方法，包括执行嵌入式代码和提取文档字符串注释。 </p><br><p>  Documenter支持许多用于插入代码的指令。 他们的格式是`` <code>@something</code> </p><br><ul><li>  <code>@docs</code> ， <code>@autodocs</code>链接到从Julia文件中提取的文档字符串文档。 </li><li>  <code>@ref</code> ， <code>@meta</code> ， <code>@index</code> ， <code>@contents</code>链接，索引页面的指示等。 </li><li>  <code>@example</code> ， <code>@repl</code> ， <code>@eval</code>嵌入式Julia代码的执行模式。 </li><li>  ... </li></ul><br><p> 实际上，指令<code>@example, @repl, @eval</code>的存在决定了是否在此概述中包括Documenter。 而且，前面提到的<code>Literate.jl</code>可以自动生成这样的标记。 也就是说，使用文档生成器作为报告生成器没有任何基本限制。 </p><br><p> 有关Documenter.jl的更多信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://juliadocs.github.io/Documenter.jl/stable/</a> </p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 尽管Julia语言很年轻，但已经为它开发的软件包和工具使我们可以谈论在高负载服务中的充分使用，而不仅仅是试用项目的实施。 如您所见，已经提供了生成各种文档和报告的功能，包括文本和图形形式的代码执行结果。 此外，根据报告的复杂性，我们可以在创建模板的简便性和生成报告的灵活性之间进行选择。 </p><br><p> 本文不考虑来自Genie.jl包的Flax生成器。  Genie.jl是尝试在Rails上实现Julia的尝试，而Flax是eRubis的一种类似形式，为Julia插入了代码。 但是，Flax不作为单独的软件包提供，并且Genie不包含在主软件包存储库中，因此此审阅未将其包括在内。 </p><br><p> 另外，我想提到<a href="">Makie.jl</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Luxor.jl软件包</a> ，它们提供了复杂的矢量可视化的形式。 他们的工作结果也可以用作报告的一部分，但与此相关的另一篇文章也应写成。 </p><br><h2 id="ssylki"> 参考文献 </h2><br><ul><li>  <a href="">Jupyter笔记本/ IJulia</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文字</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">编织</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Literate.jl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Documenter.jl</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN439442/">https://habr.com/ru/post/zh-CN439442/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN439430/index.html">如果可以的话相信我。 水表。 第一部分</a></li>
<li><a href="../zh-CN439432/index.html">如何在1.5年内成为一名Java开发人员</a></li>
<li><a href="../zh-CN439434/index.html">NestJS-Node.js上的真实后端</a></li>
<li><a href="../zh-CN439436/index.html">在俄罗斯减少小批量电子产品的成本。 WOLNA网络广播案例</a></li>
<li><a href="../zh-CN439440/index.html">实施Zimbra协作开源，通过AD授权，并自动创建邮箱</a></li>
<li><a href="../zh-CN439446/index.html">您需要了解的JavaScript Engine Switcher 3.0</a></li>
<li><a href="../zh-CN439448/index.html">您希望毕业生对虚拟化有何疑问？</a></li>
<li><a href="../zh-CN439450/index.html">Milander公司的家用微控制器上的RS-485</a></li>
<li><a href="../zh-CN439454/index.html">程序即艺术-一种新的软件管理范例</a></li>
<li><a href="../zh-CN439456/index.html">时髦播客＃2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>