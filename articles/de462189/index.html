<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👧 🕯️ 🚴🏽 Ätzen von Daten mit Travajs 🗂️ 🤚 💃🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In meinem vorherigen Beitrag habe ich die wichtigsten Punkte bei der Entwicklung einer anderen OpenSource-Bibliothek beschrieben . Ich habe vergessen,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ätzen von Daten mit Travajs</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462189/"><img src="https://habrastorage.org/webt/kb/fw/tm/kbfwtmm5xe1jxdaa1l2avw8geuo.jpeg"><br><br>  In meinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Beitrag habe</a> ich die wichtigsten Punkte bei der Entwicklung einer anderen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenSource-Bibliothek beschrieben</a> .  Ich habe vergessen, noch etwas zu erwähnen: Wenn Sie niemandem von der Bibliothek erzählen, was auch immer es sein mag, wird höchstwahrscheinlich niemand davon erfahren. <br><br>  Treffen Sie also <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">trava.js</a> - eine saftige Validierung zum Nutzen des Projekts.  Übrigens verwenden wir seit mehr als sechs Monaten Gras, und ich dachte, es wäre an der Zeit, Ihnen die Vorteile der Verwendung zu erläutern.  Bereits getrocknet, also halten Sie den Atem an.  Und mach weiter. <br><a name="habracut"></a><br><h2>  Konzept </h2><br>  Auf den ersten Blick scheint die Validierung ein triviales Thema zu sein, das keine besondere Aufmerksamkeit erfordert.  Der Wert ist entweder wahr oder nicht, was einfacher sein könnte: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// any checking... if (!check(value)) return false; return true; }</span></span></code> </pre> <br>  Aber normalerweise wäre es schön zu wissen, was genau schief gelaufen ist: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!check1(value)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'ERROR_1'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!check2(value)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'ERROR_2'</span></span>; }</code> </pre><br>  Eigentlich ist das alles, das Problem ist gelöst. <br><br>  Wenn nicht für ein "aber". <br><br>  Aus der Erfahrung mit der Entwicklung realer Anwendungen wurde festgestellt, dass die Angelegenheit nicht mit der Validierung endet.  In der Regel müssen diese Daten auch in ein bestimmtes Format konvertiert werden, aus irgendeinem Grund, der vom Serializer nicht sofort unterstützt wird, z. B. Datumsangaben, Sätze oder andere benutzerdefinierte Datentypen.  Da dies hauptsächlich JSON ist, stellt sich in der Praxis heraus, dass Sie während der Validierung und Transformation einen doppelten Durchlauf durch die Eingabedatenstruktur durchführen müssen.  Die Idee kam auf, warum nicht diese beiden Stufen zu einer kombinieren.  Ein mögliches Plus wäre auch das Vorhandensein eines expliziten deklarativen Datenschemas. <br><br>  Um die Konvertierung eines Werts in ein bestimmtes Format zu unterstützen, muss der Validator nicht nur einen Fehler, sondern auch einen reduzierten Wert zurückgeben können.  In der js-Welt sind mehrere Schnittstellenoptionen mit möglichen Fehlerrückgaben ziemlich häufig. <br><br><ol><li>  Am häufigsten ist wahrscheinlich die Rückgabe des Tupels [error, data]: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!check1(value)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'ERROR_1'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!check2(value)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'ERROR_2'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, value]; }</code> </pre> <br>  Es gibt auch eine ähnliche Option, bei der kein Array zurückgegeben wird, sondern das Objekt <i>{error, data}</i> , aber es gibt keine grundlegenden Unterschiede.  Der Vorteil dieses Ansatzes ist die Offensichtlichkeit, das Minus ist, dass Sie diesen Vertrag jetzt überall pflegen müssen.  Für die Validierung verursacht dies keine Unannehmlichkeiten, für Transformationen ist dies jedoch eindeutig überflüssig. <br></li><li>  Verwenden Sie Ausnahmen.  Obwohl meiner Meinung nach ein Validierungsfehler eine Standardsituation in der Anwendung ist, ist nichts außergewöhnlich.  Ehrlich gesagt denke ich, dass Ausnahmen am besten nur verwendet werden, wenn etwas wirklich schief gelaufen ist.  Außerdem können Ausnahmen versehentlich in den Validatoren selbst aufgerufen werden, und dann wissen Sie möglicherweise überhaupt nicht, dass es sich um einen Fehler im Code und nicht im Wert handelt.  Der Vorteil des Ansatzes ist die Vereinfachung der Schnittstelle - jetzt wird der Wert immer auf die übliche Weise zurückgegeben und der Fehler wird als Ausnahme ausgelöst. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Es besteht die Möglichkeit</a> , einen Fehler in eine globale Variable einzufügen.  Aber ich würde den Staat nicht unnötig ziehen. <br></li><li>  Verwenden Sie für Fehler einen separaten Typ.  Es sieht aus wie die Option mit Ausnahmen, wenn Sie die Art des Fehlers von ihnen nehmen, aber nicht wegwerfen. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!check1(value)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Trava.ValidationError({ <span class="hljs-attr"><span class="hljs-attr">code</span></span>: <span class="hljs-number"><span class="hljs-number">401</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!check2(value)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Trava.ValidationError({ <span class="hljs-attr"><span class="hljs-attr">code</span></span>: <span class="hljs-number"><span class="hljs-number">405</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parseOrTransform(value); <span class="hljs-comment"><span class="hljs-comment">// apply some parse or transform }</span></span></code> </pre> <br></li></ol>  Ich habe mich für die letztere Option entschieden, obwohl dies auch ein Kompromiss ist, aber insgesamt nicht schlecht.  <i>Trava.ValidationError wird</i> als Typ für den Fehler vorgeschlagen, der vom Standardfehler erbt und die Möglichkeit bietet, einen beliebigen Datentyp zum Melden eines Fehlers zu verwenden.  Es ist nicht erforderlich, <i>Trava.ValidationError</i> zu verwenden. Sie können den Standardfehler verwenden. <i>Vergessen</i> Sie jedoch nicht, dass die Fehlermeldung nur aus Zeichenfolgen besteht. <br><br>  Zusammenfassend können wir sagen, dass der Validator eine saubere, synchrone Funktion ist, die zusätzlich zum Wert einen Fehler zurückgeben kann.  Sehr einfach.  Und diese Theorie funktioniert gut ohne Bibliotheken.  In der Praxis werden Validatoren zu Ketten und Hierarchien zusammengefasst, und hier wird das Gras definitiv nützlich sein. <br><br><h2>  Zusammensetzung </h2><br>  Vielleicht ist die Zusammensetzung der häufigste Fall bei der Arbeit mit Validatoren.  Die Umsetzung der Zusammensetzung kann unterschiedlich sein.  In den berühmten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bibliotheken</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">joi</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">v8n</a> erfolgt dies beispielsweise über ein Objekt und eine Methodenkette: <br><br><pre> <code class="javascript hljs">Joi.string().alphanum().min(<span class="hljs-number"><span class="hljs-number">0</span></span>).max(<span class="hljs-number"><span class="hljs-number">255</span></span>)</code> </pre> <br>  Obwohl es auf den ersten Blick schön aussieht, hat dieser Ansatz mehrere Nachteile, und einer ist fatal.  Und hier ist das Ding.  Nach meiner Erfahrung ist ein Validator immer eine Sache für eine bestimmte Anwendung, daher sollte das Hauptaugenmerk in der Bibliothek auf der Bequemlichkeit der Erweiterung der Validatoren und der Integration in den bestehenden Ansatz liegen und nicht auf der Anzahl der Grundelemente, die meiner Meinung nach nur der Bibliothek Gewicht verleihen, sondern Die meisten werden nicht verwendet.  Nehmen Sie zum Beispiel den gleichen Validator für die Zeichenfolge.  Dann stellt sich heraus, dass Sie die Leerzeichen von den Enden abschneiden müssen, dann müssen Sie plötzlich die Verwendung von Sonderzeichen in einem einzigen Fall zulassen und irgendwo müssen Sie zu Kleinbuchstaben usw. führen.  Tatsächlich kann es unendlich viele solcher Grundelemente geben, und ich sehe keinen Sinn darin, sie überhaupt zur Bibliothek hinzuzufügen.  Meiner Meinung nach ist die Verwendung von Objekten ebenfalls redundant und führt zu einer Zunahme der Komplexität während der Erweiterung, obwohl dies auf den ersten Blick das Leben einfacher zu machen scheint.  Zum Beispiel <i>ist es</i> nicht so einfach <a href="">, Ihren Validator zu schreiben</a> . <br><br>  Ein funktionaler Ansatz und Gras hier können helfen.  Das gleiche Beispiel für die Validierung einer im Bereich von 0 bis 255 angegebenen Zahl: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    const isNumber = n =&gt; typeof n == 'number' &amp;&amp; !isNaN(n); //  const numberValidator = Trava.Check(isNumber); const byteValidator = Trava.Compose([ numberValidator, Trava.Check(n =&gt; 0 &lt;= n &amp;&amp; n &lt; 256), ]); byteValidator(-1); // !</span></span></code> </pre><br>  Die <b>Check-</b> Anweisung macht aus der Wahrheitsprüfung einen Validator (Wert =&gt; wahr / falsch).  Und <b>Compose verkettet die</b> Validatoren.  Bei der Ausführung wird die Kette nach dem ersten Fehler unterbrochen.  Wichtig ist, dass überall gewöhnliche Funktionen verwendet werden, die sehr einfach zu erweitern und zu verwenden sind.  Diese einfache Erweiterung ist meiner Meinung nach ein wesentliches Merkmal einer gültigen Validierungsbibliothek. <br><br>  Traditionell wird ein separater Platz in der Validierung belegt, indem nach <i>null</i> und <i>undefiniert gesucht wird</i> .  Hierfür gibt es Hilfskräfte im Gras: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   null  undefined const requiredNumberValidator = Trava.Required(numberValidator); requiredNumberValidator(undefined); // ! const optNumberValidator = Trava.Optional(numberValidator, 2); // 2 is default optNumberValidator(undefined); // 2 optNumberValidator(null); // null const nullNumberValidator = Trava.Nullable(numberValidator, 3); // 3 is default nullNumberValidator(undefined); // 3 nullNumberValidator(null); // 3</span></span></code> </pre><br>  Es gibt mehrere weitere Helfer im Gras, und alle komponieren wunderschön und erweitern sich überraschend einfach.  Wie gewöhnliche Funktionen :) <br><br><h2>  Hierarchie </h2><br>  Einfache Datentypen sind in einer Hierarchie organisiert.  Die häufigsten Fälle sind Objekte und Arrays.  Es gibt Bediener im Gras, die die Arbeit mit ihnen erleichtern: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   const byteArrayValidator = Trava.Each(byteValidator); byteArrayValidator([1, -1, 2, -3]); // ValidationError: {"1":"Incorrect value","3":"Incorrect value"} //   const pointValidator = Trava.Keys({ x: numberValidator, y: numberValidator, }); pointValidator({x: 1, y: 'a'}); // ValidationError: {"y":"Incorrect value"}</span></span></code> </pre><br>  Bei der Validierung von Objekten wurde beschlossen, den Schweregrad der Definition hervorzuheben: Alle Schlüssel sind standardmäßig erforderlich (eingeschlossen in <b>Erforderlich</b> ).  Schlüssel, die nicht im Validator angegeben sind, werden verworfen. <br><br>  Einige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jsonschema</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quartettlösungen</a> bevorzugen es, Validatoren in Form von Daten zu beschreiben, zum Beispiel {x: 'number', y: 'number'}, aber dies führt zu den gleichen Schwierigkeiten beim Erweitern.  Ein wesentlicher Vorteil dieses Ansatzes ist die Möglichkeit der Serialisierung und des Austauschs von Schaltungen, die mit Funktionen unmöglich ist.  Dies kann jedoch problemlos über die Funktionsschnittstelle implementiert werden.  Keine Notwendigkeit, Funktionen hinter den Linien zu verstecken!  Funktionen haben bereits Namen und das ist alles, was benötigt wird. <br><br>  Zur Vereinfachung der Verwendung in Validatoren können die Operatoren <b>Compose</b> und <b>Keys</b> weggelassen werden. Es ist auch praktisch, den Root-Validator in <b>Trava</b> zu verpacken: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pointValidator = Trava({ <span class="hljs-comment"><span class="hljs-comment">//  -&gt; Keys x: [numberValidator, Trava.Check(v =&gt; v &gt; 180)], //  -&gt; Compose y: [numberValidator, Trava.Check(v =&gt; v &lt; 180)], });</span></span></code> </pre> <br>  Wenn Sie <b>Trava</b> mit dem zweiten Argument aufrufen, ist der Rückgabewert das Ergebnis der Anwendung des Validators: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> point = Trava({ <span class="hljs-attr"><span class="hljs-attr">x</span></span>: [numberValidator, Trava.Check(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> v &gt; <span class="hljs-number"><span class="hljs-number">180</span></span>)], <span class="hljs-attr"><span class="hljs-attr">y</span></span>: [numberValidator, Trava.Check(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> v &lt; <span class="hljs-number"><span class="hljs-number">180</span></span>)], }, <span class="hljs-comment"><span class="hljs-comment">//      { x: 200, y: 100, }); // { x: 200, y: 100 }</span></span></code> </pre> <br>  Bisher wurde die Unterstützung nur für Arrays und Objekte implementiert  im Grunde JSON vergiften und das ist genug.  Pull Anfragen für Wellcome! <br><br><h2>  Kontext </h2><br>  Wenn Sie den Validator als letzten Parameter verwenden, können Sie den Kontext, auf den alle aufgerufenen Validatoren zugreifen können, als letzten Parameter übergeben.  Persönlich hat sich diese Gelegenheit für mich noch nicht als nützlich erwiesen, aber es ist möglich. <br><br>  Für einige Validatoren, die möglicherweise einen Fehler zurückgeben, ist es möglich, eine Fehlermeldung auf verschiedenen Ebenen zu definieren.  Ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pos = Trava.Check(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> v &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); pos(<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ValidationError: "Incorrect value" (by default)</span></span></code> </pre><br>  Überschreiben für einen Einzelfall: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pos = Trava.Check(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> v &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"    "</span></span>); pos(<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ValidationError: "    "</span></span></code> </pre><br>  Überschreiben für alle Fälle: <br><br><pre> <code class="javascript hljs">Trava.Check.ErrorMessage = <span class="hljs-string"><span class="hljs-string">" "</span></span>; pos(<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ValidationError: " "</span></span></code> </pre><br>  Für eine detailliertere Konfiguration können Sie auch eine Funktion an der Stelle des Fehlers übertragen, die einen Fehler zurückgeben sollte und mit den Validatorparametern aufgerufen wird. <br><br><h2>  Anwendungsfall </h2><br>  Meistens vergiften wir JSON im Backend zusammen mit Koa.  Das Frontend setzt sich ebenfalls langsam auf.  Es ist zweckmäßig, an beiden Enden gemeinsame Prüfer zu haben.  Und jetzt werde ich einen fast realen Anwendungsfall zeigen.  Angenommen, Sie möchten eine API zum Erstellen und Aktualisieren von Patientendaten implementieren. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// validators.js const trava = require('trava'); const { isFilledString, isDate, isNumber } = require('../common/validators'); const patientSchema = { name: isFilledString, dateOfBirth: isDate, height: isNumber, } //        //      const patientNew = trava(patientSchema); //      const patientPatch = trava(mapValues(patientSchema, trava.Optional)); module.exports = { patientNew, patientPatch, }; // controllers.js const validate = require('./validators'); const { ValidationError } = require('../common/errors'); function create (ctx) { const patientData = validate.patientNew(ctx.request.body); //       Error,             Error if (patientData instanceof Error) return ValidationError(ctx, patientData); // ...create new patient } function update (ctx) { const patientData = validate.patientPatch(ctx.request.body); if (patientData instanceof Error) return ValidationError(ctx, patientData); // ...update patient data }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">common / error.js</b> <div class="spoiler_text">  const trava = erfordern ('trava'); <br><br>  Funktion ValidationError (ctx, params) { <br>  if (params instanceof Error) { <br>  params = trava.ValidationError.extractData (params); <br>  }} <br>  ctx.body = { <br>  Code: 'VALIDATION_ERROR', <br>  params, <br>  }; <br>  ctx.status = HttpStatus.BAD_REQUEST; <br>  }} <br></div></div><br>  Obwohl das Beispiel sehr einfach ist, kann es nicht als vereinfacht bezeichnet werden.  In einer realen Anwendung sind nur Validatoren kompliziert.  Sie können die Validierung auch in Middleware durchführen. Der Validator wird vollständig auf den Kontext oder den Anforderungshauptteil angewendet. <br><br>  Während des Arbeitens und der Verwendung der Validierung kamen wir zu dem Schluss, dass einfache synchrone Validatoren und einfache Fehlermeldungen völlig ausreichend sind.  Tatsächlich kamen wir zu dem Schluss, dass wir nur zwei Nachrichten verwenden: "ERFORDERLICH" und "UNGÜLTIG", die zusammen mit den Eingabeaufforderungen für die Felder im Frontend lokalisiert sind.  Andere Überprüfungen, die zusätzliche Aktionen erfordern (z. B. bei der Registrierung, um zu überprüfen, ob solche E-Mails bereits vorhanden sind), liegen außerhalb des Validierungsbereichs.  In jedem Fall geht es im Gras nicht um diesen Fall. <br><br><h2>  Abschließend </h2><br>  In diesem kurzen Artikel habe ich fast die gesamte Funktionalität der Bibliothek beschrieben. Außerhalb des Geltungsbereichs des Artikels gibt es mehrere Helfer, die das Leben vereinfachen.  Ich bitte um Details auf github <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/uNmAnNeR/travajs</a> . <br><br>  Wir brauchten ein Werkzeug, das so individuell wie möglich angepasst werden kann, in dem nichts überflüssig ist, aber gleichzeitig alles für die tägliche Arbeit notwendig ist.  Und ich denke im Allgemeinen wurde dies erreicht, ich hoffe, jemand wird auch das Leben leichter machen.  Ich freue mich über Wünsche und Anregungen. <br>  Gesundheit. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462189/">https://habr.com/ru/post/de462189/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462175/index.html">Wir beschäftigen uns mit lateinischen Abkürzungen und Phrasen in Englisch</a></li>
<li><a href="../de462177/index.html">Fototour durch das nach Fersman benannte Mineralogische Museum</a></li>
<li><a href="../de462179/index.html">F-Strings oder wie man den Code etwas schneller und lesbarer macht</a></li>
<li><a href="../de462181/index.html">Regeln für eine effektive Kommunikation in Gruppenchats</a></li>
<li><a href="../de462185/index.html">Die Revolution ist vorbei. Gibt es eine Alternative zu einem Lithium-Ionen-Akku?</a></li>
<li><a href="../de462191/index.html">DataArt Museum: Eine Tour durch Norditalien</a></li>
<li><a href="../de462197/index.html">Tipps, wie Sie Ihren Geist befreien und Ihre Kreativität steigern können</a></li>
<li><a href="../de462203/index.html">KVM (unter) VDI mit einmaligen virtuellen Maschinen unter Verwendung von Bash</a></li>
<li><a href="../de462205/index.html">PHDays 9 gewinnen The Standoff: Die Chronik des True0xA3-Teams</a></li>
<li><a href="../de462209/index.html">Polycom VideoConference-Lösungen. Erinnerungen 6 Jahre später ... Stufe 2. Teil 1. RMX1500</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>