<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¶üèæ üòô üí∞ Asynchroner Stream in C # 8 üåæ üè∑Ô∏è üó∫Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Async / Await-Funktionalit√§t wurde in C # 5 eingef√ºhrt, um die Reaktionsf√§higkeit der Benutzeroberfl√§che und den Webzugriff auf Ressourcen zu verb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Asynchroner Stream in C # 8</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/462755/"><p>  Die Async / Await-Funktionalit√§t wurde in C # 5 eingef√ºhrt, um die Reaktionsf√§higkeit der Benutzeroberfl√§che und den Webzugriff auf Ressourcen zu verbessern.  Mit anderen Worten, asynchrone Methoden helfen Entwicklern, asynchrone Operationen auszuf√ºhren, die keine Threads blockieren und ein einzelnes skalares Ergebnis zur√ºckgeben.  Nach zahlreichen Versuchen von Microsoft, asynchrone Vorg√§nge zu vereinfachen, hat die Vorlage async / await dank eines einfachen Ansatzes bei Entwicklern einen guten Ruf erlangt. </p><br><p> Bestehende asynchrone Methoden sind erheblich eingeschr√§nkt, da sie nur einen Wert zur√ºckgeben sollten.  Schauen wir uns eine <code>async Task&lt;int&gt; DoAnythingAsync()</code> -Methode an, die f√ºr eine solche Syntax √ºblich ist.  Das Ergebnis seiner Arbeit ist eine Bedeutung.  Aufgrund dieser Einschr√§nkung k√∂nnen Sie diese Funktion nicht mit dem Schl√ºsselwort <code>yield</code> und der asynchronen <code>IEnumerable&lt;int&gt;</code> -Schnittstelle verwenden (um das Ergebnis einer asynchronen Aufz√§hlung zur√ºckzugeben). </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/fp/yf/bo/fpyfbog_pbidr2p7wwilr6ghspa.jpeg"></a> </p><a name="habracut"></a><br><p>  Wenn Sie die <code>async/await</code> Funktion und die <code>yield</code> kombinieren, k√∂nnen Sie ein leistungsstarkes Programmiermodell verwenden, das als <strong>asynchrones Daten-Pull bezeichnet wird</strong> , oder eine <strong>Pull-basierte Aufz√§hlungsaufz√§hlung</strong> oder eine asynchrone <strong>Async-Sequenz</strong> , wie sie in F # genannt wird. </p><br><p>  Die neue M√∂glichkeit, asynchrone Threads in C # 8 zu verwenden, hebt die mit der R√ºckgabe eines einzelnen Ergebnisses verbundene Einschr√§nkung auf und erm√∂glicht der asynchronen Methode die R√ºckgabe mehrerer Werte.  Diese √Ñnderungen geben der asynchronen Vorlage mehr Flexibilit√§t, und der Benutzer kann Daten von irgendwo (z. B. aus der Datenbank) mithilfe verz√∂gerter asynchroner Sequenzen abrufen oder Daten von asynchronen Sequenzen in Teilen empfangen, sofern verf√ºgbar. </p><br><p>  Ein Beispiel: </p><br><pre> <code class="plaintext hljs">foreach await (var streamChunck in asyncStreams) { Console.WriteLine($‚ÄúReceived data count = {streamChunck.Count}‚Äù); }</code> </pre> <br><p>  Ein anderer Ansatz zur L√∂sung von Problemen im Zusammenhang mit der asynchronen Programmierung ist die Verwendung von reaktiven Erweiterungen (Rx).  <code>Rx</code> gewinnt unter Entwicklern an Bedeutung und diese Methode wird in vielen Programmiersprachen verwendet, beispielsweise Java (RxJava) und JavaScript (RxJS). </p><br><p>  Rx basiert auf einem Push-Push-Modell (Tell Don't Ask-Prinzip), das auch als reaktive Programmierung bezeichnet wird.  Das hei√üt,  Im Gegensatz zu IEnumerable signalisiert der Datenprovider dem Verbraucher, dass ein neues Element in der Sequenz erscheint, wenn der Verbraucher das n√§chste Element im Rx-Modell anfordert.  Daten werden im asynchronen Modus in die Warteschlange gestellt und vom Verbraucher zum Zeitpunkt des Empfangs verwendet. </p><br><p>  In diesem Artikel werde ich ein Modell, das auf Push-Daten basiert (z. B. Rx), mit einem Modell vergleichen, das auf Pull-Daten basiert (z. B. IEnumerable), und zeigen, welche Szenarien f√ºr welches Modell am besten geeignet sind.  Das gesamte Konzept und die Vorteile werden anhand verschiedener Beispiele und des Demo-Codes untersucht.  Am Ende werde ich die Anwendung zeigen und sie anhand eines Codebeispiels demonstrieren. </p><br><h2 id="sravnenie-modeli-na-osnove-protalkivaniya-dannyh-s-modelyu-na-osnove-vytyagivaniya-dannyh-pull-">  Vergleich eines Modells basierend auf dem Pushing von Daten mit einem Modell basierend auf dem Pulling von Daten (Pull-) </h2><br><p><img src="https://habrastorage.org/webt/h7/hs/o8/h7hso8a8enkl-ujguuyxmzi_ova.jpeg"><br>  <em>Abb.</em>  <em>-1- Vergleich eines Modells basierend auf Datenabruf mit einem Modell basierend auf Daten Pushing</em> </p><br><p>  Diese Beispiele basieren auf der Beziehung zwischen dem Datenanbieter und dem Verbraucher, wie in Abb.  -1-.  Ein Pull-basiertes Modell ist leicht zu verstehen.  Darin fordert der Verbraucher Daten vom Lieferanten an und empf√§ngt diese.  Ein alternativer Ansatz ist ein Push-Push-Modell.  Hier ver√∂ffentlicht der Anbieter die Daten in der Warteschlange und der Verbraucher muss sie abonnieren, um sie zu erhalten. </p><br><p>  Das Data-Pull-Modell eignet sich f√ºr F√§lle, in denen der Anbieter Daten schneller generiert, als der Verbraucher sie verwendet.  Somit erh√§lt der Verbraucher nur die erforderlichen Daten, wodurch √úberlaufprobleme vermieden werden.  Wenn der Verbraucher die Daten schneller verwendet als der Lieferant sie produziert, ist ein Modell geeignet, das auf dem Pushen der Daten basiert.  In diesem Fall kann der Lieferant mehr Daten an den Verbraucher senden, damit keine unn√∂tigen Verz√∂gerungen auftreten. </p><br><p>  Rx- und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Akka-Streams</a> (ein str√∂mungsbasiertes Programmiermodell) verwenden die Gegendruckmethode, um den Durchfluss zu steuern.  Um die oben beschriebenen Probleme des Lieferanten und des Empf√§ngers zu l√∂sen, verwendet das Verfahren sowohl Push- als auch Pulling-Daten. </p><br><p>  Im folgenden Beispiel bezieht ein langsamer Verbraucher Daten von einem schnelleren Anbieter.  Nachdem der Verbraucher das aktuelle Element verarbeitet hat, fragt er den Lieferanten nach dem n√§chsten und so weiter bis zum Ende der Sequenz. </p><br><h2 id="motivaciya-dlya-ispolzovaniya-i-osnovnaya-informaciya">  Nutzungsmotivation und Basisinformationen </h2><br><p>  Beachten Sie den folgenden Code, um den gesamten Bedarf an asynchronen Threads zu verstehen. </p><br><pre> <code class="plaintext hljs">//       (count) static int SumFromOneToCount(int count) { ConsoleExt.WriteLine("SumFromOneToCount called!"); var sum = 0; for (var i = 0; i &lt;= count; i++) { sum = sum + i; } return sum; } //  : const int count = 5; ConsoleExt.WriteLine($"Starting the application with count: {count}!"); ConsoleExt.WriteLine("Classic sum starting."); ConsoleExt.WriteLine($"Classic sum result: {SumFromOneToCount(count)}"); ConsoleExt.WriteLine("Classic sum completed."); ConsoleExt.WriteLine("################################################"); ConsoleExt.WriteLine(Environment.NewLine);</code> </pre> <br><p>  Fazit: <br><img src="https://habrastorage.org/webt/m4/sf/kc/m4sfkcjbubb58prlmy2x_a8rm2u.jpeg"></p><br><p>  Wir k√∂nnen die Methode mithilfe der Yield-Anweisung verschieben, wie unten gezeigt. </p><br><pre> <code class="plaintext hljs">static IEnumerable&lt;int&gt; SumFromOneToCountYield(int count) { ConsoleExt.WriteLine("SumFromOneToCountYield called!"); var sum = 0; for (var i = 0; i &lt;= count; i++) { sum = sum + i; yield return sum; } }</code> </pre> <br><p>  Methodenaufruf </p><br><pre> <code class="plaintext hljs">const int count = 5; ConsoleExt.WriteLine("Sum with yield starting."); foreach (var i in SumFromOneToCountYield(count)) { ConsoleExt.WriteLine($"Yield sum: {i}"); } ConsoleExt.WriteLine("Sum with yield completed."); ConsoleExt.WriteLine("################################################"); ConsoleExt.WriteLine(Environment.NewLine);</code> </pre> <br><p>  Fazit: <br><img src="https://habrastorage.org/webt/oc/if/3l/ocif3lcjnm3pjaob8sje3ladu8u.jpeg"></p><br><p>  Wie im obigen Ausgabefenster gezeigt, wird das Ergebnis in Teilen und nicht in einem einzelnen Wert zur√ºckgegeben.  Die oben gezeigten zusammenfassenden Ergebnisse werden als verz√∂gerte Auflistung bezeichnet.  Das Problem ist jedoch immer noch nicht behoben: Summierungsmethoden blockieren den Code.  Wenn Sie sich die Threads ansehen, k√∂nnen Sie sehen, dass im Haupt-Thread alles l√§uft. </p><br><p>  Wenden wir das asynchrone Zauberwort auf die erste SumFromOneToCount-Methode an (ohne Ausbeute). </p><br><pre> <code class="plaintext hljs">static async Task&lt;int&gt; SumFromOneToCountAsync(int count) { ConsoleExt.WriteLine("SumFromOneToCountAsync called!"); var result = await Task.Run(() =&gt; { var sum = 0; for (var i = 0; i &lt;= count; i++) { sum = sum + i; } return sum; }); return result; }</code> </pre> <br><p>  Methodenaufruf </p><br><pre> <code class="plaintext hljs">const int count = 5; ConsoleExt.WriteLine("async example starting."); //      . ,  . ,        . var result = await SumFromOneToCountAsync(count); ConsoleExt.WriteLine("async Result: " + result); ConsoleExt.WriteLine("async completed."); ConsoleExt.WriteLine("################################################"); ConsoleExt.WriteLine(Environment.NewLine);</code> </pre> <br><p>  Fazit: <br><img src="https://habrastorage.org/webt/hp/7s/_a/hp7s_aqgqzi3aeiemsauitygcbo.jpeg"></p><br><p>  Gro√üartig.  Jetzt werden die Berechnungen in einem anderen Thread durchgef√ºhrt, aber das Problem mit dem Ergebnis besteht weiterhin.  Das System gibt das Ergebnis mit einem einzelnen Wert zur√ºck. <br>  Stellen Sie sich vor, wir k√∂nnen verz√∂gerte Aufz√§hlungen (Yield-Anweisung) und asynchrone Methoden in einem imperativen Programmierstil kombinieren.  Die Kombination wird als asynchrone Streams bezeichnet. Dies ist eine neue Funktion in C # 8. Sie eignet sich hervorragend zur L√∂sung von Problemen im Zusammenhang mit einem Programmiermodell, das auf Datenextraktion basiert, z. B. zum Herunterladen von Daten von einer Site oder zum Lesen von Datens√§tzen in einer Datei oder Datenbank auf moderne Weise. </p><br><p>  Versuchen wir dies in der aktuellen Version von C #.  Ich werde das asynchrone Schl√ºsselwort der SumFromOneToCountYield-Methode wie folgt hinzuf√ºgen: </p><br><p><img src="https://habrastorage.org/webt/se/3a/lw/se3alwvhqedkwzkmxti4ewc8sgc.jpeg"><br>  <em>Abb.</em>  <em>-2- Fehler bei gleichzeitiger Verwendung von Yield und Async Keyword.</em> </p><br><p>  Wenn wir versuchen, SumFromOneToCountYield asynchron hinzuzuf√ºgen, tritt ein Fehler wie oben gezeigt auf. <br>  Lass es uns anders versuchen.  Wir k√∂nnen das Yield-Schl√ºsselwort entfernen und IEnumerable in der Aufgabe anwenden, wie unten gezeigt: </p><br><pre> <code class="plaintext hljs">static async Task&lt;IEnumerable&lt;int&gt;&gt; SumFromOneToCountTaskIEnumerable(int count) { ConsoleExt.WriteLine("SumFromOneToCountAsyncIEnumerable called!"); var collection = new Collection&lt;int&gt;(); var result = await Task.Run(() =&gt; { var sum = 0; for (var i = 0; i &lt;= count; i++) { sum = sum + i; collection.Add(sum); } return collection; }); return result; }</code> </pre> <br><p>  Methodenaufruf </p><br><pre> <code class="plaintext hljs">const int count = 5; ConsoleExt.WriteLine("SumFromOneToCountAsyncIEnumerable started!"); var scs = await SumFromOneToCountTaskIEnumerable(count); ConsoleExt.WriteLine("SumFromOneToCountAsyncIEnumerable done!"); foreach (var sc in scs) { //   ,  .     . ConsoleExt.WriteLine($"AsyncIEnumerable Result: {sc}"); } ConsoleExt.WriteLine("################################################"); ConsoleExt.WriteLine(Environment.NewLine);</code> </pre> <br><p>  Fazit: <br><img src="https://habrastorage.org/webt/_f/ze/zl/_fzezlq44tw70sojrtlq-3wyvvw.jpeg"></p><br><p>  Wie Sie dem Beispiel entnehmen k√∂nnen, wird alles im asynchronen Modus berechnet, das Problem bleibt jedoch weiterhin bestehen.  Ergebnisse (alle Ergebnisse werden in einer Sammlung gesammelt) werden als einzelner Block zur√ºckgegeben.  Und das brauchen wir nicht.  Wenn Sie sich erinnern, war es unser Ziel, den asynchronen Berechnungsmodus mit der M√∂glichkeit einer Verz√∂gerung zu kombinieren. </p><br><p>  Dazu m√ºssen Sie eine externe Bibliothek verwenden, z. B. Ix (Teil von Rx) oder asynchrone Threads, die in C # dargestellt werden. </p><br><p>  Kehren wir zu unserem Code zur√ºck.  Um asynchrones Verhalten zu demonstrieren, habe ich eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">externe Bibliothek verwendet</a> . </p><br><pre> <code class="plaintext hljs">static async Task ConsumeAsyncSumSeqeunc(IAsyncEnumerable&lt;int&gt; sequence) { ConsoleExt.WriteLineAsync("ConsumeAsyncSumSeqeunc Called"); await sequence.ForEachAsync(value =&gt; { ConsoleExt.WriteLineAsync($"Consuming the value: {value}"); //    Task.Delay(TimeSpan.FromSeconds(1)).Wait(); }); } static IEnumerable&lt;int&gt; ProduceAsyncSumSeqeunc(int count) { ConsoleExt.WriteLineAsync("ProduceAsyncSumSeqeunc Called"); var sum = 0; for (var i = 0; i &lt;= count; i++) { sum = sum + i; //    Task.Delay(TimeSpan.FromSeconds(0,5)).Wait(); yield return sum; } }</code> </pre> <br><p>  Methodenaufruf </p><br><pre> <code class="plaintext hljs">const int count = 5; ConsoleExt.WriteLine("Starting Async Streams Demo!"); //   .       . IAsyncEnumerable&lt;int&gt; pullBasedAsyncSequence = ProduceAsyncSumSeqeunc(count).ToAsyncEnumerable(); ConsoleExt.WriteLineAsync("X#X#X#X#X#X#X#X#X#X# Doing some other work X#X#X#X#X#X#X#X#X#X#"); //    ;      . var consumingTask = Task.Run(() =&gt; ConsumeAsyncSumSeqeunc(pullBasedAsyncSequence)); //   . ,    . consumingTask.Wait(); ConsoleExt.WriteLineAsync("Async Streams Demo Done!");</code> </pre> <br><p>  Fazit: <br><img src="https://habrastorage.org/webt/-7/62/sa/-762saqp5wmuttffq6aykba57r8.jpeg"></p><br><p>  Schlie√ülich sehen wir das gew√ºnschte Verhalten.  Sie k√∂nnen eine Aufz√§hlungsschleife im asynchronen Modus ausf√ºhren. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Siehe Quellcode hier</a> . </p><br><h2 id="vytyagivanie-dannyh-v-asinhronnom-rezhime-na-primere-klient-servernoy-arhitektury">  Asynchrones Datenabrufen am Beispiel der Client-Server-Architektur </h2><br><p>  Schauen wir uns dieses Konzept mit einem realistischeren Beispiel an.  Alle Vorteile dieser Funktion lassen sich am besten im Kontext der Client-Server-Architektur erkennen. </p><br><h3 id="sinhronnyy-vyzov-v-sluchae-klient-servernoy-arhitektury">  Synchroner Aufruf bei Client-Server-Architektur </h3><br><p>  Wenn eine Anforderung an den Server gesendet wird, muss der Client warten (d. H. Blockiert werden), bis eine Antwort eintrifft, wie in Fig. 4 gezeigt.  -3-. </p><br><p><img src="https://habrastorage.org/webt/dd/kd/ys/ddkdysirir5ubotfcyidzmywice.jpeg"><br>  <em>Abb.</em>  <em>-3- Synchrones Datenabrufen, w√§hrend dessen der Client wartet, bis die Anforderungsverarbeitung abgeschlossen ist</em> </p><br><h3 id="asinhronnoe-vytyagivanie-dannyh">  Asynchrones Datenabrufen </h3><br><p>  In diesem Fall fordert der Client Daten an und f√§hrt mit anderen Aufgaben fort.  Sobald die Daten empfangen wurden, wird der Client die Arbeit fortsetzen. </p><br><p><img src="https://habrastorage.org/webt/nj/gl/k1/njglk1v-exfbnbsm157zihblhbm.jpeg"><br>  <em>Abb.</em>  <em>-4- Asynchrones Datenabrufen, bei dem der Client andere Aufgaben ausf√ºhren kann, w√§hrend Daten angefordert werden</em> </p><br><h2 id="vytyagivanie-dannyh-v-vide-asinhronnoy-posledovatelnosti">  Daten asynchron abrufen </h2><br><p>  In diesem Fall fordert der Client einen Teil der Daten an und f√ºhrt weiterhin andere Aufgaben aus.  Nach dem Empfang der Daten verarbeitet der Client diese und fordert den n√§chsten Teil usw. an, bis alle Daten empfangen wurden.  Aus diesem Szenario entstand die Idee von asynchronen Threads.  In Abb.  -5- zeigt, wie der Client die empfangenen Daten verarbeiten oder andere Aufgaben ausf√ºhren kann. </p><br><p><img src="https://habrastorage.org/webt/tk/f9/5q/tkf95qdq3w_5bg4hiqmkpx4k2y0.jpeg"><br>  <em>Abb.</em>  <em>-5- Abrufen von Daten als asynchrone Sequenz (asynchrone Streams).</em>  <em>Der Client ist nicht blockiert.</em> </p><br><h2 id="asinhronnye-potoki">  Asynchrone Threads </h2><br><p>  Wie bei <code>IEnumerable&lt;T&gt;</code> und <code>IEnumerator&lt;T&gt;</code> gibt es zwei neue <code>IAsyncEnumerable&lt;T&gt;</code> und <code>IAsyncEnumerator&lt;T&gt;</code> -Schnittstellen, die wie <code>IAsyncEnumerator&lt;T&gt;</code> definiert sind: </p><br><pre> <code class="plaintext hljs">public interface IAsyncEnumerable&lt;out T&gt; { IAsyncEnumerator&lt;T&gt; GetAsyncEnumerator(); } public interface IAsyncEnumerator&lt;out T&gt; : IAsyncDisposable { Task&lt;bool&gt; MoveNextAsync(); T Current { get; } } //      public interface IAsyncDisposable { Task DiskposeAsync(); }</code> </pre> <br><p>  In InfoQ hat Jonathan Allen dieses Thema richtig verstanden.  Hier werde ich nicht auf Details eingehen, daher empfehle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ich, seinen Artikel zu lesen</a> . </p><br><p>  Der Fokus liegt auf dem R√ºckgabewert von <code>Task&lt;bool&gt; MoveNextAsync()</code> (ge√§ndert von bool in <code>Task&lt;bool&gt;</code> , <code>bool IEnumerator.MoveNext()</code> ).  Dank ihm werden alle Berechnungen sowie deren Iteration asynchron erfolgen.  Der Verbraucher entscheidet, wann er den n√§chsten Wert erh√§lt.  Obwohl es sich um ein asynchrones Modell handelt, wird immer noch das Abrufen von Daten verwendet.  F√ºr die asynchrone Bereinigung von Ressourcen k√∂nnen Sie die <code>IAsyncDisposable</code> Schnittstelle verwenden.  <a href="">Weitere Informationen zu asynchronen Threads finden Sie hier</a> . </p><br><h2 id="sintaksis">  Syntax </h2><br><p>  Die endg√ºltige Syntax sollte ungef√§hr so ‚Äã‚Äãaussehen: </p><br><pre> <code class="plaintext hljs">foreach await (var dataChunk in asyncStreams) { //        yield    . }</code> </pre> <br><p>  Aus dem obigen Beispiel geht hervor, dass wir anstelle der Berechnung eines einzelnen Werts theoretisch nacheinander eine Reihe von Werten berechnen k√∂nnen, w√§hrend wir auf andere asynchrone Operationen warten. </p><br><h2 id="pererabotannyy-primer-microsoft">  √úberarbeitetes Microsoft-Beispiel </h2><br><p>  Ich habe den Demo-Code von Microsoft neu geschrieben.  Es kann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vollst√§ndig von meinem GitHub-Repository heruntergeladen werden</a> . </p><br><p>  Das Beispiel basiert auf der Idee, einen gro√üen Stream im Speicher (ein Array von 20.000 Bytes) zu erstellen und Elemente im asynchronen Modus nacheinander daraus zu extrahieren.  W√§hrend jeder Iteration werden 8 KB aus dem Array gezogen. </p><br><p><img src="https://habrastorage.org/webt/dc/e8/su/dce8suk_2kzcxekmrxv0uxuxse0.jpeg"></p><br><p><img src="https://habrastorage.org/webt/-r/nx/dk/-rnxdkdf61nc4acry7xknhhubyq.jpeg"></p><br><p>  In Schritt (1) wird ein gro√ües Datenarray erstellt, das mit Dummy-Werten gef√ºllt ist.  Dann wird w√§hrend Schritt (2) eine Variable definiert, die als Pr√ºfsumme bezeichnet wird.  Diese Variable, die die Pr√ºfsumme enth√§lt, soll die Richtigkeit der Summe der Berechnungen √ºberpr√ºfen.  Ein Array und eine Pr√ºfsumme werden im Speicher erstellt und in Schritt (3) als Folge von Elementen zur√ºckgegeben. </p><br><p>  Schritt (4) beinhaltet die Anwendung der <code>AsEnumarble</code> Erweiterungsmethode (der passendere Name ist AsAsyncEnumarble), mit deren Hilfe ein asynchroner Stream von 8 KB simuliert werden kann (BufferSize = 8000 Elemente (6)). </p><br><p>  Das Erben von IAsyncEnumerable ist normalerweise nicht erforderlich. In dem oben gezeigten Beispiel wird diese Operation ausgef√ºhrt, um den Demo-Code zu vereinfachen, wie in Schritt (5) gezeigt. </p><br><p>  Schritt (7) beinhaltet die Verwendung des Schl√ºsselworts <code>foreach</code> , das 8 KB Datenbl√∂cke aus einem asynchronen Datenstrom im Speicher extrahiert.  Der Abrufvorgang erfolgt nacheinander: Wenn der Verbraucher (ein Teil des Codes, der das <code>foreach</code> ) bereit ist, die n√§chsten Daten zu empfangen, zieht er sie vom Anbieter (dem im Stream im Speicher enthaltenen Array).  Wenn der Zyklus abgeschlossen ist, √ºberpr√ºft das Programm schlie√ülich den Wert von 'c' f√ºr die Pr√ºfsumme und zeigt, wenn sie √ºbereinstimmen, die Meldung "Pr√ºfsummen stimmen √ºberein!" Gem√§√ü Schritt (8) an. </p><br><p>  Microsoft Demo-Ausgabefenster: </p><br><p><img src="https://habrastorage.org/webt/_l/cw/2o/_lcw2ofjh0vkrnmwtymlnowxdr8.jpeg"></p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Wir haben uns asynchrone Threads angesehen, die sich hervorragend zum asynchronen Abrufen von Daten und zum Schreiben von Code eignen, der im asynchronen Modus mehrere Werte generiert. <br>  Mit diesem Modell k√∂nnen Sie das n√§chste Datenelement in einer Sequenz abfragen und eine Antwort erhalten.  Es unterscheidet sich vom <code>IObservable&lt;T&gt;</code> Push-Modell, mit dem Werte unabh√§ngig vom Status des Verbrauchers generiert werden.  Mit asynchronen Streams k√∂nnen Sie vom Verbraucher kontrollierte asynchrone Datenquellen perfekt darstellen, wenn er selbst die Bereitschaft bestimmt, die n√§chsten Daten zu akzeptieren.  Beispiele hierf√ºr sind die Verwendung von Webanwendungen oder das Lesen von Datens√§tzen in einer Datenbank. </p><br><p>  Ich habe gezeigt, wie eine Aufz√§hlung im asynchronen Modus erstellt und mithilfe einer externen Bibliothek mit asynchroner Reihenfolge verwendet wird.  Ich habe auch gezeigt, welche Vorteile diese Funktion beim Herunterladen von Inhalten aus dem Internet bietet.  Schlie√ülich haben wir uns die neue Syntax f√ºr asynchrone Threads sowie ein vollst√§ndiges Beispiel f√ºr deren Verwendung auf der Grundlage des Microsoft Build Demo-Codes angesehen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">7. bis 9. Mai 2018 // Seattle, WA</a> ). </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462755/">https://habr.com/ru/post/de462755/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462743/index.html">Moscow SPA Meetup # 5 - Ank√ºndigung des Treffens</a></li>
<li><a href="../de462747/index.html">Ich habe diesen Artikel geschrieben, ohne jemals auf die Tastatur zu schauen</a></li>
<li><a href="../de462749/index.html">Gl√ºcksmanagement: Pflege und Entwicklung eines Home-Office-Teams aus √ºber 30 St√§dten</a></li>
<li><a href="../de462751/index.html">Android-Umgebungen</a></li>
<li><a href="../de462753/index.html">Die Kraft der Generika in Swift. Teil 1</a></li>
<li><a href="../de462763/index.html">GAZ-66 Spielzeug auf dem Bedienfeld. Teil 3</a></li>
<li><a href="../de462765/index.html">ONYX BOOX Note Pro-Test: PDF-Reader der Spitzenklasse</a></li>
<li><a href="../de462769/index.html">Anwendung von maschinellem Lernen und Datenwissenschaft in der Industrie</a></li>
<li><a href="../de462771/index.html">Sie hatten nichts zu verbergen</a></li>
<li><a href="../de462773/index.html">So arbeiten Sie mit Google Trends: Eine vollst√§ndige Anleitung f√ºr Anf√§nger</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>