<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚛 👩🏾‍🎨 🙆🏼 Ecrire TodoMVC sur dap. 2e partie 🆎 🗼 🤳🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il s'agit de la deuxième, dernière partie du didacticiel dans laquelle nous écrivons le client TodoMVC en utilisant le framework ds js réactif minimal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ecrire TodoMVC sur dap. 2e partie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481680/"> Il s'agit de la deuxième, dernière partie du didacticiel dans laquelle nous écrivons le client TodoMVC en utilisant le framework <a href="https://dap.js.org/" rel="nofollow">ds</a> js réactif minimaliste. <br><br>  Résumé de la <a href="https://habr.com/en/post/480912/">première partie</a> : nous avons reçu une liste de tâches du serveur au format JSON, créé une liste HTML à partir de celui-ci, ajouté la possibilité de modifier le nom et le signe d'achèvement pour chaque cas et implémenté une notification du serveur concernant ces modifications. <br><br>  Cela reste à réaliser: suppression de cas arbitraires, ajout de nouveaux cas, installation / réinitialisation de masse et filtrage des cas en fonction de l'achèvement et fonction de suppression de tous les cas terminés.  Voilà ce que nous allons faire.  La version finale du client, à laquelle nous reviendrons dans cet article, peut être consultée <a href="https://dap.js.org/samples/tutorial/16.html" rel="nofollow">ici</a> . <br><br><a name="habracut"></a><br><br>  L'option sur laquelle nous nous sommes décidés la dernière fois peut être rafraîchie <a href="https://dap.js.org/samples/tutorial/7-3.html" rel="nofollow">ici</a> . <br><br>  Voici son code: <br><br><pre><code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'#todoapp'</span></span>.d(<span class="hljs-string"><span class="hljs-string">""</span></span> ,<span class="hljs-string"><span class="hljs-string">'#header'</span></span>.d(<span class="hljs-string"><span class="hljs-string">""</span></span> ,<span class="hljs-string"><span class="hljs-string">'H1'</span></span>.d(<span class="hljs-string"><span class="hljs-string">""</span></span>) ,<span class="hljs-string"><span class="hljs-string">'INPUT#new-todo placeholder="What needs to be done?" autofocus'</span></span>.d(<span class="hljs-string"><span class="hljs-string">""</span></span>) ) ,<span class="hljs-string"><span class="hljs-string">'#main'</span></span>.d(<span class="hljs-string"><span class="hljs-string">""</span></span> ,<span class="hljs-string"><span class="hljs-string">'#toggle-all type=checkbox'</span></span>.d(<span class="hljs-string"><span class="hljs-string">""</span></span>) ,<span class="hljs-string"><span class="hljs-string">'UL#todo-list'</span></span>.d(<span class="hljs-string"><span class="hljs-string">"*@ todos:query"</span></span> ,<span class="hljs-string"><span class="hljs-string">'LI'</span></span>.d(<span class="hljs-string"><span class="hljs-string">"$completed=.completed $editing= $patch=; a!"</span></span> ,<span class="hljs-string"><span class="hljs-string">'INPUT.toggle type=checkbox'</span></span> .d(<span class="hljs-string"><span class="hljs-string">"#.checked=.completed"</span></span>) .ui(<span class="hljs-string"><span class="hljs-string">"$patch=($completed=#.checked)"</span></span>) ,<span class="hljs-string"><span class="hljs-string">'LABEL.view'</span></span> .d(<span class="hljs-string"><span class="hljs-string">"? $editing:!; ! .title"</span></span>) .e(<span class="hljs-string"><span class="hljs-string">"dblclick"</span></span>,<span class="hljs-string"><span class="hljs-string">"$editing=`yes"</span></span>) ,<span class="hljs-string"><span class="hljs-string">'INPUT.edit'</span></span> .d(<span class="hljs-string"><span class="hljs-string">"? $editing; !! .title@value"</span></span>) .ui(<span class="hljs-string"><span class="hljs-string">"$patch=(.title=#.value)"</span></span>) .e(<span class="hljs-string"><span class="hljs-string">"blur"</span></span>,<span class="hljs-string"><span class="hljs-string">"$editing="</span></span>) ,<span class="hljs-string"><span class="hljs-string">'BUTTON.destroy'</span></span>.d(<span class="hljs-string"><span class="hljs-string">""</span></span>) ) .a(<span class="hljs-string"><span class="hljs-string">"!? $completed $editing"</span></span>) .u(<span class="hljs-string"><span class="hljs-string">"? $patch; (@method`PATCH .url:dehttp headers $patch@):query $patch="</span></span>) ) ) ,<span class="hljs-string"><span class="hljs-string">'#footer'</span></span>.d(<span class="hljs-string"><span class="hljs-string">""</span></span> ,<span class="hljs-string"><span class="hljs-string">'#todo-count'</span></span>.d(<span class="hljs-string"><span class="hljs-string">""</span></span>) ,<span class="hljs-string"><span class="hljs-string">'UL#filters'</span></span>.d(<span class="hljs-string"><span class="hljs-string">""</span></span> ,<span class="hljs-string"><span class="hljs-string">'LI'</span></span>.d(<span class="hljs-string"><span class="hljs-string">""</span></span>) ) ,<span class="hljs-string"><span class="hljs-string">'#clear-completed'</span></span>.d(<span class="hljs-string"><span class="hljs-string">""</span></span>) ) ) .DICT({ <span class="hljs-attr"><span class="hljs-attr">todos</span></span> : <span class="hljs-string"><span class="hljs-string">"//todo-backend-express.herokuapp.com/"</span></span>, <span class="hljs-attr"><span class="hljs-attr">headers</span></span>: {<span class="hljs-string"><span class="hljs-string">"Content-type"</span></span>:<span class="hljs-string"><span class="hljs-string">"application/json"</span></span>} }) .FUNC({ <span class="hljs-attr"><span class="hljs-attr">convert</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">dehttp</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">=&gt;</span></span>url.replace(<span class="hljs-regexp"><span class="hljs-regexp">/^https?\:/</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>) } }) .RENDER()</code> </pre> <br><br>  Maintenant, il n'y a que cinquante lignes ici, mais à la fin de l'article, il y en aura deux fois - jusqu'à 100. Il y aura de nombreuses requêtes HTTP vers le serveur, alors veuillez ouvrir les outils de développement (dans Chrome, comme vous vous en souvenez, Ctrl + Shift + I) - il y aura Tout d'abord, l'onglet Réseau est intéressant, et deuxièmement, la console.  N'oubliez pas non plus d'afficher le code de chaque version de notre page - dans Chrome, c'est Ctrl + U. <br><br>  Ici, je dois faire une petite digression.  Si vous n'avez pas lu la <a href="https://habr.com/en/post/480912/">première partie du</a> didacticiel, je vous recommande tout de même de commencer par celui-ci.  Si vous le lisez mais ne comprenez rien, il vaut mieux le relire.  Comme le montrent les commentaires sur mes deux articles précédents, la syntaxe et le principe de dap ne sont pas toujours immédiatement compris par un lecteur non préparé.  Un autre article n'est pas recommandé pour la lecture aux personnes qui ne sont pas à l'aise avec l'apparence d'une syntaxe non similaire à la SI. <br><br><img src="https://habrastorage.org/webt/wj/-n/br/wj-nbrh5eflirkcich69glgnooo.jpeg"><br><br>  Cette deuxième partie du tutoriel sera un peu plus compliquée et intéressante que la première.  <i>[À FAIRE: demandez un <a href="https://habr.com/en/users/token/" class="user_link">jeton pour</a> trouver une photo d'écolier en train d'exploser un cerveau sur Internet]</i> . <br><br>  Avec votre permission, je continuerai à numéroter les chapitres avec la partie 1.  Là, nous avons compté jusqu'à 7. Donc, <br><br><h2>  8. Faire une liste de tâches de la variable d'état </h2><br>  Pour supprimer un cas de la liste, il existe un bouton <code>BUTTON.destroy</code> .  La suppression consiste à envoyer une requête DELETE au serveur et à supprimer de la vue l'élément <code>UL#todo-list &gt; LI</code> correspondant <code>UL#todo-list &gt; LI</code> avec tout le contenu.  Avec l'envoi d'une demande DELETE, tout est clair: <br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'BUTTON.destroy'</span></span>.ui(<span class="hljs-string"><span class="hljs-string">"(@method`DELETE .url:dehttp):query"</span></span>)</code> </pre><br><br>  Mais avec la suppression d'un élément de l'écran, des options sont possibles.  On pourrait simplement introduire une autre variable d'état, par exemple <code>$deleted</code> , et masquer l'élément avec CSS, y compris la classe CSS <code>deleted</code> <br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'LI'</span></span>.d(<span class="hljs-string"><span class="hljs-string">"$completed=.completed $editing= $patch= $deleted=; a!"</span></span> <span class="hljs-comment"><span class="hljs-comment">//  $deleted   "" ... ,'BUTTON.destroy'.d("(@method`DELETE .url:dehttp):query $deleted=`yes") //  $deleted -     ) .a("!? $completed $editing $deleted") //   CSS  .deleted{display:none}</span></span></code> </pre><br><br>  Et ça marcherait.  Mais ce serait tricher.  De plus, plus loin sur la ligne, nous aurons des filtres et des compteurs de cas actifs et terminés (ce qui se trouve dans <code>#footer</code> ).  Par conséquent, il est préférable de retirer immédiatement l'objet de la liste des tâches honnêtement, «physiquement».  Autrement dit, nous devons pouvoir modifier le tableau lui-même, que nous avons initialement reçu du serveur - ce qui signifie que ce tableau doit également devenir une variable d'état.  Appelons-la <code>$todos</code> . <br><br>  La portée de la variable <code>$todos</code> est de sélectionner l'ancêtre commun de tous les éléments qui accéderont à cette variable.  Et il sera accessible par <code>INPUT#new-todo</code> partir de <code>#header</code> , et les compteurs à partir de <code>#footer</code> , et en fait <code>UL#todo-list</code> .  L'ancêtre commun de tous est l'élément racine du modèle, <code>#todoapp</code> .  Par conséquent, dans sa règle d, nous définirons la variable <code>$todos</code> .  Au même endroit, nous y téléchargeons immédiatement les données du serveur.  Et pour construire la liste <code>UL#todo-list</code> , nous en serons désormais aussi: <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'#todoapp'</span></span>.d(<span class="hljs-string"><span class="hljs-string">"$todos=todos:query"</span></span> <span class="hljs-comment"><span class="hljs-comment">//   $todos      ... ,'UL#todo-list'.d("*@ $todos" //     $todos</span></span></code> </pre><br><br>  <b>C'est important.</b>  Si pendant les tests, la liste de tâches ne se charge pas soudainement - il est fort possible que quelqu'un les ait tous supprimés (il s'agit d'un serveur public et tout peut y arriver). <br>  Dans ce cas, veuillez consulter un <a href="https://dap.js.org/samples/tutorial/16.html" rel="nofollow">exemple complet</a> et créer quelques cas à expérimenter. <br><br>  <a href="https://dap.js.org/samples/tutorial/8-1.html" rel="nofollow">Nous regardons</a> .  Ici, <code>$todos</code> <i>déclaré</i> dans la règle d de l'élément <code>#todoapp</code> et est immédiatement <i>initialisé avec les</i> données nécessaires.  Tout semble fonctionner, mais une caractéristique désagréable est apparue.  Si le serveur répond à la demande depuis longtemps (Chrome vous permet de simuler cette situation: sur l'onglet Réseau des outils de développement, vous pouvez choisir différents modes de simulation de réseaux lents), alors notre nouvelle version de l'application jusqu'à ce que la demande soit terminée semble un peu triste - il n'y a que du CSS artefacts.  Une telle image n'ajoutera certainement pas d'enthousiasme à l'utilisateur.  Bien que la version précédente n'en souffre pas - jusqu'à ce que les données soient reçues sur la page, seule la liste elle-même manquait, mais d'autres éléments sont apparus immédiatement, sans attendre les données. <br><br>  Voici le truc.  Comme vous vous en souvenez, le <code>:query</code> converter est asynchrone.  Cette asynchronie s'exprime par le fait que jusqu'à la fin de la requête, seule l'exécution de la règle courante est bloquée, c'est-à-dire la génération de l'élément, qui, en fait, a besoin des données demandées (ce qui est logique).  La génération d'autres éléments n'est pas bloquée.  Par conséquent, lorsque <code>UL#todo-list</code> accédé au serveur, seul celui-ci a été bloqué, mais pas <code>#header</code> et pas <code>#footer</code> , qui ont été dessinés immédiatement.  Maintenant, <code>#todoapp</code> attend la fin de la demande. <br><br><h2>  9. Chargement différé des données </h2><br>  Pour corriger la situation et éviter de bloquer les éléments non impliqués, nous reporterons le chargement initial des données jusqu'à ce que tout soit déjà tracé.  Pour ce faire, nous ne chargerons pas immédiatement les données dans la variable <code>$todos</code> , mais nous les initialisons simplement avec «rien» <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'#todoapp'</span></span>.d(<span class="hljs-string"><span class="hljs-string">"$todos="</span></span> <span class="hljs-comment"><span class="hljs-comment">//   $todos    ""</span></span></code> </pre><br><br>  Elle ne bloquera donc rien et le modèle entier fonctionnera - bien que pour l'instant avec une «liste de tâches» vide.  Mais maintenant, avec un écran initial ennuyeux, vous pouvez <i>modifier en</i> toute sécurité <code>$todos</code> en y téléchargeant une liste de tâches.  Pour ce faire, ajoutez ce descendant à <code>#todoapp</code> <br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'loader'</span></span> .u(<span class="hljs-string"><span class="hljs-string">"$todos=todos:query"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  $todos,       .d("u") //   (u-)   </span></span></code> </pre><br><br>  Cet élément a une règle u qui ressemble exactement à la règle de blocage que nous avons rejetée, mais il y a une différence fondamentale. <br>  Permettez-moi de vous rappeler que la règle d (de <i>bas en haut</i> ) est la règle de génération d'élément qui est exécutée lorsque le modèle est construit de haut en <i>bas</i> , du parent aux descendants;  et les règles u (à partir du <i>haut</i> ) sont des règles de réaction qui sont exécutées en réponse à un événement qui apparaît de bas en <i>haut</i> , de l'enfant au parent. <br>  Donc, si quelque chose (y compris «rien») est assigné <b>à une</b> variable <b>dans la règle d</b> , cela signifie sa <i>déclaration et son initialisation</i> dans la portée de cet élément et ses descendants (les portées imbriquées sont implémentées dans dap, comme dans JS )  L'affectation <b>dans les règles ascendantes</b> signifie une <i>modification d'une</i> variable déclarée précédemment dans la portée.  La déclaration et l'initialisation des variables dans la règle d permettent au parent de transmettre aux descendants de la hiérarchie les informations nécessaires à la construction, et la modification permet au parent de transmettre les mises à jour de ces informations vers le haut et ainsi de lancer la restructuration correspondante de tous les éléments qui en dépendent. <br><br>  L'élément <code>loader</code> , étant un descendant de <code>#todoapp</code> , dans sa règle u <b>modifie la</b> variable <code>$todos</code> , chargeant des données depuis le serveur, ce qui provoque la régénération automatique de tous les éléments consommateurs de cette variable (et seulement eux, ce qui est important!).  Les consommateurs d'une variable sont des éléments dont les règles d contiennent cette variable en tant que valeur r, c'est-à-dire  Ceux qui <b>lisent</b> cette variable (en tenant compte de la portée) lors de la construction. <br><br>  Nous avons maintenant un consommateur de la variable <code>$todos</code> - la liste de <code>UL#todo-list</code> très <code>UL#todo-list</code> , qui, en conséquence, sera reconstruite après le chargement des données. <br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'UL#todo-list'</span></span>.d(<span class="hljs-string"><span class="hljs-string">"*@ $todos"</span></span> <span class="hljs-comment"><span class="hljs-comment">//  ,   $todos</span></span></code> </pre><br><br>  Donc, <a href="https://dap.js.org/samples/tutorial/9.html" rel="nofollow">maintenant</a> nous avons une liste de choses à faire est une variable d'état dans <code>#todoapp</code> , sans bloquer le rendu initial du modèle. <br><br><h2>  10. Suppression et ajout de tâches </h2><br>  Maintenant, nous pouvons modifier <code>$todos</code> tous les sens.  Commençons par supprimer les éléments.  Nous avons déjà un bouton croisé <code>BUTTON.destroy</code> , qui jusqu'à présent envoie simplement les demandes de suppression du serveur <br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'BUTTON.destroy'</span></span>.ui(<span class="hljs-string"><span class="hljs-string">"(@method`DELETE .url:dehttp):query"</span></span>)</code> </pre><br><br>  Il est nécessaire de s'assurer que l'objet correspondant est également supprimé de la variable <code>$todos</code> - et puisqu'il s'agit d'une modification, <code>UL#todo-list</code> , en tant que consommateur de cette variable, sera automatiquement reconstruit, mais sans l'élément supprimé. <br><br>  En soi, dap ne fournit aucun moyen spécial pour manipuler les données.  Les manipulations peuvent être parfaitement écrites dans des fonctions dans JS, et les règles dap leur fournissent simplement des données et récupèrent le résultat.  Nous écrivons une fonction JS pour supprimer un objet d'un tableau sans connaître son numéro.  Par exemple, ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> remove = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr,tgt</span></span></span><span class="hljs-function">)=&gt;</span></span> arr.filter( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function"> =&gt;</span></span> obj!=tgt );</code> </pre><br><br>  Vous pouvez probablement écrire quelque chose de plus efficace, mais ce n'est pas le cas maintenant.  Il est peu probable que notre application doive fonctionner avec des listes de tâches de millions d'éléments.  L'important est que la fonction retourne un nouvel objet tableau, et pas seulement supprime l'élément de ce qu'il est. <br><br>  Pour rendre cette fonction accessible à partir des règles dap, vous devez l'ajouter à la section <code>.FUNC</code> , mais avant cela, décidez comment nous voulons l'appeler.  L'option la plus simple dans ce cas est, peut-être, de l'appeler à partir du convertisseur, qui accepte l'objet <code>{ todos, tgt }</code> et renvoie un tableau filtré <br><br><pre> <code class="javascript hljs">.FUNC({ <span class="hljs-attr"><span class="hljs-attr">convert</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">dehttp</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function"> =&gt;</span></span> url.replace(<span class="hljs-regexp"><span class="hljs-regexp">/^https?\:/</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>), <span class="hljs-comment"><span class="hljs-comment">//        remove: x =&gt; remove(x.todos,x.tgt) //     } })</span></span></code> </pre><br><br>  mais rien ne vous empêche de définir cette fonction directement à l'intérieur de <code>.FUNC</code> (j'ai déjà dit que <code>.FUNC</code> est en fait une méthode JS régulière, et son argument est un objet JS normal?) <br><br><pre> <code class="javascript hljs">.FUNC({ <span class="hljs-attr"><span class="hljs-attr">convert</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">dehttp</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function"> =&gt;</span></span> url.replace(<span class="hljs-regexp"><span class="hljs-regexp">/^https?\:/</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>), <span class="hljs-attr"><span class="hljs-attr">remove</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x.todos.filter( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todo</span></span></span><span class="hljs-function"> =&gt;</span></span> todo!=x.tgt ) } })</code> </pre><br><br>  Maintenant, nous pouvons accéder à ce convertisseur à partir des règles DAP <br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'BUTTON.destroy'</span></span> .ui(<span class="hljs-string"><span class="hljs-string">"$todos=($todos $@tgt):remove (@method`DELETE .url:dehttp):query"</span></span>)</code> </pre><br><br>  Ici, nous formons d'abord un objet qui, dans la notation JS, correspond à <code>{ todos, tgt:$ }</code> , le transmettons au convertisseur <code>:remove</code> décrit dans <code>.FUNC</code> et <code>.FUNC</code> le résultat filtré à <code>$todos</code> , le modifiant ainsi.  Ici <code>$</code> est le <i>contexte de données de l'</i> élément, cet objet métier du tableau <code>$todos</code> sur lequel le modèle est construit.  Après le symbole <code>@</code> , l'alias de l'argument est indiqué.  Si <code>@</code> absent, alors le propre nom de l'argument est utilisé.  Ceci est similaire à la récente innovation ES6 - <a href="http://es6-features.org/" rel="nofollow">raccourci immobilier</a> . <br><br>  De même, nous ajoutons un nouveau cas à la liste en utilisant l'élément <code>INPUT#new-todo</code> et la requête POST <br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'INPUT#new-todo placeholder="What needs to be done?" autofocus'</span></span> .ui(<span class="hljs-string"><span class="hljs-string">"$=(#.value@title) (@method`POST todos@url headers $):query $todos=($todos $@tgt):insert #.value="</span></span>) ... .FUNC({ <span class="hljs-attr"><span class="hljs-attr">convert</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">dehttp</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function"> =&gt;</span></span> url.replace(<span class="hljs-regexp"><span class="hljs-regexp">/^https?\:/</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>), <span class="hljs-attr"><span class="hljs-attr">remove</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x.todos.filter( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todo</span></span></span><span class="hljs-function"> =&gt;</span></span> todo!=x.tgt ), <span class="hljs-comment"><span class="hljs-comment">//     insert: x =&gt; x.todos.concat( [x.tgt] ) //     } })</span></span></code> </pre><br><br>  La règle de réaction de l'élément <code>INPUT#new-todo</code> à un événement d'interface utilisateur standard (pour les éléments <code>INPUT</code> , l'événement <code>change</code> est considéré comme le dap standard) comprend: la lecture des entrées utilisateur à partir de la propriété <code>value</code> de cet élément, la formation d'un contexte local <code>$</code> avec cette valeur comme champ <code>.title</code> , l'envoi de <code>$</code> context au serveur à l'aide de la méthode POST, en modifiant le tableau <code>$todos</code> en ajoutant le contexte <code>$</code> tant que nouvel élément et enfin en effaçant la propriété <code>value</code> de l'élément <code>INPUT</code> . <br><br>  Ici, un jeune lecteur peut se demander: pourquoi utiliser <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/concat" rel="nofollow"><code>concat()</code></a> lors de l'ajout d'un élément à un tableau, si cela peut être fait en utilisant <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/push" rel="nofollow"><code>push()</code></a> normal?  Un lecteur expérimenté comprendra immédiatement le problème et notera sa réponse dans les commentaires. <br><br>  Nous regardons ce qui <a href="https://dap.js.org/samples/tutorial/10-1.html" rel="nofollow">s'est passé: les</a> cas sont ajoutés et supprimés normalement, les demandes correspondantes sont envoyées correctement au serveur (vous gardez l'onglet Réseau ouvert tout ce temps, non?).  Mais que faire si nous voulons changer le nom ou le statut d'un cas fraîchement ajouté?  Le problème est que pour notifier le serveur de ces modifications, nous avons besoin de <code>.url</code> , qui affecte le serveur à cette entreprise.  Lorsque nous avons créé l'entreprise, <code>.url</code> ne connaissions pas son <code>.url</code> , respectivement, nous ne pouvons pas former la demande de modification PATCH correcte. <br><br>  En fait, toutes les informations nécessaires sur le cas sont contenues dans la réponse du serveur à la demande POST, et il serait plus correct de créer un nouvel objet métier non seulement à partir de l'entrée utilisateur, mais à partir de la réponse du serveur, et d'ajouter cet objet à <code>$todos</code> - avec toutes les informations fournies informations sur le serveur, y compris le champ <code>.url</code> <br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'INPUT#new-todo placeholder="What needs to be done?" autofocus'</span></span> .ui(<span class="hljs-string"><span class="hljs-string">"$todos=($todos (@method`POST todos@url headers (#.value@title)):query@tgt ):insert #.value="</span></span>)</code> </pre><br><br>  Nous regardons - d'accord, maintenant tout se déroule correctement.  Les notifications au serveur concernant la modification des cas fraîchement créés vont bien. <br><br>  On pourrait s'arrêter là, mais ... Mais si vous regardez de plus près, vous pouvez toujours remarquer un léger délai entre la saisie du nom du nouveau boîtier et le moment où il apparaît dans la liste.  Ce délai est clairement visible si vous activez un réseau lent simulé.  Comme vous l'avez peut-être deviné, il s'agit d'une demande au serveur: d'abord, nous demandons des données pour un nouveau cas au serveur, et seulement après les avoir reçus, nous modifions <code>$todos</code> .  L'étape suivante, nous essaierons de corriger cette situation, mais je vais d'abord attirer votre attention sur un autre point intéressant.  Si l'on revient un peu à la <a href="https://dap.js.org/samples/tutorial/10-1.html" rel="nofollow">version précédente</a> , on note: bien que la requête soit également là, le nouveau cas est ajouté à la liste instantanément, sans attendre la fin de la requête <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//    , :query   .ui("$=(#.value@title) (@method`POST todos@url headers $):query $todos=($todos $@tgt):insert #.value=")</span></span></code> </pre><br><br>  C'est une autre caractéristique de l'élaboration de convertisseurs asynchrones en dap: si le résultat du convertisseur asynchrone n'est pas utilisé (à savoir, il n'est affecté à rien), vous ne pouvez pas attendre sa fin - et l'exécution de la règle n'est pas bloquée.  Ceci est souvent utile: vous avez peut-être remarqué que lors de la suppression de cas de la liste, ils disparaissent instantanément de l'écran, sans attendre le résultat de la demande DELETE.  Cela est particulièrement visible si vous supprimez rapidement plusieurs cas consécutifs et suivez les demandes dans le panneau Réseau. <br><br>  Mais, puisque nous utilisons le résultat de la requête POST - l'affectons au contexte <code>$</code> - nous devons attendre qu'il se termine.  Par conséquent, vous devez trouver un autre moyen de modifier <code>$todos</code> avant d'exécuter la demande POST.  Solution: toujours, créez d'abord un nouvel objet métier et ajoutez-le immédiatement à <code>$todos</code> , laissez la liste dessiner, puis seulement, après le rendu, si l'entreprise <code>.url</code> pas <code>.url</code> (c'est-à-dire que l'entreprise vient d'être créée), exécutez une demande POST, et imposer son résultat au contexte de données de cette affaire. <br><br>  Donc, tout d'abord, nous ajoutons simplement un blanc contenant uniquement <code>.title</code> à la <code>.title</code> <br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'INPUT#new-todo placeholder="What needs to be done?" autofocus'</span></span> .ui(<span class="hljs-string"><span class="hljs-string">"$todos=($todos (#.value@title)@tgt):insert #.value="</span></span>)</code> </pre><br><br>  <code>UL#todo-list &gt; LI</code> La règle de génération d'élément <code>UL#todo-list &gt; LI</code> contient déjà <code>a!</code>  démarrer une règle a après le premier dessin de l'élément.  Nous pouvons y ajouter le lancement d'une requête POST en l'absence de <code>.url</code> .  Pour injecter des champs supplémentaires dans le contexte, dap a l'opérateur <code>&amp;</code> <br><br><pre> <code class="javascript hljs"> .a(<span class="hljs-string"><span class="hljs-string">"!? $completed $editing; ? .url:!; &amp; (@method`POST todos@url headers $):query"</span></span>)</code> </pre><br><br>  <a href="https://dap.js.org/samples/tutorial/10-3.html" rel="nofollow">Nous regardons</a> .  Une autre chose!  Même avec un réseau lent, la liste des tâches est mise à jour instantanément, et la notification du serveur et le chargement des données manquantes se produisent en arrière-plan, après avoir tracé la liste mise à jour. <br><br><h2>  11. Daw tout le monde! </h2><br>  Dans l'élément <code>#header</code> , il y a un bouton pour une installation en masse / réinitialisation du signe d'achèvement pour tous les cas de la liste.  Pour l'affectation en masse de valeurs aux champs des éléments du tableau, nous écrivons simplement un autre convertisseur <code>:assign</code> , et l'appliquons à <code>$todos</code> en cliquant sur <code>INPUT#toggle-all</code> <br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'INPUT#toggle-all type=checkbox'</span></span> .ui(<span class="hljs-string"><span class="hljs-string">"$todos=($todos (#.checked@completed)@src):assign"</span></span>) ... assign: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x.todos &amp;&amp; x.todos.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todo</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(todo,x.src))</code> </pre><br><br>  Dans ce cas, nous ne sommes intéressés que par le champ <code>.completed</code> , mais il est facile de voir qu'avec un tel convertisseur, vous pouvez modifier massivement les valeurs de tous les champs des éléments du tableau. <br>  Ok, dans le tableau <code>$todos</code> , les <code>$todos</code> commutées, nous devons maintenant informer le serveur des modifications apportées.  Dans l'exemple d'origine, cela se fait en envoyant des requêtes PATCH pour chaque cas - pas une stratégie très efficace, mais cela ne dépend plus de nous.  Ok, pour chaque cas, nous envoyons une demande de PATCH <br><br><pre> <code class="javascript hljs"> .ui(<span class="hljs-string"><span class="hljs-string">"*@ $todos=($todos (#.checked@completed)@src):assign; (@method`PATCH .url:dehttp headers (.completed)):query"</span></span>)</code> </pre><br><br>  <a href="https://dap.js.org/samples/tutorial/11.html" rel="nofollow">Nous regardons</a> : Un clic sur un daw commun aligne tous les daw individuels, et le serveur est averti par des requêtes PATCH appropriées.  Norm <br><br><h2>  12. Filtrage des cas en fonction de l'achèvement </h2><br>  En plus de la liste de tâches réelle, l'application doit également être en mesure de filtrer les cas par le signe d'achèvement et d'afficher les compteurs des tâches terminées et inachevées.  Bien sûr, pour le filtrage, il sera trivial d'utiliser la même méthode <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="nofollow"><code>filter()</code></a> fournie par JS lui-même. <br><br>  Mais vous devez d'abord vous assurer que le champ <code>.completed</code> de chaque cas est toujours vrai, et lorsque vous cliquez sur l'index individuel du cas est mis à jour avec la variable <code>$completed</code> .  Auparavant, cela n'était pas important pour nous, mais ce le sera désormais. <br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'INPUT.toggle type=checkbox'</span></span> .d(<span class="hljs-string"><span class="hljs-string">"#.checked=.completed"</span></span>) .ui(<span class="hljs-string"><span class="hljs-string">"$patch=(.completed=$completed=#.checked) $recount=()"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  .completed       </span></span></code> </pre><br><br>  Le point important ici est que le contexte de données de chaque cas est l'objet de cas lui-même, qui se trouve dans le tableau <code>$todos</code> .  Pas une seule copie, ou construction connexe, mais l'objet lui-même.  Et tous les appels aux champs <code>.title</code> , <code>.completed</code>  <code>url</code> - à la fois en lecture et en écriture - s'applique directement à cet objet.  Par conséquent, pour que le filtrage du tableau <code>$todos</code> fonctionne correctement, nous devons que l'achèvement du cas soit reflété non seulement dans le daw à l'écran, mais également dans le champ <code>.completed</code> de l'objet <code>.completed</code> . <br><br>  Afin de n'afficher que les cas avec le signe nécessaire de complétude <code>.completed</code> dans la liste, nous <code>.completed</code> simplement <code>$todos</code> selon le filtre sélectionné.  Le filtre sélectionné est, vous l'aurez deviné, une autre variable d'état de notre application, et nous l'appellerons: <code>$filter</code> .  Pour filtrer <code>$todos</code> fonction du <code>$filter</code> sélectionné <code>$filter</code> allons le long de la vignette et ajoutons simplement un autre convertisseur, de la forme <i>{list, filter} =&gt; la liste filtrée</i> , et nous prendrons les noms et les fonctions de filtrage du "tableau associatif" (c'est-à-dire JS ordinaire objet) <code>todoFilters</code> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> todoFilters={ <span class="hljs-string"><span class="hljs-string">"All"</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Active"</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todo</span></span></span><span class="hljs-function"> =&gt;</span></span> !todo.completed, <span class="hljs-string"><span class="hljs-string">"Completed"</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todo</span></span></span><span class="hljs-function"> =&gt;</span></span> !!todo.completed }; <span class="hljs-string"><span class="hljs-string">'#todoapp'</span></span>.d(<span class="hljs-string"><span class="hljs-string">"$todos= $filter="</span></span> <span class="hljs-comment"><span class="hljs-comment">//   $filter ... ,'UL#todo-list'.d("* ($todos $filter):filter" ... ,'UL#filters'.d("* filter" //  filter      .DICT ,'LI' .d("! .filter") .ui("$filter=.") //    "$filter=.filter" ) ... .DICT({ ... filter: Object.keys(todoFilters) //["All","Active","Completed"] }) .FUNC({ convert:{ ... filter: x =&gt;{ const a = x.todos, f = x.filter &amp;&amp; todoFilters[x.filter]; return a&amp;&amp;f ? a.filter(f) : a; } } })</span></span></code> </pre><br><br>  <a href="https://dap.js.org/samples/tutorial/12-1.html" rel="nofollow">Nous vérifions</a> .  Les filtres fonctionnent correctement.  Il y a une nuance dans le fait que les noms des filtres sont affichés ensemble, car  ici, nous sommes un peu sortis de la structure DOM de l'original et sommes sortis de CSS.  Mais nous y reviendrons un peu plus tard. <br><br><h2>  13. Compteurs de cas terminés et actifs. </h2><br>  Pour afficher les compteurs des cas terminés et actifs, il suffit de filtrer <code>$todos</code> avec les filtres appropriés et d'afficher les longueurs des tableaux résultants <br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'#footer'</span></span>.d(<span class="hljs-string"><span class="hljs-string">"$active=($todos @filter`Active):filter $completed=($todos @filter`Completed):filter"</span></span> ,<span class="hljs-string"><span class="hljs-string">'#todo-count'</span></span>.d(<span class="hljs-string"><span class="hljs-string">"! (active $active.length)format"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  length    active ... ,'#clear-completed'.d("! (completed $completed.length)format") ) ... .DICT({ ... active: "{length} items left", completed: "Clear completed items ({length})" })</span></span></code> </pre><br><br>  Dans <a href="https://dap.js.org/samples/tutorial/13-1.html" rel="nofollow">ce formulaire, les</a> compteurs affichent les valeurs correctes au démarrage, mais ne répondent pas aux changements ultérieurs dans la fin des affaires (en cliquant sur les daws).  Le fait est que les clics sur les choucas, changeant l'état de chaque cas individuel, ne changent pas l'état de <code>$todos</code> - une modification d'un élément de tableau n'est pas une modification du tableau lui-même.  Par conséquent, nous avons besoin d'un signal supplémentaire sur la nécessité de réenregistrer les cas.  Un tel signal peut être une variable d'état supplémentaire, qui est modifiée à chaque fois qu'un nouveau comptage est nécessaire.  Appelez ça <code>$recount</code> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous déclarerons un ancêtre commun dans la règle d, nous le mettrons à jour lorsque nous cliquons sur les mâles, et nous </font></font><code>#footer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ferons de l' </font><font style="vertical-align: inherit;">élément un </font><font style="vertical-align: inherit;">consommateur - pour cela, mentionnez simplement cette variable dans sa règle d</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'#todoapp'</span></span>.d(<span class="hljs-string"><span class="hljs-string">"$todos= $filter= $recount="</span></span> <span class="hljs-comment"><span class="hljs-comment">//  $recount     ... ,'INPUT.toggle type=checkbox' .d("#.checked=.completed") .ui("$patch=(.completed=$completed=#.checked) $recount=()") //  $recount    ... ,'#footer'.d("$active=($todos @filter`Active):filter $completed=($todos @filter`Completed):filter $recount" //  $recount</span></span></code> </pre><br><br> <a href="https://dap.js.org/samples/tutorial/13-2.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tout fonctionne comme il se doit, les compteurs sont mis à jour correctement.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14. Suppression de tous les cas terminés. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La suppression par lot des cas dans TodoMVC est implémentée comme non casher en tant que modification par lot - par plusieurs demandes. </font><font style="vertical-align: inherit;">Eh bien, soupirons, haussons les mains et exécutons par DELETE-request pour chaque cas terminé - et nous les avons déjà tous </font></font><code>$completed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En conséquence, </font></font><code>$todos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">après la suppression des dossiers terminés, ce qui devrait déjà être</font></font><code>$active</code> <br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'#clear-completed'</span></span> .d(<span class="hljs-string"><span class="hljs-string">"! (completed $completed.length)format"</span></span>) .ui(<span class="hljs-string"><span class="hljs-string">"$todos=$active; *@ $completed; (@method`DELETE .url:dehttp):query"</span></span>)</code> </pre><br><br> <a href="https://dap.js.org/samples/tutorial/14.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous regardons</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : nous créons des affaires inutiles, les marquons avec des griffes et les supprimons. </font><font style="vertical-align: inherit;">L'onglet Réseau montrera l'horreur de cette approche des opérations par lots.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15. Statut dans la barre d'adresse </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Retour à la sélection des filtres. </font><font style="vertical-align: inherit;">Dans l'exemple d'origine, le filtre sélectionné se reflète dans la barre d'adresse après #. </font><font style="vertical-align: inherit;">Lorsque vous modifiez le # -fragment dans la barre d'adresse manuellement ou pendant la navigation, le filtre sélectionné change également. </font><font style="vertical-align: inherit;">Cela vous permet d'accéder à la page de l'application par URL avec le filtre de tâches déjà sélectionné. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez écrire avec un </font></font><code>location.hash</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opérateur </font></font><code>urlhash</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, par exemple, dans la règle a d'un élément </font></font><code>#todoapp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(ou l'un de ses descendants), qui sera exécutée à chaque fois</font></font><code>$filter</code> <br><br><pre> <code class="javascript hljs">.a(<span class="hljs-string"><span class="hljs-string">"urlhash $filter"</span></span>)</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et vous pouvez initialiser la variable avec une </font></font><code>$filter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur de la barre d'adresse, puis la mettre à jour par l'événement </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hashchange à l'</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aide d'un pseudo-convertisseur </font></font><code>:urlhash</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui retourne l'état actuel </font></font><code>location.hash</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(sans #)</font></font><br><br><pre> <code class="javascript hljs">.d(<span class="hljs-string"><span class="hljs-string">"$todos= $filter=:urlhash $recount="</span></span> .e(<span class="hljs-string"><span class="hljs-string">"hashchange"</span></span>,<span class="hljs-string"><span class="hljs-string">"$filter=:urlhash"</span></span>)</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'événement </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hashchange</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est </font><i><font style="vertical-align: inherit;">déclenché</font></i><font style="vertical-align: inherit;"> par le navigateur lorsqu'un # -fragment dans la barre d'adresse change. </font><font style="vertical-align: inherit;">Cependant, pour une raison que </font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et </font></font><code>document.body</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut écouter cet événement. </font><font style="vertical-align: inherit;">Pour suivre cet événement à partir d'un élément </font></font><code>#todoapp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, vous devrez ajouter un opérateur à sa règle d </font></font><code>listen</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui signe l'élément pour relayer les événements de l'objet</font></font><code>window</code> <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'#todoapp'</span></span> .a(<span class="hljs-string"><span class="hljs-string">"urlhash $filter"</span></span>) .e(<span class="hljs-string"><span class="hljs-string">"hashchange"</span></span>,<span class="hljs-string"><span class="hljs-string">"$filter=:urlhash"</span></span>) .d(<span class="hljs-string"><span class="hljs-string">"$todos= $filter=:urlhash $recount=; listen @hashchange"</span></span></code> </pre><br><br> <a href="https://dap.js.org/samples/tutorial/15-1.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous regardons</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : changer de filtre, suivre les changements dans la barre d'adresse, suivre les liens avec </font></font><a href="https://dap.js.org/samples/tutorial/15-1.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">#Active</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://dap.js.org/samples/tutorial/15-1.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">#All</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://dap.js.org/samples/tutorial/15-1.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">#Completed</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tout fonctionne. </font><font style="vertical-align: inherit;">Mais revenons à l'original. </font><font style="vertical-align: inherit;">Là, il semble, le choix du filtre est mis en œuvre - en cliquant sur les liens. </font><font style="vertical-align: inherit;">Bien que ce ne soit pas très pratique, nous ferons de même pour être complet.</font></font><br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'UL#filters'</span></span>.d(<span class="hljs-string"><span class="hljs-string">"* filter"</span></span> ,<span class="hljs-string"><span class="hljs-string">'LI'</span></span>.d(<span class="hljs-string"><span class="hljs-string">""</span></span> ,<span class="hljs-string"><span class="hljs-string">'A'</span></span>.d(<span class="hljs-string"><span class="hljs-string">"!! (`# .filter)concat@href .filter@"</span></span>) ) )</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et pour faire ressortir le filtre sélectionné, ajoutez un opérateur de stylisation conditionnelle </font></font><code>!?</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui ajoutera une classe CSS à l'élément </font></font><code>selected</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si la valeur dans le champ de </font></font><code>.filter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contexte est égale à la valeur de la variable</font></font><code>$filter</code> <br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'A'</span></span>.d(<span class="hljs-string"><span class="hljs-string">"!! (`# .filter)concat@href .filter@; !? (.filter $filter)eq@selected"</span></span>)</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sous </font></font><a href="https://dap.js.org/samples/tutorial/15-2.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cette forme, la</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fonctionnalité de notre application dap est déjà pleinement (pour autant que je sache) cohérente avec ce que fait l' </font></font><a href="https://todo-backend-express.herokuapp.com/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">original</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 16. Quelques touches finales </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je n'aime pas vraiment que dans l'original la forme du curseur ne change pas sur les éléments actifs, nous allons donc ajouter </font></font><code>head</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ce style </font><font style="vertical-align: inherit;">à </font><font style="vertical-align: inherit;">notre document HTML</font></font><br><br><pre> <code class="javascript hljs"> [ui=click]{<span class="hljs-attr"><span class="hljs-attr">cursor</span></span>:pointer}</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Donc, au moins, nous verrons où vous pouvez cliquer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oh oui! </font><font style="vertical-align: inherit;">Il reste à écrire le mot "todos" en majuscules. </font><font style="vertical-align: inherit;">Mais ici, je me permettrai peut-être enfin de montrer un peu d'imagination et de créativité, et au lieu de simplement "todos" j'écrirai "dap todos"</font></font><br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'H1'</span></span>.d(<span class="hljs-string"><span class="hljs-string">""</span></span>,<span class="hljs-string"><span class="hljs-string">"dap todos"</span></span>)</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ouah. </font><font style="vertical-align: inherit;">Maintenant, </font></font><a href="https://dap.js.org/samples/tutorial/16.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">notre application</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> peut être considérée comme complète et le tutoriel peut être tenu (si vous lisez honnêtement ces lignes).</font></font><br><br><h2>  En conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Peut-être qu'en lisant, vous avez eu l'impression que le programme dap est écrit par essais et erreurs - ce sont tous «voyons ce qui s'est passé», «il semble fonctionner, mais il y a une nuance», etc. </font></font> Ce n'est en fait pas le cas.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toutes ces nuances sont assez évidentes et prévisibles lors de l'écriture de code. </font><font style="vertical-align: inherit;">Mais j'ai pensé qu'il serait utile de montrer par l'exemple de ces nuances pourquoi telle ou telle décision est présente dans les règles et pourquoi elle se fait de cette façon et pas autrement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Posez, comme on dit, des questions.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr481680/">https://habr.com/ru/post/fr481680/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr481670/index.html">Créer un plan d'action à l'aide de AWS Cloud Adoption Framework</a></li>
<li><a href="../fr481672/index.html">Automates cellulaires dans le navigateur</a></li>
<li><a href="../fr481674/index.html">Entonnoir de vente de voitures ou comment ne pas fusionner les clients et même travailler avec ceux qui ont refusé vos services?</a></li>
<li><a href="../fr481676/index.html">Semaine de sécurité 52: Sécurité des haut-parleurs intelligents et des caméras IP</a></li>
<li><a href="../fr481678/index.html">Examen avant les vacances: lecteur N6IIT01 et casque YB04 Armature - Hi-Fi du sud de la Chine</a></li>
<li><a href="../fr481684/index.html">Un ordinateur portable de Powerbank?</a></li>
<li><a href="../fr481688/index.html">Pourquoi apprendre Java et comment le faire efficacement. Rapport Yandex</a></li>
<li><a href="../fr481692/index.html">Utilisation de Intel Processor Trace pour tracer le code du mode de gestion du système</a></li>
<li><a href="../fr481694/index.html">Ma façon de partitionner dans PostgreSQL</a></li>
<li><a href="../fr481696/index.html">règle: contrôle dynamique de Go</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>