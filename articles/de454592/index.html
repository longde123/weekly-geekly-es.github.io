<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçüîß üëΩ üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø WAF durch die Augen von Hackern üí™ üë® üíÜüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute werden wir √ºber einen der modernen Sicherheitsmechanismen f√ºr Webanwendungen sprechen, n√§mlich die Web Application Firewall (WAF). Wir werden mo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WAF durch die Augen von Hackern</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/454592/"><img align="left" src="https://habrastorage.org/webt/nx/mm/yz/nxmmyzb6nr39jk_zmiu5wcnylbm.png">  Heute werden wir √ºber einen der modernen Sicherheitsmechanismen f√ºr Webanwendungen sprechen, n√§mlich die Web Application Firewall (WAF).  Wir werden moderne WAFs und ihre Basis sowie Bypass-Techniken, ihre Verwendung und warum Sie sich niemals vollst√§ndig auf WAF verlassen sollten, besprechen.  Wir sprechen aus der Perspektive der Pentester;  Wir haben nie WAFs entwickelt und nur Daten aus offenen Quellen gesammelt.  Daher k√∂nnen wir uns nur auf unsere eigenen Erfahrungen beziehen und sind uns m√∂glicherweise einiger Besonderheiten von WAFs nicht bewusst. <br clear="left"><a name="habracut"></a><br><hr><br><br>  <i>Haftungsausschluss: Dies ist eine √úbersetzung des Artikels aus dem Russischen ins Englische. Der Artikel wurde Ende 2017 ver√∂ffentlicht. Einige Informationen k√∂nnten veraltet sein.</i> <br><br><h4>  Inhalt </h4><br><ol><li>  Einf√ºhrung </li><li>  Die moderne WAF </li><li>  WAF identifizieren </li><li>  WAF Bypass Cheatsheet </li><li>  WAF-Bypass in der Praxis </li><li>  Fazit </li></ol><br>  <i>Wenn Sie wissen, warum WAFs verwendet werden und wie sie funktionieren, k√∂nnen Sie direkt zum Bypass-Abschnitt springen.</i> <br><br><h2>  Einf√ºhrung </h2><br>  WAFs sind in letzter Zeit sehr beliebt geworden.  Anbieter bieten verschiedene L√∂sungen in verschiedenen Preisklassen, Distributionskits und Optionen f√ºr unterschiedliche Kunden an, von kleinen bis zu gro√üen Unternehmen.  WAFs sind beliebt, weil sie eine komplexe L√∂sung zum Schutz von Webanwendungen darstellen, die ein ganzes Spektrum von Aufgaben abdeckt.  Aus diesem Grund k√∂nnen sich Web-App-Entwickler in einigen Sicherheitsaspekten auf WAF verlassen.  WAFs k√∂nnen jedoch keine vollst√§ndige Sicherheit gew√§hren. <br><br><img src="https://habrastorage.org/webt/59/e3/95/59e395af93092095133873.png"><br><br>  Was sollte ein WAF also in der Lage sein, seine Umsetzung in einem Projekt zu rechtfertigen?  Seine Hauptfunktion besteht darin, jede Anforderung zu erkennen und zu blockieren, die nach der Analyse der WAF Anomalien oder einen Angriffsvektor aufweist.  Die Analyse darf die Interaktion zwischen legitimen Benutzern und der Web-App nicht behindern und gleichzeitig Angriffsversuche genau und rechtzeitig erkennen.  Um solche Funktionen zu implementieren, verwenden WAF-Entwickler regul√§re Ausdr√ºcke, Tokenizer, Verhaltensanalysen, Reputationsanalysen und nat√ºrlich maschinelles Lernen.  Oft werden alle diese Technologien zusammen verwendet.  WAF kann auch andere Funktionen implementieren: DDoS-Schutz, Verbot der IPs des Angreifers, √úberwachung verd√§chtiger IPs, Hinzuf√ºgen von Sicherheitsheadern (X-XSS-Schutz, X-Frame-Optionen usw.), Hinzuf√ºgen von Nur-http-Flags zum Cookie, Implementierung von der HSTS-Mechanismus und CSRF-Token.  Einige WAFs verf√ºgen au√üerdem √ºber clientseitige JavaScript-Module f√ºr Websites. <br><br>  Nat√ºrlich schaffen WAFs einige Hindernisse f√ºr Hacker und Pentester.  WAF macht das Auffinden und Ausnutzen von Sicherheitsl√ºcken ressourcenintensiver (au√üer wenn der Angreifer effektive 0-Tage-Bypass-Methoden f√ºr eine bestimmte WAF kennt).  Automatische Scanner sind bei der Analyse von WAF-gesch√ºtzten Web-Apps praktisch unbrauchbar.  WAF ist ein zuverl√§ssiger Schutz gegen ‚ÄûScriptkiddies‚Äú.  Ein erfahrener Hacker oder Forscher ohne ausreichende Motivation w√ºrde wahrscheinlich keine Zeit damit verschwenden wollen, Wege zu finden, um dies zu umgehen.  Es ist zu beachten, dass je komplexer die Web-App ist, desto gr√∂√üer die Angriffsfl√§che und desto einfacher ist es, eine Bypass-Methode zu finden. <br><br>  Bei unseren j√ºngsten Audits haben wir h√§ufig verschiedene WAFs gefunden.  Wir werden sp√§ter √ºber einige von ihnen sprechen.  Wir haben bereits zwei propriet√§re WAFs in zwei Hauptszenarien getestet: <br><br><ul><li>  Wir wissen, dass eine Web-App eine bestimmte Sicherheitsl√ºcke aufweist, und versuchen, die WAF zu umgehen, um sie auszunutzen. </li><li>  Wir kennen keine Schwachstellen, daher m√ºssen wir trotz der WAF eine finden und diese dann unter Umgehung der WAF ausnutzen. </li></ul><br>  Aber zuerst schauen wir uns die grundlegenden Mechanismen hinter WAF genauer an und sehen, welche Probleme sie haben. <br><br><h2>  Die moderne WAF </h2><br>  Um verschiedene Wege zur Umgehung der WAF effektiv finden zu k√∂nnen, m√ºssen wir zun√§chst moderne Mechanismen der Anforderungsklassifizierung herausfinden.  Jede WAF ist spezifisch und einzigartig aufgebaut, es gibt jedoch einige allgemeine Analysemethoden.  Schauen wir uns diese an. <br><br><img src="https://habrastorage.org/webt/59/e3/95/59e395af93c4f468367566.png"><br><br><h4>  Regeln, die auf regul√§ren Ausdr√ºcken basieren </h4><br>  Die Mehrheit der vorhandenen WAFs verwendet Regeln, die auf regul√§ren Ausdr√ºcken basieren.  Der Entwickler untersucht eine Reihe bekannter Angriffe, um wichtige syntaktische Strukturen zu identifizieren, die auf einen Angriff hinweisen k√∂nnten.  Basierend auf diesen Daten erstellt der Entwickler regul√§re Ausdr√ºcke, die solche syntaktischen Strukturen finden.  Es klingt einfach, aber diese Methode hat bestimmte Nachteile.  Erstens kann ein regul√§rer Ausdruck nur auf eine einzelne Anforderung oder sogar auf einen einzelnen Anforderungsparameter angewendet werden, was offensichtlich die Effizienz solcher Regeln verringert und einige blinde Flecken hinterl√§sst.  Zweitens f√ºhren die Syntax regul√§rer Ausdr√ºcke und die komplexe Logik von Textprotokollen, die das Ersetzen √§quivalenter Strukturen und die Verwendung unterschiedlicher Symboldarstellungen erm√∂glicht, zu Fehlern beim Erstellen dieser Regeln. <br><br><h4>  Scorebuilding </h4><br>  Diejenigen, die wissen, wie Netzwerk-Firewalls und Antivirenprogramme funktionieren, sollten mit diesem Mechanismus vertraut sein.  Es erkennt keine Angriffe, erg√§nzt jedoch andere Mechanismen und macht sie pr√§ziser und flexibler.  Die Sache ist, dass eine ‚Äûverd√§chtige‚Äú Struktur in einer Anfrage keine ausreichende Bedingung f√ºr die Erkennung eines Angriffs ist und zu vielen Fehlalarmen f√ºhren kann.  Dieses Problem wird durch die Implementierung eines Bewertungssystems gel√∂st.  Jede Regel, die auf regul√§ren Ausdr√ºcken basiert, wird durch Informationen zu ihrer Kritikalit√§t erg√§nzt.  Nachdem alle ausgel√∂sten Regeln identifiziert wurden, wird ihre Kritikalit√§t zusammengefasst.  Wenn die Gesamtkritikalit√§t den Schwellenwert erreicht, wird der Angriff erkannt und die Anforderung blockiert.  Trotz seiner Einfachheit erwies sich dieser Mechanismus als effizient und wird h√§ufig f√ºr solche Aufgaben verwendet. <br><br><h4>  Tokenizer </h4><br>  Diese Erkennungsmethode wurde auf der Black Hat 2012 als C / C + -Bibliotheks- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Libinjektion vorgestellt</a> , mit der SQL-Injektionen schnell und pr√§zise identifiziert werden k√∂nnen.  Derzeit gibt es viele Libinjection-Ports f√ºr verschiedene Programmiersprachen wie PHP, Lua, Python usw.  Dieser Mechanismus sucht nach Signaturen, die als eine Reihe von Token dargestellt werden.  Eine bestimmte Anzahl von Signaturen wird auf die schwarze Liste gesetzt und gilt als unerw√ºnscht und b√∂swillig.  Mit anderen Worten, bevor eine Anforderung analysiert wird, wird sie in eine Reihe von Token √ºbersetzt.  Token werden in bestimmte Typen unterteilt, z. B. Variable, Zeichenfolge, regul√§rer Operator, Unbekannt, Zahl, Kommentar, gewerkschafts√§hnlicher Operator, Funktion, Komma usw.  Einer der Hauptnachteile der Methode besteht darin, dass es m√∂glich ist, eine Struktur zu erstellen, die zur falschen Bildung von Token f√ºhren w√ºrde. Daher weicht die Anforderungssignatur von der erwarteten ab.  Diese Strukturen werden normalerweise als Token Breaker bezeichnet, und wir werden sie sp√§ter diskutieren <br><br><h4>  Verhaltensanalyse </h4><br>  Das Erkennen und Blockieren von Ausnutzungsversuchen in Anforderungen ist nicht die einzige Aufgabe f√ºr WAFs.  Es ist auch wichtig, den Prozess der Schwachstellensuche zu identifizieren, und die WAF muss entsprechend reagieren.  Es kann sich in Scanversuchen, Brute-Force-Verzeichnissen, Parameter-Fuzzing und anderen automatischen Methoden √§u√üern.  Erweiterte WAFs k√∂nnen Anforderungsketten erstellen, die f√ºr normales normales Verhalten typisch sind, und Versuche blockieren, ungew√∂hnliche Anforderungen zu senden.  Diese Methode erkennt Angriffe nicht so sehr, als dass sie den Prozess der Schwachstellensuche behindert.  Das Begrenzen der Anzahl von Anforderungen pro Minute w√ºrde einen normalen Benutzer nicht beeintr√§chtigen, w√§re jedoch ein ernstes Hindernis f√ºr Scanner, die in mehreren Threads arbeiten. <br><br><h4>  Reputationsanalyse </h4><br>  Dies ist ein weiterer Mechanismus, der direkt von Firewalls und Antiviren geerbt wird.  Heutzutage enth√§lt fast jede WAF Listen mit Adressen von VPNs, Anonymisierern, Tor-Knoten und Botnetzen, um Anfragen von diesen zu blockieren.  Fortgeschrittene WAFs k√∂nnen ihre Basen automatisch aktualisieren und sie basierend auf dem analysierten Verkehr durch zus√§tzliche Eintr√§ge erg√§nzen. <br><br><h4>  Maschinelles Lernen </h4><br>  Dies ist einer der fragw√ºrdigsten Aspekte von WAF.  Beachten wir, dass der Begriff ‚Äûmaschinelles Lernen‚Äú ziemlich weit gefasst ist und viele Technologien und Methoden umfasst.  Au√üerdem ist es nur eine der Klassen der KI.  "Implementierung" von maschinellem Lernen oder "Verwendung von KI" sind sehr beliebte Marketingphrasen.  Es ist nicht immer klar, welche Algorithmen genau verwendet werden, und manchmal sieht es nur nach Kauderwelsch aus.  Diejenigen Anbieter, die maschinelles Lernen wirklich nutzen und es effektiv durchf√ºhren, sind nicht bereit, ihre Erfahrungen zu teilen.  Das macht es einem Au√üenstehenden schwer, die Situation herauszufinden.  Versuchen wir dennoch, anhand der verf√ºgbaren Informationen einige Punkte hervorzuheben. <br><br>  Erstens h√§ngt maschinelles Lernen vollst√§ndig von den Daten ab, auf denen es trainiert wurde, was ein bestimmtes Problem darstellt.  Ein Entwickler sollte √ºber eine aktuelle und vollst√§ndige Basis von Angriffen verf√ºgen, was schwer zu erreichen ist.  Aus diesem Grund protokollieren viele Entwickler die Ergebnisse ihrer WAFs gr√ºndlich und arbeiten mit den Anbietern von IDS- und SIEM-Systemen zusammen, um Beispiele f√ºr reale Angriffe zu erhalten.  Zweitens kann sich ein in einer abstrakten Web-App trainiertes Modell in einer echten Web-App als v√∂llig unwirksam herausstellen.  F√ºr eine bessere Qualit√§t wird empfohlen, in der Implementierungsphase zus√§tzlich ein Modell zu trainieren, das ressourcenintensiv und zeitaufw√§ndig ist und dennoch nicht die besten Ergebnisse liefert. <br><br><h2>  WAF identifizieren </h2><br>  WAF-Entwickler verwenden verschiedene Methoden, um den Benutzer zu benachrichtigen, dass die Anforderung blockiert wurde.  Auf diese Weise k√∂nnen wir die WAF identifizieren, indem wir die Antwort auf unsere Angriffsanforderung analysieren.  Dies wird normalerweise als WAF-Fingerabdruck bezeichnet.  Fingerabdr√ºcke k√∂nnen hilfreich sein, wenn eine WAF aus irgendeinem Grund nicht aktualisiert wird (gilt haupts√§chlich f√ºr Open Source-Projekte).  Die Entwickler propriet√§rer WAFs k√ºmmern sich um ihre Kunden und implementieren automatische Updates.  Sobald wir die WAF identifiziert haben, die sich als aktualisiert herausstellte, k√∂nnen wir die Informationen dar√ºber weiterhin verwenden, um etwas √ºber ihre Logik zu lernen. <br><br>  Hier ist eine Liste m√∂glicher WAF-Fingerabdr√ºcke: <br><br><ul><li>  Zus√§tzliche Cookies </li><li>  Zus√§tzliche Header zu jeder Antwort oder Anfrage </li><li>  Antwortinhalt (bei blockierter Anfrage) </li><li>  Antwortcode (bei blockierter Anfrage) </li><li>  IP-Adresse (Cloud WAF) </li><li>  JS clientseitiges Modul (clientseitige WAF) </li></ul><br>  Lassen Sie es uns anhand einiger Beispiele veranschaulichen <br><br>  <b>PT AF</b> <br>  Antwortcode f√ºr blockierte Anforderung: 403 <br>  Kann das Client-Modul waf.js in die Antwortseite einf√ºgen <br>  Hauptteil der Antwort: <br><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>Forbidden<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">pre</span></span></span><span class="hljs-tag">&gt;</span></span>Request ID: 2017-07-31-13-59-56-72BCA33A11EC3784<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">pre</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Ein zus√§tzlicher Header, den waf.js hinzuf√ºgt: <br><br><pre> <code class="xml hljs">X-RequestId: cbb8ff9a-4e91-48b4-8ce6-1beddc197a30</code> </pre> <br>  <b>Nemesida waf</b> <br>  Antwortcode f√ºr blockierte Anforderung: 403 <br>  Hauptteil der Antwort: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"font-size: 16px; align: center;"</span></span></span><span class="hljs-tag">&gt;</span></span> Suspicious activity detected. Access to the site is blocked. If you think that is's an erroneous blocking, please email us at <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"mailto:nwaf@pentestit.ru"</span></span></span><span class="hljs-tag">&gt;</span></span>nwaf@pentestit.ru<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> and specify your IP-address. <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  <b>Wallarm</b> <br>  Antwortcode f√ºr blockierte Anforderung: 403 <br>  Zus√§tzlicher Header: Nginx-Wallarm <br><br>  <b>Citrix NetScaler AppFirewall</b> <br>  Zus√§tzlicher Cookie: <br><br><pre> <code class="xml hljs">ns_af=31+LrS3EeEOBbxBV7AWDFIEhrn8A000; ns_af_.target.br_%2F_wat=QVNQU0VTU0lP TklEQVFRU0RDU0Nf?6IgJizHRbTRNuNoOpbBOiKRET2gA</code> </pre> <br>  <b>Mod_Security ver.</b>  <b>2.9</b> <br>  Antwortcode f√ºr blockierte Anforderung: 403 <br>  Antwortstelle: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span>403 Forbidden<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>Forbidden<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>You don't have permission to access /form.php on this server.<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">br</span></span></span><span class="hljs-tag"> /&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  <b>Mod_Security ver.</b>  <b>&lt;2,9</b> <br>  Antwortcode f√ºr blockierte Anforderung: 406 oder 501 <br>  Im Antworttext finden Sie mod_security, Mod_Security oder NOYB <br><br>  <b>Lack Firewall</b> <br>  F√ºgt der Antwort die folgenden Header hinzu: <br><br><pre> <code class="plaintext hljs">X-Varnish: 127936309 131303037. X-Varnish: 435491096 Via: 1.1 varnish-v4</code> </pre> <br>  WAF-Entwickler entscheiden selbst, welcher Antwortcode im Falle einer blockierten Anforderung zur√ºckgegeben werden soll.  Es gibt auch einige spezifische Codes.  Beispielsweise gibt Web_Knight WAF den Code 999 zur√ºck, und dotDefender gibt den Code 200 mit einem leeren Antworttext oder einer Fehlermeldung zur√ºck.  Au√üerdem k√∂nnen Entwickler eine benutzerdefinierte Antwortseite mit anderen Inhalten erstellen. <br><br>  WAF entwickelt sich wie jede andere App und √§ndert sich.  Deshalb ist es wichtig, st√§ndig die Relevanz Ihrer Fingerabdr√ºcke zu √ºberpr√ºfen. <br><br><h2>  WAF Bypass Spickzettel </h2><br>  Die allgemeine Idee hinter der Suche nach M√∂glichkeiten zur Umgehung von WAF besteht darin, die von uns ben√∂tigte Anforderung so zu transformieren, dass sie f√ºr die Web-App weiterhin g√ºltig ist, jedoch nicht f√ºr die WAF oder harmlos erscheint.  Es ist wichtig, dass ein WAF-Typ viele verschiedene Servertypen bedienen kann, einschlie√ülich der ‚Äûexotischen‚Äú Server wie Unicorn, Tornado, Weblogic, Lighttpd usw.  Jeder Server kann exklusive F√§lle von HTTP-Anforderungsanalyse auf unterschiedliche Weise wahrnehmen, was auch von WAF ber√ºcksichtigt werden sollte.  Somit kann ein Angreifer die Serverspezifikationen der HTTP-Anforderungsanalyse verwenden, um eine M√∂glichkeit zu finden, die WAF zu umgehen. <br><br><img src="https://habrastorage.org/webt/59/e3/95/59e395afb9650235665851.png"><br><br>  Es ist schwierig, alle m√∂glichen M√∂glichkeiten zur Umgehung von WAF entweder nach WAF-Sicherheitsmechanismen oder nach Anwendungsbereichen zu klassifizieren.  Dieselben Bypass-Wege k√∂nnen interagieren und gleichzeitig verschiedene Komponenten eines WAF beeinflussen.  Die unten beschriebenen Techniken wurden aus offenen Quellen gesammelt oder w√§hrend unserer eigenen Forschung entdeckt und haben sich als eine der effektivsten erwiesen. <br><br><h4>  Hinzuf√ºgen spezieller Symbole </h4><br>  Verschiedene spezielle Symbole k√∂nnen die Analyselogik einer WAF verletzen und gleichzeitig vom Server g√ºltig interpretiert werden.  Variationen dieser Symbole k√∂nnen unterschiedlich sein: Sie k√∂nnen in Urlencode (obwohl die meisten WAFs damit umgehen k√∂nnen) oder andere Codierungen umgewandelt werden.  Es ist auch m√∂glich, spezielle Symbole ohne Codierung im Rohformat in eine Anfrage einzuf√ºgen, was f√ºr eine WAF eine √úberraschung sein kann.  Beispielsweise kann <b>\ r \ n \ r \ n</b> in dieser Pr√§sentation als das Ende eines HTTP-Anforderungshauptteils angesehen werden, und ein Nullbyte kann die Analyselogik regul√§rer Ausdr√ºcke und Datenparser insgesamt verletzen.  Es k√∂nnen auch andere spezielle Symbole aus den ersten zwanzig Symbolen der ASCII-Tabelle von Nutzen sein. <br>  Beispiele: <br><br><ul><li>  0x00 - Null-Byte; </li><li>  0x0D - Wagenr√ºcklauf; </li><li>  0x0A - Zeilenvorschub; </li><li>  0x0B - Vertikale Registerkarte; </li><li>  0x09 - Registerkarte Horizontal; </li><li>  0x0C - Neue Seite </li></ul><br>  Bei der Suche nach einem Bypass ist es hilfreich, spezielle Symbole an verschiedenen Stellen im Anforderungshauptteil und nicht nur in Parameterwerte einzuf√ºgen.  Wenn eine Anforderung beispielsweise im JSON-Format vorliegt, k√∂nnen wir NULL-Byte sowohl in einen Parameter als auch zwischen Parametern sowohl am Anfang als auch am Ende von JSON einf√ºgen.  Gleiches gilt f√ºr andere Formate des Hauptteils einer POST-Anfrage.  Im Allgemeinen empfehlen wir, Nachforschungen anzustellen und Spa√ü zu haben, nach Orten zu suchen, die von WAF √ºberwacht und analysiert werden k√∂nnen, und dort verschiedene spezielle Symbole zu verwenden. <br><br>  Zum Beispiel: <br><br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">1337</span></span>,<span class="hljs-attr"><span class="hljs-attr">"string0x00"</span></span>:<span class="hljs-string"><span class="hljs-string">"test' or sleep(9)#"</span></span>} {<span class="hljs-attr"><span class="hljs-attr">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">1337</span></span>,<span class="hljs-attr"><span class="hljs-attr">"string"</span></span>:<span class="hljs-string"><span class="hljs-string">"test'/*0x00*/ or sleep(9)#"</span></span>} {<span class="hljs-attr"><span class="hljs-attr">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">1337</span></span>,<span class="hljs-attr"><span class="hljs-attr">"string"</span></span>0x0A0x0D:<span class="hljs-string"><span class="hljs-string">"test' or sleep(9)#"</span></span>}</code> </pre> <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ja0x09vas0x0A0x0Dcript:alert(1)"</span></span></span><span class="hljs-tag">&gt;</span></span>clickme<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0x00</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"javascript:alert(1)"</span></span></span><span class="hljs-tag">&gt;</span></span>clickme<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0x00</span></span></span><span class="hljs-tag">/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onload</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"alert(1)"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><pre> <code class="sql hljs">id=1337<span class="hljs-comment"><span class="hljs-comment">/*0x0C*/</span></span>1 UNION <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>(), <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>() <span class="hljs-comment"><span class="hljs-comment">--</span></span></code> </pre> <br>  <i>Aus Gr√ºnden der √úbersichtlichkeit haben wir spezielle Symbole durch ihre hexadezimale Darstellung ersetzt.</i> <br><br><h4>  Leerzeichen ersetzen </h4><br>  In den meisten Syntaxen m√ºssen Schl√ºsselw√∂rter und Operatoren getrennt werden, die bevorzugten Leerzeichen werden jedoch nicht angegeben.  Daher k√∂nnen Sie anstelle der √ºblichen <b>0x20</b> ( <b>Leerzeichen</b> ) <b>0x0B</b> (vertikale Registerkarte) oder <b>0x09</b> (horizontale Registerkarte) verwenden.  Das Ersetzen von R√§umen durch Trennstrukturen ohne eigene Bedeutung f√§llt in dieselbe Kategorie.  In SQL ist es <b>/ ** /</b> (mehrzeilige SQL-Kommentare), <b># \ r \ n</b> (einzeiliger SQL-Kommentar, endend mit Zeilenvorschub), <b>- \ r \ n</b> (alternativer einzeiliger SQL-Kommentar, endend) mit Zeilenvorschub).  Hier einige Beispiele: <br><br><pre> <code class="html hljs xml">http://test.com/test?id=1%09union/**/select/**/1,2,3 http://test.com/test?id=1%09union%23%0A%0Dselect%2D%2D%0A%0D1,2,3</code> </pre> <br>  Au√üerdem k√∂nnen wir einen Ausdruck mithilfe der Syntax der Sprache transformieren, um Leerzeichen zu entfernen.  In SQL k√∂nnen wir beispielsweise Klammern verwenden: <br><br><pre> <code class="sql hljs">UNION(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>),<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,(<span class="hljs-number"><span class="hljs-number">6</span></span>)<span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">Users</span></span>)<span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span>(login=<span class="hljs-string"><span class="hljs-string">'admin'</span></span>))</code> </pre> <br>  Und in JS verwenden Sie <b>/</b> : <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onload</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">confirm(1)</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h4>  Codierung √§ndern </h4><br>  Diese Methode basiert auf der Verwendung unterschiedlicher Codierungen, um zu verhindern, dass WAF an bestimmten Stellen Daten decodiert.  Wenn beispielsweise ein Symbol durch seinen URL-Code ersetzt wird, kann WAF nicht verstehen, dass es Daten dekodieren muss, und leitet die Anforderung weiter.  Gleichzeitig wird derselbe Parameter von der Webanwendung akzeptiert und erfolgreich dekodiert. <br><br>  Die Dezimalform eines HTML-Symbols lautet <b>&amp; # 106</b> oder <b>&amp; # 0000106.</b> WAF kennt m√∂glicherweise die Kurzversion und kennt die Version mit zus√§tzlichen Nullen nicht (insgesamt sollten nicht mehr als 7 Symbole vorhanden sein).  Ebenso lautet die Hex-Form eines HTML-Symbols <b>&amp; # x6A</b> oder <b>&amp; # x000006A</b> . <br><br>  Es gibt auch einen Trick beim Entkommen von Zeichen mit einem Backslash <b>\</b> , zum Beispiel: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">on</span></span></span><span class="hljs-tag">\</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">load</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">a\lert(1)</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Dies h√§ngt jedoch davon ab, wie eine Web-App solche Eingabedaten verarbeitet.  Die Sequenz <b>\ l</b> wird also als <b>l verarbeitet</b> und in ein einzelnes Symbol umgewandelt.  WAF kann jedes Symbol separat verarbeiten und regul√§re Ausdr√ºcke oder eine andere WAF-Logik unterbrechen.  Daher wird WAF die Schl√ºsselw√∂rter √ºbersehen.  Mit dieser Technik k√∂nnen wir den Zeichen <b>\ n</b> , <b>\ r</b> , <b>\ t</b> nicht entkommen, da sie in verschiedene Zeichen umgewandelt werden: neue Zeile, Wagenr√ºcklauf und Tabulator. <br><br>  HTML-Codierung kann in Tag-Attributen verwendet werden, zum Beispiel: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"javascript&amp;colon;alert(1)"</span></span></span><span class="hljs-tag">&gt;</span></span>clickme<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag">/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onmouseover</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"javascript&amp;colon;confirm&amp;lpar;1rpar;"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Diese Zeichen k√∂nnen leicht durch andere HTML-Darstellungen von Zielzeichen ersetzt werden.  Hier k√∂nnen Sie verschiedene Transformationen von Charakteren nachschlagen. <br><br>  Neben der HTML-Codierung k√∂nnen wir Zeichen mit <b>\ u</b> einf√ºgen: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"javascript:\u0061lert(1)"</span></span></span><span class="hljs-tag">&gt;</span></span>Clickme<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onload</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">confir\u006d(1)</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Schauen wir uns auch den Vektor an, der sich auf das Einf√ºgen von Sonderzeichen bezieht.  Lassen Sie uns die Nutzdaten mit HTML-Codierung unterbrechen: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ja&amp;Tab;vas&amp;#x0000A;cript:alert(1)"</span></span></span><span class="hljs-tag">&gt;</span></span>clickme<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  In diesem Fall k√∂nnen wir auch andere Trennzeichen einf√ºgen. <br><br>  Wir empfehlen daher, verschiedene Codierungen mit anderen Methoden zu kombinieren, um beispielsweise Sonderzeichen zu codieren. <br><br><h4>  Suche nach atypischen √§quivalenten syntaktischen Strukturen </h4><br>  Diese Methode zielt darauf ab, einen Ausnutzungsweg zu finden, der von den WAF-Entwicklern nicht ber√ºcksichtigt wird, oder einen Vektor, der in der Stichprobe des maschinellen Lernens nicht vorhanden war.  Einfache Beispiele w√§ren JavaScript-Funktionen: <b>this, top self, parent, frame;</b>  Tag-Attribute: <b>Datenbindung, Ontoggle, Onfilterchange, Onbeforescriptexecute, Onpointerover, Srcdoc;</b>  und SQL-Operatoren: <b>lpad, field, bit_count</b> . <br><br>  Hier einige Beispiele: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">window</span></span></span><span class="javascript">[</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'alert'</span></span></span><span class="javascript">](</span><span class="hljs-number"><span class="javascript"><span class="hljs-number">0</span></span></span><span class="javascript">)</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript">parent[</span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'alert'</span></span></span><span class="actionscript">](</span><span class="hljs-number"><span class="actionscript"><span class="hljs-number">1</span></span></span><span class="actionscript">)</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript">self[</span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'alert'</span></span></span><span class="actionscript">](</span><span class="hljs-number"><span class="actionscript"><span class="hljs-number">2</span></span></span><span class="actionscript">)</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">LPAD</span></span>(<span class="hljs-string"><span class="hljs-string">' '</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>())=<span class="hljs-string"><span class="hljs-string">'5.7'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">sleep</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>),<span class="hljs-literal"><span class="hljs-literal">null</span></span>);</code> </pre> <br>  Sie k√∂nnen auch die nicht symbolische Darstellung von JavaScript-Ausdr√ºcken verwenden: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JSFuck</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jjencode</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Xchars.js</a> . </li></ul><br>  Ein offensichtliches Problem dabei sind lange Nutzlasten. <br><br>  Der WAF-Bypass mit dieser Technik h√§ngt vom Angriff und dem ausgenutzten Stapel von Technologien ab.  Der ber√ºhmte ImageTragick-Exploit ist ein gutes Beispiel daf√ºr.  Die meisten WAFs, die vor diesem Angriff sch√ºtzen, hatten Schl√ºsselw√∂rter wie <b>URL</b> , <b>Kapazit√§t</b> und <b>Bezeichnung auf</b> die schwarze Liste gesetzt, da diese W√∂rter in den meisten Ver√∂ffentlichungen und PoCs erw√§hnt wurden, die diese Sicherheitsanf√§lligkeit beschreiben.  Es stellte sich jedoch bald heraus, dass auch andere Schl√ºsselw√∂rter verwendet werden k√∂nnen, z. B. <b>kurzlebig</b> und <b>pango</b> .  Infolgedessen k√∂nnten WAFs mit der Verwendung dieser Schl√ºsselw√∂rter umgangen werden. <br><br><h4>  HTTP-Parameterverschmutzung (HPP) und HTTP-Parameterfragmentierung (HPF) </h4><br>  Der HPP-Angriff basiert darauf, wie ein Server gleichnamige Parameter interpretiert.  Hier sind einige m√∂gliche Umgehungen: <br><br><ul><li>  Der Server verwendet den zuletzt empfangenen Parameter und WAF √ºberpr√ºft nur den ersten. </li><li>  Der Server vereint den Wert aus √§hnlichen Parametern und WAF √ºberpr√ºft sie separat. </li></ul><br>  In der folgenden Tabelle k√∂nnen Sie vergleichen, wie verschiedene Server dieselben Parameter verarbeiten: <br><br><img src="https://habrastorage.org/webt/59/e3/77/59e3770e949f3269504620.png"><br><br>  Der HPF-Angriff basiert wiederum auf einem anderen Prinzip.  Wenn die Logik einer Webanwendung zwei und mehr Parameter in einer Anforderung vereint, kann der Gegner die Anforderung teilen, um bestimmte WAF-Pr√ºfungen zu umgehen. <br>  Die folgende SQL-Injection ist ein Beispiel f√ºr einen solchen Angriff: <br><br><pre> <code class="html hljs xml">http://test.com/url?a=1+select&amp;b=1+from&amp;c=base</code> </pre> <br>  HPF und HPP sind sich sehr √§hnlich, aber die erste zielt auf eine Web-App ab, die zweite auf die Umgebung, in der sie betrieben wird.  Die Kombination dieser Techniken erh√∂ht die Wahrscheinlichkeit, eine WAF zu umgehen. <br><br><h4>  Unicode-Normalisierung </h4><br>  Die Unicode-Normalisierung ist eine Funktion von Unicode zum Vergleichen von Unicode-Symbolen, die gleich aussehen.  Zum Beispiel haben die Symbole <b>'¬™'</b> und <b>'·µÉ'</b> unterschiedliche Codes, sind aber ansonsten sehr √§hnlich. Nach der Normalisierung sehen beide wie ein einfaches <b>'a' aus</b> und werden als gleich angesehen.  Durch die Normalisierung k√∂nnen einige komplexe Unicode-Symbole in ihre einfacheren Alternativen umgewandelt werden.  Es gibt eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unicode-Normalisierungstabelle</a> mit allen Unicode-Symbolen und ihren m√∂glichen Normalisierungen.  Mit ihm k√∂nnen Sie verschiedene Nutzdaten erstellen und mit anderen Methoden kombinieren.  Es funktioniert jedoch nicht f√ºr alle Webanwendungen und ist sehr abh√§ngig von der Umgebung. <br><br>  In der obigen Tabelle sehen wir beispielsweise, dass sich die Symbole <b><code>Ôºú</code></b> und <b><code>Ôπ§</code></b> in einfache <b><code>&lt;</code></b> verwandeln.  Wenn eine App nach der Normalisierung eine HTML-Codierung verwendet, wird h√∂chstwahrscheinlich das normalisierte Symbol <b><code>&lt;</code></b> in <b><code>&amp;lt;</code></b>  .  In anderen F√§llen haben Entwickler diese Funktion m√∂glicherweise √ºbersehen und Unicode-Symbole nicht codiert.  Auf diese Weise erhalten wir nicht HTML-codierte Symbole <b>&lt;</b> und <b>&gt;</b> , die in XSS-Angriffe umgewandelt werden k√∂nnen.  WAF kann Probleme beim Verstehen von Unicode-Symbolen haben - es gibt m√∂glicherweise einfach keine Regeln f√ºr solche Tricks, und das maschinelle Lernen kann auch nutzlos sein.  W√§hrend wir in Webanwendungen mit Unicode-Normalisierung einen Bypass finden, k√∂nnen wir nicht nur <b>&lt;&gt;,</b> sondern auch andere Symbole aus der Nutzlast ersetzen. <br><br>  Zum Beispiel: <br><br><pre> <code class="html hljs xml">Ôºúimg srcÔπ¶x onerrorÔºùalertÔ∏µ1)&gt;</code> </pre> <br>  Dieses Problem wurde k√ºrzlich beim Rockstar BugBounty-Programm bei HackerOne festgestellt.  Es gab keine WAF, nur strenge Benutzereingabefilterung: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hackerone.com/reports/231444</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hackerone.com/reports/231389</a> <br><br><h4>  Token Breaker </h4><br>  Angriffe auf Tokenizer versuchen, die Logik der Aufteilung einer Anfrage in Token mit Hilfe der sogenannten Token Breaker zu brechen.  Token Breaker sind Symbole, mit denen die Korrespondenz zwischen einem Element einer Zeichenfolge und einem bestimmten Token beeinflusst und somit die Suche nach Signatur umgangen werden kann.  Bei Verwendung von Token Breaker muss die Anforderung jedoch g√ºltig bleiben.  Die folgende Anforderung ist ein Beispiel f√ºr einen Angriff mit einem Token Breaker <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span>-@<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>()</code> </pre> <br>  Dabei ist <b>- @</b> der Token Breaker. <br><br>  Es gibt ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chear Sheet</a> , das durch MySQL-Fuzzing und √úberpr√ºfung der Ergebnisse bei der Libinjektion erworben wurde. <br><br>  Weitere Informationen zum Auffinden von Problemen bei der Libinjektion: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Noch ein Fuzzer</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fuzz zu umgehen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">So umgehen Sie die Libinjektion</a> <br><br><h4>  Verwenden der Funktionen von RFC </h4><br>  In den Spezifikationen f√ºr das HTTP / 1.1-Protokoll und verschiedenen Anforderungstypen (z. B. mehrteilige / Formulardaten) finden wir einige merkw√ºrdige Dinge, die mit den Grenzf√§llen und Tricks der Verarbeitung von Headern und Parametern zusammenh√§ngen.  WAF-Entwickler ber√ºcksichtigen solche Probleme h√§ufig nicht. Daher kann eine WAF eine Anforderung falsch analysieren und den Teil der Daten √ºbersehen, in dem ein Angriffsvektor verborgen ist.  Die meisten Probleme in WAFs h√§ngen mit der Verarbeitung von mehrteiligen / Formulardaten und bestimmten Werten des Grenzparameters zusammen, der Parametergrenzen in solchen Anforderungen angibt.  Au√üerdem k√∂nnen sich Serverentwickler ebenfalls irren und die Spezifikationen nicht vollst√§ndig unterst√ºtzen, sodass der HTTP-Parser eines Servers m√∂glicherweise nicht dokumentierte Funktionen enth√§lt. <br><br>  Bei einer HTTP-Anforderung mit mehrteiligen / Formulardaten ist die Parametergrenze f√ºr die Trennung verschiedener Parameter im Hauptteil einer Anforderung zust√§ndig.  Laut RFC muss vor jedem neuen POST-Parameter eine zuvor festgelegte Grenze mit einem Pr√§fix mit "-" gesetzt werden, damit der Server die verschiedenen Parameter einer Anforderung unterscheiden kann. <br><br><pre> <code class="plaintext hljs">POST /vuln.php HTTP/1.1 Host: test.com Connection: close Content-Type: multipart/form-data; boundary=1049989664 Content-Length: 192 --1049989664 Content-Disposition: form-data; name="id" 287356 --1049989664--</code> </pre> <br>  Der Angriff kann auch auf der Tatsache beruhen, dass ein Server und eine WAF eine Situation, in der die Grenze leer bleibt, unterschiedlich behandeln.  Laut RFC ist in diesem Fall ‚Äû-‚Äú die Grenze zwischen den Parametern.  Trotzdem kann eine WAF einen Parser verwenden, der dies nicht ber√ºcksichtigt. Infolgedessen √ºbergibt die WAF die Anforderung, da die Daten aus den Parametern einer POST-Anforderung nicht im Analysator angezeigt werden.  Der Webserver kann eine solche Anfrage problemlos analysieren und die Daten zur weiteren Verarbeitung √ºbergeben. <br>  Hier sind einige weitere interessante Beispiele. <br><br><pre> <code class="plaintext hljs">POST /vuln.php HTTP/1.1 Host: test.com Connection: close Content-Type: multipart/form-data; boundary= Content-Length: 192 -- Content-Disposition: form-data; name="id" 123' or sleep(20)# ----</code> </pre> <br>  Wir werden auf der ZeroNights 2016 einige weitere interessante Beispiele aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Folien</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bo0oM</a> geben und erkl√§ren: <br><br><pre> <code class="plaintext hljs">POST /vuln.php HTTP/1.1 Host: test.com Content-Type: multipart/form-data; boundary=FIRST; Content-Type: multipart/form-data; boundary=SECOND; Content-Type: multipart/form-data; boundary=THIRD; --THIRD Content-Disposition: form-data; name=param UNION SELECT version() --THIRD--</code> </pre><br>  Bei diesem Angriff versuchen wir zu definieren, welcher der Grenzparameter von der WAF und welcher vom Webserver akzeptiert wird.  Wenn sie unterschiedliche Parameter akzeptieren, ist es daher m√∂glich, einen Angriff durchzuf√ºhren, indem eine Grenze angegeben wird, die die WAF nicht sieht.  Dieser Angriff √§hnelt HPP. <br><br><pre> <code class="plaintext hljs">POST /vuln.php HTTP/1.1 Host: test.com Content-Type: multipart/form-data; xxxboundaryxxx=FIRST; boundary=SECOND; --FIRST Content-Disposition: form-data; name=param UNION SELECT version() --FIRST--</code> </pre><br>  Dieser Angriff basiert auf der Annahme, dass es einen Unterschied beim Parsen einer HTTP-Anforderung durch die WAF und den Webserver gibt.  Der Parser des Webservers sucht n√§mlich nach dem ersten 'Grenz'-Eintrag und dann nach dem' = 'Symbol und definiert erst danach den Wert der Grenze.  Der WAF-Parser sucht seinerseits nur nach dem Eintrag "border =" und definiert dann die Grenze.  Wenn diese Bedingungen erf√ºllt sind, findet die WAF die Grenze in der Anforderung nicht und kann daher den Parameter nicht finden und analysieren.  Im Gegenteil, der Webserver erh√§lt die Anfrage und verarbeitet den Parameter.  Dieser Angriff funktioniert auch umgekehrt: Der Webserver-Parser sucht nach "border =" und der WAF-Parser sucht nur nach "border".  In diesem Fall m√ºssen wir nur die reale Grenze von FIRST auf SECOND √§ndern. <br><br><pre> <code class="plaintext hljs">POST /somepage.php HTTP/1.1 Host: test.com Content-Type: multipart/form-data; boundary=Test0x00othertext; --Test Content-Disposition: form-data; name=param Attack --Test--</code> </pre><br>  Dieser Angriff verwendet auch Sonderzeichen.  Im Grenzparameter haben wir NULL-Byte hinzugef√ºgt, damit der Webserver es abschneidet, aber die WAF es vollst√§ndig akzeptiert.  In diesem Fall kann WAF den Parameter nicht analysieren, da er seine Grenzen nicht finden kann. <br><br><h4>  Maschinelles Lernen umgehen </h4><br>  Die Logik ist einfach: Wir m√ºssen einen Angriff erstellen, der die Parameter des trainierten statistischen Modells erf√ºllt.  Dies h√§ngt jedoch stark davon ab, wie die WAF trainiert wurde und welches Trainingsmodell verwendet wurde.  Manchmal ist es m√∂glich, eine L√ºcke zu finden, manchmal nicht.  Normalerweise ben√∂tigt eine WAF mit maschinellem Lernen in der Phase der Implementierung zus√§tzliche Schulungen, die auf der Anforderung an die Webanwendung des Kunden basieren.  Dies stellt Pentester vor ein Problem: Parameter, die sich √§hneln und sich von Anforderung zu Anforderung nicht wesentlich √§ndern, k√∂nnen nicht getestet werden, da ein Exkurs von der √ºblichen Parameterform als Anomalie angesehen wird.  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Angenommen</a></b> , Sie haben eine Anfrage an <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">api.test.com/getuser?id=123</a></b> .  Die Parameter-ID ist immer numerisch und war im Trainingsbeispiel numerisch.  Wenn das Modul f√ºr maschinelles Lernen in diesem Parameter etwas anderes als Zahlen findet, entscheidet es h√∂chstwahrscheinlich, dass es sich um eine Anomalie handelt.  Ein weiteres Beispiel: Angenommen, WAF wurde darauf trainiert, POST-Anforderungen an <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">api.test.com/setMarkDown</a></b> mit POST-Parametern mit Markdown-Text zu klassifizieren.  Offensichtlich kann es Anf√ºhrungszeichen, spezielle Symbole und im Grunde alles im Markdown geben.  In diesem Fall ist es viel einfacher, das Modul f√ºr maschinelles Lernen zu umgehen, da die WAF Anf√ºhrungszeichen und spezielle Symbole toleriert. <br><br>  Dar√ºber hinaus zeigen wir anhand der Beispiele aus unserer Praxis, dass es aufgrund der Probleme beim Parsen von Parametern, die durch die oben beschriebenen Bypass-Methoden verursacht werden, nicht immer bis zum maschinellen Lernmodul reicht. <br><br>  Im Allgemeinen m√ºssen wir die Besonderheiten einer getesteten Anforderung und ihre Parameter ber√ºcksichtigen, m√∂gliche Optionen f√ºr Parameterwerte voraussetzen, f√ºr die WAF m√∂glicherweise tolerant ist, und darauf aufbauen. <br><br><h4>  Wann ist WAF nutzlos? </h4><br>  WAF analysiert Anforderungen und sucht in ihnen nach anomalem Verhalten. Es gibt jedoch einige Klassen von Schwachstellen, die nicht erkannt werden k√∂nnen.  Zum Beispiel logische Schwachstellen, die keine Anomalien aufweisen, aber einige Aktionen aufweisen, die die Logik einer Webanwendung st√∂ren.  H√∂chstwahrscheinlich w√§re WAF auch im Falle von Race Condition, IDOR und unsicherer Benutzerauthentifizierung nutzlos. <br><br><h4>  Bestehende Dienstprogramme </h4><br>  Es gibt einige automatische Tools zum Auffinden von WAF-Byp√§ssen, die von Enthusiasten auf diesem Gebiet geschrieben wurden.  Hier sind die bekanntesten und w√ºrdigsten: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gl√ºhbirnen-Framework</a> - ein ganzes Framework zum Testen von mit WAF gesch√ºtzten Web-Apps.  Es ist auf Python geschrieben und zus√§tzlich als Plugin f√ºr Burp Suite portiert.  Die Hauptmerkmale sind diese beiden Algorithmen: <br><br><ul><li>  GOFA - ein aktiver Algorithmus f√ºr maschinelles Lernen, mit dem die Filterung und Desinfektion von Parametern in einer Web-App analysiert werden kann. </li><li>  SFADiff - deferentieller Black-Box-Testalgorithmus, basierend auf dem Training mit symbolischen endlichen Automaten (SFA).  Es erm√∂glicht das Auffinden von Unterschieden im Verhalten von Web-Apps, wodurch WAF identifiziert und ein Bypass gefunden werden kann. </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bypass WAF</a> - ein Plugin f√ºr Burp Suite, mit dem das automatische √Ñndern der Elemente im Hauptteil einer Anforderung nach verschiedenen Regeln und Codierungs√§nderungen eingerichtet werden kann.  Es kann auch einen HPP-Angriff automatisieren. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WAFW00F</a> - ein auf Python geschriebenes Tool zur WAF-Identifizierung.  Es hat eine anst√§ndige WAF-Basis und wird noch aktualisiert.  Die Ergebnisse k√∂nnen jedoch ungenau sein, da viele WAFs h√§ufiger aktualisiert werden als das Projekt selbst. <br><br><h2>  Waf in der Praxis umgehen </h2><br><img src="https://habrastorage.org/webt/59/e4/fc/59e4fc4eee061363676501.png"><br><br>  Wir haben einen Penetrationstest eines Online-Shops durchgef√ºhrt, der durch <b>PT AF</b> (Positive Technologies Application Firewall) gesch√ºtzt war.  Es war schwer, eine Schwachstelle zu finden, die eine Basis f√ºr eine Umgehung sein k√∂nnte.  Aber bald haben wir ungew√∂hnliches Verhalten auf der Seite der Web-App entdeckt, das nicht von der WAF gefiltert wurde.  Die Anomalie wurde bei der Suche in der Geschichte der gekauften Waren gefunden.  Die Anfrage wurde im JSON-Format gesendet und sah folgenderma√üen aus: <br><br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"request"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"Count"</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-attr"><span class="hljs-attr">"Offset"</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-attr"><span class="hljs-attr">"ItemName"</span></span>:<span class="hljs-string"><span class="hljs-string">"Phone"</span></span>}}</code> </pre> <br>  Wir haben die Werte <b>Phone '</b> und <b>Phone' + '</b> in den Parameter <b>ItemName eingef√ºgt</b> und festgestellt, dass der Server f√ºr diese beiden Anforderungen unterschiedliche Antworten zur√ºckgegeben hat.  Im ersten Fall war die Antwort leer;  im zweiten Fall enthielt es Daten zu anderen Waren mit dem Wort <b>Telefon</b> im Namen, als h√§tte der Parameter <b>ItemName</b> <b>Telefon</b> als Wert.  Diese Art von Verhalten ist unter Hackern und Pentestern bekannt und weist auf ein Problem der App bei der Filterung von Benutzereingaben hin, das unter anderem zur SQL-Injection f√ºhrt. <br><br>  Mal sehen, warum dies bei einem SQL-Injection-Beispiel passiert.  Wenn ein solches Verhalten in einer Webanwendung gefunden wird, ist es sehr wahrscheinlich, dass die Daten f√ºr eine SQL-Anforderung mit der Anforderung selbst verkn√ºpft sind.  Im ersten Fall haben wir mit <b>dem</b> Parameter <b>Phone '</b> die folgende SQL-Abfrage: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> items <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> item_name=<span class="hljs-string"><span class="hljs-string">'Phone''</span></span></code> </pre> <br>  Offensichtlich wird es aufgrund falscher Syntax nicht ausgef√ºhrt und gibt kein Ergebnis zur√ºck.  Die zweite Anforderung mit <b>dem</b> Parameter <b>Telefon '+'</b> sieht folgenderma√üen aus: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> items <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> item_name=<span class="hljs-string"><span class="hljs-string">'Phone'</span></span>+<span class="hljs-string"><span class="hljs-string">''</span></span></code> </pre> <br>  Die Syntax ist korrekt, daher werden Waren mit dem Namen <b>Telefon ausgew√§hlt</b> .  Diese Methode zum Erkennen von Schwachstellen hat einen gro√üen Vorteil beim Testen einer durch WAF gesch√ºtzten Webanwendung.  Ein einfaches Anf√ºhrungszeichen wird von den meisten modernen WAFs nicht als ausreichende Anomalie in einem Parameter angesehen, daher √ºbergeben sie eine Anforderung damit. <br><br>  Wir haben die Erkennung von Sicherheitsl√ºcken beschrieben, aber wie sieht es mit der Umgehung der WAF und der Ausnutzung der Sicherheitsl√ºcke aus?  Nachdem wir einige Umgehungsstra√üen durchlaufen hatten, fanden wir ein Problem in der WAF.  Es stellte sich heraus, dass diese WAF anf√§llig f√ºr Sonderzeichen ist, die zu JSON-Parametern hinzugef√ºgt wurden.  Wenn wir JSON-Symbole <b>0x0A, 0x0D</b> (\ r \ n oder carrige reutrn und neue Zeile) im Rohformat ohne Codierung in ein Textfeld einf√ºgen w√ºrden, w√ºrde die WAF dies tats√§chlich √ºbergeben und die Web-App w√ºrde dies ber√ºcksichtigen Sei korrekt und verarbeite es.  Das Problem lag h√∂chstwahrscheinlich im JSON-Parser, der nicht f√ºr spezielle Symbole erstellt und JSON bis zu einer Stelle analysiert wurde, an der diese Symbole angezeigt wurden.  Daher w√ºrde der WAF-Analysator nicht die vollst√§ndige Anforderung erhalten, sodass wir nach Sonderzeichen einen beliebigen Angriffsvektor einf√ºgen k√∂nnten.  Neben dem Zeilenumbruch w√ºrden auch andere Zeichen (z. B. NULL-Byte) funktionieren.  Infolgedessen k√∂nnten wir die folgende Anforderung schreiben, die die WAF ausschalten w√ºrde, wenn sie versucht, diese Anforderung zu √ºberpr√ºfen (Zeilenumbruch und Wagenr√ºcklauf wurden durch ihre Textdarstellung ersetzt): <br><br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"request"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"kill-waf"</span></span>:<span class="hljs-string"><span class="hljs-string">"die0x0A0x0D"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Count"</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-attr"><span class="hljs-attr">"Offset"</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-attr"><span class="hljs-attr">"ItemName"</span></span>:[<span class="hljs-string"><span class="hljs-string">"'+(SELECT 'Phone'+CHAR(ASCII(substring(@@version,1,1))-24))+'"</span></span>]}}</code> </pre> <br>  <i>0x0A und 0x0D sind Rohbytes.</i> <br><br>  Auf diese Weise konnten wir alle Parameter einfach und schnell auf Schwachstellen testen (einige davon wurden in anderen Parametern gefunden).  Durch das Umgehen von WAF und das Ausnutzen dieser Injektion konnten wir alle Benutzer der Webanwendung vollst√§ndig gef√§hrden. <br><br>  Die gleichen Probleme wurden auch in <b>Nemesida WAF gefunden</b> .  Der einzige Unterschied besteht darin, dass die Anforderung nicht in JSON-Codierung vorliegt, sondern eine √ºbliche POST-Anforderung mit Parametern ist und ein Parameter als Zahl auf die SQL-Abfrage bezogen wurde.  Wenn einige Symbole in einer Anforderung in URL-Codierung platziert wurden, z. B. <b>% 03% 04,</b> blockiert WAF eine Anforderung. Wenn Symbole jedoch in Rohform ohne URL-Codierung platziert wurden, √ºbersieht WAF diese Anforderung.  Es ist erw√§hnenswert, dass der normale SQL-Ausdruck sowohl in der Anforderung als auch in der vorherigen WAF platziert wurde.  Der SQL-Ausdruck war einfach <b>'UNION SELECT'</b> ohne zus√§tzliche Verschleierung, was bedeutet, dass WAF die Anforderung einfach nicht korrekt analysieren und die Analyse weitergeben konnte.  Es gibt jedoch ein Problem: Wie kann die SQL-Abfragesyntax korrigiert werden?  Weil die Verwendung von Sonderzeichen wie <b>% 03% 04</b> in SQL-Abfragen nicht korrekt ist.  Die Antwort ist einfach - wir m√ºssen nur Kommentare / ** / verwenden.  Die Ergebnisanforderung sah also so aus: <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">/*0x03 0x04*/</span></span>1 UNION <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>(), <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>() <span class="hljs-comment"><span class="hljs-comment">--</span></span></code> </pre> <br>  <i>0x03 und 0x04 sind Rohbytes.</i> <br><br>  Ein weiteres Problem wurde in Nemesida WAF gefunden.  Es war mit einer fehlerhaften Verarbeitung von POST-Anfragen mit mehrteiligen / Formulardaten verbunden.  Wie unten beschrieben, ist bei einer HTTP-Anforderung mit mehrteiligen / Formulardaten die Parametergrenze f√ºr die Trennung verschiedener Parameter im Hauptteil einer Anforderung zust√§ndig.  Laut RFC muss vor jedem neuen POST-Parameter eine zuvor festgelegte Grenze mit einem Pr√§fix mit <b>"-"</b> gesetzt werden, damit der Server die verschiedenen Parameter einer Anforderung unterscheiden kann. <br>  Das Problem war also, dass der Server und die WAF die Situation unterschiedlich handhabten, wenn der Grenzparameter leer war.  Basierend auf dem RFC ist in einer solchen Situation die Grenze zwischen den Parametern eine Folge von Zeichen <b>"-"</b> .  WAF verwendete jedoch einen Parser, der diese Funktion nicht ber√ºcksichtigt. Aus diesem Grund hat WAF die Anforderung erneut √ºbergeben, da die Daten aus den POST-Anforderungsparametern einfach nicht in das Analysemodul gelangt sind und der Server diese Situation ohne Probleme analysiert hat und √ºbertrug die Daten weiter zur Verarbeitung.  Dies ist eine Beispielanforderung f√ºr diesen Angriff: <br><br><pre> <code class="plaintext hljs">POST /wp-content/plugins/answer-my-question/modal.php HTTP/1.1 Host: example.com Content-Type: multipart/form-data; boundary= Content-Length: 209 -- Content-Disposition: form-data; name="id" 1 UNION SELECT 1,2,3,CONVERT(version() USING utf8) AS name,CONVERT(user() USING utf8) AS name,6,7,8,9,10,11,12 FROM wp_users WHERE id=1 ----</code> </pre><br>  Beide Probleme wurden Pentestit gemeldet, die Jungs zahlten eine Belohnung f√ºr ihr Bug-Bounty-Programm f√ºr Nemesida WAF und behebten die Probleme so schnell wie m√∂glich.  Danke ihnen daf√ºr. <br><br>  Wie wir sehen k√∂nnen, m√∂gen WAFs modern und intelligent sein, aber manchmal ist es m√∂glich, sie zu umgehen, indem nur ein einziges Sonderzeichen hinzugef√ºgt wird.  Heutzutage k√∂nnen wir nicht alle m√∂glichen Arten von Eingabedaten f√ºr alle Server in der Entwicklungsphase vorhersehen, und maschinelles Lernen, das genau daf√ºr implementiert wurde, st√∂√üt auf Parser, die mit Sonderzeichen h√§ngen bleiben. <br><br><h2>  Fazit </h2><br><img align="left" src="https://habrastorage.org/webt/59/e5/54/59e55464f2331285132470.png">  Sollen wir uns also ganz auf WAF verlassen?  <b>Die Antwort lautet NEIN.</b> <br><br>  Bei einem unserer Audits haben wir einen WAF-Bypass entdeckt, mit dem wir einige Schwachstellen ausnutzen konnten.  Wie sich herausstellte, hatten die Entwickler bereits eine Pr√ºfung der Web-App durchgef√ºhrt, bevor sie von WAF gesch√ºtzt wurde, und es wurden dieselben Sicherheitsl√ºcken aufgedeckt.  Anstatt sie zu reparieren, entschieden sie sich f√ºr einen modernen WAF mit maschinellem Lernen.  Es ist schade, dass der Anbieter der WAF nicht darauf bestand, die Sicherheitsl√ºcken zuerst zu beheben.  oder vielleicht dachten die Entwickler selbst, dass WAF eine bessere Option w√§re.  Wir wissen es jedoch nicht genau.  In beiden F√§llen ist dies ein Beispiel f√ºr eine sehr schlechte Vorgehensweise sowohl der Entwickler als auch des Anbieters.  Es sollte auch beachtet werden, dass maschinelles Lernen immer noch eine Black Box ist und eher wie ein Marketinginstrument als wie eine echte Verteidigung aussieht. <br><br>  Im Allgemeinen ist WAF eine moderne Sicherheitsl√∂sung, und es schadet nicht, sie mit Ihren Webanwendungen zu haben.  Obwohl es heute nur den Prozess der Suche und Ausnutzung von Sicherheitsl√ºcken behindern kann, kann es nicht vollst√§ndig vor ihnen sch√ºtzen.  Aus heutiger Sicht ist dies seit einiger Zeit Stand der Technik.  Sicherheitsl√ºcken in Web-Apps k√∂nnen nur durch Korrigieren des zugeh√∂rigen Codes behoben werden. Dies ist die einzige narrensichere L√∂sung. <br><br>  <b>Mitwirkende</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ilia Bulatov</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">barracud4</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Denis Rybin</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">thefaeriedragon</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alexander Romanov</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">web_rock</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454592/">https://habr.com/ru/post/de454592/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454582/index.html">Sollte die Arrayl√§nge in einer lokalen Variablen in C # gespeichert werden?</a></li>
<li><a href="../de454584/index.html">Schule f√ºr Schnittstellenentwicklung: Analyse der Aufgaben f√ºr Minsk und ein neues Set in Moskau</a></li>
<li><a href="../de454586/index.html">L√∂sen japanischer Kreuzwortr√§tsel mit PÃ∂yÃ∂tÃ∂hÃ∂oÃ∂Ã∂nÃ∂ Rust und WebAssembly</a></li>
<li><a href="../de454588/index.html">Gazprom Neft l√§dt Sie ein: GPN Data Science Meetup</a></li>
<li><a href="../de454590/index.html">Zimbra Collaboration Suite und Mobile Control mit ABQ</a></li>
<li><a href="../de454596/index.html">Mentale Modelle in der Informationssicherheit</a></li>
<li><a href="../de454598/index.html">Serverlose Architektur und Microservices: die perfekte Erg√§nzung?</a></li>
<li><a href="../de454600/index.html">Wie wir bei Freelansim ein sicheres Gesch√§ft gemacht haben: W√§hlen Sie aus, schneiden Sie Funktionen ab, vergleichen Sie Provisionen</a></li>
<li><a href="../de454604/index.html">Generieren einer Reaktionsanwendung mit einem GraphQL-Backend in Minuten</a></li>
<li><a href="../de454606/index.html">Funktionen des Eingabemodus-Attributs f√ºr mobile Betriebssysteme und Browser</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>