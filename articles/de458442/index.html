<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💷 🎷 😱 Warum ruft LLVM möglicherweise eine nie aufgerufene Funktion auf? 🚟 🖖🏾 🕖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es ist mir egal, was dein Drache gesagt hat, es ist eine Lüge. Drachen lügen. Sie wissen nicht, was auf der anderen Seite auf Sie wartet. 

 Michael S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warum ruft LLVM möglicherweise eine nie aufgerufene Funktion auf?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458442/"><blockquote>  <i>Es ist mir egal, was dein Drache gesagt hat, es ist eine Lüge.</i>  <i>Drachen lügen.</i>  <i>Sie wissen nicht, was auf der anderen Seite auf Sie wartet.</i> <br><br>  Michael Swanwick, die Tochter des Eisendrachen </blockquote>  Dieser Artikel basiert auf dem Beitrag im Blog von Krister Walfridsson: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Warum kann undefiniertes Verhalten eine nie aufgerufene Funktion aufrufen?“</a>  . <br><br>  Der Artikel zieht eine einfache Schlussfolgerung: Undefiniertes Verhalten in einem Compiler kann alles, auch etwas absolut Unerwartetes.  In diesem Artikel untersuche ich den internen Mechanismus dieser Optimierungsarbeiten. <br><a name="habracut"></a><br>  Um Waldfridssons Beitrag im folgenden Quellcode kurz zusammenzufassen, sollte die EraseAll-Funktion nicht von main aufgerufen werden, und sie wird beim Kompilieren mit -O0 nicht wirklich aufgerufen, sondern plötzlich mit der Optimierung -O1 und höher. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdlib&gt; typedef int (*Function)(); static Function Do; static int EraseAll() { return system(“rm -rf /”); } void NeverCalled() { Do = EraseAll; } int main() { return Do(); }</span></span></span></span></code> </pre> <br>  Wie optimiert ein Compiler es?  Zunächst ist der Zeiger auf eine Funktion ungültig, da gemäß dem C-Standard alle globalen Variablen beim Starten eines Programms Nullwerte haben. <br><br><img src="https://habrastorage.org/webt/5i/k5/s0/5ik5s0xohytqkbqnw2exo1on1jc.jpeg"><br><br>  Das Programm versucht, den Do-Zeiger zu dereferenzieren und die zugewiesene Funktion aufzurufen.  Wenn wir jedoch versuchen, einen Nullzeiger dereferenzieren, sagt der Standard, dass es sich um ein undefiniertes UB-Verhalten handelt.  Wenn wir ohne Optimierung mit der Option -O0 kompilieren, erhalten wir normalerweise einen Segmentierungsfehler (unter Linux).  Aber der Standard sagt, dass im Fall von UB ein Programm alles kann. <br><br><img src="https://habrastorage.org/webt/ez/mq/bc/ezmqbco46shm4fqad2pbjyfhygw.jpeg"><br><br>  Ein Compiler verwendet diese Funktion des Standards, um unnötige Operationen zu entfernen.  Wenn ein Compiler feststellt, dass Do an einer beliebigen Stelle im Programm zugewiesen ist, kann er diesen Wert in der Initialisierungszeit zuweisen und nicht zur Laufzeit.  In Wirklichkeit gibt es zwei Möglichkeiten: <br><br>  1. Wenn ein Zeiger nach seiner Zuweisung dereferenziert wird, gewinnen wir, weil ein Compiler eine unnötige Zuweisung entfernen kann. <br><br>  2. Wenn ein Zeiger dereferenziert wird, bevor er zugewiesen werden soll, gibt der Standard an, dass es sich um UB handelt, und das Verhalten kann beliebig sein, einschließlich des Aufrufs einer beliebigen Funktion.  Das Aufrufen der Funktion PrintHello () widerspricht also nicht dem Standard. <br><br>  Das heißt, wir können in jedem Fall einem nicht initialisierten Zeiger einen Wert ungleich Null zuweisen und das Verhalten gemäß dem Standard abrufen. <br><br><img src="https://habrastorage.org/webt/se/th/yx/sethyxxeoe2wjcy941i8nxzj4gm.jpeg"><br><br>  Welche Bedingungen ermöglichen diese Optimierung?  Zu Beginn sollte ein Programm einen globalen Zeiger ohne Anfangswert oder mit Nullwert (das ist derselbe) enthalten.  Als nächstes sollte das Programm eine Zuweisung eines Werts für diesen Zeiger enthalten, unabhängig davon, ob vor oder nach der Zeiger-Dereferenzierung.  Im obigen Beispiel ist eine Zuweisung überhaupt nicht aufgetreten, aber ein Compiler sieht, dass die Zuweisung vorhanden ist. <br><br>  Wenn diese Bedingungen erfüllt sind, kann ein Compiler die Zuordnung entfernen und in den Anfangswert des Zeigers ändern. <br><br>  Im angegebenen Code ist die Variable Do ein Zeiger auf eine Funktion und hat den Anfangswert null.  Wenn wir versuchen, eine Funktion für den Nullzeiger aufzurufen, ist das Verhalten des Programms undefiniert (undefiniertes Verhalten, UB) und der Compiler hat das Recht, die UB nach Belieben zu optimieren.  In diesem Fall hat der Compiler die Zuweisung Do = EraseAll sofort ausgeführt. <br><br>  Warum passiert das?  Im Rest des Textes werden LLVM und Clang Version 5.0.0 als Compiler verwendet.  Codebeispiele können ausgeführt werden, damit Sie sich selbst üben können. <br><br>  Schauen wir uns zunächst den IR-Code an, wenn wir mit -O0 und -O1 optimieren.  Lassen Sie uns den Quellcode leicht ändern, um ihn weniger dramatisch zu machen: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdlib&gt; typedef int (*Function)(); static Function Do; static int PrintHello() { return printf("hello world\n"); } void NeverCalled() { Do = PrintHello; } int main() { return Do(); }</span></span></span></span></code> </pre> <br>  Und wir kompilieren den IR-Code mit -O0 (die Debugging-Informationen werden aus Gründen der Übersichtlichkeit weggelassen): <br><br><pre> <code class="cpp hljs">; ModuleID = <span class="hljs-string"><span class="hljs-string">'test.c'</span></span> source_filename = <span class="hljs-string"><span class="hljs-string">"test.c"</span></span> target datalayout = <span class="hljs-string"><span class="hljs-string">"em:e-i64:64-f80:128-n8:16:32:64-S128"</span></span> target triple = <span class="hljs-string"><span class="hljs-string">"x86_64-unknown-linux-gnu"</span></span> @Do = internal global i32 (...)* null, align <span class="hljs-number"><span class="hljs-number">8</span></span> @.str = <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> unnamed_addr constant [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8] c<span class="hljs-string"><span class="hljs-string">"hello world\0A\00"</span></span>, align <span class="hljs-number"><span class="hljs-number">1</span></span> ; Function Attrs: noinline nounwind optnone uwtable define <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @NeverCalled() #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: <span class="hljs-function"><span class="hljs-function">store </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i32</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitcast</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i32 ()* @PrintHello to i32 (...)*)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i32</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function">** @Do, align 8 ret </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> } </span></span>; Function Attrs: noinline nounwind optnone uwtable define i32 @main() #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: %retval = alloca i32, align <span class="hljs-number"><span class="hljs-number">4</span></span> store i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32* %retval, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">0</span></span> = load i32 (...)*, i32 (...)** @Do, align <span class="hljs-number"><span class="hljs-number">8</span></span> %call = call i32 (...) %<span class="hljs-number"><span class="hljs-number">0</span></span>() ret i32 %call } ; Function Attrs: noinline nounwind optnone uwtable define internal i32 @PrintHello() #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: %call = call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">13</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8]* @.str, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>)) ret i32 %call } declare i32 @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8*, ...) #<span class="hljs-number"><span class="hljs-number">1</span></span> And with -O1: ; ModuleID = <span class="hljs-string"><span class="hljs-string">'test.ll'</span></span> source_filename = <span class="hljs-string"><span class="hljs-string">"test.c"</span></span> target datalayout = <span class="hljs-string"><span class="hljs-string">"em:e-i64:64-f80:128-n8:16:32:64-S128"</span></span> target triple = <span class="hljs-string"><span class="hljs-string">"x86_64-unknown-linux-gnu"</span></span> @.str = <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> unnamed_addr constant [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8] c<span class="hljs-string"><span class="hljs-string">"hello world\0A\00"</span></span>, align <span class="hljs-number"><span class="hljs-number">1</span></span> ; Function Attrs: noinline nounwind optnone uwtable define <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @NeverCalled() local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: ret <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> } ; Function Attrs: noinline nounwind optnone uwtable define i32 @main() local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: %retval = alloca i32, align <span class="hljs-number"><span class="hljs-number">4</span></span> store i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32* %retval, align <span class="hljs-number"><span class="hljs-number">4</span></span> %call = call i32 (...) bitcast (i32 ()* @PrintHello to i32 (...)*)() ret i32 %call } ; Function Attrs: noinline nounwind optnone uwtable define internal i32 @PrintHello() unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: %call = call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">13</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8]* @.str, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>)) ret i32 %call } declare i32 @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8*, ...) local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Wenn Sie die ausführbaren Dateien kompilieren, bestätigen Sie, dass im ersten Fall ein Segmentierungsfehler auftritt und im zweiten Fall "Hallo Welt" angezeigt wird.  Bei anderen Optimierungsoptionen ist das Ergebnis dasselbe wie bei -O1. <br><br>  Suchen Sie nun den Teil des Compiler-Codes, der diese Optimierung durchführt.  Die Architektur von LLVM, das Frontend, behandelt keine Optimierungen selbst, d. H. Cfe (Clang Frontend) generiert immer den Code ohne Optimierungen, die wir in der Version für -O0 sehen, und alle Optimierungen werden vom Dienstprogramm opt durchgeführt: <br><br><img src="https://habrastorage.org/webt/1o/c9/vt/1oc9vtkgl4qt2yxundzkjso_u0w.jpeg"><br><br>  Mit -O1 werden 186 Optimierungsdurchläufe durchgeführt. <br><br>  Wenn wir die Pässe nacheinander ausschalten, finden wir, wonach wir suchen: den <i>globalopt-</i> Pass.  Wir können nur diesen Optimierungsdurchlauf belassen und sicherstellen, dass er und niemand anderes den Code generiert, den wir benötigen.  Die Quelle befindet sich in der Datei /lib/Transforms/IPO/GlobalOpt.cpp.  Sie können den Quellcode im LLVM-Repository sehen.  Der Kürze halber habe ich nur Funktionen bereitgestellt, die wichtig sind, um zu verstehen, wie es funktioniert. <br><br><img src="https://habrastorage.org/webt/4k/-g/nl/4k-gnlzr7e6573zeobjdcp91x5q.jpeg"><br><br>  Dieses Bild zeigt eine Struktur der IR-Darstellung.  Ein Code in der LLVM-IR-Darstellung hat Hierarchieebenen: Ein Modul repräsentiert die höchste Ebene einer Hierarchie und enthält alle Funktionen und globalen Objekte, z. B. globale Variablen.  Eine Funktion ist die wichtigste Ebene der IR-Darstellung, und die meisten Durchgänge funktionieren auf dieser Ebene.  Ein Grundblock ist eines der wichtigsten Konzepte einer Compilertheorie.  Ein Basisblock besteht aus Anweisungen, die keine Sprünge aus der Mitte eines Basisblocks oder innerhalb eines Basisblocks ausführen können.  Alle Übergänge zwischen Basisblöcken sind nur von einem Ende eines Basisblocks bis zu einem Anfang eines Basisblocks möglich, und Sprünge von oder zu einer Mitte eines Basisblocks sind niemals möglich.  Eine Befehlsebene repräsentiert eine LLVM-IR-Code-Anweisung.  Es ist keine Anweisung eines Prozessors, sondern eine Anweisung einer sehr verallgemeinerten virtuellen Maschine mit einer unendlichen Anzahl von Registern. <br><br><img src="https://habrastorage.org/webt/6y/dt/wn/6ydtwn5hajletngggvj27uzurls.png"><br><br>  Dieses Bild zeigt eine Hierarchie von LLVM-Durchläufen.  Auf der linken Seite werden Durchgänge angezeigt, die mit dem LLVM-IR-Code arbeiten, auf der rechten Seite werden Durchgänge angezeigt, die mit den Anweisungen des Ziels arbeiten. <br><br>  Zunächst wird die runOnModule-Methode implementiert, dh beim Arbeiten wird das gesamte Modul angezeigt und optimiert (was in diesem Fall natürlich sinnvoll ist).  Die Funktion, die die Optimierung durchführt, ist optimizeGlobalsInModule: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">optimizeGlobalsInModule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Module &amp;M, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DataLayout &amp;DL, TargetLibraryInfo *TLI, function_ref&lt;dominatortree&gt; LookupDomTree)</span></span></span><span class="hljs-function"> </span></span>{ SmallSet&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> comdat=<span class="hljs-string"><span class="hljs-string">"Comdat"</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>=<span class="hljs-string"><span class="hljs-string">"8"</span></span>&gt; NotDiscardableComdats; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Changed = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> LocalChange = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (LocalChange) { LocalChange = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; NotDiscardableComdats.clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GlobalVariable &amp;GV : M.globals()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Comdat *C = GV.getComdat()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GV.isDiscardableIfUnused() || !GV.use_empty()) NotDiscardableComdats.insert(C); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Function &amp;F : M) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Comdat *C = F.getComdat()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!F.isDefTriviallyDead()) NotDiscardableComdats.insert(C); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (GlobalAlias &amp;GA : M.aliases()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Comdat *C = GA.getComdat()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GA.isDiscardableIfUnused() || !GA.use_empty()) NotDiscardableComdats.insert(C); <span class="hljs-comment"><span class="hljs-comment">// Delete functions that are trivially dead, ccc -&gt; fastcc LocalChange |= OptimizeFunctions(M, TLI, LookupDomTree, NotDiscardableComdats); // Optimize global_ctors list. LocalChange |= optimizeGlobalCtorsList(M, [&amp;](Function *F) { return EvaluateStaticConstructor(F, DL, TLI); }); // Optimize non-address-taken globals. LocalChange |= OptimizeGlobalVars(M, TLI, LookupDomTree, NotDiscardableComdats); // Resolve aliases, when possible. LocalChange |= OptimizeGlobalAliases(M, NotDiscardableComdats); // Try to remove trivial global destructors if they are not removed // already. Function *CXAAtExitFn = FindCXAAtExit(M, TLI); if (CXAAtExitFn) LocalChange |= OptimizeEmptyGlobalCXXDtors(CXAAtExitFn); Changed |= LocalChange; } // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Move all global ctors functions to the end of the module for code // layout. return Changed; }</span></span></code> </pre> <br>  Versuchen wir in Worten zu beschreiben, was diese Funktion bewirkt.  Für jede globale Variable im Modul wird ein Comdat-Objekt angefordert. <br><br>  Was ist ein Comdat-Objekt? <br><br>  Ein Comdat-Abschnitt ist ein Abschnitt in der Objektdatei, in dem Objekte platziert werden, die in anderen Objektdateien dupliziert werden können.  Jedes Objekt verfügt über Informationen für den Linker, die angeben, was zu tun ist, wenn Duplikate erkannt werden.  Die Optionen können sein: Beliebig - alles tun, ExactMatch - Duplikate müssen vollständig übereinstimmen, andernfalls tritt ein Fehler auf. Größte - Nehmen Sie das Objekt mit dem größten Wert. NoDublicates - Es sollte kein Duplikat vorhanden sein. SameSize - Duplikate müssen dieselbe Größe haben. Andernfalls tritt ein Fehler auf. <br><br>  In LLVM werden Comdat-Daten durch eine Aufzählung dargestellt: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> SelectionKind { Any, <span class="hljs-comment"><span class="hljs-comment">///&lt; The linker may choose any COMDAT. ExactMatch, ///&lt; The data referenced by the COMDAT must be the same. Largest, ///&lt; The linker will choose the largest COMDAT. NoDuplicates, ///&lt; No other Module may specify this COMDAT. SameSize, ///&lt; The data referenced by the COMDAT must be the same size. };</span></span></code> </pre> <br>  und die Klasse Comdat repräsentiert tatsächlich ein Paar (Name, SelectionKind).  (Tatsächlich ist alles komplizierter.) Alle Variablen, die aus irgendeinem Grund nicht gelöscht werden können, werden in einer Reihe von NotDiscardableComdats abgelegt.  Mit Funktionen und globalen Aliasen machen wir dasselbe - etwas, das nicht gelöscht werden kann, wird in NotDiscardableComdats platziert.  Anschließend werden separate Optimierungsfunktionen für globale Konstruktoren, globale Funktionen, globale Variablen, globale Aliase und globale Destruktoren aufgerufen.  Optimierungen werden in der Schleife fortgesetzt, bis keine Optimierung mehr durchgeführt wird.  Bei jeder Iteration der Schleife wird die Menge von NotDiscardableComdats auf Null gesetzt. <br><br>  Mal sehen, welche Objekte der Liste unsere Testquelle enthält. <br><br>  Globale Variablen: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">1.</span></span> @Do = internal global i32 (...)* null, align <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">2.</span></span> @.str = <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> unnamed_addr constant [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8] c<span class="hljs-string"><span class="hljs-string">"hello world\0A\00"</span></span>, align <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  (Mit Blick auf die Zukunft kann ich sagen, dass die erste Variable bei der ersten Iteration vom Optimierer gelöscht wird.) <br>  Funktionen: <br><br><pre> <code class="cpp hljs">define <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @NeverCalled() define i32 @main() define internal i32 @PrintHello() declare i32 @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8*, ...)</code> </pre> <br>  Beachten Sie, dass printf nur deklariert, aber nicht definiert ist. <br><br>  Es gibt keine globalen Aliase. <br><br>  Schauen wir uns das Beispiel dieses Optimierungsdurchlaufs an und betrachten wir, wie sich dieses Ergebnis herausstellte.  Natürlich ist es eine sehr große Aufgabe, alle Optimierungsoptionen auch nur in einem Durchgang zu analysieren, da es sich um viele verschiedene Spezialfälle von Optimierungen handelt.  Wir werden uns auf unser Beispiel konzentrieren und die Funktionen und Datenstrukturen berücksichtigen, die für das Verständnis der Arbeit dieses Optimierungsdurchlaufs wichtig sind. <br><br>  Zunächst führt der Optimierer in diesem Fall verschiedene uninteressante Überprüfungen durch und ruft die Funktion processInternalGlobal auf, die versucht, globale Variablen zu optimieren.  Diese Funktion ist auch ziemlich komplex und macht viele verschiedene Dinge, aber wir sind an einer Sache interessiert: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GS.StoredType == GlobalStatus::StoredOnce &amp;&amp; GS.StoredOnceValue) { ... <span class="hljs-comment"><span class="hljs-comment">// We are trying to optimize global variables, about which it is known that they are assigned a value only once, except the initializing value. if (optimizeOnceStoredGlobal(GV, GS.StoredOnceValue, GS.Ordering, DL, TLI)) return true; ... }</span></span></code> </pre> <br>  Die Information, dass der globalen Variablen der Wert eins und nur einmal zugewiesen wird, wird aus der GS-Struktur (GlobalStatus) extrahiert.  Diese Struktur wird in der aufrufenden Funktion ausgefüllt: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processGlobal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GlobalValue &amp;GV, TargetLibraryInfo *TLI, function_ref&lt;dominatortree&gt; LookupDomTree)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GV.getName().startswith(<span class="hljs-string"><span class="hljs-string">"llvm."</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; GlobalStatus GS; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GlobalStatus::analyzeGlobal(&amp;GV, GS)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; ...</code> </pre> <br>  Hier sehen wir eine weitere interessante Tatsache: Objekte, deren Namen mit "llvm" beginnen.  unterliegen keiner Optimierung (da es sich um Systemaufrufe für die llvm-Laufzeit handelt).  Und nur für den Fall, dass die Namen von Variablen in LLVM IR Punkte enthalten können (und sogar aus einem Punkt mit dem Präfix @ oder% bestehen).  Die Funktion analyseGlobal ist ein Aufruf der LLVM-API, und wir werden ihre interne Arbeit nicht berücksichtigen.  Die Struktur von GlobalStatus sollte im Detail betrachtet werden, da sie sehr wichtige Informationen für Optimierungsdurchläufe enthält. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// As we analyze each global, keep track of some information about it. If we /// find out that the address of the global is taken, none of this info will be /// accurate. struct GlobalStatus { /// True if the global's address is used in a comparison. bool IsCompared = false; /// True if the global is ever loaded. If the global isn't ever loaded it /// can be deleted. bool IsLoaded = false; /// Keep track of what stores to the global look like. enum StoredType { /// There is no store to this global. It can thus be marked constant. NotStored, /// This global is stored to, but the only thing stored is the constant it /// was initialized with. This is only tracked for scalar globals. InitializerStored, /// This global is stored to, but only its initializer and one other value /// is ever stored to it. If this global isStoredOnce, we track the value /// stored to it in StoredOnceValue below. This is only tracked for scalar /// globals. StoredOnce, /// This global is stored to by multiple values or something else that we /// cannot track. Stored } StoredType = NotStored; /// If only one value (besides the initializer constant) is ever stored to /// this global, keep track of what value it is. Value *StoredOnceValue = nullptr; ... };</span></span></code> </pre> <br>  Es lohnt sich zu erklären, warum "Wenn wir herausfinden, dass die Adresse des globalen verwendet wird, ist keine dieser Informationen korrekt."  Wenn wir die Adresse einer globalen Variablen nehmen und dann etwas an diese Adresse schreiben, nicht namentlich, ist es äußerst schwierig, dies zu verfolgen, und es ist besser, solche Variablen unverändert zu lassen, ohne zu versuchen, sie zu optimieren . <br><br>  Wir gelangen also in die Funktion optimizeOnceStoredGlobal, an die die Variable (GV) und der gespeicherte Wert (StoredOnceVal) übergeben werden.  Hier sind sie: <br><br><pre> <code class="cpp hljs">@Do = internal unnamed_addr global i32 (...)* null, align <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-comment"><span class="hljs-comment">// the variable i32 (...)* bitcast (i32 ()* @PrintHello to i32 (...)*) // the value</span></span></code> </pre> <br>  Als nächstes wird für den Wert der unbedeutende Bitcast gelöscht und für die Variable die folgende Bedingung überprüft: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GV-&gt;getInitializer()-&gt;getType()-&gt;isPointerTy() &amp;&amp; GV-&gt;getInitializer()-&gt;isNullValue()) { ...</code> </pre> <br>  Das heißt, die Variable muss mit einem Nullzeiger initialisiert werden.  Wenn dies der Fall ist, erstellen wir eine neue SOVC-Variable, die dem Wert von StoredOnceVal entspricht, der in den GV-Typ umgewandelt wurde: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Constant *SOVC = dyn_cast&lt;constant&gt;(StoredOnceVal)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GV-&gt;getInitializer()-&gt;getType() != SOVC-&gt;getType()) SOVC = ConstantExpr::getBitCast(SOVC, GV-&gt;getInitializer()-&gt;getType());</code> </pre> <br>  Hier ist getBitCast die Methode, die den Bitcast-Befehl zurückgibt, der die Typen in der LLVM-IR-Sprache eingibt. <br><br>  Danach wird die Funktion OptimizeAwayTrappingUsesOfLoads aufgerufen.  Es überträgt die globale Variable GV und die Konstante LV. <br><br>  Die direkte Optimierung erfolgt über die Funktion OptimizeAwayTrappingUsesOfValue (Wert * V, Konstante * NewV). <br><br>  Für jede Verwendung einer Variablen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> UI = V-&gt;user_begin(), E = V-&gt;user_end(); UI != E; ) { Instruction *I = cast&lt;instruction&gt;(*UI++);</code> </pre> <br>  Wenn dies ein Ladebefehl ist, ersetzen Sie seinen Operanden durch einen neuen Wert: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LoadInst *LI = dyn_cast&lt;loadinst&gt;(I)) { LI-&gt;setOperand(<span class="hljs-number"><span class="hljs-number">0</span></span>, NewV); Changed = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Wenn die Variable im Funktionsaufruf oder im Funktionsaufruf verwendet wird (genau das passiert in unserem Beispiel), erstellen Sie eine neue Funktion und ersetzen Sie ihr Argument durch einen neuen Wert: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isa&lt;callinst&gt;(I) || isa&lt;invokeinst&gt;(I)) { <span class="hljs-function"><span class="hljs-function">CallSite </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(I)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CS.getCalledValue() == V) { <span class="hljs-comment"><span class="hljs-comment">// Calling through the pointer! Turn into a direct call, but be careful // that the pointer is not also being passed as an argument. CS.setCalledFunction(NewV); Changed = true; bool PassedAsArg = false; for (unsigned i = 0, e = CS.arg_size(); i != e; ++i) if (CS.getArgument(i) == V) { PassedAsArg = true; CS.setArgument(i, NewV); }</span></span></code> </pre> <br>  Alle anderen Argumente für die Funktion werden einfach kopiert. <br><br>  Ähnliche Ersetzungsalgorithmen werden auch für die Cast- und GEP-Anweisungen bereitgestellt, in unserem Fall ist dies jedoch nicht der Fall. <br><br>  Die weiteren Aktionen lauten wie folgt: Wir untersuchen alle Verwendungen einer globalen Variablen und versuchen, alles außer der Wertzuweisung zu löschen.  Wenn dies erfolgreich ist, können wir die Do-Variable löschen. <br><br>  Daher haben wir die Arbeit des Optimierungspasses LLVM an einem bestimmten Beispiel kurz besprochen.  Im Prinzip ist hier nichts sehr Kompliziertes, aber eine sorgfältigere Programmierung ist erforderlich, um alle möglichen Kombinationen von Befehlen und Variablentypen zu ermöglichen.  All dies muss natürlich durch Tests abgedeckt werden.  Das Erlernen des Quellcodes von LLVM-Optimierern hilft Ihnen beim Schreiben Ihrer Optimierungen, sodass Sie den Code für bestimmte Fälle verbessern können. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458442/">https://habr.com/ru/post/de458442/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458428/index.html">Google öffnet den Parser-Quellcode robots.txt</a></li>
<li><a href="../de458432/index.html">Kombinieren mehrerer Pakete in einem einzigen Python-Namespace</a></li>
<li><a href="../de458434/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 11. VLAN-Grundlagen</a></li>
<li><a href="../de458436/index.html">Häufige Protokollierungsfehler</a></li>
<li><a href="../de458440/index.html">Technischer Support an Wochentagen: Geschichten darüber, was passiert, wenn Sie den Benutzer nicht erreichen können</a></li>
<li><a href="../de458444/index.html">Internet für den Sommerbewohner. Teil 4. Eine SIM-Karte reicht aus</a></li>
<li><a href="../de458446/index.html">Hyperscale-Rechenzentren: Wer baut sie und wie viel kosten sie?</a></li>
<li><a href="../de458450/index.html">Eigenschaften von Quantencomputern</a></li>
<li><a href="../de458454/index.html">Alexey Savvateev: Modelle des Internets und sozialer Netzwerke</a></li>
<li><a href="../de458458/index.html">Tiefenkameras - stille Revolution (wenn Roboter sehen) Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>