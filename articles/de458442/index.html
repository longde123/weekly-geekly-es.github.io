<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí∑ üé∑ üò± Warum ruft LLVM m√∂glicherweise eine nie aufgerufene Funktion auf? üöü üññüèæ üïñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es ist mir egal, was dein Drache gesagt hat, es ist eine L√ºge. Drachen l√ºgen. Sie wissen nicht, was auf der anderen Seite auf Sie wartet. 

 Michael S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warum ruft LLVM m√∂glicherweise eine nie aufgerufene Funktion auf?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458442/"><blockquote>  <i>Es ist mir egal, was dein Drache gesagt hat, es ist eine L√ºge.</i>  <i>Drachen l√ºgen.</i>  <i>Sie wissen nicht, was auf der anderen Seite auf Sie wartet.</i> <br><br>  Michael Swanwick, die Tochter des Eisendrachen </blockquote>  Dieser Artikel basiert auf dem Beitrag im Blog von Krister Walfridsson: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûWarum kann undefiniertes Verhalten eine nie aufgerufene Funktion aufrufen?‚Äú</a>  . <br><br>  Der Artikel zieht eine einfache Schlussfolgerung: Undefiniertes Verhalten in einem Compiler kann alles, auch etwas absolut Unerwartetes.  In diesem Artikel untersuche ich den internen Mechanismus dieser Optimierungsarbeiten. <br><a name="habracut"></a><br>  Um Waldfridssons Beitrag im folgenden Quellcode kurz zusammenzufassen, sollte die EraseAll-Funktion nicht von main aufgerufen werden, und sie wird beim Kompilieren mit -O0 nicht wirklich aufgerufen, sondern pl√∂tzlich mit der Optimierung -O1 und h√∂her. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdlib&gt; typedef int (*Function)(); static Function Do; static int EraseAll() { return system(‚Äúrm -rf /‚Äù); } void NeverCalled() { Do = EraseAll; } int main() { return Do(); }</span></span></span></span></code> </pre> <br>  Wie optimiert ein Compiler es?  Zun√§chst ist der Zeiger auf eine Funktion ung√ºltig, da gem√§√ü dem C-Standard alle globalen Variablen beim Starten eines Programms Nullwerte haben. <br><br><img src="https://habrastorage.org/webt/5i/k5/s0/5ik5s0xohytqkbqnw2exo1on1jc.jpeg"><br><br>  Das Programm versucht, den Do-Zeiger zu dereferenzieren und die zugewiesene Funktion aufzurufen.  Wenn wir jedoch versuchen, einen Nullzeiger dereferenzieren, sagt der Standard, dass es sich um ein undefiniertes UB-Verhalten handelt.  Wenn wir ohne Optimierung mit der Option -O0 kompilieren, erhalten wir normalerweise einen Segmentierungsfehler (unter Linux).  Aber der Standard sagt, dass im Fall von UB ein Programm alles kann. <br><br><img src="https://habrastorage.org/webt/ez/mq/bc/ezmqbco46shm4fqad2pbjyfhygw.jpeg"><br><br>  Ein Compiler verwendet diese Funktion des Standards, um unn√∂tige Operationen zu entfernen.  Wenn ein Compiler feststellt, dass Do an einer beliebigen Stelle im Programm zugewiesen ist, kann er diesen Wert in der Initialisierungszeit zuweisen und nicht zur Laufzeit.  In Wirklichkeit gibt es zwei M√∂glichkeiten: <br><br>  1. Wenn ein Zeiger nach seiner Zuweisung dereferenziert wird, gewinnen wir, weil ein Compiler eine unn√∂tige Zuweisung entfernen kann. <br><br>  2. Wenn ein Zeiger dereferenziert wird, bevor er zugewiesen werden soll, gibt der Standard an, dass es sich um UB handelt, und das Verhalten kann beliebig sein, einschlie√ülich des Aufrufs einer beliebigen Funktion.  Das Aufrufen der Funktion PrintHello () widerspricht also nicht dem Standard. <br><br>  Das hei√üt, wir k√∂nnen in jedem Fall einem nicht initialisierten Zeiger einen Wert ungleich Null zuweisen und das Verhalten gem√§√ü dem Standard abrufen. <br><br><img src="https://habrastorage.org/webt/se/th/yx/sethyxxeoe2wjcy941i8nxzj4gm.jpeg"><br><br>  Welche Bedingungen erm√∂glichen diese Optimierung?  Zu Beginn sollte ein Programm einen globalen Zeiger ohne Anfangswert oder mit Nullwert (das ist derselbe) enthalten.  Als n√§chstes sollte das Programm eine Zuweisung eines Werts f√ºr diesen Zeiger enthalten, unabh√§ngig davon, ob vor oder nach der Zeiger-Dereferenzierung.  Im obigen Beispiel ist eine Zuweisung √ºberhaupt nicht aufgetreten, aber ein Compiler sieht, dass die Zuweisung vorhanden ist. <br><br>  Wenn diese Bedingungen erf√ºllt sind, kann ein Compiler die Zuordnung entfernen und in den Anfangswert des Zeigers √§ndern. <br><br>  Im angegebenen Code ist die Variable Do ein Zeiger auf eine Funktion und hat den Anfangswert null.  Wenn wir versuchen, eine Funktion f√ºr den Nullzeiger aufzurufen, ist das Verhalten des Programms undefiniert (undefiniertes Verhalten, UB) und der Compiler hat das Recht, die UB nach Belieben zu optimieren.  In diesem Fall hat der Compiler die Zuweisung Do = EraseAll sofort ausgef√ºhrt. <br><br>  Warum passiert das?  Im Rest des Textes werden LLVM und Clang Version 5.0.0 als Compiler verwendet.  Codebeispiele k√∂nnen ausgef√ºhrt werden, damit Sie sich selbst √ºben k√∂nnen. <br><br>  Schauen wir uns zun√§chst den IR-Code an, wenn wir mit -O0 und -O1 optimieren.  Lassen Sie uns den Quellcode leicht √§ndern, um ihn weniger dramatisch zu machen: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdlib&gt; typedef int (*Function)(); static Function Do; static int PrintHello() { return printf("hello world\n"); } void NeverCalled() { Do = PrintHello; } int main() { return Do(); }</span></span></span></span></code> </pre> <br>  Und wir kompilieren den IR-Code mit -O0 (die Debugging-Informationen werden aus Gr√ºnden der √úbersichtlichkeit weggelassen): <br><br><pre> <code class="cpp hljs">; ModuleID = <span class="hljs-string"><span class="hljs-string">'test.c'</span></span> source_filename = <span class="hljs-string"><span class="hljs-string">"test.c"</span></span> target datalayout = <span class="hljs-string"><span class="hljs-string">"em:e-i64:64-f80:128-n8:16:32:64-S128"</span></span> target triple = <span class="hljs-string"><span class="hljs-string">"x86_64-unknown-linux-gnu"</span></span> @Do = internal global i32 (...)* null, align <span class="hljs-number"><span class="hljs-number">8</span></span> @.str = <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> unnamed_addr constant [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8] c<span class="hljs-string"><span class="hljs-string">"hello world\0A\00"</span></span>, align <span class="hljs-number"><span class="hljs-number">1</span></span> ; Function Attrs: noinline nounwind optnone uwtable define <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @NeverCalled() #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: <span class="hljs-function"><span class="hljs-function">store </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i32</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitcast</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i32 ()* @PrintHello to i32 (...)*)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i32</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function">** @Do, align 8 ret </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> } </span></span>; Function Attrs: noinline nounwind optnone uwtable define i32 @main() #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: %retval = alloca i32, align <span class="hljs-number"><span class="hljs-number">4</span></span> store i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32* %retval, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">0</span></span> = load i32 (...)*, i32 (...)** @Do, align <span class="hljs-number"><span class="hljs-number">8</span></span> %call = call i32 (...) %<span class="hljs-number"><span class="hljs-number">0</span></span>() ret i32 %call } ; Function Attrs: noinline nounwind optnone uwtable define internal i32 @PrintHello() #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: %call = call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">13</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8]* @.str, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>)) ret i32 %call } declare i32 @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8*, ...) #<span class="hljs-number"><span class="hljs-number">1</span></span> And with -O1: ; ModuleID = <span class="hljs-string"><span class="hljs-string">'test.ll'</span></span> source_filename = <span class="hljs-string"><span class="hljs-string">"test.c"</span></span> target datalayout = <span class="hljs-string"><span class="hljs-string">"em:e-i64:64-f80:128-n8:16:32:64-S128"</span></span> target triple = <span class="hljs-string"><span class="hljs-string">"x86_64-unknown-linux-gnu"</span></span> @.str = <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> unnamed_addr constant [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8] c<span class="hljs-string"><span class="hljs-string">"hello world\0A\00"</span></span>, align <span class="hljs-number"><span class="hljs-number">1</span></span> ; Function Attrs: noinline nounwind optnone uwtable define <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @NeverCalled() local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: ret <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> } ; Function Attrs: noinline nounwind optnone uwtable define i32 @main() local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: %retval = alloca i32, align <span class="hljs-number"><span class="hljs-number">4</span></span> store i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32* %retval, align <span class="hljs-number"><span class="hljs-number">4</span></span> %call = call i32 (...) bitcast (i32 ()* @PrintHello to i32 (...)*)() ret i32 %call } ; Function Attrs: noinline nounwind optnone uwtable define internal i32 @PrintHello() unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: %call = call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">13</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8]* @.str, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>)) ret i32 %call } declare i32 @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8*, ...) local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Wenn Sie die ausf√ºhrbaren Dateien kompilieren, best√§tigen Sie, dass im ersten Fall ein Segmentierungsfehler auftritt und im zweiten Fall "Hallo Welt" angezeigt wird.  Bei anderen Optimierungsoptionen ist das Ergebnis dasselbe wie bei -O1. <br><br>  Suchen Sie nun den Teil des Compiler-Codes, der diese Optimierung durchf√ºhrt.  Die Architektur von LLVM, das Frontend, behandelt keine Optimierungen selbst, d. H. Cfe (Clang Frontend) generiert immer den Code ohne Optimierungen, die wir in der Version f√ºr -O0 sehen, und alle Optimierungen werden vom Dienstprogramm opt durchgef√ºhrt: <br><br><img src="https://habrastorage.org/webt/1o/c9/vt/1oc9vtkgl4qt2yxundzkjso_u0w.jpeg"><br><br>  Mit -O1 werden 186 Optimierungsdurchl√§ufe durchgef√ºhrt. <br><br>  Wenn wir die P√§sse nacheinander ausschalten, finden wir, wonach wir suchen: den <i>globalopt-</i> Pass.  Wir k√∂nnen nur diesen Optimierungsdurchlauf belassen und sicherstellen, dass er und niemand anderes den Code generiert, den wir ben√∂tigen.  Die Quelle befindet sich in der Datei /lib/Transforms/IPO/GlobalOpt.cpp.  Sie k√∂nnen den Quellcode im LLVM-Repository sehen.  Der K√ºrze halber habe ich nur Funktionen bereitgestellt, die wichtig sind, um zu verstehen, wie es funktioniert. <br><br><img src="https://habrastorage.org/webt/4k/-g/nl/4k-gnlzr7e6573zeobjdcp91x5q.jpeg"><br><br>  Dieses Bild zeigt eine Struktur der IR-Darstellung.  Ein Code in der LLVM-IR-Darstellung hat Hierarchieebenen: Ein Modul repr√§sentiert die h√∂chste Ebene einer Hierarchie und enth√§lt alle Funktionen und globalen Objekte, z. B. globale Variablen.  Eine Funktion ist die wichtigste Ebene der IR-Darstellung, und die meisten Durchg√§nge funktionieren auf dieser Ebene.  Ein Grundblock ist eines der wichtigsten Konzepte einer Compilertheorie.  Ein Basisblock besteht aus Anweisungen, die keine Spr√ºnge aus der Mitte eines Basisblocks oder innerhalb eines Basisblocks ausf√ºhren k√∂nnen.  Alle √úberg√§nge zwischen Basisbl√∂cken sind nur von einem Ende eines Basisblocks bis zu einem Anfang eines Basisblocks m√∂glich, und Spr√ºnge von oder zu einer Mitte eines Basisblocks sind niemals m√∂glich.  Eine Befehlsebene repr√§sentiert eine LLVM-IR-Code-Anweisung.  Es ist keine Anweisung eines Prozessors, sondern eine Anweisung einer sehr verallgemeinerten virtuellen Maschine mit einer unendlichen Anzahl von Registern. <br><br><img src="https://habrastorage.org/webt/6y/dt/wn/6ydtwn5hajletngggvj27uzurls.png"><br><br>  Dieses Bild zeigt eine Hierarchie von LLVM-Durchl√§ufen.  Auf der linken Seite werden Durchg√§nge angezeigt, die mit dem LLVM-IR-Code arbeiten, auf der rechten Seite werden Durchg√§nge angezeigt, die mit den Anweisungen des Ziels arbeiten. <br><br>  Zun√§chst wird die runOnModule-Methode implementiert, dh beim Arbeiten wird das gesamte Modul angezeigt und optimiert (was in diesem Fall nat√ºrlich sinnvoll ist).  Die Funktion, die die Optimierung durchf√ºhrt, ist optimizeGlobalsInModule: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">optimizeGlobalsInModule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Module &amp;M, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DataLayout &amp;DL, TargetLibraryInfo *TLI, function_ref&lt;dominatortree&gt; LookupDomTree)</span></span></span><span class="hljs-function"> </span></span>{ SmallSet&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> comdat=<span class="hljs-string"><span class="hljs-string">"Comdat"</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>=<span class="hljs-string"><span class="hljs-string">"8"</span></span>&gt; NotDiscardableComdats; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Changed = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> LocalChange = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (LocalChange) { LocalChange = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; NotDiscardableComdats.clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GlobalVariable &amp;GV : M.globals()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Comdat *C = GV.getComdat()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GV.isDiscardableIfUnused() || !GV.use_empty()) NotDiscardableComdats.insert(C); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Function &amp;F : M) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Comdat *C = F.getComdat()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!F.isDefTriviallyDead()) NotDiscardableComdats.insert(C); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (GlobalAlias &amp;GA : M.aliases()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Comdat *C = GA.getComdat()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GA.isDiscardableIfUnused() || !GA.use_empty()) NotDiscardableComdats.insert(C); <span class="hljs-comment"><span class="hljs-comment">// Delete functions that are trivially dead, ccc -&gt; fastcc LocalChange |= OptimizeFunctions(M, TLI, LookupDomTree, NotDiscardableComdats); // Optimize global_ctors list. LocalChange |= optimizeGlobalCtorsList(M, [&amp;](Function *F) { return EvaluateStaticConstructor(F, DL, TLI); }); // Optimize non-address-taken globals. LocalChange |= OptimizeGlobalVars(M, TLI, LookupDomTree, NotDiscardableComdats); // Resolve aliases, when possible. LocalChange |= OptimizeGlobalAliases(M, NotDiscardableComdats); // Try to remove trivial global destructors if they are not removed // already. Function *CXAAtExitFn = FindCXAAtExit(M, TLI); if (CXAAtExitFn) LocalChange |= OptimizeEmptyGlobalCXXDtors(CXAAtExitFn); Changed |= LocalChange; } // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Move all global ctors functions to the end of the module for code // layout. return Changed; }</span></span></code> </pre> <br>  Versuchen wir in Worten zu beschreiben, was diese Funktion bewirkt.  F√ºr jede globale Variable im Modul wird ein Comdat-Objekt angefordert. <br><br>  Was ist ein Comdat-Objekt? <br><br>  Ein Comdat-Abschnitt ist ein Abschnitt in der Objektdatei, in dem Objekte platziert werden, die in anderen Objektdateien dupliziert werden k√∂nnen.  Jedes Objekt verf√ºgt √ºber Informationen f√ºr den Linker, die angeben, was zu tun ist, wenn Duplikate erkannt werden.  Die Optionen k√∂nnen sein: Beliebig - alles tun, ExactMatch - Duplikate m√ºssen vollst√§ndig √ºbereinstimmen, andernfalls tritt ein Fehler auf. Gr√∂√üte - Nehmen Sie das Objekt mit dem gr√∂√üten Wert. NoDublicates - Es sollte kein Duplikat vorhanden sein. SameSize - Duplikate m√ºssen dieselbe Gr√∂√üe haben. Andernfalls tritt ein Fehler auf. <br><br>  In LLVM werden Comdat-Daten durch eine Aufz√§hlung dargestellt: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> SelectionKind { Any, <span class="hljs-comment"><span class="hljs-comment">///&lt; The linker may choose any COMDAT. ExactMatch, ///&lt; The data referenced by the COMDAT must be the same. Largest, ///&lt; The linker will choose the largest COMDAT. NoDuplicates, ///&lt; No other Module may specify this COMDAT. SameSize, ///&lt; The data referenced by the COMDAT must be the same size. };</span></span></code> </pre> <br>  und die Klasse Comdat repr√§sentiert tats√§chlich ein Paar (Name, SelectionKind).  (Tats√§chlich ist alles komplizierter.) Alle Variablen, die aus irgendeinem Grund nicht gel√∂scht werden k√∂nnen, werden in einer Reihe von NotDiscardableComdats abgelegt.  Mit Funktionen und globalen Aliasen machen wir dasselbe - etwas, das nicht gel√∂scht werden kann, wird in NotDiscardableComdats platziert.  Anschlie√üend werden separate Optimierungsfunktionen f√ºr globale Konstruktoren, globale Funktionen, globale Variablen, globale Aliase und globale Destruktoren aufgerufen.  Optimierungen werden in der Schleife fortgesetzt, bis keine Optimierung mehr durchgef√ºhrt wird.  Bei jeder Iteration der Schleife wird die Menge von NotDiscardableComdats auf Null gesetzt. <br><br>  Mal sehen, welche Objekte der Liste unsere Testquelle enth√§lt. <br><br>  Globale Variablen: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">1.</span></span> @Do = internal global i32 (...)* null, align <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">2.</span></span> @.str = <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> unnamed_addr constant [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8] c<span class="hljs-string"><span class="hljs-string">"hello world\0A\00"</span></span>, align <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  (Mit Blick auf die Zukunft kann ich sagen, dass die erste Variable bei der ersten Iteration vom Optimierer gel√∂scht wird.) <br>  Funktionen: <br><br><pre> <code class="cpp hljs">define <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @NeverCalled() define i32 @main() define internal i32 @PrintHello() declare i32 @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8*, ...)</code> </pre> <br>  Beachten Sie, dass printf nur deklariert, aber nicht definiert ist. <br><br>  Es gibt keine globalen Aliase. <br><br>  Schauen wir uns das Beispiel dieses Optimierungsdurchlaufs an und betrachten wir, wie sich dieses Ergebnis herausstellte.  Nat√ºrlich ist es eine sehr gro√üe Aufgabe, alle Optimierungsoptionen auch nur in einem Durchgang zu analysieren, da es sich um viele verschiedene Spezialf√§lle von Optimierungen handelt.  Wir werden uns auf unser Beispiel konzentrieren und die Funktionen und Datenstrukturen ber√ºcksichtigen, die f√ºr das Verst√§ndnis der Arbeit dieses Optimierungsdurchlaufs wichtig sind. <br><br>  Zun√§chst f√ºhrt der Optimierer in diesem Fall verschiedene uninteressante √úberpr√ºfungen durch und ruft die Funktion processInternalGlobal auf, die versucht, globale Variablen zu optimieren.  Diese Funktion ist auch ziemlich komplex und macht viele verschiedene Dinge, aber wir sind an einer Sache interessiert: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GS.StoredType == GlobalStatus::StoredOnce &amp;&amp; GS.StoredOnceValue) { ... <span class="hljs-comment"><span class="hljs-comment">// We are trying to optimize global variables, about which it is known that they are assigned a value only once, except the initializing value. if (optimizeOnceStoredGlobal(GV, GS.StoredOnceValue, GS.Ordering, DL, TLI)) return true; ... }</span></span></code> </pre> <br>  Die Information, dass der globalen Variablen der Wert eins und nur einmal zugewiesen wird, wird aus der GS-Struktur (GlobalStatus) extrahiert.  Diese Struktur wird in der aufrufenden Funktion ausgef√ºllt: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processGlobal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GlobalValue &amp;GV, TargetLibraryInfo *TLI, function_ref&lt;dominatortree&gt; LookupDomTree)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GV.getName().startswith(<span class="hljs-string"><span class="hljs-string">"llvm."</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; GlobalStatus GS; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GlobalStatus::analyzeGlobal(&amp;GV, GS)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; ...</code> </pre> <br>  Hier sehen wir eine weitere interessante Tatsache: Objekte, deren Namen mit "llvm" beginnen.  unterliegen keiner Optimierung (da es sich um Systemaufrufe f√ºr die llvm-Laufzeit handelt).  Und nur f√ºr den Fall, dass die Namen von Variablen in LLVM IR Punkte enthalten k√∂nnen (und sogar aus einem Punkt mit dem Pr√§fix @ oder% bestehen).  Die Funktion analyseGlobal ist ein Aufruf der LLVM-API, und wir werden ihre interne Arbeit nicht ber√ºcksichtigen.  Die Struktur von GlobalStatus sollte im Detail betrachtet werden, da sie sehr wichtige Informationen f√ºr Optimierungsdurchl√§ufe enth√§lt. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// As we analyze each global, keep track of some information about it. If we /// find out that the address of the global is taken, none of this info will be /// accurate. struct GlobalStatus { /// True if the global's address is used in a comparison. bool IsCompared = false; /// True if the global is ever loaded. If the global isn't ever loaded it /// can be deleted. bool IsLoaded = false; /// Keep track of what stores to the global look like. enum StoredType { /// There is no store to this global. It can thus be marked constant. NotStored, /// This global is stored to, but the only thing stored is the constant it /// was initialized with. This is only tracked for scalar globals. InitializerStored, /// This global is stored to, but only its initializer and one other value /// is ever stored to it. If this global isStoredOnce, we track the value /// stored to it in StoredOnceValue below. This is only tracked for scalar /// globals. StoredOnce, /// This global is stored to by multiple values or something else that we /// cannot track. Stored } StoredType = NotStored; /// If only one value (besides the initializer constant) is ever stored to /// this global, keep track of what value it is. Value *StoredOnceValue = nullptr; ... };</span></span></code> </pre> <br>  Es lohnt sich zu erkl√§ren, warum "Wenn wir herausfinden, dass die Adresse des globalen verwendet wird, ist keine dieser Informationen korrekt."  Wenn wir die Adresse einer globalen Variablen nehmen und dann etwas an diese Adresse schreiben, nicht namentlich, ist es √§u√üerst schwierig, dies zu verfolgen, und es ist besser, solche Variablen unver√§ndert zu lassen, ohne zu versuchen, sie zu optimieren . <br><br>  Wir gelangen also in die Funktion optimizeOnceStoredGlobal, an die die Variable (GV) und der gespeicherte Wert (StoredOnceVal) √ºbergeben werden.  Hier sind sie: <br><br><pre> <code class="cpp hljs">@Do = internal unnamed_addr global i32 (...)* null, align <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-comment"><span class="hljs-comment">// the variable i32 (...)* bitcast (i32 ()* @PrintHello to i32 (...)*) // the value</span></span></code> </pre> <br>  Als n√§chstes wird f√ºr den Wert der unbedeutende Bitcast gel√∂scht und f√ºr die Variable die folgende Bedingung √ºberpr√ºft: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GV-&gt;getInitializer()-&gt;getType()-&gt;isPointerTy() &amp;&amp; GV-&gt;getInitializer()-&gt;isNullValue()) { ...</code> </pre> <br>  Das hei√üt, die Variable muss mit einem Nullzeiger initialisiert werden.  Wenn dies der Fall ist, erstellen wir eine neue SOVC-Variable, die dem Wert von StoredOnceVal entspricht, der in den GV-Typ umgewandelt wurde: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Constant *SOVC = dyn_cast&lt;constant&gt;(StoredOnceVal)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GV-&gt;getInitializer()-&gt;getType() != SOVC-&gt;getType()) SOVC = ConstantExpr::getBitCast(SOVC, GV-&gt;getInitializer()-&gt;getType());</code> </pre> <br>  Hier ist getBitCast die Methode, die den Bitcast-Befehl zur√ºckgibt, der die Typen in der LLVM-IR-Sprache eingibt. <br><br>  Danach wird die Funktion OptimizeAwayTrappingUsesOfLoads aufgerufen.  Es √ºbertr√§gt die globale Variable GV und die Konstante LV. <br><br>  Die direkte Optimierung erfolgt √ºber die Funktion OptimizeAwayTrappingUsesOfValue (Wert * V, Konstante * NewV). <br><br>  F√ºr jede Verwendung einer Variablen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> UI = V-&gt;user_begin(), E = V-&gt;user_end(); UI != E; ) { Instruction *I = cast&lt;instruction&gt;(*UI++);</code> </pre> <br>  Wenn dies ein Ladebefehl ist, ersetzen Sie seinen Operanden durch einen neuen Wert: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LoadInst *LI = dyn_cast&lt;loadinst&gt;(I)) { LI-&gt;setOperand(<span class="hljs-number"><span class="hljs-number">0</span></span>, NewV); Changed = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Wenn die Variable im Funktionsaufruf oder im Funktionsaufruf verwendet wird (genau das passiert in unserem Beispiel), erstellen Sie eine neue Funktion und ersetzen Sie ihr Argument durch einen neuen Wert: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isa&lt;callinst&gt;(I) || isa&lt;invokeinst&gt;(I)) { <span class="hljs-function"><span class="hljs-function">CallSite </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(I)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CS.getCalledValue() == V) { <span class="hljs-comment"><span class="hljs-comment">// Calling through the pointer! Turn into a direct call, but be careful // that the pointer is not also being passed as an argument. CS.setCalledFunction(NewV); Changed = true; bool PassedAsArg = false; for (unsigned i = 0, e = CS.arg_size(); i != e; ++i) if (CS.getArgument(i) == V) { PassedAsArg = true; CS.setArgument(i, NewV); }</span></span></code> </pre> <br>  Alle anderen Argumente f√ºr die Funktion werden einfach kopiert. <br><br>  √Ñhnliche Ersetzungsalgorithmen werden auch f√ºr die Cast- und GEP-Anweisungen bereitgestellt, in unserem Fall ist dies jedoch nicht der Fall. <br><br>  Die weiteren Aktionen lauten wie folgt: Wir untersuchen alle Verwendungen einer globalen Variablen und versuchen, alles au√üer der Wertzuweisung zu l√∂schen.  Wenn dies erfolgreich ist, k√∂nnen wir die Do-Variable l√∂schen. <br><br>  Daher haben wir die Arbeit des Optimierungspasses LLVM an einem bestimmten Beispiel kurz besprochen.  Im Prinzip ist hier nichts sehr Kompliziertes, aber eine sorgf√§ltigere Programmierung ist erforderlich, um alle m√∂glichen Kombinationen von Befehlen und Variablentypen zu erm√∂glichen.  All dies muss nat√ºrlich durch Tests abgedeckt werden.  Das Erlernen des Quellcodes von LLVM-Optimierern hilft Ihnen beim Schreiben Ihrer Optimierungen, sodass Sie den Code f√ºr bestimmte F√§lle verbessern k√∂nnen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458442/">https://habr.com/ru/post/de458442/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458428/index.html">Google √∂ffnet den Parser-Quellcode robots.txt</a></li>
<li><a href="../de458432/index.html">Kombinieren mehrerer Pakete in einem einzigen Python-Namespace</a></li>
<li><a href="../de458434/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 11. VLAN-Grundlagen</a></li>
<li><a href="../de458436/index.html">H√§ufige Protokollierungsfehler</a></li>
<li><a href="../de458440/index.html">Technischer Support an Wochentagen: Geschichten dar√ºber, was passiert, wenn Sie den Benutzer nicht erreichen k√∂nnen</a></li>
<li><a href="../de458444/index.html">Internet f√ºr den Sommerbewohner. Teil 4. Eine SIM-Karte reicht aus</a></li>
<li><a href="../de458446/index.html">Hyperscale-Rechenzentren: Wer baut sie und wie viel kosten sie?</a></li>
<li><a href="../de458450/index.html">Eigenschaften von Quantencomputern</a></li>
<li><a href="../de458454/index.html">Alexey Savvateev: Modelle des Internets und sozialer Netzwerke</a></li>
<li><a href="../de458458/index.html">Tiefenkameras - stille Revolution (wenn Roboter sehen) Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>