<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👐🏾 😜 👩🏻‍🤝‍👨🏼 Warum ist ein Mann in der Java-Welt ein leidenschaftlicher Unterstützer von Node.js und JavaScript geworden? 👐🏼 🧖🏾 👰🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="David Harron, der Autor des Materials, das wir heute veröffentlichen, stellte die folgende Frage: „Sollte eine Person, die mehr als 10 Jahre bei Sun M...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warum ist ein Mann in der Java-Welt ein leidenschaftlicher Unterstützer von Node.js und JavaScript geworden?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/421741/">  David Harron, der Autor des Materials, das wir heute veröffentlichen, stellte die folgende Frage: „Sollte eine Person, die mehr als 10 Jahre bei Sun Microsystems im Java SE-Team gearbeitet hat, bis zum letzten Atemzug nur an Java-Bytecode denken und Instanzen abstrakter Schnittstellen erstellen? ".  Er stellte diese Frage in Bezug auf sich selbst, und für ihn erwies sich die Node.js-Plattform nach Java als ein Hauch frischer Luft.  David sagt, als er im Januar 2009 (kurz vor der Übernahme dieses Oracle-Unternehmens) von Sun entlassen wurde, habe er von Node.js erfahren.  Diese Technologie hat ihn begeistert.  Was bedeutet es "süchtig"?  Seit 2010 hat er viel über das Programmieren für Node.js geschrieben.  Er schrieb nämlich mehrere Bücher, darunter Node.js Web Development, dessen vierte Ausgabe dieses Jahr veröffentlicht wurde.  Er hat viele kleine Materialien über Node.js vorbereitet, die im Internet veröffentlicht wurden.  Tatsächlich verbrachte er viel Zeit und Mühe damit, über die Node.js-Plattform und die JavaScript-Funktionen zu sprechen.  Warum haben sich diejenigen, die zuvor ausschließlich in Java gearbeitet haben, so für Node.js und JavaScript interessiert? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/a7f/04b/29b/a7f04b29bb9ae083524906ac68f0d47b.jpg" alt="Bild"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Über die Java-Welt</font> </h2><br>  Während meiner Arbeit bei Sun habe ich an Java-Technologie geglaubt.  Ich hielt Präsentationen in JavaONE, nahm an der Entwicklung der Klasse java.awt.Robot teil, organisierte die Veranstaltung Mustang Regressions Contest (ein Wettbewerb zur Suche nach Fehlern in Java 1.6) und half beim Start des Projekts Distributions License for Java, das als Antwort diente auf die Frage nach Linux JDK-Distributionen vor dem Aufkommen von OpenJDK.  Später spielte ich eine Rolle beim Start des OpenJDK-Projekts.  Unterwegs habe ich ungefähr 6 Jahre lang Blog-Material auf java.net veröffentlicht (jetzt ist diese Seite geschlossen).  Dies waren 1-2 Artikel pro Woche, die wichtigen Ereignissen im Java-Ökosystem gewidmet waren.  Eine wichtige Rolle in meiner Arbeit spielte der Schutz von Java vor denen, die eine düstere Zukunft für diese Technologie vorhersagten. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0d9/adb/964/0d9adb9644509d8a25f21ebda093c506.jpg"><br>  <i><font color="#999999">Diese Auszeichnung, der Duke Award, wurde an die angesehensten Mitarbeiter von Sun vergeben.</font></i>  <i><font color="#999999">Ich habe es bekommen, nachdem ich den Mustang Regressions Contest organisiert habe</font></i> <br><br>  Was ist mit der Person passiert, die so viel mit allem zu tun hat, was mit Java zu tun hat?  Eigentlich möchte ich hier darüber sprechen, wie ich mich von einem Java-Anhänger zu einem leidenschaftlichen Unterstützer von Node.js und JavaScript entwickelt habe. <br><br>  Ich muss sagen, dass das, was mir passiert ist, nicht als völlige Aufgabe von Java bezeichnet werden kann.  In den letzten 3 Jahren habe ich ziemlich viel Java-Code geschrieben und Spring und Hibernate verwendet.  Obwohl mir das, was ich jetzt in diesem Bereich mache, wirklich gefällt (ich arbeite in der Solarbranche, mache das, was ich gerne mache - ich schreibe Anfragen für die Arbeit mit Daten aus dem Energiesektor), ist Java-Programmierung jetzt in meinen Augen verlor seine frühere Pracht. <br><br>  Durch die zweijährige Entwicklung mit Spring konnte ich eines klarstellen: Ein Versuch, komplexe Mechanismen zu verbergen, führt nicht zu Einfachheit, sondern nur zum Auftreten noch komplexerer Strukturen. <br><br>  Hier sind kurz die wichtigsten Ideen, die ich in diesem Material ansprechen werde: <br><br><ul><li>  Java-Programme sind voll von Code, der die Absichten des Programmierers verbirgt. </li><li>  Die Arbeit mit Spring und Spring Boot hat mir eine gute Lektion erteilt: Der Versuch, komplexe Mechanismen zu verbergen, führt zu noch komplexeren Konstrukten. </li><li>  Die Java EE-Plattform war ein Projekt, das sozusagen durch „gemeinsame Anstrengungen“ erstellt wurde und absolut alle Anforderungen der Entwicklung von Unternehmensanwendungen abdeckt.  Infolgedessen hat sich die Java EE-Plattform als unerschwinglich erwiesen. </li><li>  Sich mit dem Frühling zu entwickeln ist bis zu einem gewissen Punkt eine angenehme Erfahrung.  Diese Illusion verschwindet an dem Tag, an dem eine Ausnahme, die völlig unverständlich ist, aus den Tiefen eines Subsystems kommt, von dem Sie noch nie gehört haben, und es dauert mindestens drei Tage, um herauszufinden, wo das Problem liegt. </li><li>  Welche Hilfsmechanismen, die das System übermäßig belasten, benötigen Sie ein Framework, das Code für Programmierer "schreiben" kann? </li><li>  Obwohl IDEs wie Eclipse leistungsstarke Anwendungen sind, sind sie ein Indikator für die Komplexität des Java-Ökosystems. </li><li>  Die Node.js-Plattform entstand aufgrund der Bemühungen einer Person, ihre Vision einer leichten ereignisgesteuerten Architektur zu verbessern. </li><li>  Die JavaScript-Community scheint begeistert davon zu sein, Boilerplate-Code loszuwerden, der es Programmierern ermöglicht, ihre Absichten so klar wie möglich auszudrücken. </li><li>  Async / await ist eine Lösung für das Problem der JS-Rückrufhölle, das ein Beispiel für die Ablehnung von Vorlagencode darstellt und zur Klarheit des Ausdrucks von Programmiererabsichten beiträgt. </li><li>  Das Programmieren für Node.js ist ein echtes Vergnügen. </li><li>  In JavaScript gibt es keine Java-spezifische Typisierung.  Dies ist der Segen und Fluch der Zunge.  Dies erleichtert das Schreiben von Code, aber um die Richtigkeit zu überprüfen, müssen Sie mehr Zeit für das Testen aufwenden. </li><li>  Das von npm / yarn eingeführte Paketverwaltungssystem ist einfach und macht Spaß.  Sie kann nicht mit Maven verglichen werden. </li><li>  Sowohl Java als auch Node.js bieten eine hervorragende Leistung.  Dies widerspricht dem Mythos, dass JavaScript eine langsame Sprache ist, deren Verwendung zu einer schlechten Leistung der Node.js-Plattform führt. </li><li>  Leistung Node.js baut auf den Bemühungen von Google auf, V8 zu verbessern, die Engine, die sich auf die Geschwindigkeit des Chrome-Browsers auswirkt. </li><li>  Der harte Wettbewerb zwischen Herstellern von browserbasierten JS-Engines trägt zur Entwicklung von JavaScript bei, was für Node.js sehr vorteilhaft ist. </li></ul><br><h2>  <font color="#3AC1EF">Informationen zu Java-Entwicklungsproblemen</font> </h2><br>  Einige Werkzeuge oder Objekte sind das Ergebnis langjähriger Bemühungen der Ingenieure, sie zu verbessern.  Programmierer probieren verschiedene Ideen aus, entfernen unnötige Attribute und erhalten dadurch Entitäten, in denen ausschließlich das vorhanden ist, was zur Lösung eines bestimmten Problems erforderlich ist.  Oft haben solche Technologien eine sehr attraktive Einfachheit, die leistungsstarke Funktionen verbirgt.  Dies gilt nicht für Java. <br><br>  Spring ist ein beliebtes Framework für die Entwicklung von Java-basierten Webanwendungen. <br><br>  Das Hauptziel von Spring und insbesondere von Spring Boot besteht darin, die Verwendung des vorkonfigurierten Java EE-Stacks bereitzustellen.  Der Programmierer, der Spring verwendet, sollte sich nicht um Servlets, persistente Speichersysteme, Anwendungsserver und Unbekanntes kümmern, um ein vorgefertigtes System zu erstellen.  All diese Bedenken werden an Spring weitergegeben, und der Programmierer schreibt Code, der die Logik der Anwendung implementiert.  Beispielsweise sind JPARepository-Mechanismen für die Generierung von Datenbankabfragen für Methoden verantwortlich, deren Namen wie <code>findUserByFirstName</code> aussehen.  Der Programmierer muss den Code für solche Methoden nicht schreiben.  Es reicht aus, die Beschreibung der Methode an das System zu übergeben, und Spring erledigt den Rest. <br><br>  Es klingt alles sehr gut, es ist schön, in diesem Stil zu arbeiten, aber - bis etwas Unerwartetes passiert. <br><br>  Ich meine eine Situation, in der zum Beispiel eine Hibernate <code>PersistentObjectException</code> ausgelöst wird, bei der die von der Nachricht <code>detached entity passed to persist</code> .  Was könnte es bedeuten?  Es dauerte mehrere Tage, um es herauszufinden.  Wenn Sie alles sehr vereinfacht beschreiben, bedeutet dies, dass die am REST-Endpunkt empfangenen JSON-Daten ID-Felder mit einigen Werten enthalten.  Wenn Sie nicht auf Details eingehen, versucht der Ruhezustand erneut, die ID-Werte zu steuern, und löst daher die obige undurchsichtige Ausnahme aus.  Es gibt Tausende solcher Fehlermeldungen, die verwirrend und schwer zu lesen sind.  Wenn man bedenkt, dass es im Frühjahr ganze Kaskaden von Subsystemen gibt, die aufeinander basieren, sieht der Spring-Stapel wie ein vereidigter Feind eines Programmierers aus, der ihn beobachtet und darauf wartet, dass der Programmierer den geringsten Fehler macht, und in diesem Fall Ausnahmen auslöst, die nicht mit ihm kompatibel sind normaler Betrieb der Anwendung. <br><br>  Außerdem können Sie hier die längsten Stapelspuren abrufen.  Sie repräsentieren mehrere Bildschirme mit allen möglichen abstrakten Methoden.  Spring erstellt offensichtlich die Konfiguration, die erforderlich ist, um das zu implementieren, was im Code ausgedrückt wird.  Eine solche Abstraktionsebene erfordert zweifellos eine beträchtliche Menge an Hilfslogik, die darauf abzielt, alles zu entdecken, was zum Funktionieren des Codes erforderlich ist, um beispielsweise Anforderungen zu erfüllen.  Und lange Stapelspuren sind nicht unbedingt schlecht.  Solche Dinge sind eher ein Symptom, das zu der Frage führt, welche Art von Belastung des Systems durch Hilfsmechanismen erzeugt wird. <br><br>  Wie wird die <code>findUserByFirstName</code> Methode <code>findUserByFirstName</code> , da der Programmierer den Code für eine solche Methode nicht geschrieben hat?  Das Framework muss den Methodennamen analysieren, die Absicht des Programmierers verstehen, so etwas wie einen abstrakten Syntaxbaum erstellen, eine Art SQL-Code generieren und so weiter.  Wie lädt das alles das System?  Und das alles nur, damit der Programmierer keinen Code schreiben muss? <br><br>  Nachdem Sie einige zehn Mal nach der Bedeutung des oben genannten Fehlers gesucht haben und wochenlang versucht haben, Geheimnisse zu entschlüsseln, die Sie im Großen und Ganzen nicht enträtseln sollten, können Sie zu dem gleichen Schluss kommen, zu dem ich gekommen bin .  Seine Bedeutung ist, dass der Versuch, komplexe Mechanismen zu verbergen, nicht zur Einfachheit führt, sondern nur zum Auftreten noch komplexerer Strukturen.  Die Node.js-Plattform ist viel einfacher. <br><br>  Der Slogan „Compatibility Matters“ verbarg eine wunderbare Idee, wonach Abwärtskompatibilität das wichtigste Merkmal der Java-Plattform war.  Wir haben das ernst genommen und Bilder auf T-Shirts wie das unten gezeigte angebracht. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b2a/cd5/c40/b2acd5c404b3bc69c4d3af9da1fd6952.jpg"><br>  <i><font color="#999999">Abwärtskompatibilität ist sehr wichtig.</font></i> <br><br>  Natürlich kann dieses Maß an Aufmerksamkeit für die Abwärtskompatibilität eine Quelle ständiger Angst sein, und von Zeit zu Zeit ist es nützlich, sich von alten Mechanismen zu entfernen, die nicht mehr davon profitieren. <br><br><h2>  <font color="#3AC1EF">Java und Node.js.</font> </h2><br>  Spring und Java EE sind zu kompliziert.  Die Node.js-Plattform vor ihrem Hintergrund wird als ein Hauch frischer Luft wahrgenommen.  Das erste, was Sie bemerken, wenn Sie Node.js kennenlernen, ist der Ansatz von Ryan Dahl bei der Entwicklung des Plattformkerns.  Seine Erfahrung zeigte ihm, dass Plattformen, die Streams verwenden, benötigt werden, um komplexe, schwere Systeme zu erstellen.  Er suchte nach etwas anderem und verbrachte einige Jahre damit, die in Node.js enthaltenen grundlegenden Mechanismen zu verbessern.  Als Ergebnis erhielt er ein leichtes System, das sich durch einen einzelnen Ausführungsthread, die erfinderische Verwendung anonymer JavaScript-Funktionen als asynchrone Rückrufe und eine Laufzeitbibliothek auszeichnet, die ursprünglich asynchrone Mechanismen implementiert.  Die erste Nachricht beim Erstellen eines solchen Systems war, eine leistungsstarke Ereignisverarbeitung mit der Übermittlung dieser Ereignisse in einer Rückruffunktion bereitzustellen. <br><br>  Als nächstes ist eine wichtige Funktion von Node.js die Verwendung von JavaScript.  Es besteht das Gefühl, dass diejenigen, die in JS schreiben, dazu neigen, Vorlagencode loszuwerden, wodurch sie die Absichten des Programmierers klar beschreiben können. <br><br>  Betrachten Sie als Beispiel für den Unterschied zwischen Java und JavaScript die Implementierung von Listener-Funktionen (Beobachter).  In Java müssen Sie für die Arbeit mit Listenern eine bestimmte Instanz der abstrakten Schnittstelle erstellen.  Dies beinhaltet die Verwendung sperriger Sprachkonstrukte, die die Essenz des Geschehens verbergen.  Wie kann man die Absicht eines Programmierers erkennen, die unter dem Deckmantel des Boilerplate-Codes verborgen ist? <br><br>  JavaScript verwendet stattdessen einfache anonyme Funktionen.  Bei der Implementierung eines Listeners müssen Sie nicht nach einer geeigneten abstrakten Schnittstelle suchen.  Es reicht aus, ohne die Notwendigkeit einer Vielzahl von Hilfstexten zu verwenden, den erforderlichen Code zu schreiben. <br><br>  Hier ist eine wichtige Idee, die aus der Analyse der oben genannten Mechanismen abgeleitet werden kann: Die meisten Programmiersprachen verbergen die Absichten des Programmierers, was dazu führt, dass der Code schwer zu verstehen ist. <br><br>  Die Entscheidung bezüglich der Verwendung von Rückruffunktionen, die Node.js anbietet, sieht sehr attraktiv aus.  Aber es ist nicht ohne Probleme. <br><br><h2>  <font color="#3AC1EF">Problemlösung und Problemlösung</font> </h2><br>  In JavaScript gibt es seit langem zwei Probleme bei der asynchronen Programmierung.  Das erste nennt Node.js die Rückrufhölle.  Dieses Problem liegt in der Tatsache, dass es während der Entwicklung leicht ist, in eine Falle zu geraten, die aus tief verschachtelten Rückruffunktionen besteht, bei denen jede Verschachtelungsebene das Programm kompliziert und die Ergebnisse von Code und Fehlern verarbeitet.  Im Zusammenhang damit gab es ein weiteres Problem, dessen Kern darin bestand, dass die JavaScript-Sprachmechanismen dem Programmierer nicht dabei halfen, Ideen zur asynchronen Codeausführung richtig auszudrücken. <br><br>  Es wurden mehrere Bibliotheken entwickelt, um die asynchrone Entwicklung unter JS zu vereinfachen.  Dies ist jedoch ein weiteres Beispiel für den Versuch, komplexe Mechanismen zu verbergen, was nur zum Auftreten noch komplexerer Strukturen führt. <br><br>  Betrachten Sie ein Beispiel: <br><br><pre> <code class="hljs lua">const async = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'async'</span></span>); const fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); const cat = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filez, fini)</span></span></span></span> { async.eachSeries(filez, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filenm, next)</span></span></span></span> {   fs.readFile(filenm, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, data)</span></span></span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">next</span></span>(err);     process.<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(data, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-built_in"><span class="hljs-built_in">next</span></span>(err);       <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">next</span></span>();     });   }); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) fini(err);   <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> fini(); }); }; cat(process.argv.slice(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) console.<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>(err.stack); });</code> </pre> <br>  Dies ist eine unscheinbare Nachahmung des Unix- <code>cat</code> .  Die asynchrone Bibliothek vereinfacht asynchrone Aufrufsequenzen.  Für die Verwendung ist jedoch eine große Menge an Code erforderlich, der die Absicht des Programmierers verbirgt. <br><br>  Im Wesentlichen enthält dieser Code eine Schleife.  Es wird nicht als regulärer Zyklus geschrieben, es werden keine natürlichen Konstruktionen der Beschreibung von Zyklen verwendet.  Darüber hinaus gelangen die Ergebnisse der Codeausführung und die von ihnen erzeugten Fehler nicht dahin, wo sie richtig gewesen wären.  Sie sind in Rückrufen gesperrt, was unpraktisch ist.  Vor der Implementierung der ES2015 / 2016-Standards in Node.js konnte jedoch nichts Besseres getan werden. <br><br>  Wenn wir diesen Code unter Berücksichtigung neuer Funktionen umschreiben, die insbesondere in Node.js 10.x verfügbar sind, erhalten wir Folgendes: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>).promises; <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cat</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filenmz</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> filenm <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> filenmz) {   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fs.readFile(filenm, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>);   <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {     process.stdout.write(data, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>, (err) =&gt; {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) reject(err);       <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> resolve();     });   }); } } cat(process.argv.slice(<span class="hljs-number"><span class="hljs-number">2</span></span>)).catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err.stack); });</code> </pre> <br>  In diesem Beispiel haben wir das Konstrukt <code>async/await</code> verwendet.  Hier werden die gleichen asynchronen Mechanismen wie im vorherigen Beispiel dargestellt, aber hier werden die üblichen Strukturen verwendet, die beim Organisieren von Schleifen verwendet werden.  Das Arbeiten mit Ergebnissen und Fehlern sieht ganz normal aus.  Ein solcher Code ist leichter zu lesen und zu schreiben.  Dieser Ansatz macht es leicht, die Absicht des Programmierers zu verstehen. <br><br>  Der einzige Nachteil ist, dass <code>process.stdout.write</code> keine Promise-Schnittstelle hat. Daher kann dieser Mechanismus nicht in asynchronen Funktionen verwendet werden, ohne ihn in ein Versprechen einzuschließen. <br><br>  Jetzt können wir daraus schließen, dass das Problem der Rückrufhölle in JavaScript auf eine Weise gelöst wurde, die sich von dem Versuch unterscheidet, komplexe Mechanismen zu verbergen.  Stattdessen wurden Änderungen an der Sprache vorgenommen, die das Problem selbst lösten und uns vor den Unannehmlichkeiten bewahrten, die durch die Notwendigkeit verursacht wurden, große Mengen an Vorlagencode in einer temporären Lösung zu verwenden.  Darüber hinaus wurde der Code durch die Verwendung des Async / Wait-Mechanismus einfach schöner. <br><br>  Wir haben diesen Abschnitt mit einer Diskussion über den Fehler von Node.js begonnen, aber eine hervorragende Lösung für die Hölle eines Rückrufs hat dazu geführt, dass aus Gerüchten über Fehler die Stärken von Node.js und JavaScript wurden. <br><br><h2>  <font color="#3AC1EF">Starke Eingabe, Schnittstellen und imaginäre Codeklarheit</font> </h2><br>  In jenen Tagen, als ich Java vor allen möglichen Angriffen schützte, betonte ich, dass Sie durch strikte Eingabe große Anwendungen schreiben können.  In jenen Tagen wurde die Entwicklung monolithischer Systeme verwendet (es gab keine Mikrodienste, es gab keinen Docker und dergleichen).  Da Java eine stark typisierte Sprache ist, hilft der Java-Compiler dem Programmierer, viele Probleme zu vermeiden, indem er verhindert, dass er den falschen Code kompiliert. <br><br>  JavaScript ist im Gegensatz zu Java nicht stark typisiert.  Daraus können wir den offensichtlichen Schluss ziehen, dass der Programmierer nicht genau weiß, mit welchen Objekten er arbeiten muss.  Wie kann ein Programmierer wissen, was er beispielsweise mit einem bestimmten Objekt tun soll, das von irgendwoher empfangen wurde? <br><br>  Die Kehrseite der starken Java-Typisierung ist, dass Sie ständig Boilerplate-Aktionen ausführen müssen.  Der Programmierer wirft ständig oder überprüft, ob alles genau wie erwartet ist.  Der Entwickler verbringt viel Zeit damit, Code zu schreiben, macht dies mit außergewöhnlicher Genauigkeit, verwendet beträchtliche Mengen an Vorlagendesigns und hofft, dass all dies ihm hilft, Zeit durch frühzeitiges Erkennen und Korrigieren von Fehlern zu sparen. <br><br>  Das Problem der Programmierung in einer stark typisierten Sprache ist so groß, dass ein Programmierer, der fast keine Optionen hat, eine große, komplexe IDE verwenden muss.  Ein einfacher Code-Editor reicht hier nicht aus.  Die einzige Möglichkeit, den Java-Programmierer in einem angemessenen Zustand zu halten (mit Ausnahme von Pizza), besteht darin, ihm ständig Dropdown-Listen mit verfügbaren Objektfeldern oder Beschreibungen von Methodenparametern anzuzeigen.  Dieser und andere unterstützende Mechanismen von IDEs wie Eclipse, NetBeans oder IntelliJ helfen beim Erstellen von Klassen, erleichtern das Refactoring und andere Aufgaben. <br><br>  Und ... ich werde nicht über Maven sprechen.  Dies ist nur ein Albtraum-Tool. <br><br>  In JavaScript werden Variablentypen nicht angegeben, wenn sie deklariert werden, Typumwandlung wird normalerweise nicht verwendet usw.  Dadurch ist der Code leichter zu lesen, aber dieser Zustand birgt auch das Risiko von Programmierfehlern, die schwer zu erkennen sind. <br><br>  Ob sich das Vorstehende auf die Pluspunkte von Java oder auf die Minuspunkte bezieht, hängt von der Sichtweise ab. <br><br>  Vor zehn Jahren glaubte ich, dass all diese Schwierigkeiten sich rechtfertigen, indem sie dem Programmierer mehr Vertrauen in den Code geben, den er schreibt.  Heute glaube ich, dass starkes Tippen die Arbeitsbelastung des Programmierers erhöht und es viel einfacher ist, Projekte zu entwickeln, als dies in JavaScript der Fall ist. <br><br><h2>  <font color="#3AC1EF">Bekämpfen Sie Fehler mit kleinen Modulen, die einfach zu testen sind</font> </h2><br>  Node.js drängt den Programmierer, seine Projekte in kleine Fragmente, sogenannte Module, zu zerlegen.  Sie mögen diese Tatsache als unbedeutend empfinden, aber sie löst teilweise das gerade erwähnte Problem. <br><br>  Hier sind die Hauptmerkmale des Moduls: <br><br><ul><li>  Unabhängigkeit  Das Modul kombiniert miteinander verbundenen Code zu einer einzigen Entität. </li><li>  Klare Grenzen.  Der Code im Modul ist durch externe Mechanismen vor Störungen geschützt. </li><li>  Expliziter Export.  Standardmäßig werden Code- und Moduldaten nicht exportiert.  Der Entwickler entscheidet unabhängig, welche Funktionen und Daten öffentlich zugänglich gemacht werden sollen. </li><li>  Expliziter Import.  Bei der Entwicklung eines Moduls entscheidet der Programmierer selbst, von welchen Modulen er abhängig ist. </li><li>  Mögliche Unabhängigkeit.  Module können im weitesten Sinne des Wortes öffentlich zugänglich gemacht werden, indem sie in npm veröffentlicht werden oder, wenn sie für die internen Anforderungen des Unternehmens bestimmt sind, in geschlossenen Repositories veröffentlicht werden.  Dies macht es einfach, dieselben Module in verschiedenen Anwendungen zu verwenden. </li><li>  Einfach zu verstehender Code.  Die Tatsache, dass die Module klein sind, das Lesen und Verstehen ihres Codes vereinfacht, eröffnet die Möglichkeit einer freien Diskussion über sie. </li><li>  Erleichtern Sie das Testen.  Ein kleines Modul kann bei korrekter Implementierung problemlos einem Unit-Test unterzogen werden. </li></ul><br>  All dies macht Node.js Modulentitäten zu klar definierten Grenzen, deren Code leicht zu schreiben, zu lesen und zu testen ist. <br><br>  Die Sorge um die Arbeit mit JavaScript ist jedoch die Tatsache, dass das Fehlen einer starken Eingabe leicht dazu führen kann, dass Code etwas falsch macht.  In einem kleinen Modul, das darauf abzielt, ein enges Problem mit klaren Grenzen zu lösen, kann „etwas stimmt nicht“ nur den Code des Moduls selbst beeinflussen.  Dies führt dazu, dass die Probleme, die das Fehlen einer strengen Eingabe verursachen können, innerhalb des Moduls gesperrt sind. <br><br>  Eine andere Lösung für das Problem der dynamischen Eingabe in JavaScript besteht darin, den Code gründlich zu testen. <br><br>  Der Entwickler muss das Testen ernst nehmen, was einen Teil der Vorteile beeinträchtigt, die sich aus der Einfachheit des JS-Entwicklungsprozesses ergeben.  Testsysteme, die von einem JS-Programmierer erstellt wurden, sollten die Fehler finden, die der Compiler automatisch finden könnte, wenn er von ihm in etwas wie Java entwickelt wird.  Schreiben Sie Tests für Ihre JS-Anwendungen? <br><br>  Für diejenigen, die ein statisches Typisierungssystem in JavaScript benötigen, kann es hilfreich sein, sich TypeScript anzusehen.  Ich benutze diese Sprache nicht, aber ich habe viele gute Dinge darüber gehört.  Es ist mit JavaScript kompatibel und erweitert die Sprache um ein Typsteuerungssystem und andere nützliche Funktionen. <br><br>  Am Ende können wir sagen, dass die Verwendung eines modularen Entwicklungsansatzes die Stärke von Node.js und JavaScript ist. <br><br><h2>  <font color="#3AC1EF">Paketverwaltung</font> </h2><br>  Ich fühle mich schlecht bei dem bloßen Gedanken an Maven, daher kann ich nicht einmal normal darüber schreiben.  Und so wie ich es verstehe, wird Maven ohne Kompromisse entweder geliebt oder gehasst. <br><br>  Das Problem hierbei ist, dass es in der Java-Umgebung kein ganzheitliches System zum Verwalten von Paketen gibt.  Maven-Pakete existieren, Sie können normal mit ihnen arbeiten, sie werden von Gradle unterstützt.  Die Art und Weise, wie die Arbeit mit ihnen organisiert ist, ähnelt jedoch nicht den Annehmlichkeiten, die das Paketverwaltungssystem für Node.js dem Entwickler bietet. <br><br>  In der Welt von Node.js gibt es zwei großartige Paketmanager, die eng zusammenarbeiten.  Das einzige derartige Tool war zunächst das npm-Repository und das gleichnamige Befehlszeilentool. <br><br>  Dank npm haben wir ein hervorragendes Schema zur Beschreibung von Paketabhängigkeiten.  Abhängigkeiten können streng sein (es wird angegeben, dass nur Version 1.2.3 eines bestimmten Pakets benötigt wird) oder mit mehreren Freiheitsgraden angegeben werden - bis zu <code>*</code> , was bedeutet, dass die neueste Version eines bestimmten Pakets verwendet wird. <br><br>  Die Node.js-Community hat Hunderttausende von Paketen im npm-Repository veröffentlicht.  Gleichzeitig ist die Verwendung von Paketen, die nicht in npm enthalten sind, so einfach wie die Verwendung von Paketen ab npm. <br><br>  Das npm-System erwies sich als so erfolgreich, dass nicht nur Entwickler von Serverprodukten auf Node.js es verwenden, sondern auch Front-End-Programmierer.  Bisher wurden Tools wie Bower zum Verwalten von Paketen verwendet.  Bower war veraltet, und jetzt können Sie feststellen, dass alle JS-Bibliotheken für die Frontend-Entwicklung als npm-Pakete vorhanden sind.  Viele Support-Tools für die Client-Entwicklung, wie die Vue.js-CLI und das Webpack, sind als Node.js-Anwendungen geschrieben. <br><br>  Ein anderes Paketverwaltungssystem für Node.js, Garn, lädt Pakete aus dem npm-Repository herunter und verwendet dieselben Konfigurationsdateien.  Der Hauptvorteil von Garn gegenüber dem npm-Paketmanager ist seine höhere Geschwindigkeit. <br><br>  Das npm-Repository, egal ob mit dem npm-Paketmanager oder dem Garnpaketmanager, ist eine leistungsstarke Grundlage dafür, was die Entwicklung für Node.js so einfach und unterhaltsam macht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5db/382/891/5db382891911a53615838db26c67936c.png"></div><br>  <i><font color="#999999">Einmal, nachdem ich bei der Entwicklung von java.awt.Robot mitgeholfen hatte, wurde ich inspiriert, dieses Ding zu kreieren.</font></i>  <i><font color="#999999">Während das offizielle Duke-Bild aus Kurven besteht, besteht RoboDuke aus geraden Linien.</font></i>  <i><font color="#999999">Nur die Ellbogengelenke dieses Roboters sind rund</font></i> <br><br><h2>  <font color="#3AC1EF">Leistung</font> </h2><br>  Java,  JavaScript     .          -,    ,    .  ,   ,  -       . <br><br>   Java,   JavaScript      .    Java   Node.js,        .     JavaScript         .         -. <br><br> JDK Sun/Oracle  HotSpot —  ,     -.        ,      ,    ,    ,     ,    . HotSpot —   ,     . <br><br>    JavaScript,       ,     JS-,   , ,    -  . ,    JavaScript           .    ,   ,    . , ,     Google Docs,     .    JS    . <br><br> Node.js     ,      V8  Google Chrome. <br><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>   ,  Google,     V8,         .     ,  V8   Crankshaft  Turbofan. <br><br>   —  ,     ,       R  Python.  ,     ,        .  JavaScript,   ,   ,           <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>  JavaScript. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>       JavaScript  , TensorFlow.js. API     API TensorFlow  Python,      .    , ,       ,        . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>     IBM,        Node.js,  ,   ,   Docker/Kubernetes.       ,       Node.js    Spring Boot.       -,        .  ,      Node.js  , ,  ,   V8. <br><br>   ,  Node.js      .      . - ,   Node.js     ,     . ,    «Node.js Web Development»,   ,      : <br><br><ul><li>   —             . </li><li>          ,   Node.js     . </li><li>       . </li></ul><br>   JavaScript    ,          Node.js.    —    Node.js-.      Node.js-   <code>node-gyp</code> ,      . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ,     Rust-  Node.js. <br><br> WebAssembly   ,    ,   JavaScript,     . WebAssembly  ,    JavaScript-.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>         WebAssembly   Node.js. <br><br><h2> <font color="#3AC1EF"> -</font> </h2><br>  - (Rich Internet Applications, RIA)        .    ,  ,     (  ) JS-,      . <br><br>   ,     20  . Sun  Netscape    Java-  Netscape Navigator. JavaScript , ,      Java-.     ,      Java-,   — Java-.       ,                .      . <br><br>    JavaScript     ,          .       RIA,  ,   -  Java      -. <br><br>    ,   RIA   .  Node.js       , ,      ,      .    JavaScript. <br><br>  Hier einige Beispiele: <br><br><ul><li>   Google Docs (    ),        ,    . </li><li>  ,  React, Angular  Vue.js,    ,   HTML, CSS  JavaScript. </li><li> Electron —   Node.js   Chromium.      -  .          ,  Visual Studio Code, Atom, GitKraken,  Postman. </li><li>    Electron/NW.js   , -, ,  React, Angular,  Vue,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> . </li></ul><br>  Java,       ,   -  -,   JavaScript.  , , -      Sun Microsystems.    Sun   ,      .      .   Java-    ,       Java   Java Web Start.       Java-  Webstart-. <br><br>          Java, ,  , IDE NetBeans  Eclipse      .      Java  ,         ,   Java. <br><br>    JavaFX. <br><br>  JavaFX, 10  ,    Sun   iPhone. ,        Java,    , ,    .         Flash      iOS.     . JavaFX    ,        ,     .       -  React, Vue.js   . <br><br>    JavaScript  Node   Java. <br><br>    Java,  -    JavaONE.        Java  . ,  ,    ,   . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bdb/5d1/736/bdb5d1736a9e8f66394d50ef11063389.jpg"><br> <i><font color="#999999"> Java</font></i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/064/0c6/da4/0640c6da4b0defa291a2b6516f2d2606.png"><br> <i><font color="#999999">  </font></i> <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>          .       «P-» (Perl, PHP, Python)  Java,      Node.js,   Ruby, Haskell, Go, Rust,   .            . <br><br>     ,  , ,    Java,    Node.js,  ,    ,    Node.js-.  Java   ,    Node.js    . ,  ,  ,    Java,    . <br><br>      . , ,        Node.js  - ,    - .           . ,      XBRL-.        XBRL   Python,  ,   ,   Python. ,  ,           ,        . <br><br>  <b>Liebe Leser!</b>  ,     ,   JavaScript  -  ,   -    Node.js,       . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de421741/">https://habr.com/ru/post/de421741/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de421731/index.html">Wie viel kostet das Erstellen von Software? Woraus besteht das Budget für die Anwendungsentwicklung?</a></li>
<li><a href="../de421733/index.html">Nehmen Sie es und tun Sie es: Warum es manchmal nützlich ist, für die Analyse zu punkten und sich einfach zu entwickeln</a></li>
<li><a href="../de421735/index.html">"Viren" in Erweiterungen am Beispiel von FastProxy</a></li>
<li><a href="../de421737/index.html">Das amerikanische Unternehmen beschäftigt seine Mitarbeiter seit einem Jahr. Warum könnte es eine Zukunft geben?</a></li>
<li><a href="../de421739/index.html">Wie ich RxJava in meinem Projekt durch Coroutinen ersetzt habe und warum Sie dies wahrscheinlich auch tun sollten</a></li>
<li><a href="../de421745/index.html">Wie Ubisoft seine Starlink: Battle for Atlas Hybrid Game Suite startete</a></li>
<li><a href="../de421747/index.html">Parktronic auf Arduino</a></li>
<li><a href="../de421749/index.html">"Sehr wenige schreiben wirklich ein Backend über Kotlin" - ein Interview mit Pascha Finkelstein</a></li>
<li><a href="../de421751/index.html">Die besten kostenlosen Editoren für Entwicklung und Dokumentation: Atom</a></li>
<li><a href="../de421753/index.html">Videoüberprüfung DJI Mavic 2 Zoom und 2 Pro. Testen von Kameras und neuen Funktionen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>