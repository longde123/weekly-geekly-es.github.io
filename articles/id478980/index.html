<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍⚕️ ☢️ 🤦🏻 Azure SDK untuk .NET: Kisah Pencari Bug yang Sulit 🐦 😃 🙃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ketika kami memutuskan untuk mencari kesalahan dalam Azure SDK untuk proyek .NET, kami sangat terkejut dengan ukurannya. "Tiga setengah juta baris kod...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Azure SDK untuk .NET: Kisah Pencari Bug yang Sulit</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/478980/"><p><img src="https://habrastorage.org/getpro/habr/post_images/1d1/893/6e4/1d18936e4455beb69c69b410bbfd10f6.png" alt="Gambar 2" align="left"></p>  Ketika kami memutuskan untuk mencari kesalahan dalam Azure SDK untuk proyek .NET, kami sangat terkejut dengan ukurannya.  "Tiga setengah juta baris kode," kata kami, mempelajari statistik proyek.  Ini adalah berapa banyak yang dapat Anda temukan di sana.  Tapi sayang sekali, ah.  Proyek itu ternyata rahasia.  Apa kekhasan proyek dan bagaimana pengujiannya - baca di artikel ini. <br><a name="habracut"></a><br><h2>  Tentang proyek </h2><br>  Saya menulis artikel ini sebagai tindak lanjut dari artikel saya sebelumnya, yang juga tentang proyek yang berkaitan dengan Microsoft Azure: <a href="https://www.viva64.com/ru/b/0678/">Azure PowerShell: "pada dasarnya tidak berbahaya</a> . <a href="https://www.viva64.com/ru/b/0678/">"</a>  Jadi, kali ini saya mengandalkan sejumlah kesalahan yang beragam dan menarik.  Memang, untuk analisis statis, ukuran proyek biasanya penting, terutama dengan pemeriksaan satu kali seluruh proyek.  Ya, dalam praktiknya mereka biasanya tidak melakukan itu.  Dan jika mereka melakukannya, maka hanya pada tahap implementasi alat analisa.  Pada saat yang sama, tidak ada yang segera memahami sejumlah besar operasi (sejumlah besar peringatan adalah norma ketika penganalisa dimulai dalam mode ini), tetapi hanya menempatkan mereka ke dalam utang teknis menggunakan mekanisme penindasan pesan dan penyimpanannya dalam database khusus (penindasan massal).  Kami terlibat dalam inspeksi satu kali untuk tujuan penelitian.  Oleh karena itu, proyek besar untuk studi selalu lebih disukai daripada yang kecil. <br><br>  Namun, Azure SDK untuk proyek .NET segera menunjukkan kegagalannya sebagai bangku tes.  Bahkan ukurannya yang mengesankan tidak membantu, tetapi malah mempersulit pekerjaan.  Alasannya ditunjukkan dalam statistik proyek berikut: <br><br><ul><li>  File Sumber .cs (tidak termasuk tes): 16.500 </li><li>  Solusi Visual Studio (.sln): 163 </li><li>  Baris kode yang tidak kosong: 3.462.000 </li><li>  Dari yang dihasilkan secara otomatis: sekitar 3,3 juta </li><li>  Repositori proyek tersedia di <a href="https://github.com/Azure/azure-sdk-for-net">GitHub</a> . </li></ul><br>  Sekitar 95% kode dihasilkan secara otomatis, bagian penting dari kode ini diulang berkali-kali.  Memeriksa proyek-proyek semacam itu dengan analisa statis biasanya memakan waktu dan tidak berguna, karena ada banyak pekerjaan, tetapi tidak logis (sekilas pandang) dan kode berlebihan.  Ini mengarah ke sejumlah besar positif palsu. <br><br>  Sejumlah besar solusi Visual Studio (163) bertindak sebagai ceri pada kue, yang menurutnya kumpulan kode ini “tersebar.  Jadi untuk memeriksa kode yang tersisa (bukan yang dihasilkan secara otomatis) saya harus melakukan beberapa upaya.  Ini membantu bahwa semua kode yang dihasilkan secara otomatis terletak di subfolder solusi di sepanjang jalur relatif "&lt;folder Solusi&gt; \ src \ Generated".  Selain itu, setiap file .cs dari kode tersebut berisi komentar khusus dalam <i>tag &lt;auto-generated&gt;</i> : <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// &lt;auto-generated&gt; // Copyright (c) Microsoft Corporation. All rights reserved. // Licensed under the MIT License. See License.txt in the project root for // license information. // // Code generated by Microsoft (R) AutoRest Code Generator. // Changes may cause incorrect behavior and will be lost if the code is // regenerated. // &lt;/auto-generated&gt;</span></span></code> </pre> <br>  Untuk kemurnian percobaan, saya secara acak memeriksa sekitar sepuluh solusi yang dipilih secara acak dengan kode yang dibuat secara otomatis.  Hasilnya akan lebih rendah. <br><br>  Jadi, meskipun ada sedikit kode “jujur” yang tersisa, saya masih berhasil menemukan sejumlah kesalahan di sana.  Kali ini saya tidak akan memberikan perjalanan dalam urutan jumlah diagnosa PVS-Studio.  Sebagai gantinya, saya akan mengelompokkan respons berdasarkan solusi yang terdeteksi. <br><br>  Mari kita lihat apa yang saya temukan di Azure SDK untuk kode .NET. <br><br><h2>  Microsoft.Azure.Management.Advisor </h2><br>  Ini hanyalah salah satu dari banyak solusi yang berisi kode yang dibuat secara otomatis.  Seperti yang saya katakan di atas, sekitar selusin solusi semacam itu diuji secara selektif.  Dan di mana-mana pesannya sama dan, seperti yang diharapkan, tidak berguna.  Izinkan saya memberi Anda beberapa contoh tanggapan semacam itu. <br><br>  Ekspresi <a href="https://www.viva64.com/ru/w/v3022/">V3022</a> 'Kredensial! = Null' selalu benar.  AdvisorManagementClient.cs 204 <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Code generated by Microsoft (R) AutoRest Code Generator. .... public ServiceClientCredentials Credentials { get; private set; } .... public AdvisorManagementClient(ServiceClientCredentials credentials, params DelegatingHandler[] handlers) : this(handlers) { if (credentials == null) { throw new System.ArgumentNullException("credentials"); } Credentials = credentials; if (Credentials != null) // &lt;= { Credentials.InitializeServiceClient(this); } }</span></span></code> </pre> <br>  Jelas, kodenya berlebihan, dan memeriksa <i>Kredensial! = Null tidak</i> berguna.  Tetapi kodenya bekerja.  Dan dibuat otomatis.  Oleh karena itu - tidak ada keluhan. <br><br>  Ekspresi <a href="https://www.viva64.com/ru/w/v3022/">V3022</a> '_queryParameters.Count&gt; 0' selalu salah.  ConfigurationsOperations.cs 871 <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Code generated by Microsoft (R) AutoRest Code Generator. .... public async Task&lt;AzureOperationResponse&lt;IPage&lt;ConfigData&gt;&gt;&gt; ListBySubscriptionNextWithHttpMessagesAsync(....) { .... List&lt;string&gt; _queryParameters = new List&lt;string&gt;(); if (_queryParameters.Count &gt; 0) { .... } .... }</span></span></code> </pre> <br>  Dan lagi-lagi, desain logika yang tampaknya tanpa.  Untuk beberapa alasan, mereka memeriksa ukuran daftar <i>kosong yang</i> baru saja dibuat.  Bahkan - semuanya beres.  Pemeriksaan ini tidak ada gunanya sekarang, tetapi jika generator mengatur pembuatan daftar, misalnya, berdasarkan koleksi lain, maka pemeriksaan sudah masuk akal.  Jadi - lagi, tidak ada keluhan terhadap kode, mengingat asalnya, tentu saja. <br><br>  Untuk setiap solusi dengan kode yang dibuat secara otomatis, ratusan peringatan serupa diterima.  Mengingat kesia-siaan mereka, saya pikir tidak ada gunanya diskusi lebih lanjut tentang hal-hal positif semacam itu.  Hanya kesalahan nyata dalam kode "normal" yang akan dipertimbangkan di bawah ini. <br><br><h2>  Azure. Skor </h2><br>  <a href="https://www.viva64.com/ru/w/v3001/">V3001</a> Ada sub-ekspresi identik 'buffer.Length' ke kiri dan ke kanan operator '&lt;'.  AzureBaseBuffersExtensions.cs 30 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...., ReadOnlyMemory&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; buffer, ....</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]? array = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || buffer.Length &lt; buffer.Length) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { if (array != null) ArrayPool&lt;byte&gt;.Shared.Return(array); array = ArrayPool&lt;byte&gt;.Shared.Rent(buffer.Length); } if (!buffer.TryCopyTo(array)) throw new Exception("could not rent large enough buffer."); .... }</span></span></code> </pre> <br>  Kesalahan dalam kondisi itu dibuat, mungkin sebagai akibat dari copy-paste.  Dilihat oleh fakta bahwa selanjutnya dalam <i>buffer</i> kode disalin ke <i>array</i> , cek akan terlihat seperti: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || array.Length &lt; buffer.Length)</code> </pre> <br>  Tetapi, seperti yang selalu saya katakan, pembuat kode harus memperbaiki kesalahan tersebut. <br><br>  <a href="https://www.viva64.com/ru/w/v3083/">V3083</a> Doa yang tidak aman dari acara '_onChange', NullReferenceException dimungkinkan.  Pertimbangkan menugaskan acara ke variabel lokal sebelum menjalankannya.  ClientOptionsMonitor.cs 44 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action&lt;TOptions, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; _onChange; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InvokeChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_onChange != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { _onChange.Invoke(options, name); } }</code> </pre> <br>  Tidak kritis, tapi kesalahan.  Antara memeriksa acara untuk kesetaraan <i>nol</i> dan permintaannya, acara tersebut dapat berhenti berlangganan.  Kemudian variabel <i>_onChange</i> akan mendapatkan <i>nol</i> dan pengecualian akan dibuang.  Kode harus ditulis ulang dengan lebih aman.  Misalnya, seperti ini: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InvokeChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... _onChange?.Invoke(options, name); }</code> </pre> <br><h2>  Azure.Messaging.EventHubs </h2><br>  <a href="https://www.viva64.com/ru/w/v3080/">V3080</a> Kemungkinan null dereference.  Pertimbangkan untuk memeriksa 'eventPropertyValue'.  AmqpMessageConverter.cs 650 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryCreateEventPropertyForAmqpProperty</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> amqpPropertyValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eventPropertyValue</span></span></span><span class="hljs-function">)</span></span> { eventPropertyValue = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (GetTypeIdentifier(amqpPropertyValue)) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> AmqpProperty.Type.Byte: .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> AmqpProperty.Type.String: eventPropertyValue = amqpPropertyValue; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; .... } .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (amqpPropertyValue) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> AmqpSymbol symbol: eventPropertyValue = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] array: eventPropertyValue = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ArraySegment&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; segment when segment.Count == segment.Array.Length: eventPropertyValue = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ArraySegment&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; segment: .... eventPropertyValue = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">case</span></span></span><span class="hljs-function"> DescribedType described </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">when</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">described.Descriptor </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">is</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AmqpSymbol</span></span></span><span class="hljs-function">): eventPropertyValue</span></span> = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> exception = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializationException( <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(...., eventPropertyValue.GetType().FullName)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } return (eventPropertyValue != null); }</span></span></code> </pre> <br>  Mari kita lacak apa yang terjadi pada nilai variabel <i>eventPropertyValue</i> dalam cuplikan kode di atas.  Pada awal metode, variabelnya <i>nol</i> .  Selanjutnya, dalam salah satu kondisi <i>sakelar</i> pertama, variabel diinisialisasi, setelah itu metode keluar.  Blok kedua <i>saklar</i> berisi banyak kondisi, di mana masing-masing variabel juga menerima beberapa nilai baru.  Tetapi dalam blok <i>default</i> , variabel <i>eventPropertyValue</i> hanya digunakan tanpa verifikasi, yang merupakan kesalahan, karena saat ini variabelnya <i>nol</i> . <br><br>  <a href="https://www.viva64.com/ru/w/v3066/">V3066</a> Kemungkinan urutan argumen yang salah diteruskan ke konstruktor 'EventHubConsumer': 'partisiId' dan 'consumerGroup'.  TrackOneEventHubClient.cs 394 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> EventHubConsumer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateConsumer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventHubConsumer ( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TrackOneEventHubConsumer(....), TrackOneClient.EventHubName, partitionId, <span class="hljs-comment"><span class="hljs-comment">// &lt;= 3 consumerGroup, // &lt;= 4 eventPosition, consumerOptions, initialRetryPolicy ); }</span></span></code> </pre> <br>  Penganalisa menduga bahwa ketika memanggil konstruktor dari kelas <i>EventHubConsumer</i> , urutan argumen ketiga dan keempat tercampur aduk.  Mari kita lihat deklarasi konstruktor: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EventHubConsumer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TransportEventHubConsumer transportConsumer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eventHubName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> consumerGroup, // &lt;= </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> partitionId, // &lt;= </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EventPosition eventPosition, EventHubConsumerOptions consumerOptions, EventHubRetryPolicy retryPolicy</span></span></span><span class="hljs-function">)</span></span> { .... }</code> </pre> <br>  Argumennya benar-benar campur aduk.  Saya kira bagaimana kesalahan ini dibuat.  Kesalahannya mungkin karena format kode yang buruk.  Lihat lagi <i>deklarasi</i> konstruktor <i>EventHubConsumer</i> .  Karena fakta bahwa parameter <i>transportConsumer</i> pertama terletak pada baris yang sama dengan nama kelas, sambil melihat kode secara singkat, mungkin tampak bahwa parameter <i>partisiId</i> di tempat ketiga dan tidak di tempat keempat (tidak ada komentar saya dengan nomor seri parameter dalam kode asli) ) <br><br>  Ini hanya dugaan, tetapi saya akan mengubah format kode deklarasi konstruktor menjadi ini: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EventHubConsumer</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> TransportEventHubConsumer transportConsumer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eventHubName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> consumerGroup, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> partitionId, EventPosition eventPosition, EventHubConsumerOptions consumerOptions, EventHubRetryPolicy retryPolicy</span></span></span><span class="hljs-function">)</span></span> { .... }</code> </pre> <br><h2>  Azure. Penyimpanan </h2><br>  <a href="https://www.viva64.com/ru/w/v3112/">V3112</a> Kelainan dalam perbandingan serupa.  Mungkin salah ketik ada di dalam ekspresi 'ContentLanguage == other.ContentEncoding'.  BlobSasBuilder.cs 410 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> BlobSasBuilder : IEquatable&lt;BlobSasBuilder&gt; { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BlobSasBuilder other</span></span></span><span class="hljs-function">)</span></span> =&gt; BlobName == other.BlobName &amp;&amp; CacheControl == other.CacheControl &amp;&amp; BlobContainerName == other.BlobContainerName &amp;&amp; ContentDisposition == other.ContentDisposition &amp;&amp; ContentEncoding == other.ContentEncoding &amp;&amp; <span class="hljs-comment"><span class="hljs-comment">// &lt;= ContentLanguage == other.ContentEncoding &amp;&amp; // &lt;= ContentType == other.ContentType &amp;&amp; ExpiryTime == other.ExpiryTime &amp;&amp; Identifier == other.Identifier &amp;&amp; IPRange == other.IPRange &amp;&amp; Permissions == other.Permissions &amp;&amp; Protocol == other.Protocol &amp;&amp; StartTime == other.StartTime &amp;&amp; Version == other.Version; }</span></span></code> </pre> <br>  Sebuah kesalahan yang dilakukan karena kurangnya perhatian.  Menemukan kesalahan serupa dengan ulasan kode cukup sulit.  Opsi centang yang benar: <br><br><pre> <code class="cs hljs"> .... ContentEncoding == other.ContentEncoding &amp;&amp; ContentLanguage == other.ContentLanguage &amp;&amp; ....</code> </pre> <br>  <a href="https://www.viva64.com/ru/w/v3112/">V3112</a> Kelainan dalam perbandingan serupa.  Mungkin salah ketik ada di dalam ekspresi 'ContentLanguage == other.ContentEncoding'.  FileSasBuilder.cs 265 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> FileSasBuilder : IEquatable&lt;FileSasBuilder&gt; { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">FileSasBuilder other</span></span></span><span class="hljs-function">)</span></span> =&gt; CacheControl == other.CacheControl &amp;&amp; ContentDisposition == other.ContentDisposition &amp;&amp; ContentEncoding == other.ContentEncoding <span class="hljs-comment"><span class="hljs-comment">// &lt;= &amp;&amp; ContentLanguage == other.ContentEncoding // &lt;= &amp;&amp; ContentType == other.ContentType &amp;&amp; ExpiryTime == other.ExpiryTime &amp;&amp; FilePath == other.FilePath &amp;&amp; Identifier == other.Identifier &amp;&amp; IPRange == other.IPRange &amp;&amp; Permissions == other.Permissions &amp;&amp; Protocol == other.Protocol &amp;&amp; ShareName == other.ShareName &amp;&amp; StartTime == other.StartTime &amp;&amp; Version == other.Version ;</span></span></code> </pre> <br>  Kesalahan yang persis sama dalam bagian kode yang sangat mirip.  Kode mungkin disalin dan dimodifikasi sebagian.  Namun kesalahan tetap ada. <br><br><h2>  Microsoft.Azure.Batch </h2><br>  <a href="https://www.viva64.com/ru/w/v3053/">V3053</a> Ekspresi yang berlebihan.  Periksa substring 'IList' dan 'List'.  PropertyData.cs 157 <br><br>  <a href="https://www.viva64.com/ru/w/v3053/">V3053</a> Ekspresi yang berlebihan.  Periksa substring 'Daftar' dan 'IReadOnlyList'.  PropertyData.cs 158 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PropertyData</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsTypeCollection =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Type.Contains(<span class="hljs-string"><span class="hljs-string">"IList"</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Type.Contains(<span class="hljs-string"><span class="hljs-string">"IEnumerable"</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Type.Contains(<span class="hljs-string"><span class="hljs-string">"List"</span></span>) || <span class="hljs-comment"><span class="hljs-comment">// &lt;= this.Type.Contains("IReadOnlyList"); // &lt;= }</span></span></code> </pre> <br>  Penganalisa mengeluarkan dua peringatan tentang cek tidak masuk akal atau salah.  Dalam kasus pertama, pencarian untuk substring "Daftar" setelah mencari "IList" terlihat berlebihan.  Memang kondisinya: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Type.Contains(<span class="hljs-string"><span class="hljs-string">"IList"</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Type.Contains(<span class="hljs-string"><span class="hljs-string">"List"</span></span>)</code> </pre> <br>  dapat diganti dengan ini: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Type.Contains(<span class="hljs-string"><span class="hljs-string">"List"</span></span>)</code> </pre> <br>  Dalam kasus kedua, pencarian untuk substring "IReadOnlyList" tidak ada artinya, karena sebelumnya pencarian untuk substring "List" yang lebih pendek dilakukan. <br><br>  Ada juga kemungkinan bahwa substring sendiri untuk pencarian membuat kesalahan dan harus ada sesuatu yang lain.  Dalam kasus apa pun, versi yang benar dari koreksi kondisi, dengan mempertimbangkan kedua pernyataan, hanya dapat ditawarkan oleh pembuat kode. <br><br>  <a href="https://www.viva64.com/ru/w/v3095/">V3095 Objek</a> 'httpRequest.Content.Headers' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 76, 79. BatchSharedKeyCredential.cs 76 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessHttpRequestAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HttpRequestMessage httpRequest, ....</span></span></span><span class="hljs-function">)</span></span> { .... signature.Append(httpRequest.Content != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; httpRequest.Content.Headers.Contains(<span class="hljs-string"><span class="hljs-string">"Content-Language"</span></span>) ? .... : ....; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>? contentLength = httpRequest.Content?.Headers?.ContentLength; .... }</code> </pre> <br>  Pada awalnya, variabel <i>httpRequest.Content.Headers</i> digunakan tanpa pemeriksaan, tetapi kemudian dalam kode variabel ini diakses menggunakan operator akses bersyarat. <br><br>  <a href="https://www.viva64.com/ru/w/v3125/">V3125 Objek</a> 'omPropertyData' digunakan setelah diverifikasi terhadap null.  Periksa baris: 156, 148. CodeGenerationUtilities.cs 156 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetProtocolCollectionToObjectModelCollectionString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> ...., PropertyData omPropertyData, ....</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsMappedEnumPair(omPropertyData?.GenericTypeParameter, ....)) { .... } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsTypeComplex(omPropertyData.GenericTypeParameter)) .... }</code> </pre> <br>  Situasi sebaliknya.  Satu blok kode berisi opsi akses aman ke tautan <i>omPropertyData yang</i> berpotensi nol.  Lebih lanjut dalam kode dengan tautan yang sama mereka bekerja tanpa pemeriksaan. <br><br>  <a href="https://www.viva64.com/ru/w/v3146/">V3146</a> Kemungkinan nol dereferensi 'nilai'.  'FirstOrDefault' dapat mengembalikan nilai nol default.  BatchSharedKeyCredential.cs 127 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessHttpRequestAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpRequestMessage httpRequest, ....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> canonicalHeader <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> customHeaders) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = httpRequest.Headers. GetValues(canonicalHeader).FirstOrDefault(); <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Replace(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).Replace(<span class="hljs-string"><span class="hljs-string">'\r'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).TrimStart(); .... } .... }</code> </pre> <br>  Sebagai hasil dari metode <i>FirstOrDefault</i> , jika pencarian gagal, nilai default untuk tipe <i>string</i> akan dikembalikan, yaitu <i>nol</i> .  Nilai akan ditetapkan ke variabel <i>nilai</i> , yang digunakan kemudian dalam kode dengan metode <i>Ganti</i> tanpa pemeriksaan apa pun.  Kode harus dibuat lebih aman.  Misalnya, seperti ini: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> canonicalHeader <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> customHeaders) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = httpRequest.Headers. GetValues(canonicalHeader).FirstOrDefault(); <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>?.Replace(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).Replace(<span class="hljs-string"><span class="hljs-string">'\r'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).TrimStart(); .... }</code> </pre> <br><h2>  Microsoft.Azure.ServiceBus </h2><br>  <a href="https://www.viva64.com/ru/w/v3121/">V3121 Enumerasi</a> 'BlocksUsing' dideklarasikan dengan atribut 'Flags', tetapi tidak mengatur inisialisasi apa pun untuk mengesampingkan nilai default.  Fx.cs 69 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Fx</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Tag</span></span> { .... [Flags] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> BlocksUsing { MonitorEnter, MonitorWait, ManualResetEvent, AutoResetEvent, AsyncResult, IAsyncResult, PInvoke, InputQueue, ThreadNeutralSemaphore, PrivatePrimitive, OtherInternalPrimitive, OtherFrameworkPrimitive, OtherInterop, Other, NonBlocking, } .... } .... }</code> </pre> <br>  Pencacahan dideklarasikan dengan atribut <i>Flags</i> .  Dalam hal ini, nilai-nilai konstan dibiarkan secara default ( <i>MonitorEnter = 0</i> , <i>MonitorWait = 1</i> , <i>ManualResetEvent = 2,</i> dan seterusnya).  Ini dapat mengarah pada fakta bahwa ketika Anda mencoba menggunakan <i>kombinasi</i> flag, misalnya, konstanta kedua dan ketiga <i>MonitorWait (= 1)</i> |  <i>ManualResetEvent (= 2)</i> , bukan nilai unik yang akan diterima, tetapi sebuah konstanta dengan nilai 3 secara default ( <i>AutoResetEvent</i> ).  Ini mungkin mengejutkan bagi kode panggilan.  Jika enumerasi <i>BlocksUsing</i> benar <i>-</i> benar direncanakan untuk digunakan untuk menentukan kombinasi flag (bidang bit), maka Anda harus memberikan nilai konstanta yang sama dengan kekuatan dua: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Flags</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> BlocksUsing { MonitorEnter = <span class="hljs-number"><span class="hljs-number">1</span></span>, MonitorWait = <span class="hljs-number"><span class="hljs-number">2</span></span>, ManualResetEvent = <span class="hljs-number"><span class="hljs-number">4</span></span>, AutoResetEvent = <span class="hljs-number"><span class="hljs-number">8</span></span>, AsyncResult = <span class="hljs-number"><span class="hljs-number">16</span></span>, IAsyncResult = <span class="hljs-number"><span class="hljs-number">32</span></span>, PInvoke = <span class="hljs-number"><span class="hljs-number">64</span></span>, InputQueue = <span class="hljs-number"><span class="hljs-number">128</span></span>, ThreadNeutralSemaphore = <span class="hljs-number"><span class="hljs-number">256</span></span>, PrivatePrimitive = <span class="hljs-number"><span class="hljs-number">512</span></span>, OtherInternalPrimitive = <span class="hljs-number"><span class="hljs-number">1024</span></span>, OtherFrameworkPrimitive = <span class="hljs-number"><span class="hljs-number">2048</span></span>, OtherInterop = <span class="hljs-number"><span class="hljs-number">4096</span></span>, Other = <span class="hljs-number"><span class="hljs-number">8192</span></span>, NonBlocking = <span class="hljs-number"><span class="hljs-number">16384</span></span>, }</code> </pre> <br>  <a href="https://www.viva64.com/ru/w/v3125/">V3125 Objek</a> 'sesi' digunakan setelah diverifikasi terhadap nol.  Periksa baris: 69, 68. AmqpLinkCreator.cs 69 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> Task&lt;Tuple&lt;AmqpObject, DateTime&gt;&gt; CreateAndOpenAmqpLinkAsync() { .... AmqpSession session = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Create Session .... } catch (Exception exception) { .... session?.Abort(); throw AmqpExceptionHelper.GetClientException(exception, null, session.GetInnerException(), amqpConnection.IsClosing()); } .... }</span></span></code> </pre> <br>  Perhatikan pekerjaan dengan variabel <i>sesi</i> di <i>blok tangkap</i> .  Metode <i>Abort dipanggil</i> dengan aman melalui pernyataan akses bersyarat.  Tapi kemudian mereka membuat panggilan tidak aman ke metode <i>GetInnerException</i> .  Dalam hal ini, alih-alih melemparkan pengecualian dari tipe yang diharapkan, <i>NullReferenceException</i> mungkin dilemparkan.  Kode perlu diperbaiki.  Metode <i>AmqpExceptionHelper.GetClientException</i> mendukung melewati nilai <i>nol</i> untuk parameter <i>innerException</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Exception </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetClientException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Exception exception, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> referenceId = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Exception innerException = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> connectionError = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { .... }</code> </pre> <br>  Oleh karena itu, cukup menggunakan operator akses bersyarat saat memanggil <i>sesi. DapatkanInnerException ()</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> Task&lt;Tuple&lt;AmqpObject, DateTime&gt;&gt; CreateAndOpenAmqpLinkAsync() { .... AmqpSession session = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Create Session .... } catch (Exception exception) { .... session?.Abort(); throw AmqpExceptionHelper.GetClientException(exception, null, session?.GetInnerException(), amqpConnection.IsClosing()); } .... }</span></span></code> </pre> <br><h2>  Kesimpulan </h2><br>  Seperti yang Anda lihat, ukuran proyek yang besar tidak selalu menjamin sejumlah besar kesalahan.  Tetapi tidak perlu rileks - Anda selalu dapat menemukan sesuatu.  Bahkan dalam proyek yang kompleks seperti Azure SDK untuk .NET.  Ya, ini membutuhkan upaya tambahan, tetapi hasilnya akan lebih menyenangkan.  Dan agar Anda tidak perlu melakukan upaya berlebihan, kami sarankan menggunakan analisis statis, dan di tempat kerja pengembang saat menulis kode baru.  Ini adalah pendekatan yang paling efektif.  <a href="https://www.viva64.com/ru/pvs-studio-download/">Unduh dan coba PVS-Studio</a> dalam aksi.  Semoga berhasil dalam perang melawan serangga! <br><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/478978/"><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a> </p><br><br>  Jika Anda ingin berbagi artikel ini dengan audiens yang berbahasa Inggris, silakan gunakan tautan ke terjemahan: Sergey Khrenov.  <a href="https://habr.com/en/company/pvs-studio/blog/478978/">Azure SDK untuk .NET: Kisah tentang Pencarian Kesalahan yang Sulit</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id478980/">https://habr.com/ru/post/id478980/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id478966/index.html">Bagaimana cara bertahan dan menjadi pengembang frontend di dunia modern?</a></li>
<li><a href="../id478968/index.html">Nanoracks dengan SpaceX akan meluncurkan demonstran untuk membuat stasiun orbit puing ruang</a></li>
<li><a href="../id478972/index.html">Pemenang Kontes Platform Miro</a></li>
<li><a href="../id478974/index.html">Modul memuat otomatis menggunakan impor dinamis</a></li>
<li><a href="../id478978/index.html">Azure SDK untuk .NET: Kisah tentang Pencarian Kesalahan yang Sulit</a></li>
<li><a href="../id478982/index.html">Seperti yang saya yakini Topeng Ilona. Dan ketika kita akan berada di bulan lagi</a></li>
<li><a href="../id478984/index.html">TimTam - pijat perkusi generasi baru dengan fungsi pemanasan tip yang unik</a></li>
<li><a href="../id478986/index.html">Yandex meluncurkan suara populer untuk game retro. Finalis Pertempuran Game Retro 2019</a></li>
<li><a href="../id478988/index.html">Venesia: untung liar di atas batu yang telanjang</a></li>
<li><a href="../id478990/index.html">Menginstal LeoFS yang didistribusikan fasilitas penyimpanan gagal-aman yang kompatibel dengan klien menggunakan S3, NFS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>