<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüî¨ üéâ üë®üèæ‚Äçü§ù‚Äçüë®üèΩ An√°lise de Vulnerabilidade no EvilParcel üë®üèø‚Äçü§ù‚Äçüë®üèæ üèä üë©üèΩ‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 
 Em meados de abril, publicamos not√≠cias sobre o Trojan Android.InfectionAds.1 , que explorava v√°rias vulnerabilidades cr√≠ticas no sist...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>An√°lise de Vulnerabilidade no EvilParcel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/drweb/blog/457558/"><h3>  1. Introdu√ß√£o </h3><br>  Em meados de abril, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">publicamos not√≠cias</a> sobre o Trojan <b>Android.InfectionAds.1</b> , que explorava v√°rias vulnerabilidades cr√≠ticas no sistema operacional Android.  Um deles - CVE-2017-13156 (tamb√©m conhecido como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Janus</a> ) - permite que um programa malicioso infecte arquivos APK sem danificar sua assinatura digital. <br><br>  O outro √© CVE-2017-13315.  Ele concede ao Trojan privil√©gios avan√ßados e pode instalar e desinstalar aplicativos de forma independente.  Uma an√°lise detalhada do <b>Android.InfectionAds.1 est√°</b> dispon√≠vel na nossa biblioteca de v√≠rus, pode ser encontrada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Vamos nos aprofundar na vulnerabilidade CVE-2017-13315 com mais detalhes e ver como √©. <br><a name="habracut"></a><br>  CVE-2017-13315 pertence ao grupo de vulnerabilidades que receberam o nome geral EvilParcel.  Eles s√£o encontrados em v√°rias classes de sistema do sistema operacional Android.  Devido a erros neste √∫ltimo ao trocar dados entre aplicativos e o sistema, torna-se poss√≠vel substituir esses dados.  Programas maliciosos que exploram as vulnerabilidades do EvilParcel recebem privil√©gios mais altos e podem fazer o seguinte com sua ajuda: <br><br><ul><li>  instalar e desinstalar aplicativos com quaisquer permiss√µes sem confirma√ß√£o do usu√°rio; </li><li>  quando usado em conjunto com outras vulnerabilidades, infectar programas instalados no dispositivo e substituir originais "limpos" por c√≥pias infectadas; </li><li>  Redefinir c√≥digo de bloqueio de tela para dispositivo Android </li><li>  Redefinir o PIN da tela de bloqueio do dispositivo Android. </li></ul><br>  Atualmente, existem 7 vulnerabilidades conhecidas desse tipo: <br><br><ul><li>  CVE-2017-0806 (erro na classe GateKeeperResponse), publicado em outubro de 2017; </li><li>  CVE-2017-13286 (erro na classe OutputConfiguration, publicada em abril de 2018; </li><li>  CVE-2017-13287 (erro na classe VerifyCredentialResponse), publicada em abril de 2018; </li><li>  CVE-2017-13288 (erro na classe PeriodicAdvertizingReport), publicada em abril de 2018; </li><li>  CVE-2017-13289 (bug na classe ParcelableRttResults), publicado em abril de 2018; </li><li>  CVE-2017-13311 (bug na classe SparseMappingTable), publicada em maio de 2018; </li><li>  CVE-2017-13315 (erro na classe DcParamObject), publicado em maio de 2018. </li></ul><br>  Todos eles amea√ßam dispositivos com vers√µes do SO Android 5.0 - 8.1 que n√£o possuem as atualiza√ß√µes de seguran√ßa de maio de 2018 e posteriores instaladas. <br><br><h3>  Pr√©-requisitos para as vulnerabilidades do EvilParcel </h3><br>  Vamos ver como surgem as vulnerabilidades do EvilParcel.  Primeiro de tudo, veremos alguns dos recursos dos aplicativos Android.  No sistema operacional Android, todos os programas interagem entre si, bem como com o pr√≥prio sistema operacional, enviando e recebendo objetos do tipo Intent.  Esses objetos podem conter um n√∫mero arbitr√°rio de pares de valores-chave dentro de um objeto do tipo Bundle. <br><br>  Ao transmitir Intent, o objeto Bundle √© convertido (serializado) em uma matriz de bytes agrupada no Parcel e, ao ler chaves e valores de um Bundle serializado, ele √© desserializado automaticamente. <br><br>  No Bundle, a string √© a chave e o valor pode ser quase qualquer coisa.  Por exemplo, um tipo primitivo, sequ√™ncia ou cont√™iner contendo tipos ou sequ√™ncias primitivas.  Al√©m disso, pode ser um objeto do tipo Parcelable. <br><br>  Assim, no Bundle, voc√™ pode colocar um objeto de qualquer tipo que implemente a interface Parcelable.  Para fazer isso, voc√™ precisar√° implementar os m√©todos writeToParcel () e createFromParcel () para serializar e desserializar o objeto. <br><br>  Como um bom exemplo, vamos criar um simples pacote serializado.  Vamos escrever um c√≥digo que coloque tr√™s pares de valores-chave no Bundle e o serialize: <br><br>  Demonstra√ß√£o do pacote = novo pacote (); <br>  demo.putString ("String", "Ol√°, Mundo!"); <br>  demo.putInt ("Inteiro", 42); <br>  demo.putByteArray ("ByteArray", novo byte [] {1, 2, 3, 4, 5, 6, 7, 8}); <br>  Parcel parcel = Parcel.obtain (); <br>  parcel.writeBundle (demo); <br><br>  Depois de executar esse c√≥digo, obtemos um pacote do seguinte formato: <br><br><img src="https://habrastorage.org/webt/53/gn/x5/53gnx5bjhjfdaqjr5isxgva6fzg.png"><br><br>  <b>Figura 1.</b> Estrutura de um objeto Bundle serializado. <br><br>  Vamos prestar aten√ß√£o aos seguintes recursos da serializa√ß√£o de pacotes: <br><br><ul><li>  todos os pares de valores-chave s√£o escritos um ap√≥s o outro; </li><li>  antes de cada valor, seu tipo √© indicado (13 para uma matriz de bytes, 1 para um n√∫mero inteiro, 0 para uma sequ√™ncia e assim por diante); </li><li>  antes dos dados de comprimento vari√°vel, seu tamanho √© indicado (comprimento para a cadeia, n√∫mero de bytes para a matriz); </li><li>  todos os valores s√£o gravados com um alinhamento de 4 bytes. </li></ul><br>  Devido ao fato de que todas as chaves e valores no Bundle s√£o gravados sequencialmente, ao acessar uma chave ou o valor de um objeto Bundle serializado, o √∫ltimo √© desserializado completamente, incluindo a inicializa√ß√£o de todos os objetos Parcelable contidos nele. <br><br>  Parece, qual poderia ser o problema?  E √© que em algumas classes de sistema que implementam Parcelable, os m√©todos createFromParcel () e writeToParcel () podem encontrar erros.  Nessas classes, o n√∫mero de bytes lidos no m√©todo createFromParcel () ser√° diferente do n√∫mero de bytes gravados no m√©todo writeToParcel ().  Se voc√™ colocar um objeto dessa classe dentro do Bundle, os limites do objeto dentro do Bundle ser√£o alterados ap√≥s a re-serializa√ß√£o.  E √© a√≠ que as condi√ß√µes para explorar a vulnerabilidade do EvilParcel s√£o criadas. <br><br>  Aqui est√° um exemplo de uma classe com um erro semelhante: <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parcelable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Demo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Demo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parcel in)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = in.readInt(); data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[length]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { in.readByteArray(data); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Creator&lt;Demo&gt; CREATOR = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Creator&lt;Demo&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Demo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createFromParcel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parcel in)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Demo(in); } }; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeToParcel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parcel parcel, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ parcel.writeInt(data.length); parcel.writeByteArray(data); } }</code> </pre> <br>  Se o tamanho da matriz de dados for 0, ao criar um objeto em createFromParcel (), um int (4 bytes) ser√° lido e dois int (8 bytes) ser√£o gravados em writeToParcel ().  O primeiro int ser√° gravado em uma chamada expl√≠cita para writeInt.  O segundo int ser√° gravado quando writeByteArray () for chamado, porque o comprimento da matriz √© sempre gravado no Parcel antes dele (veja a Figura 1). <br><br>  Situa√ß√µes em que o tamanho da matriz de dados √© 0 s√£o raras.  Mas mesmo quando isso acontece, o programa continua funcionando se apenas um objeto for transmitido em formato serializado por vez (no nosso exemplo, o objeto Demo).  Portanto, esses erros, em regra, passam despercebidos. <br><br>  Agora vamos tentar colocar um objeto Demo com um comprimento zero da matriz no Bundle: <br><br><img src="https://habrastorage.org/webt/2y/2v/i0/2y2vi0ftdkartg9i01cc-b858g0.png"><br>  <b>Figura 2.</b> O resultado da adi√ß√£o de um objeto Demo com comprimento zero da matriz ao Bundle. <br><br>  Serializamos o objeto: <br><br><img src="https://habrastorage.org/webt/hv/tw/if/hvtwifj9curkc7ip6jplbdlk-yc.png"><br>  <b>Figura 3.</b> Objeto de pacote configur√°vel ap√≥s serializa√ß√£o. <br><br>  Vamos tentar desserializar: <br><br><img src="https://habrastorage.org/webt/_u/a1/k4/_ua1k4hp34wknsvnppv8zla0jei.png"><br>  <b>Figura 4.</b> Ap√≥s desserializar o objeto Bundle. <br><br>  Qual √© o resultado?  Considere um trecho de pacote: <br><br><img src="https://habrastorage.org/webt/g0/qs/y4/g0qsy4cigykwv2gxgpizo2qsu7u.png"><br>  <b>Figura 5.</b> Estrutura do pacote ap√≥s a desserializa√ß√£o do pacote. <br><br>  Nas Figuras 4 e 5, vemos que durante a desserializa√ß√£o, um int foi lido no m√©todo createFromParcel em vez de dois escritos anteriormente.  Portanto, todos os valores subsequentes do pacote configur√°vel n√£o foram lidos corretamente.  O valor 0x0 no endere√ßo 0x60 foi lido como o comprimento da pr√≥xima chave.  E o valor 0x1 no endere√ßo 0x64 foi lido como uma chave.  Nesse caso, o valor 0x31 no endere√ßo 0x68 foi lido como o tipo de valor.  N√£o h√° valores no pacote cujo tipo √© 0x31, portanto, readFromParcel () relatou fielmente um erro (exce√ß√£o). <br><br>  Como isso pode ser usado na pr√°tica e se tornar uma vulnerabilidade?  Vamos ver!  O erro descrito acima nas classes do sistema Parcelable permite construir Bundle, que pode diferir durante a primeira e desserializa√ß√£o repetida.  Para demonstrar isso, modifique o exemplo anterior: <br><br><pre> <code class="java hljs">Parcel data = Parcel.obtain(); data.writeInt(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 3 entries data.writeString("vuln_class"); data.writeInt(4); // value is Parcelable data.writeString("com.drweb.testbundlemismatch.Demo"); data.writeInt(0); // data.length data.writeInt(1); // key length -&gt; key value data.writeInt(6); // key value -&gt; value is long data.writeInt(0xD); // value is bytearray -&gt; low(long) data.writeInt(-1); // bytearray length dummy -&gt; high(long) int startPos = data.dataPosition(); data.writeString("hidden"); // bytearray data -&gt; hidden key data.writeInt(0); // value is string data.writeString("Hi there"); // hidden value int endPos = data.dataPosition(); int triggerLen = endPos - startPos; data.setDataPosition(startPos - 4); data.writeInt(triggerLen); // overwrite dummy value with the real value data.setDataPosition(endPos); data.writeString("A padding"); data.writeInt(0); // value is string data.writeString("to match pair count"); int length = data.dataSize(); Parcel bndl = Parcel.obtain(); bndl.writeInt(length); bndl.writeInt(0x4C444E42); // bundle magic bndl.appendFrom(data, 0, length); bndl.setDataPosition(0);</span></span></code> </pre> <br>  Esse c√≥digo cria um pacote serializado que cont√©m uma classe vulner√°vel.  Vejamos o resultado da execu√ß√£o deste c√≥digo: <br><br><img src="https://habrastorage.org/webt/tc/ke/wf/tckewffnaop28wllxnrt7pagdvs.png"><br>  <b>Figura 6.</b> Criando um pacote com uma classe vulner√°vel. <br><br>  Ap√≥s a primeira desserializa√ß√£o, este pacote configur√°vel conter√° as seguintes chaves: <br><br><img src="https://habrastorage.org/webt/cj/si/l0/cjsil0--g_jsoew8ht-oxely1u4.png"><br>  <b>Figura 7.</b> Resultado da desserializa√ß√£o de um Bundle com uma classe vulner√°vel. <br><br>  Agora, serialize novamente o Bundle resultante, deserialize-o novamente e veja a lista de chaves: <br><br><img src="https://habrastorage.org/webt/uw/e1/mj/uwe1mjdtywr59oyshaah2q1gkus.png"><br>  <b>Figura 8.</b> Resultado da nova serializa√ß√£o e desserializa√ß√£o de um Bundle com uma classe vulner√°vel. <br><br>  O que n√≥s vemos?  A chave oculta (com o valor da sequ√™ncia "Ol√°!") Apareceu no pacote, que n√£o existia antes.  Considere o snippet Parcel deste pacote para entender por que isso aconteceu: <br><br><img src="https://habrastorage.org/webt/cx/za/dz/cxzadza4tugyeemlefk1lmlkdbu.png"><br>  <b>Figura 9.</b> Estrutura do pacote do objeto Bundle com a classe vulner√°vel ap√≥s dois ciclos de serializa√ß√£o-desserializa√ß√£o. <br><br>  Aqui, a ess√™ncia das vulnerabilidades do EvilParcel fica mais clara.  √â poss√≠vel criar um pacote especialmente formado que conter√° uma classe vulner√°vel.  A altera√ß√£o dos limites desta classe permitir√° que voc√™ coloque qualquer objeto neste Bundle - por exemplo, Intent, que aparecer√° no Bundle somente ap√≥s a segunda desserializa√ß√£o.  Isso tornar√° poss√≠vel ocultar o Intent dos mecanismos de prote√ß√£o do sistema operacional. <br><br><h3>  Opera√ß√£o EvilParcel </h3><br>  O Android.InfectionAds.1 usando o CVE-2017-13315 instalou e desinstalou programas sem a interven√ß√£o do propriet√°rio do dispositivo infectado.  Mas como vai isso? <br><br>  Em 2013, o erro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">7699048</a> tamb√©m foi descoberto, tamb√©m conhecido como Launch AnyWhere.  Permitia que um aplicativo de terceiros executasse atividades arbitr√°rias em nome do sistema de usu√°rio mais privilegiado.  O diagrama abaixo mostra seu mecanismo de a√ß√£o: <br><br><img src="https://habrastorage.org/webt/dg/no/n9/dgnon92txtobknvvgr5eo2cmi54.png"><br>  <b>Figura 10.</b> Esquema do erro 7699048. <br><br>  Com essa vulnerabilidade, um aplicativo de explora√ß√£o pode implementar o servi√ßo AccountAuthenticator, projetado para adicionar novas contas ao sistema operacional.  Gra√ßas ao bug 7699048, o exploit √© capaz de executar atividades para instalar, desinstalar, substituir aplicativos, redefinir o PIN ou o bloqueio de padr√£o e fazer outras coisas desagrad√°veis. <br><br>  O Google corrigiu essa lacuna proibindo o lan√ßamento de atividades arbitr√°rias do AccountManager.  Agora, o AccountManager permite apenas o lan√ßamento de atividades provenientes do mesmo aplicativo.  Para fazer isso, ele verifica e compara a assinatura digital do programa que iniciou o in√≠cio da atividade com a assinatura do aplicativo em que a atividade iniciada est√° localizada.  √â assim: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; (intent = result.getParcelable(AccountManager.KEY_INTENT)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* * The Authenticator API allows third party authenticators to * supply arbitrary intents to other apps that they can run, * this can be very bad when those apps are in the system like * the System Settings. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> authenticatorUid = Binder.getCallingUid(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> bid = Binder.clearCallingIdentity(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { PackageManager pm = mContext.getPackageManager(); ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, <span class="hljs-number"><span class="hljs-number">0</span></span>, mAccounts.userId); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetUid = resolveInfo.activityInfo.applicationInfo.uid; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PackageManager.SIGNATURE_MATCH != pm.checkSignatures(authenticatorUid, targetUid)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecurityException( <span class="hljs-string"><span class="hljs-string">"Activity to be started with KEY_INTENT must "</span></span> + <span class="hljs-string"><span class="hljs-string">"share Authenticator's signatures"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { Binder.restoreCallingIdentity(bid); } }</code> </pre><br>  Parece que o problema foi resolvido, mas nem tudo aqui √© t√£o bom.  Aconteceu que essa corre√ß√£o pode ser contornada usando a vulnerabilidade conhecida EvilParcel CVE-2017-13315!  Como j√° sabemos, ap√≥s corrigir o Launch AnyWhere, o sistema verifica a assinatura digital do aplicativo.  Se essa verifica√ß√£o for bem-sucedida, o Bundle ser√° passado para IAccountManagerResponse.onResult ().  Ao mesmo tempo, onResult () √© chamado pelo mecanismo IPC, para que o Bundle seja serializado novamente.  Na implementa√ß√£o onResult (), acontece o seguinte: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** Handles the responses from the AccountManager */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IAccountManagerResponse</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stub</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle bundle)</span></span></span><span class="hljs-function"> </span></span>{ Intent intent = bundle.getParcelable(KEY_INTENT); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intent != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; mActivity != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// since the user provided an Activity we will silently start intents // that we see mActivity.startActivity(intent); // leave the Future running to wait for the real response to this request } //&lt;.....&gt; } //&lt;.....&gt; }</span></span></code> </pre><br>  Em seguida, o Bundle √© extra√≠do da chave de inten√ß√£o e a atividade √© iniciada sem verifica√ß√µes.  Como resultado, para iniciar uma atividade arbitr√°ria com direitos do sistema, basta construir o Bundle de forma que o campo de inten√ß√£o fique oculto na primeira desserializa√ß√£o e apare√ßa na segunda desserializa√ß√£o.  E, como j√° vimos, √© precisamente essa tarefa que as vulnerabilidades do EvilParcel cumprem. <br><br>  No momento, todas as vulnerabilidades conhecidas desse tipo s√£o corrigidas por corre√ß√µes nas pr√≥prias classes Parcelable vulner√°veis.  No entanto, o reaparecimento de classes vulner√°veis ‚Äã‚Äãno futuro n√£o pode ser descartado.  A implementa√ß√£o do Bundle e o mecanismo para adicionar novas contas ainda s√£o os mesmos de antes.  Eles ainda permitem que voc√™ crie exatamente a mesma explora√ß√£o ao descobrir (ou novas) classes Parcelable vulner√°veis.  Al√©m disso, a implementa√ß√£o dessas classes ainda √© feita manualmente, e o programador deve ficar de olho no comprimento constante do objeto Parcelable serializado.  E este √© um fator humano com todas as consequ√™ncias.  No entanto, esperamos que esses erros sejam o m√≠nimo poss√≠vel e as vulnerabilidades do EvilParcel n√£o incomodem os usu√°rios de dispositivos Android. <br><br>  Voc√™ pode verificar se h√° vulnerabilidades no EvilParcel no seu dispositivo m√≥vel usando nosso antiv√≠rus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dr.Web Security Space</a> .  O ‚ÄúAuditor de Seguran√ßa‚Äù interno relatar√° os problemas identificados e dar√° recomenda√ß√µes para resolv√™-los. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt457558/">https://habr.com/ru/post/pt457558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt457542/index.html">Hackear e proteger unidades de criptografia LUKS</a></li>
<li><a href="../pt457546/index.html">Dia da demonstra√ß√£o: por que tudo isso e como fazer? UPD + Broadcast</a></li>
<li><a href="../pt457548/index.html">Gera√ß√£o de sinal PWM multif√°sico no TMS320F28027</a></li>
<li><a href="../pt457550/index.html">Do que a ind√∫stria digital precisa ser protegida</a></li>
<li><a href="../pt457552/index.html">Alpinistas em Zafasadia. Como funcionam os promalps na torre do Lakhta Center</a></li>
<li><a href="../pt457560/index.html">A√ß√µes Tokenizadas: Como se Tornar um Investidor da Gett Antes de Fazer um IPO</a></li>
<li><a href="../pt457562/index.html">Ivideon Counter 3D: quem, como e por que contar visitantes</a></li>
<li><a href="../pt457564/index.html">Estimando o custo dos sistemas de TI de uma empresa</a></li>
<li><a href="../pt457566/index.html">A press√£o est√° boa: Por que o data center precisa de controle da press√£o do ar?</a></li>
<li><a href="../pt457568/index.html">Congresso Futurol√≥gico: uma sele√ß√£o de relatos dos evangelistas do futuro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>