<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🔬 🎉 👨🏾‍🤝‍👨🏽 Análise de Vulnerabilidade no EvilParcel 👨🏿‍🤝‍👨🏾 🏊 👩🏽‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdução 
 Em meados de abril, publicamos notícias sobre o Trojan Android.InfectionAds.1 , que explorava várias vulnerabilidades críticas no sist...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Análise de Vulnerabilidade no EvilParcel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/drweb/blog/457558/"><h3>  1. Introdução </h3><br>  Em meados de abril, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">publicamos notícias</a> sobre o Trojan <b>Android.InfectionAds.1</b> , que explorava várias vulnerabilidades críticas no sistema operacional Android.  Um deles - CVE-2017-13156 (também conhecido como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Janus</a> ) - permite que um programa malicioso infecte arquivos APK sem danificar sua assinatura digital. <br><br>  O outro é CVE-2017-13315.  Ele concede ao Trojan privilégios avançados e pode instalar e desinstalar aplicativos de forma independente.  Uma análise detalhada do <b>Android.InfectionAds.1 está</b> disponível na nossa biblioteca de vírus, pode ser encontrada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Vamos nos aprofundar na vulnerabilidade CVE-2017-13315 com mais detalhes e ver como é. <br><a name="habracut"></a><br>  CVE-2017-13315 pertence ao grupo de vulnerabilidades que receberam o nome geral EvilParcel.  Eles são encontrados em várias classes de sistema do sistema operacional Android.  Devido a erros neste último ao trocar dados entre aplicativos e o sistema, torna-se possível substituir esses dados.  Programas maliciosos que exploram as vulnerabilidades do EvilParcel recebem privilégios mais altos e podem fazer o seguinte com sua ajuda: <br><br><ul><li>  instalar e desinstalar aplicativos com quaisquer permissões sem confirmação do usuário; </li><li>  quando usado em conjunto com outras vulnerabilidades, infectar programas instalados no dispositivo e substituir originais "limpos" por cópias infectadas; </li><li>  Redefinir código de bloqueio de tela para dispositivo Android </li><li>  Redefinir o PIN da tela de bloqueio do dispositivo Android. </li></ul><br>  Atualmente, existem 7 vulnerabilidades conhecidas desse tipo: <br><br><ul><li>  CVE-2017-0806 (erro na classe GateKeeperResponse), publicado em outubro de 2017; </li><li>  CVE-2017-13286 (erro na classe OutputConfiguration, publicada em abril de 2018; </li><li>  CVE-2017-13287 (erro na classe VerifyCredentialResponse), publicada em abril de 2018; </li><li>  CVE-2017-13288 (erro na classe PeriodicAdvertizingReport), publicada em abril de 2018; </li><li>  CVE-2017-13289 (bug na classe ParcelableRttResults), publicado em abril de 2018; </li><li>  CVE-2017-13311 (bug na classe SparseMappingTable), publicada em maio de 2018; </li><li>  CVE-2017-13315 (erro na classe DcParamObject), publicado em maio de 2018. </li></ul><br>  Todos eles ameaçam dispositivos com versões do SO Android 5.0 - 8.1 que não possuem as atualizações de segurança de maio de 2018 e posteriores instaladas. <br><br><h3>  Pré-requisitos para as vulnerabilidades do EvilParcel </h3><br>  Vamos ver como surgem as vulnerabilidades do EvilParcel.  Primeiro de tudo, veremos alguns dos recursos dos aplicativos Android.  No sistema operacional Android, todos os programas interagem entre si, bem como com o próprio sistema operacional, enviando e recebendo objetos do tipo Intent.  Esses objetos podem conter um número arbitrário de pares de valores-chave dentro de um objeto do tipo Bundle. <br><br>  Ao transmitir Intent, o objeto Bundle é convertido (serializado) em uma matriz de bytes agrupada no Parcel e, ao ler chaves e valores de um Bundle serializado, ele é desserializado automaticamente. <br><br>  No Bundle, a string é a chave e o valor pode ser quase qualquer coisa.  Por exemplo, um tipo primitivo, sequência ou contêiner contendo tipos ou sequências primitivas.  Além disso, pode ser um objeto do tipo Parcelable. <br><br>  Assim, no Bundle, você pode colocar um objeto de qualquer tipo que implemente a interface Parcelable.  Para fazer isso, você precisará implementar os métodos writeToParcel () e createFromParcel () para serializar e desserializar o objeto. <br><br>  Como um bom exemplo, vamos criar um simples pacote serializado.  Vamos escrever um código que coloque três pares de valores-chave no Bundle e o serialize: <br><br>  Demonstração do pacote = novo pacote (); <br>  demo.putString ("String", "Olá, Mundo!"); <br>  demo.putInt ("Inteiro", 42); <br>  demo.putByteArray ("ByteArray", novo byte [] {1, 2, 3, 4, 5, 6, 7, 8}); <br>  Parcel parcel = Parcel.obtain (); <br>  parcel.writeBundle (demo); <br><br>  Depois de executar esse código, obtemos um pacote do seguinte formato: <br><br><img src="https://habrastorage.org/webt/53/gn/x5/53gnx5bjhjfdaqjr5isxgva6fzg.png"><br><br>  <b>Figura 1.</b> Estrutura de um objeto Bundle serializado. <br><br>  Vamos prestar atenção aos seguintes recursos da serialização de pacotes: <br><br><ul><li>  todos os pares de valores-chave são escritos um após o outro; </li><li>  antes de cada valor, seu tipo é indicado (13 para uma matriz de bytes, 1 para um número inteiro, 0 para uma sequência e assim por diante); </li><li>  antes dos dados de comprimento variável, seu tamanho é indicado (comprimento para a cadeia, número de bytes para a matriz); </li><li>  todos os valores são gravados com um alinhamento de 4 bytes. </li></ul><br>  Devido ao fato de que todas as chaves e valores no Bundle são gravados sequencialmente, ao acessar uma chave ou o valor de um objeto Bundle serializado, o último é desserializado completamente, incluindo a inicialização de todos os objetos Parcelable contidos nele. <br><br>  Parece, qual poderia ser o problema?  E é que em algumas classes de sistema que implementam Parcelable, os métodos createFromParcel () e writeToParcel () podem encontrar erros.  Nessas classes, o número de bytes lidos no método createFromParcel () será diferente do número de bytes gravados no método writeToParcel ().  Se você colocar um objeto dessa classe dentro do Bundle, os limites do objeto dentro do Bundle serão alterados após a re-serialização.  E é aí que as condições para explorar a vulnerabilidade do EvilParcel são criadas. <br><br>  Aqui está um exemplo de uma classe com um erro semelhante: <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parcelable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Demo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Demo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parcel in)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = in.readInt(); data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[length]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { in.readByteArray(data); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Creator&lt;Demo&gt; CREATOR = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Creator&lt;Demo&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Demo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createFromParcel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parcel in)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Demo(in); } }; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeToParcel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parcel parcel, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ parcel.writeInt(data.length); parcel.writeByteArray(data); } }</code> </pre> <br>  Se o tamanho da matriz de dados for 0, ao criar um objeto em createFromParcel (), um int (4 bytes) será lido e dois int (8 bytes) serão gravados em writeToParcel ().  O primeiro int será gravado em uma chamada explícita para writeInt.  O segundo int será gravado quando writeByteArray () for chamado, porque o comprimento da matriz é sempre gravado no Parcel antes dele (veja a Figura 1). <br><br>  Situações em que o tamanho da matriz de dados é 0 são raras.  Mas mesmo quando isso acontece, o programa continua funcionando se apenas um objeto for transmitido em formato serializado por vez (no nosso exemplo, o objeto Demo).  Portanto, esses erros, em regra, passam despercebidos. <br><br>  Agora vamos tentar colocar um objeto Demo com um comprimento zero da matriz no Bundle: <br><br><img src="https://habrastorage.org/webt/2y/2v/i0/2y2vi0ftdkartg9i01cc-b858g0.png"><br>  <b>Figura 2.</b> O resultado da adição de um objeto Demo com comprimento zero da matriz ao Bundle. <br><br>  Serializamos o objeto: <br><br><img src="https://habrastorage.org/webt/hv/tw/if/hvtwifj9curkc7ip6jplbdlk-yc.png"><br>  <b>Figura 3.</b> Objeto de pacote configurável após serialização. <br><br>  Vamos tentar desserializar: <br><br><img src="https://habrastorage.org/webt/_u/a1/k4/_ua1k4hp34wknsvnppv8zla0jei.png"><br>  <b>Figura 4.</b> Após desserializar o objeto Bundle. <br><br>  Qual é o resultado?  Considere um trecho de pacote: <br><br><img src="https://habrastorage.org/webt/g0/qs/y4/g0qsy4cigykwv2gxgpizo2qsu7u.png"><br>  <b>Figura 5.</b> Estrutura do pacote após a desserialização do pacote. <br><br>  Nas Figuras 4 e 5, vemos que durante a desserialização, um int foi lido no método createFromParcel em vez de dois escritos anteriormente.  Portanto, todos os valores subsequentes do pacote configurável não foram lidos corretamente.  O valor 0x0 no endereço 0x60 foi lido como o comprimento da próxima chave.  E o valor 0x1 no endereço 0x64 foi lido como uma chave.  Nesse caso, o valor 0x31 no endereço 0x68 foi lido como o tipo de valor.  Não há valores no pacote cujo tipo é 0x31, portanto, readFromParcel () relatou fielmente um erro (exceção). <br><br>  Como isso pode ser usado na prática e se tornar uma vulnerabilidade?  Vamos ver!  O erro descrito acima nas classes do sistema Parcelable permite construir Bundle, que pode diferir durante a primeira e desserialização repetida.  Para demonstrar isso, modifique o exemplo anterior: <br><br><pre> <code class="java hljs">Parcel data = Parcel.obtain(); data.writeInt(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 3 entries data.writeString("vuln_class"); data.writeInt(4); // value is Parcelable data.writeString("com.drweb.testbundlemismatch.Demo"); data.writeInt(0); // data.length data.writeInt(1); // key length -&gt; key value data.writeInt(6); // key value -&gt; value is long data.writeInt(0xD); // value is bytearray -&gt; low(long) data.writeInt(-1); // bytearray length dummy -&gt; high(long) int startPos = data.dataPosition(); data.writeString("hidden"); // bytearray data -&gt; hidden key data.writeInt(0); // value is string data.writeString("Hi there"); // hidden value int endPos = data.dataPosition(); int triggerLen = endPos - startPos; data.setDataPosition(startPos - 4); data.writeInt(triggerLen); // overwrite dummy value with the real value data.setDataPosition(endPos); data.writeString("A padding"); data.writeInt(0); // value is string data.writeString("to match pair count"); int length = data.dataSize(); Parcel bndl = Parcel.obtain(); bndl.writeInt(length); bndl.writeInt(0x4C444E42); // bundle magic bndl.appendFrom(data, 0, length); bndl.setDataPosition(0);</span></span></code> </pre> <br>  Esse código cria um pacote serializado que contém uma classe vulnerável.  Vejamos o resultado da execução deste código: <br><br><img src="https://habrastorage.org/webt/tc/ke/wf/tckewffnaop28wllxnrt7pagdvs.png"><br>  <b>Figura 6.</b> Criando um pacote com uma classe vulnerável. <br><br>  Após a primeira desserialização, este pacote configurável conterá as seguintes chaves: <br><br><img src="https://habrastorage.org/webt/cj/si/l0/cjsil0--g_jsoew8ht-oxely1u4.png"><br>  <b>Figura 7.</b> Resultado da desserialização de um Bundle com uma classe vulnerável. <br><br>  Agora, serialize novamente o Bundle resultante, deserialize-o novamente e veja a lista de chaves: <br><br><img src="https://habrastorage.org/webt/uw/e1/mj/uwe1mjdtywr59oyshaah2q1gkus.png"><br>  <b>Figura 8.</b> Resultado da nova serialização e desserialização de um Bundle com uma classe vulnerável. <br><br>  O que nós vemos?  A chave oculta (com o valor da sequência "Olá!") Apareceu no pacote, que não existia antes.  Considere o snippet Parcel deste pacote para entender por que isso aconteceu: <br><br><img src="https://habrastorage.org/webt/cx/za/dz/cxzadza4tugyeemlefk1lmlkdbu.png"><br>  <b>Figura 9.</b> Estrutura do pacote do objeto Bundle com a classe vulnerável após dois ciclos de serialização-desserialização. <br><br>  Aqui, a essência das vulnerabilidades do EvilParcel fica mais clara.  É possível criar um pacote especialmente formado que conterá uma classe vulnerável.  A alteração dos limites desta classe permitirá que você coloque qualquer objeto neste Bundle - por exemplo, Intent, que aparecerá no Bundle somente após a segunda desserialização.  Isso tornará possível ocultar o Intent dos mecanismos de proteção do sistema operacional. <br><br><h3>  Operação EvilParcel </h3><br>  O Android.InfectionAds.1 usando o CVE-2017-13315 instalou e desinstalou programas sem a intervenção do proprietário do dispositivo infectado.  Mas como vai isso? <br><br>  Em 2013, o erro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">7699048</a> também foi descoberto, também conhecido como Launch AnyWhere.  Permitia que um aplicativo de terceiros executasse atividades arbitrárias em nome do sistema de usuário mais privilegiado.  O diagrama abaixo mostra seu mecanismo de ação: <br><br><img src="https://habrastorage.org/webt/dg/no/n9/dgnon92txtobknvvgr5eo2cmi54.png"><br>  <b>Figura 10.</b> Esquema do erro 7699048. <br><br>  Com essa vulnerabilidade, um aplicativo de exploração pode implementar o serviço AccountAuthenticator, projetado para adicionar novas contas ao sistema operacional.  Graças ao bug 7699048, o exploit é capaz de executar atividades para instalar, desinstalar, substituir aplicativos, redefinir o PIN ou o bloqueio de padrão e fazer outras coisas desagradáveis. <br><br>  O Google corrigiu essa lacuna proibindo o lançamento de atividades arbitrárias do AccountManager.  Agora, o AccountManager permite apenas o lançamento de atividades provenientes do mesmo aplicativo.  Para fazer isso, ele verifica e compara a assinatura digital do programa que iniciou o início da atividade com a assinatura do aplicativo em que a atividade iniciada está localizada.  É assim: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; (intent = result.getParcelable(AccountManager.KEY_INTENT)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* * The Authenticator API allows third party authenticators to * supply arbitrary intents to other apps that they can run, * this can be very bad when those apps are in the system like * the System Settings. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> authenticatorUid = Binder.getCallingUid(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> bid = Binder.clearCallingIdentity(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { PackageManager pm = mContext.getPackageManager(); ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, <span class="hljs-number"><span class="hljs-number">0</span></span>, mAccounts.userId); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetUid = resolveInfo.activityInfo.applicationInfo.uid; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PackageManager.SIGNATURE_MATCH != pm.checkSignatures(authenticatorUid, targetUid)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecurityException( <span class="hljs-string"><span class="hljs-string">"Activity to be started with KEY_INTENT must "</span></span> + <span class="hljs-string"><span class="hljs-string">"share Authenticator's signatures"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { Binder.restoreCallingIdentity(bid); } }</code> </pre><br>  Parece que o problema foi resolvido, mas nem tudo aqui é tão bom.  Aconteceu que essa correção pode ser contornada usando a vulnerabilidade conhecida EvilParcel CVE-2017-13315!  Como já sabemos, após corrigir o Launch AnyWhere, o sistema verifica a assinatura digital do aplicativo.  Se essa verificação for bem-sucedida, o Bundle será passado para IAccountManagerResponse.onResult ().  Ao mesmo tempo, onResult () é chamado pelo mecanismo IPC, para que o Bundle seja serializado novamente.  Na implementação onResult (), acontece o seguinte: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** Handles the responses from the AccountManager */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IAccountManagerResponse</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stub</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle bundle)</span></span></span><span class="hljs-function"> </span></span>{ Intent intent = bundle.getParcelable(KEY_INTENT); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intent != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; mActivity != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// since the user provided an Activity we will silently start intents // that we see mActivity.startActivity(intent); // leave the Future running to wait for the real response to this request } //&lt;.....&gt; } //&lt;.....&gt; }</span></span></code> </pre><br>  Em seguida, o Bundle é extraído da chave de intenção e a atividade é iniciada sem verificações.  Como resultado, para iniciar uma atividade arbitrária com direitos do sistema, basta construir o Bundle de forma que o campo de intenção fique oculto na primeira desserialização e apareça na segunda desserialização.  E, como já vimos, é precisamente essa tarefa que as vulnerabilidades do EvilParcel cumprem. <br><br>  No momento, todas as vulnerabilidades conhecidas desse tipo são corrigidas por correções nas próprias classes Parcelable vulneráveis.  No entanto, o reaparecimento de classes vulneráveis ​​no futuro não pode ser descartado.  A implementação do Bundle e o mecanismo para adicionar novas contas ainda são os mesmos de antes.  Eles ainda permitem que você crie exatamente a mesma exploração ao descobrir (ou novas) classes Parcelable vulneráveis.  Além disso, a implementação dessas classes ainda é feita manualmente, e o programador deve ficar de olho no comprimento constante do objeto Parcelable serializado.  E este é um fator humano com todas as consequências.  No entanto, esperamos que esses erros sejam o mínimo possível e as vulnerabilidades do EvilParcel não incomodem os usuários de dispositivos Android. <br><br>  Você pode verificar se há vulnerabilidades no EvilParcel no seu dispositivo móvel usando nosso antivírus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dr.Web Security Space</a> .  O “Auditor de Segurança” interno relatará os problemas identificados e dará recomendações para resolvê-los. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt457558/">https://habr.com/ru/post/pt457558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt457542/index.html">Hackear e proteger unidades de criptografia LUKS</a></li>
<li><a href="../pt457546/index.html">Dia da demonstração: por que tudo isso e como fazer? UPD + Broadcast</a></li>
<li><a href="../pt457548/index.html">Geração de sinal PWM multifásico no TMS320F28027</a></li>
<li><a href="../pt457550/index.html">Do que a indústria digital precisa ser protegida</a></li>
<li><a href="../pt457552/index.html">Alpinistas em Zafasadia. Como funcionam os promalps na torre do Lakhta Center</a></li>
<li><a href="../pt457560/index.html">Ações Tokenizadas: Como se Tornar um Investidor da Gett Antes de Fazer um IPO</a></li>
<li><a href="../pt457562/index.html">Ivideon Counter 3D: quem, como e por que contar visitantes</a></li>
<li><a href="../pt457564/index.html">Estimando o custo dos sistemas de TI de uma empresa</a></li>
<li><a href="../pt457566/index.html">A pressão está boa: Por que o data center precisa de controle da pressão do ar?</a></li>
<li><a href="../pt457568/index.html">Congresso Futurológico: uma seleção de relatos dos evangelistas do futuro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>