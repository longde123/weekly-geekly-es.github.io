<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕥 👁‍🗨 🦇 Erstellen Sie Ihren Publisher in Combine 🏇🏾 🚬 🙏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute möchte ich Ihnen zeigen, wie Sie Ihren eigenen Publisher im neuen Apple Combine Framework erstellen. 


 Als erstes müssen wir uns kurz daran er...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen Sie Ihren Publisher in Combine</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482690/"><p><img src="https://habrastorage.org/webt/yu/vm/d7/yuvmd7t0eg1ws5pi_ahqklv9bba.png"></p><br><p>  Heute möchte ich Ihnen zeigen, wie Sie Ihren eigenen Publisher im neuen Apple Combine Framework erstellen. </p><a name="habracut"></a><br><p>  Als erstes müssen wir uns kurz daran erinnern, wie die grundlegenden Teile von Combine miteinander interagieren, nämlich Publisher, Subscription, Subscriber. </p><br><ul><li>  Abonnent tritt Publisher bei </li><li>  Herausgeber sendet Abonnement Abonnent </li><li>  Der Abonnent fragt nach N Werten für das Abonnement </li><li>  Publisher sendet N Werte oder weniger </li><li>  Publisher sendet ein Abschlusssignal </li></ul><br><h1 id="publisher">  Herausgeber </h1><br><p>  Beginnen wir also mit der Erstellung unseres Publishers.  In der Apple-Dokumentation sehen wir, dass <a href="https://developer.apple.com/documentation/combine/publisher">Publisher</a> ein Protokoll ist. </p><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">Output</span></span> <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">Failure</span></span> : <span class="hljs-type"><span class="hljs-type">Error</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-function">&lt;S&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(subscriber: S)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">S</span></span> : <span class="hljs-type"><span class="hljs-type">Subscriber</span></span>, <span class="hljs-type"><span class="hljs-type">Self</span></span>.<span class="hljs-type"><span class="hljs-type">Failure</span></span> == <span class="hljs-type"><span class="hljs-type">S</span></span>.<span class="hljs-type"><span class="hljs-type">Failure</span></span>, <span class="hljs-type"><span class="hljs-type">Self</span></span>.<span class="hljs-type"><span class="hljs-type">Output</span></span> == <span class="hljs-type"><span class="hljs-type">S</span></span>.<span class="hljs-type"><span class="hljs-type">Input</span></span> }</code> </pre> <br><p>  Wenn "Ausgabe" der Wertetyp ist, der von diesem Verleger übergeben wird, ist "Fehler" der Fehlertyp, der dem Fehlerprotokoll folgen muss. </p><br><p>  Und die Empfangsfunktion (_: Subscriber), die aufgerufen wird, um diesem Publisher mithilfe von subscribe (_ :) einen Subscriber hinzuzufügen. </p><br><p>  Als Beispiel implementieren wir Publisher, die für uns <a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci-Zahlen</a> generieren. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FibonacciPublisher</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Output</span></span> = <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Failure</span></span> = <span class="hljs-type"><span class="hljs-type">Never</span></span> }</code> </pre> <br><p>  Da die Sequenz aus Zahlen besteht, ist der Ausgabetyp "Ausgabe" vom Typ "Int", und "Fehler" ist ein spezieller Typ "Nie", der angibt, dass dieser Publisher niemals fehlschlagen wird. </p><br><p>  Aus Gründen der Flexibilität geben wir die Grenze für die Anzahl der Elemente an, die wir empfangen möchten, und binden diesen Wert in ein Konfigurationsobjekt unseres Publishers ein. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FibonacciConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>: <span class="hljs-type"><span class="hljs-type">UInt</span></span> }</code> </pre> <br><p>  Schauen wir uns diesen Code genauer an, var count: UInt sieht nach einer guten Option aus, aber seine Verwendung beschränkt uns auf den Bereich gültiger Werte des Typs UInt und es ist auch nicht ganz klar, was angezeigt werden soll, wenn wir immer noch eine unbegrenzte Sequenz haben möchten. </p><br><p>  Anstelle von UInt verwenden wir den Subscribers.Demand-Typ, der in Combine definiert ist. Dort wird er auch als der Typ beschrieben, der vom Abonnenten über das Abonnement an den Verleger gesendet wird.  In einfachen Worten zeigt es den <em>Bedarf</em> an Elementen, wie viele Elemente vom Abonnenten angefordert werden.  unbegrenzt - nicht begrenzt, keine - überhaupt nicht, max (N) - nicht mehr als N-mal. </p><br><pre> <code class="swift hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demand</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Equatable</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hashable</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Codable</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomStringConvertible</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> unlimited: <span class="hljs-type"><span class="hljs-type">Subscribers</span></span>.<span class="hljs-type"><span class="hljs-type">Demand</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">none</span></span>: <span class="hljs-type"><span class="hljs-type">Subscribers</span></span>.<span class="hljs-type"><span class="hljs-type">Demand</span></span> <span class="hljs-comment"><span class="hljs-comment">///  Demand.max(0) @inlinable public static func max(_ value: Int) -&gt; Subscribers.Demand .... }</span></span></code> </pre> <br><p>  Wir haben FibonacciConfiguration umgeschrieben und den Typ für die Zählung auf einen neuen geändert. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FibonacciConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>: <span class="hljs-type"><span class="hljs-type">Subscribers</span></span>.<span class="hljs-type"><span class="hljs-type">Demand</span></span> }</code> </pre> <br><p>  Kehren wir zu Publisher zurück und implementieren die Methode receive (_: Subscriber). Wie wir uns erinnern, wird diese Methode benötigt, um Subscriber zu Publisher hinzuzufügen.  Und er tut dies mit einem Abonnement, Publisher muss ein Abonnement erstellen und das Abonnement auf den Abonnenten übertragen. </p><br><pre> <code class="swift hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-function">&lt;S&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(subscriber: S)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">S</span></span> : <span class="hljs-type"><span class="hljs-type">Subscriber</span></span>, <span class="hljs-type"><span class="hljs-type">Failure</span></span> == <span class="hljs-type"><span class="hljs-type">S</span></span>.<span class="hljs-type"><span class="hljs-type">Failure</span></span>, <span class="hljs-type"><span class="hljs-type">Output</span></span> == <span class="hljs-type"><span class="hljs-type">S</span></span>.<span class="hljs-type"><span class="hljs-type">Input</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> subscription = <span class="hljs-type"><span class="hljs-type">FibonacciSubscription</span></span>(subscriber: subscriber, configuration: configuration) subscriber.receive(subscription: subscription) }</code> </pre> <br><p>  Dies ist eine generische Funktion, die Subscriber als Parameter verwendet. Die Ausgabewerte des Publishers müssen mit den Eingabewerten des Subscriber übereinstimmen (Output == S.Input). Dies gilt auch für Fehler.  Dies ist notwendig, um Publisher'a und Subscriber'a zu "verbinden". </p><br><p>  Erstellen Sie in der Funktion selbst ein FibonacciSubscription-Abonnement, und übertragen Sie im Konstruktor den Abonnenten und die Konfiguration.  Danach wird das Abonnement auf den Abonnenten übertragen. </p><br><p>  Unser Verlag ist fertig, am Ende haben wir: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FibonacciPublisher</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Output</span></span> = <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Failure</span></span> = <span class="hljs-type"><span class="hljs-type">Never</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> configuration: <span class="hljs-type"><span class="hljs-type">FibonacciConfiguration</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-function">&lt;S&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(subscriber: S)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">S</span></span> : <span class="hljs-type"><span class="hljs-type">Subscriber</span></span>, <span class="hljs-type"><span class="hljs-type">Failure</span></span> == <span class="hljs-type"><span class="hljs-type">S</span></span>.<span class="hljs-type"><span class="hljs-type">Failure</span></span>, <span class="hljs-type"><span class="hljs-type">Output</span></span> == <span class="hljs-type"><span class="hljs-type">S</span></span>.<span class="hljs-type"><span class="hljs-type">Input</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> subscription = <span class="hljs-type"><span class="hljs-type">FibonacciSubscription</span></span>(subscriber: subscriber, configuration: configuration) subscriber.receive(subscription: subscription) } }</code> </pre> <br><p>  Wie Sie sehen, enthält Publisher selbst keine Logik zum Generieren einer Fibonacci-Sequenz, die gesamte Logik befindet sich in der Subskriptionsklasse - FibonacciSubscription. </p><br><p>  Wie Sie vielleicht bereits erraten haben, folgt die FibonacciSubscription-Klasse dem Subscription-Protokoll. Schauen wir uns die Definition dieses Protokolls an. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscription</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cancellable</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomCombineIdentifierConvertible</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> demand: Subscribers.Demand)</span></span></span></span> }</code> </pre> <br><p>  Die Funktion request (_: Subscribers.Demand) teilt Publisher mit, dass er dem Abonnenten weitere Werte senden kann.  In dieser Methode wird die Logik des Sendens von Fibonacci-Zahlen sein. <br>  Wir müssen auch nach dem Cancellable-Protokoll implementieren und die cancel () -Funktion implementieren. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cancellable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> }</code> </pre> <br><p>  Folgen Sie einfach dem CustomCombineIdentifierConvertible-Protokoll und definieren Sie die schreibgeschützte Variable combineIdentifier. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomCombineIdentifierConvertible</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> combineIdentifier: <span class="hljs-type"><span class="hljs-type">CombineIdentifier</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } }</code> </pre> <br><p>  Hier gibt es eine Klarstellung: Wenn Sie direkt unter der Definition des CustomCombineIdentifierConvertible-Protokolls in Combine scrollen, können Sie feststellen, dass Combine eine Erweiterung für dieses Protokoll bereitstellt, die die Form hat: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomCombineIdentifierConvertible</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Self</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnyObject</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> combineIdentifier: <span class="hljs-type"><span class="hljs-type">CombineIdentifier</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } }</code> </pre> <br><p>  Was uns sagt, dass die Definition der Variablen combineIdentifier: CombineIdentifier standardmäßig bereitgestellt wird, wenn der Typ, der auf dieses Protokoll folgt, auch auf das AnyObject-Protokoll folgt, dh, wenn dieser Typ eine Klasse ist.  FibonacciSubscription ist eine Klasse, daher erhalten wir die Standardvariablendefinition. </p><br><h1 id="subscription">  Abo </h1><br><p>  Und so werden wir beginnen, unser Fibonacci-Abonnement zu implementieren. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FibonacciSubscription</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&gt;: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscription</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subscriber: <span class="hljs-type"><span class="hljs-type">S?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> configuration: <span class="hljs-type"><span class="hljs-type">FibonacciConfiguration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>: <span class="hljs-type"><span class="hljs-type">Subscribers</span></span>.<span class="hljs-type"><span class="hljs-type">Demand</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(subscriber: <span class="hljs-type"><span class="hljs-type">S?</span></span>, configuration: <span class="hljs-type"><span class="hljs-type">FibonacciConfiguration</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.subscriber = subscriber <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.configuration = configuration <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> = configuration.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> } ... }</code> </pre> <br><p>  Wie Sie sehen, enthält FibonacciConfiguration eine starke Verbindung zum Abonnenten, ist also der Eigentümer des Abonnenten.  <strong>Dies ist ein wichtiger Punkt. Das Abonnement ist für die Aufbewahrung des Abonnenten verantwortlich und muss so lange aufbewahrt werden, bis die Arbeit beendet ist, ein Fehler aufgetreten ist oder gekündigt wurde.</strong> </p><br><p>  Als Nächstes implementieren wir die cancel () -Methode aus dem Cancellable-Protokoll. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { subscriber = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  Wenn Sie den Subskribenten auf "nil" setzen, kann nicht auf das Abonnement zugegriffen werden. </p><br><p>  Jetzt können wir mit der Implementierung des Sendens von Fibonacci-Nummern beginnen. <br>  Wir implementieren die Request-Methode (_: Subscribers.Demand). </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> demand: Subscribers.Demand)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 guard count &gt; .none else { subscriber?.receive(completion: .finished) return } // 2 count -= .max(1) subscriber?.receive(0) if count == .none { subscriber?.receive(completion: .finished) return } // 3 count -= .max(1) subscriber?.receive(1) if count == .none { subscriber?.receive(completion: .finished) return } // 4 var prev = 0 var current = 1 var temp: Int while true { temp = prev prev = current current += temp subscriber?.receive(current) count -= .max(1) if count == .none { subscriber?.receive(completion: .finished) return } } }</span></span></code> </pre> <br><p>  1) Wir prüfen von Anfang an, wie viele Elemente Publisher uns, wenn überhaupt nicht, zur Verfügung stellen können, schließen Sie den Versand ab und senden Sie dem Abonnenten ein Signal, dass der Versand der Nummern abgeschlossen ist. <br>  2) Reduzieren Sie bei Bedarf die Gesamtzahl der angeforderten Nummern um eins, senden Sie das erste Element der Fibonacci-Sequenz an den Abonnenten, nämlich 0, und überprüfen Sie dann erneut, wie viele Elemente der Verlag uns geben kann, wenn nicht, senden Sie ein Signal an den Abonnenten, um den Vorgang abzuschließen . <br>  3) Dieselbe Vorgehensweise wie in Absatz 2), jedoch nur für das zweite Element in der Fibonacci-Sequenz. <br>  4) Wenn mehr als 2 Elemente erforderlich sind, implementieren wir einen iterativen Algorithmus zum Auffinden von Fibonacci-Zahlen, wobei wir bei jedem Schritt die nächste Nummer aus der Fibonacci-Sequenz an Subscriber'y übertragen und auch überprüfen, wie viele Elemente Publisher noch bereitstellen kann.  Wenn Publisher keine neuen Nummern mehr bereitstellt, senden Sie dem Abonnenten ein Abschlusssignal. </p><br><div class="spoiler">  <b class="spoiler_title">Im Moment haben wir einen solchen Code geschrieben</b> <div class="spoiler_text"><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FibonacciConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>: <span class="hljs-type"><span class="hljs-type">Subscribers</span></span>.<span class="hljs-type"><span class="hljs-type">Demand</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FibonacciPublisher</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Output</span></span> = <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Failure</span></span> = <span class="hljs-type"><span class="hljs-type">Never</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> configuration: <span class="hljs-type"><span class="hljs-type">FibonacciConfiguration</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-function">&lt;S&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(subscriber: S)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">S</span></span> : <span class="hljs-type"><span class="hljs-type">Subscriber</span></span>, <span class="hljs-type"><span class="hljs-type">Failure</span></span> == <span class="hljs-type"><span class="hljs-type">S</span></span>.<span class="hljs-type"><span class="hljs-type">Failure</span></span>, <span class="hljs-type"><span class="hljs-type">Output</span></span> == <span class="hljs-type"><span class="hljs-type">S</span></span>.<span class="hljs-type"><span class="hljs-type">Input</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> subscription = <span class="hljs-type"><span class="hljs-type">FibonacciSubscription</span></span>(subscriber: subscriber, configuration: configuration) subscriber.receive(subscription: subscription) } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FibonacciSubscription</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&gt;: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscription</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subscriber: <span class="hljs-type"><span class="hljs-type">S?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> configuration: <span class="hljs-type"><span class="hljs-type">FibonacciConfiguration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>: <span class="hljs-type"><span class="hljs-type">Subscribers</span></span>.<span class="hljs-type"><span class="hljs-type">Demand</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(subscriber: <span class="hljs-type"><span class="hljs-type">S?</span></span>, configuration: <span class="hljs-type"><span class="hljs-type">FibonacciConfiguration</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.subscriber = subscriber <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.configuration = configuration <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> = configuration.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { subscriber = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> demand: Subscribers.Demand)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 guard count &gt; .none else { subscriber?.receive(completion: .finished) return } // 2 count -= .max(1) subscriber?.receive(0) if count == .none { subscriber?.receive(completion: .finished) return } // 3 count -= .max(1) subscriber?.receive(1) if count == .none { subscriber?.receive(completion: .finished) return } // 4 var prev = 0 var current = 1 var temp: Int while true { temp = prev prev = current current += temp subscriber?.receive(current) count -= .max(1) if count == .none { subscriber?.receive(completion: .finished) return } } } }</span></span></code> </pre> </div></div><br><h3 id="pervoe-testirovanie">  Erster Test </h3><br><p>  Jetzt werden wir testen, was wir haben, wir haben unseren Publisher und unser Abonnement, wir haben nicht genug Sibscriber, Combine bietet 2 Sibscriber aus der Box: versenken und zuweisen. </p><br><ul><li>  sink - Diese Methode erstellt einen Abonnenten und fordert sofort <strong>eine unbegrenzte</strong> Anzahl von Werten an. </li><li>  zuweisen - legt jedes Element von Publisher auf eine Objekteigenschaft fest. </li></ul><br><p>  sink ist für unseren zweck gut geeignet, ein besonderes augenmerk sollte darauf gelegt werden, dass es eine unbegrenzte anzahl von werten verlangt. </p><br><p>  Und hier müssen wir eine wichtige Unterscheidung treffen, unser Publisher in der Variable count bestimmt die Anzahl der Elemente, die unser Publisher angeben kann, und diese Bedingungen werden von uns selbst festgelegt.  Grundsätzlich könnten wir auf diese Variable verzichten und uns nicht auf die Übertragung von Fibonacci-Zahlen beschränken, aber bald würden wir den Bereich zulässiger Werte vom Typ Int verlassen. <br>  Bei sink ist der Fall anders. Jeder Abonnent bestimmt, wie viele Werte er empfangen möchte. Sink fordert eine unbegrenzte Anzahl von Werten an. Dies bedeutet, dass er Werte empfängt, bis er ein Abschluss-, Fehler- oder Löschungssignal erhält. </p><br><p>  Um die Verwendung unseres Publishers zu vereinfachen, fügen wir dessen Erstellung der Publishers-Protokollerweiterung hinzu. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publishers</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fibonacci</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(configuration: FibonacciConfiguration)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">FibonacciPublisher</span></span> { <span class="hljs-type"><span class="hljs-type">FibonacciPublisher</span></span>(configuration: configuration) } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fibonacci</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">count</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Subscribers.Demand = .</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">max</span></span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-number">6</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">)</span></span></span></span></span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">FibonacciPublisher</span></span> { <span class="hljs-type"><span class="hljs-type">FibonacciPublisher</span></span>(configuration: <span class="hljs-type"><span class="hljs-type">FibonacciConfiguration</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>)) } }</code> </pre> <br><p>  Probieren Sie unseren Verlag aus </p><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">Publishers</span></span>.fibonacci(<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>: .<span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>)) .sink { value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(value, terminator: <span class="hljs-string"><span class="hljs-string">" "</span></span>) } <span class="hljs-comment"><span class="hljs-comment">// print 0 1 1 2 3 5 8 13 21 34 - OK</span></span></code> </pre> <br><p>  Und jetzt die Grenzfälle </p><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">Publishers</span></span>.fibonacci(<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>: .<span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)) .sink { value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(value, terminator: <span class="hljs-string"><span class="hljs-string">" "</span></span>) } <span class="hljs-comment"><span class="hljs-comment">// prinst 0 - OK Publishers.fibonacci(count: .max(2)) .sink { value in print(value, terminator: " ") } // prints 0 1 - OK Publishers.fibonacci(count: .none) .print() //    publisher'a .sink { value in print(value, terminator: " ") } // prints receive finished - OK</span></span></code> </pre> <br><p>  Aber was passiert, wenn Sie .unlimited angeben? </p><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">Publishers</span></span>.fibonacci(<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>: .unlimited) .<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>() .sink { value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(value, terminator: <span class="hljs-string"><span class="hljs-string">" "</span></span>) } <span class="hljs-comment"><span class="hljs-comment">// prints 0 1 1 2 3 5 8 13 21 ...   ,     Int.</span></span></code> </pre> <br><p>  Wie können Sie .unlimited verwenden, aber mehrere Zahlen ausgeben?  Dazu benötigen wir den Operator .prefix (_), der genauso funktioniert wie .prefix (_) aus Auflistungen, dh, es bleiben nur die ersten N Elemente übrig. </p><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">Publishers</span></span>.fibonacci(<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>: .unlimited) .<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>() .<span class="hljs-keyword"><span class="hljs-keyword">prefix</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>) .sink { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> } <span class="hljs-comment"><span class="hljs-comment">// prints 0 1 1 2 3 cancel   ,       Int.</span></span></code> </pre> <br><p>  Was ist das problem  Vielleicht in .prefix (_)?  Lassen Sie uns ein kleines Experiment mit der Standardsequenz von Foundation durchführen. </p><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//   1 2 3 4 5 6 7 8 ... 1... .publisher .print() .prefix(5) .sink { _ in } // prints 1 2 3 4 5 cancel - </span></span></code> </pre> <br><p>  Wie wir sehen können, hat der obige Code korrekt funktioniert, dann liegt das Problem in unserer Implementierung von Publisher. <br>  Wir sehen uns die Protokolle von .print () an und stellen fest, dass wir nach N Anfragen von .prefix (_) cancel () für unser FibonacciSubscription aufrufen, wobei wir Subscriber auf nil setzen. </p><br><pre> <code class="swift hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { subscriber = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  Wenn Sie die Anrufliste öffnen, können Sie sehen, dass cancel () von request (_ :) aufgerufen wird, und zwar während des Anrufs an den Teilnehmer? .Receive (_).  Daraus können wir schließen, dass zu einem bestimmten Zeitpunkt innerhalb der Anfrage (_ :) der Teilnehmer Null werden kann und wir dann die Arbeit an der Generierung neuer Nummern beenden müssen.  Fügen Sie diese Bedingung unserem Code hinzu. </p><br><pre> <code class="swift hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> demand: Subscribers.Demand)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 guard count &gt; .none else { subscriber?.receive(completion: .finished) return } // 2 count -= .max(1) subscriber?.receive(0) guard let _ = subscriber else { return } // new if count == .none { subscriber?.receive(completion: .finished) return } // 3 count -= .max(1) subscriber?.receive(1) guard let _ = subscriber else { return } // new if count == .none { subscriber?.receive(completion: .finished) return } // 4 var prev = 0 var current = 1 var temp: Int while let subscriber = subscriber { // new temp = prev prev = current current += temp subscriber.receive(current) count -= .max(1) if count == .none { subscriber.receive(completion: .finished) return } } }</span></span></code> </pre> <br><p>  Führen Sie jetzt unseren Testcode aus. </p><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">Publishers</span></span>.fibonacci(<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>: .unlimited) .<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>() .<span class="hljs-keyword"><span class="hljs-keyword">prefix</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>) .sink { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> } <span class="hljs-comment"><span class="hljs-comment">// prints 0 1 1 2 3 cancel - </span></span></code> </pre> <br><p>  Habe das erwartete Verhalten. </p><br><h1 id="subscriber">  Abonnent </h1><br><p>  Und so ist unser FibonacciSubscription bereit?  Nicht wirklich, in unseren Tests haben wir nur einen Sink-Abonnenten verwendet, der nach einer unbegrenzten Anzahl von Nummern fragt, aber was ist, wenn wir stattdessen einen Abonnenten verwenden, der eine bestimmte begrenzte Anzahl von Nummern erwartet.  Combine stellt einen solchen Abonnenten nicht zur Verfügung, aber was hindert uns daran, unseren eigenen zu schreiben?  Nachfolgend finden Sie die Implementierung unseres Fibonacci-Abonnenten. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FibonacciSubscriber</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Input</span></span> = <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Failure</span></span> = <span class="hljs-type"><span class="hljs-type">Never</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> limit: <span class="hljs-type"><span class="hljs-type">Subscribers</span></span>.<span class="hljs-type"><span class="hljs-type">Demand</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(limit: <span class="hljs-type"><span class="hljs-type">Subscribers</span></span>.<span class="hljs-type"><span class="hljs-type">Demand</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.limit = limit } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(subscription: Subscription)</span></span></span></span> { subscription.request(limit) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input: Input)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Subscribers</span></span>.<span class="hljs-type"><span class="hljs-type">Demand</span></span> { .<span class="hljs-keyword"><span class="hljs-keyword">none</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(completion: Subscribers.Completion&lt;Failure&gt;)</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Subscriber's completion: \(completion)"</span></span>) } }</code> </pre> <br><p>  Daher verfügt unser Fibonacci-Abonnent über eine Limit-Eigenschaft, die festlegt, wie viele Elemente dieser Abonnent empfangen möchte.  Und dies geschieht mit der Methode receive (_: Subscription), bei der wir dem Abonnement mitteilen, wie viele Elemente wir benötigen.  Beachten Sie auch die Funktion receive (_: Input) -&gt; Subscribers.Demand. Diese Funktion wird aufgerufen, wenn ein neuer Wert empfangen wird. Als Rückgabewert geben wir an, wie viele zusätzliche Elemente wir empfangen möchten: .none - not at all, .max (N) N pieces Insgesamt entspricht die Gesamtzahl der empfangenen Elemente der Summe aus dem Wert des gesendeten Abonnements in receive (_: Subscription) und allen Rückgabewerten von receive (_: Input) -&gt; Subscribers.Demand. </p><br><h3 id="vtoroe-testirovanie">  Zweiter Test </h3><br><p>  Versuchen wir es mit FibonacciSubscriber. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> subscriber = <span class="hljs-type"><span class="hljs-type">FibonacciSubscriber</span></span>(limit: .<span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>)) <span class="hljs-type"><span class="hljs-type">Publishers</span></span>.fibonacci(<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>: .<span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>)) .<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>() .subscribe(subscriber) <span class="hljs-comment"><span class="hljs-comment">// prints 0 1 1 2 3 -     0 1 1</span></span></code> </pre> <br><p>  Wie wir sehen, hat unser Publisher 5 statt 3 Werte gesendet. Warum?  Da die request (_: Subscribers.Demand) -Methode von FibonacciSubscription'a die Anforderungen des Abonnenten nicht berücksichtigt, müssen wir sie korrigieren. Hierzu fügen wir eine zusätzliche angeforderte Eigenschaft hinzu, mit der wir die Anforderungen des Abonnenten verfolgen. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FibonacciSubscription</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&gt;: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscription</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subscriber: <span class="hljs-type"><span class="hljs-type">S?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> configuration: <span class="hljs-type"><span class="hljs-type">FibonacciConfiguration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>: <span class="hljs-type"><span class="hljs-type">Subscribers</span></span>.<span class="hljs-type"><span class="hljs-type">Demand</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> requested: <span class="hljs-type"><span class="hljs-type">Subscribers</span></span>.<span class="hljs-type"><span class="hljs-type">Demand</span></span> = .<span class="hljs-keyword"><span class="hljs-keyword">none</span></span> <span class="hljs-comment"><span class="hljs-comment">// new init(subscriber: S?, configuration: FibonacciConfiguration) { self.subscriber = subscriber self.configuration = configuration self.count = configuration.count } func cancel() { subscriber = nil } func request(_ demand: Subscribers.Demand) { guard count &gt; .none else { subscriber?.receive(completion: .finished) return } requested += demand // new count -= .max(1) requested -= .max(1) // new requested += subscriber?.receive(0) ?? .none // new guard let _ = subscriber, requested &gt; .none else { return } // new if count == .none { subscriber?.receive(completion: .finished) return } count -= .max(1) requested -= .max(1) // new requested += subscriber?.receive(1) ?? .none // new guard let _ = subscriber, requested &gt; .none else { return } // new if count == .none { subscriber?.receive(completion: .finished) return } var prev = 0 var current = 1 var temp: Int while let subscriber = subscriber, requested &gt; .none { // new temp = prev prev = current current += temp requested += subscriber.receive(current) // new count -= .max(1) requested -= .max(1) // new if count == .none { subscriber.receive(completion: .finished) return } } } }</span></span></code> </pre> <br><h3 id="trete-testirovanie">  Dritte Prüfung </h3><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> subscriber = <span class="hljs-type"><span class="hljs-type">FibonacciSubscriber</span></span>(limit: .<span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>)) <span class="hljs-type"><span class="hljs-type">Publishers</span></span>.fibonacci(<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>: .<span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>)) .<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>() .subscribe(subscriber) <span class="hljs-comment"><span class="hljs-comment">// prints 0 1 1 - OK</span></span></code> </pre> <br><p>  Publisher funktioniert jetzt ordnungsgemäß. </p><br><div class="spoiler">  <b class="spoiler_title">Endgültiger Code</b> <div class="spoiler_text"><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Combine struct FibonacciConfiguration { var count: Subscribers.Demand } struct FibonacciPublisher: Publisher { typealias Output = Int typealias Failure = Never var configuration: FibonacciConfiguration func receive&lt;S&gt;(subscriber: S) where S : Subscriber, Failure == S.Failure, Output == S.Input { let subscription = FibonacciSubscription(subscriber: subscriber, configuration: configuration) subscriber.receive(subscription: subscription) } } private final class FibonacciSubscription&lt;S: Subscriber&gt;: Subscription where S.Input == Int { var subscriber: S? var configuration: FibonacciConfiguration var count: Subscribers.Demand var requested: Subscribers.Demand = .none init(subscriber: S?, configuration: FibonacciConfiguration) { self.subscriber = subscriber self.configuration = configuration self.count = configuration.count } func cancel() { subscriber = nil } func request(_ demand: Subscribers.Demand) { guard count &gt; .none else { subscriber?.receive(completion: .finished) return } requested += demand count -= .max(1) requested -= .max(1) requested += subscriber?.receive(0) ?? .none guard let _ = subscriber, requested &gt; .none else { return } if count == .none { subscriber?.receive(completion: .finished) return } count -= .max(1) requested -= .max(1) requested += subscriber?.receive(1) ?? .none guard let _ = subscriber, requested &gt; .none else { return } if count == .none { subscriber?.receive(completion: .finished) return } var prev = 0 var current = 1 var temp: Int while let subscriber = subscriber, requested &gt; .none { temp = prev prev = current current += temp requested += subscriber.receive(current) count -= .max(1) requested -= .max(1) if count == .none { subscriber.receive(completion: .finished) return } } } } extension Publishers { private static func fibonacci(configuration: FibonacciConfiguration) -&gt; FibonacciPublisher { FibonacciPublisher(configuration: configuration) } static func fibonacci(count: Subscribers.Demand = .max(6)) -&gt; FibonacciPublisher { FibonacciPublisher(configuration: FibonacciConfiguration(count: count)) } } class FibonacciSubscriber: Subscriber { typealias Input = Int typealias Failure = Never var limit: Subscribers.Demand init(limit: Subscribers.Demand) { self.limit = limit } func receive(subscription: Subscription) { subscription.request(limit) } func receive(_ input: Input) -&gt; Subscribers.Demand { .none } func receive(completion: Subscribers.Completion&lt;Failure&gt;) { print("Subscriber's completion: \(completion)") } } Publishers.fibonacci(count: .max(4)) .print() .sink { _ in } let subscriber = FibonacciSubscriber(limit: .max(3)) Publishers.fibonacci(count: .max(5)) .print() .subscribe(subscriber)</code> </pre></div></div><br><h1 id="rezultat">  Ergebnis </h1><br><p>  Ich hoffe, dieser Artikel hat Ihnen ein besseres Verständnis dafür vermittelt, was Publisher, Subscription und Subscriber sind, wie sie miteinander interagieren und auf welche Punkte Sie achten müssen, wenn Sie sich für die Implementierung Ihres Publishers entscheiden.  Kommentare, Erläuterungen zum Artikel sind willkommen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de482690/">https://habr.com/ru/post/de482690/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de482678/index.html">Wie ich mich für eine SMS-Suche für iOS entschieden habe und was dabei herauskam</a></li>
<li><a href="../de482680/index.html">Crypt, XOR, Hacken von unverschlüsseltem ZIP und PRSP. Problemlösung mit r0ot-mi Crypto. Teil 2</a></li>
<li><a href="../de482682/index.html">Qt Tool Automation</a></li>
<li><a href="../de482684/index.html">Ich habe in zwei Wochen mein eigenes Dipfake erstellt und $ 552</a></li>
<li><a href="../de482686/index.html">Wissenschaftler automatisieren Tierverhaltensforschung, um die Gehirnfunktion zu entschlüsseln</a></li>
<li><a href="../de482692/index.html">Intel NUC Home für Arbeit und Virtualisierung</a></li>
<li><a href="../de482694/index.html">Gibt es ein Leben nach Windows oder wo kann man 2020 einen Windows-Systemadministrator / -ingenieur entwickeln?</a></li>
<li><a href="../de482696/index.html">Vollständige Festplattenverschlüsselung von Windows Linux-Systemen. Verschlüsselter Multiboot</a></li>
<li><a href="../de482698/index.html">[Essay] Büro Plankton gewidmet. Ich bin nicht von meiner Arbeit inspiriert</a></li>
<li><a href="../de482700/index.html">Wie man Google und Yandex "fickt": Schwarz-Weiß-SEO-Werbung für Websites. Schestakow | Menschen PRO # 74</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>