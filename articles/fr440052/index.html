<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≤üèº üêµ üíï Analyse statique du BIOS / UEFI ou comment obtenir un graphique de d√©pendance üé£ üöä üíµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""J'ai fini de forger hier, 
 J'ai tromp√© deux plans ... " 
 ... chanson VS Vysotsky ... 
 Il y a pr√®s de 3 ans (d√©but 2016), le souhait d'un utilisate...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyse statique du BIOS / UEFI ou comment obtenir un graphique de d√©pendance</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440052/"><table><tbody><tr><td width="480"><img src="https://habrastorage.org/webt/bh/jy/lo/bhjylo0e06sv0b9flvjqzb4e62u.png" width="480"></td><td align="right">  <i>"J'ai fini de forger hier,</i> <i><br></i>  <i>J'ai tromp√© deux plans ... "</i> <i><br></i>  <i>... chanson VS Vysotsky ...</i> </td></tr></tbody></table><br>  Il y a pr√®s de 3 ans (d√©but 2016), le souhait d'un utilisateur est apparu sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">question</a> du projet UEFITool sur GitHub: construire un ¬´Dependency Graph¬ª pour les modules ex√©cutables inclus dans BIOS / UEFI. <br><br>  M√™me une petite discussion s'en est suivie, √† la suite de laquelle il est finalement devenu clair que cette t√¢che n'est nullement triviale, les fonctionnalit√©s disponibles pour sa solution ne suffisent pas, les perspectives √† ce moment sont brumeuses ... <br><br>  Et cette question est rest√©e dans les limbes, avec la perspective d'une r√©alisation dans un avenir ind√©fini (mais le d√©sir est probablement rest√©, et l'espoir, comme vous le savez, meurt en dernier!). <br><br>  Il y a une suggestion: enfin, trouvez une solution √† ce probl√®me! <br><a name="habracut"></a><br><h2>  D√©finissez les termes </h2><br>  On suppose en outre que nous avons affaire √† l'architecture Intel 64 et IA-32. <br><br>  Afin de d√©terminer sans ambigu√Øt√© ce que nous avons d√©cid√© de construire, nous devrons traiter plus en d√©tail le fonctionnement des phases individuelles du BIOS / UEFI. <br><br>  Si vous regardez attentivement les types de fichiers pr√©sent√©s dans les volumes de firmware <abbr title="Syst√®me de fichiers du micrologiciel">FFS</abbr> , il s'av√®re que la plupart des fichiers disponibles incluent une section avec des modules ex√©cutables. <br><br>  M√™me si nous consid√©rons le nouveau firmware d'ASUS ou ASRock, dans lequel vous pouvez facilement trouver jusqu'√† une centaine et demi de fichiers de type EFI_FV_FILETYPE_FREEFORM contenant des images de diff√©rents formats, n√©anmoins, m√™me dans ces firmwares, il y a plus de fichiers ex√©cutables que des fichiers d'autres types. <br><br><pre><code class="plaintext hljs">+--------------------------------------------------------------------------+ | File Types Information | +--------------------------------------------------------------------------+ | EFI_FV_FILETYPE_RAW = 6 | | EFI_FV_FILETYPE_FREEFORM = 83 | | EFI_FV_FILETYPE_SECURITY_CORE = 1 | | EFI_FV_FILETYPE_PEI_CORE = 1 | | EFI_FV_FILETYPE_DXE_CORE = 1 | | EFI_FV_FILETYPE_PEIM = 57 | | EFI_FV_FILETYPE_DRIVER = 196 | | EFI_FV_FILETYPE_APPLICATION = 1 | | EFI_FV_FILETYPE_SMM = 60 | | EFI_FV_FILETYPE_SMM_CORE = 1 | | EFI_FV_FILETYPE_PAD = 4 | +--------------------------------------------------------------------------+ | Total Files : = 411 | +--------------------------------------------------------------------------+</code> </pre>  <b>Un exemple de la composition d'un firmware ordinaire (ordinaire).</b> <br><br>  Bien que les fichiers contenant des modules ex√©cutables ne soient pas marqu√©s dans ce tableau, n√©anmoins, ils seront (par d√©finition) tous dans cette liste, √† l'exception des fichiers avec les suffixes RAW, FREEFORM et PAD. <br><br>  Les fichiers avec le suffixe "CORE" (SECURITY_CORE, PEI_CORE et DXE_CORE) sont les "noyaux" correspondants (modules de t√™te de la phase correspondante) qui re√ßoivent le contr√¥le d'autres phases (ou apr√®s le d√©marrage), SMM_CORE est une sous-phase de la phase DXE et est appel√©e pendant celle-ci accomplissement.  L'APPLICATION ne peut √™tre effectu√©e qu'√† la demande de l'utilisateur; elle n'a pas de liaison sp√©cifique aux phases. <br><br>  Les types de fichiers les plus courants n'√©taient pas r√©pertori√©s: PEIM (modules de phase PEI), DRIVER (modules de phase DXE) et SMM (modules de sous-phase DXE).  Les modules CORE des phases PEI et DXE comprennent un r√©partiteur qui contr√¥le la s√©quence des modules de chargement / d√©marrage de la phase correspondante. <br><br>  Dans l'exemple ci-dessus, il n'y a pas d'options combin√©es, nous ne nous en souviendrons pas: bien qu'elles se trouvent dans un vrai firmware, c'est assez rare.  Ceux qui souhaitent recevoir des informations plus d√©taill√©es et d√©taill√©es sont invit√©s √† se r√©f√©rer aux articles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">CodeRush</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3</a> .  Et citer √©galement son conseil: ¬´Pour les fans de la documentation originale, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la sp√©cification UEFI PI est</a> toujours disponible, tout est d√©crit de mani√®re beaucoup plus d√©taill√©e.¬ª <br><br>  Chaque module de micrologiciel ex√©cutable est un module de format PE + (Portable Executable) ou son d√©riv√© (Terse Executable: format TE).  Le module ex√©cutable au format PE + est un ensemble de donn√©es structur√©es ¬´l√©g√®rement¬ª compress√©es contenant les informations n√©cessaires au chargeur pour mapper ce module en m√©moire. <br><br>  Le format PE + (structure) lui-m√™me n'a pas de m√©canisme d'interaction entre les modules PE + individuels.  Chaque module ex√©cutable apr√®s le chargement et le d√©marrage de l'ex√©cution est un processus ind√©pendant et autonome <b>(enfin, il devrait en √™tre ainsi!)</b> , C'est-√†-dire  le module ne doit rien ¬´supposer¬ª sur ce qui se fait en dehors de lui. <br><br>  L'organisation de l'interaction entre des modules ex√©cutables s√©par√©s d'une phase UEFI est organis√©e au moyen du module CORE de la phase correspondante.  Les modules ex√©cutables individuels peuvent d√©finir (installer) des protocoles, demander (localiser) et utiliser des protocoles d√©clar√©s par d'autres modules, d√©finir / d√©clarer des √©v√©nements et d√©clarer (notifier) ‚Äã‚Äãdes gestionnaires d'√©v√©nements. <br><br>  Ainsi, pour chaque module de firmware ex√©cutable, nous nous int√©ressons √† la pr√©sence des artefacts suivants: <br><br><ol><li>  Liste des protocoles d√©finis par ce module.  (Chaque protocole est identifi√© par un num√©ro unique - guid). </li><li>  Liste des protocoles que ce module utilise (essaie d'utiliser). </li><li>  Liste des √©v√©nements que ce module annonce.  (L'√©v√©nement a un num√©ro unique - guid). </li><li>  Une liste des gestionnaires d'√©v√©nements pr√©sents (mis en ≈ìuvre et pouvant √™tre install√©s / initialis√©s) dans ce module. </li></ol><blockquote>  <i><u>Un graphique de d√©pendance statique</u></i> pour une phase BIOS / UEFI donn√©e est consid√©r√© comme d√©fini si, pour chaque module de phase ex√©cutable, nous connaissons tous les artefacts r√©pertori√©s ci-dessus dans les sections 1-4.  (En d'autres termes, si nous avons d√©fini toutes les informations qui d√©crivent les interd√©pendances entre les modules). </blockquote>  Nous ne consid√©rerons que l'option d'analyse statique, cela signifie que certains √©l√©ments du code qui impl√©mentent les √©l√©ments 1-4 peuvent √™tre inaccessibles (sont des fragments du code "mort") ou ne seront r√©alisables qu'avec certaines options pour les donn√©es / param√®tres d'entr√©e. <br><br>  Tout ce que nous avons consid√©r√© jusqu'√† pr√©sent est bas√© uniquement sur la sp√©cification <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BIOS / UEFI</a> .  Et pour comprendre les ¬´relations¬ª des modules ex√©cutables existants du firmware en question, nous devrons approfondir leur structure, ce qui signifie que nous devons au moins partiellement les inverser (restaurer les algorithmes originaux). <br><br>  Comme d√©j√† mentionn√© ci-dessus, le module ex√©cutable au format PE + n'est qu'un ensemble de structures pour le chargeur, construisant en m√©moire un objet vers lequel le contr√¥le sera transf√©r√©, et cet objet par sa nature se compose d'instructions de processeur, ainsi que de donn√©es pour ces instructions. <br><blockquote>  Nous dirons qu'un <i><u>d√©montage complet du</u></i> module ex√©cutable a √©t√© effectu√© s'il √©tait possible de r√©soudre le probl√®me de s√©paration des commandes et des donn√©es pr√©sent√©es dans ce module. </blockquote>  En m√™me temps, nous n'imposerons aucune exigence sur la structure et les types de donn√©es, il suffit que pour chaque octet appartenant √† l'image du module ex√©cutable re√ßu par le chargeur, nous pouvons clairement dire √† laquelle des deux cat√©gories il appartient: octet de commande ou octet de donn√©es. <br><br>  La t√¢che de <i><u>d√©monter compl√®tement le</u></i> module ex√©cutable lui-m√™me n'est g√©n√©ralement pas triviale, de plus, dans le cas g√©n√©ral, elle n'est pas solvable sur le plan algorithmique.  Nous n'entrerons pas dans les d√©tails de cette question, ne cassons pas les lances non plus, nous consid√©rons cette affirmation comme un axiome. <br><br>  Supposons: <br><br><ol><li>  Nous avons d√©j√† r√©solu le probl√®me du <i><u>d√©montage complet</u></i> d'un module d'ex√©cution BIOS / UEFI sp√©cifique, c'est-√†-dire  nous avons r√©ussi √† s√©parer les commandes et les donn√©es. </li><li>  Il y a le code source du module dans le langage ¬´C¬ª (dans le firmware BIOS / UEFI actuel, les modules sont principalement d√©velopp√©s uniquement dans le langage ¬´C¬ª). </li></ol><br>  M√™me dans ce cas, la simple comparaison des r√©sultats obtenus (le texte de l'assembleur n'est qu'une repr√©sentation textuelle des instructions du processeur) avec le code source en langage "C" n√©cessitera presque toujours une bonne exp√©rience / qualification, √† l'exception des cas absolument d√©g√©n√©r√©s. <br><br>  Une √©tude compl√®te d'exemples montrant des difficult√©s √† identifier ou √† comparer les r√©sultats de d√©sassemblage avec le code source ne fait pas partie de nos plans actuels. <br>  Consid√©rons seulement un exemple lorsque, dans la liste des assembleurs, nous rencontrons la commande <b>¬´Appel indirect¬ª</b> - un appel de proc√©dure implicite. <br><br>  Voici un exemple d'appel de proc√©dure r√©f√©renc√© dans une table.  Un tableau contenant des liens vers diverses proc√©dures est un cas typique d'impl√©mentation de la pr√©sentation des interfaces d'un protocole arbitraire. <br><br>  Un tel tableau ne doit pas √™tre compos√© uniquement de r√©f√©rences √† des proc√©dures, personne n'interdit de stocker des donn√©es arbitraires dans cette structure (et ceci est un exemple de structure typique en ¬´C¬ª). <br><br>  Voici une forme d'un tel appel (au lieu du registre ecx, presque toutes les variantes de registres de processeur 32 bits sont possibles): <br><blockquote>  FF 51 18 appel dword ptr [ecx + 18h] </blockquote>  Ayant, apr√®s analyse, une commande similaire, il est possible de comprendre quelle proc√©dure est appel√©e, une liste de ses param√®tres, le type et la valeur du r√©sultat retourn√©, n'est possible que si nous connaissons le type d'objet (protocole) dont l'interface est appel√©e par cette commande. <br><br>  Si nous savons que dans l'exemple pr√©c√©dent le registre ¬´ecx¬ª contient un pointeur (l'adresse du d√©but de la table EFI_PEI_SERVICES), nous pouvons recevoir (pr√©senter) cette commande de la mani√®re la plus compr√©hensible et ¬´agr√©able¬ª suivante: <blockquote>  Appel FF 51 18 [exx + EFI_PEI_SERVICES.InstallPpi] </blockquote>  L'obtention d'informations sur le contenu du registre participant √† la commande <b>"Appel indirect"</b> d√©passe le plus souvent les capacit√©s d'un d√©sassembleur "typique", dont la t√¢che consiste simplement √† analyser et √† convertir le code binaire du processeur sous une forme lisible par l'homme - une repr√©sentation textuelle de la commande de processeur correspondante. <br><br>  Pour r√©soudre ce probl√®me, il est souvent n√©cessaire d'utiliser des informations (m√©ta) suppl√©mentaires qui ne sont pas disponibles dans le module ex√©cutable binaire (perdues √† la suite de la compilation et de la liaison - elles sont utilis√©es dans les transformations d'une repr√©sentation de l'algorithme √† une autre, mais le processeur n'a plus besoin d'ex√©cuter les commandes re√ßues). <br><br>  Si ces m√©tadonn√©es sont toujours disponibles pour nous √† partir de sources suppl√©mentaires, puis en les utilisant et en effectuant une analyse suppl√©mentaire, nous obtenons une repr√©sentation plus compr√©hensible (et plus pr√©cise) de la commande <b>¬´Appel indirect¬ª</b> . <br><br>  En fait, cette analyse avanc√©e rappelle d√©j√† plus le processus de ¬´d√©compilation¬ª, bien que le r√©sultat ne ressemble pas au code source du module dans le langage ¬´C¬ª, n√©anmoins, √† l'avenir, nous parlerons de ce processus comme de la <i>d√©compilation de commandes qui sont <b>¬´Appel indirect¬ª</b></i> ou <i>¬´ d√©compilation partielle</i> . <br><br>  Nous sommes donc pr√™ts √† d√©terminer les conditions suffisantes pour construire le graphe de l'interd√©pendance des modules de firmware ex√©cutables pour la phase BIOS / UEFI donn√©e: <br><blockquote>  Pour obtenir un <u><i>graphe de d√©pendance statique</i></u> (n'importe laquelle des phases - PEI ou DXE), il <b><i>suffit</i></b> de d√©monter compl√®tement tous les modules ex√©cutables de la phase correspondante (au moins s√©parer toutes les commandes), et de d√©compiler les commandes <b>¬´Appel indirect¬ª</b> pr√©sentes dans les modules d√©sassembl√©s. </blockquote>  Il y a imm√©diatement beaucoup de questions sur la mani√®re dont notre connaissance des √©quipes <b>¬´Appel indirect¬ª</b> est li√©e aux interactions inter-modules. <br>  Comme mentionn√© ci-dessus, l'ensemble du service de gestion des interactions est fourni par le module ¬´CORE¬ª de la phase correspondante, et les services des phases sont con√ßus comme des tables de services ¬´de base¬ª. <br><br>  √âtant donn√© que les mod√®les d'interaction entre les modules dans les phases PEI et DXE, bien que id√©ologiquement (structurellement) similaires, sont techniquement toujours diff√©rents, il est propos√© de passer de quelques consid√©rations formelles √† l'examen d'une construction directe sp√©cifique d'un <u><i>graphe de d√©pendance statique</i></u> pour la phase PEI. <br><br>  Nous pourrons m√™me d√©terminer et formuler les <b><i>conditions n√©cessaires et suffisantes</i></b> pour la possibilit√© de construire un <u><i>graphe de d√©pendance statique</i></u> pour la phase PEI. <br><br><h2>  Cr√©ation d'un <i><u>graphique de d√©pendance statique</u></i> pour la phase PEI </h2><br>  Les descriptions de la solution au probl√®me du <u><i>d√©montage complet des</i></u> modules ex√©cutables de la phase PEI et de la d√©compilation des commandes d' <b>appel indirect</b> pr√©sentes dans ces modules d√©passent le cadre de notre histoire et n'y seront pas donn√©es - la pr√©sentation de ce mat√©riel en volume peut d√©passer la taille de cet opus. <br><br>  Il est possible qu'au fil du temps, cela se produise en tant que mat√©riau distinct, mais pour l'instant - sachez comment. <br><br>  Nous notons seulement que l'utilisation de m√©tadonn√©es, plus la pr√©sence d'une certaine structure pour construire du code binaire, permet en pratique de <i><u>d√©monter compl√®tement</u></i> les modules BIOS / UEFI ex√©cutables.  La preuve formelle de ce fait n'est pas suppos√©e maintenant ni √† l'avenir.  Au moins dans l'analyse / le traitement de plus de cent (100) BIOS / UEFI de divers fabricants, il n'y avait aucun exemple o√π <i><u>un d√©montage complet n'√©tait</u></i> pas possible. <br><br>  De plus, seuls des r√©sultats sp√©cifiques (avec explications: quoi, comment et combien ...). <br><br>  La structure EFI_PEI_SERVICES est la structure de base de la phase PEI, qui est transmise en param√®tre au point d'entr√©e de chaque module PEI et contient des liens vers les services de base n√©cessaires au fonctionnement des modules PEI. <br><br>  Nous ne nous int√©resserons qu'aux domaines situ√©s au tout d√©but de la structure: <br><br><img src="https://habrastorage.org/webt/w_/iz/_m/w_iz_mocpact66z4c382r0o53zc.png"><br><br>  <b>Un fragment d'une structure r√©elle de type EFI_PEI_SERVICES dans le d√©sassembleur IDA Pro.</b> <br><br>  Et voici comment cela appara√Æt dans le code source en langage "C" (rappelez-vous, ce n'est qu'un fragment de la structure): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EFI_PEI_SERVICES</span></span></span><span class="hljs-class"> {</span></span> EFI_TABLE_HEADER Hdr; EFI_PEI_INSTALL_PPI InstallPpi; EFI_PEI_REINSTALL_PPI ReInstallPpi; EFI_PEI_LOCATE_PPI LocatePpi; EFI_PEI_NOTIFY_PPI NotifyPpi; <span class="hljs-comment"><span class="hljs-comment">//...      ... };</span></span></code> </pre> <br>  Au d√©but de la structure EFI_PEI_SERVICES, comme dans toutes les tables de services "de base" (Tables de services), se trouve la structure EFI_TABLE_HEADER.  Les valeurs pr√©sent√©es dans cette structure d'en-t√™te nous permettent d'affirmer sans √©quivoque que si la structure EFI_PEI_SERVICES elle-m√™me est effectivement pr√©sente sur le fragment du d√©sassembleur (voir le champ ¬´Hdr.Signature¬ª), alors au moins le mod√®le de cette structure! <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EFI_TABLE_HEADER</span></span></span><span class="hljs-class"> {</span></span> UINT64 Signature; UINT32 Revision; UINT32 HeaderSize; UINT32 CRC32; UINT32 Reserved; };</code> </pre> <br>  En cours de route, nous pouvons √©tablir que le micrologiciel √©tait en cours de d√©veloppement √† un moment o√π la version de la sp√©cification UEFI PI √©tait de 1,2, dont la p√©riode de pertinence √©tait de 2009 √† 2013, mais pour le moment (d√©but 2019), la version actuelle de la sp√©cification a d√©j√† grandi (litt√©ralement d√©velopp√©e l'autre jour) √† la version 1.7. <br><br>  Dans le champ "Hdr.HeaderSize", vous pouvez d√©terminer que la longueur totale de la structure est de 78h (et ce n'est pas la longueur de l'en-t√™te, comme son nom l'indique, mais la longueur de la structure enti√®re de EFI_PEI_SERVICES). <br><br>  Les interfaces EFI_PEI_SERVICES sont divis√©es en 7 cat√©gories / classes.  Nous les √©num√©rons simplement: <br><br><ol><li>  Services PPI. </li><li>  Services en mode de d√©marrage. </li><li>  Services HOB. </li><li>  Services de volume du micrologiciel. </li><li>  Services de m√©moire de l'√é.-P.-√â. </li><li>  Services de code d'√©tat. </li><li>  R√©initialiser les services. </li></ol><br>  Toute autre narration sera directement li√©e aux proc√©dures appartenant √† la cat√©gorie / classe PPI Services, destin√©es √† l'organisation de l'interaction inter-modules des modules ex√©cutables de la phase PEI. <br><br>  Et il n'y en a que quatre pour la phase PEI. <br><br>  En g√©n√©ral, il n'est pas n√©cessaire de deviner le but de chacune des interfaces: la fonctionnalit√© est compl√®tement d√©termin√©e par le nom de l'interface, tous les d√©tails sont dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sp√©cification</a> . <br><br>  Voici les prototypes de ces proc√©dures: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EFI_STATUS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__cdecl *EFI_PEI_INSTALL_PPI)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_SERVICES **PeiServices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_PPI_DESCRIPTOR *PpiList)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EFI_STATUS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__cdecl *EFI_PEI_REINSTALL_PPI)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_SERVICES **PeiServices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_PPI_DESCRIPTOR *OldPpi, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_PPI_DESCRIPTOR *NewPpi)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EFI_STATUS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__cdecl *EFI_PEI_LOCATE_PPI)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_SERVICES **PeiServices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_GUID *Guid, UINTN Instance, EFI_PEI_PPI_DESCRIPTOR **PpiDescriptor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **Ppi)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EFI_STATUS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__cdecl *EFI_PEI_NOTIFY_PPI)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_SERVICES **PeiServices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_NOTIFY_DESCRIPTOR *NotifyList)</span></span></span></span>;</code> </pre> <br>  Nous notons seulement qu'en plus des commandes <b>"Appel indirect"</b> qui <b>appellent</b> les proc√©dures / interfaces de la classe "Services PPI", un appel explicite (direct - non tabulaire) √† ces proc√©dures est possible, ce qui se produit parfois dans les modules ex√©cutifs, o√π la structure EFI_PEI_SERVICES est d√©finie / cr√©√©e. <br><br>  Je vais vous dire un petit secret: curieusement, bien que ce soit la table de services ¬´de base¬ª pour la phase PEI, cependant, comme le montre la pratique, elle peut √™tre d√©finie non seulement dans le module PEI_CORE. <br><br>  En r√©alit√©, il existe des firmwares dans lesquels la structure EFI_PEI_SERVICES a √©t√© d√©finie / form√©e et utilis√©e dans plusieurs modules, et ceux-ci n'√©taient en aucun cas des copies du module PEI_CORE. <br><br>  Ainsi, les options de code suivantes sont possibles: <br><br><pre> <code class="cpp hljs">seg000:<span class="hljs-number"><span class="hljs-number">00785F</span></span>0D B8 <span class="hljs-number"><span class="hljs-number">8</span></span>C A6 <span class="hljs-number"><span class="hljs-number">78</span></span>+ mov eax, offset ppiList_78A68C seg000:<span class="hljs-number"><span class="hljs-number">00785F</span></span>12 <span class="hljs-number"><span class="hljs-number">50</span></span> push eax ; PpiList seg000:<span class="hljs-number"><span class="hljs-number">00785F</span></span>13 <span class="hljs-number"><span class="hljs-number">57</span></span> push edi ; PeiServices seg000:<span class="hljs-number"><span class="hljs-number">00785F</span></span>14 <span class="hljs-number"><span class="hljs-number">89</span></span> <span class="hljs-number"><span class="hljs-number">86</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>E+ mov [esi+<span class="hljs-number"><span class="hljs-number">0E40</span></span>h], eax seg000:<span class="hljs-number"><span class="hljs-number">00785F</span></span>1A E8 <span class="hljs-number"><span class="hljs-number">70</span></span> FC FF+ call InstallPpi</code> </pre> <br>  <b>Un exemple d'appel explicite √† la proc√©dure "InstallPpi".</b> <br><br><pre> <code class="cpp hljs">seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CBB <span class="hljs-number"><span class="hljs-number">8B</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>D FC mov ecx, [ebp+PeiServices] seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CBE <span class="hljs-number"><span class="hljs-number">50</span></span> push eax ; PpiList seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CBF C7 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>+ mov dword ptr [eax], <span class="hljs-number"><span class="hljs-number">80000010</span></span>h seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CC5 C7 <span class="hljs-number"><span class="hljs-number">43</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>C A8+ mov dword ptr [ebx+<span class="hljs-number"><span class="hljs-number">3</span></span>Ch], offset guid_78A9A8 seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CCC <span class="hljs-number"><span class="hljs-number">8B</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> mov edx, [ecx] seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CCE <span class="hljs-number"><span class="hljs-number">51</span></span> push ecx ; PeiServices seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CCF FF <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span> call [edx+EFI_PEI_SERVICES.InstallPpi]</code> </pre> <br>  <b>Un exemple d'appel implicite √† l'interface InstallPpi.</b> <br><br><pre> <code class="cpp hljs">FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span> call dword ptr [ecx+<span class="hljs-number"><span class="hljs-number">18</span></span>h] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span> call [ex+EFI_PEI_SERVICES.InstallPpi] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> call dword ptr [ecx+<span class="hljs-number"><span class="hljs-number">1</span></span>Ch] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>C call [ex+EFI_PEI_SERVICES.ReInstallPpi] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> call dword ptr [ecx+<span class="hljs-number"><span class="hljs-number">20</span></span>h] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> call [ex+EFI_PEI_SERVICES.LocatePpi] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span> call dword ptr [ecx+<span class="hljs-number"><span class="hljs-number">24</span></span>h] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span> call [ex+EFI_PEI_SERVICES.NotifyPpi]</code> </pre>  <b>Exemples d'appels d'interface implicites avant et apr√®s l'authentification.</b> <br><br>  On note une caract√©ristique: dans le cas de la phase PEI pour l'architecture IA-32, les interfaces de la classe PPI Services ont des d√©calages de 18h, 1Ch, 20h et 24h. <br><br>  Et maintenant, nous d√©clarons la d√©claration suivante: <br><blockquote>  Pour construire un <u><i>graphe de d√©pendance statique de la</i></u> phase PEI, <b>il est n√©cessaire et suffisant</b> de <u><i>d√©monter compl√®tement</i></u> tous les modules ex√©cutables de la phase (au moins s√©parer toutes les commandes), et de d√©compiler les commandes <b>¬´Appel indirect¬ª</b> avec les d√©calages 18h, 1Ch, 20h, 24h dans les modules d√©sassembl√©s. </blockquote>  En fait, nous avons enti√®rement formul√© un algorithme pour r√©soudre le probl√®me, et d√®s que nous avons r√©ussi √† isoler tous les appels aux interfaces / proc√©dures de la classe PPI Services, il ne reste plus qu'√† d√©terminer quels param√®tres sont pass√©s √† ces appels.  La t√¢che n'est peut-√™tre pas la plus triviale, mais, comme la pratique l'a montr√©, elle est compl√®tement r√©soluble, nous avons toutes les donn√©es pour cela. <br><br>  Et maintenant de vrais exemples de donn√©es r√©elles pour de vrais modules en phase PEI.  Nous n'indiquons pas sciemment les r√©sultats BIOS / UEFI de l'entreprise qui ont √©t√© obtenus, nous donnons simplement des exemples de leur apparence. <br><br><h2>  Deux exemples de descriptions de module PEIM avec des informations compl√®tes sur l'utilisation des interfaces des services PPI dans ces modules </h2><br><pre> <code class="plaintext hljs"> -- File 04-047/0x02F/: "TcgPlatformSetupPeiPolicy" : [007CCAF0 - 007CD144] DEPENDENCY_START EFI_PEI_READ_ONLY_VARIABLE_ACCESS_PPI DEPENDENCY_END Install Protocols: [1] TCG_PLATFORM_SETUP_PEI_POLICY Locate Protocols: [2] EFI_PEI_READ_ONLY_VARIABLE_ACCESS_PPI</code> </pre><pre> <code class="plaintext hljs">-- File 04-048/0x030/: "TcgPei" : [007CD160 - 007CF5DE] DEPENDENCY_START EFI_PEI_MASTER_BOOT_MODE_PEIM_PPI EFI_PEI_READ_ONLY_VARIABLE_ACCESS_PPI AND DEPENDENCY_END Install Protocols: [1] AMI_TCG_PLATFORM_PPI [2] EFI_PEI_TCG_PPI [2] PEI_TPM_PPI Locate Protocols: [1] EFI_PEI_TCG_PPI [1] EFI_PEI_READ_ONLY_VARIABLE_ACCESS_PPI [1] TCG_PLATFORM_SETUP_PEI_POLICY [5] PEI_TPM_PPI Notify Events: [1] AMI_TCM_CALLBACK ReInstall Protocols: [1] PEI_TPM_PPI</code> </pre><br><h2>  Listes de protocoles par types d'interfaces dans lesquels ils ont √©t√© utilis√©s </h2><br>  Sous les spoilers se trouvent ci-dessous des exemples abr√©g√©s de listes de protocoles PPIM pour chacune des interfaces de la classe Services PPI. <br><br>  Le format des listes est le suivant: <br><pre> |  num√©ro de s√©rie |  name_PPI |  guid_PPI |  nom_ex√©cutable: nom d'utilisateur |
</pre><br><div class="spoiler">  <b class="spoiler_title">***** Installez 99 Ppi dans "Firmware"</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/kl/o_/-q/klo_-qpqz-m_lokouctilmlnbxw.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">***** Localisez 194 Ppi dans "Firmware"</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/_i/bl/30/_ibl301bqdkcqk33z-i7ifzqejk.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">***** R√©installez 5 Ppi dans "Firmware"</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/7g/pe/xb/7gpexbxvf_k4sla038anu32el7s.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">***** Avertissez 29 Ppi dans "Firmware"</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ui/fj/m6/uifjm6sznoctafiav_4cez64ezc.png"><br></div></div><br><h2>  La liste finale de tous les guides des protocoles r√©f√©renc√©s dans un BIOS / UEFI particulier avec une l√©gende indiquant dans quels "services PPI" ces protocoles se trouvent </h2><br>  Vous trouverez ci-dessous une liste de spoilers de 97 PPi-guids trouv√©s et explicitement utilis√©s dans un firmware sp√©cifique, dont les donn√©es ont √©t√© fournies plus t√¥t. <br><br>  Chaque √©l√©ment de la liste est pr√©c√©d√© d'une l√©gende, qui refl√®te tous les types d'utilisation d'un protocole particulier. <br><br><pre> <code class="plaintext hljs">"D" - in DEPENDENCY section used "I" - in "InstallPpi" functions used "L" - in "LocatePpi" functions used "R" - in "ReInstallPpi" functions used "N" - in "NotifyPpi" functions used</code> </pre><br><div class="spoiler">  <b class="spoiler_title">***** Liste Ppi dans "Firmware"</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/wn/cm/8y/wncm8ymfrh-8oxdssbu0kuazejc.png"><br><img src="https://habrastorage.org/webt/t1/sn/xq/t1snxq4jhzprqvwoq93ithtlfow.png"><br><img src="https://habrastorage.org/webt/y1/tg/mz/y1tgmz0bysbuzmszkope_hegfoa.png"><br></div></div><br>  Les intervalles de liste de protocoles suivants sont √† noter dans ce BIOS / UEFI: <br><br><ol><li>  N ¬∞ 38-50. <br>  D√©finition de protocoles / √©v√©nements (InstallPpi) qui ne sont utilis√©s par aucun module. </li><li>  No. 87-95. <br>  Essayez de demander des protocoles qui n'ont √©t√© install√©s par aucun module de ce micrologiciel. <br></li><li>  N ¬∞ 96-97. <br>  Deux √©v√©nements ¬´Notify¬ª, pour lesquels aucun module n'a pris la peine de d√©clarer l'interface correspondante, respectivement, bien que ces proc√©dures soient d√©clar√©es dans des modules ex√©cutables, elles ne fonctionneront jamais. </li></ol><br><h2>  Conclusion </h2><br><ul><li>  Des r√©sultats similaires √† ceux ci-dessus ont √©t√© obtenus pour le BIOS / UEFI de divers fabricants, c'est pourquoi tous les exemples sont anonymes. </li><li>  En fait, des t√¢ches plus g√©n√©rales d'inversion des algorithmes des modules BIOS / UEFI ex√©cutables ont √©t√© r√©solues, et le graphique r√©sultant est un r√©sultat secondaire, une sorte de bonus suppl√©mentaire. </li><li><blockquote>  La solution correcte de la t√¢che <i><u>¬´Obtention d'un graphique de d√©pendance statique¬ª</u></i> pour les modules BIOS / UEFI ex√©cutables n√©cessite une analyse statique du code binaire, qui comprend un <i><u>d√©montage complet</u></i> des modules ex√©cutables et <i><u>une d√©compilation partielle des</u></i> commandes d' <b>appel indirect</b> de ces modules. </blockquote></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr440052/">https://habr.com/ru/post/fr440052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr440040/index.html">En d√©veloppement - chacun pour soi. Mais parfois, cela conduit √† une impasse.</a></li>
<li><a href="../fr440044/index.html">Historique d√©taill√© de Qualcomm</a></li>
<li><a href="../fr440046/index.html">Le√ßon ouverte "Cr√©ation de clients REST au printemps"</a></li>
<li><a href="../fr440048/index.html">Statistiques pr√©f√©r√©es: 5 indicateurs que chaque √©quipe commerciale doit suivre</a></li>
<li><a href="../fr440050/index.html">Proxy DNS √† faire soi-m√™me sur Node.JS</a></li>
<li><a href="../fr440054/index.html">Transf√©rer le service Web vers Yandex.Cloud avec AWS</a></li>
<li><a href="../fr440058/index.html">Rapport sur les probl√®mes et la disponibilit√© d'Internet 2018-2019</a></li>
<li><a href="../fr440060/index.html">TensorFlow sur Apache Ignite</a></li>
<li><a href="../fr440062/index.html">Planifier avec plaisir. Comment nous mettons en place des processus sans managers</a></li>
<li><a href="../fr440064/index.html">Centres de donn√©es au choix: Londres, Moscou, Zurich, Saint-P√©tersbourg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>