<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëò üç° üë®üèΩ‚Äçüíº Chariot de camion ROS. Partie 6. Odom√©trie avec encodeurs de roue, plan de salle, lidar üíñ ‚õπüèæ üèß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Messages dans la s√©rie: 
 8. Nous contr√¥lons √† partir du t√©l√©phone-ROS Control, GPS-node 
 7. Localisation du robot: gmapping, AMCL, points de r√©f√©ren...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Chariot de camion ROS. Partie 6. Odom√©trie avec encodeurs de roue, plan de salle, lidar</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471028/"> Messages dans la s√©rie: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">8. Nous contr√¥lons √† partir du t√©l√©phone-ROS Control, GPS-node</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">7. Localisation du robot: gmapping, AMCL, points de r√©f√©rence sur le plan de la salle</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6. Odom√©trie avec encodeurs de roue, plan de salle, lidar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">5. Nous travaillons en rviz et gazebo: xacro, nouveaux capteurs.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4. Cr√©ez une simulation de robot √† l'aide des √©diteurs rviz et gazebo.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3. Acc√©l√©rez, changez la cam√©ra, corrigez la d√©marche</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2. Logiciel</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1. Fer</a> <br><br>  La derni√®re fois, nous avons con√ßu le projet en modules xacro s√©par√©s, ajout√© une cam√©ra vid√©o virtuelle et un imu (gyroscope). <br><br>  Dans cet article, nous travaillerons avec l'odom√©trie √† partir d'encodeurs optiques mont√©s sur des axes de roue, chargerons un plan de salle et le monterons sur un vrai chariot robot. <br><a name="habracut"></a><br><h3>  Odom√©trie et tf </h3><br>  Qu'est-ce que l'odom√©trie et le tf et comment ils sont g√©n√©ralement mis en ≈ìuvre dans ROS est d√©j√† bien d√©crit dans la ressource, nous nous r√©f√©rons donc aux articles pertinents dans la partie th√©orique, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br>  Partant de la base th√©orique, nous travaillerons avec la pratique. <br><br>  Commen√ßons par travailler sur un robot trolley en nous y connectant via VNC. <br><br>  Acc√©dez au dossier rosbots_driver et cr√©ez un n≈ìud de fichier.  Ce fichier va g√©n√©rer l'odom√©trie, le recevoir des encodeurs optiques, qui √† son tour l'envoyer √† Arduino Uno puis √† Raspberry Pi. <br><br><pre><code class="plaintext hljs">cd /home/pi/rosbots_catkin_ws/src/rosbots_driver/scripts/rosbots_driver touch diff-tf.py</code> </pre> <br>  Nous mettons le code dans le fichier: <br><br><div class="spoiler">  <b class="spoiler_title">diff_tf.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python """ diff_tf.py - follows the output of a wheel encoder and creates tf and odometry messages. some code borrowed from the arbotix diff_controller script A good reference: http://rossum.sourceforge.net/papers/DiffSteer/ Copyright (C) 2012 Jon Stephan. """ import rospy #import roslib #roslib.load_manifest('differential_drive') from math import sin, cos, pi from geometry_msgs.msg import Quaternion from geometry_msgs.msg import Twist from geometry_msgs.msg import Vector3 from nav_msgs.msg import Odometry import tf from tf.broadcaster import TransformBroadcaster from std_msgs.msg import Int16, Int32, Int64, UInt32 ############################################################################# class DiffTf: ############################################################################# ############################################################################# def __init__(self): ############################################################################# rospy.init_node("diff_tf") self.nodename = rospy.get_name() rospy.loginfo("-I- %s started" % self.nodename) #### parameters ####### #Wheel radius : 0.0325 # wheel circum = 2* 3.14 * 0.0325 = 0.2041 # One rotation encoder ticks : 8 ticks # For 1 meter: 8 * ( 1 / 0.2041) = 39 ticks self.rate = rospy.get_param('~rate',10.0) # the rate at which to publish the transform self.ticks_meter = float(rospy.get_param('ticks_meter', 190)) # The number of wheel encoder ticks per meter of travel self.base_width = float(rospy.get_param('~base_width', 0.11)) # The wheel base width in meters self.base_frame_id = rospy.get_param('~base_frame_id','base_link') # basefootprint /the name of the base frame of the robot self.odom_frame_id = rospy.get_param('~odom_frame_id', 'odom') # the name of the odometry reference frame self.encoder_min = rospy.get_param('encoder_min', -2147483648) self.encoder_max = rospy.get_param('encoder_max', 2147483648) self.encoder_low_wrap = rospy.get_param('wheel_low_wrap', (self.encoder_max - self.encoder_min) * 0.3 + self.encoder_min ) self.encoder_high_wrap = rospy.get_param('wheel_high_wrap', (self.encoder_max - self.encoder_min) * 0.7 + self.encoder_min ) self.t_delta = rospy.Duration(1.0/self.rate) self.t_next = rospy.Time.now() + self.t_delta # internal data self.enc_left = None # wheel encoder readings self.enc_right = None self.left = 0 # actual values coming back from robot self.right = 0 self.lmult = 0 self.rmult = 0 self.prev_lencoder = 0 self.prev_rencoder = 0 self.x = 0 # position in xy plane self.y = 0 self.th = 0 self.dx = 0 # speeds in x/rotation self.dr = 0 self.yaw = 0.01 self.pitch = 0.01 self.roll = 0.01 self.then = rospy.Time.now() self.quaternion_1 = Quaternion() # subscriptions rospy.Subscriber("wheel_ticks_left", UInt32, self.lwheelCallback) rospy.Subscriber("wheel_ticks_right", UInt32, self.rwheelCallback) #rospy.Subscriber("imu_data", Vector3, self.imu_value_update) self.odomPub = rospy.Publisher("odom", Odometry,queue_size=10) self.odomBroadcaster = TransformBroadcaster() ############################################################################# def spin(self): ############################################################################# r = rospy.Rate(self.rate) while not rospy.is_shutdown(): self.update() r.sleep() ############################################################################# def update(self): ############################################################################# now = rospy.Time.now() if now &gt; self.t_next: elapsed = now - self.then self.then = now elapsed = elapsed.to_sec() # calculate odometry if self.enc_left == None: d_left = 0 d_right = 0 else: d_left = (self.left - self.enc_left) / self.ticks_meter d_right = (self.right - self.enc_right) / self.ticks_meter self.enc_left = self.left self.enc_right = self.right # distance traveled is the average of the two wheels d = ( d_left + d_right ) / 2 # this approximation works (in radians) for small angles th = ( d_right - d_left ) / self.base_width # calculate velocities self.dx = d / elapsed self.dr = th / elapsed if (d != 0): # calculate distance traveled in x and y x = cos( th ) * d y = -sin( th ) * d # calculate the final position of the robot self.x = self.x + ( cos( self.th ) * x - sin( self.th ) * y ) self.y = self.y + ( sin( self.th ) * x + cos( self.th ) * y ) if( th != 0): self.th = self.th + th # publish the odom information quaternion = Quaternion() quaternion.x = 0.0 quaternion.y = 0.0 quaternion.z = sin( self.th / 2 ) quaternion.w = cos( self.th / 2 ) ''' try: quaternion.z = self.quaternion_1[2] quaternion.w = self.quaternion_1[3] except: quaternion.z = sin( self.th / 2 ) quaternion.w = cos( self.th / 2 ) pass ''' self.odomBroadcaster.sendTransform( (self.x, self.y, 0), (quaternion.x, quaternion.y, quaternion.z, quaternion.w), rospy.Time.now(), self.base_frame_id, self.odom_frame_id ) odom = Odometry() odom.header.stamp = now odom.header.frame_id = self.odom_frame_id odom.pose.pose.position.x = self.x odom.pose.pose.position.y = self.y odom.pose.pose.position.z = 0 odom.pose.pose.orientation = quaternion odom.child_frame_id = self.base_frame_id odom.twist.twist.linear.x = self.dx odom.twist.twist.linear.y = 0 odom.twist.twist.angular.z = self.dr self.odomPub.publish(odom) def imu_value_update(self, imu_data): orient = Vector3() orient = imu_data self.yaw = orient.x self.pitch = orient.y self.roll = orient.z try: self.quaternion_1 = tf.transformations.quaternion_from_euler(self.yaw, self.pitch, self.roll) #print self.quaternion_1[0] #print self.quaternion_1[1] #print self.quaternion_1[2] #print self.quaternion_1[3] except: rospy.logwarn("Unable to get quaternion values") pass ############################################################################# def lwheelCallback(self, msg): ############################################################################# enc = msg.data if (enc &lt; self.encoder_low_wrap and self.prev_lencoder &gt; self.encoder_high_wrap): self.lmult = self.lmult + 1 if (enc &gt; self.encoder_high_wrap and self.prev_lencoder &lt; self.encoder_low_wrap): self.lmult = self.lmult - 1 self.left = 1.0 * (enc + self.lmult * (self.encoder_max - self.encoder_min)) self.prev_lencoder = enc ############################################################################# def rwheelCallback(self, msg): ############################################################################# enc = msg.data if(enc &lt; self.encoder_low_wrap and self.prev_rencoder &gt; self.encoder_high_wrap): self.rmult = self.rmult + 1 if(enc &gt; self.encoder_high_wrap and self.prev_rencoder &lt; self.encoder_low_wrap): self.rmult = self.rmult - 1 self.right = 1.0 * (enc + self.rmult * (self.encoder_max - self.encoder_min)) self.prev_rencoder = enc ############################################################################# ############################################################################# if __name__ == '__main__': """ main """ diffTf = DiffTf() diffTf.spin()</span></span></code> </pre><br></div></div><br>  Enregistrez le fichier et rendez-le ex√©cutable: <br> <code>CTRL+X <br> chmod +x diff-tf.py</code> <br> <br>  Maintenant sur le robot, ex√©cutez les 2e noeuds - driver et diff-tf: <br>  1er terminal: <br><br><pre> <code class="plaintext hljs">python diff_tf.py</code> </pre> <br>  2e: <br><br><pre> <code class="plaintext hljs">rosrun rosbots_driver part2_cmr.py</code> </pre> <br>  Dans le 3√®me terminal, nous v√©rifierons qu'il y a de nouveaux sujets odom et tf: <br><br><img src="https://habrastorage.org/webt/zy/tc/rw/zytcrwcee_4-ygvgiwipil9jyxm.png"><br><br>  Voyons avec la commande rostopic echo odom ce qui est publi√© dans le sujet (et s'il est publi√© du tout). <br>  La sortie sera approximativement la suivante: <br><br><img src="https://habrastorage.org/webt/c2/f0/-o/c2f0-onzf3-8gdjtvegw7axrgtw.png"><br><br>  Maintenant, sans fermer les n≈ìuds en cours d'ex√©cution sur le robot, nous allons lancer l'ordinateur de contr√¥le avec les environnements graphiques rviz et gazebo. <br><br>  * Une image (machine virtuelle VMWare avec Ubuntu 16.04 + ROS Kinetic), pr√©c√©demment propos√©e en t√©l√©chargement, contient tout ce dont vous avez besoin. <br><br>  Sur l'ordinateur de contr√¥le (ci-apr√®s d√©nomm√© ¬´ordinateur¬ª), ex√©cutez le mod√®le dans rviz: <br><br><pre> <code class="plaintext hljs">roslaunch rosbots_description rviz.launch</code> </pre> <br>  Le mod√®le de robot charg√© qui a fonctionn√© dans les articles pr√©c√©dents chargera: <br><br><img src="https://habrastorage.org/webt/e2/xf/kb/e2xfkbeuzqsl8g9vcl_ffiz2caa.png"><br><br>  Ajoutez deux √©crans √† rviz en cliquant sur Ajouter.  L'affichage avec odom√©trie et l'affichage avec tf, cochez les cases pour les visualiser. <br><br>  Dans la fen√™tre o√π le mod√®le de robot est repr√©sent√©, des graphiques caract√©ristiques appara√Ætront: <br><br><img src="https://habrastorage.org/webt/i_/p3/r1/i_p3r1fflodksrj2vowmldcmxl0.png"><br>  * Pour le rendre plus visible, vous pouvez d√©sactiver l'affichage Robotmodel. <br><br>  Nous contr√¥lons le robot depuis le clavier de l'ordinateur et voyons comment la visualisation du tf et de l'odom√©trie change. <br><br>  Sans fermer rviz dans le 2√®me terminal, nous allons commencer le contr√¥le depuis le clavier: <br><br><pre> <code class="plaintext hljs">rosrun teleop_twist_keyboard teleop_twist_keyboard.py /cmd_vel:=/part2_cmr/cmd_vel</code> </pre> <br>  Lors du contr√¥le du robot, la fen√™tre de visualisation affichera: fl√®che rouge (visualisation du sujet odom), lignes vectorielles (sujet tf). <br><br>  Si la fl√®che rouge du sujet odom indique la direction du mouvement du robot, alors les lignes vectorielles tf montrent comment les √©l√©ments individuels du robot sont situ√©s dans l'espace: <br><br><div class="spoiler">  <b class="spoiler_title">la vid√©o</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/CC6CO5VIDUA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br>  Maintenant, pour continuer, vous devez ¬´r√©gler¬ª l'odom√©trie. <br>  Pour ce faire, fermez l'√©diteur rviz et red√©marrez-le, uniquement sans visualiser le mod√®le avec la commande: <br><br><pre> <code class="plaintext hljs">rosrun rviz rviz</code> </pre> <br>  Ceci est n√©cessaire pour que seuls base_link et odom restent des vecteurs du sujet tf: <br><br><img src="https://habrastorage.org/webt/x6/qn/fn/x6qnfnbvkzstivryymtyovdnmuw.gif"><br><br>  En rviz, une cellule mesure 1 m√®tre.  Par cons√©quent, en r√©alit√©, le robot doit √©galement passer 1 m√®tre pour que les donn√©es soient comparables. <br><br>  Nous passerons 1 m√®tre sur le robot, en le contr√¥lant depuis le clavier.  En rviz, le robot doit √©galement conduire 1 m√®tre - une cellule. <br><br>  Si le robot voyage plus longtemps qu'il ne devrait l'√™tre dans rviz, ou vice versa, une distance plus courte qu'en r√©alit√©, alors vous devez √©diter le fichier diff_tf.py qui a √©t√© cr√©√© pr√©c√©demment, √† savoir ce bloc: <br><br><div class="spoiler">  <b class="spoiler_title">diff_tf.py</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> #### parameters ####### #Wheel radius : 0.0325 # wheel circum = 2* 3.14 * 0.0325 = 0.2041 # One rotation encoder ticks : 8 ticks # For 1 meter: 8 * ( 1 / 0.2041) = 39 ticks self.rate = rospy.get_param('~rate',10.0) # the rate at which to publish the transform self.ticks_meter = float(rospy.get_param('ticks_meter', 190)) # The number of wheel encoder ticks per meter of travel self.base_width = float(rospy.get_param('~base_width', 0.11)) # The wheel base width in meters</code> </pre> <br></div></div><br><h3>  La carte </h3><br>  Pour aller quelque part, vous avez besoin d'une carte.  Pour les besoins de notre robot - nous avons besoin d'un plan de salle. <br>  Travaillons avec elle. <br><br>  Pour t√©l√©charger une carte sur rviz, vous devez cr√©er un dossier de carte dans le projet (rosbots_description) sur l'ordinateur (pas sur le robot) et y mettre deux fichiers qui composent la carte: map.pgm et map.yaml. <br>  * En fait, il peut y avoir plusieurs fichiers de carte dans un dossier, mais vous ne pouvez en t√©l√©charger qu'un dans l'assistant. <br><br>  Une carte dans ROS se compose de deux fichiers, dont l'un est une image PGM, o√π chaque pixel est soit: <br><br><ul><li>  blanc - l'espace est libre; </li><li>  noir - l'espace est occup√© par un obstacle; </li><li>  l'espace gris n'a pas encore √©t√© explor√©. </li></ul><br>  Le deuxi√®me fichier .yaml est un fichier avec les param√®tres de la carte, o√π ses dimensions, l'occupation des pixels avec diff√©rents types (r√©pertori√©s ci-dessus), d'autres param√®tres sont indiqu√©s. <br><br>  Ex√©cutez le n≈ìud sur l'ordinateur qui publiera la carte: <br><br><pre> <code class="plaintext hljs">rosrun map_server map_server /home/pi/catkin_ws/src/rosbots_description/maps/rail_lab.pgm 0.05</code> </pre> <br>  Dans le terminal voisin, ex√©cutez le mod√®le dans rviz: <br><br><pre> <code class="plaintext hljs">roslaunch rosbots_description rviz.launch</code> </pre> <br>  Dans rviz, ajoutez un affichage de carte. <br><br>  Dans rviz, le robot s'est av√©r√© √™tre de taille disproportionn√©e et est situ√© hors de la carte: <br><br><img src="https://habrastorage.org/webt/h6/ob/8g/h6ob8gyq_u11omb3bzneqczgkra.gif"><br><br>  Pour r√©soudre ce probl√®me, vous devez ex√©cuter une carte o√π la taille des cellules sera de 1 m√®tre.  Red√©marrez la carte avec le param√®tre 1 √† la fin: <br><br><pre> <code class="plaintext hljs">rosrun map_server map_server /home/pi/catkin_ws/src/rosbots_description/maps/rail_lab.pgm 1</code> </pre> <br>  Vous pouvez maintenant parcourir la carte dans rviz, en contr√¥lant le robot depuis le clavier: <br><br><div class="spoiler">  <b class="spoiler_title">la vid√©o</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/bbsn97FUNnI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br>  <b>Alors, ce qui a √©t√© r√©alis√©</b> : <br><br><ul><li>  recevoir les donn√©es d'odom√©trie des encodeurs de roue optique du robot et les envoyer aux sujets pour les afficher dans rviz; </li><li>  configurer l'odom√©trie du robot pour correspondre √† la distance parcourue en direct et virtuellement; </li><li>  charger et afficher un plan de salle. </li></ul><br>  Cependant, malgr√© le fait que la carte soit affich√©e et que le robot puisse y rouler avec une odom√©trie ¬´r√©gl√©e¬ª, en r√©alit√© le robot est aveugle.  Il ne voit aucun obstacle et tombera sur eux.  Le deuxi√®me inconv√©nient est le plan de salle virtuel charg√© dans rviz vous permet de rouler seul dans toutes les directions, m√™me dans celles o√π les obstacles sont clairement indiqu√©s. <br><br>  Comment faire ¬´voir¬ª les obstacles au robot dans la r√©alit√© et virtuellement? <br><br>  Avec un environnement virtuel, c'est plus simple.  Tout ici est bas√© sur l'√©mulateur-√©diteur de gazebo.  Et dans les messages pr√©c√©dents, cela a √©t√© mentionn√©. <br><br>  C'est plus compliqu√© avec la r√©alit√©.  Nous avons besoin d'un √©l√©ment (capteur) qui indiquera les obstacles et le signalera au syst√®me. <br><br>  Une option consiste √† mettre du lidar sur le robot. <br><br><h3>  Lidar RPlidar A1 </h3><br>  Nous utiliserons la solution √©conomique et mettrons le lidar sur le robot.  Peut-√™tre que cette solution sera plus ch√®re que d'utiliser le m√™me Kinect, mais, comme la pratique l'a montr√©, elle est plus efficace en termes de vitesse, de pr√©cision et de facilit√© d'installation (moins lourde).  De plus, il est plus facile de commencer √† travailler avec le lidar, car  Aucune r√©flexion n'est n√©cessaire sur la fa√ßon de l'alimenter et de le connecter au projet (https://habr.com/en/company/tod/blog/210252/). <br><br>  Nous aurons besoin du paquet ros pour travailler avec lidar - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wiki.ros.org/rplidar</a> . <br>  Avec l'aide du lidar, nous allons construire une carte de la pi√®ce et l'utiliser √©galement dans la navigation. <br><br>  Comment installer rplidar dans ROS a beaucoup d'articles, par exemple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Nous utiliserons les connaissances des vieillards aux cheveux gris et installerons des packages avec lidar dans le syst√®me <u>du robot</u> : <br><br><pre> <code class="plaintext hljs">cd /home/pi/rosbots_catkin_ws/src git clone https://github.com/robopeak/rplidar_ros.git cd .. catkin_make</code> </pre> <br>  Sur l' <u>ordinateur,</u> installez le package pour travailler avec la carte: <br><br><pre> <code class="plaintext hljs">cd /home/pi/rosbots_catkin_ws/src git clone https://github.com/tu-darmstadt-ros-pkg/hector_slam &lt;/code&gt; cd .. catkin_make</code> </pre> <br>  Ex√©cutez le package sur le robot et v√©rifiez si le lidar fonctionne: <br><br><pre> <code class="plaintext hljs">sudo chmod a+rw /dev/ttyUSB0 roslaunch rplidar_ros rplidar.launch</code> </pre> <br>  * La premi√®re commande donne acc√®s au port USB o√π le lidar est connect√©. <br><br>  Si tout s'est bien pass√©, il affichera des lignes sur la console: <br><br><pre> <code class="plaintext hljs">[ INFO] [1570900184.874891236]: RPLIDAR running on ROS package rplidar_ros. SDK Version:1.9.0 RPLIDAR S/N: ---------------- [ INFO] [1570900187.397858270]: Firmware Ver: 1.24 [ INFO] [1570900187.398081809]: Hardware Rev: 5 [ INFO] [1570900187.401749476]: RPLidar health status : 0 [ INFO] [1570900188.014285166]: current scan mode: Express, max_distance: 12.0 m, Point number: 4.0K , angle_compensate: 1</code> </pre> <br>  Ici, nous configurons imm√©diatement un petit lidar, car  le site <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">officiel</a> dit qu'il (lidar) peut mieux fonctionner. <br><br>  Nous devons obtenir la sortie lorsque la num√©risation n'est pas de 4,0K points, qui sont √©mis par d√©faut, mais de 8,0K.  Cette option am√©liorera l√©g√®rement la qualit√© de la num√©risation. <br><br>  Pour cela, nous allons d√©finir un param√®tre suppl√©mentaire dans le package rplidar - mode scan: <br><br><pre> <code class="plaintext hljs">cd /rosbots_catkin_ws/src/rplidar_ros/launch nano nano rplidar.launch</code> </pre> <br>  Et apr√®s <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">param</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"angle_compensate"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"bool"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag">/&gt;</span></span></code> </pre>  ajoutez la ligne: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">param</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"scan_mode"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"string"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Boost"</span></span></span><span class="hljs-tag">/&gt;</span></span></code> </pre> <br>  La deuxi√®me ligne qui doit √™tre corrig√©e ici: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">param</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"frame_id"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"string"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"laser"</span></span></span><span class="hljs-tag">/&gt;</span></span></code> </pre> <br>  Remplacez la valeur laser par base_link. <br><br>  * Maintenant, si vous red√©marrez le n≈ìud avec la commande roslaunch rplidar_ros rplidar.launch, la sortie sera diff√©rente: <br><br><pre> <code class="plaintext hljs">[ INFO] [1570900188.014285166]: current scan mode: Boost, max_distance: 12.0 m, Point number: 8.0K , angle_compensate: 1</code> </pre> <br>  Jetez un oeil.  qui affiche lidar dans rviz. <br><br>  Pour ce faire, ex√©cutez sur le robot: <br><br><pre> <code class="plaintext hljs">roslaunch rplidar_ros rplidar.launch</code> </pre> <br>  Sur un ordinateur: <br><br><pre> <code class="plaintext hljs">roslaunch rosbots_description rviz.launch</code> </pre> <br>  Dans rviz, ajoutez l'affichage LaserScan et s√©lectionnez la rubrique de num√©risation.  De plus, on verra que les messages tombent dans le sujet: <br><br><img src="https://habrastorage.org/webt/mg/mo/6p/mgmo6p_pyjzofzrfyxwj5ollnrw.gif"><br><br>  Dans la fen√™tre avec la visualisation du robot, le robot s'est av√©r√© √™tre un g√©ant.  Avec sa taille, nous le d√©couvrirons plus tard.  Construisons maintenant un plan de salle. <br><br>  Pour ce faire, cr√©ez un package avec un n≈ìud: <br><br><pre> <code class="plaintext hljs">catkin_create_pkg my_hector_mapping rospy cd my_hector_mapping mkdir launch cd launch nano hector.launch</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">hector.launch</b> <div class="spoiler_text"><pre> <code class="python hljs">&lt;?xml version=<span class="hljs-string"><span class="hljs-string">"1.0"</span></span>?&gt; &lt;launch&gt; &lt;node pkg=<span class="hljs-string"><span class="hljs-string">"tf"</span></span> type=<span class="hljs-string"><span class="hljs-string">"static_transform_publisher"</span></span> name=<span class="hljs-string"><span class="hljs-string">"laser_link"</span></span> args=<span class="hljs-string"><span class="hljs-string">"0.0 0.0 0.0 0.0 0.0 0.0 /base_link /laser 50"</span></span> /&gt; &lt;node pkg=<span class="hljs-string"><span class="hljs-string">"hector_mapping"</span></span> type=<span class="hljs-string"><span class="hljs-string">"hector_mapping"</span></span> name=<span class="hljs-string"><span class="hljs-string">"hector_mapping"</span></span> output=<span class="hljs-string"><span class="hljs-string">"screen"</span></span>&gt; &lt;!-- Frame names --&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"map_frame"</span></span> value=<span class="hljs-string"><span class="hljs-string">"map"</span></span> /&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"odom_frame"</span></span> value=<span class="hljs-string"><span class="hljs-string">"base_link"</span></span> /&gt; &lt;!-- Map size / start point --&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"map_resolution"</span></span> value=<span class="hljs-string"><span class="hljs-string">"0.050"</span></span>/&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"map_size"</span></span> value=<span class="hljs-string"><span class="hljs-string">"1024"</span></span>/&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"map_start_x"</span></span> value=<span class="hljs-string"><span class="hljs-string">"0.5"</span></span>/&gt; //  &lt;param name=<span class="hljs-string"><span class="hljs-string">"map_start_y"</span></span> value=<span class="hljs-string"><span class="hljs-string">"0.5"</span></span> /&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"map_multi_res_levels"</span></span> value=<span class="hljs-string"><span class="hljs-string">"2"</span></span> /&gt; &lt;!-- Map update parameters --&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"update_factor_free"</span></span> value=<span class="hljs-string"><span class="hljs-string">"0.4"</span></span>/&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"update_factor_occupied"</span></span> value=<span class="hljs-string"><span class="hljs-string">"0.9"</span></span> /&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"map_update_distance_thresh"</span></span> value=<span class="hljs-string"><span class="hljs-string">"0.4"</span></span>/&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"map_update_angle_thresh"</span></span> value=<span class="hljs-string"><span class="hljs-string">"0.06"</span></span> /&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"laser_z_min_value"</span></span> value=<span class="hljs-string"><span class="hljs-string">"-1.0"</span></span> /&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"laser_z_max_value"</span></span> value=<span class="hljs-string"><span class="hljs-string">"1.0"</span></span> /&gt; &lt;!-- Advertising config --&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"advertise_map_service"</span></span> value=<span class="hljs-string"><span class="hljs-string">"true"</span></span>/&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"scan_subscriber_queue_size"</span></span> value=<span class="hljs-string"><span class="hljs-string">"5"</span></span>/&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"scan_topic"</span></span> value=<span class="hljs-string"><span class="hljs-string">"scan"</span></span>/&gt; &lt;/node&gt; &lt;/launch&gt;</code> </pre><br></div></div><br><pre> <code class="plaintext hljs">cd ~/rosbots_catkin_ws catkin_make</code> </pre> <br>  Lan√ßons-le. <br><br>  Sur le robot: <br><br>  1er terminal: <code>roslaunch rplidar_ros rplidar.launch</code> <br>  2√®me: <code>rosrun rosbots_driver part2_cmr.py</code> <br><br>  Sur un ordinateur: <br><br>  1er terminal: <code>roslaunch my_hector_mapping hector.launch</code> <br>  2e: <code>roslaunch rosbots_description rviz.launch</code> <br>  3e: <code>rosrun teleop_twist_keyboard teleop_twist_keyboard.py /cmd_vel:=/part2_cmr/cmd_vel</code> <br><br>  Dans les √©crans, vous devez ajouter une carte et un cadre fixe s√©lectionnez base_link.  Ensuite, vous pouvez observer en temps r√©el comment le lidar "illumine" l'espace autour de lui: <br><br><img src="https://habrastorage.org/webt/-6/gv/gq/-6gvgqgtmggjf7ffvnwlr1w6gwa.jpeg"><br><br>  √Ä l'√©tape actuelle, pour construire une carte, vous devez faire le tour de la pi√®ce, en vous ¬´arr√™tant¬ª √† diff√©rents angles pour que le lidar les marque sur la carte. <br><br>  Je recommande donc les manuels.  Mais notre conseil est de prendre le robot et de marcher avec lui, en le tenant devant vous.  Ainsi, la vitesse de construction d'une carte sera plus grande dans le sens o√π vous n'aurez pas √† √™tre distrait et √† regarder o√π le robot a conduit dans la pi√®ce voisine en l'absence de contact visuel. <br><br>  De plus, lors de la rotation du robot autour de son axe pendant un voyage, le lidar laisse des artefacts noirs caract√©ristiques dans les endroits o√π il n'y a en fait aucun obstacle: <br><br><img src="https://habrastorage.org/webt/wf/tn/0y/wftn0yxvutj6keza4jhqngsasai.jpeg"><br><br>  Apr√®s avoir construit la carte, enregistrez-la avec la commande: <br><br><pre> <code class="plaintext hljs">rosrun map_server map_saver -f map-1</code> </pre> <br>  Construire la carte parfaite avec un lidar √©conomique est un mythe.  Par cons√©quent, nous allons aider le lidar dans Photoshop.  Nous allons supprimer les artefacts noirs de la carte, o√π il n'y a vraiment aucun obstacle, et aligner les murs avec des lignes noires: <br><br><img src="https://habrastorage.org/webt/-k/xv/fo/-kxvfoxyjflij37fvy_ntw2d-ic.jpeg"><br><br>  N'oubliez pas de sauvegarder la carte au format .pgm. <br><br>  Maintenant, nous r√©p√©tons sur l'ordinateur les commandes qui √©taient au d√©but du post, mais avec une nouvelle carte: <br>  1er terminal: <code>rosrun map_server maserver /home/pi/catkin_ws/src/rosbots_description/maps/map-1.pgm 0.05</code> <br>  2e: <code>roslaunch rosbots_description rviz.launch</code> <br><br>  R√©sultat dans rviz: <br><br><img src="https://habrastorage.org/webt/g1/g9/mj/g1g9mjpl0nwsgfumdmpmrvvem4q.jpeg"><br><br>  La nouvelle carte est charg√©e, comme le mod√®le de robot dessus, mais le robot est en dehors de la carte. <br><br>  Nous en reparlerons plus tard, mais pour l'instant, r√©sumons: <br><br><ul><li>  ma√Ætriser le lidar RP-lidar A1 </li><li>  construire un plan de pi√®ce √† l'aide d'un lidar, l'ajuster et le charger dans l'√©diteur visuel rviz. </li></ul><br>  Fichiers √† t√©l√©charger: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plan de salle</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr471028/">https://habr.com/ru/post/fr471028/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr471018/index.html">Comparaison des performances du PC et du smartphone, y compris l'iPhone 11</a></li>
<li><a href="../fr471020/index.html">Comment trouver un bug dans un microprocesseur sorti il ‚Äã‚Äãy a trente-cinq ans</a></li>
<li><a href="../fr471022/index.html">R√©v√©ler un secret de 140 ans en physique</a></li>
<li><a href="../fr471024/index.html">Analyse: que sont les futures et comment les utiliser pour des investissements en devises</a></li>
<li><a href="../fr471026/index.html">TypeScript Puissance jamais</a></li>
<li><a href="../fr471032/index.html">Photo invisible</a></li>
<li><a href="../fr471034/index.html">Entretien avec Pornhub Web Developer</a></li>
<li><a href="../fr471036/index.html">Vivez et apprenez. Partie 5. Auto-√©ducation: ressaisissez-vous</a></li>
<li><a href="../fr471038/index.html">Fichier descripteur Linux avec des exemples</a></li>
<li><a href="../fr471040/index.html">[signet] Version PDF et ePUB du manuel React</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>