<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÉüèª ü§∑üèæ üññüèø Lambda funktioniert in SQL ... denken wir mal üë©üèª‚Äçüî¨ ‚ôæ ü§∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Worum es in dem Artikel geht, und so impliziert der Name. 

 Dar√ºber hinaus wird der Autor erkl√§ren, warum dies aus seiner Sicht notwendig ist, und er...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lambda funktioniert in SQL ... denken wir mal</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435120/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sl/ch/fp/slchfpm_a-deoh62fqiazjgdc5k.png" alt="Bild"></div><br>  Worum es in dem Artikel geht, und so impliziert der Name. <br><br>  Dar√ºber hinaus wird der Autor erkl√§ren, warum dies aus seiner Sicht notwendig ist, und erkl√§ren, dass SUBJ nicht nur eine modische Technologie ist, sondern auch ‚Äûein doppelt notwendiges Gesch√§ft - sowohl angenehm als auch n√ºtzlich‚Äú. <br><a name="habracut"></a><br>  Es ist immer wieder interessant zu sehen, wie mehrere talentierte Leute etwas tun (eine Programmiersprache, warum nicht) und genau wissen, welches Problem sie l√∂sen und welche Aufgaben sie sich stellen.  Und testen Sie auch ihre Kreation an sich selbst.  Es kann nicht mit den monumentalen Kreationen riesiger Komitees verglichen werden, die die Aufrechterhaltung der Harmonie des Universums in den Vordergrund stellen und wer sie versteht. <br><br>  Vergleichen Sie zum Beispiel das Schicksal von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FORTRAN</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PL / 1</a> .  Wer wird sich jetzt an diesen PL / 1 erinnern? <br><br>  Aus dieser Sicht ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AWK</a> beispielsweise sehr erfolgreich.  Es ist erw√§hnenswert, dass in seinem Namen A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alfred Aho</a> , einer der Autoren des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Drachenbuchs</a> , W <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Peter Weinberger ist</a> , der an Fortran-77 beteiligt war, K <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Brian Kernigan ist</a> , wo er ohne ihn w√§re.  Die Sprache ist f√ºr die Verarbeitung von Textstr√∂men im laufenden Betrieb in Pipes zwischen Prozessen vorgesehen. <br><br>  Die Sprache ist typenlos ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dies ist nicht ganz richtig</a> ), ihre Syntax ist C sehr √§hnlich, sie verf√ºgt √ºber Filterfunktionen, assoziative Arrays, Stream-Start / Ende-Ereignisse, Newline-Ereignisse ... <br><br>  Der Autor war von dieser Sprache immer beeindruckt, auch von der Tatsache, dass sein Interpreter nicht installiert werden muss, unter UNIX-√§hnlichen Systemen immer vorhanden ist und unter Windows ausreicht, nur die ausf√ºhrbare Datei zu kopieren und alles funktioniert.  Dies ist jedoch nicht der Fall. <br><br>  Dabei muss der Autor das SQL + AWK-Bundle h√§ufig verwenden, und deshalb.  SQL ist nach wie vor eine deklarative Sprache zur Steuerung des Datenflusses.  Es bietet nur sehr begrenzte M√∂glichkeiten, mit dem Kontext der Abfrageausf√ºhrung in Form von Aggregatfunktionen zu arbeiten. <br><br>  Wie kann man beispielsweise ein zweidimensionales Histogramm mit SQL erstellen? <br><br><pre><code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--   100 x 100 SELECT count(), round(x, -2) AS cx, round(y, -2) AS cy FROM samples GROUP BY cx, xy</span></span></code> </pre> <br>  Angenommen, die Verwendung von GROUP BY impliziert das Sortieren. Wenn Sie Hunderte von Millionen (oder sogar mehr) Zeilen haben, ist dies kein billiges Vergn√ºgen. <br><div class="spoiler">  <b class="spoiler_title">UPD: In den Kommentaren haben sie mich korrigiert, dass dies nicht ganz richtig ist (oder √ºberhaupt nicht)</b> <div class="spoiler_text">  Der SQL-Prozessor kann beim Erstellen eines Hashs gem√§√ü dem Gruppierungskriterium Aggregatfunktionen ausf√ºhren.  Dazu ist es notwendig, dass es √ºber gen√ºgend freien Speicher verf√ºgt, um die Hash-Map im Speicher abzulegen. <br><br>  Dann werden die Kontexte der Gruppen aktualisiert, wenn die Tabelle gelesen wird, und am Ende dieses Lesens haben wir bereits das berechnete Ergebnis. <br>  Die gleiche Technik kann auf Fensterfunktionen (unten) erweitert werden, nur der Kontext wird "dicker". <br><br>  Wenn die Anzahl der Gruppen im Voraus unbekannt oder sehr gro√ü ist, muss der SQL-Prozessor einen tempor√§ren Index erstellen und diesen in einem zweiten Durchgang ausf√ºhren. <br><br>  In einfachen F√§llen, wie hier, wie hier - ein einfacher COUNT, eine universelle Option ist m√∂glich - ein tempor√§rer Index (cx, cy, count), dann wird bei einer kleinen Anzahl von Gruppen alles auf zwischengespeicherten Seiten gespeichert.  In komplexen F√§llen, Fensterfunktionen, wird der Zustand der Gruppe nicht trivial und die st√§ndige (De-) Serialisierung entspricht √ºberhaupt nicht den Anweisungen des Arztes. <br></div></div>  Zusammenfassung: Der SQL-Prozessor greift zum Sortieren zur√ºck, wenn er die Anzahl der Gruppen nach GROUP BY nicht sch√§tzen kann.  Die Gruppierung nach berechneten Werten ist jedoch (oft) genau der Fall. <br><br>  Deshalb m√ºssen Sie etwas tun wie: <br><br><pre> <code class="bash hljs">psql -t -q -c <span class="hljs-string"><span class="hljs-string">'select x, y from samples'</span></span> | gawk -f mk_hist2d.awk</code> </pre> <br>  Dabei sammelt mk_hist2d.awk Statistiken im assoziativen Array und zeigt sie nach Abschluss der Arbeit an <br><br><pre> <code class="cpp hljs"># mk_hist2d.awk { bucket[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>($<span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-number"><span class="hljs-number">0.01</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>($<span class="hljs-number"><span class="hljs-number">3</span></span>*<span class="hljs-number"><span class="hljs-number">0.01</span></span>)]+=$<span class="hljs-number"><span class="hljs-number">1</span></span>; } END { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">500</span></span>; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">500</span></span>; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((i, j) in bucket) print i*<span class="hljs-number"><span class="hljs-number">100.</span></span><span class="hljs-string"><span class="hljs-string">" "</span></span>j*<span class="hljs-number"><span class="hljs-number">100.</span></span><span class="hljs-string"><span class="hljs-string">" "</span></span>bucket[i, j]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> print i*<span class="hljs-number"><span class="hljs-number">100.</span></span><span class="hljs-string"><span class="hljs-string">" "</span></span>j*<span class="hljs-number"><span class="hljs-number">100.</span></span><span class="hljs-string"><span class="hljs-string">" 0"</span></span>; } }</code> </pre><br>  Es gibt einen ABER - der gesamte Datenstrom muss vom Server an die Arbeitsmaschine gesendet werden, und das ist nicht so billig. <br><br>  Ist es m√∂glich, das Angenehme mit dem N√ºtzlichen zu kombinieren - um w√§hrend der Ausf√ºhrung der SQL-Abfrage Statistiken zu sammeln, ohne jedoch zu sortieren?  Ja, zum Beispiel mit benutzerdefinierten Aggregatfunktionen. <br><br><h4>  Benutzerdefinierte Aggregatfunktionen </h4><br>  Subj ist in verschiedenen Systemen vorhanden, √ºberall wird es ein wenig auf seine eigene Weise gemacht. <br><br><ol><li>  <b>PostgreSQL</b>  Die Dokumentation finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Weitere Details <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br>  Hier wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der</a> maximale Kontostand berechnet. <br>  Und dies ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel</a> , das berechnet, was mehr in der booleschen Spalte steht - wahr oder falsch. <br><br>  Es sieht so aus - <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AGGREGATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mode</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">boolean</span></span>) ( SFUNC = mode_bool_state, STYPE = <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span>[], FINALFUNC = mode_bool_final, INITCOND = <span class="hljs-string"><span class="hljs-string">'{0,0}'</span></span> );</code> </pre><br>  Hier ist <b>SFUNC</b> eine Funktion, die f√ºr jede Zeile im Stream aufgerufen wird. <br>  Das erste Argument ist vom Typ <b>STYPE</b> . <br><br>  <b>FINALFUNC</b> wird verwendet, um die Berechnungen abzuschlie√üen und den Wert des Aggregats zur√ºckzugeben. <br>  <b>INITCOND</b> - Initialisierung des Anfangswertes des internen Zustands ( <b>STYPE</b> ), der als erstes Argument √ºbergeben wurde. <br>  Da Funktionen in C geschrieben werden k√∂nnen (was bedeutet, dass Sie f√ºr den internen Status den Speicher verwenden k√∂nnen, der beim Schlie√üen der Anforderung automatisch freigegeben wird), ist dies ein sehr leistungsf√§higes Tool.  Au√üerhalb des Anwendungsbereichs muss man noch gehen k√∂nnen. </li><li>  <b>MS SQL</b> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zuvor</a> (2000) war es vor der Anforderung erforderlich, ein ActiveX-Objekt zu erstellen, um die Aggregation mit diesem Objekt durchzuf√ºhren. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jetzt</a> (2016+) erfolgt dies in der CLR-Umgebung.  Sie m√ºssen eine benutzerdefinierte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktion</a> erstellen, eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Baugruppe</a> erstellen und registrieren.  Dann k√∂nnen Sie ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aggregat</a> erstellen. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein Beispiel f√ºr die</a> Berechnung des geometrischen Mittelwerts sowie f√ºr das Zusammenf√ºhren von Zeichenfolgen: mit zus√§tzlichen Parametern und einem benutzerdefinierten Typ zum Speichern eines Zwischenzustands. </li><li>  <b>Oracle</b> <br>  In Oracle erfolgt dies mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ODCIAggregate-Datenkassette</a> (Schnittstelle). <br>  Um ein eigenes Aggregat zu erstellen, m√ºssen Sie einen benutzerdefinierten Typ schreiben, der 4 Methoden implementiert <br>  - Die statische Initialisierung (ODCIAggregateInitialize) sollte eine Instanz des gew√ºnschten Typs erstellen und √ºber den Parameter zur√ºckkehren <br>  - Iterationen (ODCIAggregateIterate), die f√ºr jede Datenzeile aufgerufen werden <br>  - Merge (ODCIAggregateMerge), mit dem parallel ausgef√ºhrte Aggregate zusammengef√ºhrt werden <br>  - finish (ODCIAggregateTerminate) - Ergebnisausgabe <br>  Beispiele: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4</a> . </li><li>  <b>DB2</b> <br>  Es gibt keine explizite M√∂glichkeit, benutzerdefinierte Aggregate in DB2 zu verwenden. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie k√∂nnen jedoch</a> eine Standardfunktion (wenn auch MAX) in einen benutzerdefinierten Typ (in Java) einf√ºgen und das System dazu bringen, Abfragen des Formulars auszuf√ºhren <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> Complex <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-built_in"><span class="hljs-built_in">real</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DOUBLE</span></span>, i <span class="hljs-keyword"><span class="hljs-keyword">DOUBLE</span></span> ) ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> complexNumbers ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">number</span></span> Complex ) ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum..real, sum..i <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> GetAggrResult(<span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>(BuildComplexSum(<span class="hljs-built_in"><span class="hljs-built_in">number</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> complexNumbers ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>)</code> </pre></li></ol><br>  Was ist in all diesen Systemen bemerkenswert? <br><br><ul><li>  Auf die eine oder andere Weise m√ºssen Sie einige Objekte in der Datenbank erstellen.  Sei es AGGREGATE oder TYPE.  Zumindest sind entsprechende Rechte erforderlich.  <i>Und m√∂chte nur ein paar Zahlen auf sein Knie setzen.</i> <br></li><li>  M√∂glicherweise m√ºssen Sie etwas in einer anderen Sprache schreiben, sei es C, C # oder Java. <br>  Um das, was geschrieben ist, in das System zu integrieren, sind wiederum Rechte erforderlich.  <i>Aber alles was ich will ...</i> <br></li><li>  Schwierigkeiten beim Initialisieren.  Angenommen, Sie m√∂chten Histogramme mit unterschiedlichen Korbgr√∂√üen lesen.  Es scheint einfacher zu sein - wir geben die gew√ºnschte INITCOND an, wenn wir das Aggregat (PostgreSQL) und das gesamte Unternehmen deklarieren.  Aber dann ben√∂tigen Sie f√ºr jede Gr√∂√üe des Warenkorbs Ihr eigenes Aggregat, und auch hierf√ºr sind die Rechte erforderlich. <br><br>  Hier k√∂nnen Sie auf einen schmutzigen Trick zur√ºckgreifen und den Union-Prozessor aus der Initialisierungszeile (vorw√§rts) und den Daten entfernen. Erstellen Sie den Kontext nicht im Konstruktor, sondern wenn die erste Zeile empfangen wird. <br></li><li>  Trotz der beschriebenen Einschr√§nkungen k√∂nnen Sie mit benutzerdefinierten Aggregaten alles berechnen. <br></li><li>  Es ist wichtig, dass <u>Aggregate parallelisiert werden k√∂nnen</u> , zumindest PostgreSQL, und Oracle (Enterprise Edition) kann dies tun.  Dazu muss die Wahrheit lernen, wie man Zwischenzust√§nde serialisiert / deserialisiert und sie aus verschiedenen Streams einfriert. </li></ul><br><h4>  Fensterfunktionen </h4><br>  Fensterfunktionen wurden im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SQL: 2003-</a> Standard angezeigt.  Im Moment werden sie von allen oben genannten Systemen unterst√ºtzt.  Fensterfunktionen sind im Wesentlichen eine Erweiterung der Arbeit mit Einheiten.  Benutzerdefinierte Aggregatfunktionen funktionieren nat√ºrlich auch in einem Fensterkontext. <br><br>  Die Erweiterung ist dies.  Vor SQL: 2003 arbeiteten Aggregatfunktionen in einem bestimmten Fenster, das entweder die gesamte Ergebnismenge oder deren Teil war und der Kombination von Feldwerten aus dem GROUP BY-Ausdruck entsprach.  Der Benutzer hat jetzt einige Freiheiten bei der Bearbeitung dieses Fensters. <br><br>  Der Unterschied besteht darin, dass die mithilfe der Fenster berechneten Werte in einer separaten Spalte zur Ausgabe hinzugef√ºgt werden und nicht erforderlich ist, dass der gesamte Stream mithilfe von Aggregatfunktionen zusammenf√§llt.  In einer Anfrage k√∂nnen Sie also mehrere Fensteraggregate jeweils in einem eigenen Kontext (Fenster) verwenden.  Es konnte vorher mehrere Aggregatfunktionen geben, aber alle funktionierten in einem Fenster. <br><br>  Gro√üe Striche <br><br><ul><li>  <b>Over ()</b> <br>  Das Fenster ist die gesamte Ergebnismenge.  Angenommen, die Abfrage ' <i>select count (1) from Samples</i> ' gibt 169 zur√ºck. In diesem Fall erhalten wir beim Ausf√ºhren von ' <i>select count (1) over () from Samples</i> ' eine Spalte, die 169-mal 169-mal geschrieben wird. </li><li>  <b>√úBER (TEILUNG DURCH)</b> <br>  Es ist ein Analogon zu GROUP BY. F√ºr jede Wertekombination wird ein Fenster erstellt, in dem Aggregatfunktionen ausgef√ºhrt werden.  Angenommen, in der Samples-Tabelle ist eine Ganzzahlspalte val, die Daten sind Zahlen von 1 bis 169. <br>  Dann gibt die Abfrage ' <i>select count (1) over (Partition by (12 + val) / 13) from Samples</i> ' eine Spalte zur√ºck, in die der Wert 13 169 Mal geschrieben wird. <br></li><li>  <b>√úBER (BESTELLEN NACH)</b> <br>  kann mit PARTITION BY kombiniert werden, erm√∂glicht es Ihnen, die Gr√∂√üe des Fensters w√§hrend des Cursors dynamisch zu √§ndern. In diesem Fall erstreckt sich das Fenster vom Anfang der Gruppe bis zur aktuellen Cursorposition.  Infolgedessen ergibt sich f√ºr die Gruppe nicht derselbe Wert in der Aggregatspalte, sondern der eigene.  Praktisch f√ºr die Berechnung der kumulierten Betr√§ge.  Abfrageergebnis <br>  <i>'Summe (Wert) √ºber (Reihenfolge nach Wert) aus Stichproben ausw√§hlen</i> ' ist eine Spalte, in der das n-te Element die Summe der nat√ºrlichen Zahlen von 1 bis n enth√§lt. </li><li>  <b>√úBER (REIHEN)</b> <br>  Mit dieser Option k√∂nnen Sie die Fensterrahmen ausgehend von der Cursorposition oder dem Anfang / Ende des ORDER BY-Bereichs definieren. <br><br>  Beispiel: " <i>... REIHEN 1 VORHER ...</i> " bedeutet, dass das Fenster aus der aktuellen Zeile und 1 davor besteht.  A ' <i>... REIHEN ZWISCHEN 1 FOLGENDEN UND 2 FOLGENDEN ...</i> ' - Das Fenster besteht aus zwei Zeilen unmittelbar nach dem Cursor. <br><br>  AKTUELLE REIHE in diesem Modus zeigt die aktuelle Cursorposition an.  Zum Beispiel bedeutet " <i>REIHEN ZWISCHEN AKTUELLER REIHE UND UNBEGRENZTEM FOLGENDEM</i> " von der aktuellen Zeile bis zum Ende des Bereichs. </li><li>  <b>√úBER (BEREICH)</b> <br>  unterscheidet sich von ROWS darin, dass CURRENT ROW hier als Anfang des Fensters den Beginn des Bereichs von ORDER BY und als Ende des Fensters - die letzte Zeile des Bereichs ORDER BY - bedeutet. </li></ul><br>  Die Syntax f√ºr die Verwendung von Fensterfunktionen auf verschiedenen Systemen unterscheidet sich geringf√ºgig. <br><br>  Zusammenfassend l√§sst sich sagen, dass die Entwickler nach der Analyse der Erstellung verschiedener Berichte in SQL die h√§ufigsten F√§lle hervorgehoben und in der Syntax genau konkretisiert haben. <br><br><h4>  Funktionen zum Zur√ºckgeben von Datens√§tzen </h4><br>  Bei der Ausgabe von Aggregat- / Fensterfunktionen entspricht jede resultierende Zeile einem bestimmten Zeilenbereich aus dem eingehenden Datenstrom.  Im Leben existiert eine solche Entsprechung nicht immer. <br><br>  Zum Beispiel ist es erforderlich, eine Kovarianzmatrix 10X10 zu konstruieren ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">daf√ºr</a> w√ºrde es 672X672 dauern).  Dies <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kann</a> in einem Durchgang erfolgen, dazu f√ºhren wir die von uns geschriebene Aggregatfunktion mit 10 numerischen Parametern aus.  Das Ergebnis ihrer Arbeit ist ein Recordset von 10 Zeilen mit 10 Werten. Jedes Matrixelement bezieht sich auf alle Zeilen des Eingabestreams (egal wie viele es gibt). <br><br>  Wir k√∂nnen sagen - also, was, zum Beispiel, in PostgreSQl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">k√∂nnen Sie</a> ein zweidimensionales Array von einer Funktion zur√ºckgeben (Beispiel: 'ARRAY [[1,2], [3,4]').  Oder serialisieren Sie die Matrix einfach in eine Zeile. <br><br>  Es ist gut, aber es ist nicht immer m√∂glich, die Gr√∂√üe des Ergebnisses innerhalb des f√ºr einen solchen Ansatz akzeptablen Rahmens zu halten. <br><br><div class="spoiler">  <b class="spoiler_title">Lyrischer Exkurs</b> <div class="spoiler_text">  Unsere Aufgabe ist es beispielsweise, die Geometrie zu verallgemeinern. <br><br>  Die Gr√∂√üe der Geometrien ist uns unbekannt, es kann auch die K√ºste Eurasiens von zig Millionen Punkten sein.  Oder umgekehrt, es gibt eine sehr grobe Geometrie, die Sie mit Splines gl√§tten m√ºssen.  Ich m√∂chte die Parameter an das Aggregat √ºbergeben und den Datenstrom anstelle eines Vektors oder einer Zeichenfolge abrufen. <br><br>  Man kann nat√ºrlich sagen, dass das Problem weit hergeholt ist, dass es niemand tut, die Geometrien im DBMS auf besondere Weise gespeichert werden, es gibt spezielle Programme zur Verarbeitung von Geometrien, ... <br><br>  Tats√§chlich ist es sehr praktisch, Geometrien in regul√§ren Tabellen punktweise zu speichern, schon allein deshalb, weil durch Verschieben eines Punkts nicht der gesamte Blob neu geschrieben werden muss.  Bevor r√§umliche Daten √ºberall im DBMS durchgesickert sind, war dies beispielsweise in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ArcSDE</a> der Fall. <br><br>  Sobald die durchschnittliche Gr√∂√üe des Geometrie-Blobs die Seitengr√∂√üe √ºberschreitet, wird es rentabler, direkt mit Punkten zu arbeiten.  Wenn es eine physische M√∂glichkeit g√§be, mit einem Fluss von Punkten zu arbeiten, w√ºrde sich das Rad der Geschichte vielleicht wieder drehen. <br></div></div><br>  Die Kovarianzmatrix ist immer noch kein sehr gutes Beispiel f√ºr die Desynchronisation zwischen den Eingangs- und Ausgangsstr√∂men, da das gesamte Ergebnis am Ende gleichzeitig erhalten wird.  Angenommen, Sie m√∂chten einen Quelldatenstrom verarbeiten / komprimieren.  Dabei <br><br><ul><li>  Es gibt viele Daten, sie befinden sich auf dem "Haufen" ohne Indizes, tats√§chlich wurden sie einfach "schnell" auf die Festplatte geschrieben </li><li>  Sie m√ºssen sie in verschiedene Kategorien sortieren, die relativ wenige sind </li><li>  Innerhalb von Kategorien Durchschnitt √ºber Zeitintervalle, nur Durchschnitt, Anzahl der Messungen und Varianz speichern </li><li>  All dies muss schnell erledigt werden </li></ul><br>  Welche M√∂glichkeiten gibt es? <br><br><ol><li>  In SQL ist eine Sortierung nach Zeitintervall / Kategorie erforderlich, was dem letzten Punkt widerspricht. </li><li>  Wenn die Daten bereits nach Zeit sortiert sind (was tats√§chlich nicht garantiert ist) und diese Tatsache an den SQL-Prozessor √ºbermittelt werden kann, k√∂nnen Sie Fensterfunktionen und einen Durchgang verwenden. </li><li>  Schreiben Sie eine separate Anwendung, die all dies erledigt.  In PL / SQL oder wahrscheinlicher in C / C ++, da viele Daten vorhanden sind. </li><li>  Funktionen, die Datens√§tze zur√ºckgeben.  Vielleicht k√∂nnen sie uns helfen. </li></ol><br>  Weitere Details zu A.4.  Hierf√ºr gibt es zwei Mechanismen: tempor√§re Tabellen und Pipeline-Funktionen. <br><br><ol><li>  F√∂rdererfunktionen. <br>  Dieser Mechanismus wurde in Oracle (ab 9i, 2001) eingef√ºhrt und erm√∂glicht es der Funktion, die das Recordset zur√ºckgegeben hat, Daten nicht zu akkumulieren, sondern nach Bedarf zu berechnen (analog zur Synchronisation von stdout und stdin zweier √ºber Pipe verbundener Prozesse). <br>  Das hei√üt,  Die Ergebnisse von Pipeline-Funktionen werden m√∂glicherweise verarbeitet, bevor diese Funktion beendet wird.  Dazu reicht es aus, in der Definition der Funktion zu sagen <br><br><pre> <code class="sql hljs"> FUNCTION f_trans(p refcur_t) RETURN outrecset PIPELINED IS ‚Ä¶</code> </pre> <br>  und Ergebniszeilen im K√∂rper registrieren <br><br><pre> <code class="sql hljs">LOOP ‚Ä¶ out_rec.var_char1 := in_rec.email; out_rec.var_char2 := in_rec.phone_number; PIPE ROW(out_rec); ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span>;</code> </pre> <br>  Als Ergebnis haben wir <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>( refcur_pkg.f_trans( <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> employees <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> department_id = <span class="hljs-number"><span class="hljs-number">60</span></span>)));</code> </pre><br>  Benutzerdefinierte Aggregate werden bei Pipelinefunktionen einfach nicht ben√∂tigt. <br><br>  Bravo, Orakel! <br><br>  Vor nicht allzu langer Zeit (2014) wurden Pipeline-Funktionen auch in DB2 (IBM i 7.1 TR9, i 7.2 TR1) angezeigt. </li><li>  Tempor√§re Tische. <br>  Zun√§chst scheint es, dass weder MS SQL noch PostgreSQL einen Cursor von einer Aggregatfunktion zur√ºckgeben k√∂nnen. <br><br>  Lassen Sie uns in Analogie zu den Pipeline-Funktionen den Cursor als Parameter abrufen, verarbeiten, einer tempor√§ren Tabelle hinzuf√ºgen und den Cursor darauf zur√ºcksetzen. <br><br>  In MS SQL ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">es jedoch nicht m√∂glich</a> , den Cursor durch einen Parameter an eine gespeicherte Prozedur zu √ºbergeben. Es ist nur m√∂glich, einen Cursor in der Prozedur zu erstellen und den Parameter √ºber die Ausgabe zur√ºckzugeben.  Gleiches gilt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">f√ºr</a> PostgreSQL. <br><br>  Nun gut, √∂ffnen Sie einfach den Cursor, subtrahieren Sie ihn, verarbeiten Sie die Werte, berechnen Sie das Ergebnis, f√ºgen Sie es der tempor√§ren Tabelle hinzu und rendern Sie den Cursor. <br><br>  Oder noch einfacher: Wir f√ºgen die Abfrageergebnisse einer tempor√§ren Tabelle hinzu, verarbeiten sie und geben die Ergebnisse √ºber den Cursor an eine andere tempor√§re Tabelle zur√ºck. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was soll</a> ich sagen  Erstens und vor allem ist das Lesen von Daten √ºber den Cursor langsamer als das Verarbeiten im Stream.  Zweitens, warum brauchen Sie dann √ºberhaupt einen SQL-Prozessor? Lassen Sie uns Tabellen mit Cursorn lesen, tempor√§re Tabellen mit unseren H√§nden erstellen, Verkn√ºpfungslogik in Schleifen schreiben ... Es ist wie Assembler-Einf√ºgungen in C / C ++, manchmal k√∂nnen Sie sich selbst behandeln, aber es ist besser, sie nicht zu missbrauchen. </li></ol><br>  Nachdem wir eine Frage mit Funktionen betrachtet haben, die Recordset zur√ºckgeben, kommen wir zu folgenden Schlussfolgerungen: <br><br><ul><li>  Benutzerdefinierte Aggregate helfen uns hier nicht wirklich. </li><li>  In jedem Fall m√ºssen Sie einige Objekte in der Datenbank erstellen.  Sei es Funktionen oder tempor√§re Tabellen.  Zumindest sind entsprechende Rechte erforderlich.  <i>Und m√∂chte nur ein paar Zahlen verarbeiten.</i> <br></li><li>  Trotz der beschriebenen Einschr√§nkungen ist es manchmal nicht sehr elegant, aber mit dieser Methode k√∂nnen Sie das Problem l√∂sen. </li></ul><br><h4>  Was noch </h4><br>  Was braucht der Autor noch, wenn wir bereits die M√∂glichkeit haben, Probleme zu l√∂sen? <br>  Eigentlich kann die Turingmaschine auch alles berechnen, macht es einfach nicht sehr schnell und nicht zu bequem. <br><br>  Wir formulieren die Anforderungen wie folgt: <br><br><ol><li>  Es muss sich um einen Vergleichsoperator handeln, der mit den anderen vergleichbar ist (Auswahl, Projektion, ...). </li><li>  Es muss ein Operator sein, der einen Datenstrom in einen anderen umwandelt </li><li>  Es gibt keine Synchronisation zwischen Eingangs- und Ausgangsstr√∂men </li><li>  Die Operatordeklaration definiert die Struktur des Ausgabestreams </li><li>  Der Operator hat die M√∂glichkeit, dynamisch zu initialisieren (in Form einer Funktion, genauer gesagt ihres K√∂rpers, der direkt in der Definition des Operators angegeben ist). </li><li>  sowie ein Destruktor in Form einer Funktion (...) </li><li>  sowie eine Funktion (...), die jedes Mal aufgerufen wird, wenn eine neue Zeile vom Eingabestream empfangen wird </li><li>  Der Operator verf√ºgt √ºber einen Ausf√ºhrungskontext - einen benutzerdefinierten Satz von Variablen und / oder Sammlungen, die f√ºr die Arbeit ben√∂tigt werden </li><li>  Um diesen Operator auszuf√ºhren, m√ºssen Sie keine Datenbankobjekte erstellen und ben√∂tigen keine zus√§tzlichen Rechte </li><li>  Alles, was f√ºr die Arbeit ben√∂tigt wird, wird an einem Ort in einer Sprache definiert </li></ol><br>  Es war einmal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, dass der</a> Autor einen solchen Operator erstellt hat, der den selbst erstellten Prozessor der implementierten Teilmenge von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TTM / Tutorial D erweitert.</a>  Jetzt wird die gleiche Idee f√ºr SQL vorgeschlagen. <br><br>  Es ist eine Warnung wert, hier endet SQL und die Improvisation beginnt.  Die Syntax bleibt wie im Original, am Ende kann syntaktischer Zucker alles sein, es √§ndert nichts an der Essenz. <br><br>  Der <b>Kauoperator</b> besteht also aus <br><br><ol><li>  Ein Header, der eine Liste der Ausgabefelder und ihrer Typen enth√§lt. <br>  Jedes Ausgabe- (und Eingabe-) Feld ist eine lokale Variable. <br>  Beispiel: <i>"Kauen {" var1 "float," var2 "Ganzzahl}"</i> bedeutet, dass der Ausgabestream zwei Spalten enth√§lt - einen Gleitkomma- und eine Ganzzahl </li><li>  K√∂rper - eine Liste von R√ºckrufen f√ºr Ereignisse im Moment - der Beginn des Streams, das Ende des Streams, die Zeile.  Nach der Syntax liegen die Funktionen in der N√§he von PL / SQL.  Die vordefinierte Funktion <i>__interrupt</i> () ist ein Analogon zu PIPE. Sie nimmt Werte aus den Variablen, die den Ausgabespalten entsprechen, und platziert sie im Ausgabestream.  Wenn der Puffer des Ausgabestreams voll ist, wird der Handler angehalten und die empfangende Seite des Streams beginnt zu arbeiten. <br>  Beispiel: "hook" init "{var1: = 0;  var2: = -1;  } " </li></ol><br>  Der einfachste Weg, Beispiele zu zeigen. <br><br><ul><li>  Ein Analogon der Aggregatfunktion SUM. <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  'select sum(val) from samples' -- select * from samples chew {‚Äúsum(val)‚Äù float} --    hook ‚Äúinit‚Äù { ‚Äúsum(val)‚Äù := 0; --      } hook ‚Äúrow‚Äù { if (not isnull("val")) then "sum(val)" := "sum(val)" + "val"; end if; } hook ‚Äúfinit‚Äù { call __interrupt(); --  PIPE }</span></span></code> </pre><br>  Es sieht sperrig aus, ist aber nur ein Beispiel. <br>  Es ist nicht erforderlich, ein C-Programm zu schreiben, um einige Zahlen hinzuzuf√ºgen. </li><li>  SUM + AVG <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  'select sum(val), avg(val) from samples' -- select * from samples chew { ‚Äúsum(val)‚Äù float, ‚Äúavg(val)‚Äù float --       } hook ‚Äúinit‚Äù { ‚Äúsum(val)‚Äù := 0; ‚Äúavg(val)‚Äù := 0; var num integer; num := 0; --    ,       } hook ‚Äúrow‚Äù { if (not isnull("val")) then "sum(val)" := "sum(val)" + "val"; num := num + 1; end if; } hook ‚Äúfinit‚Äù { if (num &gt; 0) then ‚Äúavg(val)‚Äù := ‚Äúsum(val)‚Äù / num; end if; call __interrupt(); }</span></span></code> </pre><br>  Hier machen wir darauf aufmerksam, dass die Summierung nur einmal erfolgt. </li><li>  SUM + GROUP BY <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  'select sum(val) from samples group by type' -- select * from --     ( samples val, type from samples order by type ) chew { ‚Äúsum(val)‚Äù float } hook ‚Äúinit‚Äù { ‚Äúsum(val)‚Äù := 0; var gtype integer; gtype := NULL; var num integer; --   num := 0; } hook ‚Äúrow‚Äù { if (gtype &lt;&gt; ‚Äútype‚Äù) then __interrupt(); ‚Äúgtype‚Äù := type; "sum(val)" := 0; num := 0; end if; if (not isnull("val")) then "sum(val)" := "sum(val)" + "val"; num := num + 1; end if; } hook ‚Äúfinit‚Äù { if (num &gt; 0) then call __interrupt(); end if; }</span></span></code> </pre></li><li>  ROW_NUMBER () OVER () <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">-- select row_number() over() as num, * from samples -- select * from samples chew { ‚Äúnum‚Äù integer, * --        --   '* except val1, ...valX',   TTM } hook ‚Äúinit‚Äù { num := 0; } hook ‚Äúrow‚Äù { num := num + 1; call __interrupt(); }</span></span></code> </pre></li></ul><br>  Ist es m√∂glich, ein Beispiel anzubieten, anhand dessen dieser Ansatz Ergebnisse liefert, die auf √ºbliche Weise grunds√§tzlich unerreichbar sind?  Wir haben sie. <br><br>  Manchmal kommt es vor, dass die Daten fast sortiert sind.  Sie k√∂nnen sogar vollst√§ndig sortiert sein, aber es ist nicht sicher bekannt. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angenommen, im obigen Beispiel (Datenstromkomprimierung) stammen die Daten aus verschiedenen Quellen und k√∂nnen aus verschiedenen Gr√ºnden leicht gemischt werden.</font></font> Das hei√üt,<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Zeile von einer Quelle mit dem Zeitstempel T1 kann sich in der Datenbank nach einer Zeile von einer anderen Quelle mit der Zeit T2 befinden, w√§hrend T1 &lt;T2 ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selbst wenn wir garantieren, dass der Unterschied zwischen T1 und T2 niemals eine bestimmte (sp√§rliche) Konstante √ºberschreitet, k√∂nnen wir hier nicht (auf herk√∂mmliche Weise) auf Sortierung verzichten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unter Verwendung des vorgeschlagenen Ansatzes ist es jedoch m√∂glich, den Eingabestrom zu puffern und die Daten des aktuellen Zeitintervalls erst zu verarbeiten, nachdem die Eingabe Zeilen mit einem Zeitstempel empfangen hat, der mindestens eine gegebene Konstante um die rechte Grenze des Intervalls √ºberschreitet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier gibt es einen sehr wichtigen Punkt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nur wir wissen, dass die Daten fast sortiert sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nur wir kennen den Wert dieser Konstante.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Konstante ist nur f√ºr dieses Problem und m√∂glicherweise nur f√ºr dieses Experiment charakteristisch. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und wir verwenden diesen Hack in eigener Verantwortung, um ein Sortieren zu vermeiden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unser Standardwissen √ºber die Aufgabe ist nicht in der Regel vorhanden, um es dem SQL-Prozessor mitzuteilen, und es ist schwer vorstellbar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verwendung von Lambda-Funktionen bietet eine universelle M√∂glichkeit, den SQL-Prozessor zu zwingen, genau das zu tun, was wir brauchen, genau dort, wo wir es brauchen.</font></font><br><br><h4>  Fazit </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das vorgeschlagene Design scheint nicht sehr schwierig zu implementieren zu sein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In jedem Fall mit g√ºltigem PL / SQL. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Idee selbst ist einfach und intuitiv und f√ºgt der Sprache keine neuen Entit√§ten hinzu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist eine einzelne Einheit, die bei Bedarf die Aggregat- und Fensterfunktionen GROUP BY ersetzt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Mechanismus, mit dem Sie auf Sortierungen verzichten k√∂nnen, bei denen ein herk√∂mmlicher SQL-Prozessor keine M√∂glichkeit bietet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vor allem aber ist es ein Mechanismus, der Ihnen die Freiheit gibt, mit den Daten alles zu tun, was Sie wollen. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vielen Dank an Dorofei Proleskovsky f√ºr die Teilnahme an der Vorbereitung des Artikels.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435120/">https://habr.com/ru/post/de435120/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435106/index.html">Noch einmal √ºber passport.js</a></li>
<li><a href="../de435108/index.html">Mit Prolog</a></li>
<li><a href="../de435112/index.html">Unternehmensinterview</a></li>
<li><a href="../de435114/index.html">Federdaten jpa</a></li>
<li><a href="../de435118/index.html">Save File Me - ein kostenloser Sicherungsdienst mit clientseitiger Verschl√ºsselung</a></li>
<li><a href="../de435122/index.html">Wie die Flamme in Doom auf der Playstation implementiert wurde</a></li>
<li><a href="../de435124/index.html">Meisterwerke der Welts√§ulenkonstruktion: ein Studiomonitor-Transformator mit variabler Anzahl von B√§ndern</a></li>
<li><a href="../de435126/index.html">Erfahrung in der Organisation und Durchf√ºhrung von Unternehmenskonferenzen f√ºr Analysten</a></li>
<li><a href="../de435128/index.html">Pi-Sonos: ein au√üer Kontrolle geratenes Hobby</a></li>
<li><a href="../de435132/index.html">Nomad: Probleme und L√∂sungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>