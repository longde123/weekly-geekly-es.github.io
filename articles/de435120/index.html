<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👃🏻 🤷🏾 🖖🏿 Lambda funktioniert in SQL ... denken wir mal 👩🏻‍🔬 ♾ 🤷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Worum es in dem Artikel geht, und so impliziert der Name. 

 Darüber hinaus wird der Autor erklären, warum dies aus seiner Sicht notwendig ist, und er...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lambda funktioniert in SQL ... denken wir mal</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435120/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sl/ch/fp/slchfpm_a-deoh62fqiazjgdc5k.png" alt="Bild"></div><br>  Worum es in dem Artikel geht, und so impliziert der Name. <br><br>  Darüber hinaus wird der Autor erklären, warum dies aus seiner Sicht notwendig ist, und erklären, dass SUBJ nicht nur eine modische Technologie ist, sondern auch „ein doppelt notwendiges Geschäft - sowohl angenehm als auch nützlich“. <br><a name="habracut"></a><br>  Es ist immer wieder interessant zu sehen, wie mehrere talentierte Leute etwas tun (eine Programmiersprache, warum nicht) und genau wissen, welches Problem sie lösen und welche Aufgaben sie sich stellen.  Und testen Sie auch ihre Kreation an sich selbst.  Es kann nicht mit den monumentalen Kreationen riesiger Komitees verglichen werden, die die Aufrechterhaltung der Harmonie des Universums in den Vordergrund stellen und wer sie versteht. <br><br>  Vergleichen Sie zum Beispiel das Schicksal von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FORTRAN</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PL / 1</a> .  Wer wird sich jetzt an diesen PL / 1 erinnern? <br><br>  Aus dieser Sicht ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AWK</a> beispielsweise sehr erfolgreich.  Es ist erwähnenswert, dass in seinem Namen A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alfred Aho</a> , einer der Autoren des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Drachenbuchs</a> , W <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Peter Weinberger ist</a> , der an Fortran-77 beteiligt war, K <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Brian Kernigan ist</a> , wo er ohne ihn wäre.  Die Sprache ist für die Verarbeitung von Textströmen im laufenden Betrieb in Pipes zwischen Prozessen vorgesehen. <br><br>  Die Sprache ist typenlos ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dies ist nicht ganz richtig</a> ), ihre Syntax ist C sehr ähnlich, sie verfügt über Filterfunktionen, assoziative Arrays, Stream-Start / Ende-Ereignisse, Newline-Ereignisse ... <br><br>  Der Autor war von dieser Sprache immer beeindruckt, auch von der Tatsache, dass sein Interpreter nicht installiert werden muss, unter UNIX-ähnlichen Systemen immer vorhanden ist und unter Windows ausreicht, nur die ausführbare Datei zu kopieren und alles funktioniert.  Dies ist jedoch nicht der Fall. <br><br>  Dabei muss der Autor das SQL + AWK-Bundle häufig verwenden, und deshalb.  SQL ist nach wie vor eine deklarative Sprache zur Steuerung des Datenflusses.  Es bietet nur sehr begrenzte Möglichkeiten, mit dem Kontext der Abfrageausführung in Form von Aggregatfunktionen zu arbeiten. <br><br>  Wie kann man beispielsweise ein zweidimensionales Histogramm mit SQL erstellen? <br><br><pre><code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--   100 x 100 SELECT count(), round(x, -2) AS cx, round(y, -2) AS cy FROM samples GROUP BY cx, xy</span></span></code> </pre> <br>  Angenommen, die Verwendung von GROUP BY impliziert das Sortieren. Wenn Sie Hunderte von Millionen (oder sogar mehr) Zeilen haben, ist dies kein billiges Vergnügen. <br><div class="spoiler">  <b class="spoiler_title">UPD: In den Kommentaren haben sie mich korrigiert, dass dies nicht ganz richtig ist (oder überhaupt nicht)</b> <div class="spoiler_text">  Der SQL-Prozessor kann beim Erstellen eines Hashs gemäß dem Gruppierungskriterium Aggregatfunktionen ausführen.  Dazu ist es notwendig, dass es über genügend freien Speicher verfügt, um die Hash-Map im Speicher abzulegen. <br><br>  Dann werden die Kontexte der Gruppen aktualisiert, wenn die Tabelle gelesen wird, und am Ende dieses Lesens haben wir bereits das berechnete Ergebnis. <br>  Die gleiche Technik kann auf Fensterfunktionen (unten) erweitert werden, nur der Kontext wird "dicker". <br><br>  Wenn die Anzahl der Gruppen im Voraus unbekannt oder sehr groß ist, muss der SQL-Prozessor einen temporären Index erstellen und diesen in einem zweiten Durchgang ausführen. <br><br>  In einfachen Fällen, wie hier, wie hier - ein einfacher COUNT, eine universelle Option ist möglich - ein temporärer Index (cx, cy, count), dann wird bei einer kleinen Anzahl von Gruppen alles auf zwischengespeicherten Seiten gespeichert.  In komplexen Fällen, Fensterfunktionen, wird der Zustand der Gruppe nicht trivial und die ständige (De-) Serialisierung entspricht überhaupt nicht den Anweisungen des Arztes. <br></div></div>  Zusammenfassung: Der SQL-Prozessor greift zum Sortieren zurück, wenn er die Anzahl der Gruppen nach GROUP BY nicht schätzen kann.  Die Gruppierung nach berechneten Werten ist jedoch (oft) genau der Fall. <br><br>  Deshalb müssen Sie etwas tun wie: <br><br><pre> <code class="bash hljs">psql -t -q -c <span class="hljs-string"><span class="hljs-string">'select x, y from samples'</span></span> | gawk -f mk_hist2d.awk</code> </pre> <br>  Dabei sammelt mk_hist2d.awk Statistiken im assoziativen Array und zeigt sie nach Abschluss der Arbeit an <br><br><pre> <code class="cpp hljs"># mk_hist2d.awk { bucket[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>($<span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-number"><span class="hljs-number">0.01</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>($<span class="hljs-number"><span class="hljs-number">3</span></span>*<span class="hljs-number"><span class="hljs-number">0.01</span></span>)]+=$<span class="hljs-number"><span class="hljs-number">1</span></span>; } END { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">500</span></span>; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">500</span></span>; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((i, j) in bucket) print i*<span class="hljs-number"><span class="hljs-number">100.</span></span><span class="hljs-string"><span class="hljs-string">" "</span></span>j*<span class="hljs-number"><span class="hljs-number">100.</span></span><span class="hljs-string"><span class="hljs-string">" "</span></span>bucket[i, j]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> print i*<span class="hljs-number"><span class="hljs-number">100.</span></span><span class="hljs-string"><span class="hljs-string">" "</span></span>j*<span class="hljs-number"><span class="hljs-number">100.</span></span><span class="hljs-string"><span class="hljs-string">" 0"</span></span>; } }</code> </pre><br>  Es gibt einen ABER - der gesamte Datenstrom muss vom Server an die Arbeitsmaschine gesendet werden, und das ist nicht so billig. <br><br>  Ist es möglich, das Angenehme mit dem Nützlichen zu kombinieren - um während der Ausführung der SQL-Abfrage Statistiken zu sammeln, ohne jedoch zu sortieren?  Ja, zum Beispiel mit benutzerdefinierten Aggregatfunktionen. <br><br><h4>  Benutzerdefinierte Aggregatfunktionen </h4><br>  Subj ist in verschiedenen Systemen vorhanden, überall wird es ein wenig auf seine eigene Weise gemacht. <br><br><ol><li>  <b>PostgreSQL</b>  Die Dokumentation finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Weitere Details <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br>  Hier wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der</a> maximale Kontostand berechnet. <br>  Und dies ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel</a> , das berechnet, was mehr in der booleschen Spalte steht - wahr oder falsch. <br><br>  Es sieht so aus - <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AGGREGATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mode</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">boolean</span></span>) ( SFUNC = mode_bool_state, STYPE = <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span>[], FINALFUNC = mode_bool_final, INITCOND = <span class="hljs-string"><span class="hljs-string">'{0,0}'</span></span> );</code> </pre><br>  Hier ist <b>SFUNC</b> eine Funktion, die für jede Zeile im Stream aufgerufen wird. <br>  Das erste Argument ist vom Typ <b>STYPE</b> . <br><br>  <b>FINALFUNC</b> wird verwendet, um die Berechnungen abzuschließen und den Wert des Aggregats zurückzugeben. <br>  <b>INITCOND</b> - Initialisierung des Anfangswertes des internen Zustands ( <b>STYPE</b> ), der als erstes Argument übergeben wurde. <br>  Da Funktionen in C geschrieben werden können (was bedeutet, dass Sie für den internen Status den Speicher verwenden können, der beim Schließen der Anforderung automatisch freigegeben wird), ist dies ein sehr leistungsfähiges Tool.  Außerhalb des Anwendungsbereichs muss man noch gehen können. </li><li>  <b>MS SQL</b> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zuvor</a> (2000) war es vor der Anforderung erforderlich, ein ActiveX-Objekt zu erstellen, um die Aggregation mit diesem Objekt durchzuführen. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jetzt</a> (2016+) erfolgt dies in der CLR-Umgebung.  Sie müssen eine benutzerdefinierte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktion</a> erstellen, eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Baugruppe</a> erstellen und registrieren.  Dann können Sie ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aggregat</a> erstellen. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein Beispiel für die</a> Berechnung des geometrischen Mittelwerts sowie für das Zusammenführen von Zeichenfolgen: mit zusätzlichen Parametern und einem benutzerdefinierten Typ zum Speichern eines Zwischenzustands. </li><li>  <b>Oracle</b> <br>  In Oracle erfolgt dies mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ODCIAggregate-Datenkassette</a> (Schnittstelle). <br>  Um ein eigenes Aggregat zu erstellen, müssen Sie einen benutzerdefinierten Typ schreiben, der 4 Methoden implementiert <br>  - Die statische Initialisierung (ODCIAggregateInitialize) sollte eine Instanz des gewünschten Typs erstellen und über den Parameter zurückkehren <br>  - Iterationen (ODCIAggregateIterate), die für jede Datenzeile aufgerufen werden <br>  - Merge (ODCIAggregateMerge), mit dem parallel ausgeführte Aggregate zusammengeführt werden <br>  - finish (ODCIAggregateTerminate) - Ergebnisausgabe <br>  Beispiele: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4</a> . </li><li>  <b>DB2</b> <br>  Es gibt keine explizite Möglichkeit, benutzerdefinierte Aggregate in DB2 zu verwenden. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie können jedoch</a> eine Standardfunktion (wenn auch MAX) in einen benutzerdefinierten Typ (in Java) einfügen und das System dazu bringen, Abfragen des Formulars auszuführen <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> Complex <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-built_in"><span class="hljs-built_in">real</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DOUBLE</span></span>, i <span class="hljs-keyword"><span class="hljs-keyword">DOUBLE</span></span> ) … <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> complexNumbers ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">number</span></span> Complex ) … <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum..real, sum..i <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> GetAggrResult(<span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>(BuildComplexSum(<span class="hljs-built_in"><span class="hljs-built_in">number</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> complexNumbers ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>)</code> </pre></li></ol><br>  Was ist in all diesen Systemen bemerkenswert? <br><br><ul><li>  Auf die eine oder andere Weise müssen Sie einige Objekte in der Datenbank erstellen.  Sei es AGGREGATE oder TYPE.  Zumindest sind entsprechende Rechte erforderlich.  <i>Und möchte nur ein paar Zahlen auf sein Knie setzen.</i> <br></li><li>  Möglicherweise müssen Sie etwas in einer anderen Sprache schreiben, sei es C, C # oder Java. <br>  Um das, was geschrieben ist, in das System zu integrieren, sind wiederum Rechte erforderlich.  <i>Aber alles was ich will ...</i> <br></li><li>  Schwierigkeiten beim Initialisieren.  Angenommen, Sie möchten Histogramme mit unterschiedlichen Korbgrößen lesen.  Es scheint einfacher zu sein - wir geben die gewünschte INITCOND an, wenn wir das Aggregat (PostgreSQL) und das gesamte Unternehmen deklarieren.  Aber dann benötigen Sie für jede Größe des Warenkorbs Ihr eigenes Aggregat, und auch hierfür sind die Rechte erforderlich. <br><br>  Hier können Sie auf einen schmutzigen Trick zurückgreifen und den Union-Prozessor aus der Initialisierungszeile (vorwärts) und den Daten entfernen. Erstellen Sie den Kontext nicht im Konstruktor, sondern wenn die erste Zeile empfangen wird. <br></li><li>  Trotz der beschriebenen Einschränkungen können Sie mit benutzerdefinierten Aggregaten alles berechnen. <br></li><li>  Es ist wichtig, dass <u>Aggregate parallelisiert werden können</u> , zumindest PostgreSQL, und Oracle (Enterprise Edition) kann dies tun.  Dazu muss die Wahrheit lernen, wie man Zwischenzustände serialisiert / deserialisiert und sie aus verschiedenen Streams einfriert. </li></ul><br><h4>  Fensterfunktionen </h4><br>  Fensterfunktionen wurden im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SQL: 2003-</a> Standard angezeigt.  Im Moment werden sie von allen oben genannten Systemen unterstützt.  Fensterfunktionen sind im Wesentlichen eine Erweiterung der Arbeit mit Einheiten.  Benutzerdefinierte Aggregatfunktionen funktionieren natürlich auch in einem Fensterkontext. <br><br>  Die Erweiterung ist dies.  Vor SQL: 2003 arbeiteten Aggregatfunktionen in einem bestimmten Fenster, das entweder die gesamte Ergebnismenge oder deren Teil war und der Kombination von Feldwerten aus dem GROUP BY-Ausdruck entsprach.  Der Benutzer hat jetzt einige Freiheiten bei der Bearbeitung dieses Fensters. <br><br>  Der Unterschied besteht darin, dass die mithilfe der Fenster berechneten Werte in einer separaten Spalte zur Ausgabe hinzugefügt werden und nicht erforderlich ist, dass der gesamte Stream mithilfe von Aggregatfunktionen zusammenfällt.  In einer Anfrage können Sie also mehrere Fensteraggregate jeweils in einem eigenen Kontext (Fenster) verwenden.  Es konnte vorher mehrere Aggregatfunktionen geben, aber alle funktionierten in einem Fenster. <br><br>  Große Striche <br><br><ul><li>  <b>Over ()</b> <br>  Das Fenster ist die gesamte Ergebnismenge.  Angenommen, die Abfrage ' <i>select count (1) from Samples</i> ' gibt 169 zurück. In diesem Fall erhalten wir beim Ausführen von ' <i>select count (1) over () from Samples</i> ' eine Spalte, die 169-mal 169-mal geschrieben wird. </li><li>  <b>ÜBER (TEILUNG DURCH)</b> <br>  Es ist ein Analogon zu GROUP BY. Für jede Wertekombination wird ein Fenster erstellt, in dem Aggregatfunktionen ausgeführt werden.  Angenommen, in der Samples-Tabelle ist eine Ganzzahlspalte val, die Daten sind Zahlen von 1 bis 169. <br>  Dann gibt die Abfrage ' <i>select count (1) over (Partition by (12 + val) / 13) from Samples</i> ' eine Spalte zurück, in die der Wert 13 169 Mal geschrieben wird. <br></li><li>  <b>ÜBER (BESTELLEN NACH)</b> <br>  kann mit PARTITION BY kombiniert werden, ermöglicht es Ihnen, die Größe des Fensters während des Cursors dynamisch zu ändern. In diesem Fall erstreckt sich das Fenster vom Anfang der Gruppe bis zur aktuellen Cursorposition.  Infolgedessen ergibt sich für die Gruppe nicht derselbe Wert in der Aggregatspalte, sondern der eigene.  Praktisch für die Berechnung der kumulierten Beträge.  Abfrageergebnis <br>  <i>'Summe (Wert) über (Reihenfolge nach Wert) aus Stichproben auswählen</i> ' ist eine Spalte, in der das n-te Element die Summe der natürlichen Zahlen von 1 bis n enthält. </li><li>  <b>ÜBER (REIHEN)</b> <br>  Mit dieser Option können Sie die Fensterrahmen ausgehend von der Cursorposition oder dem Anfang / Ende des ORDER BY-Bereichs definieren. <br><br>  Beispiel: " <i>... REIHEN 1 VORHER ...</i> " bedeutet, dass das Fenster aus der aktuellen Zeile und 1 davor besteht.  A ' <i>... REIHEN ZWISCHEN 1 FOLGENDEN UND 2 FOLGENDEN ...</i> ' - Das Fenster besteht aus zwei Zeilen unmittelbar nach dem Cursor. <br><br>  AKTUELLE REIHE in diesem Modus zeigt die aktuelle Cursorposition an.  Zum Beispiel bedeutet " <i>REIHEN ZWISCHEN AKTUELLER REIHE UND UNBEGRENZTEM FOLGENDEM</i> " von der aktuellen Zeile bis zum Ende des Bereichs. </li><li>  <b>ÜBER (BEREICH)</b> <br>  unterscheidet sich von ROWS darin, dass CURRENT ROW hier als Anfang des Fensters den Beginn des Bereichs von ORDER BY und als Ende des Fensters - die letzte Zeile des Bereichs ORDER BY - bedeutet. </li></ul><br>  Die Syntax für die Verwendung von Fensterfunktionen auf verschiedenen Systemen unterscheidet sich geringfügig. <br><br>  Zusammenfassend lässt sich sagen, dass die Entwickler nach der Analyse der Erstellung verschiedener Berichte in SQL die häufigsten Fälle hervorgehoben und in der Syntax genau konkretisiert haben. <br><br><h4>  Funktionen zum Zurückgeben von Datensätzen </h4><br>  Bei der Ausgabe von Aggregat- / Fensterfunktionen entspricht jede resultierende Zeile einem bestimmten Zeilenbereich aus dem eingehenden Datenstrom.  Im Leben existiert eine solche Entsprechung nicht immer. <br><br>  Zum Beispiel ist es erforderlich, eine Kovarianzmatrix 10X10 zu konstruieren ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dafür</a> würde es 672X672 dauern).  Dies <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kann</a> in einem Durchgang erfolgen, dazu führen wir die von uns geschriebene Aggregatfunktion mit 10 numerischen Parametern aus.  Das Ergebnis ihrer Arbeit ist ein Recordset von 10 Zeilen mit 10 Werten. Jedes Matrixelement bezieht sich auf alle Zeilen des Eingabestreams (egal wie viele es gibt). <br><br>  Wir können sagen - also, was, zum Beispiel, in PostgreSQl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">können Sie</a> ein zweidimensionales Array von einer Funktion zurückgeben (Beispiel: 'ARRAY [[1,2], [3,4]').  Oder serialisieren Sie die Matrix einfach in eine Zeile. <br><br>  Es ist gut, aber es ist nicht immer möglich, die Größe des Ergebnisses innerhalb des für einen solchen Ansatz akzeptablen Rahmens zu halten. <br><br><div class="spoiler">  <b class="spoiler_title">Lyrischer Exkurs</b> <div class="spoiler_text">  Unsere Aufgabe ist es beispielsweise, die Geometrie zu verallgemeinern. <br><br>  Die Größe der Geometrien ist uns unbekannt, es kann auch die Küste Eurasiens von zig Millionen Punkten sein.  Oder umgekehrt, es gibt eine sehr grobe Geometrie, die Sie mit Splines glätten müssen.  Ich möchte die Parameter an das Aggregat übergeben und den Datenstrom anstelle eines Vektors oder einer Zeichenfolge abrufen. <br><br>  Man kann natürlich sagen, dass das Problem weit hergeholt ist, dass es niemand tut, die Geometrien im DBMS auf besondere Weise gespeichert werden, es gibt spezielle Programme zur Verarbeitung von Geometrien, ... <br><br>  Tatsächlich ist es sehr praktisch, Geometrien in regulären Tabellen punktweise zu speichern, schon allein deshalb, weil durch Verschieben eines Punkts nicht der gesamte Blob neu geschrieben werden muss.  Bevor räumliche Daten überall im DBMS durchgesickert sind, war dies beispielsweise in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ArcSDE</a> der Fall. <br><br>  Sobald die durchschnittliche Größe des Geometrie-Blobs die Seitengröße überschreitet, wird es rentabler, direkt mit Punkten zu arbeiten.  Wenn es eine physische Möglichkeit gäbe, mit einem Fluss von Punkten zu arbeiten, würde sich das Rad der Geschichte vielleicht wieder drehen. <br></div></div><br>  Die Kovarianzmatrix ist immer noch kein sehr gutes Beispiel für die Desynchronisation zwischen den Eingangs- und Ausgangsströmen, da das gesamte Ergebnis am Ende gleichzeitig erhalten wird.  Angenommen, Sie möchten einen Quelldatenstrom verarbeiten / komprimieren.  Dabei <br><br><ul><li>  Es gibt viele Daten, sie befinden sich auf dem "Haufen" ohne Indizes, tatsächlich wurden sie einfach "schnell" auf die Festplatte geschrieben </li><li>  Sie müssen sie in verschiedene Kategorien sortieren, die relativ wenige sind </li><li>  Innerhalb von Kategorien Durchschnitt über Zeitintervalle, nur Durchschnitt, Anzahl der Messungen und Varianz speichern </li><li>  All dies muss schnell erledigt werden </li></ul><br>  Welche Möglichkeiten gibt es? <br><br><ol><li>  In SQL ist eine Sortierung nach Zeitintervall / Kategorie erforderlich, was dem letzten Punkt widerspricht. </li><li>  Wenn die Daten bereits nach Zeit sortiert sind (was tatsächlich nicht garantiert ist) und diese Tatsache an den SQL-Prozessor übermittelt werden kann, können Sie Fensterfunktionen und einen Durchgang verwenden. </li><li>  Schreiben Sie eine separate Anwendung, die all dies erledigt.  In PL / SQL oder wahrscheinlicher in C / C ++, da viele Daten vorhanden sind. </li><li>  Funktionen, die Datensätze zurückgeben.  Vielleicht können sie uns helfen. </li></ol><br>  Weitere Details zu A.4.  Hierfür gibt es zwei Mechanismen: temporäre Tabellen und Pipeline-Funktionen. <br><br><ol><li>  Fördererfunktionen. <br>  Dieser Mechanismus wurde in Oracle (ab 9i, 2001) eingeführt und ermöglicht es der Funktion, die das Recordset zurückgegeben hat, Daten nicht zu akkumulieren, sondern nach Bedarf zu berechnen (analog zur Synchronisation von stdout und stdin zweier über Pipe verbundener Prozesse). <br>  Das heißt,  Die Ergebnisse von Pipeline-Funktionen werden möglicherweise verarbeitet, bevor diese Funktion beendet wird.  Dazu reicht es aus, in der Definition der Funktion zu sagen <br><br><pre> <code class="sql hljs"> FUNCTION f_trans(p refcur_t) RETURN outrecset PIPELINED IS …</code> </pre> <br>  und Ergebniszeilen im Körper registrieren <br><br><pre> <code class="sql hljs">LOOP … out_rec.var_char1 := in_rec.email; out_rec.var_char2 := in_rec.phone_number; PIPE ROW(out_rec); … <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span>;</code> </pre> <br>  Als Ergebnis haben wir <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>( refcur_pkg.f_trans( <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> employees <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> department_id = <span class="hljs-number"><span class="hljs-number">60</span></span>)));</code> </pre><br>  Benutzerdefinierte Aggregate werden bei Pipelinefunktionen einfach nicht benötigt. <br><br>  Bravo, Orakel! <br><br>  Vor nicht allzu langer Zeit (2014) wurden Pipeline-Funktionen auch in DB2 (IBM i 7.1 TR9, i 7.2 TR1) angezeigt. </li><li>  Temporäre Tische. <br>  Zunächst scheint es, dass weder MS SQL noch PostgreSQL einen Cursor von einer Aggregatfunktion zurückgeben können. <br><br>  Lassen Sie uns in Analogie zu den Pipeline-Funktionen den Cursor als Parameter abrufen, verarbeiten, einer temporären Tabelle hinzufügen und den Cursor darauf zurücksetzen. <br><br>  In MS SQL ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">es jedoch nicht möglich</a> , den Cursor durch einen Parameter an eine gespeicherte Prozedur zu übergeben. Es ist nur möglich, einen Cursor in der Prozedur zu erstellen und den Parameter über die Ausgabe zurückzugeben.  Gleiches gilt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">für</a> PostgreSQL. <br><br>  Nun gut, öffnen Sie einfach den Cursor, subtrahieren Sie ihn, verarbeiten Sie die Werte, berechnen Sie das Ergebnis, fügen Sie es der temporären Tabelle hinzu und rendern Sie den Cursor. <br><br>  Oder noch einfacher: Wir fügen die Abfrageergebnisse einer temporären Tabelle hinzu, verarbeiten sie und geben die Ergebnisse über den Cursor an eine andere temporäre Tabelle zurück. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was soll</a> ich sagen  Erstens und vor allem ist das Lesen von Daten über den Cursor langsamer als das Verarbeiten im Stream.  Zweitens, warum brauchen Sie dann überhaupt einen SQL-Prozessor? Lassen Sie uns Tabellen mit Cursorn lesen, temporäre Tabellen mit unseren Händen erstellen, Verknüpfungslogik in Schleifen schreiben ... Es ist wie Assembler-Einfügungen in C / C ++, manchmal können Sie sich selbst behandeln, aber es ist besser, sie nicht zu missbrauchen. </li></ol><br>  Nachdem wir eine Frage mit Funktionen betrachtet haben, die Recordset zurückgeben, kommen wir zu folgenden Schlussfolgerungen: <br><br><ul><li>  Benutzerdefinierte Aggregate helfen uns hier nicht wirklich. </li><li>  In jedem Fall müssen Sie einige Objekte in der Datenbank erstellen.  Sei es Funktionen oder temporäre Tabellen.  Zumindest sind entsprechende Rechte erforderlich.  <i>Und möchte nur ein paar Zahlen verarbeiten.</i> <br></li><li>  Trotz der beschriebenen Einschränkungen ist es manchmal nicht sehr elegant, aber mit dieser Methode können Sie das Problem lösen. </li></ul><br><h4>  Was noch </h4><br>  Was braucht der Autor noch, wenn wir bereits die Möglichkeit haben, Probleme zu lösen? <br>  Eigentlich kann die Turingmaschine auch alles berechnen, macht es einfach nicht sehr schnell und nicht zu bequem. <br><br>  Wir formulieren die Anforderungen wie folgt: <br><br><ol><li>  Es muss sich um einen Vergleichsoperator handeln, der mit den anderen vergleichbar ist (Auswahl, Projektion, ...). </li><li>  Es muss ein Operator sein, der einen Datenstrom in einen anderen umwandelt </li><li>  Es gibt keine Synchronisation zwischen Eingangs- und Ausgangsströmen </li><li>  Die Operatordeklaration definiert die Struktur des Ausgabestreams </li><li>  Der Operator hat die Möglichkeit, dynamisch zu initialisieren (in Form einer Funktion, genauer gesagt ihres Körpers, der direkt in der Definition des Operators angegeben ist). </li><li>  sowie ein Destruktor in Form einer Funktion (...) </li><li>  sowie eine Funktion (...), die jedes Mal aufgerufen wird, wenn eine neue Zeile vom Eingabestream empfangen wird </li><li>  Der Operator verfügt über einen Ausführungskontext - einen benutzerdefinierten Satz von Variablen und / oder Sammlungen, die für die Arbeit benötigt werden </li><li>  Um diesen Operator auszuführen, müssen Sie keine Datenbankobjekte erstellen und benötigen keine zusätzlichen Rechte </li><li>  Alles, was für die Arbeit benötigt wird, wird an einem Ort in einer Sprache definiert </li></ol><br>  Es war einmal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, dass der</a> Autor einen solchen Operator erstellt hat, der den selbst erstellten Prozessor der implementierten Teilmenge von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TTM / Tutorial D erweitert.</a>  Jetzt wird die gleiche Idee für SQL vorgeschlagen. <br><br>  Es ist eine Warnung wert, hier endet SQL und die Improvisation beginnt.  Die Syntax bleibt wie im Original, am Ende kann syntaktischer Zucker alles sein, es ändert nichts an der Essenz. <br><br>  Der <b>Kauoperator</b> besteht also aus <br><br><ol><li>  Ein Header, der eine Liste der Ausgabefelder und ihrer Typen enthält. <br>  Jedes Ausgabe- (und Eingabe-) Feld ist eine lokale Variable. <br>  Beispiel: <i>"Kauen {" var1 "float," var2 "Ganzzahl}"</i> bedeutet, dass der Ausgabestream zwei Spalten enthält - einen Gleitkomma- und eine Ganzzahl </li><li>  Körper - eine Liste von Rückrufen für Ereignisse im Moment - der Beginn des Streams, das Ende des Streams, die Zeile.  Nach der Syntax liegen die Funktionen in der Nähe von PL / SQL.  Die vordefinierte Funktion <i>__interrupt</i> () ist ein Analogon zu PIPE. Sie nimmt Werte aus den Variablen, die den Ausgabespalten entsprechen, und platziert sie im Ausgabestream.  Wenn der Puffer des Ausgabestreams voll ist, wird der Handler angehalten und die empfangende Seite des Streams beginnt zu arbeiten. <br>  Beispiel: "hook" init "{var1: = 0;  var2: = -1;  } " </li></ol><br>  Der einfachste Weg, Beispiele zu zeigen. <br><br><ul><li>  Ein Analogon der Aggregatfunktion SUM. <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  'select sum(val) from samples' -- select * from samples chew {“sum(val)” float} --    hook “init” { “sum(val)” := 0; --      } hook “row” { if (not isnull("val")) then "sum(val)" := "sum(val)" + "val"; end if; } hook “finit” { call __interrupt(); --  PIPE }</span></span></code> </pre><br>  Es sieht sperrig aus, ist aber nur ein Beispiel. <br>  Es ist nicht erforderlich, ein C-Programm zu schreiben, um einige Zahlen hinzuzufügen. </li><li>  SUM + AVG <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  'select sum(val), avg(val) from samples' -- select * from samples chew { “sum(val)” float, “avg(val)” float --       } hook “init” { “sum(val)” := 0; “avg(val)” := 0; var num integer; num := 0; --    ,       } hook “row” { if (not isnull("val")) then "sum(val)" := "sum(val)" + "val"; num := num + 1; end if; } hook “finit” { if (num &gt; 0) then “avg(val)” := “sum(val)” / num; end if; call __interrupt(); }</span></span></code> </pre><br>  Hier machen wir darauf aufmerksam, dass die Summierung nur einmal erfolgt. </li><li>  SUM + GROUP BY <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  'select sum(val) from samples group by type' -- select * from --     ( samples val, type from samples order by type ) chew { “sum(val)” float } hook “init” { “sum(val)” := 0; var gtype integer; gtype := NULL; var num integer; --   num := 0; } hook “row” { if (gtype &lt;&gt; “type”) then __interrupt(); “gtype” := type; "sum(val)" := 0; num := 0; end if; if (not isnull("val")) then "sum(val)" := "sum(val)" + "val"; num := num + 1; end if; } hook “finit” { if (num &gt; 0) then call __interrupt(); end if; }</span></span></code> </pre></li><li>  ROW_NUMBER () OVER () <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">-- select row_number() over() as num, * from samples -- select * from samples chew { “num” integer, * --        --   '* except val1, ...valX',   TTM } hook “init” { num := 0; } hook “row” { num := num + 1; call __interrupt(); }</span></span></code> </pre></li></ul><br>  Ist es möglich, ein Beispiel anzubieten, anhand dessen dieser Ansatz Ergebnisse liefert, die auf übliche Weise grundsätzlich unerreichbar sind?  Wir haben sie. <br><br>  Manchmal kommt es vor, dass die Daten fast sortiert sind.  Sie können sogar vollständig sortiert sein, aber es ist nicht sicher bekannt. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angenommen, im obigen Beispiel (Datenstromkomprimierung) stammen die Daten aus verschiedenen Quellen und können aus verschiedenen Gründen leicht gemischt werden.</font></font> Das heißt,<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Zeile von einer Quelle mit dem Zeitstempel T1 kann sich in der Datenbank nach einer Zeile von einer anderen Quelle mit der Zeit T2 befinden, während T1 &lt;T2 ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selbst wenn wir garantieren, dass der Unterschied zwischen T1 und T2 niemals eine bestimmte (spärliche) Konstante überschreitet, können wir hier nicht (auf herkömmliche Weise) auf Sortierung verzichten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unter Verwendung des vorgeschlagenen Ansatzes ist es jedoch möglich, den Eingabestrom zu puffern und die Daten des aktuellen Zeitintervalls erst zu verarbeiten, nachdem die Eingabe Zeilen mit einem Zeitstempel empfangen hat, der mindestens eine gegebene Konstante um die rechte Grenze des Intervalls überschreitet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier gibt es einen sehr wichtigen Punkt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nur wir wissen, dass die Daten fast sortiert sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nur wir kennen den Wert dieser Konstante.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Konstante ist nur für dieses Problem und möglicherweise nur für dieses Experiment charakteristisch. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und wir verwenden diesen Hack in eigener Verantwortung, um ein Sortieren zu vermeiden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unser Standardwissen über die Aufgabe ist nicht in der Regel vorhanden, um es dem SQL-Prozessor mitzuteilen, und es ist schwer vorstellbar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verwendung von Lambda-Funktionen bietet eine universelle Möglichkeit, den SQL-Prozessor zu zwingen, genau das zu tun, was wir brauchen, genau dort, wo wir es brauchen.</font></font><br><br><h4>  Fazit </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das vorgeschlagene Design scheint nicht sehr schwierig zu implementieren zu sein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In jedem Fall mit gültigem PL / SQL. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Idee selbst ist einfach und intuitiv und fügt der Sprache keine neuen Entitäten hinzu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist eine einzelne Einheit, die bei Bedarf die Aggregat- und Fensterfunktionen GROUP BY ersetzt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Mechanismus, mit dem Sie auf Sortierungen verzichten können, bei denen ein herkömmlicher SQL-Prozessor keine Möglichkeit bietet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vor allem aber ist es ein Mechanismus, der Ihnen die Freiheit gibt, mit den Daten alles zu tun, was Sie wollen. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vielen Dank an Dorofei Proleskovsky für die Teilnahme an der Vorbereitung des Artikels.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435120/">https://habr.com/ru/post/de435120/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435106/index.html">Noch einmal über passport.js</a></li>
<li><a href="../de435108/index.html">Mit Prolog</a></li>
<li><a href="../de435112/index.html">Unternehmensinterview</a></li>
<li><a href="../de435114/index.html">Federdaten jpa</a></li>
<li><a href="../de435118/index.html">Save File Me - ein kostenloser Sicherungsdienst mit clientseitiger Verschlüsselung</a></li>
<li><a href="../de435122/index.html">Wie die Flamme in Doom auf der Playstation implementiert wurde</a></li>
<li><a href="../de435124/index.html">Meisterwerke der Weltsäulenkonstruktion: ein Studiomonitor-Transformator mit variabler Anzahl von Bändern</a></li>
<li><a href="../de435126/index.html">Erfahrung in der Organisation und Durchführung von Unternehmenskonferenzen für Analysten</a></li>
<li><a href="../de435128/index.html">Pi-Sonos: ein außer Kontrolle geratenes Hobby</a></li>
<li><a href="../de435132/index.html">Nomad: Probleme und Lösungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>