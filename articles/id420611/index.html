<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕊️ 🏴 🤱🏼 Pemodelan keterikatan kuantum dalam C # 🤯 👭 🤚🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ketika topik keterikatan kuantum semakin banyak muncul, saya ingin melangkah lebih dalam. Dilihat oleh komentar pada artikel tentang keterikatan kuant...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemodelan keterikatan kuantum dalam C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420611/">  Ketika topik keterikatan kuantum semakin banyak muncul, saya ingin melangkah lebih dalam.  Dilihat oleh komentar pada artikel tentang keterikatan kuantum, informasi ini tidak akan berguna bagi saya sendiri.  Nah, dengan mempertimbangkan fakta bahwa bagi sebagian besar dari kita, kode program jauh lebih nyaman daripada kiasan apa pun, diputuskan untuk menyajikan pemahaman saya dalam bentuk kode. <br><a name="habracut"></a><br>  Artikel ini memperluas artikel penulis lain <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Keterikatan Kuantum untuk Dummies"</a> (Saya sarankan membacanya, itu banyak membantu saya).  Dalam artikelnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">indomit</a> memberikan contoh program yang dengan jelas menunjukkan masalah teori parameter tersembunyi, tetapi tidak dapat memberikan contoh kode untuk partikel dalam superposisi.  Pada artikel ini, kami akan mencoba mensimulasikan 2 kasus: <br><br><ol><li>  Bagaimana partikel-partikel terjerat berperilaku dalam determinisme, ketika keadaan partikel terbentuk sebelum pengukuran, kita tidak bisa mengukurnya tanpa memperkenalkan distorsi (teori parameter tersembunyi).  Kami mendapatkan angka-angka dan melihat perbedaan dengan latihan. </li><li>  Kami akan menulis model partikel terjerat dalam superposisi (keadaan partikel tidak ditentukan sebelum pengukuran).  Mari kita coba asumsikan bagaimana partikel diprogram di dalam, yaitu, kita akan menyesuaikan kodenya dengan data yang diperoleh secara eksperimental. </li></ol><br>  Artikel ini didasarkan pada penjelasan populer tentang fenomena keterikatan kuantum dari Mermin: <br><br><div class="spoiler">  <b class="spoiler_title">Paradox Mermin Dijelaskan</b> <div class="spoiler_text">  Untuk laporan populer paradoks, D. Mermin mengusulkan untuk membangun perangkat sederhana [23].  Perangkat harus terdiri dari penghasil partikel dan dua detektor.  Dua partikel identik dipancarkan ke masing-masing.  Setelah menangkap partikel, detektor memberikan jawaban biner (0 atau 1), tergantung pada partikel dan sakelar penyetelan tiga posisi.  Mendeteksi sepasang partikel harus memberikan jawaban yang sama: <br><br><ol><li>  Setiap kali detektor dikonfigurasikan dengan cara yang sama. </li><li>  Menurut statistik, dalam setengah kasus ketika mereka dikonfigurasi secara acak. </li></ol><br>  Properti pertama mengharuskan semua detektor menggunakan pengkodean yang sama, posisi sakelar adalah ∈ {1,2,3} ↦ respons ∈ {0,1}, tanpa unsur keacakan.  Artinya, mereka harus menyetujui terlebih dahulu yang mana dari respon, 0 atau 1, berikan kepada posisi sakelar, memilih untuk setiap partikel satu dari delapan fungsi yang mungkin, 000, 001, 010, 011, 100, 101, 110 dan 111. Memilih 000 atau 111 akan menghasilkan hingga 100% kebetulan pembacaan detektor, terlepas dari posisi tombol kontrol.  Jika detektor menerapkan salah satu dari enam fungsi yang tersisa, salah satu digit ditarik oleh sakelar yang disetel secara acak dalam 2/3 dari kasing, yang lainnya dengan probabilitas 1/3.  Peluang dari kedua jawaban tersebut adalah (⅔) ² + (⅓) ² = 5/9.  Jadi apa pun algoritma otomatinya, korelasinya pasti melebihi 50%, melanggar persyaratan kedua. <br><br>  <i>Tetapi karena mesin seperti itu masih dapat dibangun (misalnya, dengan memposisikan polarizer pada 120 ° seperti dalam percobaan Bohm), tidak ada determinisme (parameter) bahkan dalam bentuk tersembunyi.</i>  <i>Alih-alih, korelasi respons dipertahankan dengan mengirimkan informasi dari satu partikel "terukur" ke partikel lain yang lebih cepat daripada pengukuran kedua.</i> <br><br>  Diambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari sini</a> . <br></div></div><br>  Sayangnya, saya tidak melakukan fisika baik secara profesional atau bahkan pada tingkat amatir, saya tidak berpura-pura menjadi sempurna.  Tujuan utama dari artikel ini adalah untuk menunjukkan bagaimana membuat model dapat dimengerti oleh mereka yang terbiasa dengan pemrograman.  Jika seseorang secara profesional bekerja di bidang ini, maka alih-alih mencela, coba tulis model interaksi yang lebih akurat berdasarkan artikel saya. <br><br><h2>  [Perbarui] Penjelasan deskripsi Mermin </h2><br>  Meskipun beberapa bulan telah berlalu sejak penulisan artikel dan tidak ada yang akan kembali ke sana, saya memutuskan untuk membuat klarifikasi untuk menenangkan hati nurani saya. <br><br>  Saya pergi sedikit lebih dalam dan sampai pada kesimpulan bahwa deskripsi menurut Mermin sangat disederhanakan dan upaya untuk menghubungkannya dengan eksperimen fisik nyata <i>tidak</i> ada <i>artinya</i> . <br><br>  Awalnya, saya mencoba menghubungkan artikel itu dengan eksperimen nyata dengan polarisasi sirkular, dan saya membuat kesalahan dalam hal ini.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">ARad</a> mencoba mengembangkan ikatan dengan eksperimen fisik nyata, menulis tentang kesalahan yang dibuat, dan bahkan mengusulkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">versi kodenya sendiri</a> (yang juga tidak sesuai dengan eksperimen fisik apa pun). <br><br>  Agar artikel masuk akal setidaknya, diputuskan untuk menghapus semua tautan imajiner ke eksperimen fisik nyata dan cukup <i>menjelaskan deskripsi Mermin dalam kode</i> dan membuatnya lebih visual.  Eksperimen nyata lebih rumit dan untuk mensimulasikannya Anda perlu menghabiskan lebih banyak waktu. <br><br>  Dalam versi pertama artikel, kami menerima bahwa dalam percobaan pertama (posisi sensor bertepatan) partikel memberikan hasil cermin, tetapi dalam deskripsi asli menurut Mermin hasil pengukuran dengan posisi sensor yang sama selalu bertepatan.  Ini sudah <i>diperbaiki</i> . <br><br>  Selain itu, saya akan menambahkan "penjelasan untuk penjelasan" dari Mermin ini sendiri, karena tidak ditulis dengan jelas: <br><br><blockquote>  Artinya, mereka harus menyetujui terlebih dahulu yang mana dari respon, 0 atau 1, berikan kepada posisi sakelar, memilih untuk setiap partikel satu dari delapan fungsi yang mungkin, 000, 001, 010, 011, 100, 101, 110 dan 111. <br></blockquote><br>  Ungkapan "delapan fungsi yang mungkin" adalah ambigu.  Delapan kemungkinan varian dampak <i>potensial</i> partikel pada sensor dibahas.  Sensor memiliki tiga posisi (lihat uraian lengkap di atas).  Jika kita percaya bahwa keadaan kedua partikel tersebut bertepatan dan diatur terlebih dahulu, maka kita dapat menentukan terlebih dahulu respons mana (0 atau 1) yang berpotensi kita terima untuk masing-masing dari tiga posisi sakelar (walaupun kita dapat "mengukur" hanya satu dari tiga opsi). <br><br><blockquote>  Memilih 000 atau 111 akan menghasilkan 100% cocok dengan pembacaan detektor terlepas dari posisi tombol tuning. </blockquote><br>  Jika partikel dapat mengambil nilai di mana kita berpotensi menerima respons "1" untuk setiap posisi sakelar (dan juga 0 untuk posisi sakelar mana pun), maka percobaan kedua dalam kasus ini akan memberikan 100% kebetulan.  Untuk mendekati 50%, opsi ini dapat dikecualikan. <br><br><blockquote>  Jika detektor menerapkan salah satu dari enam fungsi yang tersisa, salah satu digit ditarik oleh sakelar yang disetel secara acak dalam 2/3 dari kasing, yang lainnya dengan probabilitas 1/3. </blockquote><br>  Ini berarti bahwa di masing-masing dari tiga kali lipat (001, 010, 011, 100, 101, 110) - hanya dua dari tiga digit yang cocok (dalam versi pertama, dua dari tiga adalah "0", dan salah satu dari ketiganya adalah "1" ) <br><br>  Untuk menilai probabilitas, kami menyusun tabel untuk kasus pertama <b>001</b> : <br><br><table><tbody><tr><th>  Posisi Sensor 1 </th><th>  Posisi Sensor 2 </th><th>  Apakah pengukuran cocok </th></tr><tr><td>  1 </td><td>  1 </td><td>  + </td></tr><tr><td>  1 </td><td>  2 </td><td>  + </td></tr><tr><td>  1 </td><td>  3 </td><td>  - </td></tr><tr><td>  2 </td><td>  1 </td><td>  + </td></tr><tr><td>  2 </td><td>  2 </td><td>  + </td></tr><tr><td>  2 </td><td>  3 </td><td>  - </td></tr><tr><td>  3 </td><td>  1 </td><td>  - </td></tr><tr><td>  3 </td><td>  2 </td><td>  - </td></tr><tr><td>  3 </td><td>  3 </td><td>  + </td></tr></tbody></table><br>  Dapat dilihat bahwa dalam lima kasus dari sembilan pengukuran bertepatan.  Probabilitas yang sama akan untuk masing-masing dari enam opsi ini (setelah semua, di masing-masing dari mereka dua angka sama). <br><br><h2>  Pengukuran </h2><br>  Dalam masing-masing model (deterministik dan superposisi), kami akan melakukan dua percobaan dengan partikel terjerat yang sesuai dengan kondisi pertama dan kedua menurut Mermin: <br><br><ol><li>  Pertama, atur kedua sensor pada posisi yang sama.  Dalam hal ini, kita akan memperoleh hasil identik 100% (jika foton pertama melewati polarizer, maka foton yang terkait juga melewati polarizer pada sudut yang sama). </li><li>  Kemudian kita akan mengatur posisi sensor secara acak. </li></ol><br>  Berikut ini kode untuk percobaan pertama: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> totalAttempts = <span class="hljs-number"><span class="hljs-number">10000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     var position = GetRandomInteger(1, 3); //        //            int firstSensorPosition = position; int secondSensorPosition = position; bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" №1: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); //  </span></span></code> </pre> <br>  Berikut ini kode untuk percobaan kedua: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> totalAttempts = <span class="hljs-number"><span class="hljs-number">10000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     int firstSensorPosition = GetRandomInteger(1, 3); //      1 int secondSensorPosition = GetRandomInteger(1, 3); //      2 bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" №2: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100);</span></span></code> </pre><br>  Tes yang sama akan untuk semua model partikel, hanya kode partikel akan berbeda untuk model deterministik dan superposisi (lebih lanjut tentang ini di bawah). <br><br><h2>  Model deterministik </h2><br>  Perhatian!  Lihat PEMBARUAN di akhir artikel! <br><br>  Bagi mereka yang ingin segera menjalankan kode, ini dapat dilakukan dari browser: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dotnetfiddle.net/N5Xg18</a> <br><br>  Jadi, menurut penjelasan Mermin, kami memiliki partikel kuantum dengan 3 parameter: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   ( , ) public class Particle { private bool _measured = false; public bool A { get; private set; } //       1 public bool B { get; private set; } //       2 public bool C { get; private set; } //       3 public Particle(bool a, bool b, bool c) { A = a; B = b; C = c; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (_measured) throw new InvalidOperationException("    !"); _measured = true; switch (sensorPosition) { case 1: return A; case 2: return B; case 3: return C; default: throw new ArgumentOutOfRangeException(); } } }</span></span></code> </pre><br>  Karena model bersifat deterministik, semua parameter partikel diinisialisasi pada saat pembuatannya, yaitu langsung di konstruktor.  Satu-satunya syarat adalah pengukuran hanya diperbolehkan sekali! <br><br>  Selanjutnya  Sepasang partikel terjerat: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (   ,         ) public EntanglementParticles() { //         bool a; bool b; bool c; do { a = GetRandomBoolean(); //     1 b = GetRandomBoolean(); //     2 c = GetRandomBoolean(); ; //     3 } while (a == b &amp;&amp; b == c); //   000  111 (    ,       ) First = new Particle(a, b, c); Second = new Particle(a, b, c); //       } }</span></span></code> </pre><br><br>  Dapat dilihat bahwa nilai-nilai dari masing-masing partikel diatur pada saat membuat pasangan partikel terjerat, dan parameter dari partikel kedua sesuai dengan parameter yang pertama (tanpa ini kita tidak dapat melewati tes pertama).  Kami menggunakan angka acak, tetapi menurut model, parameter tergantung pada faktor-faktor pada saat kekusutan (sebagai akibat dari roulette, itu tergantung pada sejumlah faktor pada saat unwinding). <br><br>  Kode contoh lengkap: <br><br><div class="spoiler">  <b class="spoiler_title">Kode C # dari model deterministik (tetap)</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Random Random = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); <span class="hljs-comment"><span class="hljs-comment">//   public class Particle { private bool _measured = false; public bool A { get; private set; } //       1 public bool B { get; private set; } //       2 public bool C { get; private set; } //       3 public Particle(bool a, bool b, bool c) { A = a; B = b; C = c; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (_measured) throw new InvalidOperationException("    !"); _measured = true; switch (sensorPosition) { case 1: return A; case 2: return B; case 3: return C; default: throw new ArgumentOutOfRangeException(); } } } //    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (   ,         ) public EntanglementParticles() { //         bool a; bool b; bool c; do { a = GetRandomBoolean(); //     1 b = GetRandomBoolean(); //     2 c = GetRandomBoolean();; //     3 } while (a == b &amp;&amp; b == c); //   000  111 (   ,       ) First = new Particle(a, b, c); Second = new Particle(a, b, c); //       } } public static void Main(string[] args) { Experiment1(); Experiment2(); } private static void Experiment1() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     var position = GetRandomInteger(1, 3); //        //            int firstSensorPosition = position; int secondSensorPosition = position; bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" №1: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); //   } private static void Experiment2() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     int firstSensorPosition = GetRandomInteger(1, 3); //      1 int secondSensorPosition = GetRandomInteger(1, 3); //      2 bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" №2: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); } private static bool GetRandomBoolean() { return GetRandomInteger(0, 1) == 1; } private static int GetRandomInteger(int from, int to) { return Random.Next(from, to + 1); //          } }</span></span></code> </pre><br></div></div><br>  Anda dapat memulainya dari browser (sekali lagi tautan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dotnetfiddle.net/N5Xg18</a> ). <br><br>  Setelah diluncurkan, inilah hasilnya: <br><br><blockquote>  Eksperimen No. 1: 100% dari nilai-nilai tersebut bertepatan <br>  Eksperimen No. 2: 55.6700% dari nilai yang cocok <br></blockquote><br>  Tes pertama berlalu, sesuai dengan apa yang terjadi dalam kenyataan.  Tetapi yang kedua - tidak cocok, karena mereka harus mendapatkan 50%! <br><br>  Akibatnya, fisikawan terpaksa sampai pada kesimpulan bahwa teori parameter tersembunyi salah.  Dan dengan itu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prinsip lokalitas</a> disangkal dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prinsip kausalitas</a> bahkan telah diguncang. <br><br><h2>  Model Superpositional </h2><br>  Segera tautan ke kode contoh, bagi mereka yang suka spesifik (dapat diluncurkan di browser): <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dotnetfiddle.net/Mb7JqU</a> <br><br>  Untuk menjelaskan hasil yang diperoleh selama percobaan, perlu untuk menggunakan model yang lebih kompleks.  Dalam model modern, keadaan parameter partikel tidak ditentukan sebelum pengukuran, dan partikel yang terjerat sendiri memiliki kemampuan untuk secara instan (melebihi kecepatan cahaya) memengaruhi kondisi masing-masing.  Seperti apa model partikel kita sekarang: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   public class Particle { private Particle _superluminalChannel; //         . private int? _measuredPosition; public bool? A { get; private set; } //       1 public bool? B { get; private set; } //       2 public bool? C { get; private set; } //       3 internal void CreateSuperluminalChannelWith(Particle particle) { _superluminalChannel = particle; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (null != _measuredPosition) throw new InvalidOperationException("    !"); _measuredPosition = sensorPosition; if (null != _superluminalChannel._measuredPosition) //        { var measuredValue = _superluminalChannel.GetNakedValue(); //         (    ),   ,     . if (sensorPosition == _superluminalChannel._measuredPosition) return measuredValue; if (GetRandomInteger(1, 4) == 1) return measuredValue; return !measuredValue; } //  .        ,       -  . //   ! var value = GetRandomBoolean(); SetValue(sensorPosition, value); return value; } private bool GetNakedValue() //           ,    . { if (null == _measuredPosition) throw new InvalidOperationException(); switch (_measuredPosition.Value) { case 1: return A.Value; case 2: return B.Value; case 3: return C.Value; default: throw new InvalidOperationException(); } } private void SetValue(int position, bool value) { switch (position) { case 1: A = value; break; case 2: B = value; break; case 3: C = value; break; default: throw new ArgumentOutOfRangeException(); } } }</span></span></code> </pre><br>  Pertama, parameternya adalah Nullable (mungkin tidak masalah) dan kami tidak mengaturnya di konstruktor.  Kedua, metode CreateSuperluminalChannelWith untuk mengatur saluran superlight antara partikel, yaitu  Sekarang satu partikel bisa mendapatkan keadaan yang lain secara instan, terlepas dari jarak.  Nah, dan yang paling penting, sekarang keadaan sebuah partikel <i>hanya terbentuk pada saat pengukuran</i> (memanggil metode GetValue) dan tergantung pada apakah partikel lain yang terkait dengannya diukur. <br><br>  Bagian dalam metode GetValue adalah spekulasi murni.  Tidak ada yang tahu bagaimana partikel diatur di dalam, tetapi kita tahu bahwa itu berfungsi seperti itu: 100% ketidakcocokan saat mengukur parameter yang sama dan 50% ketidakcocokan saat mengukur parameter dalam urutan acak. <br><br>  Dalam versi kode saya, sebuah partikel melalui saluran superluminal memeriksa apakah pengukuran dibuat bingung dengan itu dan bertindak seperti ini: <br><br><ol><li>  Jika parameter yang diukur dari partikel lain sama dengan yang kita coba ukur, itu memberikan nilai yang sama. </li><li>  Jika parameternya berbeda, maka dalam 1/4 dari kasus itu memberikan nilai yang sama, dan dalam 3/4 kasus itu memberikan nilai yang berlawanan (karena kita mendapatkan 50/50). </li></ol><br>  Jika pengukuran tidak dilakukan, partikel menggunakan keacakan benar untuk menetapkan nilainya, yaitu hubungan sebab akibat dilanggar (nilai tidak ada sebelum pengukuran dan pengukuran itu sendiri tidak menentukan nilainya). <br><br>  <i>Ngomong-ngomong!</i>  <i>Anda dapat menulis ulang fungsi ini dengan cara lain, tetapi agar hasil pengujiannya sama.</i>  <i>Semua sama, tidak ada yang tahu bagaimana partikel elementer diatur dan bagaimana 50% dicapai untuk tes kedua.</i> <i><br></i> <br>  Sepasang partikel terjerat menjadi lebih mudah, karena pada saat belitan tidak ada nilai yang ditetapkan (nilai belum ditentukan): <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (  ,   ) public EntanglementParticles() { First = new Particle(); //   ,    Second = new Particle(); //   ,    //         First.CreateSuperluminalChannelWith(Second); Second.CreateSuperluminalChannelWith(First); } }</span></span></code> </pre><br>  Kode contoh lengkap: <br><br><div class="spoiler">  <b class="spoiler_title">Model superposisi dalam C #</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Random Random = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); <span class="hljs-comment"><span class="hljs-comment">//   public class Particle { private Particle _superluminalChannel; //         . private int? _measuredPosition; public bool? A { get; private set; } //       1 public bool? B { get; private set; } //       2 public bool? C { get; private set; } //       3 internal void CreateSuperluminalChannelWith(Particle particle) { _superluminalChannel = particle; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (null != _measuredPosition) throw new InvalidOperationException("    !"); _measuredPosition = sensorPosition; if (null != _superluminalChannel._measuredPosition) //        { var measuredValue = _superluminalChannel.GetNakedValue(); //         (    ),   ,     . if (sensorPosition == _superluminalChannel._measuredPosition) return measuredValue; if (GetRandomInteger(1, 4) == 1) return measuredValue; return !measuredValue; } //  .        ,       -  . //   ! var value = GetRandomBoolean(); SetValue(sensorPosition, value); return value; } private bool GetNakedValue() //           ,    . { if (null == _measuredPosition) throw new InvalidOperationException(); switch (_measuredPosition.Value) { case 1: return A.Value; case 2: return B.Value; case 3: return C.Value; default: throw new InvalidOperationException(); } } private void SetValue(int position, bool value) { switch (position) { case 1: A = value; break; case 2: B = value; break; case 3: C = value; break; default: throw new ArgumentOutOfRangeException(); } } } //    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (  ,   ) public EntanglementParticles() { First = new Particle(); //   ,    Second = new Particle(); //   ,    //         First.CreateSuperluminalChannelWith(Second); Second.CreateSuperluminalChannelWith(First); } } public static void Main(string[] args) { Experiment1(); Experiment2(); } private static void Experiment1() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     var position = GetRandomInteger(1, 3); //        //            int firstSensorPosition = position; int secondSensorPosition = position; bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" №1: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); //   } private static void Experiment2() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     int firstSensorPosition = GetRandomInteger(1, 3); //      1 int secondSensorPosition = GetRandomInteger(1, 3); //      2 bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" №2: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); } private static bool GetRandomBoolean() { return GetRandomInteger(0, 1) == 1; } private static int GetRandomInteger(int from, int to) { return Random.Next(from, to + 1); //          } }</span></span></code> </pre><br></div></div><br>  Hasil: <br><br><blockquote>  Eksperimen No. 1: 100% dari nilai-nilai tersebut bertepatan <br>  Eksperimen No. 2: 49.7700% dari nilai-nilai tersebut bertepatan <br></blockquote><br>  Jalankan di browser: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dotnetfiddle.net/Mb7JqU</a> <br><br><h2>  Kesimpulan </h2><br>  Saya ingin lebih banyak interpretasi tersedia, seperti yang diungkapkan oleh Mermin.  Berdasarkan interpretasi ini, saya berhasil membuat model visual dari teori yang ada dan bahkan mengajukan model alternatif, dan model ini tidak bersifat alegoris - Anda dapat menjalankannya dan melihat cara kerjanya. <br><br>  Sayangnya, saya tidak memiliki sumber daya waktu untuk pengetahuan fisika kuantum yang lebih dalam dan saya berharap mereka yang tahu bisa mengikuti contoh saya dan memberikan model kerja yang lebih akurat. <br><br>  <b>PEMBARUAN</b> <br>  Penjelasan Mermin tidak lain tentang desain detektor.  Atas inisiatif saya sendiri, saya menambahkan penjelasan pada A, B, dan C sebagai proyeksi putaran ke masing-masing sumbu X, Y, dan Z.  Artinya, saya ingin menambahkan pengikatan ke fenomena fisik dalam komentar ke kode sehingga tidak akan terlalu kering.  Dan saya salah dalam hal ini ... <br><br>  Artikel ini diperbaiki dan semua upaya sia-sia untuk menghubungkan penjelasan Mermin dengan eksperimen fisik nyata dihapus. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420611/">https://habr.com/ru/post/id420611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420599/index.html">Tiga Belas Hal Yang Terlihat Lama</a></li>
<li><a href="../id420603/index.html">Statistik dari pemilik Tesla Model S</a></li>
<li><a href="../id420605/index.html">Ikhtisar Algoritma Wawancara Kerja - Mengatur Generasi</a></li>
<li><a href="../id420607/index.html">Acara digital di Moskow dari 20 hingga 26 Agustus</a></li>
<li><a href="../id420609/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 327 (13 - 19 Agustus 2018)</a></li>
<li><a href="../id420613/index.html">11 pustaka (kumpulan komponen) untuk React Native yang harus Anda ketahui di 2018</a></li>
<li><a href="../id420615/index.html">JavaScript: menjelajahi objek</a></li>
<li><a href="../id420617/index.html">Panduan Desain Web untuk Pengembang</a></li>
<li><a href="../id420619/index.html">Gambar Responsif: Trik CSS Yang Menghemat Waktu</a></li>
<li><a href="../id420623/index.html">Aplikasi C ++ terdistribusi dengan upaya minimal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>