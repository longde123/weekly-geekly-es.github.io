<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äç‚úàÔ∏è üë©‚Äçüéì üë©üèø‚Äçüè≠ Biblioteca generadora de c√≥digo ensamblador para microcontroladores AVR. Parte 5 ü§æ üëÜüèª üõ´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚Üê Parte 4. Programaci√≥n de perif√©ricos y manejo de interrupciones 
 Biblioteca de generador de c√≥digo ensamblador para microcontroladores AVR 
 Parte ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Biblioteca generadora de c√≥digo ensamblador para microcontroladores AVR. Parte 5</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464651/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">‚Üê Parte 4. Programaci√≥n de perif√©ricos y manejo de interrupciones</a> </p><br><h2 id="biblioteka-generatora-assemblernogo-koda-dlya-mikrokontrollerov-avr">  Biblioteca de generador de c√≥digo ensamblador para microcontroladores AVR </h2><br><h3 id="chast-5-proektirovanie-mnogopotochnyh-prilozheniy">  Parte 5. Dise√±o de aplicaciones de subprocesos m√∫ltiples </h3><br><p>  En las partes anteriores del art√≠culo, elaboramos los conceptos b√°sicos de la programaci√≥n utilizando la biblioteca.  En la parte anterior, nos familiarizamos con la implementaci√≥n de interrupciones y las restricciones que pueden surgir al trabajar con ellas.  En esta parte de la publicaci√≥n, nos detendremos en una de las posibles opciones para programar procesos paralelos utilizando la clase <em>Paralelo</em> .  El uso de esta clase hace posible simplificar la creaci√≥n de aplicaciones en las que los datos deben procesarse en varias secuencias de programas independientes. </p><a name="habracut"></a><br><p>  Todos los sistemas multitarea para sistemas de un solo n√∫cleo son similares entre s√≠.  El subprocesamiento m√∫ltiple se implementa a trav√©s del trabajo del despachador, que asigna un intervalo de tiempo para cada subproceso, y cuando finaliza, toma el control y da el control al siguiente subproceso.  La diferencia entre las diversas implementaciones est√° solo en los detalles, por lo que nos detendremos en m√°s detalles principalmente en las caracter√≠sticas espec√≠ficas de esta implementaci√≥n. </p><br><p>  La unidad de ejecuci√≥n del proceso en el hilo es la tarea.  Puede existir un n√∫mero ilimitado de tareas en el sistema, pero en un momento dado solo se puede activar un cierto n√∫mero de ellas, limitado por el n√∫mero de flujos de trabajo en el despachador.  En esta implementaci√≥n, el n√∫mero de flujos de trabajo se especifica en el constructor del administrador y no se puede cambiar posteriormente.  En el proceso, los hilos pueden realizar tareas o permanecer libres.  A diferencia de otras soluciones, <em>Parallel</em> Manager no cambia las tareas.  Para que la tarea devuelva el control al despachador, se deben insertar comandos apropiados en su c√≥digo.  Por lo tanto, la responsabilidad de la duraci√≥n del intervalo de tiempo en la tarea recae en el programador, que debe insertar comandos de interrupci√≥n en ciertos lugares del c√≥digo si la tarea lleva demasiado tiempo, as√≠ como determinar el comportamiento del hilo al completar la tarea.  La ventaja de este enfoque es que el programador controla los puntos de conmutaci√≥n entre tareas, lo que le permite optimizar significativamente el c√≥digo de guardar / restaurar al cambiar de tarea, as√≠ como deshacerse de la mayor√≠a de los problemas relacionados con el acceso a datos seguro para subprocesos. </p><br><p>  Para controlar la ejecuci√≥n de las tareas en ejecuci√≥n, se utiliza una clase especial de <em>se√±al</em> .  La se√±al es una variable de bit, cuya configuraci√≥n se utiliza como se√±al de habilitaci√≥n para iniciar una tarea en una secuencia.  Los valores de la se√±al pueden establecerse manualmente o mediante un evento asociado con esta se√±al. </p><br><p>  La se√±al se restablece cuando el despachador activa la tarea o se puede realizar mediante programaci√≥n. </p><br><p>  Las tareas en el sistema pueden estar en los siguientes estados: </p><br><p>  <strong>Desactivado</strong> : estado inicial para todas las tareas.  La tarea no ocupa el flujo y el control de ejecuci√≥n no se transfiere.  El retorno a este estado para las tareas activadas se produce al completar el comando. </p><br><p>  <strong>Activado</strong> : el estado en el que se encuentra la tarea despu√©s de la activaci√≥n.  El proceso de activaci√≥n asocia una tarea con un hilo de ejecuci√≥n y una se√±al de activaci√≥n.  El administrador sondea los hilos y comienza la tarea si la se√±al de la tarea est√° activada. </p><br><p>  <strong>Bloqueado</strong> : cuando se activa una tarea, se le puede asignar una se√±al como se√±al, que ya se utiliza para controlar otro subproceso.  En este caso, para evitar la ambig√ºedad del comportamiento del programa, la tarea activada pasa al estado bloqueado.  En este estado, la tarea ocupa el hilo, pero no puede recibir el control, incluso si su se√±al est√° activada.  Al finalizar las tareas o al cambiar la se√±al de activaci√≥n, el despachador verifica y cambia el estado de las tareas en los hilos.  Si los hilos han bloqueado tareas para las cuales la se√±al coincide con la liberada, se activa el primero encontrado.  Si es necesario, el programador puede bloquear y desbloquear tareas independientemente, en funci√≥n de la l√≥gica requerida del programa. </p><br><p>  <strong>En espera</strong> : el estado en el que se encuentra la tarea despu√©s de ejecutar el comando <em>Delay</em> .  En este estado, la tarea no recibe control hasta que haya transcurrido el intervalo requerido.  En la clase <em>paralela</em> , se utilizan interrupciones WDT de 16 ms para controlar el retraso, lo que permite no ocupar temporizadores para las necesidades del sistema.  En caso de que necesite m√°s estabilidad o resoluci√≥n en peque√±os intervalos, en lugar de <em>Retardo,</em> puede usar la activaci√≥n por se√±ales de temporizador.  Debe tenerse en cuenta que la precisi√≥n del retraso seguir√° siendo baja y fluctuar√° en el rango de <em>"tiempo de respuesta del despachador" - "duraci√≥n m√°xima de intervalo de tiempo en el sistema + tiempo de respuesta del despachador"</em> .  Para tareas con rangos de tiempo exactos, se debe usar un modo h√≠brido, en el que el temporizador que no se usa en la clase <em>Paralela</em> funciona independientemente del flujo de la tarea y procesa los intervalos en el modo de interrupci√≥n pura. </p><br><p>  Cada tarea ejecutada en un hilo es un proceso aislado.  Esto requiere la definici√≥n de dos tipos de datos: datos locales de una secuencia, que deber√≠an ser visibles y cambiados solo dentro del marco de esta secuencia, y datos globales para el intercambio entre flujos y acceso a recursos compartidos.  En el marco de esta implementaci√≥n, los datos globales se crean mediante comandos previamente considerados en el nivel del dispositivo.  Para crear variables de tareas locales, deben crearse utilizando m√©todos de la clase de tarea.  El comportamiento de la variable de tarea local es el siguiente: cuando la tarea se interrumpe antes de transferir el control al despachador, todas las variables de registro local se almacenan en la memoria de la secuencia.  Cuando se devuelve el control, las variables de registro local se restauran antes de ejecutar el siguiente comando. <br>  Una clase con la interfaz <em>IHeap</em> asociada con la propiedad <em>Heap</em> de la clase <em>Parallel</em> es responsable de almacenar los datos locales de la secuencia.  La implementaci√≥n m√°s simple de esta clase es <em>StaticHeap</em> , que implementa la asignaci√≥n est√°tica de los mismos bloques de memoria para cada subproceso.  En caso de que las tareas tengan una gran extensi√≥n de acuerdo con la demanda de la cantidad de datos locales, puede usar <em>DynamicHeap</em> , que le permite determinar el tama√±o de la memoria local individualmente para cada tarea.  Obviamente, la sobrecarga de trabajar con memoria de flujo en este caso ser√° significativamente mayor. </p><br><p>  Ahora echemos un vistazo m√°s de cerca a la sintaxis de la clase usando dos flujos como ejemplo, cada uno de los cuales cambia independientemente una salida de puerto separada. </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328 { FCLK = <span class="hljs-number"><span class="hljs-number">16000000</span></span>, CKDIV8 = <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; m.PortB.Direction(<span class="hljs-number"><span class="hljs-number">0x07</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bit1 = m.PortB[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bit2 = m.PortB[<span class="hljs-number"><span class="hljs-number">2</span></span>]; m.PortB.Activate(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tasks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Parallel(m, <span class="hljs-number"><span class="hljs-number">2</span></span>); tasks.Heap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticHeap(tasks, <span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = tasks.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); bit1.Toggle(); tsk.Delay(<span class="hljs-number"><span class="hljs-number">32</span></span>); tsk.TaskContinue(loop); },<span class="hljs-string"><span class="hljs-string">"Task1"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = tasks.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); bit2.Toggle(); tsk.Delay(<span class="hljs-number"><span class="hljs-number">48</span></span>); tsk.TaskContinue(loop); }, <span class="hljs-string"><span class="hljs-string">"Task2"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ca = tasks.ContinuousActivate(tasks.AlwaysOn, t1); tasks.ActivateNext(ca, tasks.AlwaysOn, t2); ca.Dispose(); m.EnableInterrupt(); tasks.Loop();</code> </pre> <br><p>  Las l√≠neas superiores del programa ya te son familiares.  En ellos, determinamos el tipo de controlador y asignamos el primer y segundo bits del puerto B como salida.  Luego viene la inicializaci√≥n de una variable de la clase <em>Paralelo</em> , donde en el segundo par√°metro determinamos el n√∫mero m√°ximo de hilos de ejecuci√≥n.  En la siguiente l√≠nea, asignamos memoria para acomodar flujos de variables locales.  Tenemos tareas iguales, por lo que utilizamos <em>StaticHeap</em> .  El siguiente bloque de c√≥digo es la definici√≥n de tarea.  En √©l, definimos dos tareas casi id√©nticas.  La √∫nica diferencia es el puerto de control y la cantidad de retraso.  Para trabajar con objetos de tareas locales, se pasa un puntero a la tarea local <em>tsk</em> al <em>bloque de c√≥digo de</em> la tarea.  El texto de la tarea en s√≠ es muy simple: </p><br><ul><li>  Se crea una etiqueta local para organizar un ciclo de cambio infinito </li><li>  el estado del puerto se invierte </li><li>  el control se devuelve al despachador y la tarea pasa al estado de espera durante el n√∫mero especificado de milisegundos </li><li>  El puntero de retorno se establece en el bloque de inicio del bloque y el control se devuelve al despachador. <br>  Obviamente, en un ejemplo concreto, el √∫ltimo comando podr√≠a reemplazarse por un comando normal para ir al comienzo del bloque y proporcionarse en el ejemplo solo con el prop√≥sito de demostrarlo.  Si lo desea, el ejemplo se puede ampliar f√°cilmente para controlar una gran cantidad de conclusiones, copiando tareas y aumentando el n√∫mero de hilos. </li></ul><br><p>  Una lista completa de comandos de aborto de tareas para transferir el control al despachador es la siguiente <br>  <strong>ESPERA (se√±al)</strong> : el flujo guarda todas las variables en la memoria del flujo y transfiere el control al despachador.  La pr√≥xima vez que se active la secuencia, las variables se restauran y la ejecuci√≥n contin√∫a, comenzando con la siguiente instrucci√≥n despu√©s de <em>AWAIT</em> .  El comando est√° dise√±ado para dividir la tarea en intervalos de tiempo e implementar la m√°quina de estado de acuerdo con el esquema <em>Se√±al ‚Üí Procesamiento 1 ‚Üí Se√±al ‚Üí Procesamiento 2</em> , etc. </p><br><p>  El comando AWAIT puede tener una se√±al como par√°metro opcional.  Si el par√°metro est√° vac√≠o, se guarda la se√±al de activaci√≥n.  Si se especifica en el par√°metro, todas las llamadas de tareas posteriores se realizar√°n cuando se active la se√±al especificada y se pierda la comunicaci√≥n con la se√±al anterior. </p><br><p>  <strong>TaskContinue (etiqueta, se√±al)</strong> : el comando finaliza la secuencia y le da el control al despachador sin guardar variables.  La pr√≥xima vez que se active la transmisi√≥n, el control se transfiere a la <em>etiqueta</em> .  El par√°metro de <em>se√±al</em> opcional le permite anular la se√±al de activaci√≥n de flujo para la pr√≥xima llamada.  Si no se especifica, la se√±al permanece igual.  Un comando sin especificar una se√±al se puede usar para organizar ciclos dentro de una sola tarea, donde cada ciclo se realiza en un intervalo de tiempo separado.  Tambi√©n se puede usar para asignar una nueva tarea al hilo actual despu√©s de completar el anterior.  La ventaja de este enfoque en comparaci√≥n con el ciclo <em>Liberar un hilo ‚Üí Destacar un flujo</em> es un programa m√°s eficiente.  El uso de <em>TaskContinue</em> elimina la necesidad de que el administrador busque un subproceso libre en el grupo y garantiza errores al intentar asignar subprocesos en ausencia de subprocesos libres. </p><br><p>  <strong>TaskEnd ()</strong> : borra la secuencia una vez que se completa la tarea.  La tarea finaliza, el hilo se libera y se puede utilizar para asignar una nueva tarea con el comando <em>Activar</em> . </p><br><p>  <strong>Retraso (ms)</strong> : el flujo, como en el caso de usar <em>AWAIT</em> , guarda todas las variables en la memoria del flujo y transfiere el control al despachador.  En este caso, el valor de retraso en milisegundos se registra en el encabezado de la secuencia.  En el bucle despachador, en el caso de un valor distinto de cero en el campo de retraso, el flujo no se activa.  El cambio de los valores en el campo de retraso para todos los flujos se realiza interrumpiendo el temporizador WDT cada 16 ms.  Cuando se alcanza el valor cero, se elimina la prohibici√≥n de ejecuci√≥n y se establece la se√±al de activaci√≥n del flujo.  Solo se almacena un valor de un solo byte para el retraso en el encabezado, lo que proporciona un rango relativamente estrecho de posibles retrasos, por lo tanto, para implementar retrasos m√°s largos, <em>Delay ()</em> crea un bucle interno utilizando variables de flujo local. <br>  La activaci√≥n de los comandos en el ejemplo se realiza utilizando los comandos <em>ContinuousActivate</em> y <em>ActivateNext</em> .  Este es un tipo especial de activaci√≥n de tarea inicial al inicio.  En la etapa de activaci√≥n inicial, tenemos la garant√≠a de no tener un solo subproceso ocupado, por lo que el proceso de activaci√≥n no requiere una b√∫squeda preliminar de un subproceso libre para una tarea y le permite activar tareas en secuencia.  <em>ContinuousActivate</em> activa la tarea en el subproceso cero y devuelve un puntero al encabezado del siguiente subproceso, y la funci√≥n <em>ActivateNext</em> usa este puntero para activar las siguientes tareas en subprocesos secuenciales. </p><br><p>  Como se√±al de activaci√≥n, el ejemplo usa la se√±al <em>AlwaysOn</em> .  Esta es una de las se√±ales del sistema.  Su prop√≥sito significa que la tarea siempre se ejecutar√°, ya que esta es la √∫nica se√±al que siempre se activa y no se restablece con el uso. </p><br><p>  El ejemplo termina con una llamada de <em>bucle</em> .  Esta funci√≥n inicia el ciclo del despachador, por lo que este comando deber√≠a ser el √∫ltimo en el c√≥digo. </p><br><p>  Considere otro ejemplo donde el uso de la biblioteca puede simplificar significativamente la estructura del c√≥digo.  Sea un dispositivo de control condicional que registre una se√±al anal√≥gica y la env√≠e en forma de c√≥digo HEX al terminal. </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); m.FCLK = <span class="hljs-number"><span class="hljs-number">16000000</span></span>; m.CKDIV8 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cData = m.DREG(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> outDigit = m.ARRAY(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> chex = Const.String(<span class="hljs-string"><span class="hljs-string">"0123456789ABCDEF"</span></span>); m.ADC.Clock = eADCPrescaler.S64; m.ADC.ADCReserved = <span class="hljs-number"><span class="hljs-number">0x01</span></span>; m.ADC.Source = eASource.ADC0; m.Usart.Baudrate = <span class="hljs-number"><span class="hljs-number">9600</span></span>; m.Usart.FrameFormat = eUartFrame.U8N1; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> os = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Parallel(m, <span class="hljs-number"><span class="hljs-number">4</span></span>); os.Heap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticHeap(os, <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ADS = os.AddSignal(m.ADC.Handler, () =&gt; m.ADC.Data(cData)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> trm = os.AddSignal(m.Usart.TXC_Handler); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> starts = os.AddLocker(); os.PrepareSignals(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t0 = os.CreateTask((tsk) =&gt; { m.LOOP(m.TempL, (r, l) =&gt; m.GO(l), (r, l) =&gt; { m.ADC.ConvertAsync(); tsk.Delay(<span class="hljs-number"><span class="hljs-number">500</span></span>); }); }, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = os.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mref = m.ROMPTR(); mref.Load(chex); m.TempL.Load(cData.High); m.TempL &gt;&gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>; mref += m.TempL; mref.MLoad(m.TempL); m.TempL.MStore(outDigit[<span class="hljs-number"><span class="hljs-number">0</span></span>]); mref.Load(chex); m.TempL.Load(cData.High); m.TempL &amp;= <span class="hljs-number"><span class="hljs-number">0x0F</span></span>; mref += m.TempL; mref.MLoad(m.TempL); m.TempL.MStore(outDigit[<span class="hljs-number"><span class="hljs-number">1</span></span>]); mref.Load(chex); m.TempL.Load(cData.Low); m.TempL &gt;&gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>; mref += m.TempL; mref.MLoad(m.TempL); m.TempL.MStore(outDigit[<span class="hljs-number"><span class="hljs-number">2</span></span>]); mref.Load(chex); m.TempL.Load(cData.Low); m.TempL &amp;= <span class="hljs-number"><span class="hljs-number">0x0F</span></span>; mref += m.TempL; mref.MLoad(m.TempL); m.TempL.MStore(outDigit[<span class="hljs-number"><span class="hljs-number">3</span></span>]); starts.Set(); tsk.TaskContinue(loop); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = os.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); trm.Clear(); m.TempL.Load(<span class="hljs-string"><span class="hljs-string">'0'</span></span>); m.Usart.Transmit(m.TempL); tsk.AWAIT(trm); m.TempL.Load(<span class="hljs-string"><span class="hljs-string">'x'</span></span>); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.MLoad(outDigit[<span class="hljs-number"><span class="hljs-number">0</span></span>]); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.MLoad(outDigit[<span class="hljs-number"><span class="hljs-number">1</span></span>]); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.MLoad(outDigit[<span class="hljs-number"><span class="hljs-number">2</span></span>]); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.MLoad(outDigit[<span class="hljs-number"><span class="hljs-number">3</span></span>]); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.Load(<span class="hljs-number"><span class="hljs-number">13</span></span>); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.Load(<span class="hljs-number"><span class="hljs-number">10</span></span>); m.Usart.Transmit(m.TempL); tsk.TaskContinue(loop, starts); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = os.ContinuousActivate(os.AlwaysOn, t0); os.ActivateNext(p, ADS, t1); os.ActivateNext(p, starts, t2); m.ADC.Activate(); m.Usart.Activate(); m.EnableInterrupt(); os.Loop();</code> </pre> <br><p>  Esto no quiere decir que vimos muchas cosas nuevas aqu√≠, pero puedes ver algo interesante en este c√≥digo. </p><br><p>  En este ejemplo, ADC (convertidor anal√≥gico a digital) se menciona por primera vez.  Este dispositivo perif√©rico est√° dise√±ado para convertir el voltaje de la se√±al de entrada en un c√≥digo digital.  La funci√≥n <em>ConvertAsync</em> inicia el ciclo de conversi√≥n, que solo inicia el proceso sin esperar el resultado.  Cuando se completa la conversi√≥n, el ADC genera una interrupci√≥n que activa la se√±al <em>adcSig</em> .  Preste atenci√≥n a la definici√≥n de la se√±al <em>adcSig</em> .  Adem√°s del puntero de interrupci√≥n, tambi√©n contiene un bloque de c√≥digo para almacenar valores del registro de datos ADC.  Todo el c√≥digo que se ejecute preferiblemente inmediatamente despu√©s de que ocurra una interrupci√≥n (por ejemplo, leer datos de registros de dispositivos) debe ubicarse en este lugar. <br>  La tarea de <em>conversi√≥n</em> es convertir un c√≥digo de voltaje binario en una representaci√≥n HEX de cuatro caracteres para nuestro terminal condicional.  Aqu√≠ podemos observar el uso de funciones para describir fragmentos repetidos para reducir el tama√±o del c√≥digo fuente y el uso de una cadena constante para la conversi√≥n de datos. </p><br><p>  El problema de <em>transmisi√≥n</em> es interesante desde el punto de vista de implementar la salida formateada de una cadena en la que se combina la salida de datos est√°ticos y din√°micos.  El mecanismo en s√≠ no puede considerarse ideal; m√°s bien, es una demostraci√≥n de las posibilidades para administrar manejadores.  Aqu√≠ tambi√©n puede prestar atenci√≥n a la redefinici√≥n de la se√±al de activaci√≥n durante la ejecuci√≥n, que cambia la se√±al de activaci√≥n de <em>ConvS</em> a <em>TxS</em> y viceversa. </p><br><p>  Para una mejor comprensi√≥n, describimos en palabras el algoritmo del programa. </p><br><p>  En el estado inicial, hemos lanzado tres tareas.  Dos de ellos tienen se√±ales inactivas, ya que la se√±al para la tarea de <em>conversi√≥n (adcSig) se</em> activa al final del ciclo de lectura de la se√±al anal√≥gica, y <em>ConvS</em> para la tarea de <em>transmisi√≥n</em> se activa mediante un c√≥digo que a√∫n no se ha ejecutado.  Como resultado, la primera tarea que se lanzar√° despu√©s del lanzamiento siempre ser√° la medici√≥n.  El c√≥digo para esta tarea inicia el ciclo de conversi√≥n de ADC, despu√©s del cual la tarea de 500 ms pasa al ciclo de espera.  Al final del ciclo de conversi√≥n, se <em>activa el</em> indicador <em>adcSig</em> , que desencadena la tarea de <em>conversi√≥n</em> .  En esta tarea, se implementa un ciclo de conversi√≥n de los datos recibidos en una cadena.  Antes de salir de la tarea, activamos el indicador <em>ConvS</em> , dejando en claro que tenemos nuevos datos para enviar al terminal.  El comando de salida restablece el punto de retorno al comienzo de la tarea y le da control al despachador.  El <em>conjunto de</em> banderas <em>ConvS</em> permite transferir el control a la tarea de <em>transmisi√≥n</em> .  Despu√©s de transmitir el primer byte de la secuencia, la se√±al de activaci√≥n en la tarea cambia a <em>TxS</em> .  Como resultado de esto, una vez completada la transferencia del byte, se volver√° a llamar a la tarea de transmisi√≥n, lo que conducir√° a la transferencia del siguiente byte.  Despu√©s de que se transmite el √∫ltimo byte de la secuencia, la tarea devuelve la <em>se√±al de</em> activaci√≥n de <em>ConvS</em> y restablece el punto de retorno al comienzo de la tarea.  El ciclo se completa.  El siguiente ciclo comenzar√° cuando la tarea de medici√≥n complete la espera y active el siguiente ciclo de medici√≥n. </p><br><p>  En casi todos los sistemas multitarea, existe el concepto de colas para la interacci√≥n entre hilos.  Ya hemos descubierto que dado que cambiar entre tareas en este sistema es un proceso completamente controlado, es muy posible usar variables globales para intercambiar datos entre tareas.  Sin embargo, hay una serie de tareas en las que se justifica el uso de colas.  Por lo tanto, no dejaremos de lado este tema y veremos c√≥mo se implementa en la biblioteca. </p><br><p>  Para implementar una cola en un programa, es mejor usar la clase <em>RingBuff</em> .  La clase, como su nombre lo indica, implementa un buffer de anillo con comandos de escritura y recuperaci√≥n.  La lectura y escritura de datos se realiza mediante los comandos de <em>lectura</em> y <em>escritura</em> .  Los comandos de lectura y escritura no tienen par√°metros.  El b√∫fer utiliza la variable de registro especificada en el constructor como fuente / receptor de datos.  El acceso a esta variable se realiza a trav√©s del par√°metro <em>IOReg</em> class.  El estado del b√∫fer est√° determinado por los dos indicadores <em>Ovf</em> y <em>Empty</em> , que ayudan a determinar el estado de desbordamiento durante la escritura y el desbordamiento durante la lectura.  Adem√°s, la clase tiene la capacidad de determinar el c√≥digo que se ejecuta en eventos de desbordamiento / desbordamiento.  <em>RingBuff</em> no tiene dependencias en la clase <em>Paralelo</em> y se puede usar por separado.  La limitaci√≥n cuando se trabaja con la clase es la capacidad permitida, que deber√≠a ser un m√∫ltiplo de la potencia de dos (8.16.32, etc.) por razones de optimizaci√≥n del c√≥digo. </p><br><p>  A continuaci√≥n se muestra un ejemplo de trabajo con la clase. </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> io = m.REG(); <span class="hljs-comment"><span class="hljs-comment">//     16     io. var bf = new RingBuff(m, 16, io) { //    OnOverflow = () =&gt; { AVRASM.Comment("   "); }, OnEmpty = () =&gt; { AVRASM.Comment("   "); } }; var cntr = m.REG(); cntr.Load(16); //       m.LOOP(cntr, (r, l) =&gt; { cntr--; m.IFNOTEMPTY(l); },(r)=&gt; { //         //m.IF(bf.Ovf,()=&gt;{AVRASM.Comment("‚Äù)}; bf.IOReg.Load(cntr); //      bf.Write(); //    }); //     m.LOOP(cntr, (r, l) =&gt; { m.GO(l); }, (r) =&gt; { //         //m.IF(bf.Ovf,()=&gt;{AVRASM.Comment(" ‚Äù)}; bf.Read(); //       IOReg //    });</span></span></code> </pre> <br><p>  Esta parte concluye la descripci√≥n general de las caracter√≠sticas de la biblioteca.  Desafortunadamente, quedaban varios aspectos relacionados con las capacidades de la biblioteca, que ni siquiera se mencionaron.  En el futuro, en caso de inter√©s en el proyecto, se planean art√≠culos dedicados a resolver problemas espec√≠ficos utilizando la biblioteca y una descripci√≥n m√°s detallada de problemas complejos que requieren una publicaci√≥n por separado. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/464651/">https://habr.com/ru/post/464651/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../464641/index.html">C√≥mo configurar PVS-Studio en Travis CI usando el ejemplo del emulador de consola de juegos PSP</a></li>
<li><a href="../464643/index.html">No es un solo escaneo, o c√≥mo construir un proceso de gesti√≥n de vulnerabilidades en 9 pasos</a></li>
<li><a href="../464645/index.html">C√≥mo configurar PVS-Studio en Travis CI usando el emulador de consola de juegos PSP como ejemplo</a></li>
<li><a href="../464647/index.html">Peri√≥dico Harry Potter</a></li>
<li><a href="../464649/index.html">Sistema de colaboraci√≥n de documentos para Zimbra Open-Source Edition</a></li>
<li><a href="../464655/index.html">C√≥mo los salarios y la popularidad de los lenguajes de programaci√≥n han cambiado en los √∫ltimos 2 a√±os</a></li>
<li><a href="../464657/index.html">Ingenier√≠a inversa cornisa el√©ctrica AM82TV</a></li>
<li><a href="../464659/index.html">Seguridad de aplicaciones o C√≥mo incrustar seguridad en el desarrollo personalizado. Experiencia personal en AGIMA</a></li>
<li><a href="../464661/index.html">A qui√©n confiar el dise√±o de las instalaciones t√©cnicas de reequipamiento y reconstrucci√≥n</a></li>
<li><a href="../464665/index.html">Particionamiento en SQL Server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>