<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ê üöß üö¶ Schonende Fehlerbehandlung in Microservices üîΩ ü§ò ü§™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Artikel zeigt, wie die Fehlerbehandlung und -protokollierung auf der Grundlage des "Made and Forgot" -Prinzips in Go implementiert wird. Die Metho...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schonende Fehlerbehandlung in Microservices</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459130/"><p>  Der Artikel zeigt, wie die Fehlerbehandlung und -protokollierung auf der Grundlage des "Made and Forgot" -Prinzips in Go implementiert wird.  Die Methode wurde f√ºr Microservices on Go entwickelt, die in einem Docker-Container arbeiten und den Prinzipien der Clean Architecture entsprechen. </p><a name="habracut"></a><br><p>  Dieser Artikel ist eine detaillierte Version eines Berichts vom letzten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Go-Treffen in Kasan</a> .  Wenn Sie sich f√ºr Go interessieren und in Kasan, Innopolis, im sch√∂nen Yoshkar-Ola oder in einer anderen Stadt in der N√§he wohnen, sollten Sie die Community-Seite besuchen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">golangkazan.github.io</a> . </p><br><p>  W√§hrend des Treffens zeigte unser Team in zwei Berichten, wie wir Microservices on Go entwickeln - welchen Prinzipien wir folgen und wie wir unser Leben vereinfachen.  Dieser Artikel konzentriert sich auf unser Konzept der Fehlerbehandlung, das wir jetzt auf alle unsere neuen Mikrodienste ausweiten. </p><br><h2 id="soglasheniya-o-strukture-mikroservisa">  Microservice-Strukturvereinbarungen </h2><br><p>  Bevor wir auf die Regeln f√ºr die Fehlerbehandlung eingehen, sollten Sie entscheiden, welche Einschr√§nkungen wir beim Entwerfen und Codieren beachten.  Dazu lohnt es sich zu sagen, wie unsere Microservices aussehen. </p><br><p>  Zuallererst respektieren wir saubere Architektur.  Wir teilen den Code in drei Ebenen ein und beachten die Abh√§ngigkeitsregel: Pakete auf einer tieferen Ebene sind unabh√§ngig von externen Paketen und es gibt keine zyklischen Abh√§ngigkeiten.  Gl√ºcklicherweise sind direkte Round-Robin-Abh√§ngigkeiten von Paketen in Go verboten.  Indirekte Abh√§ngigkeiten durch Ausleihterminologie, Annahmen √ºber das Verhalten oder das Umwandeln in einen Typ k√∂nnen weiterhin auftreten. Sie sollten vermieden werden. </p><br><p>  So sehen unsere Levels aus: </p><br><ol><li>  Die Dom√§nenebene enth√§lt Gesch√§ftslogikregeln, die vom Themenbereich vorgegeben werden. <br><ul><li>  Manchmal verzichten wir auf Domain, wenn die Aufgabe einfach ist </li><li>  <em>Regel:</em> Code auf Dom√§nenebene h√§ngt nur von den Funktionen von Go, der Standard-Go-Bibliothek und ausgew√§hlten Bibliotheken ab, die die Go-Sprache erweitern </li></ul></li><li>  Die App-Schicht enth√§lt Gesch√§ftslogikregeln, die von den Aufgaben der Anwendung vorgegeben werden. <br><ul><li>  <em>Regel:</em> Code auf App-Ebene kann von der Domain abh√§ngen </li></ul></li><li>  Die Infrastrukturebene enth√§lt Infrastrukturcode, der die Anwendung mit verschiedenen Technologien f√ºr Speicher (MySQL, Redis), Transport (GRPC, HTTP), Interaktion mit der externen Umgebung und anderen Diensten verbindet <br><ul><li>  <em>Regel:</em> Code auf Infrastrukturebene kann von Dom√§ne und App abh√§ngen </li><li>  <em>Regel:</em> Nur eine Technologie pro Go-Paket </li></ul></li><li>  Das Hauptpaket erstellt alle Objekte - "Lifetime Singleton", verbindet sie miteinander und startet langlebige Coroutinen - beispielsweise beginnt es mit der Verarbeitung von HTTP-Anforderungen von Port 8081 </li></ol><br><p>  So sieht der Microservice-Verzeichnisbaum aus (der Teil, in dem sich der Go-Code befindet): </p><br><p><img src="https://habrastorage.org/webt/dk/ft/id/dkftidhxmqh30yy9zbdaeajfbgy.png" alt="Bild: Gehen Sie zum Projektbaum"></p><br><p>  F√ºr jeden Anwendungskontext (Module) sieht die Paketstruktur folgenderma√üen aus: </p><br><ul><li> Das App-Paket deklariert eine Service-Schnittstelle, die alle auf einer bestimmten Ebene m√∂glichen Aktionen enth√§lt, die die Service-Struktur-Schnittstelle und die Funktionsfunktion <code>func NewService(...) Service</code> implementieren </li><li>  Die Isolierung der Arbeit mit der Datenbank wird dadurch erreicht, dass das Dom√§nen- oder App-Paket die Repository-Schnittstelle deklariert, die auf Infrastrukturebene im Paket mit dem visuellen Namen "mysql" implementiert ist. </li><li>  Der Transportcode befindet sich im <code>infrastructure/transport</code> <br><ul><li>  Wir verwenden GRPC, daher werden Server-Stubs aus der Protodatei generiert (d. h. Serverschnittstelle, Antwort- / Anforderungsstrukturen und der gesamte Client-Interaktionscode). </li></ul></li></ul><br><p>  All dies ist im Diagramm dargestellt: </p><br><p><img src="https://habrastorage.org/webt/-p/gm/hi/-pgmhid0ohkvijl2zmghnlokz7y.png" alt="Bild: Gehen Sie zum Projektpaketdiagramm"></p><br><h2 id="principy-obrabotki-oshibok">  Prinzipien zur Fehlerbehandlung </h2><br><p>  Hier ist alles einfach: </p><br><ol><li>  Wir glauben, dass Fehler und Panik auftreten, wenn Anforderungen an die API verarbeitet werden. Dies bedeutet, dass ein Fehler oder eine Panik nur eine Anforderung betreffen sollte </li><li>  Wir glauben, dass Protokolle nur f√ºr die Vorfallanalyse ben√∂tigt werden (und es gibt einen Debugger zum Debuggen). Daher werden Informationen zu Anforderungen im Protokoll empfangen und vor allem unerwartete Fehler bei der Verarbeitung von Anforderungen </li><li>  Wir glauben, dass eine ganze Infrastruktur f√ºr die Verarbeitung von Protokollen aufgebaut ist (zum Beispiel basierend auf ELK) - und der Microservice spielt dabei eine passive Rolle, indem er Protokolle an stderr schreibt </li></ol><br><p>  Wir werden uns nicht auf Panik konzentrieren: Vergessen Sie nur nicht, die Panik in jeder Goroutine und w√§hrend der Verarbeitung jeder Anfrage, jeder Nachricht, jeder asynchronen Aufgabe, die von der Anfrage gestartet wird, zu behandeln.  Fast immer kann Panik in einen Fehler umgewandelt werden, um zu verhindern, dass die gesamte Anwendung abgeschlossen wird. </p><br><h2 id="idioma-sentinel-errors">  Idiom Sentinel-Fehler </h2><br><p>  Auf der Ebene der Gesch√§ftslogik werden nur erwartete Fehler verarbeitet, die durch Gesch√§ftsregeln definiert sind.  Sentinel-Fehler helfen Ihnen dabei, solche Fehler zu identifizieren. Wir verwenden diese Redewendung, anstatt unsere eigenen Datentypen f√ºr Fehler zu schreiben.  Ein Beispiel: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> app <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"errors"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrNoCake = errors.New(<span class="hljs-string"><span class="hljs-string">"no cake found"</span></span>)</code> </pre> <br><p>  Hier wird eine globale Variable deklariert, die wir nach Zustimmung unseres Herrn nirgendwo √§ndern sollten.  Wenn Sie globale Variablen nicht m√∂gen und sie mit dem Linter erkennen, k√∂nnen Sie mit einigen Konstanten auskommen, wie Dave Cheney im Beitrag <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Konstantenfehler</a> vorschl√§gt: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> app <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Error <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e Error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(e) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ErrNoCake = Error(<span class="hljs-string"><span class="hljs-string">"no cake found"</span></span>)</code> </pre> <br><blockquote>  Wenn Ihnen dieser Ansatz gef√§llt, m√∂chten Sie m√∂glicherweise den <code>ConstError</code> Typ zu Ihrer Go-Sprachbibliothek f√ºr Unternehmen hinzuf√ºgen. </blockquote><br><h2 id="kompoziciya-oshibok">  Zusammensetzung der Fehler </h2><br><p>  Der Hauptvorteil von Sentinel-Fehlern ist die M√∂glichkeit, Fehler einfach zu komponieren.  Insbesondere wenn ein Fehler erstellt oder ein Fehler von au√üen empfangen wird, ist es hilfreich, Stacktrace hinzuzuf√ºgen.  F√ºr solche Zwecke gibt es zwei beliebte L√∂sungen. </p><br><ul><li>  xerrors-Paket, das in Go 1.13 als Experiment in die Standardbibliothek aufgenommen wird </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/pkg/errors</a> Paket von Dave Cheney <br><ul><li>  Das Paket ist eingefroren und dehnt sich nicht aus, aber es ist trotzdem gut </li></ul></li></ul><br><p>  Unser Team verwendet weiterhin <code>github.com/pkg/errors</code> und die <code>errors.WithStack</code> Funktionen (wenn wir nichts hinzuf√ºgen m√ºssen, au√üer Stacktrace) oder <code>errors.Wrap</code> (wenn wir etwas zu diesem Fehler zu sagen haben).  Beide Funktionen akzeptieren einen Fehler am Eingang und geben einen neuen Fehler zur√ºck, jedoch mit Stacktrace.  Beispiel aus der Infrastrukturschicht: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> mysql <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/pkg/errors"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *repository)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindOne</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> { row := r.client.QueryRow(sql, params...) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> err := row.Scan(...) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> sql.ErrNoRows: <span class="hljs-comment"><span class="hljs-comment">//     stacktrace return nil, errors.WithStack(app.ErrNoCake) } }</span></span></code> </pre> <br><p>  Wir empfehlen, jeden Fehler nur einmal zu verpacken.  Dies ist einfach, wenn Sie die Regeln befolgen: </p><br><ul><li>  Alle externen Fehler werden einmal in eines der Infrastrukturpakete eingeschlossen </li><li>  Alle durch Gesch√§ftslogikregeln generierten Fehler werden zum Zeitpunkt der Erstellung durch Stacktrace erg√§nzt </li></ul><br><h2 id="pervoprichina-oshibki">  Grundursache des Fehlers </h2><br><p>  Alle Fehler werden erwartungsgem√§√ü in erwartete und unerwartete unterteilt.  Um den erwarteten Fehler zu behandeln, m√ºssen Sie die Auswirkungen der Komposition beseitigen.  Die Pakete xerrors und <code>github.com/pkg/errors</code> alles, was Sie ben√∂tigen: Insbesondere das <code>errors.Cause</code> Funktion <code>errors.Cause</code> , die die Grundursache des Fehlers zur√ºckgibt.  Diese Funktion in einer Schleife ruft nacheinander fr√ºhere Fehler ab, w√§hrend der n√§chste extrahierte Fehler die Fehlermethode <code>Cause() error</code> . </p><br><p>  Ein Beispiel, mit dem wir die Grundursache extrahieren und direkt mit dem Sentinel-Fehler vergleichen: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveCake</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { state, err := s.repo.FindOne(...) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Cause(err) == ErrNoCake { err = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-comment"><span class="hljs-comment">// No cake is OK, create a new one // ... } else if err != nil { // ... } }</span></span></code> </pre> <br><h2 id="obrabotka-oshibok-v-defer">  Fehlerbehandlung beim Aufschieben </h2><br><p>  M√∂glicherweise verwenden Sie Linter, wodurch Sie alle Fehler manuell √ºberpr√ºfen k√∂nnen.  In diesem Fall sind Sie wahrscheinlich w√ºtend, wenn linter Sie <code>.Close()</code> , mit den <code>.Close()</code> -Methoden und anderen Methoden, die Sie nur <code>defer</code> <code>.Close()</code> , nach Fehlern zu <code>.Close()</code> .  Haben Sie jemals versucht, den Fehler beim Aufschieben korrekt zu behandeln, insbesondere wenn zuvor ein anderer Fehler aufgetreten ist?  Und wir haben versucht und haben es eilig, das Rezept zu teilen. </p><br><p>  Stellen Sie sich vor, wir arbeiten ausschlie√ülich mit Transaktionen in der Datenbank.  Gem√§√ü der Abh√§ngigkeitsregel sollten die App- und Dom√§nenebenen nicht direkt oder indirekt von der Infrastruktur und der SQL-Technologie abh√§ngig sein.  Dies bedeutet, dass <strong>auf App- und Domain-Ebene kein Wort "Transaktion" vorhanden ist</strong> . </p><br><p>  Die einfachste L√∂sung besteht darin, das Wort "Transaktion" durch etwas Abstraktes zu ersetzen.  So wird das Muster der Arbeitseinheit geboren.  In unserer Implementierung empf√§ngt der Service im App-Paket die Factory √ºber die UnitOfWorkFactory-Schnittstelle und erstellt w√§hrend jeder Operation ein UnitOfWork-Objekt, das die Transaktion verbirgt.  Mit dem UnitOfWork-Objekt k√∂nnen Sie ein Repository abrufen. </p><br><div class="spoiler">  <b class="spoiler_title">Mehr zu UnitOfWork</b> <div class="spoiler_text"><p>  Schauen Sie sich das Diagramm an, um die Verwendung von Arbeitseinheiten besser zu verstehen: </p><br><p><img src="https://habrastorage.org/webt/08/hi/iy/08hiiyavd51o3_aof9ys_s9noue.png" alt="Bild Go Arbeitseinheit"></p><br><ul><li>  Das Repository stellt eine abstrakte persistente Sammlung von Objekten (z. B. Aggregate auf Dom√§nenebene) eines definierten Typs dar </li><li>  UnitOfWork versteckt die Transaktion und erstellt Repository-Objekte </li><li>  Mit UnitOfWorkFactory kann der Service einfach neue Transaktionen erstellen, ohne etwas √ºber Transaktionen zu wissen. </li></ul><br><p>  Ist es nicht √ºbertrieben, f√ºr jede Operation eine Transaktion zu erstellen, auch wenn diese zun√§chst atomar ist?  Es liegt an dir;  Wir glauben, dass die Wahrung der Unabh√§ngigkeit der Gesch√§ftslogik wichtiger ist als das Sparen beim Erstellen einer Transaktion. </p><br><p>  Ist es m√∂glich, UnitOfWork und Repository zu kombinieren?  Es ist m√∂glich, aber wir glauben, dass dies gegen das Prinzip der Einzelverantwortung verst√∂√üt. </p></div></div><br><p>  So sieht die Benutzeroberfl√§che aus: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> UnitOfWork <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Repository() Repository Complete(err *error) }</code> </pre> <br><p>  Die UnitOfWork-Schnittstelle bietet die Complete-Methode, die einen In-Out-Parameter verwendet: einen Zeiger auf die Fehlerschnittstelle.  Ja, es ist der Zeiger und der In-Out-Parameter. In allen anderen F√§llen ist der Code auf der aufrufenden Seite viel komplizierter. </p><br><p>  Beispieloperation mit unitOfWork: </p><br><blockquote>  Achtung: Der Fehler <strong>muss</strong> als benannter R√ºckgabewert deklariert werden.  Wenn Sie anstelle des genannten R√ºckgabewerts err die lokale Variable err verwenden, k√∂nnen Sie sie nicht in defer verwenden!  Und noch kein einziger Linter wird dies erkennen - siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Go-Kritiker # 801</a> </blockquote><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CookCake</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span></span> { unitOfWork, err := s.unitOfWorkFactory.New() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> unitOfWork.Complete(&amp;err) repo := unitOfWork.Repository() } <span class="hljs-comment"><span class="hljs-comment">// ...  </span></span></code> </pre> <br><p>  Damit ist die Fertigstellung realisiert <del>  Transaktionen </del>  UnitOfWork: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u *unitOfWork)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Complete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err *error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     -  commit txErr := u.tx.Commit() *err = errors.Wrap(txErr, "cannot complete transaction") } else { //    -  rollback txErr := return u.tx.Rollback() //  rollback   ,    *err = mergeErrors(*err, errors.Wrap(txErr, "cannot rollback transaction")) } }</span></span></code> </pre> <br><p>  Die Funktion <code>mergeErrors</code> zwei Fehler zusammen, verarbeitet jedoch null ohne Probleme anstelle eines oder beider Fehler.  Gleichzeitig glauben wir, dass beide Fehler w√§hrend der Ausf√ºhrung einer Operation in verschiedenen Phasen aufgetreten sind und der erste Fehler wichtiger ist. Wenn also beide Fehler nicht Null sind, speichern wir den ersten und vom zweiten Fehler nur die Nachricht: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> errors <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mergeErrors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error, nextErr error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { err = nextErr } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> nextErr != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { err = errors.Wrap(err, nextErr.Error()) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br><blockquote>  Vielleicht sollten Sie die Funktion <code>mergeErrors</code> zu Ihrer Unternehmensbibliothek f√ºr Go hinzuf√ºgen. </blockquote><br><h2 id="podsistema-logirovaniya">  Protokollierungssubsystem </h2><br><p>  Artikel- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Checkliste: Was Sie tun mussten, bevor Sie Microservices in Prod</a> Advices <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">starten</a> : </p><br><ul><li>  Protokolle werden in stderr geschrieben </li><li>  Protokolle sollten sich in JSON befinden, einem kompakten JSON-Objekt pro Zeile </li><li>  Es sollte einen Standardsatz von Feldern geben: <br><ul><li>  Zeitstempel - Ereigniszeit in <strong>Millisekunden</strong> , vorzugsweise im RFC 3339-Format (Beispiel: "1985-04-12T23: 20: 50.52Z") </li><li>  level - Wichtigkeitsstufe, zum Beispiel "info" oder "error" </li><li>  Anwendungsname - Anwendungsname </li><li>  und andere Felder </li></ul></li></ul><br><p>  Wir ziehen es vor, den Fehlermeldungen zwei weitere Felder hinzuzuf√ºgen: <code>"error"</code> und <code>"stacktrace"</code> . </p><br><p>  Es gibt viele hochwertige Protokollierungsbibliotheken f√ºr die Golang-Sprache, zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sirupsen / Logrus</a> , die wir verwenden.  Wir nutzen die Bibliothek aber nicht direkt.  Zun√§chst reduzieren wir in unserem <code>log</code> die √ºberm√§√üig umfangreiche Bibliotheksschnittstelle auf eine Logger-Schnittstelle: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> log <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Logger <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { WithField(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Logger WithFields(Fields) Logger Debug(...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Info(...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Error(error, ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) }</code> </pre> <br><p>  Wenn der Programmierer Protokolle schreiben m√∂chte, muss er die Logger-Schnittstelle von au√üen beziehen. Dies sollte auf Infrastrukturebene erfolgen, nicht auf der Ebene der App oder Dom√§ne.  Die Logger-Oberfl√§che ist √ºbersichtlich: </p><br><ul><li>  Es reduziert die Anzahl der Schweregrade f√ºr Debugging, Informationen und Fehler, wie im Artikel empfohlen. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lassen Sie uns √ºber die Protokollierung sprechen.</a> </li><li>  Es werden spezielle Regeln f√ºr die Fehlermethode eingef√ºhrt: Die Methode akzeptiert immer ein Fehlerobjekt </li></ul><br><p>  Diese Strenge erm√∂glicht es, Programmierer in die richtige Richtung zu lenken: Wenn jemand das Protokollierungssystem selbst verbessern m√∂chte, sollte er dies unter Ber√ºcksichtigung der gesamten Infrastruktur seiner Erfassung und Verarbeitung tun, die nur im Mikrodienst beginnt (und normalerweise irgendwo in Kibana und endet Zabbix). </p><br><p>  Im Protokollpaket gibt es jedoch eine andere Schnittstelle, √ºber die Sie das Programm unterbrechen k√∂nnen, wenn ein schwerwiegender Fehler auftritt, und die daher nur im Hauptpaket verwendet werden kann: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> log <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MainLogger <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Logger FatalError(error, ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) }</code> </pre> <br><h2 id="paket-jsonlog">  Jsonlog-Paket </h2><br><p>  Implementiert die Logger-Schnittstelle unseres <code>jsonlog</code> Pakets, das die Logrus-Bibliothek konfiguriert und die Arbeit damit abstrahiert.  Sieht schematisch so aus: </p><br><p><img src="https://habrastorage.org/webt/g4/we/6m/g4we6m81oxxtd1nlvwklblru6eq.png" alt="Image Logger-Paketdiagramm"></p><br><p>  Mit einem propriet√§ren Paket k√∂nnen Sie die Anforderungen eines Mikrodienstes (ausgedr√ºckt durch die <code>log.Logger</code> Schnittstelle), die Funktionen der logrus-Bibliothek und die Funktionen Ihrer Infrastruktur, die Protokollierung, verbinden. </p><br><p>  Zum Beispiel verwenden wir ELK (Elastic Search, Logstash, Kibana) und daher im jsonlog-Paket: </p><br><ul><li>  Legen Sie das Format <code>logrus.JSONFormatter</code> f√ºr <code>logrus.JSONFormatter</code> <br><ul><li>  Gleichzeitig setzen wir die FieldMap-Option, mit der wir das Feld <code>"time"</code> in <code>"@timestamp"</code> und das Feld <code>"msg"</code> in <code>"message"</code> <code>"@timestamp"</code> </li></ul></li><li>  Protokollstufe ausw√§hlen </li><li>  F√ºgen Sie einen Hook hinzu, der die Stapelverfolgung aus dem Fehlerobjekt extrahiert, das an die Methode <code>Error(error, ...interface{})</code> </li></ul><br><p>  Der Microservice initialisiert den Logger in der Hauptfunktion: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initLogger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(log.MainLogger, error)</span></span></span></span> { logLevel, err := jsonlog.ParseLevel(config.LogLevel) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"failed to parse log level"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jsonlog.NewLogger(&amp;jsonlog.Config{ Level: logLevel, AppName: <span class="hljs-string"><span class="hljs-string">"cookingservice"</span></span> }), <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><h2 id="obrabotka-oshibok-i-logirovanie-s-pomoschyu-middleware">  Fehlerbehandlung und Protokollierung mit Middleware </h2><br><p>  Wir wechseln in unseren Microservices on Go zu GRPC.  Aber selbst wenn Sie die HTTP-API verwenden, sind die allgemeinen Prinzipien f√ºr Sie. </p><br><p>  Zuallererst sollte die Fehlerbehandlung und -protokollierung auf <code>infrastructure</code> in dem f√ºr den Transport verantwortlichen Paket erfolgen, da er das Wissen √ºber die Transportprotokollregeln und das Wissen √ºber die Schnittstellenmethoden der <code>app.Service</code> .  Erinnern Sie sich daran, wie die Paketbeziehung aussieht: </p><br><p><img src="https://habrastorage.org/webt/fw/zn/hz/fwznhzsxd35ydgajmotnvprqbum.png" alt="Bild GRPC-Paketdiagramm"></p><br><p>  Es ist praktisch, Fehler zu verarbeiten und Protokolle mithilfe des Middleware-Musters zu verwalten (Middleware ist der Name des Decorator-Musters in der Welt von Golang und Node.js): </p><br><p>  Wo kann man Middleware hinzuf√ºgen?  Wie viele sollte es geben? </p><br><p>  Sie haben verschiedene M√∂glichkeiten, Middleware hinzuzuf√ºgen: </p><br><ul><li>  Sie k√∂nnen die <code>app.Service</code> Schnittstelle dekorieren. <code>app.Service</code> wird jedoch nicht empfohlen, da diese Schnittstelle keine Informationen zur Transportschicht wie die Client-IP empf√§ngt </li><li>  Mit GRPC k√∂nnen Sie einen Handler an alle Anforderungen h√§ngen (genauer gesagt zwei - un√§r und Steam), aber dann werden alle API-Methoden im selben Stil mit demselben Satz von Feldern protokolliert </li><li>  Mit GRPC erstellt der Codegenerator f√ºr uns eine Serverschnittstelle, in der wir die <code>app.Service</code> Methode <code>app.Service</code> Wir dekorieren diese Schnittstelle, da sie Informationen auf Transportebene enth√§lt und verschiedene API-Methoden auf unterschiedliche Weise protokollieren kann </li></ul><br><p>  Sieht schematisch so aus: </p><br><p><img src="https://habrastorage.org/webt/vn/dl/eh/vndlehx5hogpu09hj3zekrzmyie.png" alt="Bild GRPC Middleware-Paketdiagramm"></p><br><p>  Sie k√∂nnen verschiedene Middlewares f√ºr die Fehlerbehandlung (und Panik) und f√ºr die Protokollierung erstellen.  Sie k√∂nnen alles in einem kreuzen.  Wir werden ein Beispiel betrachten, in dem alles in eine Middleware gekreuzt wird, die wie folgt erstellt wird: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewMiddleware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(next api.BackendService, logger log.Logger)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">api</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BackendService</span></span></span></span> { server := &amp;errorHandlingMiddleware{ next: next, logger: logger, } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> server }</code> </pre> <br><p>  Wir erhalten die <code>api.BackendService</code> Schnittstelle als <code>api.BackendService</code> und dekorieren sie, wobei wir unsere Implementierung der <code>api.BackendService</code> Schnittstelle als <code>api.BackendService</code> . </p><br><p>  Eine beliebige API-Methode in Middleware wird wie folgt implementiert: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *errorHandlingMiddleware)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ctx context.Context, req *api.ListCakesRequest)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*api.ListCakesResponse, error)</span></span></span></span> { start := time.Now() res, err := m.next.ListCakes(ctx, req) m.logCall(start, err, <span class="hljs-string"><span class="hljs-string">"ListCakes"</span></span>, log.Fields{ <span class="hljs-string"><span class="hljs-string">"cookIDs"</span></span>: req.CookIDs, }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res, translateError(err) }</code> </pre> <br><p>  Hier f√ºhren wir drei Aufgaben aus: </p><br><ol><li>  Rufen Sie die ListCakes-Methode des dekorierten Objekts auf </li><li>  Wir <code>logCall</code> Methode auf und √ºbergeben ihr alle wichtigen Informationen, einschlie√ülich eines individuell ausgew√§hlten Satzes von Feldern, die in das Protokoll fallen </li><li>  Am Ende ersetzen wir den Fehler durch den Aufruf von translateError. </li></ol><br><p>  Die Fehler√ºbersetzung wird sp√§ter erl√§utert.  Die <code>logCall</code> erfolgt √ºber die <code>logCall</code> Methode, die einfach die richtige Logger-Schnittstellenmethode aufruft: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *errorHandlingMiddleware)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(start time.Time, err error, method </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, fields log.Fields)</span></span></span></span> { fields[<span class="hljs-string"><span class="hljs-string">"duration"</span></span>] = fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%v"</span></span>, time.Since(start)) fields[<span class="hljs-string"><span class="hljs-string">"method"</span></span>] = method logger := m.logger.WithFields(fields) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { logger.Error(err, <span class="hljs-string"><span class="hljs-string">"call failed"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { logger.Info(<span class="hljs-string"><span class="hljs-string">"call finished"</span></span>) } }</code> </pre> <br><h2 id="translyaciya-oshibok">  Fehler√ºbersetzung </h2><br><p>  Wir m√ºssen die Grundursache des Fehlers ermitteln und ihn in einen Fehler umwandeln, der auf Transportebene verst√§ndlich und in der API Ihres Dienstes dokumentiert ist. </p><br><p>  In GRPC ist es einfach: Verwenden Sie die Funktion <code>status.Errorf</code> , um einen Fehler mit einem Statuscode zu erstellen.  Wenn Sie √ºber eine HTTP-API (REST-API) verf√ºgen, k√∂nnen Sie einen eigenen Fehlertyp erstellen, den die <strong>App- und Dom√§nenebenen nicht kennen sollten.</strong> </p><br><p>  In erster N√§herung sieht die Fehler√ºbersetzung folgenderma√üen aus: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// ! ! -   err  status.Error func translateError(err error) error { switch errors.Cause(err) { case app.ErrNoCake: err = status.Errorf(codes.NotFound, err.Error()) default: err = status.Errorf(codes.Internal, err.Error()) } return err }</span></span></code> </pre> <br><p>  Bei der √úberpr√ºfung von Eingabeargumenten kann die dekorierte Schnittstelle einen Fehler vom Typ <code>status.Status</code> mit einem Statuscode zur√ºckgeben, und die erste Version von translateError verliert diesen Statuscode. </p><br><p>  Lassen Sie uns eine verbesserte Version erstellen, indem wir einen Schnittstellentyp verwenden (es lebe die Ententypisierung!): </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> statusError <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GRPCStatus() *status.Status } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isGrpcStatusError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(er error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { _, ok := err.(statusError) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">translateError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isGrpcStatusError(err) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> errors.Cause(err) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> app.ErrNoCake: err = status.Errorf(codes.NotFound, err.Error()) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: err = status.Errorf(codes.Internal, err.Error()) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br><p>  Die Funktion <code>translateError</code> wird f√ºr jeden Kontext (unabh√§ngiges Modul) in Ihrem Microservice einzeln erstellt und √ºbersetzt Gesch√§ftslogikfehler in Fehler auf Transportebene. </p><br><h2 id="podvedyom-itogi">  Zusammenfassend </h2><br><p>  Wir bieten Ihnen verschiedene Regeln f√ºr den Umgang mit Fehlern und das Arbeiten mit Protokollen.  Ob Sie ihnen folgen oder nicht, liegt bei Ihnen. </p><br><ol><li>  Befolgen Sie die Prinzipien der sauberen Architektur und brechen Sie nicht direkt oder indirekt die Abh√§ngigkeitsregel.  Die Gesch√§ftslogik sollte nur von einer Programmiersprache und nicht von externen Technologien abh√§ngen. </li><li>  Verwenden Sie ein Paket, das Fehlerkomposition und Stacktrace-Erstellung bietet.  Zum Beispiel "github.com/pkg/errors" oder das xerrors-Paket, das bald Teil der Go-Standardbibliothek sein wird. </li><li>  Verwenden Sie keine Protokollierungsbibliotheken von Drittanbietern im Microservice. Erstellen Sie Ihre eigene Bibliothek mit den Paketen log und jsonlog, wodurch die Details der Protokollierungsimplementierung ausgeblendet werden </li><li>  Verwenden Sie das Middleware-Muster, um Fehler zu behandeln und Protokolle √ºber die Transportrichtung der Infrastrukturebene des Programms zu schreiben </li></ol><br><p>  Hier haben wir nichts √ºber Abfrageverfolgungstechnologien (z. B. OpenTracing), Metrik√ºberwachung (z. B. Leistung von Datenbankabfragen) und andere Dinge wie die Protokollierung gesagt.  Sie selbst werden sich darum k√ºmmern, wir glauben an Sie. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459130/">https://habr.com/ru/post/de459130/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459118/index.html">Wie wir das neue Netzwerk auf Huawei im Moskauer B√ºro entworfen und implementiert haben, Teil 2</a></li>
<li><a href="../de459120/index.html">Modulare eingebettete Computer der UNO-1000/2000-Serie</a></li>
<li><a href="../de459122/index.html">Aleksey Savvateev: Jean Tyrols Nobelpreis f√ºr die Analyse unvollkommener M√§rkte (2014) und des kollektiven Ansehens</a></li>
<li><a href="../de459126/index.html">Himbeer-Pi-Robotertank mit Intel Neural Computer Stick 2</a></li>
<li><a href="../de459128/index.html">Japanische Schnittstellen in der realen Welt</a></li>
<li><a href="../de459134/index.html">Erfahrung mit BDD</a></li>
<li><a href="../de459136/index.html">Gef√§lschte blaue Pille</a></li>
<li><a href="../de459138/index.html">Wie der geheime Schl√ºssel von Huawei in die Firmware von Cisco-Routern gelangt ist</a></li>
<li><a href="../de459140/index.html">Implantatinsertion: Wie wird das gemacht?</a></li>
<li><a href="../de459142/index.html">Erstellen eines animierten Liniendiagramms f√ºr den gleitenden Durchschnitt in R. Abrufen von Daten √ºber die NBA-API</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>