<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï¥üèæ ü¶â ü§õ Contoh parsing kode C ++ menggunakan libclang dengan Python ‚¨áÔ∏è üöì üôçüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada satu proyek C ++ pribadi, saya perlu mendapatkan informasi tentang jenis objek saat runtime. C ++ memiliki mekanisme Run-Time Type Information (R...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Contoh parsing kode C ++ menggunakan libclang dengan Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439270/"><p>  Pada satu proyek C ++ pribadi, saya perlu mendapatkan informasi tentang jenis objek saat runtime.  C ++ memiliki mekanisme Run-Time Type Information (RTTI) bawaan, dan tentu saja pikiran pertama adalah untuk menggunakannya, tetapi saya memutuskan untuk menulis implementasi saya karena saya tidak ingin menarik seluruh mekanisme built-in, karena saya hanya memerlukan sebagian kecil dari fungsinya.  Saya juga ingin mencoba dalam praktiknya fitur-fitur baru C ++ 17, yang tidak terlalu saya kenal. </p><br><p>  Dalam posting ini saya akan menyajikan contoh bekerja dengan parser libclang dengan Python. </p><a name="habracut"></a><br><p>  Saya akan menghilangkan detail tentang melepaskan RTTI saya.  Penting bagi kami dalam hal ini hanya poin-poin berikut: </p><br><ul><li> Setiap kelas atau struktur yang dapat memberikan informasi tentang jenisnya harus mewarisi antarmuka <code>IRttiTypeIdProvider</code> ; </li><li>  Di setiap kelas tersebut (jika tidak abstrak), Anda harus menambahkan makro <code>RTTI_HAS_TYPE_ID</code> , yang menambahkan bidang statis penunjuk jenis ke objek <code>RttiTypeId</code> .  Jadi, untuk mendapatkan pengenal tipe, Anda dapat menulis <code>MyClass::__typeId</code> atau memanggil metode <code>getTypeId</code> instance spesifik dari kelas saat runtime. </li></ul><br><p>  Contoh: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include "RTTI.h" struct BaseNode : public IRttiTypeIdProvider { virtual ~BaseNode() = default; bool bypass = false; }; struct SourceNode : public BaseNode { RTTI_HAS_TYPE_ID std::string inputFilePath; }; struct DestinationNode : public BaseNode { RTTI_HAS_TYPE_ID bool includeDebugInfo = false; std::string outputFilePath; }; struct MultiplierNode : public BaseNode { RTTI_HAS_TYPE_ID double multiplier; }; struct InverterNode : public BaseNode { RTTI_HAS_TYPE_ID };</span></span></span></span></code> </pre> <br><p>  Itu sudah mungkin untuk bekerja dengan ini, tetapi setelah beberapa waktu saya perlu mendapatkan informasi tentang bidang kelas ini: nama bidang, offset dan ukuran.  Untuk mengimplementasikan semua ini, Anda harus secara manual membentuk struktur dengan deskripsi setiap bidang kelas yang diminati di suatu tempat di file .cpp.  Setelah menulis beberapa makro, deskripsi jenis dan bidangnya mulai terlihat seperti ini: </p><br><pre> <code class="cpp hljs">RTTI_PROVIDER_BEGIN_TYPE(SourceNode) ( RTTI_DEFINE_FIELD(SourceNode, bypass) RTTI_DEFINE_FIELD(SourceNode, inputFilePath) ) RTTI_PROVIDER_END_TYPE() RTTI_PROVIDER_BEGIN_TYPE(DestinationNode) ( RTTI_DEFINE_FIELD(DestinationNode, bypass) RTTI_DEFINE_FIELD(DestinationNode, includeDebugInfo) RTTI_DEFINE_FIELD(DestinationNode, outputFilePath) ) RTTI_PROVIDER_END_TYPE() RTTI_PROVIDER_BEGIN_TYPE(MultiplierNode) ( RTTI_DEFINE_FIELD(MultiplierNode, bypass) RTTI_DEFINE_FIELD(MultiplierNode, multiplier) ) RTTI_PROVIDER_END_TYPE() RTTI_PROVIDER_BEGIN_TYPE(InverterNode) ( RTTI_DEFINE_FIELD(InverterNode, bypass) )</code> </pre> <br><p>  Dan ini hanya untuk 4 kelas.  Masalah apa yang bisa diidentifikasi? </p><br><ol><li>  Saat menyalin blok kode yang ditempel secara manual, Anda bisa kehilangan nama kelas ketika mendefinisikan bidang (kami menyalin blok dari SourceNode ke DestinationNode, tetapi lupa mengubah SourceNode ke DestinationNode di salah satu bidang).  Kompiler akan melewatkan segalanya, aplikasi mungkin tidak jatuh, tetapi informasi tentang bidang tersebut akan salah.  Dan jika Anda merekam atau membaca data berdasarkan informasi dari bidang seperti itu, maka semuanya akan meledak (kata mereka, tetapi saya tidak ingin memeriksanya sendiri). </li><li>  Jika Anda menambahkan bidang ke kelas dasar, maka SEMUA catatan harus diperbarui. </li><li>  Jika Anda mengubah nama atau urutan bidang di kelas, maka Anda harus ingat untuk memperbarui nama dan urutan di footcloth kode ini. </li></ol><br><p>  Tetapi yang utama adalah semua ini harus ditulis secara manual.  Ketika datang ke kode monoton, saya menjadi sangat malas dan mencari cara untuk menghasilkannya secara otomatis, bahkan jika itu membutuhkan lebih banyak waktu dan usaha daripada penulisan manual. </p><br><p>  Python membantu saya dengan ini, saya menulis skrip di atasnya untuk menyelesaikan masalah seperti itu.  Tapi kita berhadapan bukan hanya dengan teks templat, tetapi dengan teks yang dibangun berdasarkan kode sumber C ++.  Kami membutuhkan alat untuk mendapatkan informasi tentang kode C ++, dan libclang akan membantu kami dalam hal ini. </p><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">libclang</a> adalah antarmuka C tingkat tinggi untuk Dentang.  Menyediakan API untuk alat untuk mem-parsing kode sumber dalam pohon sintaksis abstrak (AST), memuat AST yang sudah diuraikan, melintasi AST, memetakan lokasi sumber fisik ke elemen-elemen dalam AST, dan toolset Dentang lainnya. </blockquote><p>  Sebagai berikut dari deskripsi, libclang menyediakan antarmuka-C, dan untuk bekerja dengannya melalui Python Anda membutuhkan pustaka pengikat (binding).  Pada saat menulis posting ini tidak ada perpustakaan seperti resmi untuk Python, tetapi dari tidak resmi ada ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/ethanhs/clang</a> . </p><br><p>  Instal melalui manajer paket: </p><br><pre> <code class="plaintext hljs">pip install clang</code> </pre> <br><p>  Perpustakaan disediakan dengan komentar dalam kode sumber.  Tetapi untuk memahami perangkat libclang, Anda perlu membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi libclang</a> .  Tidak banyak contoh menggunakan perpustakaan, dan tidak ada komentar yang menjelaskan mengapa semuanya berjalan seperti ini, dan tidak sebaliknya.  Mereka yang sudah memiliki pengalaman dengan libclang akan memiliki lebih sedikit pertanyaan, tetapi saya pribadi tidak memiliki pengalaman seperti itu, jadi saya harus menggali lebih dalam ke dalam kode dan melihat-lihat dalam debugger. </p><br><p>  Mari kita mulai dengan contoh sederhana: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> clang.cindex index = clang.cindex.Index.create() translation_unit = index.parse(<span class="hljs-string"><span class="hljs-string">'my_source.cpp'</span></span>, args=[<span class="hljs-string"><span class="hljs-string">'-std=c++17'</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> translation_unit.get_tokens(extent=translation_unit.cursor.extent): <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (i.kind)</code> </pre> <br><p>  Di sini objek tipe <code>Index</code> dibuat yang dapat mem-parsing file dengan kode C ++.  Metode <code>parse</code> mengembalikan objek bertipe <code>TranslationUnit</code> , ini adalah unit terjemahan kode.  <code>TranslationUnit</code> adalah simpul AST, dan setiap simpul AST menyimpan informasi tentang posisinya dalam kode sumber (luas).  Kami mengulangi semua token di <code>TranslationUnit</code> dan mencetak jenis token ini (properti jenis). </p><br><p>  Misalnya, ambil kode C ++ berikut: </p><br><pre> <code class="plaintext hljs">class X {}; class Y {}; class Z : public X {};</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Hasil eksekusi skrip</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">TokenKind.KEYWORD TokenKind.IDENTIFIER TokenKind.PUNCTUATION TokenKind.PUNCTUATION TokenKind.PUNCTUATION TokenKind.KEYWORD TokenKind.IDENTIFIER TokenKind.PUNCTUATION TokenKind.PUNCTUATION TokenKind.PUNCTUATION TokenKind.KEYWORD TokenKind.IDENTIFIER TokenKind.PUNCTUATION TokenKind.KEYWORD TokenKind.IDENTIFIER TokenKind.PUNCTUATION TokenKind.PUNCTUATION TokenKind.PUNCTUATION</code> </pre> </div></div><br><p>  Sekarang mari kita menangani AST.  Sebelum menulis kode Python, mari kita lihat apa yang harus kita harapkan dari parser dentang.  Jalankan dentang dalam mode dump AST: </p><br><pre> <code class="plaintext hljs">clang++ -cc1 -ast-dump my_source.cpp</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Hasil perintah</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">TranslationUnitDecl 0xaaaa9b9fa8 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; |-TypedefDecl 0xaaaa9ba880 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __int128_t '__int128' | `-BuiltinType 0xaaaa9ba540 '__int128' |-TypedefDecl 0xaaaa9ba8e8 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __uint128_t 'unsigned __int128' | `-BuiltinType 0xaaaa9ba560 'unsigned __int128' |-TypedefDecl 0xaaaa9bac48 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __NSConstantString '__NSConstantString_tag' | `-RecordType 0xaaaa9ba9d0 '__NSConstantString_tag' | `-CXXRecord 0xaaaa9ba938 '__NSConstantString_tag' |-TypedefDecl 0xaaaa9e6570 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __builtin_ms_va_list 'char *' | `-PointerType 0xaaaa9e6530 'char *' | `-BuiltinType 0xaaaa9ba040 'char' |-TypedefDecl 0xaaaa9e65d8 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __builtin_va_list 'char *' | `-PointerType 0xaaaa9e6530 'char *' | `-BuiltinType 0xaaaa9ba040 'char' |-CXXRecordDecl 0xaaaa9e6628 &lt;my_source.cpp:1:1, col:10&gt; col:7 referenced class X definition | |-DefinitionData pass_in_registers empty aggregate standard_layout trivially_copyable pod trivial literal has_constexpr_non_copy_move_ctor can_const_default_init | | |-DefaultConstructor exists trivial constexpr needs_implicit defaulted_is_constexpr | | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param | | |-MoveConstructor exists simple trivial needs_implicit | | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param | | |-MoveAssignment exists simple trivial needs_implicit | | `-Destructor simple irrelevant trivial needs_implicit | `-CXXRecordDecl 0xaaaa9e6748 &lt;col:1, col:7&gt; col:7 implicit class X |-CXXRecordDecl 0xaaaa9e6800 &lt;line:3:1, col:10&gt; col:7 class Y definition | |-DefinitionData pass_in_registers empty aggregate standard_layout trivially_copyable pod trivial literal has_constexpr_non_copy_move_ctor can_const_default_init | | |-DefaultConstructor exists trivial constexpr needs_implicit defaulted_is_constexpr | | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param | | |-MoveConstructor exists simple trivial needs_implicit | | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param | | |-MoveAssignment exists simple trivial needs_implicit | | `-Destructor simple irrelevant trivial needs_implicit | `-CXXRecordDecl 0xaaaa9e6928 &lt;col:1, col:7&gt; col:7 implicit class Y `-CXXRecordDecl 0xaaaa9e69e0 &lt;line:5:1, col:21&gt; col:7 class Z definition |-DefinitionData pass_in_registers empty standard_layout trivially_copyable trivial literal has_constexpr_non_copy_move_ctor can_const_default_init | |-DefaultConstructor exists trivial constexpr needs_implicit defaulted_is_constexpr | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param | |-MoveConstructor exists simple trivial needs_implicit | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param | |-MoveAssignment exists simple trivial needs_implicit | `-Destructor simple irrelevant trivial needs_implicit |-public 'X' `-CXXRecordDecl 0xaaaa9e6b48 &lt;col:1, col:7&gt; col:7 implicit class Z</code> </pre> </div></div><br><p>  Di sini <code>CXXRecordDecl</code> adalah jenis simpul yang mewakili deklarasi kelas.  Anda mungkin memperhatikan bahwa ada lebih banyak node daripada kelas dalam file sumber.  Ini karena node referensi diwakili oleh tipe yang sama, yaitu  node yang merupakan tautan ke node lain.  Dalam kasus kami, menentukan kelas dasar adalah referensi.  Saat membongkar pohon ini, Anda dapat menentukan simpul referensi menggunakan bendera khusus. </p><br><p>  Sekarang kami akan menulis skrip yang mencantumkan kelas dalam file sumber: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> clang.cindex <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> typing index = clang.cindex.Index.create() translation_unit = index.parse(<span class="hljs-string"><span class="hljs-string">'my_source.cpp'</span></span>, args=[<span class="hljs-string"><span class="hljs-string">'-std=c++17'</span></span>]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter_node_list_by_node_kind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( nodes: typing.Iterable[clang.cindex.Cursor], kinds: list )</span></span></span><span class="hljs-function"> -&gt; typing.Iterable[clang.cindex.Cursor]:</span></span> result = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> nodes: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i.kind <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> kinds: result.append(i) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result all_classes = filter_node_list_by_node_kind(translation_unit.cursor.get_children(), [clang.cindex.CursorKind.CLASS_DECL, clang.cindex.CursorKind.STRUCT_DECL]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> all_classes: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (i.spelling)</code> </pre><br><p>  Nama kelas disimpan di properti <code>spelling</code> .  Untuk berbagai jenis node, nilai <code>spelling</code> mungkin berisi beberapa jenis pengubah, tetapi untuk deklarasi kelas atau struktur, itu berisi nama tanpa pengubah. </p><br><p>  Hasil Eksekusi: </p><br><pre> <code class="plaintext hljs">X Y Z</code> </pre> <br><p>  Saat parsing, AST clang juga mem-parsing file yang terhubung melalui <code>#include</code> .  Coba tambahkan <code>#include &lt;string&gt;</code> ke sumber, dan di dump Anda akan mendapatkan 84 ribu baris, yang jelas sedikit banyak untuk menyelesaikan masalah kami. </p><br><p>  Untuk melihat dump AST dari file-file tersebut melalui baris perintah, lebih baik hapus semua <code>#include</code> .  Bawa mereka kembali ketika Anda mempelajari AST dan mendapatkan gagasan tentang hierarki dan jenis dalam file yang menarik. </p><br><p>  Dalam skrip, untuk memfilter hanya AST milik file sumber, dan tidak terhubung melalui <code>#include</code> , Anda dapat menambahkan fungsi penyaringan berikut oleh file: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter_node_list_by_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( nodes: typing.Iterable[clang.cindex.Cursor], file_name: str )</span></span></span><span class="hljs-function"> -&gt; typing.Iterable[clang.cindex.Cursor]:</span></span> result = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> nodes: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i.location.file.name == file_name: result.append(i) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result ... filtered_ast = filter_by_file(translation_unit.cursor, translation_unit.spelling)</code> </pre> <br><p>  Sekarang Anda bisa melakukan ekstraksi bidang.  Selanjutnya, saya akan memberikan kode lengkap yang menghasilkan daftar bidang <em>dengan mempertimbangkan warisan akun</em> dan menghasilkan teks sesuai dengan templat.  Tidak ada yang spesifik untuk dentang di sini, jadi tidak ada komentar. </p><br><div class="spoiler">  <b class="spoiler_title">Kode skrip lengkap</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> clang.cindex <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> typing index = clang.cindex.Index.create() translation_unit = index.parse(<span class="hljs-string"><span class="hljs-string">'Input.h'</span></span>, args=[<span class="hljs-string"><span class="hljs-string">'-std=c++17'</span></span>]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter_node_list_by_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( nodes: typing.Iterable[clang.cindex.Cursor], file_name: str )</span></span></span><span class="hljs-function"> -&gt; typing.Iterable[clang.cindex.Cursor]:</span></span> result = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> nodes: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i.location.file.name == file_name: result.append(i) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter_node_list_by_node_kind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( nodes: typing.Iterable[clang.cindex.Cursor], kinds: list )</span></span></span><span class="hljs-function"> -&gt; typing.Iterable[clang.cindex.Cursor]:</span></span> result = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> nodes: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i.kind <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> kinds: result.append(i) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_exposed_field</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(node)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node.access_specifier == clang.cindex.AccessSpecifier.PUBLIC <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_all_exposed_fields</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( cursor: clang.cindex.Cursor )</span></span></span><span class="hljs-function">:</span></span> result = [] field_declarations = filter_node_list_by_node_kind(cursor.get_children(), [clang.cindex.CursorKind.FIELD_DECL]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> field_declarations: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> is_exposed_field(i): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result.append(i.displayname) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result source_nodes = filter_node_list_by_file(translation_unit.cursor.get_children(), translation_unit.spelling) all_classes = filter_node_list_by_node_kind(source_nodes, [clang.cindex.CursorKind.CLASS_DECL, clang.cindex.CursorKind.STRUCT_DECL]) class_inheritance_map = {} class_field_map = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> all_classes: bases = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> i.get_children(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.kind == clang.cindex.CursorKind.CXX_BASE_SPECIFIER: referenceNode = node.referenced bases.append(node.referenced) class_inheritance_map[i.spelling] = bases <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> all_classes: fields = find_all_exposed_fields(i) class_field_map[i.spelling] = fields <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">populate_field_list_recursively</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(class_name: str)</span></span></span><span class="hljs-function">:</span></span> field_list = class_field_map.get(class_name) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> field_list <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] baseClasses = class_inheritance_map[class_name] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> baseClasses: field_list = populate_field_list_recursively(i.spelling) + field_list <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> field_list rtti_map = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> class_name, class_list <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> class_inheritance_map.items(): rtti_map[class_name] = populate_field_list_recursively(class_name) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> class_name, field_list <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rtti_map.items(): wrapper_template = <span class="hljs-string"><span class="hljs-string">"""\ RTTI_PROVIDER_BEGIN_TYPE(%s) ( %s ) RTTI_PROVIDER_END_TYPE() """</span></span> rendered_fields = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> field_list: rendered_fields.append(<span class="hljs-string"><span class="hljs-string">" RTTI_DEFINE_FIELD(%s, %s)"</span></span> % (class_name, f)) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (wrapper_template % (class_name, <span class="hljs-string"><span class="hljs-string">",\n"</span></span>.join(rendered_fields)))</code> </pre></div></div><br><p>  Skrip ini tidak mempertimbangkan apakah kelas memiliki RTTI.  Oleh karena itu, setelah menerima hasilnya, Anda harus menghapus secara manual blok yang menggambarkan kelas tanpa RTTI.  Tapi ini agak sepele. </p><br><p>  Saya harap seseorang akan berguna dan menghemat waktu.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Semua kode diposting di GitHub</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439270/">https://habr.com/ru/post/id439270/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439260/index.html">Penulis The Witcher masih akan menerima kompensasi dari CD Projekt Red</a></li>
<li><a href="../id439262/index.html">Menyebarkan kode langsung ke wadah buruh pelabuhan. Atau bagaimana tidak menunda-nunda setelah setiap komit</a></li>
<li><a href="../id439264/index.html">Cara mengelola proyek teknis yang rumit tanpa mempekerjakan PM: Pengalaman DataLine</a></li>
<li><a href="../id439266/index.html">Pengalaman membuat game untuk Android sendiri dari awal dan bagaimana itu dikreditkan ke Google Play</a></li>
<li><a href="../id439268/index.html">Bagaimana VR, AR, dan pencetakan 3D bekerja bersama: Pengalaman Konsep VR</a></li>
<li><a href="../id439272/index.html">Notebook Jupyter di Netflix</a></li>
<li><a href="../id439278/index.html">ACS LCD saya - pengaman di dua baut</a></li>
<li><a href="../id439280/index.html">Trautonium: gelombang Jerman dalam sejarah synthesizer</a></li>
<li><a href="../id439282/index.html">Efek penyaringan SVG. Bagian 1. Filter SVG 101</a></li>
<li><a href="../id439286/index.html">Tentang analisis statis dalam semua kejujuran</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>