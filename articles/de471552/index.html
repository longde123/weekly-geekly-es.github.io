<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äçüç≥ üë¥üèΩ üë©üèº‚Äçüç≥ Schreiben eines Doom-Engine-Klons: Lesen von Karteninformationen üí¶ üö¢ üë®üèº‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Das Ziel dieses Projekts ist es, einen Klon der DOOM-Engine unter Verwendung von Ressourcen zu erstellen, die mit Ultimate DOOM ( Version...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schreiben eines Doom-Engine-Klons: Lesen von Karteninformationen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471552/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/423/35b/c2f42335b751d3bd9acec03251204977.png" alt="Bild"></div><br><h2>  Einf√ºhrung </h2><br>  Das Ziel dieses Projekts ist es, einen Klon der DOOM-Engine unter Verwendung von Ressourcen zu erstellen, die mit Ultimate DOOM ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Version von Steam</a> ) ver√∂ffentlicht wurden. <br><br>  Es wird in Form eines Tutorials pr√§sentiert. Ich m√∂chte keine maximale Leistung im Code erzielen, sondern nur eine funktionierende Version erstellen. Sp√§ter werde ich damit beginnen, sie zu verbessern und zu optimieren. <br><br>  Ich habe keine Erfahrung mit dem Erstellen von Spielen oder Game-Engines und wenig Erfahrung mit dem Schreiben von Artikeln. Sie k√∂nnen also Ihre eigenen √Ñnderungen vorschlagen oder den Code sogar komplett neu schreiben. <br><br>  Hier ist eine Liste von Ressourcen und Links. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Book Game Engine Schwarzes Buch: DOOM Fabien Sanglar</a> .  Eines der besten B√ºcher √ºber DOOM-Interna. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Doom Wiki</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DOOM-Quellcode</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellcode Chocolate Doom</a> <br><a name="habracut"></a><br><h3>  Anforderungen </h3><br><ul><li>  Visual Studio: Jede IDE reicht aus.  Ich werde in Visual Studio 2017 arbeiten. </li><li>  SDL2: Bibliotheken. </li><li>  DOOM: Als Kopie der Steam-Version von Ultimate DOOM ben√∂tigen wir nur eine WAD-Datei. </li></ul><br><h3>  Optional </h3><br><ul><li>  Slade3: Ein gutes Werkzeug, um unsere Arbeit zu testen. </li></ul><br><h3>  Gedanken </h3><br>  Ich wei√ü nicht, ich kann dieses Projekt abschlie√üen, aber ich werde mein Bestes geben. <br><br>  Windows wird meine Zielplattform sein, aber da ich SDL verwende, funktioniert die Engine nur unter jeder anderen Plattform. <br><br>  Installieren Sie in der Zwischenzeit Visual Studio! <br><br>  Das Projekt wurde von Handmade DOOM in Do It Yourself Doom mit SLD (DIY Doom) umbenannt, damit es nicht mit anderen Projekten namens ‚ÄûHandmade‚Äú verwechselt wird.  Es gibt einige Screenshots im Tutorial, in denen es immer noch Handmade DOOM hei√üt. <br><br><h2>  WAD-Dateien </h2><br>  Bevor wir mit dem Codieren beginnen, setzen wir uns Ziele und √ºberlegen, was wir erreichen wollen. <br><br>  Lassen Sie uns zun√§chst pr√ºfen, ob wir DOOM-Ressourcendateien lesen k√∂nnen.  Alle DOOM-Ressourcen befinden sich in der WAD-Datei. <br><br><h2>  Was ist eine WAD-Datei? </h2><br>  "Wo sind alle meine Daten?"  ("Wo sind alle meine Daten?") Sie sind in WAD!  WAD ist ein Archiv aller DOOM-Ressourcen (und DOOM-basierten Spiele) in einer einzigen Datei. <br><br>  Doom-Entwickler haben dieses Format entwickelt, um die Erstellung von Spielmodifikationen zu vereinfachen. <br><br><h2>  WAD-Dateianatomie </h2><br>  Die WAD-Datei besteht aus drei Hauptteilen: dem Header (Header), "St√ºcken" (Klumpen) und Verzeichnissen (Verzeichnissen). <br><br><ol><li>  Header - enth√§lt grundlegende Informationen zur WAD-Datei und zum Verzeichnisoffset. </li><li>  Klumpen - hier sind gespeicherte Spielressourcen, Daten von Karten, Sprites, Musik usw. gespeichert. </li><li>  Verzeichnisse - Die Organisationsstruktur zum Auffinden von Daten im Pauschalabschnitt. </li></ol><br><br><pre> <code class="hljs erlang-repl"> &lt;---- <span class="hljs-number"><span class="hljs-number">32</span></span> bits ----&gt; /------------------\ ---&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>x00 | ASCII WAD Type | <span class="hljs-number"><span class="hljs-number">0</span></span>X03 | |------------------| Header -| <span class="hljs-number"><span class="hljs-number">0</span></span>x04 | # of directories | <span class="hljs-number"><span class="hljs-number">0</span></span>x07 | |------------------| ---&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>x08 | directory offset | <span class="hljs-number"><span class="hljs-number">0</span></span>x0B -- ---&gt; |------------------| &lt;-- | | <span class="hljs-number"><span class="hljs-number">0</span></span>x0C | Lump Data | | | | |------------------| | | Lumps - | | . | | | | | . | | | | | . | | | ---&gt; | . | | | ---&gt; |------------------| &lt;--|--- | | Lump offset | | | |------------------| | Directory -| | directory offset | --- List | |------------------| | | Lump Name | | |------------------| | | . | | | . | | | . | ---&gt; \------------------/</code> </pre><br><h3>  Header-Format </h3><br><div class="scrollable-table"><table><thead><tr><th>  Feldgr√∂√üe </th><th>  Datentyp </th><th>  Inhalt </th></tr></thead><tbody><tr><td>  0x00-0x03 </td><td>  4 ASCII-Zeichen </td><td>  ASCII-Zeichenfolge (mit den Werten "IWAD" oder "PWAD"). </td></tr><tr><td>  0x04-0x07 </td><td>  unsigned int </td><td>  Verzeichnis-Artikelnummer. </td></tr><tr><td>  0x08-0x0b </td><td>  unsigned int </td><td>  Verzeichnisversatzwert in der WAD-Datei. </td></tr></tbody></table></div><br><h3>  Verzeichnisformat </h3><br><div class="scrollable-table"><table><thead><tr><th>  Feldgr√∂√üe </th><th>  Datentyp </th><th>  Inhalt </th></tr></thead><tbody><tr><td>  0x00-0x03 </td><td>  unsigned int </td><td>  Der Versatzwert am Anfang der Klumpendaten in der WAD-Datei. </td></tr><tr><td>  0x04-0x07 </td><td>  unsigned int </td><td>  Die Gr√∂√üe des "St√ºcks" (Klumpens) in Bytes. </td></tr><tr><td>  0x08-0x0f </td><td>  8 ASCII-Zeichen </td><td>  ASCII mit dem Namen "St√ºck". </td></tr></tbody></table></div><br><h2>  Ziele </h2><br><ol><li>  Erstellen Sie ein Projekt. </li><li>  √ñffnen Sie die WAD-Datei. </li><li>  Lesen Sie die √úberschrift. </li><li>  Lesen Sie alle Verzeichnisse und zeigen Sie sie an. </li></ol><br><h2>  Architektur </h2><br>  Lassen Sie uns noch nichts komplizieren.  Erstellen Sie eine Klasse, die WAD gerade √∂ffnet und l√§dt, und nennen Sie sie WADLoader.  Dann schreiben wir eine Klasse, die abh√§ngig von ihrem Format f√ºr das Lesen von Daten verantwortlich ist, und nennen sie WADReader.  Wir brauchen auch eine einfache Hauptfunktion, die diese Klassen aufruft. <br><br>  Hinweis: Diese Architektur ist m√∂glicherweise nicht optimal. Falls erforderlich, werden wir sie √§ndern. <br><br><h2>  Zum Code gelangen </h2><br>  Beginnen wir mit der Erstellung eines leeren C ++ - Projekts.  Klicken Sie in Visual Studio auf Datei-&gt; Neu -&gt; Projekt.  Nennen wir es DIYDoom. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdc/753/755/bdc7537557888a7ece9738204ecb457d.png"></div><br>  F√ºgen wir zwei neue Klassen hinzu: WADLoader und WADReader.  Beginnen wir mit der Implementierung von WADLoader. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WADLoader</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: WADLoader(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> sWADFilePath); <span class="hljs-comment"><span class="hljs-comment">// We always want to make sure a WAD file is passed bool LoadWAD(); // Will call other helper functions to open and load the WAD file ~WADLoader(); // Clean up! protected: bool OpenAndLoad(); // Open the file and load it to memory bool ReadDirectories(); // A function what will iterate though the directory section std::string m_sWADFilePath; // Sore the file name passed to the constructor std::ifstream m_WADFile; // The file stream that will pint to the WAD file. uint8_t *m_WADData; // let's load the file and keep it in memory! It is just a few MBs! std::vector&lt;Directory&gt; m_WADDirectories; //let's store all the directories in this vector. };</span></span></code> </pre> <br>  Die Implementierung des Konstruktors ist einfach: Initialisieren Sie den Datenzeiger und speichern Sie eine Kopie des √ºbertragenen Pfads in der WAD-Datei. <br><br><pre> <code class="cpp hljs">WADLoader::WADLoader(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> sWADFilePath) : m_WADData(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>), m_sWADFilePath(sWADFilePath) { }</code> </pre> <br>  <code>OpenAndLoad</code> wir nun zur Implementierung der Hilfsfunktion zum Laden von <code>OpenAndLoad</code> : Wir versuchen nur, die Datei als Bin√§rdatei zu √∂ffnen und im Fehlerfall einen Fehler anzuzeigen. <br><br><pre> <code class="cpp hljs">m_WADFile.open(m_sWADFilePath, ifstream::binary); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_WADFile.is_open()) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error: Failed to open WAD file"</span></span> &lt;&lt; m_sWADFilePath &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Wenn alles gut geht und wir die Datei finden und √∂ffnen k√∂nnen, m√ºssen wir die Dateigr√∂√üe kennen, um Speicher zum Kopieren der Datei zuzuweisen. <br><br><pre> <code class="cpp hljs">m_WADFile.seekg(<span class="hljs-number"><span class="hljs-number">0</span></span>, m_WADFile.end); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> length = m_WADFile.tellg();</code> </pre> <br>  Jetzt wissen wir, wie viel Speicherplatz ein vollst√§ndiger WAD ben√∂tigt, und wir werden die erforderliche Speichermenge zuweisen. <br><br><pre> <code class="cpp hljs">m_WADData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>[length];</code> </pre> <br>  Kopieren Sie den Inhalt der Datei in diesen Speicher. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// remember to know the file size we had to move the file pointer all the way to the end! We need to move it back to the beginning. m_WADFile.seekg(ifstream::beg); m_WADFile.read((char *)m_WADData, length); // read the file and place it in m_WADData m_WADFile.close();</span></span></code> </pre> <br>  M√∂glicherweise haben Sie bemerkt, dass ich den Typ <code>m_WADData</code> als Datentyp f√ºr <code>unint8_t</code> .  Dies bedeutet, dass ich ein genaues Array von 1 Byte (1 Byte * L√§nge) ben√∂tige.  Die Verwendung von unint8_t stellt sicher, dass die Gr√∂√üe einem Byte entspricht (8 Bit, was aus dem Typnamen ersichtlich ist).  Wenn wir 2 Bytes (16 Bit) zuweisen wollten, w√ºrden wir unint16_t verwenden, wor√ºber wir sp√§ter sprechen werden.  Durch die Verwendung dieser Codetypen wird der Code plattformunabh√§ngig.  Ich werde erkl√§ren: Wenn wir "int" verwenden, h√§ngt die genaue Gr√∂√üe von int im Speicher vom System ab.  Wenn wir "int" in einer 32-Bit-Konfiguration kompilieren, erhalten wir eine Speichergr√∂√üe von 4 Bytes (32 Bit), und wenn wir denselben Code in einer 64-Bit-Konfiguration kompilieren, erhalten wir eine Speichergr√∂√üe von 8 Bytes (64 Bit)!  Schlimmer noch, wenn Sie den Code auf einer 16-Bit-Plattform kompilieren (Sie k√∂nnten ein DOS-Fan sein), erhalten Sie 2 Bytes (16 Bit)! <br><br>  Lassen Sie uns den Code kurz √ºberpr√ºfen und sicherstellen, dass alles funktioniert.  Aber zuerst m√ºssen wir LoadWAD implementieren.  W√§hrend LoadWAD "OpenAndLoad" aufruft <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WADLoader::LoadWAD() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!OpenAndLoad()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  F√ºgen wir dem Hauptfunktionscode hinzu, der eine Instanz der Klasse erstellt und versucht, WAD zu laden <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">WADLoader </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wadloader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"D:\\SDKs\\Assets\\Doom\\DOOM.WAD"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; wadloader.LoadWAD(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  <strong>Sie m√ºssen den richtigen Pfad zu Ihrer WAD-Datei eingeben.</strong>  Lass es uns laufen! <br><br>  Autsch!  Wir haben ein Konsolenfenster, das sich nur f√ºr ein paar Sekunden √∂ffnet!  Nichts besonders N√ºtzliches ... funktioniert das Programm?  Die Idee!  Werfen wir einen Blick auf die Erinnerung und sehen, was darin enthalten ist!  Vielleicht finden wir dort etwas Besonderes!  Platzieren Sie zun√§chst einen Haltepunkt, indem Sie links neben der Zeilennummer doppelklicken.  Sie sollten so etwas sehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/c5c/760/44bc5c7609610c9f8f1efd2c2e2046ef.png"></div><br>  Ich habe unmittelbar nach dem Lesen aller Daten aus der Datei einen Haltepunkt gesetzt, um das Speicherarray zu √ºberpr√ºfen und festzustellen, was in die Datei geladen wurde.  F√ºhren Sie nun den Code erneut aus!  Im automatischen Fenster sehe ich die ersten paar Bytes.  Die ersten 4 Bytes sagen "IWAD"!  Gro√üartig, es funktioniert!  Ich h√§tte nie gedacht, dass dieser Tag kommen w√ºrde!  Also, okay, du musst dich beruhigen, es liegt noch viel Arbeit vor dir! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c4/1a3/ddb/4c41a3ddb26bfa88f350435ca4792c31.png" alt="Debuggen"></div><br><h2>  Header lesen </h2><br>  Die Gesamtgr√∂√üe des Headers betr√§gt 12 Bytes (von 0x00 bis 0x0b). Diese 12 Bytes sind in 3 Gruppen unterteilt.  Die ersten 4 Bytes sind eine Art von WAD, normalerweise "IWAD" oder "PWAD".  IWAD sollte das offizielle WAD sein, das von ID Software ver√∂ffentlicht wurde, "PWAD" sollte f√ºr Mods verwendet werden.  Mit anderen Worten, dies ist nur eine M√∂glichkeit festzustellen, ob die WAD-Datei eine offizielle Version ist oder von Moddern ver√∂ffentlicht wurde.  Beachten Sie, dass die Zeichenfolge nicht mit NULL abgeschlossen ist. Seien Sie also vorsichtig!  Die n√§chsten 4 Bytes sind int ohne Vorzeichen, das die Gesamtzahl der Verzeichnisse am Ende der Datei enth√§lt.  Die n√§chsten 4 Bytes geben den Offset des ersten Verzeichnisses an. <br><br>  F√ºgen wir eine Struktur hinzu, in der Informationen gespeichert werden.  Ich werde eine neue Header-Datei hinzuf√ºgen und sie "DataTypes.h" nennen.  Darin werden wir alle Strukturen beschreiben, die wir brauchen. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Header</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> WADType[<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// I added an extra character to add the NULL uint32_t DirectoryCount; //uint32_t is 4 bytes (32 bits) uint32_t DirectoryOffset; // The offset where the first directory is located. };</span></span></code> </pre> <br>  Jetzt m√ºssen wir die WADReader-Klasse implementieren, die Daten aus dem geladenen WAD-Byte-Array liest.  Autsch!  Hier gibt es einen Trick: WAD-Dateien sind im Big-Endian-Format, dh wir m√ºssen die Bytes verschieben, um sie zu Little-Endian zu machen (heutzutage verwenden die meisten Systeme Little-Endian).  Dazu f√ºgen wir zwei Funktionen hinzu, eine f√ºr die Verarbeitung von 2 Bytes (16 Bit) und eine f√ºr die Verarbeitung von 4 Bytes (32 Bit).  Wenn wir nur 1 Byte lesen m√ºssen, muss nichts getan werden. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> WADReader::bytesToShort(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (pWADData[offset + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | pWADData[offset]; } <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> WADReader::bytesToInteger(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (pWADData[offset + <span class="hljs-number"><span class="hljs-number">3</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">24</span></span>) | (pWADData[offset + <span class="hljs-number"><span class="hljs-number">2</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | (pWADData[offset + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | pWADData[offset]; }</code> </pre> <br>  Jetzt k√∂nnen wir den Header lesen: Z√§hlen Sie die ersten vier Bytes als Zeichen und f√ºgen Sie dann NULL hinzu, um unsere Arbeit zu vereinfachen.  Bei der Anzahl der Verzeichnisse und deren Versatz k√∂nnen Sie diese einfach mit Hilfsfunktionen in das richtige Format konvertieren. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WADReader::ReadHeaderData(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset, Header &amp;header) { <span class="hljs-comment"><span class="hljs-comment">//0x00 to 0x03 header.WADType[0] = pWADData[offset]; header.WADType[1] = pWADData[offset + 1]; header.WADType[2] = pWADData[offset + 2]; header.WADType[3] = pWADData[offset + 3]; header.WADType[4] = '\0'; //0x04 to 0x07 header.DirectoryCount = bytesToInteger(pWADData, offset + 4); //0x08 to 0x0b header.DirectoryOffset = bytesToInteger(pWADData, offset + 8); }</span></span></code> </pre> <br>  Lassen Sie uns alles zusammenfassen, diese Funktionen aufrufen und die Ergebnisse drucken <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WADLoader::ReadDirectories() { WADReader reader; Header header; reader.ReadHeaderData(m_WADData, <span class="hljs-number"><span class="hljs-number">0</span></span>, header); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; header.WADType &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; header.DirectoryCount &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; header.DirectoryOffset &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  F√ºhren Sie das Programm aus und pr√ºfen Sie, ob alles funktioniert! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfa/693/d03/dfa693d039ab66df047768c209561ac2.png"></div><br>  Gro√üartig!  Die IWAD-Linie ist deutlich sichtbar, aber sind die beiden anderen Zahlen korrekt?  Versuchen wir, Verzeichnisse mit diesen Offsets zu lesen und zu sehen, ob es funktioniert! <br><br>  Wir m√ºssen eine neue Struktur hinzuf√ºgen, um das Verzeichnis zu verarbeiten, das den obigen Optionen entspricht. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Directory</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> LumpOffset; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> LumpSize; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> LumpName[<span class="hljs-number"><span class="hljs-number">9</span></span>]; };</code> </pre> <br>  F√ºgen wir nun die ReadDirectories-Funktion hinzu: Z√§hlen Sie den Offset und geben Sie sie aus! <br><br>  In jeder Iteration multiplizieren wir i * 16, um zum Offset-Inkrement des n√§chsten Verzeichnisses zu gelangen. <br><br><pre> <code class="cpp hljs">Directory directory; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; header.DirectoryCount; ++i) { reader.ReadDirectoryData(m_WADData, header.DirectoryOffset + i * <span class="hljs-number"><span class="hljs-number">16</span></span>, directory); m_WADDirectories.push_back(directory); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; directory.LumpOffset &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; directory.LumpSize &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; directory.LumpName &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br>  F√ºhren Sie den Code aus und sehen Sie, was passiert.  Wow!  Eine gro√üe Liste von Verzeichnissen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fb/7b5/af6/8fb7b5af6df0d44303c11d5bd005e93d.png" alt="Unterscheidet Sie 2 aus"></div><br>  Dem Namensklumpen nach zu urteilen, k√∂nnen wir davon ausgehen, dass wir die Daten korrekt gelesen haben, aber vielleicht gibt es einen besseren Weg, dies zu √ºberpr√ºfen.  Wir werden uns die WAD-Verzeichniseintr√§ge mit Slade3 ansehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1c/6b7/21c/d1c6b721c04575fe71785efe1f2bdbd3.png"></div><br>  Es scheint, dass der Name und die Gr√∂√üe des Klumpens den Daten entsprechen, die mit unserem Code erhalten wurden.  Heute haben wir einen tollen Job gemacht! <br><br><h2>  Sonstige Hinweise </h2><br><ul><li>  Irgendwann dachte ich, es w√§re gut, Vektor zum Speichern von Verzeichnissen zu verwenden.  Warum nicht Map verwenden?  Dies ist schneller als das Abrufen von Daten durch lineare Vektorsuche.  Das ist eine schlechte Idee.  Bei Verwendung von map wird die Reihenfolge der Verzeichniseintr√§ge nicht verfolgt, aber wir ben√∂tigen diese Informationen, um die richtigen Daten zu erhalten. <br><br>  Und noch ein Missverst√§ndnis: Map in C ++ wird als rot-schwarze B√§ume mit O (log N) Suchzeit implementiert, und Iterationen √ºber Map ergeben immer eine zunehmende Reihenfolge der Schl√ºssel.  Wenn Sie eine Datenstruktur ben√∂tigen, die die durchschnittliche Zeit O (1) und die schlechteste Zeit O (N) angibt, m√ºssen Sie eine ungeordnete Karte verwenden. </li><li>  <s>Das Laden aller WAD-Dateien in den Speicher ist keine optimale Implementierungsmethode.</s>  <s>Es w√§re logischer, die Verzeichnisse einfach in den Speicherheader einzulesen und dann zur WAD-Datei zur√ºckzukehren und Ressourcen von der Festplatte zu laden.</s>  <s>Hoffentlich lernen wir eines Tages mehr √ºber das Caching.</s> <br><br>  <strong>DOOMReboot</strong> : <em>stimme √ºberhaupt nicht zu.</em>  <em>15 MB RAM sind heutzutage eine Kleinigkeit, und das Lesen aus dem Speicher ist viel schneller als die umfangreiche Suche, die verwendet werden muss, nachdem alles heruntergeladen wurde, was f√ºr das Level erforderlich ist.</em>  <em>Dies erh√∂ht die Downloadzeit um nicht weniger als ein bis zwei Sekunden (ich brauche weniger als 20 ms, um die ganze Zeit herunterzuladen).</em>  <em>Verwenden Sie das Betriebssystem.</em>  <em>Welche Datei befindet sich am wahrscheinlichsten im RAM-Cache, aber m√∂glicherweise nicht.</em>  <em>Aber selbst wenn er dort ist, ist es eine gro√üe Verschwendung von Ressourcen und diese Operationen werden viele WAD-Messwerte in Bezug auf den CPU-Cache verwirren.</em>  <em>Das Beste ist, dass Sie hybride Startmethoden erstellen und WAD-Daten f√ºr eine Ebene speichern k√∂nnen, die in den L3-Cache moderner Prozessoren passt, wo die Einsparungen erstaunlich sind.</em> </li></ul><br><h2>  Quellcode </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellcode</a> <br><br><h2>  Grundlegende Kartendaten </h2><br>  Nachdem wir gelernt haben, die WAD-Datei zu lesen, versuchen wir, die gelesenen Daten zu verwenden.  Es wird gro√üartig sein zu lernen, wie man Missionsdaten (Welt / Ebene) liest und anwendet.  Die ‚ÄûBrocken‚Äú dieser Missionen (Mission Lumps) sollten komplex und knifflig sein.  Daher m√ºssen wir das Wissen schrittweise bewegen und weiterentwickeln.  Als ersten kleinen Schritt erstellen wir so etwas wie eine Automap-Funktion: einen zweidimensionalen Plan einer Karte mit einer Draufsicht.  Lassen Sie uns zuerst sehen, was sich im Missionsklumpen befindet. <br><br><h2>  Kartenanatomie </h2><br>  Fangen wir noch einmal an: Die Beschreibung der DOOM-Ebenen ist der 2D-Zeichnung sehr √§hnlich, auf der die W√§nde mit Linien markiert sind.  Um 3D-Koordinaten zu erhalten, nimmt jede Wand die H√∂he des Bodens und der Decke an (XY ist die Ebene, entlang der wir uns horizontal bewegen, und Z ist die H√∂he, die es uns erm√∂glicht, uns auf und ab zu bewegen, beispielsweise durch Anheben mit einem Aufzug oder Abspringen von einer Plattform. Diese drei Die Koordinatenkomponenten werden verwendet, um die Mission als 3D-Welt zu rendern. Um jedoch eine gute Leistung zu gew√§hrleisten, weist die Engine bestimmte Einschr√§nkungen auf: Auf Ebenen befinden sich keine √ºbereinander liegenden R√§ume, und der Spieler kann nicht nach oben und unten schauen. Ein weiteres interessantes Merkmal: Muscheln und  Rock, zum Beispiel Raketen, steigen vertikal auf, um ein Ziel zu treffen, das sich auf einer h√∂heren Plattform befindet. <br><br>  Diese merkw√ºrdigen Eigenschaften haben endlose Probleme damit verursacht, ob das DOOM eine 2D- oder eine 3D-Engine ist.  Allm√§hlich wurde ein diplomatischer Kompromiss erzielt, der viele Leben rettete: Die Parteien einigten sich auf die f√ºr beide akzeptable Bezeichnung ‚Äû2.5D‚Äú. <br><br>  Um die Aufgabe zu vereinfachen und zum Thema zur√ºckzukehren, versuchen wir einfach, diese 2D-Daten zu lesen und zu pr√ºfen, ob sie irgendwie verwendet werden k√∂nnen.  Sp√§ter werden wir versuchen, sie in 3D zu rendern, aber jetzt m√ºssen wir verstehen, wie die einzelnen Teile der Engine zusammenarbeiten. <br><br>  Nach Recherchen fand ich heraus, dass jede Mission aus einer Reihe von "Teilen" besteht.  Diese ‚ÄûKlumpen‚Äú werden in der WAD-Datei eines DOOM-Spiels immer in derselben Reihenfolge dargestellt. <br><br><ol><li>  <strong>Scheitelpunkte: Die</strong> Endpunkte von W√§nden in 2D.  Zwei verbundene VERTEXs bilden einen LINEDEF.  Drei verbundene VERTEX bilden zwei W√§nde / LINEDEF und so weiter.  Sie k√∂nnen einfach als Verbindungspunkte von zwei oder mehr W√§nden wahrgenommen werden.  (Ja, die meisten Menschen bevorzugen den Plural ‚ÄûVertices‚Äú, aber John Carmack hat ihn nicht gefallen. Laut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Merriam-Webster</a> gelten beide Optionen. </li><li>  <strong>LINEDEFS:</strong> Linien, die Fugen zwischen Eckpunkten und W√§nden bilden.  Nicht alle Linien (W√§nde) verhalten sich gleich. Es gibt Flags, die das Verhalten solcher Linien angeben. </li><li>  <strong>SIDEDDEFS:</strong> Im wirklichen Leben haben die W√§nde zwei Seiten - wir betrachten eine, die zweite ist auf der anderen Seite.  Die beiden Seiten k√∂nnen unterschiedliche Texturen haben, und SIDEDEFS ist der Klumpen, der die Texturinformationen f√ºr die Wand (LINEDEF) enth√§lt. </li><li>  <strong>SEKTOREN:</strong> Sektoren sind ‚ÄûR√§ume‚Äú, die vom LINEDEF-Join erhalten wurden.  Jeder Sektor enth√§lt Informationen wie Boden- und Deckenh√∂hen, Texturen, Beleuchtungswerte, Sonderaktionen wie das Bewegen von B√∂den / Plattformen / Aufz√ºgen.  Einige dieser Parameter wirken sich auch auf die Art und Weise aus, wie W√§nde gerendert werden, z. B. die Beleuchtungsst√§rke und die Berechnung der Texturabbildungskoordinaten. </li><li>  <strong>SSECTORS:</strong> (Teilsektoren) bilden konvexe Bereiche innerhalb eines Sektors, die beim Rendern in Verbindung mit dem BSP-Bypass verwendet werden, und helfen auch dabei, festzustellen, wo sich ein Spieler auf einer bestimmten Ebene befindet.  Sie sind sehr n√ºtzlich und werden oft verwendet, um die vertikale Position eines Spielers zu bestimmen.  Jeder SSECTOR besteht aus verbundenen Teilen eines Sektors, beispielsweise aus W√§nden, die einen Winkel bilden.  Solche Teile der W√§nde oder "Segmente" werden in einem eigenen Klumpen namens ... </li><li>  <strong>SEGS:</strong> Wandteile / LINEDEF;  Mit anderen Worten, dies sind die ‚ÄûSegmente‚Äú der Wand / LINEDEF.  Die Welt wird umgangen, indem der BSP-Baum umgangen wird, um zu bestimmen, welche W√§nde zuerst gezeichnet werden sollen (die allerersten sind die n√§chsten).  Obwohl das System sehr gut funktioniert, werden Linedefs h√§ufig in zwei oder mehr SEGs aufgeteilt.  Solche SEGs werden dann verwendet, um W√§nde anstelle von LINEDEF zu rendern.  Die Geometrie jedes SSECTOR wird durch die darin enthaltenen Segmente bestimmt. </li><li>  <strong>NODES:</strong> Ein BSP-Knoten ist ein Knoten einer bin√§ren Baumstruktur, in der Teilsektordaten gespeichert sind.  Es wird verwendet, um schnell festzustellen, welche SSECTOR (und SEG) sich vor dem Player befinden.  Durch das Eliminieren von SEGs, die sich hinter dem Player befinden und daher unsichtbar sind, kann sich die Engine auf potenziell sichtbare SEGs konzentrieren, was die Renderzeit erheblich verk√ºrzt. </li><li>  <strong>DINGE:</strong> Klumpen namens DINGE ist eine Liste von Landschafts- und Missionsakteuren (Feinde, Waffen usw.).  Jedes Element dieses Knotens enth√§lt Informationen zu einer Instanz des Akteurs / der Gruppe, z. B. den Objekttyp, den Erstellungspunkt, die Richtung usw. </li><li>  <strong>ABLEHNEN:</strong> Dieser Knoten enth√§lt Daten dar√ºber, welche Sektoren von anderen Sektoren aus sichtbar sind.  Es wird verwendet, um zu bestimmen, wann ein Monster von der Anwesenheit eines Spielers erf√§hrt.  Es wird auch verwendet, um den Verteilungsbereich der vom Player erzeugten Sounds zu bestimmen, z. B. Aufnahmen.  Wenn ein solcher Ton auf den Sektor des Monsters √ºbertragen werden kann, kann er etwas √ºber den Spieler erfahren.  Die REJECT-Tabelle kann auch verwendet werden, um die Erkennung von Kollisionen von Waffenpatronen zu beschleunigen. </li><li>  <strong>BLOCKMAP:</strong> Informationen zur Erkennung von Spielerkollisionen und DING-Bewegung.  Besteht aus einem Raster, das die Geometrie der gesamten Mission abdeckt.  Jede Gitterzelle enth√§lt eine Liste von LINEDEFs, die sich darin befinden oder diese schneiden.  Es wird verwendet, um die Erkennung von Kollisionen erheblich zu beschleunigen: Kollisionspr√ºfungen sind nur f√ºr wenige LINEDEF pro Spieler / THING erforderlich, wodurch Rechenleistung erheblich gespart wird. </li></ol><br>  Bei der Erstellung unserer 2D-Karte konzentrieren wir uns auf VERTEXES und LINEDEFS.  Wenn wir die Eckpunkte zeichnen und mit den durch linedef angegebenen Linien verbinden k√∂nnen, m√ºssen wir ein 2D-Modell der Karte erstellen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f4/dd4/a3b/3f4dd4a3b79fab0d47e7f1212a73df83.png" alt="Demo Karte"></div><br>  Die oben gezeigte Demokarte weist die folgenden Eigenschaften auf: <br><br><ul><li>  4 Spitzen <ul><li>  Scheitelpunkt 1 in (10.10) </li><li>  Top 2 bei (10.100) </li><li>  Top 3 bei (100, 10) </li><li>  Peak 4 in (100.100) </li></ul></li><li>  4 Zeilen <ul><li>  Linie von oben 1 bis 2 </li><li>  Linie von oben 1 bis 3 </li><li>  Linie von oben 2 bis 4 </li><li>  Linie von oben 3 bis 4 </li></ul></li></ul><br><h3>  Scheitelpunktformat </h3><br>  Wie zu erwarten ist, sind die Scheitelpunktdaten sehr einfach - nur x und y (Punkt) einiger Koordinaten. <br><br><div class="scrollable-table"><table><thead><tr><th>  Feldgr√∂√üe </th><th>  Datentyp </th><th>  Inhalt </th></tr></thead><tbody><tr><td>  0x00-0x01 </td><td>  Kurz signiert </td><td>  Position X. </td></tr><tr><td>  0x02-0x03 </td><td>  Kurz signiert </td><td>  Y-Position </td></tr></tbody></table></div><br><h3>  Linedef-Format </h3><br>  Linedef enth√§lt weitere Informationen: Es beschreibt die Linie, die die beiden Eckpunkte verbindet, und die Eigenschaften dieser Linie (die sp√§ter zu einer Wand wird). <br><br><div class="scrollable-table"><table><thead><tr><th>  Feldgr√∂√üe </th><th>  Datentyp </th><th>  Inhalt </th></tr></thead><tbody><tr><td>  0x00-0x01 </td><td>  Kurz ohne Vorzeichen </td><td>  Startspitze </td></tr><tr><td>  0x02-0x03 </td><td>  Kurz ohne Vorzeichen </td><td>  Ultimativer H√∂hepunkt </td></tr><tr><td>  0x04-0x05 </td><td>  Kurz ohne Vorzeichen </td><td>  Flaggen (siehe unten f√ºr weitere Details) </td></tr><tr><td>  0x06-0x07 </td><td>  Kurz ohne Vorzeichen </td><td>  Linientyp / Aktion </td></tr><tr><td>  0x08-0x09 </td><td>  Kurz ohne Vorzeichen </td><td>  Branchenbezeichnung </td></tr><tr><td>  0x10-0x11 </td><td>  Kurz ohne Vorzeichen </td><td>  Front Sidedef (0xFFFF - keine Seite) </td></tr><tr><td>  0x12-0x13 </td><td>  Kurz ohne Vorzeichen </td><td>  Zur√ºck Sidedef (0xFFFF - keine Seite) </td></tr></tbody></table></div><br><h3>  Linedef-Flag-Werte </h3><br>  Nicht alle Linien (W√§nde) werden gezeichnet.  Einige von ihnen haben ein besonderes Verhalten. <br><br><div class="scrollable-table"><table><thead><tr><th>  Bit </th><th>  Beschreibung </th></tr></thead><tbody><tr><td>  0 </td><td>  Blockiert den Weg f√ºr Spieler und Monster </td></tr><tr><td>  1 </td><td>  Blockiere Monster </td></tr><tr><td>  2 </td><td>  Doppelseitig </td></tr><tr><td>  3 </td><td>  Die obere Textur ist deaktiviert (wir werden sp√§ter dar√ºber sprechen) </td></tr><tr><td>  4 </td><td>  Die untere Textur ist deaktiviert (wir werden sp√§ter dar√ºber sprechen) </td></tr><tr><td>  5 </td><td>  Geheimnis (auf der Karte als einseitige Wand dargestellt) </td></tr><tr><td>  6 </td><td>  Behindert den Ton </td></tr><tr><td>  7 </td><td>  Nie auf der Autokarte gezeigt </td></tr><tr><td>  8 </td><td>  Wird immer auf der Autokarte angezeigt </td></tr></tbody></table></div><br><h2>  Ziele </h2><br><ol><li>  Erstellen Sie eine Map-Klasse. </li><li>  Scheitelpunktdaten lesen. </li><li>  Lesen Sie die Linedef-Daten. </li></ol><br><h2>  Architektur </h2><br>  Zuerst erstellen wir eine Klasse und nennen sie Map.  Darin speichern wir alle mit der Karte verkn√ºpften Daten. <br><br>  Im Moment plane ich, nur Scheitelpunkte und Linedefs als Vektor zu speichern, damit ich sie sp√§ter anwenden kann. <br><br>  Erg√§nzen wir auch WADLoader und WADReader, damit wir diese beiden neuen Informationen lesen k√∂nnen. <br><br><h2>  Codierung </h2><br>  Der Code √§hnelt dem WAD-Lesecode. Wir werden nur einige weitere Strukturen hinzuf√ºgen und diese dann mit Daten aus WAD f√ºllen.  Beginnen wir mit dem Hinzuf√ºgen einer neuen Klasse und der √úbergabe des Kartennamens. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Map(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> sName); ~Map(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// Incase someone need to know the map name void AddVertex(Vertex &amp;v); // Wrapper class to append to the vertexes vector void AddLinedef(Linedef &amp;l); // Wrapper class to append to the linedef vector protected: std::string m_sName; std::vector&lt;Vertex&gt; m_Vertexes; std::vector&lt;Linedef&gt; m_Linedef; };</span></span></code> </pre> <br>  F√ºgen Sie nun Strukturen hinzu, um diese neuen Felder zu lesen.  Da wir dies bereits mehrmals getan haben, f√ºgen Sie einfach alle auf einmal hinzu. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vertex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> XPosition; <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> YPosition; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Linedef</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> StartVertex; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> EndVertex; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> Flags; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> LineType; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> SectorTag; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> FrontSidedef; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> BackSidedef; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Als n√§chstes ben√∂tigen wir eine Funktion, um sie aus WADReader zu lesen. Sie wird in etwa dem entsprechen, was wir zuvor getan haben. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WADReader::ReadVertexData(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset, Vertex &amp;vertex) { vertex.XPosition = Read2Bytes(pWADData, offset); vertex.YPosition = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WADReader::ReadLinedefData(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset, Linedef &amp;linedef) { linedef.StartVertex = Read2Bytes(pWADData, offset); linedef.EndVertex = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">2</span></span>); linedef.Flags = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">4</span></span>); linedef.LineType = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">6</span></span>); linedef.SectorTag = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">8</span></span>); linedef.FrontSidedef = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">10</span></span>); linedef.BackSidedef = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">12</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich denke, hier gibt es nichts Neues f√ºr dich. </font><font style="vertical-align: inherit;">Und jetzt m√ºssen wir diese Funktionen aus der WADLoader-Klasse aufrufen. </font><font style="vertical-align: inherit;">Lassen Sie mich die Fakten darlegen: Die Reihenfolge der Klumpen ist hier wichtig. Wir finden den Namen der Karte im Klumpenverzeichnis, gefolgt von allen Klumpen, die den Karten in der angegebenen Reihenfolge zugeordnet sind. </font><font style="vertical-align: inherit;">Um unsere Aufgabe zu vereinfachen und die Klumpenindizes nicht separat zu verfolgen, f√ºgen wir eine Aufz√§hlung hinzu, mit der wir magische Zahlen loswerden k√∂nnen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EMAPLUMPSINDEX { eTHINGS = <span class="hljs-number"><span class="hljs-number">1</span></span>, eLINEDEFS, eSIDEDDEFS, eVERTEXES, eSEAGS, eSSECTORS, eNODES, eSECTORS, eREJECT, eBLOCKMAP, eCOUNT };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich werde auch eine Funktion hinzuf√ºgen, um nach einer Karte anhand ihres Namens in der Verzeichnisliste zu suchen. </font><font style="vertical-align: inherit;">Sp√§ter werden wir wahrscheinlich die Leistung dieses Schritts durch Verwendung der Kartendatenstruktur steigern, da hier eine erhebliche Anzahl von Datens√§tzen vorhanden ist und wir diese h√§ufig durchlaufen m√ºssen, insbesondere zu Beginn des Ladens von Ressourcen wie Texturen, Sprites, Sounds usw.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> WADLoader::FindMapIndex(Map &amp;<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m_WADDirectories.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_WADDirectories[i].LumpName == <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.GetName()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wow, wir sind fast fertig! </font><font style="vertical-align: inherit;">Jetzt z√§hlen wir einfach VERTEXES! </font><font style="vertical-align: inherit;">Ich wiederhole, wir haben das schon einmal gemacht, jetzt m√ºssen Sie das verstehen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WADLoader::ReadMapVertex(Map &amp;<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iMapIndex = FindMapIndex(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iMapIndex == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } iMapIndex += EMAPLUMPSINDEX::eVERTEXES; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(m_WADDirectories[iMapIndex].LumpName, <span class="hljs-string"><span class="hljs-string">"VERTEXES"</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iVertexSizeInBytes = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Vertex); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iVertexesCount = m_WADDirectories[iMapIndex].LumpSize / iVertexSizeInBytes; Vertex vertex; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; iVertexesCount; ++i) { m_Reader.ReadVertexData(m_WADData, m_WADDirectories[iMapIndex].LumpOffset + i * iVertexSizeInBytes, vertex); <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.AddVertex(vertex); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; vertex.XPosition &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; vertex.YPosition &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hmm, es sieht so aus, als w√ºrden wir st√§ndig denselben Code kopieren. </font><font style="vertical-align: inherit;">M√∂glicherweise m√ºssen Sie es in Zukunft optimieren, aber vorerst implementieren Sie ReadMapLinedef selbst (oder sehen Sie sich den Quellcode √ºber den Link an). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Letzte Ber√ºhrungen - wir m√ºssen diese Funktion aufrufen und das Kartenobjekt an sie √ºbergeben.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WADLoader::LoadMapData(Map &amp;<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ReadMapVertex(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error: Failed to load map vertex data MAP: "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.GetName() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ReadMapLinedef(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error: Failed to load map linedef data MAP: "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.GetName() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt √§ndern wir die Hauptfunktion und sehen, ob alles funktioniert. </font><font style="vertical-align: inherit;">Ich m√∂chte die Karte ‚ÄûE1M1‚Äú laden, die ich auf das Kartenobjekt √ºbertragen werde.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">Map </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"E1M1"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; wadloader.LoadMapData(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns jetzt alles laufen. </font><font style="vertical-align: inherit;">Wow, eine Menge interessanter Zahlen, aber sind sie wahr? </font><font style="vertical-align: inherit;">Lass es uns ausprobieren! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mal sehen, ob Slade uns dabei helfen kann. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen die Karte im Slade-Men√º finden und uns die Details der Klumpen ansehen. </font><font style="vertical-align: inherit;">Vergleichen wir die Zahlen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48b/3ec/439/48b3ec43988e25260d45a4abd1999c91.png" alt="Scheitelpunkt"></div><br>  Gro√üartig! <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Was ist mit Linedef? </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/96f/93d/ecd/96f93decd409dad0b8b6836726345a08.png" alt="Linedef"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich habe auch diese Aufz√§hlung hinzugef√ºgt, die wir beim Rendern der Karte verwenden werden. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ELINEDEFFLAGS { eBLOCKING = <span class="hljs-number"><span class="hljs-number">0</span></span>, eBLOCKMONSTERS = <span class="hljs-number"><span class="hljs-number">1</span></span>, eTWOSIDED = <span class="hljs-number"><span class="hljs-number">2</span></span>, eDONTPEGTOP = <span class="hljs-number"><span class="hljs-number">4</span></span>, eDONTPEGBOTTOM = <span class="hljs-number"><span class="hljs-number">8</span></span>, eSECRET = <span class="hljs-number"><span class="hljs-number">16</span></span>, eSOUNDBLOCK = <span class="hljs-number"><span class="hljs-number">32</span></span>, eDONTDRAW = <span class="hljs-number"><span class="hljs-number">64</span></span>, eDRAW = <span class="hljs-number"><span class="hljs-number">128</span></span> };</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sonstige Hinweise </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Schreiben des Codes habe ich f√§lschlicherweise mehr Bytes als n√∂tig gelesen und falsche Werte erhalten. </font><font style="vertical-align: inherit;">Zum Debuggen habe ich angefangen, den WAD-Offset im Speicher zu untersuchen, um festzustellen, ob ich den richtigen Offset hatte. </font><font style="vertical-align: inherit;">Dies kann mithilfe des Visual Studio-Speicherfensters erfolgen, das ein sehr n√ºtzliches Tool zum Verfolgen von Bytes oder Speicher ist (Sie k√∂nnen in diesem Fenster auch Haltepunkte festlegen). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn das Speicherfenster nicht angezeigt wird, gehen Sie zu Debug&gt; Speicher&gt; Speicher.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27d/cba/0d3/27dcba0d33094493822f4444a4c0d8c8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt sehen wir die Werte im Speicher hexadezimal. </font><font style="vertical-align: inherit;">Diese Werte k√∂nnen mit der Hex-Anzeige in Slade verglichen werden, indem Sie mit der rechten Maustaste auf einen Klumpen klicken und ihn als Hex anzeigen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cc/159/757/1cc15975726f8a1204bf674aa0824fc6.png" alt="Slade"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vergleichen Sie sie mit der Adresse des in den Speicher geladenen WAD. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/970/2af/c96/9702afc96be99794e7d9f01e4d6d89bb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und das Letzte f√ºr heute: Wir haben all diese Scheitelpunktwerte gesehen, aber gibt es eine einfache M√∂glichkeit, sie zu visualisieren, ohne Code zu schreiben? </font><font style="vertical-align: inherit;">Ich m√∂chte keine Zeit damit verschwenden, nur um herauszufinden, dass wir uns in die falsche Richtung bewegen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sicherlich hat schon jemand einen Plotter erstellt. </font><font style="vertical-align: inherit;">Ich googelte ‚ÄûPunkte in einem Diagramm zeichnen‚Äú und das erste Ergebnis war die Website ‚Äû </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plot Points‚Äú - Desmos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Darauf k√∂nnen Sie Zahlen aus der Zwischenablage einf√ºgen, und er wird sie zeichnen. </font><font style="vertical-align: inherit;">Sie m√ºssen das Format "(x, y)" haben. </font><font style="vertical-align: inherit;">Um es zu bekommen, √§ndern Sie einfach die Ausgabefunktion auf dem Bildschirm.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"("</span></span> &lt;&lt; vertex.XPosition &lt;&lt; <span class="hljs-string"><span class="hljs-string">","</span></span> &lt;&lt; vertex.YPosition &lt;&lt; <span class="hljs-string"><span class="hljs-string">")"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wow! </font><font style="vertical-align: inherit;">Es sieht schon aus wie ein E1M1! </font><font style="vertical-align: inherit;">Wir haben etwas erreicht!</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/499/ce6/36b/499ce636b2dbd6bd3e158bff07304b37.png" alt="E1M1 Plotpunkte"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie dazu faul sind, finden Sie hier einen Link zu einem gepunkteten Diagramm: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plot Vertex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber machen wir noch einen Schritt: Nach ein wenig Arbeit k√∂nnen wir diese Punkte basierend auf Linedefs verbinden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/423/35b/c2f42335b751d3bd9acec03251204977.png" alt="E1M1 Plot Vertex"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist der Link: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E1M1 Plot Vertex</font></font></a> <br><br><h2>  Quellcode </h2><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quellcode</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Referenzen </font></font></h2><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom Wiki </font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZDoom Wiki</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471552/">https://habr.com/ru/post/de471552/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471538/index.html">Von der Idee einer mobilen Anwendung bis zum MVP, in das Investoren investieren werden</a></li>
<li><a href="../de471542/index.html">OCR-Texterkennung</a></li>
<li><a href="../de471544/index.html">√úber die Liebe oder warum hat der Kosaken-Zenturio seine Uniform in ein usbekisches Gewand verwandelt</a></li>
<li><a href="../de471548/index.html">Top 5 B√ºcher von einem K√ºnstler zu lesen</a></li>
<li><a href="../de471550/index.html">Wo kann man Audio f√ºr die Spieleentwicklung und andere kommerzielle Projekte bekommen? Bibliotheken mit den Kl√§ngen der Natur</a></li>
<li><a href="../de471554/index.html">Wie kann das Risiko von Steueranspr√ºchen aus dem Verkauf von Anwendungen und Inhalten verringert werden?</a></li>
<li><a href="../de471556/index.html">Fujitsu World Tour 2019. Wie war unsere gr√∂√üte Konferenz?</a></li>
<li><a href="../de471558/index.html">Mama, ich bin im Fernsehen: Wie war das Finale des Digital Breakthrough-Wettbewerbs?</a></li>
<li><a href="../de471562/index.html">Superinfektion 2: Rubikon der Probleme, das Fiasko der Technologie und eine neue Hoffnung</a></li>
<li><a href="../de471564/index.html">Freunde RaspberryPi mit TP-Link TL-WN727N</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>