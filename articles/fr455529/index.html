<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìñ üç≠ ü¶ñ Inverser et pirater le disque dur externe √† chiffrement automatique d'Aigo. Partie 2: Dump avec Cypress PSoC üêû üö´ üíáüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il s'agit de la deuxi√®me et derni√®re partie de l'article sur le piratage de disques externes √† chiffrement automatique. Je vous rappelle qu‚Äôun coll√®gu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Inverser et pirater le disque dur externe √† chiffrement automatique d'Aigo. Partie 2: Dump avec Cypress PSoC</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455529/"><p>  Il s'agit de la deuxi√®me et derni√®re partie de l'article sur le piratage de disques externes √† chiffrement automatique.  Je vous rappelle qu‚Äôun coll√®gue m‚Äôa r√©cemment apport√© un disque dur Patriot (Aigo) SK8671, et j‚Äôai d√©cid√© de l‚Äôinverser, et maintenant je partage ce qui en est sorti.  Avant de continuer √† lire, assurez-vous de lire la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premi√®re partie de l'</a> article. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4. Nous commen√ßons √† supprimer le vidage du lecteur flash interne PSoC</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">5. Protocole ISSP</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">- 5.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Qu'est-ce qu'un ISSP?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">- 5.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©mystification des vecteurs</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">- 5.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chat avec PSoC</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">- 5.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Identification des registres intra-puce</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">- 5.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Embouts de protection</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6. Premi√®re attaque (√©chou√©e): ROMX</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">7. Deuxi√®me attaque: trace avec r√©initialisation √† froid</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">- 7.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Impl√©mentation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">- 7.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lire le r√©sultat</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">- 7.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Reconstruction du binaire flash</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">- 7.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Trouver l'adresse de stockage du code PIN</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">- 7.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nous supprimons le d√©potoir du bloc n ¬∞ 126</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">- 7.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">R√©cup√©ration de code PIN</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">8. Et ensuite?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">9. Conclusion</a> </p><br><p><img src="https://habrastorage.org/webt/wx/nm/gk/wxnmgkeurrmiurx87rujoynxrsq.jpeg"></p><a name="habracut"></a><br><a name="a4"></a><br><h1 id="4-nachinaem-snimat-damp-s-vnutrenney-fleshki-psoc">  4. Nous commen√ßons √† supprimer le vidage du lecteur flash interne PSoC </h1><br><p>  Donc, tout indique (comme nous l'avons √©tabli dans [la premi√®re partie] ()) que le code PIN est stock√© dans les entrailles flash PSoC.  Par cons√©quent, nous devons lire ces entrailles flash.  Devant des travaux n√©cessaires: </p><br><ul><li>  prendre le contr√¥le de la "communication" avec le microcontr√¥leur; </li><li>  trouver un moyen de v√©rifier si cette "communication" est prot√©g√©e de la lecture de l'ext√©rieur; </li><li>  trouver un moyen de contourner la s√©curit√©. </li></ul><br><p>  Il y a deux endroits o√π il est logique de rechercher un code PIN valide: </p><br><ul><li>  m√©moire flash interne; </li><li>  SRAM, o√π le code PIN peut √™tre stock√© pour le comparer avec le code PIN que l'utilisateur entre. </li></ul><br><p>  Pour l'avenir, je note que j'ai quand m√™me r√©ussi √† supprimer le vidage du lecteur flash interne PSoC, en contournant son syst√®me de protection, en utilisant l'attaque mat√©rielle "trace de r√©initialisation √† froid" apr√®s avoir invers√© les fonctionnalit√©s non document√©es du protocole ISSP.  Cela m'a permis de vider directement le code PIN actuel. </p><br><pre><code class="plaintext hljs">$ ./psoc.py syncing: KO OK [...] PIN: 1 2 3 4 5 6 7 8 9</code> </pre> <br><p>  Le code de programme r√©sultant: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code Arduino pour HSSP</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pilote Python et d√©sassembleur ISSP</a> . </li></ul><br><a name="a5"></a><br><h1 id="5-issp-protokol">  5. Protocole ISSP </h1><br><a name="a51"></a><br><h2 id="51-chto-takoe-issp">  5.1.  Qu'est-ce qu'un ISSP? </h2><br><p>  La ¬´communication¬ª avec le microcontr√¥leur peut signifier diff√©rentes choses: de ¬´fournisseur √† fournisseur¬ª, √† l'interaction √† l'aide d'un protocole s√©rie (par exemple, ICSP pour PIC de Microchip). </p><br><p>  Cypress a son propre protocole propri√©taire pour cela, appel√© ISSP (protocole de programmation s√©rie dans le syst√®me), qui est partiellement d√©crit dans les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sp√©cifications techniques</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">US7185162</a> fournit √©galement des informations.  Il existe √©galement un analogue OpenSource appel√© HSSP (nous l'utiliserons un peu plus tard).  L'ISSP fonctionne comme suit: </p><br><ul><li>  red√©marrer PSoC; </li><li>  apporter le nombre magique √† la jambe de donn√©es s√©rie de ce PSoC;  pour entrer en mode de programmation externe; </li><li>  envoyer des commandes qui sont de longues cha√Ænes de bits appel√©es ¬´vecteurs¬ª. </li></ul><br><p>  Dans la documentation ISSP, ces vecteurs sont d√©finis uniquement pour une petite poign√©e de commandes: </p><br><ul><li>  Initialialize-1 </li><li>  Initialize-2 </li><li>  Initialize-3 (options 3V et 5V) </li><li>  ID-SETUP </li><li>  LIRE-ID-MOT </li><li>  SET-BLOCK-NUM: 10011111010dddddddd111, o√π dddddddd = bloc # </li><li>  EFFACEMENT EN VRAC </li><li>  PROGRAMME-BLOC </li><li>  VERIFY-SETUP </li><li>  LECTURE: 10110aaaaaaZDDDDDDDDDZ1, o√π DDDDDDDDD = sortie de donn√©es, aaaaaa = adresse (6 bits) </li><li>  WRITE-BYTE: 10010aaaaaadddddddd111, o√π dddddddd = donn√©es en entr√©e, aaaaaa = adresse (6 bits) </li><li>  S√©curis√© </li><li>  CHECKSUM-SETUP </li><li>  READ-CHECKSUM: 10111111001ZDDDDDDDDDZ110111111000ZDDDDDDDDZ1, o√π DDDDDDDDDDDDDDDDD = donn√©es sortantes: somme de contr√¥le de l'appareil </li><li>  EFFACER LE BLOC </li></ul><br><p>  Par exemple, le vecteur pour Initialize-2: </p><br><pre> <code class="plaintext hljs">1101111011100000000111 1101111011000000000111 1001111100000111010111 1001111100100000011111 1101111010100000000111 1101111010000000011111 1001111101110000000111 1101111100100110000111 1101111101001000000111 1001111101000000001111 1101111000000000110111 1101111100000000000111 1101111111100010010111</code> </pre> <br><p>  Tous les vecteurs ont la m√™me longueur: 22 bits.  La documentation HSSP contient des informations suppl√©mentaires sur les ISSP: ¬´Un vecteur ISSP n'est rien de plus qu'une s√©quence de bits repr√©sentant un ensemble d'instructions.¬ª </p><br><a name="a52"></a><br><h2 id="52-demistifikaciya-vektorov">  5.2.  D√©mystification des vecteurs </h2><br><p>  Voyons ce qui se passe ici.  Initialement, j'ai suppos√© que ces m√™mes vecteurs sont des variantes brutes des instructions M8C, cependant, apr√®s avoir test√© cette hypoth√®se, j'ai trouv√© que les opcodes des op√©rations ne correspondent pas. </p><br><p>  Ensuite, j'ai googl√© le vecteur ci-dessus et suis tomb√© sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette</a> √©tude, o√π l'auteur, sans entrer dans les d√©tails, donne quelques indices pratiques: ¬´Chaque instruction commence par trois bits qui correspondent √† l'une des quatre mn√©moniques (lire √† partir de RAM, √©crire √† RAM , lire le registre, √©crire le registre).  Vient ensuite l'adresse 8 bits, suivie de 8 bits de donn√©es (lus ou √©crits) et enfin trois bits d'arr√™t. ¬ª </p><br><p>  J'ai ensuite pu recueillir des informations tr√®s utiles dans la section ROM de supervision (SROM) du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">manuel technique</a> .  SROM est une ROM cod√©e en dur dans PSoC qui fournit des fonctions de service (similaires √† Syscall) pour le code logiciel ex√©cut√© dans l'espace utilisateur: </p><br><ul><li>  00h: SWBootReset </li><li>  01h: ReadBlock </li><li>  02h: WriteBlock </li><li>  03h: EraseBlock </li><li>  06h: TableRead </li><li>  07h: CheckSum </li><li>  08h: Calibrate0 </li><li>  09h: Calibrate1 </li></ul><br><p>  En comparant les noms de vecteur avec les fonctions SROM, nous pouvons mapper les diff√©rentes op√©rations prises en charge par ce protocole aux param√®tres SROM attendus.  Gr√¢ce √† cela, nous pouvons d√©coder les trois premiers bits des vecteurs ISSP: </p><br><ul><li>  100 =&gt; ¬´wrmem¬ª </li><li>  101 =&gt; ¬´rdmem¬ª </li><li>  110 =&gt; ¬´wrreg¬ª </li><li>  111 =&gt; ¬´rdreg¬ª </li></ul><br><p>  Cependant, une compr√©hension compl√®te des processus intra-puce ne peut √™tre obtenue que par une communication directe avec PSoC. </p><br><a name="a53"></a><br><h2 id="53-obschenie-s-psoc">  5.3.  Chat avec PSoC </h2><br><p>  Puisque Dirk Petrautsky a d√©j√† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">port√© le</a> code Cypress HSSP sur Arduino, j'ai utilis√© Arduino Uno pour connecter la carte clavier au connecteur ISSP. </p><br><p>  Veuillez noter que lors de mes recherches, j'ai pratiquement chang√© le code Dirk.  Vous pouvez retrouver ma modification sur GitHub: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voici le</a> script Python correspondant pour communiquer avec Arduino, dans mon r√©f√©rentiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cypress_psoc_tools</a> . </p><br><p>  Donc, en utilisant Arduino, au d√©but, je n'utilisais que des vecteurs ¬´officiels¬ª pour la ¬´communication¬ª.  J'ai essay√© de lire la ROM interne en utilisant la commande VERIFY.  Comme pr√©vu, je n'ai pas pu faire √ßa.  Probablement d√ª au fait que les bits de protection en lecture sont activ√©s √† l'int√©rieur du lecteur flash. </p><br><p>  Ensuite, j'ai cr√©√© certains de mes vecteurs simples pour √©crire et lire la m√©moire / les registres.  Veuillez noter que nous pouvons lire l'int√©gralit√© du SROM, m√™me si le lecteur flash est prot√©g√©! </p><br><a name="a54"></a><br><h2 id="54-identifikaciya-vnutrichipovyh-registrov">  5.4.  Identification des registres intra-puce </h2><br><p>  En regardant les vecteurs "d√©sassembl√©s", j'ai trouv√© que l'appareil utilise des registres non document√©s (0xF8-0xFA) pour indiquer les opcodes M8C qui sont ex√©cut√©s directement, en contournant la protection.  Cela m'a permis d'ex√©cuter divers opcodes tels que ¬´ADD¬ª, ¬´MOV A, X¬ª, ¬´PUSH¬ª ou ¬´JMP¬ª.  Gr√¢ce √† eux (en regardant les effets secondaires qu'ils ont sur les registres), j'ai pu d√©terminer lesquels des registres non document√©s sont en fait des registres r√©guliers (A, X, SP et PC). </p><br><p>  En cons√©quence, le code ¬´d√©sassembl√©¬ª g√©n√©r√© par l'outil HSSP_disas.rb ressemble √† ceci (j'ai ajout√© des commentaires pour plus de clart√©): </p><br><pre> <code class="plaintext hljs">--== init2 ==-- [DE E0 1C] wrreg CPU_F (f7), 0x00 #   [DE C0 1C] wrreg SP (f6), 0x00 #  SP [9F 07 5C] wrmem KEY1, 0x3A #    SSC [9F 20 7C] wrmem KEY2, 0x03 #  [DE A0 1C] wrreg PCh (f5), 0x00 #  PC (MSB) ... [DE 80 7C] wrreg PCl (f4), 0x03 # (LSB) ...  3 ?? [9F 70 1C] wrmem POINTER, 0x80 # RAM-    [DF 26 1C] wrreg opc1 (f9), 0x30 #  1 =&gt; "HALT" [DF 48 1C] wrreg opc2 (fa), 0x40 #  2 =&gt; "NOP" [9F 40 3C] wrmem BLOCKID, 0x01 # BLOCK ID   SSC [DE 00 DC] wrreg A (f0), 0x06 #  "Syscall" : TableRead [DF 00 1C] wrreg opc0 (f8), 0x00 #   SSC, "Supervisory SROM Call" [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12 #  :   </code> </pre> <br><a name="a55"></a><br><h2 id="55-zaschitnye-bity">  5.5.  Embouts de protection </h2><br><p>  √Ä ce stade, je peux d√©j√† communiquer avec PSoC, mais je n'ai toujours pas d'informations fiables sur les bits de protection du lecteur flash.  J'ai √©t√© tr√®s surpris par le fait que Cypress ne donne √† l'utilisateur de l'appareil aucun moyen de v√©rifier si la protection est activ√©e.  Je suis all√© profond√©ment dans Google pour finalement comprendre que le code HSSP fourni par Cypress a √©t√© mis √† jour apr√®s que Dirk ait publi√© sa modification.  Et voil√†!  Voici un nouveau vecteur comme celui-ci: </p><br><pre> <code class="plaintext hljs">[DE E0 1C] wrreg CPU_F (f7), 0x00 [DE C0 1C] wrreg SP (f6), 0x00 [9F 07 5C] wrmem KEY1, 0x3A [9F 20 7C] wrmem KEY2, 0x03 [9F A0 1C] wrmem 0xFD, 0x00 #   [9F E0 1C] wrmem 0xFF, 0x00 #  [DE A0 1C] wrreg PCh (f5), 0x00 [DE 80 7C] wrreg PCl (f4), 0x03 [9F 70 1C] wrmem POINTER, 0x80 [DF 26 1C] wrreg opc1 (f9), 0x30 [DF 48 1C] wrreg opc2 (fa), 0x40 [DE 02 1C] wrreg A (f0), 0x10 #  syscall ! [DF 00 1C] wrreg opc0 (f8), 0x00 [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12</code> </pre> <br><p>  En utilisant ce vecteur (voir read_security_data dans psoc.py), nous obtenons tous les bits de protection dans SRAM √† 0x80, o√π chaque bit est prot√©g√© avec deux bits. </p><br><p>  Le r√©sultat est d√©primant: tout est prot√©g√© en mode "d√©sactiver la lecture et l'√©criture externes".  Par cons√©quent, nous pouvons non seulement lire quoi que ce soit √† partir du lecteur flash USB, mais aussi l'√©crire (par exemple, pour y introduire un dumper ROM).  Et la seule fa√ßon de d√©sactiver la protection est d'effacer compl√®tement la puce enti√®re.  :-( </p><br><a name="a6"></a><br><h1 id="6-pervaya-neudavshayasya-ataka-romx">  6. Premi√®re attaque (√©chou√©e): ROMX </h1><br><p>  Cependant, nous pouvons essayer l'astuce suivante: puisque nous avons la possibilit√© d'ex√©cuter des opcodes arbitraires, pourquoi ne pas ex√©cuter ROMX, qui est utilis√© pour lire la m√©moire flash?  Cette approche a de bonnes chances de succ√®s.  Parce que la fonction ReadBlock, qui lit les donn√©es de SROM (qui est utilis√© par les vecteurs), v√©rifie si elle est appel√©e depuis ISSP.  Cependant, l'opcode ROMX peut ne pas avoir une telle v√©rification.  Voici donc le code Python (apr√®s avoir ajout√© quelques classes d'assistance au code Arduino C): </p><br><pre> <code class="plaintext hljs">for i in range(0, 8192): write_reg(0xF0, i&gt;&gt;8) # A = 0 write_reg(0xF3, i&amp;0xFF) # X = 0 exec_opcodes("\x28\x30\x40") # ROMX, HALT, NOP byte = read_reg(0xF0) # ROMX reads ROM[A|X] into A print "%02x" % ord(byte[0]) # print ROM byte</code> </pre> <br><p>  Malheureusement, ce code ne fonctionne pas.  :-( Au contraire, cela fonctionne, mais en sortie, nous obtenons nos propres opcodes (0x28 0x30 0x40)! Je ne pense pas que la fonctionnalit√© correspondante de l'appareil soit un √©l√©ment de protection en lecture. Cela ressemble plus √† une astuce d'ing√©nierie: lors de l'ex√©cution d'opcodes externes, le bus ROM est redirig√© dans un tampon temporaire. </p><br><a name="a7"></a><br><h1 id="7-vtoraya-ataka-trassirovka-s-holodnoy-perezagruzkoy">  7. Deuxi√®me attaque: trace avec r√©initialisation √† froid </h1><br><p>  √âtant donn√© que l'astuce ROMX n'a ‚Äã‚Äãpas fonctionn√©, j'ai commenc√© √† penser √† une autre variante de cette astuce - d√©crite dans la publication <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´√âclairer trop de lumi√®re sur la protection du microprogramme d'un microcontr√¥leur¬ª</a> . </p><br><a name="a71"></a><br><h2 id="71-realizaciya">  7.1.  Impl√©mentation </h2><br><p>  Le vecteur suivant pour CHECKSUM-SETUP est r√©pertori√© dans la documentation ISSP: </p><br><pre> <code class="plaintext hljs">[DE E0 1C] wrreg CPU_F (f7), 0x00 [DE C0 1C] wrreg SP (f6), 0x00 [9F 07 5C] wrmem KEY1, 0x3A [9F 20 7C] wrmem KEY2, 0x03 [DE A0 1C] wrreg PCh (f5), 0x00 [DE 80 7C] wrreg PCl (f4), 0x03 [9F 70 1C] wrmem POINTER, 0x80 [DF 26 1C] wrreg opc1 (f9), 0x30 [DF 48 1C] wrreg opc2 (fa), 0x40 [9F 40 1C] wrmem BLOCKID, 0x00 [DE 00 FC] wrreg A (f0), 0x07 [DF 00 1C] wrreg opc0 (f8), 0x00 [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12</code> </pre> <br><p>  Ici, en substance, la fonction SROM 0x07 est appel√©e, comme pr√©sent√© dans la documentation (la mienne en italique): </p><br><blockquote>  Cette fonction checksum checksum.  Il calcule une somme de contr√¥le de 16 bits du nombre de blocs d√©fini par l'utilisateur dans une banque flash, en comptant √† partir de z√©ro.  Le param√®tre BLOCKID est utilis√© pour transf√©rer le nombre de blocs qui seront utilis√©s lors du calcul de la somme de contr√¥le.  Une valeur de ¬´1¬ª calculera la somme de contr√¥le pour le bloc z√©ro uniquement;  tandis que <em>"0" conduira au fait que la somme de contr√¥le totale des 256 blocs de la banque flash sera calcul√©e.</em>  <em>Une somme de contr√¥le de 16 bits est renvoy√©e via KEY1 et KEY2.</em>  Dans le param√®tre KEY1, les 8 bits bas de la somme de contr√¥le sont fixes et dans KEY2, les 8 bits hauts sont enregistr√©s.  Pour les appareils avec plusieurs banques de flash, la fonction de somme de contr√¥le est appel√©e pour chacun individuellement.  Le num√©ro de banque avec lequel il fonctionnera est fix√© par le registre FLS_PR1 (en y ins√©rant un bit correspondant √† la banque flash cible). </blockquote><p>  Notez que c'est la somme de contr√¥le la plus simple: les octets sont simplement additionn√©s un par un;  pas de bizarreries CRC sophistiqu√©es.  De plus, sachant que l'ensemble des registres dans le noyau M8C est tr√®s petit, j'ai suppos√© que lors du calcul de la somme de contr√¥le, les valeurs interm√©diaires seront fix√©es dans les m√™mes variables qui seront √©ventuellement sorties: KEY1 (0xF8) / KEY2 (0xF9). </p><br><p>  Donc, en th√©orie, mon attaque ressemble √† ceci: </p><br><ol><li>  Connectez-vous via ISSP. </li><li>  Nous commen√ßons le calcul de la somme de contr√¥le en utilisant le vecteur CHECKSUM-SETUP. </li><li>  Nous red√©marrons le processeur apr√®s le temps sp√©cifi√© T. </li><li>  Lisez la RAM pour obtenir la somme de contr√¥le actuelle C. </li><li>  R√©p√©tez les √©tapes 3 et 4, en augmentant chaque fois T. </li><li>  Nous r√©cup√©rons les donn√©es du lecteur flash en soustrayant la somme de contr√¥le C pr√©c√©dente de celle actuelle. </li></ol><br><p>  Cependant, un probl√®me est survenu: le vecteur Initialize-1, que nous devons envoyer apr√®s le red√©marrage, √©crase KEY1 et KEY2: </p><br><pre> <code class="plaintext hljs">1100101000000000000000 # ,  PSoC    nop nop nop nop nop [DE E0 1C] wrreg CPU_F (f7), 0x00 [DE C0 1C] wrreg SP (f6), 0x00 [9F 07 5C] wrmem KEY1, 0x3A #     [9F 20 7C] wrmem KEY2, 0x03 #   [DE A0 1C] wrreg PCh (f5), 0x00 [DE 80 7C] wrreg PCl (f4), 0x03 [9F 70 1C] wrmem POINTER, 0x80 [DF 26 1C] wrreg opc1 (f9), 0x30 [DF 48 1C] wrreg opc2 (fa), 0x40 [DE 01 3C] wrreg A (f0), 0x09 # SROM- 9 [DF 00 1C] wrreg opc0 (f8), 0x00 # SSC [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12</code> </pre> <br><p>  Ce code √©crase notre pr√©cieuse somme de contr√¥le en appelant Calibrate1 (fonction SROM 9) ... Peut-√™tre que nous pouvons simplement entrer dans le mode de programmation en envoyant le num√©ro magique (depuis le d√©but du code ci-dessus) puis lire SRAM?  Et oui, √ßa marche!  Le code Arduino impl√©mentant cette attaque est assez simple: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Cmnd_STK_START_CSUM: checksum_delay = ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)getch())&lt;&lt;<span class="hljs-number"><span class="hljs-number">24</span></span>; checksum_delay |= ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)getch())&lt;&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>; checksum_delay |= ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)getch())&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; checksum_delay |= getch(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(checksum_delay &gt; <span class="hljs-number"><span class="hljs-number">10000</span></span>) { ms_delay = checksum_delay/<span class="hljs-number"><span class="hljs-number">1000</span></span>; checksum_delay = checksum_delay%<span class="hljs-number"><span class="hljs-number">1000</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ms_delay = <span class="hljs-number"><span class="hljs-number">0</span></span>; } send_checksum_v(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(checksum_delay) delayMicroseconds(checksum_delay); delay(ms_delay); start_pmode();</code> </pre> <br><ol><li>  Lisez checkum_delay. </li><li>  Ex√©cutez le calcul de la somme de contr√¥le (send_checksum_v). </li><li>  Attendez une p√©riode de temps donn√©e;  √©tant donn√© les pi√®ges suivants: <br><ul><li>  J'ai tu√© beaucoup de temps jusqu'√† ce que je d√©couvre que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">delayMicroseconds s'est</a> av√©r√© fonctionner correctement uniquement avec des retards ne d√©passant pas 16383mks; </li><li>  et puis encore tu√© le m√™me laps de temps jusqu'√† ce qu'il trouve que delayMicroseconds, s'il passait 0 √† son entr√©e, fonctionnait compl√®tement mal! </li></ul></li><li>  Rechargez PSoC en mode de programmation (envoyez simplement le nombre magique, sans envoyer de vecteurs d'initialisation). </li></ol><br><p>  Le code Python r√©sultant: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> delay <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">150000</span></span>): <span class="hljs-comment"><span class="hljs-comment">#    for i in range(0, 10): #      try: reset_psoc(quiet=True) #       send_vectors() #    ser.write("\x85"+struct.pack("&gt;I", delay)) #    +    res = ser.read(1) #  arduino ACK except Exception as e: print e ser.close() os.system("timeout -s KILL 1s picocom -b 115200 /dev/ttyACM0 2&gt;&amp;1 &gt; /dev/null") ser = serial.Serial('/dev/ttyACM0', 115200, timeout=0.5) #    continue print "%05d %02X %02X %02X" % (delay, #  RAM- read_regb(0xf1), read_ramb(0xf8), read_ramb(0xf9))</span></span></code> </pre> <br><p>  En un mot, ce que fait ce code: </p><br><ol><li>  Recharge le PSoC (et lui envoie un nombre magique). </li><li>  Envoie des vecteurs d'initialisation complets. </li><li>  Appelle la fonction Arduino Cmnd_STK_START_CSUM (0x85), o√π le retard en microsecondes est pass√© en param√®tre. </li><li>  Lit la somme de contr√¥le (0xF8 et 0xF9) et le registre non document√© 0xF1. </li></ol><br><p>  Ce code est ex√©cut√© 10 fois en 1 microseconde.  0xF1 est inclus ici car c'est le seul registre qui a chang√© lors du calcul de la somme de contr√¥le.  Il s'agit peut-√™tre d'une sorte de variable temporaire utilis√©e par le dispositif de logique arithm√©tique.  Faites attention au hack laid que je red√©marre Arduino en utilisant picocom lorsque l'Arduino cesse de donner des signes de vie (je ne sais pas pourquoi). </p><br><a name="a72"></a><br><h2 id="72-schityvaem-rezultat">  7.2.  Lire le r√©sultat </h2><br><p>  Le r√©sultat du script Python ressemble √† ceci (simplifi√© pour la lisibilit√©): </p><br><pre> <code class="plaintext hljs">DELAY F1 F8 F9 # F1 ‚Äì    # F8     # F9     00000 03 E1 19 [...] 00016 F9 00 03 00016 F9 00 00 00016 F9 00 03 00016 F9 00 03 00016 F9 00 03 00016 F9 00 00 #     0 00017 FB 00 00 [...] 00023 F8 00 00 00024 80 80 00 # 1- : 0x0080-0x0000 = 0x80 00024 80 80 00 00024 80 80 00 [...] 00057 CC E7 00 # 2- : 0xE7-0x80: 0x67 00057 CC E7 00 00057 01 17 01 #   ,    00057 01 17 01 00057 01 17 01 00058 D0 17 01 00058 D0 17 01 00058 D0 17 01 00058 D0 17 01 00058 F8 E7 00 #  E7? 00058 D0 17 01 [...] 00059 E7 E7 00 00060 17 17 00 #  [...] 00062 00 17 00 00062 00 17 00 00063 01 17 01 # , !        00063 01 17 01 [...] 00075 CC 17 01 # , 0x117-0xE7: 0x30</code> </pre> <br><p>  Dans le m√™me temps, nous avons un probl√®me: puisque nous op√©rons sur la somme de contr√¥le r√©elle, un octet z√©ro ne change pas la valeur lue.  Cependant, comme toute la proc√©dure de calcul (8192 octets) prend 0,1478 seconde (avec de l√©g√®res d√©viations √† chaque d√©marrage), ce qui correspond √† peu pr√®s √† 18,04 Œºs par octet, nous pouvons utiliser ce temps pour v√©rifier la valeur de la somme de contr√¥le √† des moments appropri√©s.  Pour les premi√®res ex√©cutions, tout est lu assez facilement, car la dur√©e de la proc√©dure de calcul est toujours presque la m√™me.  Cependant, la fin de ce vidage est moins pr√©cise, car les ¬´√©carts de temps insignifiants¬ª √† chaque passage se r√©sument et deviennent significatifs: </p><br><pre> <code class="plaintext hljs">134023 D0 02 DD 134023 CC D2 DC 134023 CC D2 DC 134023 CC D2 DC 134023 FB D2 DC 134023 3F D2 DC 134023 CC D2 DC 134024 02 02 DC 134024 CC D2 DC 134024 F9 02 DC 134024 03 02 DD 134024 21 02 DD 134024 02 D2 DC 134024 02 02 DC 134024 02 02 DC 134024 F8 D2 DC 134024 F8 D2 DC 134025 CC D2 DC 134025 EF D2 DC 134025 21 02 DD 134025 F8 D2 DC 134025 21 02 DD 134025 CC D2 DC 134025 04 D2 DC 134025 FB D2 DC 134025 CC D2 DC 134025 FB 02 DD 134026 03 02 DD 134026 21 02 DD</code> </pre> <br><p>  Ce sont 10 d√©charges pour chaque retard de microsecondes.  La dur√©e totale de fonctionnement pour le vidage de tous les 8192 octets d'un lecteur flash est d'environ 48 heures. </p><br><a name="a73"></a><br><h2 id="73-rekonstrukciya-flesh-binarnika">  7.3.  Reconstruction du binaire flash </h2><br><p>  Je n'ai pas encore fini d'√©crire un code qui reconstruit compl√®tement le code programme du lecteur flash, en tenant compte de tous les √©carts dans le temps.  Cependant, j'ai d√©j√† restaur√© le d√©but de ce code.  Pour m'assurer que je l'ai fait correctement, je l'ai d√©mont√© √† l'aide de m8cdis: </p><br><pre> <code class="plaintext hljs">0000: 80 67 jmp 0068h ; Reset vector [...] 0068: 71 10 or F,010h 006a: 62 e3 87 mov reg[VLT_CR],087h 006d: 70 ef and F,0efh 006f: 41 fe fb and reg[CPU_SCR1],0fbh 0072: 50 80 mov A,080h 0074: 4e swap A,SP 0075: 55 fa 01 mov [0fah],001h 0078: 4f mov X,SP 0079: 5b mov A,X 007a: 01 03 add A,003h 007c: 53 f9 mov [0f9h],A 007e: 55 f8 3a mov [0f8h],03ah 0081: 50 06 mov A,006h 0083: 00 ssc [...] 0122: 18 pop A 0123: 71 10 or F,010h 0125: 43 e3 10 or reg[VLT_CR],010h 0128: 70 00 and F,000h ; Paging mode changed from 3 to 0 012a: ef 62 jacc 008dh 012c: e0 00 jacc 012dh 012e: 71 10 or F,010h 0130: 62 e0 02 mov reg[OSC_CR0],002h 0133: 70 ef and F,0efh 0135: 62 e2 00 mov reg[INT_VC],000h 0138: 7c 19 30 lcall 1930h 013b: 8f ff jmp 013bh 013d: 50 08 mov A,008h 013f: 7f ret</code> </pre> <br><p>  Semble tout √† fait cr√©dible! </p><br><a name="a74"></a><br><h2 id="74-nahodim-adres-hraneniya-pinkoda">  7.4.  Trouver l'adresse de stockage du code PIN </h2><br><p>  Maintenant que nous pouvons lire la somme de contr√¥le au moment o√π nous en avons besoin, nous pouvons facilement v√©rifier comment et o√π elle change lorsque nous: </p><br><ul><li>  entrez le mauvais code PIN; </li><li>  changer le code PIN. </li></ul><br><p>  Tout d'abord, pour trouver l'adresse de stockage approximative, j'ai effectu√© un vidage de la somme de contr√¥le par incr√©ments de 10 ms apr√®s un red√©marrage.  Ensuite, j'ai entr√© le mauvais code PIN et j'ai fait de m√™me. </p><br><p>  Le r√©sultat n'√©tait pas tr√®s agr√©able, car il y avait beaucoup de changements.  Mais √† la fin, j'ai pu √©tablir que la somme de contr√¥le a chang√© quelque part dans l'intervalle entre 120 000 Œºs et 140 000 Œºs de retard.  Mais le ¬´code PIN¬ª que j'ai obtenu √©tait compl√®tement faux - en raison de l'artefact de la proc√©dure delayMicroseconds, qui fait des choses √©tranges quand il obtient 0. </p><br><p>  Puis, apr√®s avoir pass√© pr√®s de 3 heures, je me suis souvenu que l'appel syst√®me CheckSum SROM √† l'entr√©e recevait un argument sp√©cifiant le nombre de blocs pour la somme de contr√¥le!  T.O.  nous pouvons facilement localiser l'adresse de stockage du code PIN et le compteur des ¬´tentatives incorrectes¬ª, pr√©cis au bloc de 64 octets. </p><br><p>  Mes premiers runs ont donn√© le r√©sultat suivant: </p><br><p><img src="https://habrastorage.org/webt/0n/ol/xc/0nolxcgp8espvfdubrhrmvmbgrg.png"></p><br><p>  Ensuite, j'ai chang√© le code PIN de "123456" en "1234567" et j'ai re√ßu: </p><br><p><img src="https://habrastorage.org/webt/0r/zp/s2/0rzps2e2mwldmhtot1tswiv7mdq.png"></p><br><p>  Ainsi, le code PIN et le compteur des tentatives incorrectes semblent √™tre stock√©s dans le bloc n ¬∞ 126. </p><br><a name="a75"></a><br><h2 id="75-snimaem-damp-bloka-126">  7.5.  Nous supprimons le d√©potoir du bloc n ¬∞ 126 </h2><br><p>  Le bloc n ¬∞ 126 devrait √™tre situ√© quelque part dans la r√©gion de 125x64x18 = 144000mks, depuis le d√©but du calcul de la somme de contr√¥le, dans mon vidage complet, et cela semble tout √† fait cr√©dible.  Puis, apr√®s avoir tri√© manuellement de nombreux vidages invalides (dus √† l'accumulation de "l√©g√®res d√©viations dans le temps"), j'ai finalement obtenu ces octets (avec un retard de 145527 Œºs): </p><br><p><img src="https://habrastorage.org/webt/ji/31/ye/ji31yewphovunymnjxp0fcpwrdw.png"></p><br><p>  Il est clair que le code PIN est stock√© sous forme non crypt√©e!  Ces valeurs ne sont bien s√ªr pas √©crites en codes ASCII, mais comme il s'est av√©r√©, elles refl√®tent les lectures prises sur le clavier capacitif. </p><br><p>  Enfin, j'ai effectu√© quelques tests suppl√©mentaires pour trouver o√π le compteur de tentatives incorrectes est stock√©.  Voici le r√©sultat: </p><br><p><img src="https://habrastorage.org/webt/dc/r5/tf/dcr5tf0yevdxcg5lyrbcr9srowu.png"></p><br><p>  0xFF - signifie "15 tentatives", et il diminue √† chaque tentative incorrecte. </p><br><a name="a76"></a><br><h2 id="76-vosstanovlenie-pinkoda">  7.6.  R√©cup√©ration de code PIN </h2><br><p>  Voici mon code laid qui rassemble tout ce qui pr√©c√®de: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dump_pin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> pin_map = {<span class="hljs-number"><span class="hljs-number">0x24</span></span>: <span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-number"><span class="hljs-number">0x25</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-number"><span class="hljs-number">0x26</span></span>: <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-number"><span class="hljs-number">0x27</span></span>:<span class="hljs-string"><span class="hljs-string">"3"</span></span>, <span class="hljs-number"><span class="hljs-number">0x20</span></span>: <span class="hljs-string"><span class="hljs-string">"4"</span></span>, <span class="hljs-number"><span class="hljs-number">0x21</span></span>: <span class="hljs-string"><span class="hljs-string">"5"</span></span>, <span class="hljs-number"><span class="hljs-number">0x22</span></span>: <span class="hljs-string"><span class="hljs-string">"6"</span></span>, <span class="hljs-number"><span class="hljs-number">0x23</span></span>: <span class="hljs-string"><span class="hljs-string">"7"</span></span>, <span class="hljs-number"><span class="hljs-number">0x2c</span></span>: <span class="hljs-string"><span class="hljs-string">"8"</span></span>, <span class="hljs-number"><span class="hljs-number">0x2d</span></span>: <span class="hljs-string"><span class="hljs-string">"9"</span></span>} last_csum = <span class="hljs-number"><span class="hljs-number">0</span></span> pin_bytes = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> delay <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">145495</span></span>, <span class="hljs-number"><span class="hljs-number">145719</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>): csum = csum_at(delay, <span class="hljs-number"><span class="hljs-number">1</span></span>) byte = (csum-last_csum)&amp;<span class="hljs-number"><span class="hljs-number">0xFF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"%05d %04x (%04x) =&gt; %02x"</span></span> % (delay, csum, last_csum, byte) pin_bytes.append(byte) last_csum = csum <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"PIN: "</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(pin_bytes)): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pin_bytes[i] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pin_map: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> pin_map[pin_bytes[i]], <span class="hljs-keyword"><span class="hljs-keyword">print</span></span></code> </pre> <br><p>  Voici le r√©sultat de son ex√©cution: </p><br><pre> <code class="plaintext hljs">$ ./psoc.py syncing: KO OK Resetting PSoC: KO Resetting PSoC: KO Resetting PSoC: OK 145495 53e2 (0000) =&gt; e2 145511 5407 (53e2) =&gt; 25 145527 542d (5407) =&gt; 26 145543 5454 (542d) =&gt; 27 145559 5474 (5454) =&gt; 20 145575 5495 (5474) =&gt; 21 145591 54b7 (5495) =&gt; 22 145607 54da (54b7) =&gt; 23 145623 5506 (54da) =&gt; 2c 145639 5506 (5506) =&gt; 00 145655 5533 (5506) =&gt; 2d 145671 554c (5533) =&gt; 19 145687 554e (554c) =&gt; 02 145703 554e (554e) =&gt; 00 PIN: 1 2 3 4 5 6 7 8 9</code> </pre> <br><p>  Hourra!  √áa marche! </p><br><p>  Veuillez noter que les valeurs de retard utilis√©es par moi sont tr√®s probablement pertinentes pour un PSoC sp√©cifique - celui que j'ai utilis√©. </p><br><a name="a8"></a><br><h1 id="8-chto-dalshe">  8. Et ensuite? </h1><br><p> ,     PSoC,     Aigo: </p><br><ul><li>    SRAM,      ; </li><li>      ,   ¬´   ¬ª,    . </li></ul><br><p>   ,       ‚Äì -   .       : </p><br><ul><li>       ,      ¬´   ¬ª; </li><li>  FPGA-       (    Arduino); </li><li>    :    ,     RAM,   ,       RAM,  .   Arduino    - ,    Arduino  5 ,            3,3 . </li></ul><br><p>   ,      ‚Äì   ,     .     ,         , ‚Äì  ,          . </p><br><p>  SROM,        ReadBlock,       ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>     ‚Äì     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´REcon Brussels 2017¬ª</a> . </p><br><p>    ,      ‚Äì    :    SRAM,      . </p><br><a name="a9"></a><br><h1 id="9-zaklyuchenie"> 9.  </h1><br><p> ,      ,         ( ¬´¬ª) ‚Ä¶      (),         ! </p><br><p>     Aigo?  -   HDD-,   2015   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>  SyScan,        HDD-,   ,       .  :-) </p><br><p>          .     40 .     (   )    ( ).    40   ,       .    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455529/">https://habr.com/ru/post/fr455529/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455517/index.html">Dipl√¥m√© du cours de Netologie "Data Science" sur son travail dans le secteur bancaire</a></li>
<li><a href="../fr455519/index.html">Comment nous avons impl√©ment√© l'int√©gration de nouveaux d√©veloppeurs</a></li>
<li><a href="../fr455523/index.html">Impl√©mentation de l'interface utilisateur d'OpenStack LBaaS</a></li>
<li><a href="../fr455525/index.html">Zimbra et Mail Bomb Defense</a></li>
<li><a href="../fr455527/index.html">Qu'est-ce qui est √©crit ici? Dans les coulisses des objets JavaScript</a></li>
<li><a href="../fr455533/index.html">Bubble Physics: A Search for Foam Destruction Mechanism</a></li>
<li><a href="../fr455535/index.html">G√©rer les certificats SSL / TLS dans les nuages ‚Äã‚Äãet les conteneurs - pas du travail humain</a></li>
<li><a href="../fr455537/index.html">Optimisation de la recherche √©tendue: comment traiter un graphique avec 10 milliards d'√©tats</a></li>
<li><a href="../fr455539/index.html">Voyants mobiles: 10 nouveaux faits sur la fa√ßon dont les appareils portables vous regardent</a></li>
<li><a href="../fr455543/index.html">Le cluster Kubernetes est-il facile et pratique √† pr√©parer? Annoncer l'op√©rateur d'addon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>