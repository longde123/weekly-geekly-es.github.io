<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📖 🍭 🦖 Inverser et pirater le disque dur externe à chiffrement automatique d'Aigo. Partie 2: Dump avec Cypress PSoC 🐞 🚫 💇🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il s'agit de la deuxième et dernière partie de l'article sur le piratage de disques externes à chiffrement automatique. Je vous rappelle qu’un collègu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Inverser et pirater le disque dur externe à chiffrement automatique d'Aigo. Partie 2: Dump avec Cypress PSoC</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455529/"><p>  Il s'agit de la deuxième et dernière partie de l'article sur le piratage de disques externes à chiffrement automatique.  Je vous rappelle qu’un collègue m’a récemment apporté un disque dur Patriot (Aigo) SK8671, et j’ai décidé de l’inverser, et maintenant je partage ce qui en est sorti.  Avant de continuer à lire, assurez-vous de lire la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">première partie de l'</a> article. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4. Nous commençons à supprimer le vidage du lecteur flash interne PSoC</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">5. Protocole ISSP</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">- 5.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Qu'est-ce qu'un ISSP?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">- 5.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Démystification des vecteurs</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">- 5.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chat avec PSoC</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">- 5.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Identification des registres intra-puce</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">- 5.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Embouts de protection</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6. Première attaque (échouée): ROMX</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">7. Deuxième attaque: trace avec réinitialisation à froid</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">- 7.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Implémentation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">- 7.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lire le résultat</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">- 7.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Reconstruction du binaire flash</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">- 7.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Trouver l'adresse de stockage du code PIN</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">- 7.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nous supprimons le dépotoir du bloc n ° 126</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">- 7.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Récupération de code PIN</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">8. Et ensuite?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">9. Conclusion</a> </p><br><p><img src="https://habrastorage.org/webt/wx/nm/gk/wxnmgkeurrmiurx87rujoynxrsq.jpeg"></p><a name="habracut"></a><br><a name="a4"></a><br><h1 id="4-nachinaem-snimat-damp-s-vnutrenney-fleshki-psoc">  4. Nous commençons à supprimer le vidage du lecteur flash interne PSoC </h1><br><p>  Donc, tout indique (comme nous l'avons établi dans [la première partie] ()) que le code PIN est stocké dans les entrailles flash PSoC.  Par conséquent, nous devons lire ces entrailles flash.  Devant des travaux nécessaires: </p><br><ul><li>  prendre le contrôle de la "communication" avec le microcontrôleur; </li><li>  trouver un moyen de vérifier si cette "communication" est protégée de la lecture de l'extérieur; </li><li>  trouver un moyen de contourner la sécurité. </li></ul><br><p>  Il y a deux endroits où il est logique de rechercher un code PIN valide: </p><br><ul><li>  mémoire flash interne; </li><li>  SRAM, où le code PIN peut être stocké pour le comparer avec le code PIN que l'utilisateur entre. </li></ul><br><p>  Pour l'avenir, je note que j'ai quand même réussi à supprimer le vidage du lecteur flash interne PSoC, en contournant son système de protection, en utilisant l'attaque matérielle "trace de réinitialisation à froid" après avoir inversé les fonctionnalités non documentées du protocole ISSP.  Cela m'a permis de vider directement le code PIN actuel. </p><br><pre><code class="plaintext hljs">$ ./psoc.py syncing: KO OK [...] PIN: 1 2 3 4 5 6 7 8 9</code> </pre> <br><p>  Le code de programme résultant: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code Arduino pour HSSP</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pilote Python et désassembleur ISSP</a> . </li></ul><br><a name="a5"></a><br><h1 id="5-issp-protokol">  5. Protocole ISSP </h1><br><a name="a51"></a><br><h2 id="51-chto-takoe-issp">  5.1.  Qu'est-ce qu'un ISSP? </h2><br><p>  La «communication» avec le microcontrôleur peut signifier différentes choses: de «fournisseur à fournisseur», à l'interaction à l'aide d'un protocole série (par exemple, ICSP pour PIC de Microchip). </p><br><p>  Cypress a son propre protocole propriétaire pour cela, appelé ISSP (protocole de programmation série dans le système), qui est partiellement décrit dans les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">spécifications techniques</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">US7185162</a> fournit également des informations.  Il existe également un analogue OpenSource appelé HSSP (nous l'utiliserons un peu plus tard).  L'ISSP fonctionne comme suit: </p><br><ul><li>  redémarrer PSoC; </li><li>  apporter le nombre magique à la jambe de données série de ce PSoC;  pour entrer en mode de programmation externe; </li><li>  envoyer des commandes qui sont de longues chaînes de bits appelées «vecteurs». </li></ul><br><p>  Dans la documentation ISSP, ces vecteurs sont définis uniquement pour une petite poignée de commandes: </p><br><ul><li>  Initialialize-1 </li><li>  Initialize-2 </li><li>  Initialize-3 (options 3V et 5V) </li><li>  ID-SETUP </li><li>  LIRE-ID-MOT </li><li>  SET-BLOCK-NUM: 10011111010dddddddd111, où dddddddd = bloc # </li><li>  EFFACEMENT EN VRAC </li><li>  PROGRAMME-BLOC </li><li>  VERIFY-SETUP </li><li>  LECTURE: 10110aaaaaaZDDDDDDDDDZ1, où DDDDDDDDD = sortie de données, aaaaaa = adresse (6 bits) </li><li>  WRITE-BYTE: 10010aaaaaadddddddd111, où dddddddd = données en entrée, aaaaaa = adresse (6 bits) </li><li>  Sécurisé </li><li>  CHECKSUM-SETUP </li><li>  READ-CHECKSUM: 10111111001ZDDDDDDDDDZ110111111000ZDDDDDDDDZ1, où DDDDDDDDDDDDDDDDD = données sortantes: somme de contrôle de l'appareil </li><li>  EFFACER LE BLOC </li></ul><br><p>  Par exemple, le vecteur pour Initialize-2: </p><br><pre> <code class="plaintext hljs">1101111011100000000111 1101111011000000000111 1001111100000111010111 1001111100100000011111 1101111010100000000111 1101111010000000011111 1001111101110000000111 1101111100100110000111 1101111101001000000111 1001111101000000001111 1101111000000000110111 1101111100000000000111 1101111111100010010111</code> </pre> <br><p>  Tous les vecteurs ont la même longueur: 22 bits.  La documentation HSSP contient des informations supplémentaires sur les ISSP: «Un vecteur ISSP n'est rien de plus qu'une séquence de bits représentant un ensemble d'instructions.» </p><br><a name="a52"></a><br><h2 id="52-demistifikaciya-vektorov">  5.2.  Démystification des vecteurs </h2><br><p>  Voyons ce qui se passe ici.  Initialement, j'ai supposé que ces mêmes vecteurs sont des variantes brutes des instructions M8C, cependant, après avoir testé cette hypothèse, j'ai trouvé que les opcodes des opérations ne correspondent pas. </p><br><p>  Ensuite, j'ai googlé le vecteur ci-dessus et suis tombé sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette</a> étude, où l'auteur, sans entrer dans les détails, donne quelques indices pratiques: «Chaque instruction commence par trois bits qui correspondent à l'une des quatre mnémoniques (lire à partir de RAM, écrire à RAM , lire le registre, écrire le registre).  Vient ensuite l'adresse 8 bits, suivie de 8 bits de données (lus ou écrits) et enfin trois bits d'arrêt. » </p><br><p>  J'ai ensuite pu recueillir des informations très utiles dans la section ROM de supervision (SROM) du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">manuel technique</a> .  SROM est une ROM codée en dur dans PSoC qui fournit des fonctions de service (similaires à Syscall) pour le code logiciel exécuté dans l'espace utilisateur: </p><br><ul><li>  00h: SWBootReset </li><li>  01h: ReadBlock </li><li>  02h: WriteBlock </li><li>  03h: EraseBlock </li><li>  06h: TableRead </li><li>  07h: CheckSum </li><li>  08h: Calibrate0 </li><li>  09h: Calibrate1 </li></ul><br><p>  En comparant les noms de vecteur avec les fonctions SROM, nous pouvons mapper les différentes opérations prises en charge par ce protocole aux paramètres SROM attendus.  Grâce à cela, nous pouvons décoder les trois premiers bits des vecteurs ISSP: </p><br><ul><li>  100 =&gt; «wrmem» </li><li>  101 =&gt; «rdmem» </li><li>  110 =&gt; «wrreg» </li><li>  111 =&gt; «rdreg» </li></ul><br><p>  Cependant, une compréhension complète des processus intra-puce ne peut être obtenue que par une communication directe avec PSoC. </p><br><a name="a53"></a><br><h2 id="53-obschenie-s-psoc">  5.3.  Chat avec PSoC </h2><br><p>  Puisque Dirk Petrautsky a déjà <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">porté le</a> code Cypress HSSP sur Arduino, j'ai utilisé Arduino Uno pour connecter la carte clavier au connecteur ISSP. </p><br><p>  Veuillez noter que lors de mes recherches, j'ai pratiquement changé le code Dirk.  Vous pouvez retrouver ma modification sur GitHub: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voici le</a> script Python correspondant pour communiquer avec Arduino, dans mon référentiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cypress_psoc_tools</a> . </p><br><p>  Donc, en utilisant Arduino, au début, je n'utilisais que des vecteurs «officiels» pour la «communication».  J'ai essayé de lire la ROM interne en utilisant la commande VERIFY.  Comme prévu, je n'ai pas pu faire ça.  Probablement dû au fait que les bits de protection en lecture sont activés à l'intérieur du lecteur flash. </p><br><p>  Ensuite, j'ai créé certains de mes vecteurs simples pour écrire et lire la mémoire / les registres.  Veuillez noter que nous pouvons lire l'intégralité du SROM, même si le lecteur flash est protégé! </p><br><a name="a54"></a><br><h2 id="54-identifikaciya-vnutrichipovyh-registrov">  5.4.  Identification des registres intra-puce </h2><br><p>  En regardant les vecteurs "désassemblés", j'ai trouvé que l'appareil utilise des registres non documentés (0xF8-0xFA) pour indiquer les opcodes M8C qui sont exécutés directement, en contournant la protection.  Cela m'a permis d'exécuter divers opcodes tels que «ADD», «MOV A, X», «PUSH» ou «JMP».  Grâce à eux (en regardant les effets secondaires qu'ils ont sur les registres), j'ai pu déterminer lesquels des registres non documentés sont en fait des registres réguliers (A, X, SP et PC). </p><br><p>  En conséquence, le code «désassemblé» généré par l'outil HSSP_disas.rb ressemble à ceci (j'ai ajouté des commentaires pour plus de clarté): </p><br><pre> <code class="plaintext hljs">--== init2 ==-- [DE E0 1C] wrreg CPU_F (f7), 0x00 #   [DE C0 1C] wrreg SP (f6), 0x00 #  SP [9F 07 5C] wrmem KEY1, 0x3A #    SSC [9F 20 7C] wrmem KEY2, 0x03 #  [DE A0 1C] wrreg PCh (f5), 0x00 #  PC (MSB) ... [DE 80 7C] wrreg PCl (f4), 0x03 # (LSB) ...  3 ?? [9F 70 1C] wrmem POINTER, 0x80 # RAM-    [DF 26 1C] wrreg opc1 (f9), 0x30 #  1 =&gt; "HALT" [DF 48 1C] wrreg opc2 (fa), 0x40 #  2 =&gt; "NOP" [9F 40 3C] wrmem BLOCKID, 0x01 # BLOCK ID   SSC [DE 00 DC] wrreg A (f0), 0x06 #  "Syscall" : TableRead [DF 00 1C] wrreg opc0 (f8), 0x00 #   SSC, "Supervisory SROM Call" [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12 #  :   </code> </pre> <br><a name="a55"></a><br><h2 id="55-zaschitnye-bity">  5.5.  Embouts de protection </h2><br><p>  À ce stade, je peux déjà communiquer avec PSoC, mais je n'ai toujours pas d'informations fiables sur les bits de protection du lecteur flash.  J'ai été très surpris par le fait que Cypress ne donne à l'utilisateur de l'appareil aucun moyen de vérifier si la protection est activée.  Je suis allé profondément dans Google pour finalement comprendre que le code HSSP fourni par Cypress a été mis à jour après que Dirk ait publié sa modification.  Et voilà!  Voici un nouveau vecteur comme celui-ci: </p><br><pre> <code class="plaintext hljs">[DE E0 1C] wrreg CPU_F (f7), 0x00 [DE C0 1C] wrreg SP (f6), 0x00 [9F 07 5C] wrmem KEY1, 0x3A [9F 20 7C] wrmem KEY2, 0x03 [9F A0 1C] wrmem 0xFD, 0x00 #   [9F E0 1C] wrmem 0xFF, 0x00 #  [DE A0 1C] wrreg PCh (f5), 0x00 [DE 80 7C] wrreg PCl (f4), 0x03 [9F 70 1C] wrmem POINTER, 0x80 [DF 26 1C] wrreg opc1 (f9), 0x30 [DF 48 1C] wrreg opc2 (fa), 0x40 [DE 02 1C] wrreg A (f0), 0x10 #  syscall ! [DF 00 1C] wrreg opc0 (f8), 0x00 [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12</code> </pre> <br><p>  En utilisant ce vecteur (voir read_security_data dans psoc.py), nous obtenons tous les bits de protection dans SRAM à 0x80, où chaque bit est protégé avec deux bits. </p><br><p>  Le résultat est déprimant: tout est protégé en mode "désactiver la lecture et l'écriture externes".  Par conséquent, nous pouvons non seulement lire quoi que ce soit à partir du lecteur flash USB, mais aussi l'écrire (par exemple, pour y introduire un dumper ROM).  Et la seule façon de désactiver la protection est d'effacer complètement la puce entière.  :-( </p><br><a name="a6"></a><br><h1 id="6-pervaya-neudavshayasya-ataka-romx">  6. Première attaque (échouée): ROMX </h1><br><p>  Cependant, nous pouvons essayer l'astuce suivante: puisque nous avons la possibilité d'exécuter des opcodes arbitraires, pourquoi ne pas exécuter ROMX, qui est utilisé pour lire la mémoire flash?  Cette approche a de bonnes chances de succès.  Parce que la fonction ReadBlock, qui lit les données de SROM (qui est utilisé par les vecteurs), vérifie si elle est appelée depuis ISSP.  Cependant, l'opcode ROMX peut ne pas avoir une telle vérification.  Voici donc le code Python (après avoir ajouté quelques classes d'assistance au code Arduino C): </p><br><pre> <code class="plaintext hljs">for i in range(0, 8192): write_reg(0xF0, i&gt;&gt;8) # A = 0 write_reg(0xF3, i&amp;0xFF) # X = 0 exec_opcodes("\x28\x30\x40") # ROMX, HALT, NOP byte = read_reg(0xF0) # ROMX reads ROM[A|X] into A print "%02x" % ord(byte[0]) # print ROM byte</code> </pre> <br><p>  Malheureusement, ce code ne fonctionne pas.  :-( Au contraire, cela fonctionne, mais en sortie, nous obtenons nos propres opcodes (0x28 0x30 0x40)! Je ne pense pas que la fonctionnalité correspondante de l'appareil soit un élément de protection en lecture. Cela ressemble plus à une astuce d'ingénierie: lors de l'exécution d'opcodes externes, le bus ROM est redirigé dans un tampon temporaire. </p><br><a name="a7"></a><br><h1 id="7-vtoraya-ataka-trassirovka-s-holodnoy-perezagruzkoy">  7. Deuxième attaque: trace avec réinitialisation à froid </h1><br><p>  Étant donné que l'astuce ROMX n'a ​​pas fonctionné, j'ai commencé à penser à une autre variante de cette astuce - décrite dans la publication <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Éclairer trop de lumière sur la protection du microprogramme d'un microcontrôleur»</a> . </p><br><a name="a71"></a><br><h2 id="71-realizaciya">  7.1.  Implémentation </h2><br><p>  Le vecteur suivant pour CHECKSUM-SETUP est répertorié dans la documentation ISSP: </p><br><pre> <code class="plaintext hljs">[DE E0 1C] wrreg CPU_F (f7), 0x00 [DE C0 1C] wrreg SP (f6), 0x00 [9F 07 5C] wrmem KEY1, 0x3A [9F 20 7C] wrmem KEY2, 0x03 [DE A0 1C] wrreg PCh (f5), 0x00 [DE 80 7C] wrreg PCl (f4), 0x03 [9F 70 1C] wrmem POINTER, 0x80 [DF 26 1C] wrreg opc1 (f9), 0x30 [DF 48 1C] wrreg opc2 (fa), 0x40 [9F 40 1C] wrmem BLOCKID, 0x00 [DE 00 FC] wrreg A (f0), 0x07 [DF 00 1C] wrreg opc0 (f8), 0x00 [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12</code> </pre> <br><p>  Ici, en substance, la fonction SROM 0x07 est appelée, comme présenté dans la documentation (la mienne en italique): </p><br><blockquote>  Cette fonction checksum checksum.  Il calcule une somme de contrôle de 16 bits du nombre de blocs défini par l'utilisateur dans une banque flash, en comptant à partir de zéro.  Le paramètre BLOCKID est utilisé pour transférer le nombre de blocs qui seront utilisés lors du calcul de la somme de contrôle.  Une valeur de «1» calculera la somme de contrôle pour le bloc zéro uniquement;  tandis que <em>"0" conduira au fait que la somme de contrôle totale des 256 blocs de la banque flash sera calculée.</em>  <em>Une somme de contrôle de 16 bits est renvoyée via KEY1 et KEY2.</em>  Dans le paramètre KEY1, les 8 bits bas de la somme de contrôle sont fixes et dans KEY2, les 8 bits hauts sont enregistrés.  Pour les appareils avec plusieurs banques de flash, la fonction de somme de contrôle est appelée pour chacun individuellement.  Le numéro de banque avec lequel il fonctionnera est fixé par le registre FLS_PR1 (en y insérant un bit correspondant à la banque flash cible). </blockquote><p>  Notez que c'est la somme de contrôle la plus simple: les octets sont simplement additionnés un par un;  pas de bizarreries CRC sophistiquées.  De plus, sachant que l'ensemble des registres dans le noyau M8C est très petit, j'ai supposé que lors du calcul de la somme de contrôle, les valeurs intermédiaires seront fixées dans les mêmes variables qui seront éventuellement sorties: KEY1 (0xF8) / KEY2 (0xF9). </p><br><p>  Donc, en théorie, mon attaque ressemble à ceci: </p><br><ol><li>  Connectez-vous via ISSP. </li><li>  Nous commençons le calcul de la somme de contrôle en utilisant le vecteur CHECKSUM-SETUP. </li><li>  Nous redémarrons le processeur après le temps spécifié T. </li><li>  Lisez la RAM pour obtenir la somme de contrôle actuelle C. </li><li>  Répétez les étapes 3 et 4, en augmentant chaque fois T. </li><li>  Nous récupérons les données du lecteur flash en soustrayant la somme de contrôle C précédente de celle actuelle. </li></ol><br><p>  Cependant, un problème est survenu: le vecteur Initialize-1, que nous devons envoyer après le redémarrage, écrase KEY1 et KEY2: </p><br><pre> <code class="plaintext hljs">1100101000000000000000 # ,  PSoC    nop nop nop nop nop [DE E0 1C] wrreg CPU_F (f7), 0x00 [DE C0 1C] wrreg SP (f6), 0x00 [9F 07 5C] wrmem KEY1, 0x3A #     [9F 20 7C] wrmem KEY2, 0x03 #   [DE A0 1C] wrreg PCh (f5), 0x00 [DE 80 7C] wrreg PCl (f4), 0x03 [9F 70 1C] wrmem POINTER, 0x80 [DF 26 1C] wrreg opc1 (f9), 0x30 [DF 48 1C] wrreg opc2 (fa), 0x40 [DE 01 3C] wrreg A (f0), 0x09 # SROM- 9 [DF 00 1C] wrreg opc0 (f8), 0x00 # SSC [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12</code> </pre> <br><p>  Ce code écrase notre précieuse somme de contrôle en appelant Calibrate1 (fonction SROM 9) ... Peut-être que nous pouvons simplement entrer dans le mode de programmation en envoyant le numéro magique (depuis le début du code ci-dessus) puis lire SRAM?  Et oui, ça marche!  Le code Arduino implémentant cette attaque est assez simple: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Cmnd_STK_START_CSUM: checksum_delay = ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)getch())&lt;&lt;<span class="hljs-number"><span class="hljs-number">24</span></span>; checksum_delay |= ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)getch())&lt;&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>; checksum_delay |= ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)getch())&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; checksum_delay |= getch(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(checksum_delay &gt; <span class="hljs-number"><span class="hljs-number">10000</span></span>) { ms_delay = checksum_delay/<span class="hljs-number"><span class="hljs-number">1000</span></span>; checksum_delay = checksum_delay%<span class="hljs-number"><span class="hljs-number">1000</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ms_delay = <span class="hljs-number"><span class="hljs-number">0</span></span>; } send_checksum_v(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(checksum_delay) delayMicroseconds(checksum_delay); delay(ms_delay); start_pmode();</code> </pre> <br><ol><li>  Lisez checkum_delay. </li><li>  Exécutez le calcul de la somme de contrôle (send_checksum_v). </li><li>  Attendez une période de temps donnée;  étant donné les pièges suivants: <br><ul><li>  J'ai tué beaucoup de temps jusqu'à ce que je découvre que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">delayMicroseconds s'est</a> avéré fonctionner correctement uniquement avec des retards ne dépassant pas 16383mks; </li><li>  et puis encore tué le même laps de temps jusqu'à ce qu'il trouve que delayMicroseconds, s'il passait 0 à son entrée, fonctionnait complètement mal! </li></ul></li><li>  Rechargez PSoC en mode de programmation (envoyez simplement le nombre magique, sans envoyer de vecteurs d'initialisation). </li></ol><br><p>  Le code Python résultant: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> delay <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">150000</span></span>): <span class="hljs-comment"><span class="hljs-comment">#    for i in range(0, 10): #      try: reset_psoc(quiet=True) #       send_vectors() #    ser.write("\x85"+struct.pack("&gt;I", delay)) #    +    res = ser.read(1) #  arduino ACK except Exception as e: print e ser.close() os.system("timeout -s KILL 1s picocom -b 115200 /dev/ttyACM0 2&gt;&amp;1 &gt; /dev/null") ser = serial.Serial('/dev/ttyACM0', 115200, timeout=0.5) #    continue print "%05d %02X %02X %02X" % (delay, #  RAM- read_regb(0xf1), read_ramb(0xf8), read_ramb(0xf9))</span></span></code> </pre> <br><p>  En un mot, ce que fait ce code: </p><br><ol><li>  Recharge le PSoC (et lui envoie un nombre magique). </li><li>  Envoie des vecteurs d'initialisation complets. </li><li>  Appelle la fonction Arduino Cmnd_STK_START_CSUM (0x85), où le retard en microsecondes est passé en paramètre. </li><li>  Lit la somme de contrôle (0xF8 et 0xF9) et le registre non documenté 0xF1. </li></ol><br><p>  Ce code est exécuté 10 fois en 1 microseconde.  0xF1 est inclus ici car c'est le seul registre qui a changé lors du calcul de la somme de contrôle.  Il s'agit peut-être d'une sorte de variable temporaire utilisée par le dispositif de logique arithmétique.  Faites attention au hack laid que je redémarre Arduino en utilisant picocom lorsque l'Arduino cesse de donner des signes de vie (je ne sais pas pourquoi). </p><br><a name="a72"></a><br><h2 id="72-schityvaem-rezultat">  7.2.  Lire le résultat </h2><br><p>  Le résultat du script Python ressemble à ceci (simplifié pour la lisibilité): </p><br><pre> <code class="plaintext hljs">DELAY F1 F8 F9 # F1 –    # F8     # F9     00000 03 E1 19 [...] 00016 F9 00 03 00016 F9 00 00 00016 F9 00 03 00016 F9 00 03 00016 F9 00 03 00016 F9 00 00 #     0 00017 FB 00 00 [...] 00023 F8 00 00 00024 80 80 00 # 1- : 0x0080-0x0000 = 0x80 00024 80 80 00 00024 80 80 00 [...] 00057 CC E7 00 # 2- : 0xE7-0x80: 0x67 00057 CC E7 00 00057 01 17 01 #   ,    00057 01 17 01 00057 01 17 01 00058 D0 17 01 00058 D0 17 01 00058 D0 17 01 00058 D0 17 01 00058 F8 E7 00 #  E7? 00058 D0 17 01 [...] 00059 E7 E7 00 00060 17 17 00 #  [...] 00062 00 17 00 00062 00 17 00 00063 01 17 01 # , !        00063 01 17 01 [...] 00075 CC 17 01 # , 0x117-0xE7: 0x30</code> </pre> <br><p>  Dans le même temps, nous avons un problème: puisque nous opérons sur la somme de contrôle réelle, un octet zéro ne change pas la valeur lue.  Cependant, comme toute la procédure de calcul (8192 octets) prend 0,1478 seconde (avec de légères déviations à chaque démarrage), ce qui correspond à peu près à 18,04 μs par octet, nous pouvons utiliser ce temps pour vérifier la valeur de la somme de contrôle à des moments appropriés.  Pour les premières exécutions, tout est lu assez facilement, car la durée de la procédure de calcul est toujours presque la même.  Cependant, la fin de ce vidage est moins précise, car les «écarts de temps insignifiants» à chaque passage se résument et deviennent significatifs: </p><br><pre> <code class="plaintext hljs">134023 D0 02 DD 134023 CC D2 DC 134023 CC D2 DC 134023 CC D2 DC 134023 FB D2 DC 134023 3F D2 DC 134023 CC D2 DC 134024 02 02 DC 134024 CC D2 DC 134024 F9 02 DC 134024 03 02 DD 134024 21 02 DD 134024 02 D2 DC 134024 02 02 DC 134024 02 02 DC 134024 F8 D2 DC 134024 F8 D2 DC 134025 CC D2 DC 134025 EF D2 DC 134025 21 02 DD 134025 F8 D2 DC 134025 21 02 DD 134025 CC D2 DC 134025 04 D2 DC 134025 FB D2 DC 134025 CC D2 DC 134025 FB 02 DD 134026 03 02 DD 134026 21 02 DD</code> </pre> <br><p>  Ce sont 10 décharges pour chaque retard de microsecondes.  La durée totale de fonctionnement pour le vidage de tous les 8192 octets d'un lecteur flash est d'environ 48 heures. </p><br><a name="a73"></a><br><h2 id="73-rekonstrukciya-flesh-binarnika">  7.3.  Reconstruction du binaire flash </h2><br><p>  Je n'ai pas encore fini d'écrire un code qui reconstruit complètement le code programme du lecteur flash, en tenant compte de tous les écarts dans le temps.  Cependant, j'ai déjà restauré le début de ce code.  Pour m'assurer que je l'ai fait correctement, je l'ai démonté à l'aide de m8cdis: </p><br><pre> <code class="plaintext hljs">0000: 80 67 jmp 0068h ; Reset vector [...] 0068: 71 10 or F,010h 006a: 62 e3 87 mov reg[VLT_CR],087h 006d: 70 ef and F,0efh 006f: 41 fe fb and reg[CPU_SCR1],0fbh 0072: 50 80 mov A,080h 0074: 4e swap A,SP 0075: 55 fa 01 mov [0fah],001h 0078: 4f mov X,SP 0079: 5b mov A,X 007a: 01 03 add A,003h 007c: 53 f9 mov [0f9h],A 007e: 55 f8 3a mov [0f8h],03ah 0081: 50 06 mov A,006h 0083: 00 ssc [...] 0122: 18 pop A 0123: 71 10 or F,010h 0125: 43 e3 10 or reg[VLT_CR],010h 0128: 70 00 and F,000h ; Paging mode changed from 3 to 0 012a: ef 62 jacc 008dh 012c: e0 00 jacc 012dh 012e: 71 10 or F,010h 0130: 62 e0 02 mov reg[OSC_CR0],002h 0133: 70 ef and F,0efh 0135: 62 e2 00 mov reg[INT_VC],000h 0138: 7c 19 30 lcall 1930h 013b: 8f ff jmp 013bh 013d: 50 08 mov A,008h 013f: 7f ret</code> </pre> <br><p>  Semble tout à fait crédible! </p><br><a name="a74"></a><br><h2 id="74-nahodim-adres-hraneniya-pinkoda">  7.4.  Trouver l'adresse de stockage du code PIN </h2><br><p>  Maintenant que nous pouvons lire la somme de contrôle au moment où nous en avons besoin, nous pouvons facilement vérifier comment et où elle change lorsque nous: </p><br><ul><li>  entrez le mauvais code PIN; </li><li>  changer le code PIN. </li></ul><br><p>  Tout d'abord, pour trouver l'adresse de stockage approximative, j'ai effectué un vidage de la somme de contrôle par incréments de 10 ms après un redémarrage.  Ensuite, j'ai entré le mauvais code PIN et j'ai fait de même. </p><br><p>  Le résultat n'était pas très agréable, car il y avait beaucoup de changements.  Mais à la fin, j'ai pu établir que la somme de contrôle a changé quelque part dans l'intervalle entre 120 000 μs et 140 000 μs de retard.  Mais le «code PIN» que j'ai obtenu était complètement faux - en raison de l'artefact de la procédure delayMicroseconds, qui fait des choses étranges quand il obtient 0. </p><br><p>  Puis, après avoir passé près de 3 heures, je me suis souvenu que l'appel système CheckSum SROM à l'entrée recevait un argument spécifiant le nombre de blocs pour la somme de contrôle!  T.O.  nous pouvons facilement localiser l'adresse de stockage du code PIN et le compteur des «tentatives incorrectes», précis au bloc de 64 octets. </p><br><p>  Mes premiers runs ont donné le résultat suivant: </p><br><p><img src="https://habrastorage.org/webt/0n/ol/xc/0nolxcgp8espvfdubrhrmvmbgrg.png"></p><br><p>  Ensuite, j'ai changé le code PIN de "123456" en "1234567" et j'ai reçu: </p><br><p><img src="https://habrastorage.org/webt/0r/zp/s2/0rzps2e2mwldmhtot1tswiv7mdq.png"></p><br><p>  Ainsi, le code PIN et le compteur des tentatives incorrectes semblent être stockés dans le bloc n ° 126. </p><br><a name="a75"></a><br><h2 id="75-snimaem-damp-bloka-126">  7.5.  Nous supprimons le dépotoir du bloc n ° 126 </h2><br><p>  Le bloc n ° 126 devrait être situé quelque part dans la région de 125x64x18 = 144000mks, depuis le début du calcul de la somme de contrôle, dans mon vidage complet, et cela semble tout à fait crédible.  Puis, après avoir trié manuellement de nombreux vidages invalides (dus à l'accumulation de "légères déviations dans le temps"), j'ai finalement obtenu ces octets (avec un retard de 145527 μs): </p><br><p><img src="https://habrastorage.org/webt/ji/31/ye/ji31yewphovunymnjxp0fcpwrdw.png"></p><br><p>  Il est clair que le code PIN est stocké sous forme non cryptée!  Ces valeurs ne sont bien sûr pas écrites en codes ASCII, mais comme il s'est avéré, elles reflètent les lectures prises sur le clavier capacitif. </p><br><p>  Enfin, j'ai effectué quelques tests supplémentaires pour trouver où le compteur de tentatives incorrectes est stocké.  Voici le résultat: </p><br><p><img src="https://habrastorage.org/webt/dc/r5/tf/dcr5tf0yevdxcg5lyrbcr9srowu.png"></p><br><p>  0xFF - signifie "15 tentatives", et il diminue à chaque tentative incorrecte. </p><br><a name="a76"></a><br><h2 id="76-vosstanovlenie-pinkoda">  7.6.  Récupération de code PIN </h2><br><p>  Voici mon code laid qui rassemble tout ce qui précède: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dump_pin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> pin_map = {<span class="hljs-number"><span class="hljs-number">0x24</span></span>: <span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-number"><span class="hljs-number">0x25</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-number"><span class="hljs-number">0x26</span></span>: <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-number"><span class="hljs-number">0x27</span></span>:<span class="hljs-string"><span class="hljs-string">"3"</span></span>, <span class="hljs-number"><span class="hljs-number">0x20</span></span>: <span class="hljs-string"><span class="hljs-string">"4"</span></span>, <span class="hljs-number"><span class="hljs-number">0x21</span></span>: <span class="hljs-string"><span class="hljs-string">"5"</span></span>, <span class="hljs-number"><span class="hljs-number">0x22</span></span>: <span class="hljs-string"><span class="hljs-string">"6"</span></span>, <span class="hljs-number"><span class="hljs-number">0x23</span></span>: <span class="hljs-string"><span class="hljs-string">"7"</span></span>, <span class="hljs-number"><span class="hljs-number">0x2c</span></span>: <span class="hljs-string"><span class="hljs-string">"8"</span></span>, <span class="hljs-number"><span class="hljs-number">0x2d</span></span>: <span class="hljs-string"><span class="hljs-string">"9"</span></span>} last_csum = <span class="hljs-number"><span class="hljs-number">0</span></span> pin_bytes = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> delay <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">145495</span></span>, <span class="hljs-number"><span class="hljs-number">145719</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>): csum = csum_at(delay, <span class="hljs-number"><span class="hljs-number">1</span></span>) byte = (csum-last_csum)&amp;<span class="hljs-number"><span class="hljs-number">0xFF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"%05d %04x (%04x) =&gt; %02x"</span></span> % (delay, csum, last_csum, byte) pin_bytes.append(byte) last_csum = csum <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"PIN: "</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(pin_bytes)): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pin_bytes[i] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pin_map: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> pin_map[pin_bytes[i]], <span class="hljs-keyword"><span class="hljs-keyword">print</span></span></code> </pre> <br><p>  Voici le résultat de son exécution: </p><br><pre> <code class="plaintext hljs">$ ./psoc.py syncing: KO OK Resetting PSoC: KO Resetting PSoC: KO Resetting PSoC: OK 145495 53e2 (0000) =&gt; e2 145511 5407 (53e2) =&gt; 25 145527 542d (5407) =&gt; 26 145543 5454 (542d) =&gt; 27 145559 5474 (5454) =&gt; 20 145575 5495 (5474) =&gt; 21 145591 54b7 (5495) =&gt; 22 145607 54da (54b7) =&gt; 23 145623 5506 (54da) =&gt; 2c 145639 5506 (5506) =&gt; 00 145655 5533 (5506) =&gt; 2d 145671 554c (5533) =&gt; 19 145687 554e (554c) =&gt; 02 145703 554e (554e) =&gt; 00 PIN: 1 2 3 4 5 6 7 8 9</code> </pre> <br><p>  Hourra!  Ça marche! </p><br><p>  Veuillez noter que les valeurs de retard utilisées par moi sont très probablement pertinentes pour un PSoC spécifique - celui que j'ai utilisé. </p><br><a name="a8"></a><br><h1 id="8-chto-dalshe">  8. Et ensuite? </h1><br><p> ,     PSoC,     Aigo: </p><br><ul><li>    SRAM,      ; </li><li>      ,   «   »,    . </li></ul><br><p>   ,       – -   .       : </p><br><ul><li>       ,      «   »; </li><li>  FPGA-       (    Arduino); </li><li>    :    ,     RAM,   ,       RAM,  .   Arduino    - ,    Arduino  5 ,            3,3 . </li></ul><br><p>   ,      –   ,     .     ,         , –  ,          . </p><br><p>  SROM,        ReadBlock,       ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>     –     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«REcon Brussels 2017»</a> . </p><br><p>    ,      –    :    SRAM,      . </p><br><a name="a9"></a><br><h1 id="9-zaklyuchenie"> 9.  </h1><br><p> ,      ,         ( «») …      (),         ! </p><br><p>     Aigo?  -   HDD-,   2015   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>  SyScan,        HDD-,   ,       .  :-) </p><br><p>          .     40 .     (   )    ( ).    40   ,       .    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455529/">https://habr.com/ru/post/fr455529/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455517/index.html">Diplômé du cours de Netologie "Data Science" sur son travail dans le secteur bancaire</a></li>
<li><a href="../fr455519/index.html">Comment nous avons implémenté l'intégration de nouveaux développeurs</a></li>
<li><a href="../fr455523/index.html">Implémentation de l'interface utilisateur d'OpenStack LBaaS</a></li>
<li><a href="../fr455525/index.html">Zimbra et Mail Bomb Defense</a></li>
<li><a href="../fr455527/index.html">Qu'est-ce qui est écrit ici? Dans les coulisses des objets JavaScript</a></li>
<li><a href="../fr455533/index.html">Bubble Physics: A Search for Foam Destruction Mechanism</a></li>
<li><a href="../fr455535/index.html">Gérer les certificats SSL / TLS dans les nuages ​​et les conteneurs - pas du travail humain</a></li>
<li><a href="../fr455537/index.html">Optimisation de la recherche étendue: comment traiter un graphique avec 10 milliards d'états</a></li>
<li><a href="../fr455539/index.html">Voyants mobiles: 10 nouveaux faits sur la façon dont les appareils portables vous regardent</a></li>
<li><a href="../fr455543/index.html">Le cluster Kubernetes est-il facile et pratique à préparer? Annoncer l'opérateur d'addon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>