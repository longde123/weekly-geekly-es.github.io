<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¢ üíí üß¶ Vuex: Strukturierung gro√üer Projekte und Arbeiten mit Modulen üçÆ ü§òüèº üïäÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vuex ist eine offizielle, gut dokumentierte Bibliothek zur Verwaltung des Anwendungsstatus, die speziell f√ºr Vue.js entwickelt wurde. Der Autor des Ma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vuex: Strukturierung gro√üer Projekte und Arbeiten mit Modulen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/420357/">  Vuex ist eine offizielle, gut dokumentierte Bibliothek zur Verwaltung des Anwendungsstatus, die speziell f√ºr Vue.js entwickelt wurde.  Der Autor des Materials, dessen √úbersetzung wir heute ver√∂ffentlichen, ist der Ansicht, dass die Verwendung dieser Bibliothek viel angenehmer ist als die von Redux, da Vuex zum einen weniger Boilerplate-Code ben√∂tigt und zum anderen aufgrund der Tatsache, dass sie funktioniert Bei asynchronen Mechanismen werden hier keine zus√§tzlichen Bibliotheken ben√∂tigt.  Da die Vuex-Bibliothek von demselben Team erstellt wurde, das an Vue arbeitet, l√§sst sich diese Bibliothek au√üerdem sehr gut in dieses Framework integrieren.  Leider kann es bei der Arbeit mit Vuex immer noch zu einer Schwierigkeit kommen, n√§mlich darin, die Struktur der Projekte, in denen Sie diese Bibliothek verwenden m√∂chten, ordnungsgem√§√ü vorzubereiten. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/lh/pj/o0/lhpjo0basq6-ilsaqqoua0ajpbi.jpeg"></a> <br><br>  In diesem Artikel finden Sie eine Beschreibung der Methodik zum Strukturieren gro√üer Projekte mit Vuex sowie ein Skript zur Automatisierung des Erstellungsprozesses von Vuex-Modulen. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Vue-Enterprise-Boilerplate-Muster und Projektstrukturproblem</font> </h2><br>  Einer der Vue-Entwickler, Chris Fritz, hat eine hervorragende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorlage</a> f√ºr Vue erstellt, die vorgestellte Projektstruktur, in der Vuex verwendet wird.  Diese Vorlage erm√∂glicht es Vuex insbesondere, Module basierend auf den Dateien im Modulordner automatisch zu registrieren.  Die Ordnerstruktur des Projekts sieht m√∂glicherweise wie in der folgenden Abbildung aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ce/603/64f/8ce60364f855dbf775de3171ca2cf981.png"></div><br>  <i><font color="#999999">Projektstruktur und unbequeme Code-Platzierung</font></i> <br><br>  Wenn Sie diese Vorlage verwenden, m√ºssen sich Status, Getter, Aktionen und Mutationen in derselben Datei befinden.  Pers√∂nlich ziehe ich es vor, sie in separaten Dateien zu speichern. Angesichts der Tatsache, dass Vuex-Module manchmal recht gro√ü sind, ist es praktisch, durch Programme zu navigieren, ohne durch gro√üe Codeteile scrollen zu m√ºssen.  Nach dieser Idee √§ndern wir den Code aus der Vorlage, sodass das, was sich auf einzelne Module bezieht, in Ordner sortiert werden kann, die f√ºr diese Module bestimmt sind.  Das hei√üt, die Struktur des Projekts wird sich √§ndern und der unten gezeigten √§hnlich sein. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3cc/366/02b/3cc36602bdf8225aa8bf20db963973d9.png"></div><br>  <i><font color="#999999">Die Struktur des Projekts mit der Aufteilung der Materialien von Modulen in separate Dateien, die sich in den Ordnern von Modulen befinden</font></i> <br><br><h2>  <font color="#3AC1EF">Entwicklung einer Vorlage, die eine bequeme Projektstruktur unterst√ºtzt</font> </h2><br>  Daher werden wir die Arbeit mit Vuex so organisieren, dass wir Ordner- und Dateistrukturen verwenden k√∂nnen, die den in der vorherigen Abbildung gezeigten in unseren Projekten √§hneln.  Erstellen Sie dazu zun√§chst ein neues Projekt mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vue CLI 3</a> . <br><br>  Nachdem Sie eine Projektvorlage f√ºr die weitere Arbeit bereit haben, installieren Sie Vuex und Lodash, indem <code>npm install vuex lodash -save</code> Befehl <code>npm install vuex lodash -save</code> im Terminal <code>npm install vuex lodash -save</code> .  Um mit Modulen arbeiten zu k√∂nnen, ben√∂tigen wir die Funktion <code>camelCase</code> von Lodash, mit der Zeichenfolgen in den <code>camelCase</code> konvertiert werden k√∂nnen. <br><br>  Erstellen Sie nun einen Ordner und eine Dateistruktur √§hnlich der in der vorherigen Abbildung gezeigten. <br><br>  Beginnen wir mit der Datei <code>store.js</code> .  Hier ist sein Code: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Vue <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Vuex <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vuex'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> modules <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./modules'</span></span> Vue.use(Vuex) const store = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Vuex.Store({ modules, <span class="hljs-keyword"><span class="hljs-keyword">strict</span></span>: process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span> }) //    `init`     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (const moduleName <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.keys(modules)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (modules[moduleName].actions.init) {   store.dispatch(`${moduleName}/init`) } } export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> store</code> </pre> <br>  Vue und Vuex werden hier importiert, da wir nicht ohne sie auskommen k√∂nnen.  Au√üerdem importieren wir Module aus <code>/modules/index.js</code> .  Als n√§chstes initialisieren wir den Speicher und durchlaufen alle Module.  Wenn das Modul eine <code>init</code> Aktion hat, initialisieren wir das Modul.  Dies erweist sich als sehr n√ºtzlich f√ºr Module, die beim Start der Anwendung initialisiert werden m√ºssen.  Aus diesem Grund exportieren wir den <code>store</code> nat√ºrlich. <code>main.js</code> wird er normalerweise in die Datei <code>main.js</code> importiert und der Vue-Instanz hinzugef√ºgt. <br><br>  Jetzt ist es Zeit, mit der Datei <code>index.js</code> zu arbeiten, die sich im Ordner <code>/store/modules</code> . <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    Vuex     ,    . <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> camelCase <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lodash/camelCase'</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    const requireModule = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>.context( <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      <span class="hljs-string"><span class="hljs-string">'.'</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   index.js,    ,    <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-string"><span class="hljs-string">'actions'</span></span>, <span class="hljs-string"><span class="hljs-string">'mutations'</span></span>,  <span class="hljs-string"><span class="hljs-string">'getters'</span></span> . <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,      .js <span class="hljs-regexp"><span class="hljs-regexp">/^(?!.*(actions|mutations|getters|index)).*\.js$/</span></span> ); const modules = {}; requireModule.keys().forEach(fileName =&gt; { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-regexp"><span class="hljs-regexp">/\.unit\.js$/</span></span>.test(fileName)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>            modules[camelCase(fileName.split(<span class="hljs-string"><span class="hljs-string">'/'</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>].replace(<span class="hljs-regexp"><span class="hljs-regexp">/(\.\/|\.js)/g</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>))] = {   namespaced: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,   ...requireModule(fileName).<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> }; }); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> modules;</code> </pre> <br>  In diesem Code importieren wir zuerst die <code>camelCase</code> Funktion aus Lodash.  Dann verwenden wir die <code>require.context</code> Methode, um die Module zu verbinden.  Als dritten Parameter √ºbergeben wir dort einen regul√§ren Ausdruck, der die Datei <code>index.js</code> , sowie Dateien, deren Namen die <code>index.js</code> , <code>mutations</code> und <code>getters</code> .  Sie werden beispielsweise in <code>auth.js</code> in die <code>auth.js</code> importiert und anschlie√üend exportiert.  So k√∂nnte beispielsweise die Datei <code>auth.js</code> aus dem Ordner <code>src/store/modules/auth/</code> zu Beginn der Arbeit aussehen: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> actions <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./actions'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mutations <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./mutations'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> getters <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./getters'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> state = {   <span class="hljs-attr"><span class="hljs-attr">user</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> {   state,   mutations,   getters,   actions };</code> </pre> <br>  Jetzt m√ºssen nur noch alle Module durchlaufen und mit allen ein einziges Objekt gebildet werden.  Hier m√ºssen Sie alle Dateien ausschlie√üen, in deren Namen sich eine <code>unit</code> , da sie nur f√ºr Tests und nicht f√ºr die Entwicklung oder die Bereitstellung eines Projekts in der Produktion ben√∂tigt werden.  Danach f√ºgen wir dem Modulobjekt eine neue Eigenschaft hinzu, die den Namen der Statusdatei enth√§lt, z. B. <code>auth</code> oder <code>users</code> .  Dar√ºber hinaus verwenden wir die Funktion <code>camelCase</code> , um Eigenschaftsnamen konsistent aussehen zu lassen.  Anschlie√üend <code>requireModule</code> wir das <code>requireModule</code> , durchlaufen das <code>requireModule</code> und verwenden das <code>...requireModule(fileName).default</code> Anschlie√üend exportieren <code>...requireModule(fileName).default</code> die <code>modules</code> . <br><br>  Tats√§chlich kann so ein Projekt strukturiert werden, in dem Zustand, Getter, Aktionen und Mutationen separat gespeichert und bequem organisiert werden.  Lassen Sie uns nun dar√ºber sprechen, wie Sie ein Skript schreiben, um automatisch Vuex-Module zu erstellen. <br><br><h2>  <font color="#3AC1EF">Skript zum automatischen Erstellen von Vuex-Modulen</font> </h2><br>  Erstellen Sie einen neuen Ordner im Projektordner mit den <code>scripts</code> und erstellen Sie darin die Datei <code>generateVuexModule.js</code> .  F√ºr dieses Projekt ben√∂tigen wir Node.js. Wenn Sie diese Plattform nicht installiert haben, ist es jetzt an der Zeit, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sie</a> zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beheben</a> .  Unser Skript hat nur eine Abh√§ngigkeit - das <code>chalk</code> , mit dem in der Konsole angezeigte Materialien entworfen werden.  Sie k√∂nnen dieses Paket mit dem <code>npm install -save-dev chalk</code> . <br><br><h3>  <font color="#3AC1EF">‚ñçSchritt 1</font> </h3><br>  In der Datei <code>generateVuexModule.js</code> m√ºssen Sie drei Module verbinden: <code>fs</code> , <code>path</code> und <code>chalk</code> .  Auch hier ben√∂tigen Sie eine Konstante mit dem Pfad zum Modulordner ( <code>src/store/modules</code> ) und eine weitere Konstante - <code>args</code> , mit der die Argumente beim Ausf√ºhren an das Skript √ºbergeben werden. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> chalk = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chalk'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> modulesPath = <span class="hljs-string"><span class="hljs-string">'src/store/modules'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> args = process.argv.slice(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chalk.red(...args)); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> success = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chalk.green(...args)); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!args.length) { error(<span class="hljs-string"><span class="hljs-string">'You must provide a name for the module!'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br>  Wie Sie sehen k√∂nnen, schreiben wir alle Argumente in die Argumente mit Ausnahme der ersten beiden, da sie den Pfad zu <code>node.exe</code> und der Skriptdatei darstellen und wir diese Informationen nicht ben√∂tigen.  Uns interessiert nur der dritte Parameter - der Name des neuen Moduls.  Dar√ºber hinaus gibt es einige Funktionen, <code>error</code> und <code>success</code> , die das oben genannte <code>chalk</code> , um Nachrichten mit Texten in verschiedenen Farben anzuzeigen. <br><br>  Hier m√ºssen Sie die L√§nge des <code>args</code> Arrays √ºberpr√ºfen, um herauszufinden, ob der Modulname an unser Skript √ºbergeben wird. Wenn dies nicht der <code>args</code> ist, geben Sie eine Fehlermeldung aus.  Wenn Sie versuchen, dieses Skript mit dem Befehl nodeVuexModule.js auszuf√ºhren, ohne etwas anderes an ihn zu √ºbergeben, wird im Terminal eine Fehlermeldung angezeigt. <br><br><h3>  <font color="#3AC1EF">‚ñçSchritt 2</font> </h3><br>  Zu diesem Zeitpunkt haben wir einen Namen f√ºr das Modul und den Pfad, der durch die Konstante <code>modulesPath</code> wird.  Wir m√ºssen jedoch noch mit diesen Daten arbeiten.  Extrahieren Sie n√§mlich den Namen aus dem <code>args</code> Array und sammeln Sie den vollst√§ndigen Pfad zum Modul, ganz zu schweigen von der Bildung seines Inhalts. <br><br><pre> <code class="hljs pgsql">const moduleName = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; const modulePath = <span class="hljs-type"><span class="hljs-type">path</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(__dirname, <span class="hljs-string"><span class="hljs-string">'../'</span></span>, modulesPath, moduleName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fs.existsSync(modulePath)) { error(`${moduleName} directory already <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span>!`); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } const stateContent = `<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> getters <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./getters'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> actions <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./actions'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mutations <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./mutations'</span></span>; const state = {}; export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { state, getters, actions, mutations }; `; const exportFileContent = `<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@/store/types'</span></span>; export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { }; `;</code> </pre> <br>  Der Modulname befindet sich im Element des Arrays <code>args</code> mit dem Index 0. In dieser Phase des Programms k√∂nnen wir auf das Vorhandensein dieses Elements z√§hlen, da wir zuvor versucht haben, es aus <code>process.argv</code> zu extrahieren, und dann die L√§nge des Arrays <code>args</code> √ºberpr√ºft haben.  Dar√ºber hinaus haben wir den vollst√§ndigen Pfad mithilfe des Pfadmoduls und der <code>join</code> Methode vorbereitet.  Wir haben das aktuelle Verzeichnis mit dem Konstrukt <code>__dirname</code> um eine Ebene nach oben verschoben, da sich die Datei <code>generateVuexModule.js</code> im Projektordner <code>scripts</code> .  Dann f√ºgen wir dem Ergebnis einfach den Inhalt der Konstanten <code>modulesPath</code> und den Namen des Moduls hinzu.  Zu diesem Zeitpunkt sollte die <code>modulePath</code> Konstante so etwas wie <code>pathToYourProject/project/src/store/modules/moduleName</code> .  Hier wird das Modul erstellt.  Da wir nun den vollst√§ndigen Pfad haben, k√∂nnen wir √ºberpr√ºfen, ob dieses Verzeichnis vorhanden ist.  Wir m√∂chten nicht versehentlich die Dateien eines vorhandenen Moduls √ºberschreiben.  Wenn das Verzeichnis vorhanden ist, in dem Sie ein neues Modul erstellen m√∂chten, wird dank <code>chalk</code> eine Fehlermeldung in roten Buchstaben angezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92c/7e1/bc7/92c7e1bc7826ddc9f300393109b247f4.png"></div><br>  <i><font color="#999999">Beispiel f√ºr eine Fehlermeldung</font></i> <br><br>  Als N√§chstes m√ºssen Sie Konstanten erstellen, in denen Daten f√ºr die Dateien vorhanden sind.  Wie Sie sich vorstellen k√∂nnen, wird <code>stateContent</code> f√ºr die <code>stateContent</code> verwendet, <code>stateContent</code> beispielsweise f√ºr <code>auth.js</code> , und <code>exportFileContent</code> wird f√ºr die <code>getters.js</code> <code>auth.js</code> , <code>exportFileContent</code> und <code>mutations.js</code> verwendet.  Bei Bedarf k√∂nnen Sie dieser Liste alles hinzuf√ºgen, was in Ihrem Projekt erforderlich ist. <br><br><h3>  <font color="#3AC1EF">‚ñçSchritt 3</font> </h3><br>  Jetzt m√ºssen wir nur noch Pfade f√ºr die Moduldateien erstellen und diese erstellen. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> statePath = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${path.join(modulePath, </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">`</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${moduleName}</span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">.js`</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gettersPath = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${path.join(modulePath, </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'getters.js'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actionsPath = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${path.join(modulePath, </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'actions.js'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mutationsPath = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${path.join(modulePath, </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'mutations.js'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">`</span></span> fs.mkdirSync(modulePath); fs.appendFileSync(statePath, stateContent); fs.appendFileSync(gettersPath, exportFileContent); fs.appendFileSync(actionsPath, exportFileContent); fs.appendFileSync(mutationsPath, exportFileContent); success(<span class="hljs-string"><span class="hljs-string">'Module'</span></span>, moduleName, <span class="hljs-string"><span class="hljs-string">'generated!'</span></span>);</code> </pre> <br>  Zuerst deklarieren wir vier Konstanten, von denen jede einen Pfad f√ºr die entsprechende Datei enth√§lt.  Als n√§chstes m√ºssen wir einen Ordner f√ºr das Modul erstellen.  Wir haben bereits gepr√ºft, ob ein solcher Ordner vorhanden ist, und in diesem Fall einen Fehler ausgegeben.  Daher sollte es keine Probleme beim Erstellen eines Ordners geben.  Und schlie√ülich verwenden wir die <code>fs.appendFileSync</code> und platzieren die neuen Dateien mit dem Inhalt, der beim Erstellen angegeben wurde, im neu erstellten Verzeichnis.  Am Ende zeigt das Skript eine Meldung √ºber den erfolgreichen Abschluss des Vorgangs an. <br><br>  Um dieses Skript zu verwenden, <code>node generateVuexModule.js yourModuleName</code> einfach den <code>scripts</code> Ihres Projekts im Terminal auf und f√ºhren Sie einen Befehl des Formularknotens <code>node generateVuexModule.js yourModuleName</code> .  Nach erfolgreichem Abschluss des Skripts wird eine Meldung zum Erstellen eines Moduls angezeigt. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Nachdem Sie dieses Material gelesen haben, haben Sie eine Vorlage zum Strukturieren gro√üer Projekte kennengelernt, in denen Sie Vuex verwenden m√∂chten, sowie ein Skript, das die Erstellung von Vuex-Modulen vereinfacht.  Wir hoffen, dass Sie dieses Wissen n√ºtzlich finden.  Den Projektcode, dessen Beispiele wir untersucht haben, finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  <b>Liebe Leser!</b>  Wie strukturieren Sie gro√üe Vue-Anwendungen, die Vuex verwenden? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420357/">https://habr.com/ru/post/de420357/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420347/index.html">Erfahren Sie, wie Sie in weniger als 4 Minuten Ihre eigenen Bash-Befehle erstellen</a></li>
<li><a href="../de420349/index.html">IT-Outsourcing-Checkliste: Arbeiten ohne Risiken</a></li>
<li><a href="../de420351/index.html">So f√ºhren Sie Benutzersuchen auf GitHub mit Vue durch</a></li>
<li><a href="../de420353/index.html">Wir machen Shrimp noch n√ºtzlicher: F√ºgen Sie Bildtranscodierungen zu anderen Formaten hinzu</a></li>
<li><a href="../de420355/index.html">Smart Watch Pebble: Wie man √ºber Nacht zur Seltenheit wird</a></li>
<li><a href="../de420359/index.html">Var, let oder const? Variable Scope Issues und ES6</a></li>
<li><a href="../de420361/index.html">Fehler beim Ausf√ºhren von TextBox.GetLineText in .NET WPF</a></li>
<li><a href="../de420363/index.html">HPE-Webinare von August bis Oktober: Neue Themen (+ SHD, KI-Praxis, schl√ºsselfertiger Petabyte-Speicher)</a></li>
<li><a href="../de420367/index.html">Klimatisierte Apokalypse: Smart-Grid-Blackout-Szenario</a></li>
<li><a href="../de420369/index.html">Extreme Extended Edge oder IEEE 802.1BR-Switching</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>