<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôèÔ∏è ‚ôäÔ∏è üôè IDisposable - dass deine Mutter nicht √ºber die Freigabe von Ressourcen gesprochen hat. Teil 1 üç• üì∑ üë®üèº‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist eine √úbersetzung des ersten Teils des Artikels. Der Artikel wurde 2008 geschrieben. Nach 10 Jahren fast seine Relevanz verloren. 
 Determinis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>IDisposable - dass deine Mutter nicht √ºber die Freigabe von Ressourcen gesprochen hat. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414873/"><p>  Dies ist eine √úbersetzung des ersten Teils des Artikels.  Der Artikel wurde 2008 geschrieben.  Nach 10 Jahren fast seine Relevanz verloren. </p><br><h2 id="determinirovannoe-osvobozhdenie-resursov---neobhodimost">  Deterministische Freisetzung von Ressourcen - ein Bedarf </h2><br><p>  Im Laufe von mehr als 20 Jahren Erfahrung im Codieren habe ich manchmal meine eigenen Sprachen entwickelt, um Probleme zu l√∂sen.  Sie reichten von einfachen, zwingenden Sprachen bis zu speziellen regul√§ren Ausdr√ºcken f√ºr B√§ume.  Beim Erstellen von Sprachen gibt es viele Empfehlungen und einige einfache Regeln sollten nicht verletzt werden.  Einer von ihnen: </p><br><blockquote>  Erstellen Sie niemals eine Ausnahmesprache, in der keine deterministische Freigabe von Ressourcen erfolgt. </blockquote><p>  Ratet mal, welchen Empfehlungen die .NET-Laufzeit nicht folgt und daher alle darauf basierenden Sprachen? </p><a name="habracut"></a><br><p> Der Grund f√ºr diese Regel ist, dass eine <strong>deterministische Freigabe von Ressourcen erforderlich ist, um unterst√ºtzte Programme zu erstellen</strong> .  Die festgelegte Freigabe von Ressourcen bietet einen bestimmten Punkt, an dem der Programmierer sicher ist, dass die Ressource freigegeben ist.  Es gibt zwei M√∂glichkeiten, zuverl√§ssige Programme zu schreiben: Der traditionelle Ansatz besteht darin, Ressourcen so fr√ºh wie m√∂glich freizugeben, und der moderne Ansatz besteht darin, Ressourcen auf unbestimmte Zeit freizugeben.  Der Vorteil des modernen Ansatzes besteht darin, dass der Programmierer keine Ressourcen explizit freigeben muss.  Der Nachteil ist, dass es viel schwieriger ist, eine zuverl√§ssige Anwendung zu schreiben, es gibt viele subtile Fehler.  Leider wurde die .NET-Laufzeit mit einem modernen Ansatz erstellt. </p><br><p> .NET unterst√ºtzt die nicht deterministische Freigabe von Ressourcen mithilfe der <code>Finalize</code> Methode, die eine besondere Bedeutung hat.  F√ºr die deterministische Freigabe von Ressourcen hat Microsoft au√üerdem die <code>IDisposable</code> Schnittstelle (und andere Klassen, auf die wir sp√§ter noch <code>IDisposable</code> werden) hinzugef√ºgt.  Trotzdem ist <code>IDisposable</code> zur Laufzeit eine normale Schnittstelle, wie alle anderen auch.  Dieser Status "zweitklassig" schafft einige Schwierigkeiten. </p><br><p>  In C # kann "deterministische Freigabe f√ºr die Armen" mithilfe von <code>try</code> and <code>finally</code> <code>try</code> oder <code>using</code> (was fast dasselbe ist) implementiert werden.  Microsoft hat lange dar√ºber diskutiert, ob Linkz√§hlungen durchgef√ºhrt werden sollen oder nicht, und es scheint mir, dass die falsche Entscheidung getroffen wurde.  Daher m√ºssen Sie f√ºr die deterministische Freigabe von Ressourcen das ungeschickte <code>finally</code> \ <code>using</code> Konstrukt oder einen direkten Aufruf von <code>IDisposable.Dispose</code> , der mit Fehlern behaftet ist.  F√ºr einen C ++ - Programmierer, der es gewohnt ist, <code>shared_ptr&lt;T&gt;</code> beide Optionen nicht attraktiv.  (Der letzte Satz macht deutlich, wo der Autor eine solche Beziehung hat - <em>ca.</em> </p><br><h2 id="idisposable">  IDisposable </h2><br><p>  <code>IDisposable</code> ist eine L√∂sung f√ºr die deterministische Freigabe von Ressourcen, die von Misoftro angeboten werden.  Einer ist f√ºr die folgenden F√§lle: </p><br><ul><li>  Jeder Typ, <em>der</em> verwaltete ( <code>IDisposable</code> ) Ressourcen besitzt.  Ein Typ muss unbedingt <strong>besitzen</strong> , dh die Lebenszeit und die Ressourcen verwalten und sich nicht nur auf sie beziehen. </li><li>  Jeder Typ, der nicht verwaltete Ressourcen besitzt. </li><li>  Jeder Typ, der sowohl verwaltete als auch nicht verwaltete Ressourcen besitzt. </li><li>  Jeder Typ, der von einer Klasse geerbt wurde, die <code>IDisposable</code> implementiert.  Ich empfehle nicht, von Klassen zu erben, die nicht verwaltete Ressourcen besitzen.  Verwenden Sie besser einen Anhang. </li></ul><br><p>  <code>IDisposable</code> hilft, Ressourcen deterministisch <code>IDisposable</code> , hat jedoch seine eigenen Probleme. </p><br><h2 id="slozhnosti-idisposable---udobstvo-ispolzovaniya">  Schwierigkeiten IDisposable - Benutzerfreundlichkeit </h2><br><p>  <code>IDisposable</code> Objekte sind <code>IDisposable</code> um ziemlich umst√§ndlich zu verwenden.  Die Verwendung eines Objekts muss in ein <code>using</code> Konstrukt eingeschlossen werden.  Die schlechte Nachricht ist, dass C # die <code>using</code> mit einem Typ nicht zul√§sst, der <code>IDisposable</code> nicht implementiert.  Daher muss der Programmierer jedes Mal auf die Dokumentation zur√ºckgreifen, um zu verstehen, ob es notwendig ist, <code>using</code> oder nur <code>using</code> √ºberall zu schreiben, und dann zu l√∂schen, wo der Compiler schw√∂rt. </p><br><p>  Managed C ++ ist in dieser Hinsicht viel besser.  Es unterst√ºtzt die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stapelsemantik f√ºr Referenztypen</a> , die bei Bedarf nur f√ºr Typen verwendet wird.  C # k√∂nnte von der F√§higkeit profitieren, mit jedem Typ zu schreiben. </p><br><p>  Dieses Problem kann mit gel√∂st werden.  Tools zur Code-Analyse.  Wenn Sie die Verwendung vergessen, kann das Programm die Tests bestehen, st√ºrzt jedoch ab, w√§hrend Sie "auf den Feldern" arbeiten. </p><br><p>  Anstatt Links zu z√§hlen, hat <code>IDisposable</code> ein anderes Problem - die Bestimmung des Besitzers.  Wenn in C ++ die letzte Kopie von <code>shared_ptr&lt;T&gt;</code> G√ºltigkeitsbereich <code>shared_ptr&lt;T&gt;</code> , werden Ressourcen sofort freigegeben, ohne dass Sie √ºberlegen m√ºssen, wer freigegeben werden soll.  <code>IDisposable</code> zwingt den Programmierer zu bestimmen, wem das Objekt "geh√∂rt" und f√ºr dessen Freigabe verantwortlich ist.  Manchmal ist das Eigentum offensichtlich: Wenn ein Objekt ein anderes kapselt und selbst <code>IDisposable</code> implementiert, ist es daher f√ºr die Freigabe <code>IDisposable</code> Objekte verantwortlich.  Manchmal wird die Lebensdauer eines Objekts durch einen Codeblock bestimmt, und der Programmierer verwendet einfach die <code>using</code> um diesen Block herum.  Trotzdem gibt es viele F√§lle, in denen ein Objekt an mehreren Orten verwendet werden kann und seine Lebensdauer schwer zu bestimmen ist (obwohl in diesem Fall die Referenzanzahl in Ordnung w√§re). </p><br><h2 id="slozhnosti-idisposable---obratnaya-sovmestimost">  Schwierigkeiten IDisposable - Abw√§rtskompatibilit√§t </h2><br><p>  Das Hinzuf√ºgen von <code>IDisposable</code> zur Klasse und das Entfernen von <code>IDisposable</code> aus der Liste der implementierten Schnittstellen ist eine <code>IDisposable</code> √Ñnderung.  Client-Code, der <code>IDisposable</code> nicht erwartet, <code>IDisposable</code> keine Ressourcen frei, wenn Sie <code>IDisposable</code> zu einer Ihrer Klassen hinzuf√ºgen, die als Verweis auf eine Schnittstelle oder Basisklasse √ºbergeben werden. </p><br><p>  Microsoft selbst ist auf dieses Problem gesto√üen.  <code>IEnumerator</code> nicht von <code>IDisposable</code> geerbt, und <code>IEnumerator&lt;T&gt;</code> geerbt.  Wenn Sie <code>IEnumerator&lt;T&gt;</code> Code √ºbergeben, der <code>IEnumerator</code> empf√§ngt, wird <code>Dispose</code> nicht aufgerufen. </p><br><p>  Dies ist nicht das Ende der Welt, aber es gibt eine sekund√§re Essenz von <code>IDisposable</code> . </p><br><h2 id="slozhnosti-idisposable---proektirovanie-ierarhii-klassov">  IDISposable Schwierigkeiten - Entwerfen einer Klassenhierarchie </h2><br><p>  Der gr√∂√üte Nachteil von <code>IDisposable</code> im Bereich des Hierarchiedesigns besteht darin, dass jede Klasse und Schnittstelle vorhersagen muss, ob <code>IDisposable</code> von ihren Nachkommen ben√∂tigt wird. </p><br><p>  Wenn die Schnittstelle <code>IDisposable</code> nicht erbt, die Klassen, die die Schnittstelle implementieren, jedoch auch <code>IDisposable</code> implementieren, ignoriert der endg√ºltige Code entweder die deterministische Version oder muss pr√ºfen, ob das Objekt die <code>IDisposable</code> Schnittstelle implementiert.  Daf√ºr ist es jedoch nicht m√∂glich, das using-Konstrukt zu verwenden, und Sie m√ºssen einen h√§sslichen <code>try</code> schreiben und <code>finally</code> . </p><br><p>  Kurz gesagt, <code>IDisposable</code> erschwert die Entwicklung wiederverwendbarer Software.  Der Hauptgrund ist die Verletzung eines der Prinzipien des objektorientierten Designs - Trennung von Schnittstelle und Implementierung.  Die Freigabe von Ressourcen sollte ein Implementierungsdetail sein.  Microsoft hat beschlossen, die deterministische Freigabe von Ressourcen zu einer Schnittstelle zweiter Klasse zu machen. </p><br><p>  Eine der nicht so sch√∂nen L√∂sungen besteht darin, alle Klassen <code>IDisposable</code> implementieren zu <code>IDisposable</code> , aber in der √ºberwiegenden Mehrheit der Klassen wird <code>IDisposable.Dispose</code> nichts tun.  Das ist aber nicht zu sch√∂n. </p><br><p>  Eine weitere Schwierigkeit bei <code>IDisposable</code> sind Sammlungen.  Einige Sammlungen ‚Äûbesitzen‚Äú Objekte in ihnen, andere nicht.  Die Sammlungen selbst implementieren jedoch kein <code>IDisposable</code> .  Der Programmierer muss daran denken, <code>IDisposable.Dispose</code> f√ºr die Objekte in der Auflistung <code>IDisposable.Dispose</code> oder eigene Nachkommen von Auflistungsklassen zu erstellen, die <code>IDisposable</code> als Eigent√ºmer implementieren. </p><br><h2 id="slozhnosti-idisposable---dopolnitelnoe-oshibochnoe-sostoyanie">  Schwierigkeiten IDisposable - zus√§tzlicher "fehlerhafter" Zustand </h2><br><p>  <code>IDisposable</code> kann jederzeit explizit aufgerufen werden, unabh√§ngig von der Lebensdauer des Objekts.  Das hei√üt, jedem Objekt wird ein "freigegebener" Status hinzugef√ºgt, in dem empfohlen wird, eine <code>ObjectDisposedException</code> .  Das √úberpr√ºfen des Status und das Ausl√∂sen von Ausnahmen ist ein zus√§tzlicher Aufwand. </p><br><p>  Anstatt nach jedem Niesen zu suchen, ist es besser, den Zugriff auf das Objekt im "freigegebenen" Zustand als "undefiniertes Verhalten" als Aufruf des freigegebenen Speichers zu betrachten. </p><br><h2 id="slozhnosti-idisposable---net-garantiy">  Schwierigkeiten IDisposable - keine Garantien </h2><br><p>  <code>IDisposable</code> ist nur eine Schnittstelle.  Eine Klasse, die <code>IDisposable</code> implementiert, <strong>unterst√ºtzt die</strong> deterministische Freigabe, <strong>garantiert</strong> sie jedoch nicht.  F√ºr Client-Code ist es in Ordnung, <code>Dispose</code> nicht aufzurufen.  Daher muss eine Klasse, die <code>IDisposable</code> implementiert, sowohl deterministische als auch nicht deterministische Releases unterst√ºtzen. </p><br><h2 id="slozhnosti-idisposable---slozhnaya-realizaciya">  Komplexit√§ten IDisposable - Komplexe Implementierung </h2><br><p>  Microsoft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bietet ein Muster</a> f√ºr die Implementierung von <code>IDisposable</code> .  (Fr√ºher gab es ein allgemein schreckliches Muster, aber vor relativ kurzer Zeit, nach dem Erscheinen von .NET 4, wurde die Dokumentation korrigiert, auch unter dem Einfluss dieses Artikels. In den alten Ausgaben von .NET-B√ºchern finden Sie die alte Version. - <em>Ca.</em> ) </p><br><ul><li>  <code>IDisposable.Dispose</code> m√∂glicherweise √ºberhaupt nicht aufgerufen, daher muss die Klasse einen Finalizer enthalten, um Ressourcen <code>IDisposable.Dispose</code> . </li><li>  <code>IDisposable.Dispose</code> kann mehrmals aufgerufen werden und sollte ohne sichtbare Nebenwirkungen funktionieren.  Daher muss gepr√ºft werden, ob die Methode bereits aufgerufen wurde oder nicht. </li><li>  Finalizer werden in einem separaten Thread aufgerufen und k√∂nnen vor dem <code>IDisposable.Dispose</code> .  Die Verwendung von <code>GC.SuppressFinalize</code> , um solche "Rennen" zu vermeiden. </li></ul><br><p>  Au√üerdem: </p><br><ul><li>  Finalizer werden aufgerufen, auch f√ºr Objekte, die im Konstruktor eine Ausnahme ausl√∂sen.  Daher muss der Release-Code mit teilweise initialisierten Objekten funktionieren. </li><li>  Das Implementieren eines <code>IDisposable</code> in einer von <code>CriticalFinalizerObject</code> geerbten Klasse erfordert nicht triviale Konstrukte.  <code>void Dispose(bool disposing)</code> ist eine virale Methode und muss in der eingeschr√§nkten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ausf√ºhrungsregion ausgef√ºhrt werden</a> , f√ºr die ein Aufruf von <code>RuntimeHelpers.PrepareMethod</code> erforderlich ist. </li></ul><br><h2 id="slozhnosti-idisposable---ne-podhodit-dlya-logiki-zaversheniya">  Schwierigkeiten IDisposable - Nicht f√ºr die Abschlusslogik geeignet </h2><br><p>  Herunterfahren eines Objekts - tritt h√§ufig in Programmen in parallelen oder asynchronen Threads auf.  Beispielsweise verwendet eine Klasse einen separaten Thread und m√∂chte ihn mit <code>ManualResetEvent</code> .  Dies kann in <code>IDisposable.Dispose</code> , kann jedoch zu einem Fehler f√ºhren, wenn der Code im Finalizer aufgerufen wird. </p><br><p>  Um die Einschr√§nkungen im Finalizer zu verstehen, m√ºssen Sie wissen, wie der Garbage Collector funktioniert.  Im Folgenden finden Sie ein vereinfachtes Diagramm, in dem viele Details zu Generationen, Schwachstellen, Wiederbelebung von Objekten, Hintergrund-Garbage-Collection usw. weggelassen werden. </p><br><p>  Der .NET-Garbage Collector verwendet den Mark-and-Sweep-Algorithmus.  Im Allgemeinen sieht die Logik folgenderma√üen aus: </p><br><ol><li>  Unterbrechen Sie alle Threads. </li><li>  Nehmen Sie alle <code>GCHandle</code> : Variablen auf dem Stapel, statische Felder, <code>GCHandle</code> Objekte, Finalisierungswarteschlange.  Beim Entladen der Anwendungsdom√§ne (Programmbeendigung) wird davon ausgegangen, dass die Variablen im Stapel und in den statischen Feldern keine Roots sind. </li><li>  Gehen Sie rekursiv alle Links der Objekte durch und markieren Sie sie als "erreichbar". </li><li>  Durchsuchen Sie alle anderen Objekte mit Destruktoren (Finalisierern), deklarieren Sie sie als erreichbar und stellen Sie sie in die Finalisierungswarteschlange ( <code>GC.SuppressFinalize</code> weist GC an, dies nicht zu tun).  Objekte werden in einer unvorhersehbaren Reihenfolge in die Warteschlange gestellt. </li></ol><br><p>  Im Hintergrund funktioniert ein Stream (oder mehrere) der Finalisierung: </p><br><ol><li>  Nimmt ein Objekt aus der Warteschlange und startet seinen Finalizer.  Es ist m√∂glich, mehrere Finalizer verschiedener Objekte gleichzeitig auszuf√ºhren. </li><li>  Das Objekt wird aus der Warteschlange entfernt, und wenn niemand anderes darauf verweist, wird es bei der n√§chsten Speicherbereinigung gel√∂scht. </li></ol><br><p>  Jetzt sollte klar sein, warum es unm√∂glich ist, vom Finalizer aus auf verwaltete Ressourcen zuzugreifen - Sie wissen nicht, in welcher Reihenfolge die Finalizer aufgerufen werden.  Selbst das Aufrufen von <code>IDisposable.Dispose</code> anderen Objekts aus dem Finalizer kann zu einem Fehler f√ºhren, da der Ressourcenfreigabecode m√∂glicherweise in einem anderen Thread funktioniert. </p><br><p>  Es gibt einige Ausnahmen, wenn Sie von einem Finalizer aus auf verwaltete Ressourcen zugreifen k√∂nnen: </p><br><ol><li>  Die Finalisierung von Objekten, die von <code>CriticalFinalizerObject</code> geerbt wurden, erfolgt <strong>nach der</strong> Finalisierung von Objekten, die nicht von dieser Klasse geerbt wurden.  Dies bedeutet, dass Sie <code>ManualResetEvent</code> vom <code>ManualResetEvent</code> aus aufrufen <code>ManualResetEvent</code> , bis die Klasse von <code>CriticalFinalizerObject</code> geerbt wird </li><li>  Einige Objekte und Methoden sind speziell, z. B. die Konsolen- und einige Thread-Methoden.  Sie k√∂nnen von Finalisierern aufgerufen werden, auch wenn das Programm endet. </li></ol><br><p>  Im Allgemeinen ist es besser, nicht √ºber Finalizer auf verwaltete Ressourcen zuzugreifen.  Trotzdem ist die Logik der Fertigstellung f√ºr nicht triviale Software erforderlich.  Unter <code>Windows.Forms</code> enth√§lt <code>Windows.Forms</code> die Abschlusslogik in der <code>Application.Exit</code> Methode.  Wenn Sie Ihre Komponentenbibliothek entwickeln, ist es am besten, die Abschlusslogik mit <code>IDisposable</code> zu <code>IDisposable</code> .  Normale K√ºndigung bei Anruf <code>IDisposable.Dispose</code> . <code>IDisposable.Dispose</code> und sonst Notfall. </p><br><p>  Microsoft ist auch auf dieses Problem gesto√üen.  Die <code>StreamWriter</code> Klasse besitzt ein <code>Stream</code> Objekt (abh√§ngig von den Konstruktorparametern in der neuesten Version - <em>ca. Per.</em> ).  <code>StreamWriter.Close</code> den Puffer und ruft <code>Stream.Close</code> (tritt auch auf, wenn <code>using</code> - <em>ca. Per.</em> <code>Stream.Close</code> ).  Wenn <code>StreamWriter</code> nicht geschlossen ist, wird der Puffer nicht <code>StreamWriter</code> und der <code>StreamWriter</code> geht verloren.  Microsoft hat den Finalizer einfach nicht neu definiert und damit das Abschlussproblem "gel√∂st".  Ein gutes Beispiel f√ºr die Notwendigkeit einer Vervollst√§ndigungslogik. </p><br><h2 id="rekomenduyu-pochitat">  Ich empfehle zu lesen </h2><br><p>  Viele Informationen zu .NET-Interna in diesem Artikel stammen von Jeffrey Richters CLR √ºber C #.  Wenn Sie es noch nicht haben, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kaufen Sie es</a> .  Im Ernst.  Dies ist das notwendige Wissen f√ºr jeden C # -Programmierer. </p><br><h2 id="zaklyuchenie-ot-perevodchika">  Fazit des √úbersetzers </h2><br><p>  Die meisten .NET-Programmierer werden niemals auf die in diesem Artikel beschriebenen Probleme sto√üen.  .NET wird weiterentwickelt, um den Abstraktionsgrad zu erh√∂hen und den Bedarf an "Jonglieren" nicht verwalteter Ressourcen zu verringern.  Trotzdem ist dieser Artikel insofern n√ºtzlich, als er die tiefen Details einfacher Dinge und ihre Auswirkungen auf das Code-Design beschreibt. </p><br><p>  Im n√§chsten Teil wird anhand einer Reihe von Beispielen ausf√ºhrlich erl√§utert, wie mit verwalteten und nicht verwalteten Ressourcen in .NET gearbeitet wird. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414873/">https://habr.com/ru/post/de414873/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414861/index.html">Tunnelmodellierung - Version 1.0</a></li>
<li><a href="../de414865/index.html">iMaterialist Furniture Challenge oder 50 Stuhlfarben</a></li>
<li><a href="../de414867/index.html">ThinkingHome.Migrator - versionierte Migration des Datenbankschemas auf der .NET Core-Plattform</a></li>
<li><a href="../de414869/index.html">Verschwindende Rahmenbedingungen</a></li>
<li><a href="../de414871/index.html">Der Staubsturm auf dem Mars erreichte das planetare Ausma√ü, sogar die Neugier war betroffen</a></li>
<li><a href="../de414875/index.html">Kubernetes Containerd-Integration ersetzt Docker f√ºr die Produktion</a></li>
<li><a href="../de414877/index.html">Ein ungew√∂hnliches Objektiv f√ºr eine normale Kamera oder wie man aufh√∂rt, √ºber den Fokus nachzudenken</a></li>
<li><a href="../de414879/index.html">Warum 2 Extruder in einem 3D-Drucker?</a></li>
<li><a href="../de414881/index.html">Ein bisschen Backstage VK</a></li>
<li><a href="../de414883/index.html">Erinnerungen klangen neu: BBC hat das Soundarchiv des RemArc-Projekts aktualisiert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>