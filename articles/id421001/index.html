<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíí üßëüèø‚Äçü§ù‚Äçüßëüèø üò∞ RPC - kesempatan untuk mencoba yang baru di C ++ 14/17 üïµüèø üçä üÜë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa tahun yang lalu, pengembang C ++ menerima standar C ++ 11 yang telah lama ditunggu-tunggu, yang membawa banyak hal baru. Dan saya memiliki mi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RPC - kesempatan untuk mencoba yang baru di C ++ 14/17</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421001/"><img src="https://habrastorage.org/webt/r5/fg/-w/r5fg-wsld9ujbwxghq54s-kpaso.jpeg" width="250" height="180" align="left">  Beberapa tahun yang lalu, pengembang C ++ menerima standar C ++ 11 yang telah lama ditunggu-tunggu, yang membawa banyak hal baru.  Dan saya memiliki minat untuk dengan cepat beralih ke penggunaannya dalam tugas sehari-hari.  Pergi ke C ++ 14 dan 17 ini bukan.  Tampaknya tidak ada set fitur yang akan menarik.  Pada musim semi, saya memutuskan untuk melihat inovasi bahasa dan mencoba sesuatu.  Untuk bereksperimen dengan inovasi, Anda harus membuat sendiri tugas.  Saya tidak perlu berpikir panjang.  Diputuskan untuk menulis RPC Anda dengan struktur data khusus sebagai parameter dan tanpa menggunakan makro dan pembuatan kode - semuanya dalam C ++.  Ini dimungkinkan berkat fitur baru bahasa tersebut. <br><br>  Ide, implementasi, umpan balik dengan Reddit, perbaikan - semuanya muncul di musim semi, awal musim panas.  Pada akhirnya, mereka berhasil menyelesaikan pos di Habr. <br><br>  Sudahkah Anda memikirkan RPC Anda sendiri?  Mungkin materi posting akan membantu Anda menentukan tujuan, metode, sarana dan memutuskan mendukung yang selesai atau mengimplementasikan sesuatu sendiri ... <br><a name="habracut"></a><br><h1>  Pendahuluan </h1><br>  RPC (panggilan prosedur jarak jauh) bukan topik baru.  Ada banyak implementasi dalam berbagai bahasa pemrograman.  Implementasi menggunakan berbagai format data dan mode transportasi.  Semua ini dapat tercermin dalam beberapa poin: <br><br><ul><li>  Serialisasi / Deserialisasi </li><li>  Transportasi </li><li>  Eksekusi metode jarak jauh </li><li>  Hasil kembali </li></ul><br>  Implementasi ditentukan oleh tujuan yang diinginkan.  Misalnya, Anda dapat menetapkan sendiri tujuan untuk memastikan metode panggilan jarak jauh yang cepat dan mengorbankan kegunaan, atau sebaliknya, untuk memberikan kenyamanan maksimal untuk menulis kode, mungkin kehilangan sedikit performa.  Tujuan dan alatnya berbeda ... Saya menginginkan kenyamanan dan kinerja yang dapat diterima. <br><br><h1>  Implementasi </h1><br>  Berikut adalah beberapa langkah untuk mengimplementasikan RPC di C ++ 14/17, dan penekanan diberikan pada beberapa inovasi bahasa yang menyebabkan materi ini muncul. <br><br>  Materi ini ditujukan bagi mereka yang karena alasan tertentu tertarik pada RPC mereka, dan, mungkin, sejauh ini, membutuhkan informasi tambahan.  Dalam komentar, akan menarik untuk melihat deskripsi pengalaman pengembang lain yang menghadapi tugas serupa. <br><br><h2>  Serialisasi </h2><br>  Sebelum Anda mulai menulis kode, saya akan membentuk tugas: <br><br><ul><li>  Semua parameter metode dan hasil yang dikembalikan dilewatkan melalui tuple. </li><li>  Metode yang disebut sendiri tidak berkewajiban untuk menerima dan mengembalikan tupel. </li><li>  Hasil pengemasan tuple harus berupa buffer yang formatnya tidak diperbaiki </li></ul><br>  Berikut ini adalah kode serializer string yang disederhanakan. <br><br><div class="spoiler">  <b class="spoiler_title">string_serializer</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> rpc::type { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> buffer = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;; } <span class="hljs-comment"><span class="hljs-comment">// namespace rpc::type namespace rpc::packer { class string_serializer final { public: template &lt;typename ... T&gt; type::buffer save(std::tuple&lt;T ... &gt; const &amp;tuple) const { auto str = to_string(tuple, std::make_index_sequence&lt;sizeof ... (T)&gt;{}); return {begin(str), end(str)}; } template &lt;typename ... T&gt; void load(type::buffer const &amp;buffer, std::tuple&lt;T ... &gt; &amp;tuple) const { std::string str{begin(buffer), end(buffer)}; from_string(std::move(str), tuple, std::make_index_sequence&lt;sizeof ... (T)&gt;{}); } private: template &lt;typename T, std::size_t ... I&gt; std::string to_string(T const &amp;tuple, std::index_sequence&lt;I ... &gt;) const { std::stringstream stream; auto put_item = [&amp;stream] (auto const &amp;i) { if constexpr (std::is_same_v&lt;std::decay_t&lt;decltype(i)&gt;, std::string&gt;) stream &lt;&lt; std::quoted(i) &lt;&lt; ' '; else stream &lt;&lt; i &lt;&lt; ' '; }; (put_item(std::get&lt;I&gt;(tuple)), ... ); return std::move(stream.str()); } template &lt;typename T, std::size_t ... I&gt; void from_string(std::string str, T &amp;tuple, std::index_sequence&lt;I ... &gt;) const { std::istringstream stream{std::move(str)}; auto get_item = [&amp;stream] (auto &amp;i) { if constexpr (std::is_same_v&lt;std::decay_t&lt;decltype(i)&gt;, std::string&gt;) stream &gt;&gt; std::quoted(i); else stream &gt;&gt; i; }; (get_item(std::get&lt;I&gt;(tuple)), ... ); } }; } // namespace rpc::packer</span></span></code> </pre> </div></div><br>  Dan kode fungsi utama menunjukkan operasi serializer. <br><br><div class="spoiler">  <b class="spoiler_title">Fungsi utama</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple args{<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{<span class="hljs-string"><span class="hljs-string">"Test string !!!"</span></span>}, <span class="hljs-number"><span class="hljs-number">3.14</span></span>}; rpc::packer::string_serializer serializer; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pack = serializer.save(args); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Pack data: "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{begin(pack), end(pack)} &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(args) params; serializer.load(pack, params); <span class="hljs-comment"><span class="hljs-comment">// For test { auto pack = serializer.save(params); std::cout &lt;&lt; "Deserialized pack: " &lt;&lt; std::string{begin(pack), end(pack)} &lt;&lt; std::endl; } } catch (std::exception const &amp;e) { std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; std::endl; return EXIT_FAILURE; } return EXIT_SUCCESS; }</span></span></code> </pre></div></div><br>  <b>Aksen terakreditasi</b> <br><br>  Pertama-tama, Anda perlu menentukan buffer yang dengannya seluruh pertukaran data akan dilakukan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> rpc::type { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> buffer = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;; } <span class="hljs-comment"><span class="hljs-comment">// namespace rpc::type</span></span></code> </pre><br>  Serializer memiliki metode untuk menyimpan tuple ke buffer (simpan) dan memuatnya dari buffer (memuat) <br><br>  Metode save mengambil tuple dan mengembalikan buffer. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... T&gt; type::<span class="hljs-function"><span class="hljs-function">buffer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::tuple&lt;T ... &gt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;tuple)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> str = to_string(tuple, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_index_sequence&lt;<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> ... (T)&gt;{}); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {begin(str), end(str)}; }</code> </pre><br>  Sebuah tuple adalah templat dengan sejumlah parameter variabel.  Pola seperti itu muncul di C ++ 11 dan bekerja dengan baik.  Di sini Anda harus melalui semua elemen dari template semacam itu.  Mungkin ada beberapa opsi.  Saya akan menggunakan salah satu fitur C ++ 14 - urutan bilangan bulat (indeks).  Tipe make_index_afterence telah muncul di pustaka standar, yang memungkinkan untuk mendapatkan urutan berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ints</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">integer_sequence</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">N</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">make_integer_sequence</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:integer_sequence&lt;T, <span class="hljs-comment"><span class="hljs-comment">/* a sequence 0, 1, 2, ..., N-1 */</span></span> &gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> make_index_sequence = make_integer_sequence&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>, N&gt;;</code> </pre><br>  Yang serupa dapat diimplementasikan dalam C ++ 11, dan kemudian membawanya dari proyek ke proyek. <br><br>  Urutan indeks seperti itu memungkinkan untuk "melewati" tuple: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ... I&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;tuple, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::index_sequence&lt;I ... &gt;)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">stringstream</span></span> stream; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> put_item = [&amp;stream] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same_v&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(i)&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;) stream &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::quoted(i) &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> stream &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; }; (put_item(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;I&gt;(tuple)), ... ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(stream.str()); }</code> </pre><br>  Metode to_string menggunakan beberapa fitur dari standar C ++ terbaru. <br><br>  <b>Aksen terakreditasi</b> <br><br>  Dalam C ++ 14, menjadi mungkin untuk menggunakan otomatis sebagai parameter untuk fungsi lambda.  Ini sering kali tidak cukup, misalnya, ketika bekerja dengan algoritma perpustakaan standar. <br><br>  <b>Konvolusi</b> muncul di C ++ 17, yang memungkinkan Anda menulis kode seperti: <br><br><pre> <code class="cpp hljs">(put_item(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;I&gt;(tuple)), ... );</code> </pre><br>  Dalam fragmen yang diberikan, fungsi put_item lambda dipanggil untuk setiap elemen dari tuple yang ditransfer.  Ini menjamin urutan independen dari platform dan kompiler.  Hal serupa dapat ditulis dalam C ++ 11. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ‚Ä¶ T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unused</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T &amp;&amp; ‚Ä¶ )</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// ... unused(put_item(std::get&lt;I&gt;(tuple)) ... );</span></span></code> </pre><br>  Tetapi dalam urutan apa elemen-elemen yang akan disimpan akan tergantung pada kompiler. <br><br>  Banyak alias muncul di pustaka standar C ++ 17, misalnya, decay_t, yang mengurangi catatan formulir: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> decay&lt;T&gt;::type</code> </pre><br>  Keinginan untuk menulis konstruksi yang lebih pendek memiliki tempatnya.  Desain template, di mana beberapa jenis nama dan template ditemukan dalam satu baris, dipisahkan oleh titik dua dan kurung sudut, terlihat menyeramkan.  Bagaimana Anda bisa menakuti beberapa kolega Anda.  Di masa depan, mereka berjanji untuk mengurangi jumlah tempat di mana Anda perlu menulis templat, ketik nama. <br><br>  Keinginan untuk keringkasan memberi konstruksi menarik lain dari bahasa "jika constexpr", menghindari menulis banyak spesialisasi pribadi template. <br><br>  Ada satu hal yang menarik.  Banyak yang telah diajarkan bahwa saklar dan konstruksi serupa tidak terlalu bagus dalam hal skalabilitas kode.  Lebih disukai menggunakan polimorfisme run-time / compile-time dan overload dengan argumen yang mendukung ‚Äúpilihan yang tepat‚Äù.  Dan kemudian "jika constexpr" ... Kemungkinan kekompakan tidak membuat semua orang acuh terhadapnya.  Kemungkinan bahasa tidak berarti kebutuhan untuk menggunakannya. <br><br>  Itu perlu untuk menulis serialisasi terpisah untuk tipe string.  Untuk pekerjaan yang mudah dengan string, misalnya, ketika menyimpan ke aliran dan membaca darinya, fungsi std :: dikutip muncul.  Ini memungkinkan Anda untuk menyaring string dan memungkinkan untuk menyimpan ke aliran dan memuat tanggal darinya tanpa memikirkan pembatas. <br><br>  Anda dapat berhenti dengan deskripsi serialisasi untuk saat ini.  Deserialization (beban) diimplementasikan dengan cara yang sama. <br><br><h2>  Transportasi </h2><br>  Transportasi sederhana.  Ini adalah fungsi yang menerima dan mengembalikan buffer. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> rpc::type { <span class="hljs-comment"><span class="hljs-comment">// ... using executor = std::function&lt;buffer (buffer)&gt;; } // namespace rpc::type</span></span></code> </pre><br>  Membentuk objek seperti "eksekutor" menggunakan std :: bind, fungsi lambda, dll., Anda dapat menggunakan implementasi transportasi apa pun.  Detail pelaksanaan transportasi dalam pos ini tidak akan dipertimbangkan.  Anda dapat melihat implementasi RPC yang telah selesai, tautan yang akan diberikan di bagian akhir. <br><br><h2>  Pelanggan </h2><br>  Di bawah ini adalah kode klien uji.  Klien membuat permintaan dan mengirimkannya ke server, dengan mempertimbangkan transportasi yang dipilih.  Dalam kode pengujian di bawah ini, semua permintaan klien ditampilkan di konsol.  Dan pada langkah implementasi selanjutnya, klien sudah akan berkomunikasi langsung dengan server. <br><br><div class="spoiler">  <b class="spoiler_title">Pelanggan</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> rpc { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TPacker&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">client</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">result</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: client(type::executor executor) : executor_{executor} { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... TArgs&gt; <span class="hljs-function"><span class="hljs-function">result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;func_name, TArgs &amp;&amp; ... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> request = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(func_name, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgs&gt;(args) ... ); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pack = packer_.save(request); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> responce = executor_(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(pack)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {responce}; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> packer_type = TPacker; packer_type packer_; type::executor executor_; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">result</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: result(type::buffer buffer) : buffer_{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(buffer)} { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;T&gt;&gt; tuple; packer_.load(buffer_, tuple); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(tuple)); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: packer_type packer_; type::buffer buffer_; }; }; } <span class="hljs-comment"><span class="hljs-comment">// namespace rpc</span></span></code> </pre></div></div><br>  Klien diimplementasikan sebagai kelas templat.  Parameter template adalah serializer.  Jika perlu, kelas dapat diulang tidak dalam satu template dan diteruskan ke konstruktor objek yang mengimplementasikan serializer. <br><br>  Dalam implementasi saat ini, konstruktor kelas menerima objek yang mengeksekusi.  Kontraktor menyembunyikan implementasi transportasi dengan sendirinya, dan memungkinkan pada titik ini dalam kode untuk tidak memikirkan metode pertukaran data antar proses.  Dalam kasus uji, implementasi transportasi menampilkan permintaan ke konsol. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> executor = [] (rpc::type::buffer buffer) { <span class="hljs-comment"><span class="hljs-comment">// Print request data std::cout &lt;&lt; "Request pack: " &lt;&lt; std::string{begin(buffer), end(buffer)} &lt;&lt; std::endl; return buffer; };</span></span></code> </pre><br>  Kode khusus belum mencoba mengambil keuntungan dari hasil pekerjaan klien, karena tidak ada tempat untuk mendapatkannya. <br><br>  <b>Metode panggilan klien:</b> <br><br><ul><li>  menggunakan serializer mengemas nama metode yang dipanggil dan parameternya </li><li>  menggunakan objek yang mengeksekusi mengirim permintaan ke server dan menerima respons </li><li>  meneruskan respons yang diterima ke kelas yang mengambil hasil yang diterima </li></ul><br>  Implementasi klien dasar sudah siap.  Sesuatu yang tersisa.  Lebih lanjut tentang ini nanti. <br><br><h2>  Server </h2><br>  Sebelum mulai mempertimbangkan detail implementasi dari sisi server, saya sarankan untuk melihat dengan cepat dan diagonal pada contoh interaksi klien-server yang sudah selesai. <br><br>  Untuk kesederhanaan, demonstrasi semuanya dalam satu proses.  Implementasi transportasi adalah fungsi lambda yang melewati buffer antara klien dan server. <br><br><div class="spoiler">  <b class="spoiler_title">Interaksi klien-server.</b>  <b class="spoiler_title">Uji kasus</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdint&gt; #include &lt;cstdlib&gt; #include &lt;functional&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;sstream&gt; #include &lt;string&gt; #include &lt;tuple&gt; #include &lt;vector&gt; #include &lt;utility&gt; namespace rpc::type { using buffer = std::vector&lt;char&gt;; using executor = std::function&lt;buffer (buffer)&gt;; } // namespace rpc::type namespace rpc::detail { template &lt;typename&gt; struct function_meta; template &lt;typename TRes, typename ... TArgs&gt; struct function_meta&lt;std::function&lt;TRes (TArgs ... )&gt;&gt; { using result_type = std::decay_t&lt;TRes&gt;; using args_type = std::tuple&lt;std::decay_t&lt;TArgs&gt; ... &gt;; using request_type = std::tuple&lt;std::string, std::decay_t&lt;TArgs&gt; ... &gt;; }; } // namespace rpc::detail namespace rpc::packer { class string_serializer final { public: template &lt;typename ... T&gt; type::buffer save(std::tuple&lt;T ... &gt; const const &amp;tuple) const { auto str = to_string(tuple, std::make_index_sequence&lt;sizeof ... (T)&gt;{}); return {begin(str), end(str)}; } template &lt;typename ... T&gt; void load(type::buffer const &amp;buffer, std::tuple&lt;T ... &gt; &amp;tuple) const { std::string str{begin(buffer), end(buffer)}; from_string(std::move(str), tuple, std::make_index_sequence&lt;sizeof ... (T)&gt;{}); } private: template &lt;typename T, std::size_t ... I&gt; std::string to_string(T const &amp;tuple, std::index_sequence&lt;I ... &gt;) const { std::stringstream stream; auto put_item = [&amp;stream] (auto const &amp;i) { if constexpr (std::is_same_v&lt;std::decay_t&lt;decltype(i)&gt;, std::string&gt;) stream &lt;&lt; std::quoted(i) &lt;&lt; ' '; else stream &lt;&lt; i &lt;&lt; ' '; }; (put_item(std::get&lt;I&gt;(tuple)), ... ); return std::move(stream.str()); } template &lt;typename T, std::size_t ... I&gt; void from_string(std::string str, T &amp;tuple, std::index_sequence&lt;I ... &gt;) const { std::istringstream stream{std::move(str)}; auto get_item = [&amp;stream] (auto &amp;i) { if constexpr (std::is_same_v&lt;std::decay_t&lt;decltype(i)&gt;, std::string&gt;) stream &gt;&gt; std::quoted(i); else stream &gt;&gt; i; }; (get_item(std::get&lt;I&gt;(tuple)), ... ); } }; } // namespace rpc::packer namespace rpc { template &lt;typename TPacker&gt; class client final { private: class result; public: client(type::executor executor) : executor_{executor} { } template &lt;typename ... TArgs&gt; result call(std::string const &amp;func_name, TArgs &amp;&amp; ... args) { auto request = std::make_tuple(func_name, std::forward&lt;TArgs&gt;(args) ... ); auto pack = packer_.save(request); auto responce = executor_(std::move(pack)); return {responce}; } private: using packer_type = TPacker; packer_type packer_; type::executor executor_; class result final { public: result(type::buffer buffer) : buffer_{std::move(buffer)} { } template &lt;typename T&gt; auto as() const { std::tuple&lt;std::decay_t&lt;T&gt;&gt; tuple; packer_.load(buffer_, tuple); return std::move(std::get&lt;0&gt;(tuple)); } private: packer_type packer_; type::buffer buffer_; }; }; template &lt;typename TPacker&gt; class server final { public: template &lt;typename ... THandler&gt; server(std::pair&lt;char const *, THandler&gt; const &amp; ... handlers) { auto make_executor = [&amp;packer = packer_] (auto const &amp;handler) { auto executor = [&amp;packer, function = std::function{handler}] (type::buffer buffer) { using meta = detail::function_meta&lt;std::decay_t&lt;decltype(function)&gt;&gt;; typename meta::request_type request; packer.load(buffer, request); auto response = std::apply([&amp;function] (std::string const &amp;, auto &amp;&amp; ... args) { return function(std::forward&lt;decltype(args)&gt;(args) ... ); }, std::move(request) ); return packer.save(std::make_tuple(std::move(response))); }; return executor; }; (handlers_.emplace(handlers.first, make_executor(handlers.second)), ... ); } type::buffer execute(type::buffer buffer) { std::tuple&lt;std::string&gt; pack; packer_.load(buffer, pack); auto func_name = std::move(std::get&lt;0&gt;(pack)); auto const iter = handlers_.find(func_name); if (iter == end(handlers_)) throw std::runtime_error{"Function \"" + func_name + "\" not found."}; return iter-&gt;second(std::move(buffer)); } private: using packer_type = TPacker; packer_type packer_; using handlers_type = std::map&lt;std::string, type::executor&gt;; handlers_type handlers_; }; } // namespace rpc int main() { try { using packer_type = rpc::packer::string_serializer; rpc::server&lt;packer_type&gt; server{ std::pair{"hello", [] (std::string const &amp;s) { std::cout &lt;&lt; "Func: \"hello\". Inpur string: " &lt;&lt; s &lt;&lt; std::endl; return "Hello " + s + "!"; }}, std::pair{"to_int", [] (std::string const &amp;s) { std::cout &lt;&lt; "Func: \"to_int\". Inpur string: " &lt;&lt; s &lt;&lt; std::endl; return std::stoi(s); }} }; auto executor = [&amp;server] (rpc::type::buffer buffer) { return server.execute(std::move(buffer)); }; rpc::client&lt;packer_type&gt; client{std::move(executor)}; std::cout &lt;&lt; client.call("hello", std::string{"world"}).as&lt;std::string&gt;() &lt;&lt; std::endl; std::cout &lt;&lt; "Convert to int: " &lt;&lt; client.call("to_int", std::string{"100500"}).as&lt;int&gt;() &lt;&lt; std::endl; } catch (std::exception const &amp;e) { std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; std::endl; return EXIT_FAILURE; } return EXIT_SUCCESS; }</span></span></span></span></code> </pre></div></div><br>  Dalam implementasi kelas server di atas, hal yang paling menarik adalah konstruktor dan metode eksekusi. <br><br>  <b>Konstruktor kelas server</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... THandler&gt; server(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *, THandler&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; ... handlers) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> make_executor = [&amp;packer = packer_] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;handler) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> executor = [&amp;packer, function = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function{handler}] (type::buffer buffer) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> meta = detail::function_meta&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(function)&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> meta::request_type request; packer.load(buffer, request); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> response = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::apply([&amp;function] (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp; ... args) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> function(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(args)&gt;(args) ... ); }, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(request) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> packer.save(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(response))); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> executor; }; (handlers_.emplace(handlers.first, make_executor(handlers.second)), ... ); }</code> </pre><br>  Konstruktor kelas adalah boilerplate.  Pada input dibutuhkan daftar pasangan.  Setiap pasangan adalah nama metode dan penangan.  Dan karena konstruktor adalah templat dengan sejumlah variabel parameter, saat membuat objek server, semua penangan yang tersedia di server terdaftar segera.  Itu akan memungkinkan untuk tidak membuat metode pendaftaran tambahan yang disebut pada penangan server.  Dan, pada gilirannya, membebaskan seseorang dari memikirkan apakah objek kelas server akan digunakan dalam lingkungan multi-threaded dan apakah sinkronisasi diperlukan. <br><br>  <b>Sebuah fragmen dari konstruktor dari kelas server</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... THandler&gt; server(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *, THandler&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; ... handlers) { <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶ (handlers_.emplace(handlers.first, make_executor(handlers.second)), ... ); }</span></span></code> </pre><br>  Menempatkan banyak penangan heterogen yang lulus ke dalam peta fungsi dari jenis yang sama.  Untuk ini, konvolusi juga digunakan, yang membuatnya mudah untuk dimasukkan ke dalam std :: map seluruh set handler yang lulus dalam satu baris tanpa loop dan algoritma <br><br><pre> <code class="cpp hljs">(handlers_.emplace(handlers.first, make_executor(handlers.second)), ... );</code> </pre><br>  Fungsi Lambda yang memungkinkan penggunaan otomatis sebagai parameter membuatnya mudah untuk menerapkan jenis pembungkus yang sama pada penangan.  Wraps dari jenis yang sama terdaftar di peta metode yang tersedia di server (std :: map).  Saat memproses permintaan, pencarian dilakukan pada kartu tersebut, dan penangan yang sama memanggil penangan yang ditemukan, terlepas dari parameter yang diterima dan hasil yang dikembalikan.  Fungsi std :: apply yang muncul di pustaka standar memanggil fungsi yang diteruskan ke sana dengan parameter yang dikirimkan sebagai tuple.  Fungsi std :: apply juga dapat diimplementasikan dalam C ++ 11.  Sekarang sudah tersedia "out of the box" dan tidak perlu mentransfernya dari proyek ke proyek. <br><br>  <b>Jalankan metode</b> <br><br><pre> <code class="cpp hljs">type::<span class="hljs-function"><span class="hljs-function">buffer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(type::buffer buffer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; pack; packer_.load(buffer, pack); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> func_name = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(pack)); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> iter = handlers_.find(func_name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iter == end(handlers_)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error{<span class="hljs-string"><span class="hljs-string">"Function \""</span></span> + func_name + <span class="hljs-string"><span class="hljs-string">"\" not found."</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iter-&gt;second(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(buffer)); }</code> </pre><br>  Mengambil nama fungsi yang dipanggil, mencari metode di peta penangan terdaftar, memanggil penangan dan mengembalikan hasilnya.  Semua yang menarik dalam pembungkus disiapkan di konstruktor kelas server.  Seseorang mungkin telah memperhatikan pengecualian, dan mungkin muncul pertanyaan: "Apakah pengecualiannya ditangani entah bagaimana?"  Ya, dalam implementasi penuh, yang akan diberikan dengan referensi di akhir, pengecualian marshaling disediakan.  Di sana untuk menyederhanakan materi, pengecualian tidak diberikan antara klien dan server. <br><br>  Lihatlah fungsinya <br><br><div class="spoiler">  <b class="spoiler_title">utama</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> packer_type = rpc::packer::string_serializer; rpc::server&lt;packer_type&gt; server{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair{<span class="hljs-string"><span class="hljs-string">"hello"</span></span>, [] (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;s) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Func: \"hello\". Inpur string: "</span></span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello "</span></span> + s + <span class="hljs-string"><span class="hljs-string">"!"</span></span>; }}, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair{<span class="hljs-string"><span class="hljs-string">"to_int"</span></span>, [] (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;s) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Func: \"to_int\". Inpur string: "</span></span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::stoi(s); }} }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> executor = [&amp;server] (rpc::type::buffer buffer) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> server.execute(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(buffer)); }; rpc::client&lt;packer_type&gt; client{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(executor)}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; client.call(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{<span class="hljs-string"><span class="hljs-string">"world"</span></span>}).as&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Convert to int: "</span></span> &lt;&lt; client.call(<span class="hljs-string"><span class="hljs-string">"to_int"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{<span class="hljs-string"><span class="hljs-string">"100500"</span></span>}).as&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;e) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error: "</span></span> &lt;&lt; e.what() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EXIT_FAILURE; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EXIT_SUCCESS; }</code> </pre></div></div><br>  Ini mengimplementasikan interaksi klien-server penuh.  Agar tidak menyulitkan materi, klien dan server bekerja dalam satu proses.  Mengganti implementasi pelaksana, Anda dapat menggunakan transportasi yang diperlukan. <br><br>  Dalam standar C ++ 17, kadang-kadang mungkin untuk tidak menentukan parameter template di instantiation.  Dalam fungsi utama di atas, ini digunakan ketika mendaftarkan penangan server (std :: pair tanpa parameter template) dan membuat kode lebih sederhana. <br><br>  Implementasi RPC dasar sudah siap.  Tetap menambahkan kemampuan yang dijanjikan untuk melewati struktur data khusus sebagai parameter dan mengembalikan hasil. <br><br><h2>  Struktur data khusus </h2><br>  Untuk mentransfer data melintasi batas proses, mereka perlu diserialisasi menjadi sesuatu.  Misalnya, Anda dapat menampilkan semuanya ke aliran standar.  Banyak yang akan didukung di luar kotak.  Untuk struktur data khusus, Anda harus mengimplementasikan sendiri operator keluaran.  Setiap struktur membutuhkan operator keluarannya sendiri.  Terkadang Anda ingin tidak melakukan ini.  Untuk memilah-milah semua bidang struktur dan output masing-masing bidang ke aliran, Anda memerlukan beberapa metode umum.  Refleksi dapat membantu dengan baik dalam hal ini.  Itu belum di C ++.  Anda dapat menggunakan pembuatan kode dan penggunaan campuran makro dan templat.  Tapi idenya adalah membuat antarmuka pustaka di C ++ murni. <br><br>  Belum ada refleksi penuh dalam C ++.  Oleh karena itu, solusi di bawah ini dapat digunakan dengan beberapa batasan. <br><br>  Solusi ini didasarkan pada penggunaan fitur C ++ 17 "binding terstruktur" baru.  Seringkali dalam dialog Anda dapat menemukan banyak jargon, jadi saya menolak opsi apa pun untuk nama fitur ini dalam bahasa Rusia. <br><br>  Di bawah ini adalah solusi yang memungkinkan Anda untuk mentransfer bidang struktur data yang ditransfer ke tuple. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_tuple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T &amp;&amp;value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;T&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(is_braces_constructible_v&lt;type, dummy_type, dummy_type, dummy_type&gt;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;[f1, f2, f3] = value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(f1, f2, f3); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> (is_braces_constructible_v&lt;type, dummy_type, dummy_type&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;[f1, f2] = value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(f1, f2); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> (is_braces_constructible_v&lt;type, dummy_type&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;[f1] = value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(f1); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(); } }</code> </pre><br>  Di Internet Anda dapat menemukan banyak solusi serupa. <br><br>  Banyak dari apa yang digunakan di sini dikatakan di atas, kecuali untuk binding terstruktur.  Fungsi to_tuple menerima jenis kustom, menentukan jumlah bidang, dan dengan bantuan binding terstruktur "mentransfer" bidang struktur ke tupel.  Dan "jika constexpr" memungkinkan Anda untuk memilih cabang implementasi yang diinginkan.  Karena tidak ada refleksi dalam C ++, solusi lengkap yang memperhitungkan semua aspek dari tipe tidak dapat dibangun.  Ada batasan pada jenis yang digunakan.  Salah satunya - jenisnya harus tanpa konstruktor khusus. <br><br>  To_tuple menggunakan is_braces_constructible_v.  Jenis ini memungkinkan Anda untuk menentukan kemampuan menginisialisasi struktur yang ditransfer menggunakan kurung kurawal dan menentukan jumlah bidang. <br><br><div class="spoiler">  <b class="spoiler_title">is_braces_constructible_v</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dummy_type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *&gt;(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... TArgs&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">(T{</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TArgs&gt;() ... }), </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::true_type&gt;())</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_braces_constructible</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... &gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">false_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_braces_constructible</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... TArgs&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_braces_constructible_v = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(is_braces_constructible&lt;T, TArgs ... &gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>))&gt;::value;</code> </pre></div></div><br>  Fungsi to_tuple di atas dapat mengubah struktur data pengguna yang berisi tidak lebih dari tiga bidang menjadi tupel.  Untuk menambah jumlah kemungkinan "bergeser" bidang struktur, Anda dapat menyalin cabang "jika constexpr" dengan inklusi kecil dari pikiran, atau menggunakan tidak hanya meningkatkan boost.prosesor perpustakaan.  Jika Anda memilih opsi kedua, kode akan menjadi sulit dibaca dan akan memungkinkan untuk menggunakan struktur dengan sejumlah besar bidang. <br><br><div class="spoiler">  <b class="spoiler_title">Menerapkan to_tuple dengan boost.preprosesor</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_tuple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T &amp;&amp;value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;T&gt;; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NANORPC_TO_TUPLE_LIMIT_FIELDS 64 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// you can try to use BOOST_PP_LIMIT_REPEAT #define NANORPC_TO_TUPLE_DUMMY_TYPE_N(_, n, data) \ BOOST_PP_COMMA_IF(n) data #define NANORPC_TO_TUPLE_PARAM_N(_, n, data) \ BOOST_PP_COMMA_IF(n) data ## n #define NANORPC_TO_TUPLE_ITEM_N(_, n, __) \ if constexpr (is_braces_constructible_v&lt;type, \ BOOST_PP_REPEAT_FROM_TO(0, BOOST_PP_SUB(NANORPC_TO_TUPLE_LIMIT_FIELDS, n), NANORPC_TO_TUPLE_DUMMY_TYPE_N, dummy_type) \ &gt;) { auto &amp;&amp;[ \ BOOST_PP_REPEAT_FROM_TO(0, BOOST_PP_SUB(NANORPC_TO_TUPLE_LIMIT_FIELDS, n), NANORPC_TO_TUPLE_PARAM_N, f) \ ] = value; return std::make_tuple( \ BOOST_PP_REPEAT_FROM_TO(0, BOOST_PP_SUB(NANORPC_TO_TUPLE_LIMIT_FIELDS, n), NANORPC_TO_TUPLE_PARAM_N, f) \ ); } else #define NANORPC_TO_TUPLE_ITEMS(n) \ BOOST_PP_REPEAT_FROM_TO(0, n, NANORPC_TO_TUPLE_ITEM_N, nil) NANORPC_TO_TUPLE_ITEMS(NANORPC_TO_TUPLE_LIMIT_FIELDS) { return std::make_tuple(); } #undef NANORPC_TO_TUPLE_ITEMS #undef NANORPC_TO_TUPLE_ITEM_N #undef NANORPC_TO_TUPLE_PARAM_N #undef NANORPC_TO_TUPLE_DUMMY_TYPE_N #undef NANORPC_TO_TUPLE_LIMIT_FIELDS }</span></span></span></span></code> </pre></div></div><br>  Jika Anda pernah mencoba melakukan sesuatu seperti boost.bind untuk C ++ 03, di mana Anda harus membuat banyak implementasi dengan jumlah parameter yang berbeda, maka implementasi to_tuple menggunakan boost.preprosesor tampaknya tidak aneh atau rumit. <br><br>  Dan jika dukungan tuple ditambahkan ke serializer, fungsi to_tuple akan mengaktifkan serialisasi struktur data pengguna.  Dan menjadi mungkin untuk mengkhianati mereka sebagai parameter dan mengembalikan hasil di RPC Anda. <br><br>  Selain struktur data yang ditentukan pengguna, C ++ memiliki tipe bawaan lain yang output ke aliran standar tidak diimplementasikan.  Keinginan untuk mengurangi jumlah operator output yang kelebihan beban dalam aliran mengarah ke kode umum yang memungkinkan satu metode untuk memproses sebagian besar wadah C ++, seperti std :: list, std :: vector, std :: map.  Tanpa lupa tentang SFINAE dan std :: enable_if_t, Anda dapat terus memperpanjang serializer.  Dalam hal ini, akan diperlukan untuk entah bagaimana menentukan secara tidak langsung properti tipe, mirip dengan apa yang dilakukan dalam implementasi is_braces_constructible_v. <br><br><h1>  Kesimpulan </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di luar ruang lingkup pos, pengecualian marshaling, transportasi, serialisasi wadah stl dan banyak lagi yang tersisa. </font><font style="vertical-align: inherit;">Agar tidak menyulitkan posting, hanya prinsip-prinsip umum yang diberikan di mana saya dapat membangun perpustakaan RPC saya dan menyelesaikan tugas asli yang ditetapkan untuk diri saya sendiri - untuk mencoba fitur C ++ 14/17 yang baru. Dan implementasi yang dihasilkan memungkinkan Anda untuk memanggil metode jarak jauh menggunakan HTTP / HTTPS yang tersebar luas dan berisi contoh penggunaan yang cukup rinci. </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">Kode</font></a></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> perpustakaan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NanoRPC di GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  Terima kasih atas perhatian anda! <br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id421001/">https://habr.com/ru/post/id421001/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../hi486174/index.html">‡§Æ‡•á‡§∞‡§æ ‡§ú‡•Ä‡§∞‡•ã ‡§ü‡§∞‡•ç‡§®‡§ì‡§µ‡§∞ ‡§π‡•à</a></li>
<li><a href="../id420993/index.html">5 langkah sederhana untuk membuat server untuk menguji permintaan REST android</a></li>
<li><a href="../id420995/index.html">Kami memilih kata sandi untuk TIN India dalam dua detik, atau mengapa brute force math</a></li>
<li><a href="../id420997/index.html">KDD 2018, Hari Keempat, Penerima Hadiah Nobel</a></li>
<li><a href="../id420999/index.html">Kivy. Xamarin Bereaksi Asli. Tiga kerangka kerja - satu percobaan (bagian 2)</a></li>
<li><a href="../id421005/index.html">REST-terjamin: Tips Berguna</a></li>
<li><a href="../id421007/index.html">Tape recorder - alat untuk merekam autotest</a></li>
<li><a href="../id421009/index.html">25 dan 26 Agustus: konferensi online tentang manajemen operasional</a></li>
<li><a href="../id421011/index.html">Pertanyaan pada wawancara yang menurut Anda bodoh. Tapi tidak juga</a></li>
<li><a href="../id421015/index.html">Survei Keberlanjutan 2018 untuk Segmen Internet Nasional</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>