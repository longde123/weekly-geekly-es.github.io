<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤲🏾 🤚 🙏🏾 استثناءات خاصة في .NET وكيفية إعدادها 👏🏿 🎒 🤠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="الاستثناءات المختلفة في .NET لها خصائصها الخاصة ، وقد يكون من المفيد جدًا التعرف عليها. كيفية خداع CLR؟ كيفية البقاء على قيد الحياة في وقت التشغيل عن ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>استثناءات خاصة في .NET وكيفية إعدادها</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/426045/" style=";text-align:right;direction:rtl">  الاستثناءات المختلفة في .NET لها خصائصها الخاصة ، وقد يكون من المفيد جدًا التعرف عليها.  كيفية خداع CLR؟  كيفية البقاء على قيد الحياة في وقت التشغيل عن طريق اللحاق StackOverflowException؟  ما الاستثناءات التي يبدو من المستحيل التقاطها ، ولكن إذا كنت تريد حقًا ، هل يمكنك ذلك؟ <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f1/314/78d/4f131478de33b4a6acd0ed25a0e53987.png"><br><br>  تحت القطع ، نص تقرير يوجين ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" class="user_link">epeshk</a> ) Peshkov من مؤتمر <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">DotNext 2018 Piter</a> ، حيث تحدث عن هذه الميزات وغيرها من الاستثناءات. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WLSrYgMWif4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  مرحبًا  اسمي يوجين.  أنا أعمل لدى SKB Kontur وأطور نظام استضافة ونشر تطبيقات لـ Windows.  خلاصة القول هي أن لدينا العديد من فرق المنتجات التي تكتب خدماتها وتستضيفها معنا.  نحن نقدم لهم حل سهل وبسيط لمجموعة متنوعة من مهام البنية التحتية.  على سبيل المثال ، لمراقبة استهلاك موارد النظام أو إنهاء النسخ المتماثلة للخدمة. <br><br>  في بعض الأحيان يتبين أن التطبيقات التي تتم استضافتها على نظامنا تنهار.  لقد رأينا العديد من الطرق لكيفية تعطل التطبيق في وقت التشغيل.  إحدى هذه الطرق هي التخلص من بعض الاستثناءات غير المتوقعة والساحرة. <br><br>  اليوم سأتحدث عن ميزات الاستثناءات في .NET.  واجهنا بعض هذه الميزات في الإنتاج ، وبعضها في سياق التجارب. <br><br><h2 style=";text-align:right;direction:rtl">  الخطة </h2><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  سلوك استثناء .NET <br></li><li style=";text-align:right;direction:rtl">  معالجة استثناءات Windows وعمليات الاختراق <br></li></ol><br>  كل ما يلي صحيح بالنسبة لنظام التشغيل Windows.  تم اختبار جميع الأمثلة على أحدث إصدار من إطار عمل .NET 4.7.1 الكامل.  سيكون هناك أيضًا بعض الإشارات إلى .NET Core. <br><br><h2 style=";text-align:right;direction:rtl">  انتهاك الوصول </h2><br>  يحدث هذا الاستثناء أثناء عمليات الذاكرة غير الصحيحة.  على سبيل المثال ، إذا حاول تطبيق الوصول إلى منطقة ذاكرة لا يمكنه الوصول إليها.  الاستثناء هو مستوى منخفض ، وعادةً ، إذا حدث ذلك ، فسيكون هناك حاجة إلى تصحيح طويل جدًا. <br><br>  دعونا نحاول الحصول على هذا الاستثناء باستخدام C #.  للقيام بذلك ، سنكتب بايت 42 على العنوان 1000 (نفترض أن 1000 عنوان عشوائي نوعًا ما وعلى الأرجح أن تطبيقنا لا يمكنه الوصول إليه). <br><br><pre style=";text-align:right;direction:rtl"><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Marshal.WriteByte((IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AccessViolationException) { ... }</code> </pre> <br>  يقوم WriteByte بما نحتاجه فقط: يكتب بايت إلى العنوان المحدد.  نتوقع من هذه المكالمة طرح AccessViolationException.  سوف يرمي هذا الرمز بالفعل هذا الاستثناء ، وسيكون قادرًا على التعامل معه وسيستمر التطبيق في العمل.  الآن دعنا نغير الشفرة قليلاً: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] {<span class="hljs-number"><span class="hljs-number">42</span></span>}; Marshal.Copy(bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, (IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, bytes.Length); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AccessViolationException) { ... }</code> </pre><br>  إذا استخدمت بدلاً من WriteByte أسلوب النسخ ونسخ البايت 42 إلى العنوان 1000 ، ثم باستخدام try-catch ، لا يمكن اكتشاف AccessViolation.  في نفس الوقت ، سيتم عرض رسالة على وحدة التحكم تفيد أنه تم إنهاء التطبيق بسبب AccessViolationException غير معالج. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">Marshal.Copy(bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, (IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, bytes.Length); Marshal.WriteByte((IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre><br>  اتضح أن لدينا سطرين من التعليمات البرمجية ، بينما يعطل الأول التطبيق بأكمله مع AccessViolation ، والثاني يطرح استثناء معالجًا من نفس النوع.  لفهم سبب حدوث ذلك ، سننظر في كيفية ترتيب هذه الأساليب من الداخل. <br><br>  لنبدأ مع طريقة النسخ. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Copy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...</span></span></span><span class="hljs-function">)</span></span> { Marshal.CopyToNative((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>) source, startIndex, destination, length); } [MethodImpl(MethodImplOptions.InternalCall)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyToNative</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> source, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startIndex, IntPtr destination, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  الشيء الوحيد الذي تفعله طريقة النسخ هو استدعاء طريقة CopyToNative ، التي يتم تنفيذها داخل .NET.  إذا استمر تعطل تطبيقنا وحدث استثناء في مكان ما ، فيمكن أن يحدث هذا فقط داخل CopyToNative.  من هنا يمكننا عمل الملاحظة الأولى: إذا حدث كود NET يسمى الكود الأصلي و AccessViolation بداخله ، فلن يتمكن كود .NET من معالجة هذا الاستثناء لسبب ما. <br><br>  الآن سوف نفهم لماذا كان من الممكن معالجة AccessViolation باستخدام أسلوب WriteByte.  دعونا نلقي نظرة على كود هذه الطريقة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteByte</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { *(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*) ptr = val; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (NullReferenceException) {     <span class="hljs-comment"><span class="hljs-comment">// this method is documented to throw AccessViolationException on any AV throw new AccessViolationException(); } }</span></span></code> </pre><br>  يتم تنفيذ هذه الطريقة بالكامل في التعليمات البرمجية المُدارة.  يستخدم مؤشر C # لكتابة البيانات إلى العنوان المطلوب ، كما أنه يمسك NullReferenceException.  إذا تم اعتراض NRE ، يتم طرح AccessViolationException.  لذلك من الضروري بسبب <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">المواصفات</a> .  في هذه الحالة ، يتم التعامل مع جميع الاستثناءات التي تم طرحها بواسطة بنية الرمي.  وفقًا لذلك ، في حالة حدوث NullReferenceException أثناء تنفيذ التعليمات البرمجية داخل WriteByte ، يمكننا التقاط AccessViolation.  هل يمكن أن تحدث NRE ، في حالتنا ، عند الوصول إلى العنوان 1000 بدلاً من العنوان صفر؟ <br><br>  نعيد كتابة الرمز باستخدام مؤشرات C # مباشرة ، ونرى أنه عند الوصول إلى عنوان غير صفري ، يتم طرح NullReferenceException فعليًا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">*(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*) <span class="hljs-number"><span class="hljs-number">1000</span></span> = <span class="hljs-number"><span class="hljs-number">42</span></span>;</code> </pre><br>  لفهم سبب حدوث ذلك ، نحتاج إلى تذكر كيفية عمل ذاكرة العملية.  في ذاكرة العملية ، جميع العناوين افتراضية.  هذا يعني أن التطبيق يحتوي على مساحة عنوان كبيرة ويتم عرض بعض الصفحات منه فقط في الذاكرة الفعلية الحقيقية.  ولكن هناك ميزة: أول 64 كيلوبايت من العناوين لا يتم تعيينها أبدًا للذاكرة الفعلية ولا يتم إعطاؤها للتطبيق.  يعرف Rantime .NET هذا ويستخدمه.  إذا حدث AccessViolation في التعليمات البرمجية المُدارة ، فإن وقت التشغيل يتحقق من العنوان الذي تم الوصول إليه في الذاكرة ويولد استثناء مناسبًا.  للعناوين من 0 إلى 2 ^ 16 - NullReference ، لجميع الآخرين - AccessViolation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/775/3d4/38f/7753d438fc8a977ac0bb54e431d81c6f.png"><br><br>  دعونا نرى لماذا يتم طرح NullReference ليس فقط عند الوصول إلى العنوان صفر.  تخيل أنك تصل إلى حقل كائن من النوع المرجعي وأن المرجع إلى هذا الكائن فارغ: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/127/a27/867/127a27867ef7a568a242797758855b44.png"><br><br>  في هذه الحالة ، نتوقع الحصول على NullReferenceException.  يحدث الوصول إلى حقل كائن بواسطة الإزاحة نسبة إلى عنوان هذا الكائن.  اتضح أننا سننتقل إلى عنوان قريب بما يكفي من الصفر (تذكر أن الرابط إلى كائننا الأصلي هو صفر).  مع سلوك وقت التشغيل هذا ، نحصل على الاستثناء المتوقع دون التحقق الإضافي من عنوان الكائن نفسه. <br><br>  ولكن ماذا يحدث إذا انتقلنا إلى حقل كائن ، وكان هذا الكائن نفسه يستهلك أكثر من 64 كيلوبايت؟ <br><br><img src="https://habrastorage.org/getpro/habr/post_images/356/897/143/356897143b1275403569dc9f9a71471a.png"><br><br>  هل يمكننا الحصول على AccessViolation في هذه الحالة؟  لنقم بتجربة.  لنقم بإنشاء كائن كبير جدًا وسنشير إلى حقوله.  حقل واحد في بداية الكائن ، والثاني في النهاية: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/08d/619/95a/08d61995a01630f94f31f759890af4a8.png"><br><br>  ستقوم كلتا الطريقتين بإلقاء NullReferenceException.  لن يحدث AccessViolationException. <br>  دعونا نلقي نظرة على التعليمات التي سيتم إنشاؤها لهذه الأساليب.  في الحالة الثانية ، أضاف المترجم JIT تعليمة cmp إضافية تصل إلى عنوان الكائن نفسه ، وبالتالي استدعاء AccessViolation بعنوان صفر ، والذي سيتم تحويله بواسطة وقت التشغيل إلى NullReferenceException. <br><br>  تجدر الإشارة إلى أنه في هذه التجربة لا يكفي استخدام مصفوفة ككائن كبير.  لماذا؟  اترك هذا السؤال للقارئ ، اكتب الأفكار في التعليقات :) <br><br>  دعونا نلخص التجارب مع AccessViolation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ffa/86b/0a8/ffa86b0a85f29a16936c92845f5d3e1e.png"><br><br>  يتصرف AccessViolationException بشكل مختلف اعتمادًا على مكان حدوث الاستثناء (في التعليمات البرمجية المُدارة أو في اللغة الأم).  بالإضافة إلى ذلك ، إذا حدث استثناء في التعليمات البرمجية المُدارة ، فسيتم التحقق من عنوان الكائن. <br><br>  السؤال هو: هل يمكننا التعامل مع AccessViolationException التي حدثت في التعليمات البرمجية الأصلية أو في التعليمات البرمجية المُدارة ، ولكن لم يتم تحويلها إلى NullReference ولا يتم طرحها باستخدام الرمي؟  هذه في بعض الأحيان ميزة مفيدة ، خاصة عند العمل مع رمز غير آمن.  تعتمد الإجابة على هذا السؤال على إصدار .NET. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/67a/785/318/67a785318bc8b5f084a3b23fa36e766b.png"><br><br>  في .NET 1.0 ، لم يكن هناك AccessViolationException على الإطلاق.  تم اعتبار جميع الروابط صالحة أو خالية.  بحلول وقت .NET 2.0 ، أصبح من الواضح أنه بدون العمل المباشر مع الذاكرة - لا توجد طريقة ، وظهرت AccessViolation ، بينما كانت قابلة للمعالجة.  في الإصدار 4.0 وما فوق ، لا يزال قابلاً للتطبيق ، ولكن معالجته ليست بهذه البساطة.  لالتقاط هذا الاستثناء ، تحتاج الآن إلى وضع علامة على الطريقة التي توجد بها كتلة الالتقاط بالسمة HandleProcessCorruptedStateException.  على ما يبدو ، قام المطورون بذلك لأنهم اعتقدوا أن AccessViolationException لم يكن الاستثناء الذي يجب اكتشافه في التطبيق العادي. <br>  بالإضافة إلى ذلك ، من أجل التوافق مع الإصدارات السابقة ، من الممكن استخدام إعدادات وقت التشغيل: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  legacyNullReferenceExceptionPolicy يُرجع سلوك .NET 1.0 - تتحول جميع مركبات AV إلى NRE <br></li><li style=";text-align:right;direction:rtl">  legacyCorruptedStateExceptionsPolicy تُرجع سلوك .NET 2.0 - يتم اعتراض جميع مركبات AV <br></li></ul><br>  في .NET ، لا يتم التعامل مع Core AccessViolation على الإطلاق. <br><br>  في إنتاجنا كان هناك مثل هذا الوضع: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad7/0f1/6d3/ad70f16d3438d1e8ab80e43ba29d5412.png"><br><br>  استخدم تطبيق تم إنشاؤه بموجب .NET 4.7.1 مكتبة تعليمات برمجية مشتركة تم إنشاؤها بموجب .NET 3.5.  كان هناك مساعد في هذه المكتبة لتشغيل إجراء دوري: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (isRunning) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { action(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { log.Error(e); } WaitForNextExecution(... ); }</code> </pre><br>  مررنا من تطبيقنا إلى هذا المساعد.  حدث ذلك أنه تحطم مع AccessViolation.  نتيجة لذلك ، سجل تطبيقنا باستمرار AccessViolation ، بدلاً من تعطله بسبب  الكود في المكتبة تحت 3.5 يمكن أن يمسك به.  وتجدر الإشارة إلى أن الاعتراض لا يعتمد على إصدار وقت التشغيل الذي يتم تشغيل التطبيق عليه ، ولكن على TargetFramework ، الذي تم إنشاء التطبيق بموجبه ، وتبعياته. <br><br>  لتلخيص.  تعتمد معالجة AccessVilolation على مكان نشأتها - في التعليمات البرمجية الأصلية أو المُدارة - بالإضافة إلى إعدادات TargetFramework ووقت التشغيل. <br><br><h2 style=";text-align:right;direction:rtl">  إحباط الموضوع </h2><br>  في بعض الأحيان في الكود تحتاج إلى إيقاف تنفيذ أحد سلاسل المحادثات.  للقيام بذلك ، يمكنك استخدام مؤشر الترابط. Abort ()؛ <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ThreadAbortException e) { ... Thread.ResetAbort(); } }); ... thread.Abort();</code> </pre><br>  عندما يتم استدعاء الأسلوب إحباط في مؤشر ترابط توقف ، يتم طرح ThreadAbortException.  دعونا نحلل ميزاته.  على سبيل المثال ، رمز مثل هذا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { … } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ThreadAbortException e) { … } }); ... thread.Abort();</code> </pre><br>  ما يعادل هذا تماما: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ThreadAbortException e) { ... <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } }); ... thread.Abort();</code> </pre><br>  إذا كنت لا تزال بحاجة إلى معالجة ThreadAbort وتنفيذ بعض الإجراءات الأخرى في سلسلة المحادثات المتوقفة ، فيمكنك استخدام طريقة Thread.ResetAbort () ؛  إنه يوقف عملية إيقاف التدفق ويتوقف الاستثناء عن الرمي أعلى المكدس.  من المهم أن نفهم أن أسلوب thread.Abort () نفسه لا يضمن أي شيء - قد يمنعه الرمز الموجود في مؤشر الترابط الذي تم إيقافه. <br><br>  ميزة أخرى في thread.Abort () هي أنه لن يكون قادرًا على مقاطعة الرمز إذا كان موجودًا في النهاية وأخيرًا يتم حظره. <br><br>  داخل كود الإطار ، يمكنك غالبًا العثور على طرق يكون فيها كتلة المحاولة فارغة ويكون كل المنطق بداخلها أخيرًا.  يتم ذلك فقط لمنع طرح هذا الرمز بواسطة ThreadAbortException. <br><br>  أيضاً ، ينتظر استدعاء الأسلوب thread.Abort () لـ ThreadAbortException ليتم طرحه.  اجمع بين هاتين الحقائقين واحصل على أن طريقة thread.Abort () يمكن أن تحظر مؤشر الترابط. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { }       <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { } <span class="hljs-comment"><span class="hljs-comment">// &lt;-- No ThreadAbortException in catch       finally { // &lt;-- No ThreadAbortException in finally           Thread.Sleep(- 1); } }); thread.Start(); ... thread.Abort(); // Never returns</span></span></code> </pre><br>  في الواقع ، يمكن مواجهة ذلك عند استخدام الاستخدام.  يتم نشرها في محاولة / أخيرا ، في النهاية ، تسمى طريقة التخلص.  يمكن أن يكون معقدًا بشكل تعسفي ، ويحتوي على معالجات الأحداث ، استخدم الأقفال.  وإذا تم استدعاء thread.Abort في وقت التشغيل ، فإن Dispose - thread.Abort () سينتظرها.  لذا نحصل على قفل من الصفر تقريبًا. <br><br>  في .NET Core ، يطرح أسلوب thread.Abort () PlatformNotSupportedException.  وأعتقد أن هذا أمر جيد للغاية ، لأنه يحفز استخدام ليس الخيط. Abort () ، ولكن الأساليب غير الغازية لوقف تنفيذ التعليمات البرمجية ، على سبيل المثال استخدام CancellationToken. <br><br><h2 style=";text-align:right;direction:rtl">  خارج الذاكرة </h2><br>  يمكن الحصول على هذا الاستثناء إذا كانت الذاكرة الموجودة على الجهاز أقل من المطلوب.  أو عندما واجهنا قيود عملية 32 بت.  ولكن يمكنك الحصول عليها حتى إذا كان الكمبيوتر يحتوي على الكثير من الذاكرة الفارغة ، والعملية 64 بت. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr4gb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue/<span class="hljs-number"><span class="hljs-number">2</span></span>];</code> </pre><br>  سوف يرمي الرمز أعلاه OutOfMemory.  الشيء هو أنه ، بشكل افتراضي ، لا يُسمح بالكائنات الأكبر من 2 غيغابايت.  يمكن إصلاح ذلك عن طريق تعيين gcAllowVeryLargeObjects في App.config.  في هذه الحالة ، يتم إنشاء صفيف 4 غيغابايت. <br><br>  الآن دعنا نحاول إنشاء مصفوفة أكثر. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> largeArr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue];</code> </pre><br>  الآن لن تساعد حتى gcAllowVeryLargeObjects.  وذلك لأن .NET لديها <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">حد على الفهرس الأقصى في المصفوفة</a> .  هذا التقييد أقل من int.MaxValue. <br><br>  مؤشر الصفيف ماكس: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  صفائف بايت - 0x7FFFFFC7 <br></li><li style=";text-align:right;direction:rtl">  صفائف أخرى - 0X7F <b>E</b> FFFFF <br></li></ul><br>  في هذه الحالة ، سيحدث OutOfMemoryException ، على الرغم من أننا واجهنا في الواقع قيودًا على نوع البيانات ، وليس نقصًا في الذاكرة. <br><br>  في بعض الأحيان يتم التخلص من OutOfMemory بشكل واضح من خلال التعليمات البرمجية المُدارة داخل .NET framework: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/efd/c84/d98/efdc84d98a7786e39c9c5931ac523d13.png"><br>  هذا هو تنفيذ أسلوب string.Concat.  إذا كان طول سلسلة النتائج أكبر من int.MaxValue ، يتم طرح OutOfMemoryException على الفور. <br><br>  دعنا ننتقل إلى الحالة عندما تنشأ OutOfMemory في حالة نفاد الذاكرة بالفعل. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">LimitMemory(<span class="hljs-number"><span class="hljs-number">64.</span></span>Mb()); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>)   list.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size]); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (OutOfMemoryException e) { Console.WriteLine(e); }</code> </pre><br>  أولاً ، نقصر ذاكرة العملية على 64 ميغابايت.  بعد ذلك ، داخل الحلقة ، حدد صفائف بايت جديدة ، واحفظها في بعض الورقة بحيث لا يجمعها GC ، وحاول التقاط OutOfMemory. <br><br>  في هذه الحالة ، يمكن أن يحدث أي شيء: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  تمت معالجة الاستثناء <br></li><li style=";text-align:right;direction:rtl">  ستنهار العملية <br></li><li style=";text-align:right;direction:rtl">  دعنا نذهب ، ولكن الاستثناء سيتعطل مرة أخرى <br></li><li style=";text-align:right;direction:rtl">  دعنا نذهب ، ولكن StackOverflow سوف يتعطل <br></li></ul><br>  في هذه الحالة ، لن يكون البرنامج نهائيًا.  دعونا نحلل جميع الخيارات: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يمكن معالجة الاستثناء.  داخل .NET ، لا يوجد شيء يمنعك من التعامل مع OutOfMemoryException. <br></li><li style=";text-align:right;direction:rtl">  قد تسقط العملية.  لا تنس أن لدينا تطبيق مُدار.  هذا يعني أنه لا يتم تنفيذ التعليمات البرمجية داخله فقط ، ولكن أيضًا رمز وقت التشغيل.  على سبيل المثال ، GC.  وبالتالي ، قد يحدث موقف عندما يريد وقت التشغيل تخصيص ذاكرة لنفسه ، ولكن لا يمكنه القيام بذلك ، فلن نتمكن من التقاط الاستثناء. <br></li><li style=";text-align:right;direction:rtl">  دعنا نذهب إلى الصيد ، لكن الاستثناء سيتعطل مرة أخرى.  داخل المصيد ، نقوم أيضًا بالمهمة حيث نحتاج إلى ذاكرة (نقوم بطباعة استثناء لوحدة التحكم) ، وهذا يمكن أن يتسبب في استثناء جديد. <br></li><li style=";text-align:right;direction:rtl">  دعنا نذهب ، ولكن StackOverflow سوف يتعطل.  يحدث StackOverflow نفسه عندما يتم استدعاء أسلوب WriteLine ، ولكن لا يوجد تجاوز سعة مكدس هنا ، ولكن يحدث موقف مختلف.  دعونا نحلل ذلك بمزيد من التفصيل. <br></li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/6e3/d32/752/6e3d32752ba10fd39d1f4a5e2e6648a7.png"><br><br>  في الذاكرة الافتراضية ، لا يمكن فقط تعيين الصفحات على الذاكرة الفعلية ، ولكن يمكن أيضًا حجزها.  إذا كانت الصفحة محجوزة ، فقد لاحظ التطبيق أنها ستستخدمها.  إذا تم تعيين الصفحة بالفعل على ذاكرة حقيقية أو مبادلة ، فعندئذٍ تسمى "ملتزم" (ملتزم).  يستخدم المكدس هذه القدرة لتقسيم الذاكرة إلى محجوزة وملتزمة.  يبدو شيء مثل هذا: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b17/9e4/41f/b179e441f0c00f18e2a5fdf12b3093a9.png"><br><br>  اتضح أننا نسمي طريقة WriteLine ، التي تأخذ مكانًا ما على المكدس.  اتضح أن كل الذاكرة المخصصة قد انتهت بالفعل ، مما يعني أن نظام التشغيل في هذه اللحظة يجب أن يأخذ صفحة محجوزة أخرى على المكدس ويعينها على ذاكرة فعلية حقيقية ، مليئة بالفعل بمصفوفات بايت.  هذا يؤدي إلى استثناء StackOverflow. <br><br>  سيسمح لك الكود التالي بتخصيص كل الذاكرة إلى المكدس في بداية الدفق في وقت واحد. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; F(), <span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>).Start();</code> </pre><br>  وبدلاً من ذلك ، يمكنك استخدام <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">إعداد وقت التشغيل</a> disableCommitThreadStack.  يجب تعطيله حتى يتم تنفيذ مكدس مؤشر الترابط مقدمًا.  تجدر الإشارة إلى أن السلوك الافتراضي الموصوف في التوثيق والملاحظ في الواقع مختلف. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/46e/0e6/dbd/46e0e6dbd47906fb1d0ddf74ac927383.png"><br><br><h2 style=";text-align:right;direction:rtl">  تجاوز سعة المكدس </h2><br>  دعونا نلقي نظرة فاحصة على StackOverflowException.  دعونا نلقي نظرة على مثالين من التعليمات البرمجية.  في أحدها ، نقوم بتشغيل العودية اللانهائية ، مما يؤدي إلى تجاوز سعة المكدس ، في الثانية نرمي هذا الاستثناء برمية. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { InfiniteRecursion(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception) { ... }</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StackOverflowException(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception) { ... }</code> </pre><br>  نظرًا لأن جميع الاستثناءات التي تم طرحها برمية يتم التعامل معها ، في الحالة الثانية سنلتقط الاستثناء.  ومع الحالة الأولى ، كل شيء أكثر إثارة للاهتمام.  أنتقل إلى <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">MSDN</a> : <br><br><blockquote style=";text-align:right;direction:rtl">  "لا يمكنك التقاط استثناءات تجاوز سعة المكدس ، لأن كود معالجة الاستثناء قد يتطلب المكدس." <br>  MSDN </blockquote><br>  تقول هنا أننا لن نتمكن من التقاط StackOverflowException ، لأن الاعتراض نفسه قد يتطلب مساحة مكدس إضافية قد انتهت بالفعل. <br><br>  للحماية بطريقة ما من هذا الاستثناء ، يمكننا القيام بما يلي.  أولاً ، يمكنك تحديد عمق العودية.  ثانيًا ، يمكنك استخدام أساليب فئة RuntimeHelpers: <br><br><blockquote style=";text-align:right;direction:rtl">  RuntimeHelpers.EnsureSufficientExecutionStack () ؛ <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  "يضمن أن مساحة المكدس المتبقية كبيرة بما يكفي لتنفيذ متوسط ​​وظيفة .NET Framework."  - MSDN <br></li><li style=";text-align:right;direction:rtl">  InsufficientExecutionStackException <br></li><li style=";text-align:right;direction:rtl">  512 كيلوبايت - x86 ، AnyCPU ، 2 ميجابايت - x64 (نصف حجم المكدس) <br></li><li style=";text-align:right;direction:rtl">  64/128 كيلوبايت - .NET Core <br></li><li style=";text-align:right;direction:rtl">  تحقق من مساحة عنوان المكدس فقط <br></li></ul><br></blockquote><br>  توضح وثائق هذه الطريقة أنها تتحقق من وجود مساحة كافية على المكدس لتنفيذ <i>متوسط</i> وظيفة .NET.  ولكن ما هي الوظيفة <i>المتوسطة</i> ؟  في الواقع ، في .NET Framework ، تتحقق هذه الطريقة من أن نصف حجمها على الأقل مجاني على المكدس.  في .NET Core ، يتحقق من وجود 64 كيلو بايت مجانًا. <br><br>  وقد ظهر أيضًا تناظري في .NET Core: RuntimeHelpers.TryEnsureSufficientExecutionStack () الذي يعيد منطقية ، بدلاً من إلقاء استثناء. <br><br>  قدم C # 7.2 القدرة على استخدام Span و stackallock معًا دون استخدام رمز غير آمن.  ربما بسبب هذا ، سيتم استخدام stackalloc بشكل أكثر تكرارًا في التعليمات البرمجية وسيكون من المفيد أن يكون لديك طريقة لحماية نفسك من StackOverflow عند استخدامه ، واختيار مكان تخصيص الذاكرة.  وبهذه الطريقة ، يتم اقتراح طريقة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">للتحقق من إمكانية التخصيص على المكدس</a> وبناء <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">trystackalloc</a> . <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; span; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CanAllocateOnStack(size)) span = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> span = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size];</code> </pre><br>  العودة إلى وثائق StackOverflow على MSDN <br><br><blockquote style=";text-align:right;direction:rtl">  بدلاً من ذلك ، عندما يحدث تجاوز سعة مكدس في <b>تطبيق عادي</b> ، ينهي وقت تشغيل اللغة العامة (CLR) العملية ". <br>  MSDN <br></blockquote><br>  إذا كان هناك تطبيق "عادي" يقع أثناء StackOverflow ، فهناك تطبيقات غير عادية لا تقع؟  للإجابة على هذا السؤال ، سيكون عليك النزول إلى مستوى من مستوى التطبيق المُدار إلى مستوى CLR. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/186/516/64d/18651664dd1c1d1346e5377f0e0b3995.png"><br><br><blockquote style=";text-align:right;direction:rtl">  "يمكن للتطبيق الذي <b>يستضيف CLR</b> تغيير السلوك الافتراضي وتحديد أن CLR يقوم بإلغاء <b>تحميل مجال التطبيق</b> حيث يحدث الاستثناء ، ولكنه يتيح استمرار العملية."  - MSDN <br>  StackOverflowException -&gt; AppDomainUnloadedException <br></blockquote><br>  يمكن للتطبيق الذي يستضيف CLR إعادة تعريف سلوك تجاوز سعة المكدس بحيث بدلاً من إكمال العملية بأكملها ، يتم إلغاء تحميل مجال التطبيق ، في الدفق الذي حدث فيه تجاوز الحد الأقصى.  حتى نتمكن من تحويل StackOverflowException إلى AppDomainUnloadedException. <br><br>  عند تشغيل تطبيق مُدار ، يبدأ وقت تشغيل .NET تلقائيًا.  ولكن يمكنك الذهاب في الاتجاه الآخر.  على سبيل المثال ، اكتب تطبيقًا غير مُدار (في لغة C ++ أو لغة أخرى) سيستخدم واجهة برمجة تطبيقات خاصة من أجل رفع CLR وتشغيل تطبيقنا.  التطبيق الذي يقوم بتشغيل CLR داخليًا سيسمى CLR-host.  من خلال كتابته ، يمكننا تكوين العديد من الأشياء في وقت التشغيل.  على سبيل المثال ، استبدل مدير الذاكرة ومدير سلسلة المحادثات.  نحن في الإنتاج نستخدم CLR-host لتجنب تبديل صفحات الذاكرة. <br><br>  يكوّن الرمز التالي مضيف CLR بحيث يتم إلغاء تحميل AppDomain (C ++) أثناء StackOverflow: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">ICLRPolicyManager *policyMgr; pCLRControl-&gt;GetCLRManager(IID_ICLRPolicyManager, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**) (&amp;policyMgr)); policyMgr-&gt;SetActionOnFailure(FAIL_StackOverflow, eRudeUnloadAppDomain);</code> </pre><br>  هل هذه طريقة جيدة للهروب من StackOverflow؟  ربما ليس كذلك.  أولاً ، كان علينا كتابة رمز C ++ ، والذي لا نريد القيام به.  ثانيًا ، يجب علينا تغيير رمز C # الخاص بنا بحيث يتم تنفيذ الوظيفة التي يمكنها رمي StackOverflowException في AppDomain منفصل وفي سلسلة محادثات منفصلة.  سيتحول رمزنا على الفور إلى مثل هذه المكرونة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appDomain = AppDomain.CreateDomain(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); appDomain.DoCallBack(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; InfiniteRecursion()); thread.Start(); thread.Join(); }); AppDomain.Unload(appDomain); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AppDomainUnloadedException) { }</code> </pre><br>  من أجل استدعاء طريقة InfiniteRecursion ، كتبنا مجموعة من الخطوط.  ثالثًا ، بدأنا في استخدام AppDomain.  وهذا يكفل مجموعة من المشاكل الجديدة.  بما في ذلك مع الاستثناءات.  فكر في مثال: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomException</span></span> : <span class="hljs-title"><span class="hljs-title">Exception</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appDomain = AppDomain.CreateDomain( <span class="hljs-string"><span class="hljs-string">"..."</span></span>); appDomain.DoCallBack(() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomException()); System.Runtime.Serialization.SerializationException: Type <span class="hljs-string"><span class="hljs-string">'CustomException'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> not marked <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> serializable. at System.AppDomain.DoCallBack(CrossAppDomainDelegate callBackDelegate)</code> </pre><br>  نظرًا لأن استثناءنا لم يتم وضع علامة عليه على أنه قابل للتسلسل ، فسيتم إسقاط رمزنا مع SerializationException.  ولإصلاح هذه المشكلة ، لا يكفي أن نميز استثناءنا بسمة Serializable ، فما زلنا بحاجة إلى تطبيق مُنشئ إضافي للتسلسل. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomException</span></span> : <span class="hljs-title"><span class="hljs-title">Exception</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SerializationInfo info, StreamingContext ctx</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">info, context</span></span></span><span class="hljs-function">)</span></span>{} } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appDomain = AppDomain.CreateDomain(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); appDomain.DoCallBack(() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomException());</code> </pre><br>  كل شيء ليس جميلًا جدًا ، لذلك نذهب إلى أبعد من ذلك - إلى مستوى نظام التشغيل والاختراق ، والذي لا ينبغي استخدامه في الإنتاج. <br><br><h2 style=";text-align:right;direction:rtl">  Seh / veh </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/2c5/7a2/aff/2c57a2aff0542b2a02ad8ab34d097412.png"><br><br>  لاحظ أنه بينما تطير الاستثناءات المُدارة بين المُدار و CLR ، تنتقل استثناءات SEH بين CLR و Windows. <br><br>  SEH - معالجة الاستثناءات المركبة <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  محرك معالجة استثناء Windows <br></li><li style=";text-align:right;direction:rtl">  معالجة موحدة للبرامج والأجهزة <br></li><li style=";text-align:right;direction:rtl">  تم تنفيذ استثناءات C # أعلى SEH <br></li></ul><br>  SEH هي آلية لمعالجة الاستثناءات في Windows ، فهي تسمح لك بالتعامل بشكل متساوٍ مع أي استثناءات جاءت ، على سبيل المثال ، من مستوى المعالج ، أو كانت مرتبطة بمنطق التطبيق نفسه. <br><br>  يعرف Rantime .NET عن استثناءات SEH ويمكنه تحويلها إلى استثناءات مُدارة: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  EXCEPTION_STACK_OVERFLOW -&gt; تحطم <br></li><li style=";text-align:right;direction:rtl">  EXCEPTION_ACCESS_VIOLATION -&gt; AccessViolationException <br></li><li style=";text-align:right;direction:rtl">  EXCEPTION_ACCESS_VIOLATION -&gt; NullReferenceException <br></li><li style=";text-align:right;direction:rtl">  EXCEPTION_INT_DIVIDE_BY_ZERO -&gt; DivideByZeroException <br></li><li style=";text-align:right;direction:rtl">  استثناءات SEH غير معروفة -&gt; SEHException <br></li></ul><br>  يمكننا التفاعل مع SEH من خلال WinApi. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"kernel32.dll"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dwExceptionCode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dwExceptionFlags, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nNumberOfArguments,IntPtr lpArguments</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">// DivideByZeroException RaiseException(0xc0000094, 0, 0, IntPtr.Zero); // Stack overflow RaiseException(0xc00000fd, 0, 0, IntPtr.Zero);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> في الواقع ، يعمل هيكل الرمي أيضًا من خلال SEH. </font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> -&gt; RaiseException(<span class="hljs-number"><span class="hljs-number">0xe0434f4d</span></span>, ...)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تجدر الإشارة هنا إلى أن رمز استثناء CLR هو نفسه دائمًا ، لذلك بغض النظر عن نوع الاستثناء الذي نطرحه ، ستتم معالجته دائمًا. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VEH هو معالجة استثناء متجه ، وهو امتداد لـ SEH ، ولكنه يعمل على مستوى العملية ، وليس على مستوى مؤشر ترابط واحد. </font><font style="vertical-align: inherit;">إذا كان SEH مشابهًا لغويًا لتجربة الالتقاط ، فإن VEH يشبه إلى حد ما معالج المقاطعة. </font><font style="vertical-align: inherit;">نقوم ببساطة بتعيين معالجنا ويمكننا تلقي معلومات حول جميع الاستثناءات التي تحدث في عمليتنا. </font><font style="vertical-align: inherit;">ميزة مثيرة للاهتمام في VEH هي أنها تسمح لك بتغيير استثناء SEH قبل أن تصل إلى المعالج.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b8/79d/848/7b879d848390b9e3d1b9156b00b8e2bf.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكننا وضع معالج المتجه الخاص بنا بين نظام التشغيل ووقت التشغيل ، والذي سيتعامل مع استثناءات SEH ، وعندما يواجه EXCEPTION_STACK_OVERFLOW ، قم بتغييره بحيث لا يعطل وقت تشغيل .NET العملية. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكنك التفاعل مع VEH من خلال WinApi:</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"kernel32.dll"</span></span></span><span class="hljs-meta">, SetLastError = true)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddVectoredExceptionHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr FirstHandler,  VECTORED_EXCEPTION_HANDLER VectoredHandler</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PVECTORED_EXCEPTION_HANDLER</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS exceptionPointers</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> VEH : <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> { EXCEPTION_CONTINUE_SEARCH = <span class="hljs-number"><span class="hljs-number">0</span></span>, EXCEPTION_EXECUTE_HANDLER = <span class="hljs-number"><span class="hljs-number">1</span></span>, EXCEPTION_CONTINUE_EXECUTION = <span class="hljs-number"><span class="hljs-number">-1</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PVECTORED_EXCEPTION_HANDLER</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS exceptionPointers</span></span></span><span class="hljs-function">)</span></span>; [StructLayout(LayoutKind.Sequential)] <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> EXCEPTION_POINTERS { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> EXCEPTION_RECORD* ExceptionRecord; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IntPtr Context; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PVECTORED_EXCEPTION_HANDLER</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS exceptionPointers</span></span></span><span class="hljs-function">)</span></span>; [StructLayout(LayoutKind.Sequential)] <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> EXCEPTION_RECORD { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> ExceptionCode; ... }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يحتوي السياق على معلومات حول حالة كافة سجلات المعالج في وقت الاستثناء. </font><font style="vertical-align: inherit;">سنكون مهتمين بـ EXCEPTION_RECORD وحقل ExceptionCode فيه. </font><font style="vertical-align: inherit;">يمكننا استبداله برمز الاستثناء الخاص بنا ، والذي لا يعرف CLR عنه شيئًا. </font><font style="vertical-align: inherit;">يبدو معالج المتجهات كالتالي:</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.ExceptionRecord == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VEH. EXCEPTION_CONTINUE_SEARCH; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> record = e. ExceptionRecord; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (record-&gt;ExceptionCode != ExceptionStackOverflow) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VEH. EXCEPTION_CONTINUE_SEARCH; record-&gt;ExceptionCode = <span class="hljs-number"><span class="hljs-number">0x01234567</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VEH. EXCEPTION_EXECUTE_HANDLER; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> سننشئ الآن مجمِّعًا يثبت معالج متجه في شكل طريقة HandleSO ، والذي يستوعب مفوضًا من المحتمل أن يسقط من StackOverflowException (للتوضيح ، لا يتعامل الرمز مع أخطاء وظيفة WinApi وإزالة معالج المتجه). </font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">HandleSO(() =&gt; InfiniteRecursion()) ; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T HandleSO&lt;T&gt;(Func&lt;T&gt; action) { Kernel32. AddVectoredExceptionHandler(IntPtr.Zero, Handler); Kernel32.SetThreadStackGuarantee(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> size); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) when ((<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>) Marshal. GetExceptionCode() == <span class="hljs-number"><span class="hljs-number">0x01234567</span></span>) {} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(T); } HandleSO(() =&gt; InfiniteRecursion());</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">داخله ، يتم أيضًا استخدام طريقة SetThreadStackGuarantee. </font><font style="vertical-align: inherit;">تحجز هذه الطريقة مساحة مكدس لمعالجة StackOverflow. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بهذه الطريقة ، يمكننا البقاء على قيد الحياة باستدعاء طريقة مع العودية اللانهائية. </font><font style="vertical-align: inherit;">سيستمر البث لدينا في العمل كما لو لم يحدث شيء ، كما لو لم يحدث تجاوز. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ولكن ماذا يحدث إذا اتصلت بـ HandleSO مرتين في نفس الموضوع؟</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">HandleSO(() =&gt; InfiniteRecursion()); HandleSO(() =&gt; InfiniteRecursion());</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">وسيكون هناك AccessViolationException. العودة إلى جهاز المكدس. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/639/e93/c8d/639e93c8d187dc31fc37a2ac7247f193.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكن لنظام التشغيل الكشف عن تجاوزات المكدس. في أعلى المكدس توجد صفحة خاصة تحمل علامة صفحة الحماية. في المرة الأولى التي يتم فيها الوصول إلى هذه الصفحة ، سيحدث استثناء آخر - STATUS_GUARD_PAGE_VIOLATION ، وستتم إزالة علامة صفحة الحماية من الصفحة. إذا قمت ببساطة باعتراض هذا الفائض ، فلن تكون هذه الصفحة على المكدس - في التدفق الفائض التالي ، لن يتمكن نظام التشغيل من فهم هذا وسيتجاوز مؤشر المكدس الذاكرة المخصصة للمكدس. نتيجة لذلك ، سيحدث AccessViolationException. لذلك تحتاج إلى استعادة علامات الصفحة بعد معالجة StackOverflow - أسهل طريقة للقيام بذلك هي استخدام طريقة _resetstkoflw من مكتبة وقت التشغيل C (msvcrt.dll).</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"msvcrt.dll"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _resetstkoflw();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بطريقة مماثلة ، يمكنك التقاط AccessViolationException في .NET Core ضمن Windows ، مما يؤدي إلى تعطل العملية. </font><font style="vertical-align: inherit;">في هذه الحالة ، يجب أن تأخذ في الاعتبار الترتيب الذي يتم فيه استدعاء معالجات المتجهات وتعيين المعالج الخاص بك على بداية السلسلة ، حيث يستخدم .NET Core أيضًا VEH عند معالجة AccessViolation. </font><font style="vertical-align: inherit;">تكون المعلمة الأولى للدالة AddVectoredExceptionHandler مسؤولة عن الترتيب الذي يتم من خلاله استدعاء المعالجات:</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">Kernel32.AddVectoredExceptionHandler(FirstHandler: (IntPtr) <span class="hljs-number"><span class="hljs-number">1</span></span>, handler);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> بعد دراسة القضايا العملية ، نلخص النتائج العامة: </font></font><br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الاستثناءات ليست بسيطة كما تبدو ؛ </font></font><br></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> لا يتم التعامل مع جميع الاستثناءات بنفس الطريقة ؛ </font></font><br></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تحدث معالجة الاستثناءات على مستويات مختلفة من التجريد ؛ </font></font><br></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> يمكنك التدخل في عملية معالجة الاستثناءات وجعل وقت تشغيل .NET يعمل بشكل مختلف عن الغرض الأصلي. </font></font><br></li></ul><br><h2 style=";text-align:right;direction:rtl">  المراجع </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مستودع مع أمثلة من التقرير</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> → </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dotnext 2016 موسكو - آدم سيتنيك - استثناءات استثنائية في .NET</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> → </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DotNetBook: استثناءات</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> → </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Inside Out Part 8 - التعامل مع استثناء تجاوز سعة المكدس في C # مع VEH</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> هو طريقة أخرى لاعتراض StackOverflow.</font></font><br><br><blockquote style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">من 22 إلى 23 نوفمبر ، سيتحدث يوجين في </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DotNext 2018 موسكو</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> بتقرير </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"مقاييس النظام: </font></font></a><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">جمع </font></b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;">العثرات"</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">سيأتي إلى موسكو جيفري ريشتر ، جريج يونج ، بافل يوسيفوفيتش وغيرهم من المتحدثين المثيرين للاهتمام. </font><font style="vertical-align: inherit;">يمكن الاطلاع على مواضيع التقارير </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هنا</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، وشراء التذاكر </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هنا</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">انضم الآن!</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar426045/">https://habr.com/ru/post/ar426045/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar426029/index.html">هل تستسلم وتريد إنهاء المهمة؟ هذه هي الطريقة التي يبدو بها تدريب المطور الفعال</a></li>
<li><a href="../ar426031/index.html">قد يعتمد القلق بشأن الاستيلاء على الذكاء الاصطناعي على العالم على افتراضات غير علمية</a></li>
<li><a href="../ar426033/index.html">اشتبك جبابرة الرياضيات حول إثبات ملحمي لفرضية ABC</a></li>
<li><a href="../ar426039/index.html">إطلاق الطوارئ "Soyuz MS-10" (إنقاذ الطاقم ، البث عبر)</a></li>
<li><a href="../ar426041/index.html">حل رمزي للمعادلات التفاضلية الخطية والنظم باستخدام طريقة تحويل لابلاس باستخدام SymPy</a></li>
<li><a href="../ar426047/index.html">10 كتب رائعة للمبتدئين باللغة الإنجليزية</a></li>
<li><a href="../ar426051/index.html">تحسين مهارات تصحيح البرامج - بعض النصائح</a></li>
<li><a href="../ar426053/index.html">التخزين المؤقت لمعالج الأحداث وتحسين أداء التطبيق المتفاعل</a></li>
<li><a href="../ar426055/index.html">TensorFlow.js و clmtrackr.js: تتبع اتجاه نظرة المستخدم في المتصفح</a></li>
<li><a href="../ar426059/index.html">لقاء توتو PHP # 2: فيديو الخطب</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>