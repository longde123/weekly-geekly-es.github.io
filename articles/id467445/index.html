<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⁉️ 👩🏼‍🤝‍👩🏻 👌🏻 Daftar pembaruan Windows yang diinstal yang sulit dipahami 🔵 ↙️ ⛰️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pernahkah Anda bertanya-tanya mengapa daftar pembaruan Windows yang diinstal dibuat? Dan melalui API mana untuk mendapatkannya? Saya akan mencoba memb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Daftar pembaruan Windows yang diinstal yang sulit dipahami</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467445/">  Pernahkah Anda bertanya-tanya mengapa daftar pembaruan Windows yang diinstal dibuat?  Dan melalui API mana untuk mendapatkannya?  Saya akan mencoba memberikan jawaban untuk ini dan pertanyaan lain yang muncul dalam studi kecil saya. <br><br><img src="https://habrastorage.org/webt/bb/rl/zc/bbrlzcws8p-tumczrzauuvx2l7w.jpeg"><br><a name="habracut"></a><br><h2>  Latar belakang atau bagaimana semuanya dimulai. </h2><br>  Setiap tahun sebuah konferensi spesialis muda diadakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di perusahaan kami</a> , di mana setiap peserta dapat menyelesaikan masalah departemen (daftar topik diusulkan sebelumnya).  Dan departemen SPAS (dukungan perangkat lunak dan perangkat keras) memiliki tugas berikut, yang menarik minat saya, ditambah lagi memungkinkan untuk kembali ke pemrograman lagi (sayangnya, saat ini saya bekerja di perusahaan ini sebagai operator sederhana NPPS). <br><br>  Sebelumnya, untuk setiap "TO" dengan bantuan WSUS, semua pembaruan yang dirilis ditarik dan didistribusikan ke semua mesin.  TSB (buletin layanan teknis) juga muncul secara berkala, yang mengindikasikan bahwa diperlukan untuk menginstal pembaruan yang diperlukan dalam bentuk paket terisolasi.  Akibatnya, kami mengumpulkan pembaruan yang tidak dapat dilacak di WSUS, tetapi hanya dapat dilihat melalui panel kontrol di bagian "Pembaruan Terpasang". <br><br><br><br><img src="https://habrastorage.org/webt/v6/9f/kb/v69fkb557stfaokhfjpoccmnuma.png" alt="Skema pembaruan visual"><br><br>  Ada situasi ketika workstation atau server "crash" dan Anda harus mengembalikannya dari gambar yang dibuat beberapa waktu lalu.  Saat memulihkan dari suatu gambar, ada kemungkinan bahwa kita mungkin kehilangan pembaruan yang kita butuhkan (yang datang dalam bentuk paket terisolasi) yang diinstal sebelum mesin crash.  Dijelaskan sedetail mungkin, karena klarifikasi sudah akan menjadi rahasia dagang. <br><br>  Itu sebabnya muncul ide untuk membuat program yang dapat mengekstrak daftar pembaruan ini (lebih disukai dari <b>jarak jauh</b> melalui jaringan lokal), menulis ke file / database, membandingkan daftar saat ini dengan templat tertentu dan mengirim pesan ke sistem SCADA melalui salah satu protokol - SNMP, OPC. <br><br>  Seperti yang mungkin sudah Anda tebak dari judul artikel, saya sudah memiliki tugas yang sulit untuk memilih metode pencarian daftar.  Seperti biasa, saya memutuskan untuk mencari yang tepat di mesin pencari, mengajukan pertanyaan tentang sumber daya khusus ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua</a> , untuk beberapa alasan stackoverflow dalam bahasa Inggris tidak menyukai pertanyaan saya dan harus dihapus), tetapi semua jawaban tidak memberikan hasil yang diinginkan.  Karena itu, saya harus mencari tahu sendiri, yang akan dibahas nanti. <br><br><h2>  Perintah konsol </h2><br>  Mari kita mulai dengan yang sederhana dan memanfaatkan apa yang ditawarkan Windows tanpa menggunakan alat pihak ketiga.  Ini dapat dilakukan dengan menggunakan perintah berikut: <br><br><ul><li>  daftar qfe wmic </li><li>  systeminfo </li><li>  bongkar / online / dapatkan paket </li><li>  melalui PowerShell: <br><br><ul><li>  <b>Dapatkan perbaikan terbaru</b> </li><li>  <b>Get-SilWindowsUpdate</b> (hanya tersedia dalam edisi server) </li><li>  <b>Get-WmiObject -Class win32_quickfixengineering</b> - melalui akses ke kelas WMI win32_quickfixengineering (tentang WMI beberapa saat kemudian) </li></ul><br></li></ul><br><br>  Anda bisa mendapatkan daftar melalui antarmuka grafis melalui item standar dari Control Panel "Tambah / Hapus Program", tetapi kami tidak dapat menyalin apa pun dari sana.  Setiap alat panel kontrol diwakili oleh file .cpl di folder Windows \ System.  File .Cpl di folder sistem Windows secara otomatis diunduh ketika panel kontrol dimulai.  File Appwiz.cpl bertanggung jawab atas item Program.  Analisisnya tidak mengarah pada apa pun. <br><br>  Output dari perintah konsol dapat diarahkan ke file dan kemudian dapat diuraikan, tetapi ini salah, ditambah panggilan program (menurut aturan SB, itu tidak akan berfungsi) dan tidak ada pertanyaan untuk menerima daftar dari jarak jauh.  Karena itu, saya sarankan Anda cukup memanggil perintah, membandingkan jumlah pembaruan di setiap daftar, dengan daftar melalui Panel Kontrol dan melanjutkan penyelidikan kami lebih lanjut. <br><br>  Secara formal, semua metode untuk mendapatkan daftar pembaruan dapat dibagi menjadi dua kelompok: lokal dan jaringan. <br><br><img src="https://habrastorage.org/webt/jw/jt/nf/jwjtnfe3m0dqr_cc9q9xybhf1ka.png" alt="Metode lokal dan jaringan untuk memperoleh informasi"><br><br>  Semua metode diuji pada gambar sistem yang bersih (Windows 7, 8, Server 2012 R2) dengan pembaruan terintegrasi, setelah setiap pembaruan melalui Pusat Pembaruan dari server Microsoft resmi pemeriksaan tambahan dilakukan.  Mari kita bahas masing-masing dengan lebih detail. <br><br><h2>  WUA </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WUApi</a> (Windows Agen Pemutakhiran API) - Menggunakan API Agen Pemutakhiran Windows.  Opsi yang paling jelas, nama yang berbicara sendiri.  Kami akan menggunakan perpustakaan Wuapi.dll untuk ini. <br><blockquote>  Catatan: selanjutnya, untuk kenyamanan saya, saya akan menyematkan semua hasil dalam Daftar.  Ini mungkin tidak rasional, tapi menurut saya itu ide yang bagus. </blockquote><div class="spoiler">  <b class="spoiler_title">Contoh implementasi</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> WUApiLib; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listUpdateHistory</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//WUApi List&lt;string&gt; result = new List&lt;string&gt;(200); try { UpdateSession uSession = new UpdateSession(); IUpdateSearcher uSearcher = uSession.CreateUpdateSearcher(); uSearcher.Online = false; ISearchResult sResult = uSearcher.Search("IsInstalled=1 And IsHidden=0"); string sw = "   WUApi: " + sResult.Updates.Count; result.Add(sw); foreach (WUApiLib.IUpdate update in sResult.Updates) { result.Add(update.Title); } } catch (Exception ex) { result.Add("-   : " + ex.Message); } return result; }</span></span></code> </pre> <br></div></div><br>  Ada variasi kedua dari metode ini: <b>Perbarui Sesi</b> - menerima informasi dengan menghubungkan ke sesi pembaruan Agen Pembaruan Windows (dalam hal ini, kami tidak bekerja secara langsung dengan perpustakaan). <br><br><div class="spoiler">  <b class="spoiler_title">Contoh implementasi</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sessionlist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pc</span></span></span><span class="hljs-function">)</span></span> { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">50</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    object sess = null; object search = null; object coll = null; try { sess = Activator.CreateInstance(Type.GetTypeFromProgID("Microsoft.Update.Session", pc)); search = (sess as dynamic).CreateUpdateSearcher(); int n = (search as dynamic).GetTotalHistoryCount(); int kol = 0; //coll = (search as dynamic).QueryHistory(1, n); coll = (search as dynamic).QueryHistory(0, n); result.Add("  Update.Session: " + n); foreach (dynamic item in coll as dynamic) { if (item.Operation == 1) result.Add(item.Title); kol++; //Console.WriteLine(": " + kol); } result.Add("  : " + kol); } catch (Exception ex) { result.Add("-   : " + ex.Message); } finally { if (sess != null) Marshal.ReleaseComObject(sess); if (search != null) Marshal.ReleaseComObject(search); if (coll != null) Marshal.ReleaseComObject(coll); } return result; }</span></span></code> </pre><br></div></div><br>  Microsoft menyarankan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penggunaan API secara</a> jarak jauh. <br><br>  Kerugian utama dari kedua metode ini adalah mereka tidak memungkinkan Anda menemukan perbaikan KB yang tidak didistribusikan melalui Pembaruan Windows.  Anda hanya dapat melihat apa yang melalui agen pembaruan itu sendiri, yaitu, opsi ini tidak cocok untuk kami. <br><br><h2>  DISM </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penerapan Gambar Servis dan Manajemen</a> adalah alat baris perintah yang dapat digunakan untuk melayani gambar Windows atau untuk menyiapkan gambar Lingkungan Pra-Instalasi Windows (Windows PE).  Ini adalah pengganti untuk Package Manager (Pkgmgr.exe), PEimg, dan Intlcfg. <br><br>  Utilitas ini digunakan untuk mengintegrasikan pembaruan, paket layanan ke dalam gambar sistem.  Pembaruan Windows adalah modul terpisah yang dapat disajikan dalam beberapa cara: <br><br><ul><li>  File .cab (Kabinet) - arsip.  Dirancang untuk distribusi dan instalasi menggunakan modul Pembaruan Windows dalam mode otomatis; </li><li>  file .msu (Microsoft Update Standalone Package) - file yang dapat dieksekusi.  Dirancang untuk distribusi dan instalasi oleh pengguna sendiri dalam mode manual melalui katalog pembaruan Microsoft.  Bahkan, mereka adalah paket yang terdiri dari file .cab-, .xml, .txt. </li></ul><br>  Perintah <b>dism / online / get-paket yang</b> disebutkan sebelumnya menampilkan informasi dasar tentang semua paket dalam gambar wim / sistem saat ini.  Microsoft telah mengurus kami dan menyediakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paket NuGet</a> untuk penggunaan API yang nyaman. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh implementasi</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.Dism; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DISMlist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">220</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { DismApi.Initialize(DismLogLevel.LogErrors); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dismsession = DismApi.OpenOnlineSession(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listupdate = DismApi.GetPackages(dismsession); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ab = listupdate.Count; <span class="hljs-comment"><span class="hljs-comment">//Console.WriteLine("   DISM: " + ab); string sw = "   DISM: " + ab; result.Add(sw); foreach (DismPackage feature in listupdate) { result.Add(feature.PackageName); //result.Add($"[ ] {feature.PackageName}"); //result.Add($"[ ] {feature.InstallTime}"); //result.Add($"[ ] {feature.ReleaseType}"); } } catch (Exception ex) { result.Add("-   : " + ex.Message); } return result; }</span></span></code> </pre><br></div></div><br>  Jumlah pembaruan bertepatan dengan jumlah dari daftar Panel Kontrol sampai pembaruan pertama melalui pusat kontrol - setelah itu jumlah pembaruan menjadi kurang (itu adalah 214, menjadi 209), meskipun secara logis mereka seharusnya meningkat.  Contoh output <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sebelum memperbarui</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Setelah memperbarui</a> . <br><br>  Apa alasannya, saya hanya bisa berspekulasi - mungkin beberapa pembaruan menggantikan yang sebelumnya, oleh karena itu, jumlahnya menjadi kurang. <br><br>  Beberapa saat kemudian, saya menemukan sebuah utilitas dari Chinese <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DISM ++</a> , yang tidak didasarkan pada DISM API atau DISM Core API, tetapi perpustakaan itu tidak memiliki metode yang perlu saya buka, jadi saya meninggalkan ide ini dan melanjutkan pencarian lebih lanjut. <br><br><h2>  WSUS </h2><br>  Layanan Pembaruan Server Windows ( <a href="">WSUS</a> ) adalah server untuk memperbarui sistem operasi dan produk Microsoft.  Server pembaruan disinkronkan dengan situs web Microsoft, mengunduh pembaruan yang dapat didistribusikan dalam LAN perusahaan.  Sekali lagi, alat khusus yang dirancang untuk bekerja dengan pembaruan. <br><br>  Didistribusikan hanya pada edisi server Windows, jadi dudukan berikut digunakan: <br><br><ul><li>  sistem utamanya adalah Windows Server 2016; </li><li>  dan melalui sistem virtualisasi Hyper-V, dua OS klien dikerahkan: <br><ul><li>  Windows 8.1 </li><li>  Windows 7 </li></ul><br></li></ul><br>  Semua sistem terhubung ke jaringan area lokal virtual tunggal, tetapi <u>tanpa akses ke Internet</u> . <br><br><div class="spoiler">  <b class="spoiler_title">Beberapa tips</b> <div class="spoiler_text">  Agar tidak mengalokasikan partisi hard disk untuk sistem baru, saya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WinNTSetup</a> dan menginstal sistem dalam disk VHD - bootloader, dimulai dengan Windows 7 (edisi Profesional / Ultimate), sangat cocok dengan booting dari disk image.  Disk yang diperoleh dapat digunakan dengan aman di Hyper-V - Anda membunuh dua burung dengan satu batu sekaligus.  Jangan lupa untuk membuat salinan repositori BCD terlebih dahulu melalui perintah <b>bcdedit / ekspor e: \ bcd_backup.bcd</b> . <br><br>  Saya tidak ingin mengonfigurasi AD untuk distribusi pembaruan, oleh karena itu saya hanya mendaftarkan jalur ke server WSUS dalam kebijakan grup: <br><br><img src="https://habrastorage.org/webt/j6/7f/v0/j67fv0mdw8mr8l0m73fowtmm238.png" alt="Pengaturan"><br><br>  Pastikan untuk memperhatikan port, karena kesalahan ketik (8350 bukannya 8530) saya tidak bisa menerima pembaruan pada mesin klien, meskipun semuanya dilakukan dengan benar.  Juga, nama item dalam kebijakan grup pada Windows 7 dan Windows 8 berbeda. <br><br>  Untuk menerima laporan menggunakan WSUS, Anda harus menginstal paket tambahan - sistem akan memberi tahu Anda mengenai hal ini. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Dan sekarang kode kecil</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//      using Microsoft.UpdateServices.Administration; public static List&lt;string&gt; GetWSUSlist(params string[] list) { List&lt;string&gt; result = new List&lt;string&gt;(200); //    string namehost = list[0]; // ,     string = "example1"; string servername = list[1]; //  string = "WIN-E1U41FA6E55"; string Username = list[2]; string Password = list[3]; try { ComputerTargetScope scope = new ComputerTargetScope(); IUpdateServer server = AdminProxy.GetUpdateServer(servername, false, 8530); ComputerTargetCollection targets = server.GetComputerTargets(scope); // Search targets = server.SearchComputerTargets(namehost); // To get only on server FindTarget method IComputerTarget target = FindTarget(targets, namehost); result.Add(" : " + target.FullDomainName); IUpdateSummary summary = target.GetUpdateInstallationSummary(); UpdateScope _updateScope = new UpdateScope(); // See in UpdateInstallationStates all other properties criteria //_updateScope.IncludedInstallationStates = UpdateInstallationStates.Downloaded; UpdateInstallationInfoCollection updatesInfo = target.GetUpdateInstallationInfoPerUpdate(_updateScope); int updateCount = updatesInfo.Count; result.Add(" -   - " + updateCount); foreach (IUpdateInstallationInfo updateInfo in updatesInfo) { result.Add(updateInfo.GetUpdate().Title); } } catch (Exception ex) { result.Add("-   : " + ex.Message); } return result; } public static IComputerTarget FindTarget(ComputerTargetCollection coll, string computername) { foreach (IComputerTarget target in coll) { if (target.FullDomainName.Contains(computername.ToLower())) return target; } return null; }</span></span></code> </pre><br></div></div><br>  Karena tidak ada Internet, situasi dengan pembaruan keluar seperti pada tangkapan layar di bawah ini: <br><br><img src="https://habrastorage.org/webt/az/gc/le/azgclepy6kznsibmilm1psoewa8.png"><br><br>  Perilaku ini mirip dengan WUApi - jika pembaruan belum melewati mereka, maka mereka tidak mengetahuinya.  Karena itu, metode ini tidak berfungsi lagi. <br><br><h2>  Wmi </h2><br>  Instrumentasi Manajemen Windows ( <b>WMI</b> ) dalam terjemahan literal adalah toolkit manajemen Windows. <br><br>  WMI adalah standar yang diterapkan Microsoft untuk mengelola perusahaan <u>melalui Internet</u> untuk administrasi terpusat dan pemantauan berbagai bagian infrastruktur komputer yang menjalankan platform Windows.  WMI adalah sistem antarmuka akses terbuka terpadu untuk parameter apa pun dari sistem operasi, perangkat, dan aplikasi yang beroperasi di dalamnya. <br><br>  Metode ini memungkinkan Anda untuk menerima data baik dari mesin lokal dan jarak jauh dalam jaringan lokal.  Untuk mengakses objek WMI, WMI Query Language (WQL) tertentu digunakan, yang merupakan salah satu varietas SQL.  Kami akan menerima daftar melalui <b>win32_quickfixengineering</b> kelas WMI. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh implementasi</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Management; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWMIlist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] list</span></span></span><span class="hljs-function">)</span></span> { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    ManagementScope Scope; string ComputerName = list[0]; string Username = list[1]; string Password = list[2]; int kol = 0; if (!ComputerName.Equals("localhost", StringComparison.OrdinalIgnoreCase)) { //    ,      //  . ConnectionOptions Conn = new ConnectionOptions(); Conn.Username = Username; Conn.Password = Password; //      «NTLMDOMAIN:»  NTLM  ,       NTLM. Conn.Authority = "ntlmdomain:DOMAIN"; Scope = new ManagementScope(String.Format("\\\\{0}\\root\\CIMV2", ComputerName), Conn); } else Scope = new ManagementScope(String.Format("\\\\{0}\\root\\CIMV2", ComputerName), null); try { Scope.Connect(); ObjectQuery Query = new ObjectQuery("SELECT * FROM Win32_QuickFixEngineering"); ManagementObjectSearcher Searcher = new ManagementObjectSearcher(Scope, Query); foreach (ManagementObject WmiObject in Searcher.Get()) { result.Add(WmiObject["HotFixID"].ToString()); //Console.WriteLine("{0,-35} {1,-40}", "HotFixID", WmiObject["HotFixID"]);// String //result.Add(); /*result.Add("{0,-17} {1}", " : ", WmiObject["Description"]); result.Add("{0,-17} {1}", ": ", WmiObject["Caption"]); result.Add("{0,-17} {1}", " : ", WmiObject["InstalledOn"]);*/ kol++; } result.Add("  " + kol); } catch (Exception ex) { result.Add("-   : " + ex.Message); } return result; }</span></span></code> </pre><br></div></div><br>  Secara kuantitatif, semuanya bertepatan (bahkan setelah pembaruan), jadi diputuskan untuk menggunakan metode ini.  Untuk pembuatan permintaan WMI terprogram, saya menyarankan Anda untuk menggunakan utilitas berikut - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WMI Delphi Code Creator</a> .  Berkat dia, saya melihat kode saya sedikit berbeda dan memutuskan untuk menggunakan blank dari program ini. <br><br><h2>  XML </h2><br>  Data yang diperoleh dengan metode WMI tidak menghentikan saya, dan saya memutuskan "rekayasa permukaan terbalik".  Kami akan menggunakan utilitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Process Monitor</a> dari kumpulan perangkat lunak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sysinternals Suite</a> untuk mengidentifikasi file dan cabang registri yang digunakan saat memanggil perintah konsol yang tercantum di atas dan mengakses item "Pembaruan yang diinstal" melalui Panel Kontrol. <br><br>  Perhatian saya tertuju pada file wuindex.xml yang terletak di folder C: \ Windows \ servicing \ Packages \.  Untuk menganalisisnya, program berikut ini ditulis: <br><br><div class="spoiler">  <b class="spoiler_title">Contoh Aplikasi Konsol</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Xml; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text.RegularExpressions; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">XMLviewer</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> writePath = AppDomain.CurrentDomain.BaseDirectory + <span class="hljs-string"><span class="hljs-string">"XML  "</span></span> + Environment.MachineName + <span class="hljs-string"><span class="hljs-string">".txt"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!File.Exists(writePath)) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"  txt "</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" XML .txt ,   "</span></span>); File.Delete(writePath); } <span class="hljs-comment"><span class="hljs-comment">//      KB Regex regex = new Regex(@"KB[0-9]{6,7}"); //Regex(@"(\w{2}\d{6,7}) ?"); //SortedSet    ,     ""     SortedSet&lt;string&gt; spisok = new SortedSet&lt;string&gt;(); XmlDocument xDoc = new XmlDocument(); string path = "C:\\Windows\\servicing\\Packages\\wuindex.xml"; //   xml xDoc.Load(path); int kol = 0; //-  int total = 0; //-    xml int total2 = 0; //-   XmlNodeList name = xDoc.GetElementsByTagName("Mappings"); foreach (XmlNode xnode in name) { //Console.WriteLine(xnode.Name); kol++; XmlNode attr = xnode.Attributes.GetNamedItem("UpdateId"); //Console.WriteLine(attr.Value); foreach (XmlNode childnode in xnode.ChildNodes) { XmlNode childattr = childnode.Attributes.GetNamedItem("Package"); total++; //Console.WriteLine(childattr.Value); MatchCollection matches = regex.Matches(childattr.Value); if (matches.Count &gt; 0) { foreach (Match match in matches) //Console.WriteLine(match.Value); spisok.Add(match.Value); } else { //Console.WriteLine("  "); } } } try { StreamWriter sw = new StreamWriter(writePath); foreach (string element in spisok) { //Console.WriteLine(element); sw.WriteLine(element); total2++; } sw.Close(); } catch (Exception ex) { Console.WriteLine(": " + ex.Message); } //Console.WriteLine("\n"); Console.WriteLine(" : " +kol); Console.WriteLine("    xml: " + total); Console.WriteLine(" KB : " + total2); Console.WriteLine("    ."); Console.Read(); } } }</span></span></code> </pre><br></div></div><br>  Sayangnya, file ini tidak ditemukan di semua sistem dan prinsip pembuatannya dan pemutakhiran tetap menjadi misteri bagi saya.  Karena itu, sekali lagi metode ini tidak cocok untuk kita. <br><br><h2>  Cb </h2><br>  Di sini kita sampai pada apa yang terkait dengan semua metode ini.  Melanjutkan analisis log Monitor Proses, saya mengidentifikasi folder dan file berikut. <br><br>  File DataStore.edb terletak di <b>folder C: \ Windows \ SoftwareDistribution \ DataStore</b> .  Ini adalah database yang berisi riwayat semua pembaruan untuk versi Windows yang diinstal, termasuk yang hanya di-antri. <br><br>  Program ESEDatabaseView digunakan untuk menganalisis file DataStore.edb.  Ada tabel tbUpdates dalam database, yang isinya sulit ditafsirkan. <br><br><img src="https://habrastorage.org/webt/n4/1v/b0/n41vb0kmc5axymvp2gd3qax5bek.png" alt="Tabel TbUpdates di ESEDatabaseView"><br><br>  Setelah perhatian saya tertarik pada proses <b>TiWorker.exe</b> , yang dipanggil setiap kali saya membuka item di Control Panel.  Dia "berjalan" melalui banyak folder, salah satunya membawa saya ke jalur yang benar. <br><br>  <b>C: \ Windows \ SoftwareDistribution</b> adalah folder yang digunakan oleh Pembaruan Windows untuk mengunduh pembaruan ke komputer dan menginstalnya, dan juga menyimpan informasi tentang semua pembaruan yang diinstal sebelumnya. <br><br>  Folder WinSxS terletak di <b>C: \ Windows \ winsxs</b> .  Ini adalah folder layanan sistem operasi Windows yang digunakan untuk menyimpan versi komponen sistem yang diinstal sebelumnya.  Karena keberadaannya, dimungkinkan untuk memutar kembali ke versi pembaruan yang lebih lama jika perlu. <br><br>  <b>C: \ Windows \ servicing</b> - komponen utama dari keseluruhan sistem, yang namanya adalah <b>Component-Based Servicing (CBS)</b> . <br><br>  CBS adalah layanan berbasis komponen yang merupakan bagian dari Windows dan terintegrasi dengan layanan Pembaruan Windows.  Berbeda dengan layanan <b>File-Based Servicing (FBS)</b> (untuk sistem operasi sebelum Windows Vista), di mana file diperbarui langsung di direktori sistem, CBS memperkenalkan seluruh hierarki direktori dan seluruh keluarga (tumpukan) modul / perpustakaan layanan. <br><br>  <b>CbsApi.dll</b> adalah perpustakaan dukungan teknologi CBS utama.  Tidak ada metode terbuka, jadi saya tidak bisa menggunakannya secara langsung.  Microsoft menggunakan TrustedInstaller.exe dan TiWorker.exe untuk mengakses metode perpustakaan ini dan sudah melalui proses ini menampilkan data yang kami butuhkan.  Catatan dipelihara dalam <b>C: \ Windows \ Logs \ CBS \ CBS.log</b> . <br><br>  Pada saat pembuatan prototipe program (Anda dapat melihat Mei 2019 di screenshot), tidak ada informasi berbahasa Rusia tentang CBS, tetapi pada akhir Agustus ada artikel blog yang sangat bagus - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://datadump.ru/component-based-servicing</a> .  Artikel yang sangat menarik yang mengkonfirmasi pengalaman saya dan mengumpulkan informasi yang diperlukan.  Dan lebih banyak tentang topik: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://www.outsidethebox.ms/17988/</a> <br><br><h2>  Kesimpulan </h2><br>  Microsoft telah terlalu rumit tugas sepele untuk mendapatkan daftar pembaruan dan membuat proses ini tidak sepenuhnya jelas.  Semua ini dilakukan untuk keamanan, tetapi bukan untuk kemudahan penggunaan.  Saya setuju dengan penulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> - prediktabilitas dan transparansi mulai tidak ada dalam menerima pembaruan. <br><br>  Sebagai hasil dari penelitian ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">program</a> berikut ini ditulis, sebuah demonstrasi yang dapat dilihat dalam video ini: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/SNxReaN4EKY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Rencana untuk menambahkan: <br><br><ol><li>  membandingkan daftar pembaruan yang diperlukan dengan yang diterima; </li><li>  kirim hasilnya melalui SNMP / OPC (jika ada yang punya pengalaman, bagikan dalam komentar); </li><li>  mengatur instalasi pembaruan "offline" yang hilang dari folder yang ditentukan. </li></ol><br>  Jika Anda mengetahui lebih banyak metode untuk mendapatkan daftar tidak hanya pembaruan, tetapi juga komponen tambahan (Adobe Flash, Acrobat Reader, dll.) Atau Anda memiliki saran menarik lainnya, tulis tentang itu di komentar atau di pesan pribadi - Saya akan dengan senang hati menerima umpan balik .  Dan ikut serta dalam survei untuk artikel ini - jadi saya akan tahu apakah pengalaman saya dengan audiens Habrahabr akan menarik. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467445/">https://habr.com/ru/post/id467445/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467429/index.html">Habrastatistics: menjelajahi bagian situs yang paling banyak dikunjungi dan paling tidak dikunjungi</a></li>
<li><a href="../id467435/index.html">Kami mengirim laporan agen Veeam Linux ke email atau di Telegram</a></li>
<li><a href="../id467437/index.html">MVCC di PostgreSQL-1. Isolasi</a></li>
<li><a href="../id467439/index.html">Mengapa vinil kembali, dan bagaimana layanan streaming terkait dengan ini?</a></li>
<li><a href="../id467443/index.html">Pusat Multimedia "Kodi" dan Proyek Yocto</a></li>
<li><a href="../id467449/index.html">Deteksi kerentanan dan penilaian resistensi terhadap serangan hacker kartu pintar dan prosesor kripto dengan perlindungan built-in</a></li>
<li><a href="../id467453/index.html">Memecahkan masalah nomor 42 menggunakan superkomputer planet</a></li>
<li><a href="../id467455/index.html">Template QBS untuk pemrograman mikrokontroler di QtCreator menggunakan contoh pengontrol Milander</a></li>
<li><a href="../id467457/index.html">Mulai dari operasi hingga pengembang game atau pengalaman pertama pengembangan ponsel di Unity</a></li>
<li><a href="../id467459/index.html">Bagaimana mikrokontroler dapat membaca data pada 1,6 Gbps</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>