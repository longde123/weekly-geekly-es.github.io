<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🅾️ 🕵🏾 👰🏿 Résolution de mots croisés japonais avec P̶y̶t̶h̶o̶̶n̶ Rust et WebAssembly 👨🏿‍🤝‍👨🏾 🍪 🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Comment faire un solveur nonogram pour Python, réécrivez-le dans Rust pour l'exécuter directement dans le navigateur via WebAssembly. 


 TL; DR 
 Com...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Résolution de mots croisés japonais avec P̶y̶t̶h̶o̶̶n̶ Rust et WebAssembly</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454586/"><p><img src="https://habrastorage.org/webt/sy/k0/va/syk0va4uczwmji3lwzhq2nqq2hy.png" alt="Logo rouille comme nonogramme"></p><br><p>  Comment faire un solveur nonogram pour Python, réécrivez-le dans Rust pour l'exécuter directement dans le navigateur via WebAssembly. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TL; DR</a> </p><a name="habracut"></a><br><h2 id="nachalo">  Commencer </h2><br><p>  À propos des mots croisés japonais (nonogrammes) sur le Habré, il y avait déjà plusieurs messages.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exemple</a> <br>  et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un de plus</a> . </p><br><blockquote>  Les images sont cryptées avec des numéros situés à gauche des lignes, ainsi qu'au-dessus des colonnes.  Le nombre de nombres indique le nombre de groupes de cellules noires (ou leur couleur, pour les mots croisés de couleur) dans la ligne ou la colonne correspondante, et les nombres eux-mêmes - combien de cellules fusionnées chacun de ces groupes contient (par exemple, un ensemble de trois nombres - 4, 1 et 3 signifie que dans cette ligne, il y a trois groupes: le premier - à partir de quatre, le second - à partir d'un, le troisième - à partir de trois cellules noires).  Dans un puzzle de mots croisés en noir et blanc, les groupes doivent être séparés par au moins une cellule vide, en couleur, cette règle ne s'applique qu'aux groupes monochromes, et les groupes multicolores peuvent être étroitement espacés (les cellules vides peuvent également se trouver le long des bords des lignes).  Il est nécessaire de déterminer l'emplacement des groupes de cellules. </blockquote><p>  L'un des points de vue les plus généralement acceptés est que les mots croisés «corrects» ne peuvent être appelés que ceux qui sont résolus de manière «logique».  Ceci est généralement appelé la méthode de solution, dans laquelle les dépendances entre différentes lignes et / ou colonnes ne sont pas prises en compte.  En d'autres termes, une solution est une séquence de décisions <strong>indépendantes</strong> de lignes ou de colonnes individuelles jusqu'à ce que toutes les cellules soient remplies (en savoir plus sur l'algorithme ci-dessous).  Par exemple, seuls de tels nonogrammes peuvent être trouvés sur le site Web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://nonograms.org/</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://nonograms.ru/</a> ).  Les nonogrammes de ce site ont déjà été cités en exemple dans l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Résoudre les mots croisés de couleur japonaise à la vitesse de la lumière</a> .  À des fins de comparaison et de vérification, mon solveur a également ajouté un support pour le téléchargement et l'analyse des mots croisés à partir de ce site (merci à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">KyberPrizrak</a> pour la permission d'utiliser les matériaux de son site). </p><br><p>  Cependant, le concept de nonogrammes peut être étendu à un problème plus général, lorsque la méthode "logique" habituelle conduit à une impasse.  Dans de tels cas, il faut faire une hypothèse sur la couleur d'une cellule et, après avoir prouvé que cette couleur conduit à une contradiction, marquer la couleur opposée pour cette cellule.  La séquence de ces étapes peut (si vous avez la patience) nous donner toutes les solutions.  Cet article portera principalement sur la résolution d'un cas plus général de mots croisés. </p><br><h2 id="python">  Python </h2><br><p>  Il y a environ un an et demi, je suis tombé accidentellement sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article</a> qui décrivait une méthode pour résoudre une seule ligne (comme il s'est avéré plus tard, la méthode était plutôt lente). </p><br><p>  Lorsque j'ai implémenté cette méthode en Python (mon principal langage de travail) et ajouté une mise à jour séquentielle de toutes les lignes, j'ai vu que tout cela n'était pas résolu très rapidement.  Après avoir étudié le matériel, il s'est avéré que sur ce sujet, il existe de nombreux travaux et implémentations qui proposent différentes approches pour cette tâche. </p><br><p>  Il m'a semblé que le travail le plus ambitieux sur l'analyse de diverses implémentations de solveurs a été effectué par Jan Wolter, publiant sur son site (qui, à ma connaissance, reste le plus grand référentiel public de nonogrammes sur Internet), une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">étude détaillée</a> contenant une multitude d'informations et de liens qui peuvent aider à créer votre propre solveur. </p><br><p>  En étudiant de nombreuses sources (elles seront à la fin de l'article), j'ai progressivement amélioré la vitesse et la fonctionnalité de mon solveur.  En conséquence, j'étais accro et j'étais engagé dans la mise en œuvre, la refactorisation, le débogage d'algorithmes pendant environ 10 mois dans un temps libre du travail. </p><br><h3 id="osnovnye-algoritmy">  Algorithmes de base </h3><br><p>  Le solveur résultant peut être représenté sous la forme de quatre niveaux de décision: </p><br><ul><li><p>  ( <strong>ligne</strong> ) solveur linéaire: en entrée, une ligne de cellules et une ligne de description (indices), en sortie, une ligne partiellement résolue.  Dans la solution python, j'ai implémenté 4 algorithmes différents (3 d'entre eux sont adaptés aux mots croisés couleur).  Le plus rapide s'est avéré être l'algorithme BguSolver, nommé d'après la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">source d'origine</a> .  Il s'agit d'une méthode très efficace et pratiquement standard pour résoudre des chaînes de nonogrammes en utilisant la programmation dynamique.  Le pseudocode de cette méthode se trouve, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans cet article</a> . </p><br></li><li><p>  ( <strong>propagation</strong> ) nous mettons toutes les lignes et colonnes dans une file d'attente, nous les parcourons avec un solveur linéaire, lorsque nous recevons de nouvelles informations lors de la résolution d'une ligne (colonne), nous mettons à jour la file d'attente, respectivement, avec de nouvelles colonnes (lignes).  Continuez jusqu'à ce que la ligne soit vide. </p><br><div class="spoiler">  <b class="spoiler_title">Exemple et code</b> <div class="spoiler_text"><p> Nous prenons la tâche suivante à résoudre à partir de la file d'attente.  Soit une chaîne vide (non résolue) de longueur 7 (nous la désignons comme <code>???????</code> ) avec une description des blocs <code>[2, 3]</code> .  Le solveur linéaire produira une chaîne partiellement résolue <code>?X??XX?</code>  où <code>X</code> est la cellule remplie.  Lors de la mise à jour de la ligne, nous voyons que les colonnes avec les numéros 1, 4, 5 ont changé (l'indexation commence à 0).  Cela signifie que de nouvelles informations sont apparues dans les colonnes indiquées et peuvent être renvoyées au solveur «linéaire».  Nous mettons ces colonnes dans la file d'attente des tâches avec une priorité plus élevée (afin de les donner ensuite au solveur linéaire). </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">propagation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(board)</span></span></span><span class="hljs-function">:</span></span> line_jobs = PriorityDict() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row_index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(board.height): new_job = (<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, row_index) line_jobs[new_job] = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> column_index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(board.width): new_job = (<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, column_index) line_jobs[new_job] = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (is_column, index), priority <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> line_jobs.sorted_iter(): new_jobs = solve_and_update(board, index, is_column) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> new_job <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_jobs: <span class="hljs-comment"><span class="hljs-comment"># upgrade priority new_priority = priority - 1 line_jobs[new_job] = new_priority def solve_and_update(board, index, is_column): if is_column: row_desc = board.columns_descriptions[index] row = tuple(board.get_column(index)) else: row_desc = board.rows_descriptions[index] row = tuple(board.get_row(index)) updated = line_solver(row_desc, row) if row != updated: for i, (pre, post) in enumerate(zip(row, updated)): if _is_pixel_updated(pre, post): yield (not is_column, i) if is_column: board.set_column(index, updated) else: board.set_row(index, updated)</span></span></code> </pre> <br></div></div><br></li></ul><br><ul><li><p>  ( <strong>sondage</strong> ) pour chaque cellule non résolue, nous trions toutes les options de couleur et essayons la propagation avec ces nouvelles informations.  Si nous obtenons une contradiction, nous jetons cette couleur hors des options de couleur pour la cellule et essayons d'en profiter à nouveau en utilisant la propagation.  S'il est résolu jusqu'au bout, nous ajoutons la solution à la liste des solutions, mais continuons d'expérimenter avec d'autres couleurs (il peut y avoir plusieurs solutions).  Si nous arrivons à une situation où il est impossible de résoudre davantage, nous ignorons simplement et répétons la procédure avec une couleur / cellule différente. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><p>  Renvoie True si une contradiction est reçue à la suite de l'échantillon. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">probe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, cell_state)</span></span></span><span class="hljs-function">:</span></span> board = self.board pos, assumption = cell_state.position, cell_state.color <span class="hljs-comment"><span class="hljs-comment"># already solved if board.is_cell_solved(pos): return False if assumption not in board.cell_colors(pos): LOG.warning("The probe is useless: color '%s' already unset", assumption) return False save = board.make_snapshot() try: board.set_color(cell_state) propagation( board, row_indexes=(cell_state.row_index,), column_indexes=(cell_state.column_index,)) except NonogramError: LOG.debug('Contradiction', exc_info=True) # rollback solved cells board.restore(save) else: if board.is_solved_full: self._add_solution() board.restore(save) return False LOG.info('Found contradiction at (%i, %i)', *pos) try: board.unset_color(cell_state) except ValueError as ex: raise NonogramError(str(ex)) propagation( board, row_indexes=(pos.row_index,), column_indexes=(pos.column_index,)) return True</span></span></code> </pre> <br></div></div><br></li></ul><br><ul><li><p>  ( <strong>retour arrière</strong> ) si pendant le sondage vous n'ignorez pas un puzzle partiellement résolu, mais continuez à invoquer récursivement la même procédure, nous obtenons un retour arrière (en d'autres termes, une marche complète dans la profondeur de l'arbre de décision potentiel).  Ici, un grand rôle commence à jouer, laquelle des cellules sera choisie comme la prochaine extension de la solution potentielle.  De bonnes recherches sur ce sujet figurent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans cette publication</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><p>  Le retour arrière est assez compliqué avec moi, mais ces deux fonctions décrivent approximativement ce qui se passe lors d'une recherche récursive </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, search_directions, path=</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Return False if the given path is a dead end (no solutions can be found) """</span></span> board = self.board depth = len(path) save = board.make_snapshot() <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> search_directions: state = search_directions.popleft() assumption, pos = state.color, state.position cell_colors = board.cell_colors(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> assumption <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cell_colors: LOG.warning(<span class="hljs-string"><span class="hljs-string">"The assumption '%s' is already expired. "</span></span> <span class="hljs-string"><span class="hljs-string">"Possible colors for %s are %s"</span></span>, assumption, pos, cell_colors) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(cell_colors) == <span class="hljs-number"><span class="hljs-number">1</span></span>: LOG.warning(<span class="hljs-string"><span class="hljs-string">'Only one color for cell %r left: %s. Solve it unconditionally'</span></span>, pos, assumption) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: self._solve_without_search() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> NonogramError: LOG.warning( <span class="hljs-string"><span class="hljs-string">"The last possible color '%s' for the cell '%s' "</span></span> <span class="hljs-string"><span class="hljs-string">"lead to the contradiction. "</span></span> <span class="hljs-string"><span class="hljs-string">"The path %s is invalid"</span></span>, assumption, pos, path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> board.is_solved_full: self._add_solution() LOG.warning( <span class="hljs-string"><span class="hljs-string">"The only color '%s' for the cell '%s' lead to full solution. "</span></span> <span class="hljs-string"><span class="hljs-string">"No need to traverse the path %s anymore"</span></span>, assumption, pos, path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> rate = board.solution_rate guess_save = board.make_snapshot() <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: LOG.warning(<span class="hljs-string"><span class="hljs-string">'Trying state: %s (depth=%d, rate=%.4f, previous=%s)'</span></span>, state, depth, rate, path) success = self._try_state(state, path) <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: board.restore(guess_save) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> success: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: LOG.warning( <span class="hljs-string"><span class="hljs-string">"Unset the color %s for cell '%s'. Solve it unconditionally"</span></span>, assumption, pos) board.unset_color(state) self._solve_without_search() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError: LOG.warning( <span class="hljs-string"><span class="hljs-string">"The last possible color '%s' for the cell '%s' "</span></span> <span class="hljs-string"><span class="hljs-string">"lead to the contradiction. "</span></span> <span class="hljs-string"><span class="hljs-string">"The whole branch (depth=%d) is invalid. "</span></span>, assumption, pos, depth) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> board.is_solved_full: self._add_solution() LOG.warning( <span class="hljs-string"><span class="hljs-string">"The negation of color '%s' for the cell '%s' lead to full solution. "</span></span> <span class="hljs-string"><span class="hljs-string">"No need to traverse the path %s anymore"</span></span>, assumption, pos, path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: <span class="hljs-comment"><span class="hljs-comment"># do not restore the solved cells on a root path - they are really solved! if path: board.restore(save) return True def _try_state(self, state, path): board = self.board full_path = path + (state,) probe_jobs = self._get_all_unsolved_jobs(board) try: # update with more prioritized cells for new_job, priority in self._set_guess(state): probe_jobs[new_job] = priority __, best_candidates = self._solve_jobs(probe_jobs) except NonogramError as ex: LOG.warning('Dead end found (%s): %s', full_path[-1], str(ex)) return False rate = board.solution_rate LOG.info('Reached rate %.4f on %s path', rate, full_path) if rate == 1: return True cells_left = round((1 - rate) * board.width * board.height) LOG.info('Unsolved cells left: %d', cells_left) if best_candidates: return self.search(best_candidates, path=full_path) return True</span></span></code> </pre> <br></div></div><br></li></ul><br><p>  Ainsi, nous commençons à résoudre notre puzzle de mots croisés à partir du deuxième niveau (le premier ne convient que pour le cas dégénéré, alors que dans le puzzle de mots croisés entier, il n'y a qu'une seule ligne ou colonne) et montons progressivement les niveaux.  Comme vous pouvez le deviner, chaque niveau provoque le niveau sous-jacent plusieurs fois, donc pour une solution efficace, il est impératif d'avoir des premier et deuxième niveaux rapides, qui peuvent être appelés des millions de fois pour des puzzles complexes. </p><br><p>  À ce stade, il s'avère (plutôt attendu) que python n'est pas du tout l'outil qui convient aux performances maximales dans une telle tâche gourmande en CPU: tous les calculs y sont extrêmement inefficaces par rapport aux langages de bas niveau.  Par exemple, le solveur BGU le plus proche algorithmiquement (en Java), selon les résultats des mesures, s'est avéré 7 à 17 (parfois jusqu'à 27) fois plus rapide sur une variété de tâches. </p><br><div class="spoiler">  <b class="spoiler_title">Plus de détails</b> <div class="spoiler_text"><pre>         pynogram_my BGU_my speedup
 Danseur 0,976 0,141 6,921986      
 Cat 1.064 0.110 9.672727      
 Skid 1.084 0.101 10.732673     
 Bucks 1.116 0.118 9.457627      
 Bord 1,208 0,094 12,851064     
 Fumée 1,464 0,120 12.200000     
 Nœud 1,332 0,140 9,514286      
 Balançoire 1,784 0,138 12,927536     
 Maman 2.108 0.147 14.340136     
 DiCap 2.076 0.176 11.795455     
 Tragic 2,368 0,265 8,935849      
 Merka 2.084 0.196 10.632653     
 Petro 2,948 0,219 13,461187     
 M&amp;M 3,588 0,375 9,568000      
 Signé 4.068 0.242 16.809917     
 Léger 3,848 0,488 7,885246      
 Forever 111.000 13.570 8.179808  
 Centre 5,700 0,327 17,431193     
 Chaud 3.150 0.278 11.330935     
 Karaté 2.500 0.219 11.415525     
 9-Dom 510.000 70.416 7.242672      
 Drapeau 149.000 5.628 26.474769     
 Lion 71,000 2,895 24,525043     
 Marley 12.108 4.405 2.748695      
 Chose 321.000 46.166 6.953169      
 Nature inf 433.138 inf     
 Sierp inf inf NaN      
 Gettys inf inf NaN      
</pre><br><p>  Les mesures ont été effectuées sur ma voiture, les puzzles sont tirés de l'ensemble standard que Jan Wolter a utilisé dans sa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comparaison</a> </p></div></div><br><p>  Et c'est déjà après avoir commencé à utiliser PyPy, et sur CPython standard, le temps de calcul était plus long que sur PyPy 4-5 fois!  Nous pouvons dire que les performances d'un solveur Java similaire étaient 28 à 85 fois supérieures à celles du code CPython. </p><br><p>  Les tentatives pour améliorer les performances de mon solveur à l'aide du profilage (cProfile, SnakeViz, line_profiler) ont conduit à une certaine accélération, mais bien sûr, elles n'ont pas donné un résultat étrange. </p><br><h3 id="itogihttpsgithubcomtsionyxpynogram">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Résumé</a> : </h3><br><p>  <strong>+ le</strong> solveur peut résoudre tous les puzzles des sites <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://webpbn.com</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://nonograms.org</a> et son propre format (basé sur l'ini) </p><br><p>  <strong>+</strong> résout les nonogrammes en noir et blanc et en couleur avec n'importe quel nombre de couleurs (le nombre maximum de couleurs rencontrées est de 10) </p><br><p>  <strong>+</strong> résout des puzzles avec des tailles de blocs manquantes (blott).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un exemple d'un tel puzzle</a> . </p><br><p>  <strong>+</strong> peut restituer des puzzles à la console / aux curses / fenêtre du navigateur (lors de l'installation de l'option <em>pynogram-web</em> supplémentaire).  Pour tous les modes, la visualisation de la progression de la solution en temps réel est prise en charge. </p><br><p>  <strong>-</strong> calculs lents (par rapport aux implémentations décrites dans l'article-comparaison des solveurs, voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tableau</a> ). </p><br><p>  <strong>-</strong> retour arrière inefficace: certains casse-tête peuvent être résolus pendant des heures (lorsque l'arbre de décision est très grand). </p><br><h2 id="rust">  Rouille </h2><br><p>  Au début de l'année, j'ai commencé à étudier Rust.  J'ai commencé, comme d'habitude, avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">The Book</a> , j'ai découvert WASM, j'ai suivi le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tutoriel proposé</a> .  Cependant, je voulais une tâche réelle dans laquelle vous pouvez vous impliquer dans les points forts du langage (principalement sa super-performance), et non des exemples inventés par quelqu'un.  Je suis donc retourné aux nonogrammes.  Mais maintenant, j'avais déjà une version de travail de tous les algorithmes en Python, il ne restait plus qu'à "réécrire". </p><br><p>  La bonne nouvelle m'attendait depuis le tout début: il s'est avéré que Rust, avec son système de type, décrit parfaitement les structures de données pour ma tâche.  Par exemple, l'une des correspondances de base <em>BinaryColor + BinaryBlock</em> / <em>MultiColor + ColoredBlock vous</em> permet de séparer de façon permanente les nonogrammes noir et blanc et couleur.  Si, quelque part dans le code, nous essayons de résoudre une chaîne colorée à l'aide de blocs de description binaires ordinaires, nous obtenons une erreur de compilation sur la non-concordance de type. </p><br><div class="spoiler">  <b class="spoiler_title">Les types de base ressemblent à ceci</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">blank</span></span></span></span>() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_solved</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">solution_rate</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_updated_with</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, new: &amp;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">variants</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_color_id</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;ColorId&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_color_ids</span></span></span></span>(ids: &amp;[ColorId]) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Block</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span>: Color; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_str_and_color</span></span></span></span>(s: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, color: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;ColorId&gt;) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> size = s.parse::&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;().expect(<span class="hljs-string"><span class="hljs-string">"Non-integer block size given"</span></span>); Self::from_size_and_color(size, color) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_size_and_color</span></span></span></span>(size: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, color: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;ColorId&gt;) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">color</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Self::Color; } <span class="hljs-meta"><span class="hljs-meta">#[derive(Debug, PartialEq, Eq, Hash, Clone)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Description</span></span></span></span>&lt;T: Block&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T: Block, { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> vec: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;T&gt;, } <span class="hljs-comment"><span class="hljs-comment">// for black-and-white puzzles #[derive(Debug, PartialEq, Eq, Hash, Copy, Clone, PartialOrd)] pub enum BinaryColor { Undefined, White, Black, BlackOrWhite, } impl Color for BinaryColor { // omitted } #[derive(Debug, PartialEq, Eq, Hash, Default, Clone)] pub struct BinaryBlock(pub usize); impl Block for BinaryBlock { type Color = BinaryColor; // omitted } // for multicolor puzzles #[derive(Debug, PartialEq, Eq, Hash, Default, Copy, Clone, PartialOrd, Ord)] pub struct MultiColor(pub ColorId); impl Color for MultiColor { // omitted } #[derive(Debug, PartialEq, Eq, Hash, Default, Clone)] pub struct ColoredBlock { size: usize, color: ColorId, } impl Block for ColoredBlock { type Color = MultiColor; // omitted }</span></span></code> </pre> </div></div><br><p>  Lors du portage du code, certains points ont clairement indiqué qu'un langage typé statiquement tel que Rust (enfin, ou, par exemple, C ++) est plus approprié pour cette tâche.  Plus précisément, les génériques et les traits décrivent un domaine mieux que les hiérarchies de classes.  Donc, dans le code Python, j'avais deux classes pour un <code>BguSolver</code> linéaire, <code>BguSolver</code> et <code>BguColoredSolver</code> qui résolvaient respectivement une ligne en noir et blanc et une ligne en couleur.  Dans le code Rust, j'ai toujours la seule <code>struct DynamicSolver&lt;B: Block, S = &lt;B as Block&gt;::Color&gt;</code> générique <code>struct DynamicSolver&lt;B: Block, S = &lt;B as Block&gt;::Color&gt;</code> , qui peut résoudre les deux types de tâches, selon le type passé lors de la création ( <code>DynamicSolver&lt;BinaryBlock&gt;, DynamicSolver&lt;ColoredBlock&gt;</code> ).  Bien sûr, cela ne signifie pas que quelque chose de similaire ne peut pas être fait en Python, juste dans Rust, le système de type m'a clairement indiqué que si vous n'alliez pas de cette façon, vous auriez à écrire une tonne de code répétitif. </p><br><p>  De plus, quiconque a essayé d'écrire dans Rust, a sans aucun doute remarqué l'effet de la «confiance» dans le compilateur, lorsque le processus d'écriture du code se résume à l'algorithme pseudo-méta suivant: </p><br><pre> write_initial_code
 while (compiler_hints = $ (cargo check))! = 0;  faire
     fix_errors (compiler_hints)
 fin
</pre><br><p>  Lorsque le compilateur cesse d'émettre des erreurs et des avertissements, votre code sera cohérent avec le système de type et le vérificateur d'emprunt et vous préviendrez à l'avance l'occurrence d'un tas de bogues potentiels (bien sûr, sous réserve d'une conception soignée des types de données). </p><br><p>  Je vais donner quelques exemples de fonctions qui montrent à quel point le code Rust peut être concis (par rapport aux équivalents Python). </p><br><div class="spoiler">  <b class="spoiler_title">unsolved_neighbours</b> <div class="spoiler_text"><p>  Donne une liste de "voisins" non résolus pour un point donné (x, y) </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsolved_neighbours</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, position)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.neighbours(position): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.is_cell_solved(*pos): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> pos</code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsolved_neighbours</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, point: &amp;Point) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Iterator</span></span>&lt;Item = Point&gt; + <span class="hljs-symbol"><span class="hljs-symbol">'_</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.neighbours(&amp;point) .into_iter() .filter(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |n| !<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cell(n).is_solved()) }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">partial_sums</b> <div class="spoiler_text"><p>  Pour un ensemble de blocs décrivant une ligne, donnez des sommes partielles (en tenant compte des espaces requis entre les blocs). Les indices résultants indiqueront la position minimale à laquelle le bloc peut se terminer (cette information sera utilisée plus tard pour un solveur linéaire). </p><br><p>  Par exemple, pour un tel ensemble de blocs <code>[2, 3, 1]</code> nous avons à la sortie <code>[2, 6, 8]</code> , ce qui signifie que le premier bloc peut être déplacé au maximum vers la gauche afin que son bord droit occupe la 2e cellule, de même pour le reste blocs: </p><br><pre>             1 2 3 4 5 6 7 8 9 
             _ _ _ _ _ _ _ _ _ _
      2 3 1 | _ | _ | _ | _ | _ | _ | _ | _ | _ | 
               ^ ^ ^
               |  |  |
 fin d'un bloc |  |  | 
 fin du bloc 2 -------- |
 fin du bloc 3 ------------
</pre><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@expand_generator def partial_sums(blocks): if not blocks: return sum_so_far = blocks[0] yield sum_so_far for block in blocks[1:]: sum_so_far += block + 1 yield sum_so_far</span></span></code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">partial_sums</span></span></span></span>(desc: &amp;[<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>]) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { desc.iter() .scan(<span class="hljs-literal"><span class="hljs-literal">None</span></span>, |prev, block| { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> current = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> prev_size) = prev { prev_size + block.<span class="hljs-number"><span class="hljs-number">0</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { block.<span class="hljs-number"><span class="hljs-number">0</span></span> }; *prev = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(current); *prev }) .collect() }</code> </pre> </div></div><br><p>  Lors du portage, j'ai apporté plusieurs modifications </p><br><ul><li>  le noyau du solveur (algorithmes) a subi des modifications mineures (principalement pour prendre en charge les types génériques pour les cellules et les blocs) </li><li>  laissé le seul algorithme (le plus rapide) pour le solveur linéaire </li><li>  au lieu du format ini, introduit un format TOML légèrement modifié </li><li>  n'a pas ajouté la prise en charge des mots croisés effacés, car, à proprement parler, il s'agit d'une classe de tâches différente </li><li><p>  laissé le seul moyen de sortie - juste à la console, mais maintenant les cellules colorées dans la console sont dessinées vraiment colorées (grâce à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette caisse</a> ) </p><br><div class="spoiler">  <b class="spoiler_title">comme ça</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xm/fd/ez/xmfdezlfahkoksuj3h0djom3p9k.png" alt="Jack moineau"></p><br></div></div><br></li></ul><br><h3 id="poleznye-instrumenty">  Des outils utiles </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">clippy</a> est un analyseur statique standard qui peut même parfois donner des conseils augmentant légèrement les performances du code. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">valgrind</a> est un outil d'analyse dynamique des applications.  Je l'ai utilisé comme profileur pour rechercher des botneks ( <code>valrgind --tool=callgrind</code> ) et en particulier des sections de code <code>valrgind --tool=massif</code> ( <code>valrgind --tool=massif</code> ).  Astuce: définissez <em>[profile.release] debug = true</em> sur Cargo.toml avant de démarrer le profileur.  Cela laissera des caractères de débogage dans l'exécutable. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">kcachegrind</a> pour afficher les fichiers de callgrind.  Un outil très utile pour trouver les endroits les plus problématiques en termes de performances. </li></ul><br><h3 id="proizvoditelnost">  Performances </h3><br><p>  C'est pour ça que la réécriture sur Rust a commencé.  Nous prenons les mots croisés du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tableau de comparaison</a> déjà mentionné et les exécutons à travers les meilleurs solveurs décrits dans l'article d'origine.  Résultats et description des runs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Nous prenons le <a href="">fichier</a> résultant et construisons quelques graphiques dessus. Comme le temps de résolution varie de quelques millisecondes à des dizaines de minutes, le graphique est fait avec une échelle logarithmique. </p><br><div class="spoiler">  <b class="spoiler_title">courir dans un ordinateur portable jupyter</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt %matplotlib inline <span class="hljs-comment"><span class="hljs-comment"># strip the spaces df = pd.read_csv('perf.csv', skipinitialspace=True) df.columns = df.columns.str.strip() df['name'] = df['name'].str.strip() # convert to numeric df = df.replace('\+\ *', np.inf, regex=True) ALL_SOLVERS = list(df.columns[3:]) df.loc[:,ALL_SOLVERS] = df.loc[:,ALL_SOLVERS].apply(pd.to_numeric) # it cannot be a total zero df = df.replace(0, 0.001) #df.set_index('name', inplace=True) SURVEY_SOLVERS = [s for s in ALL_SOLVERS if not s.endswith('_my')] MY_MACHINE_SOLVERS = [s for s in ALL_SOLVERS if s.endswith('_my') and s[:-3] in SURVEY_SOLVERS] MY_SOLVERS = [s for s in ALL_SOLVERS if s.endswith('_my') and s[:-3] not in SURVEY_SOLVERS] bar_width = 0.17 df_compare = df.replace(np.inf, 10000, regex=True) plt.rcParams.update({'font.size': 20}) def compare(first, others): bars = [first] + list(others) index = np.arange(len(df)) fig, ax = plt.subplots(figsize=(30,10)) df_compare.sort_values(first, inplace=True) for i, column in enumerate(bars): ax.bar(index + bar_width*i, df_compare[column], bar_width, label=column[:-3]) ax.set_xlabel("puzzles") ax.set_ylabel("Time, s (log)") ax.set_title("Compare '{}' with others (lower is better)".format(first[:-3])) ax.set_xticks(index + bar_width / 2) ax.set_xticklabels("#" + df_compare['ID'].astype(str) + ": " + df_compare['name'].astype(str)) ax.legend() plt.yscale('log') plt.xticks(rotation=90) plt.show() fig.savefig(first[:-3] + '.png', bbox_inches='tight') for my in MY_SOLVERS: compare(my, MY_MACHINE_SOLVERS) compare(MY_SOLVERS[0], MY_SOLVERS[1:])</span></span></code> </pre> </div></div><br><h5 id="python-solver">  solveur python </h5><br><p> <a href=""><img src="https://habrastorage.org/webt/si/qb/5o/siqb5ohxk_bjjaulmkohy1uhzkw.png" alt="performances du pynogramme"><br></a> <br>  (l' <em>image est cliquable</em> ) </p><br><p>  Nous voyons que le <em>pynogramme</em> ici est plus lent que tous les solveurs présentés.  La seule exception à cette règle est le solveur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tamura / Copris</a> basé sur SAT, qui résout les puzzles les plus simples (la partie gauche du graphique) plus longtemps que le nôtre.  Cependant, c'est une caractéristique des solveurs SAT: ils sont conçus pour des mots croisés super complexes dans lesquels un solveur régulier est coincé dans le retour arrière pendant une longue période.  Ceci est clairement visible sur le côté droit du graphique, où <em>Tamura / Copris</em> résout les puzzles les plus difficiles des dizaines et des centaines de fois plus rapidement que tout le monde. </p><br><h5 id="rust-solver">  solveur de rouille </h5><br><p> <a href=""><img src="https://habrastorage.org/webt/bh/be/cb/bhbecb0ccinpwfhysauyjkrcx24.png" alt="performance non-grille"><br></a> <br>  (l' <em>image est cliquable</em> ) </p><br><p>  Ce graphique montre que les <em>non</em> - <em>grids</em> sur des tâches simples <em>supportent</em> également ou légèrement pire que les solveurs hautes performances écrits en C et C ++ ( <em>Wolter</em> et <em>Syromolotov</em> ).  Avec la complication des tâches, notre solveur répète approximativement la trajectoire du solveur <em>BGU</em> (Java), mais presque toujours devant lui d'environ un ordre de grandeur.  Sur les tâches les plus difficiles, <em>Tamura / Copris</em> est toujours en avance sur tout le monde. </p><br><h5 id="rust-vs-python">  rouille vs python </h5><br><p> <a href=""><img src="https://habrastorage.org/webt/ih/0b/2r/ih0b2rnmyk5o_rpgckz_5hkkifc.png" alt="py-vs-rust-performance"><br></a> <br>  (l' <em>image est cliquable</em> ) </p><br><p>  Et enfin, une comparaison de nos deux solveurs décrits ici.  On peut voir que le solveur Rust est presque toujours à 1 à 3 ordres de grandeur devant le solveur Python. </p><br><h3 id="itogihttpsgithubcomtsionyxnonogrid">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Résumé</a> : </h3><br><p>  <strong>+ le</strong> solveur peut résoudre tous les puzzles des sites <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://webpbn.com</a> (sauf buvard - avec des tailles de bloc partiellement masquées), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://nonograms.org</a> et son propre format (basé sur TOML) </p><br><p>  <strong>+</strong> résout les nonogrammes noir et blanc et couleur avec n'importe quel nombre de couleurs </p><br><p>  <strong>+</strong> peut rendre des puzzles sur la console (la couleur c webpbn.com dessine la vraie couleur) </p><br><p>  <strong>+</strong> fonctionne rapidement (en comparaison avec les implémentations décrites dans l'article-comparaison des solveurs, voir tableau). </p><br><p>  <strong>- le</strong> retour en arrière est resté inefficace, comme dans la solution Python: certains casse-tête (par exemple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">, un tel 20x20 inoffensif</a> ) peuvent être résolus pendant des heures (lorsque l'arbre de décision est très grand).  Peut-être qu'au lieu de revenir en arrière, vous devriez utiliser les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">solveurs SAT</a> déjà mentionnés sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le concentrateur</a> .  Certes, le seul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">solveur SAT</a> que j'ai trouvé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur Rust</a> à première vue semble inachevé et abandonné. </p><br><h2 id="webassembly">  Webassembly </h2><br><p>  La réécriture du code dans Rust a donc porté ses fruits: le solveur est devenu beaucoup plus rapide.  Cependant, Rust nous offre une autre fonctionnalité incroyablement cool: la compilation dans WebAssembly et la possibilité d'exécuter votre code directement dans le navigateur. </p><br><p>  Pour implémenter cette fonctionnalité, il existe un outil spécial pour Rust qui fournit les liants nécessaires et génère un passe-partout pour que vous puissiez exécuter sans douleur les fonctions Rust en code JS - ce <em>wasm-pack</em> (+ <em>wasm-bindgen</em> ).  La plupart du travail avec celui-ci et d'autres outils importants est déjà décrit dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">didacticiel Rust et WebAssembly</a> .  Cependant, il y a quelques points que j'ai dû comprendre par moi-même: </p><br><ul><li><p>  lors de la lecture, cela donne l'impression que le tutoriel est principalement écrit pour un développeur JS qui souhaite accélérer son code avec Rust.  Eh bien, ou du moins pour quelqu'un qui connaît bien <em>npm</em> .  Pour moi, en tant que personne loin du front-end, il était surprenant de constater que même l'exemple standard du livre ne voulait pas fonctionner avec un serveur Web tiers différent de <code>npm run start</code> . </p><br><p>  Heureusement, wasm-pack dispose d'un mode qui vous permet de générer du code JS standard (qui n'est pas un module npm).  <code>wasm-pack build --target no-modules --no-typescript</code> ne donnera que deux fichiers dans la sortie: <em>project-name.wasm</em> - le binaire du code Rust compilé dans WebAssembly et <em>project-name.js</em> .  Le dernier fichier peut être ajouté à n'importe quelle page HTML <code>&lt;script src="project-name.js"&gt;&lt;/script&gt;</code> et utiliser les fonctions WASM sans se soucier de npm, webpack, ES6, des modules et autres joies du développeur JS moderne.  Le mode <code>no-modules</code> est idéal pour les développeurs non frontaux lors du développement d'une application WASM, ainsi que pour les exemples et les démos, car il ne nécessite aucune infrastructure frontale supplémentaire. </p><br></li><li><p>  WebAssembly convient aux tâches trop lourdes pour JavaScript.  Tout d'abord, ce sont des tâches qui effectuent de nombreux calculs.  Et si c'est le cas, une telle tâche peut être effectuée pendant longtemps même avec WebAssembly et ainsi violer le principe asynchrone du web moderne.  Je parle de toutes sortes d' <em>avertissement: script ne répondant pas</em> que j'ai observé lorsque mon solveur fonctionnait.  Pour résoudre ce problème, vous pouvez utiliser le mécanisme de <em>travail Web</em> .  Dans ce cas, le schéma de travail avec les fonctions WASM "lourdes" peut ressembler à ceci: </p><br><ol><li>  à partir du script principal d'un événement (par exemple, en cliquant sur un bouton) envoyer un message au travailleur avec la tâche de lancer une fonction lourde. </li><li>   ,        . </li><li>      -   () </li></ol><br></li></ul><br><p>   WASM-         JS,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  WASM</a> .      -   (       ),     <code>HashMap</code>       ,     .    ( JS)    ,          /   . </p><br><p>       ,  <a href="">  Mutex</a> ,        thread-safe.       smart-    .   thread-safe     <em>Rc</em>  <em>Arc</em>  <em>RefCell</em>  <em>RwLock</em> .         :         30%.         <code>--features=threaded</code>      thread-safe ,     WASM-. </p><br><p>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6574</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">8098</a>    (     10 ): </p><br><div class="scrollable-table"><table><thead><tr><th> id </th><th> non-thread-safe </th><th> thread-safe </th><th> web-interface </th></tr></thead><tbody><tr><td> 6574 </td><td>  5.4 </td><td> 7.4 </td><td>  9.2 </td></tr><tr><td> 8098 </td><td> 21.5 </td><td> 28.4 </td><td> 29.9 </td></tr></tbody></table></div><br><p> ,   -    40..70% ,       ,      (32..37%)      thread-safe  ( <code>cargo build --release --features=threaded</code> ). </p><br><p>    Firefox 67.0  Chromium 74.0. </p><br><p> WASM-   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ).            <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://webpbn.com/</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://www.nonograms.org/</a> </p><br><h3 id="todo"> TODO </h3><br><ul><li><p> ""  /,  /    . </p><br></li><li><p>     ,     .      "" ,    ,        .      . </p><br></li><li><p>     (    ,      3600 ).  WASM     ,     (  ,   (!) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ,   ,     WASM). ,  , -  ,       nonogrid  . </p><br></li><li><p>   .      : ,       ,      WASM   .    ,         ( )    ,    JS  ,      . </p><br></li><li><p>     JS.         backtrace,       . </p><br></li><li><p>        (     <a href="">TOML-</a> ) </p><br></li></ul><br><h2 id="itogi">  Résumé </h2><br><ul><li><p>           ,    (, , etc). </p><br></li><li><p>   Rust  1-3     PyPy       1.5-2  (  ). </p><br></li><li><p>    Python  Rust  ,            Python (, , comprehensions),      Rust-. </p><br></li><li><p>   Rust  WebAssembly   .     Rust ,   WASM,      (     1.5  ). </p><br></li></ul><br><h2 id="osnovnye-istochniki">   </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">The 'pbnsolve' Paint-by-Number Puzzle Solver by Jan Wolter</a> and the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">survey</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">The BGU Nonograms Project</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Solving Nonograms by combining relaxations</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">An Efficient Approach to Solving Nonograms</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">      </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Color and black and white Japanese crosswords on-line</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">      </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">'Nonolib' library by Dr. Steven Simpson</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rust and WebAssembly</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454586/">https://habr.com/ru/post/fr454586/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454574/index.html">Apprentissage automatique en microfinance: construire un modèle de notation pour les clients avec un historique de crédit vide</a></li>
<li><a href="../fr454576/index.html">Les auteurs de GandCrab cessent de travailler: ils prétendent en avoir assez volé</a></li>
<li><a href="../fr454578/index.html">Comment connecter la galerie PhotoSwipe dans la vue Web Android</a></li>
<li><a href="../fr454582/index.html">La longueur du tableau doit-elle être stockée dans une variable locale en C #?</a></li>
<li><a href="../fr454584/index.html">École de développement d'interface: analyse des tâches pour Minsk et un nouvel ensemble à Moscou</a></li>
<li><a href="../fr454588/index.html">Gazprom Neft vous invite à visiter: GPN Data Science Meetup</a></li>
<li><a href="../fr454590/index.html">Zimbra Collaboration Suite et Mobile Control avec ABQ</a></li>
<li><a href="../fr454592/index.html">WAF à travers les yeux des pirates</a></li>
<li><a href="../fr454596/index.html">Modèles mentaux en sécurité de l'information</a></li>
<li><a href="../fr454598/index.html">Architecture sans serveur et microservices: l'accord parfait?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>