<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÖæÔ∏è üïµüèæ üë∞üèø R√©solution de mots crois√©s japonais avec PÃ∂yÃ∂tÃ∂hÃ∂oÃ∂Ã∂nÃ∂ Rust et WebAssembly üë®üèø‚Äçü§ù‚Äçüë®üèæ üç™ üé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Comment faire un solveur nonogram pour Python, r√©√©crivez-le dans Rust pour l'ex√©cuter directement dans le navigateur via WebAssembly. 


 TL; DR 
 Com...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>R√©solution de mots crois√©s japonais avec PÃ∂yÃ∂tÃ∂hÃ∂oÃ∂Ã∂nÃ∂ Rust et WebAssembly</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454586/"><p><img src="https://habrastorage.org/webt/sy/k0/va/syk0va4uczwmji3lwzhq2nqq2hy.png" alt="Logo rouille comme nonogramme"></p><br><p>  Comment faire un solveur nonogram pour Python, r√©√©crivez-le dans Rust pour l'ex√©cuter directement dans le navigateur via WebAssembly. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TL; DR</a> </p><a name="habracut"></a><br><h2 id="nachalo">  Commencer </h2><br><p>  √Ä propos des mots crois√©s japonais (nonogrammes) sur le Habr√©, il y avait d√©j√† plusieurs messages.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exemple</a> <br>  et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un de plus</a> . </p><br><blockquote>  Les images sont crypt√©es avec des num√©ros situ√©s √† gauche des lignes, ainsi qu'au-dessus des colonnes.  Le nombre de nombres indique le nombre de groupes de cellules noires (ou leur couleur, pour les mots crois√©s de couleur) dans la ligne ou la colonne correspondante, et les nombres eux-m√™mes - combien de cellules fusionn√©es chacun de ces groupes contient (par exemple, un ensemble de trois nombres - 4, 1 et 3 signifie que dans cette ligne, il y a trois groupes: le premier - √† partir de quatre, le second - √† partir d'un, le troisi√®me - √† partir de trois cellules noires).  Dans un puzzle de mots crois√©s en noir et blanc, les groupes doivent √™tre s√©par√©s par au moins une cellule vide, en couleur, cette r√®gle ne s'applique qu'aux groupes monochromes, et les groupes multicolores peuvent √™tre √©troitement espac√©s (les cellules vides peuvent √©galement se trouver le long des bords des lignes).  Il est n√©cessaire de d√©terminer l'emplacement des groupes de cellules. </blockquote><p>  L'un des points de vue les plus g√©n√©ralement accept√©s est que les mots crois√©s ¬´corrects¬ª ne peuvent √™tre appel√©s que ceux qui sont r√©solus de mani√®re ¬´logique¬ª.  Ceci est g√©n√©ralement appel√© la m√©thode de solution, dans laquelle les d√©pendances entre diff√©rentes lignes et / ou colonnes ne sont pas prises en compte.  En d'autres termes, une solution est une s√©quence de d√©cisions <strong>ind√©pendantes</strong> de lignes ou de colonnes individuelles jusqu'√† ce que toutes les cellules soient remplies (en savoir plus sur l'algorithme ci-dessous).  Par exemple, seuls de tels nonogrammes peuvent √™tre trouv√©s sur le site Web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://nonograms.org/</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://nonograms.ru/</a> ).  Les nonogrammes de ce site ont d√©j√† √©t√© cit√©s en exemple dans l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">R√©soudre les mots crois√©s de couleur japonaise √† la vitesse de la lumi√®re</a> .  √Ä des fins de comparaison et de v√©rification, mon solveur a √©galement ajout√© un support pour le t√©l√©chargement et l'analyse des mots crois√©s √† partir de ce site (merci √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">KyberPrizrak</a> pour la permission d'utiliser les mat√©riaux de son site). </p><br><p>  Cependant, le concept de nonogrammes peut √™tre √©tendu √† un probl√®me plus g√©n√©ral, lorsque la m√©thode "logique" habituelle conduit √† une impasse.  Dans de tels cas, il faut faire une hypoth√®se sur la couleur d'une cellule et, apr√®s avoir prouv√© que cette couleur conduit √† une contradiction, marquer la couleur oppos√©e pour cette cellule.  La s√©quence de ces √©tapes peut (si vous avez la patience) nous donner toutes les solutions.  Cet article portera principalement sur la r√©solution d'un cas plus g√©n√©ral de mots crois√©s. </p><br><h2 id="python">  Python </h2><br><p>  Il y a environ un an et demi, je suis tomb√© accidentellement sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article</a> qui d√©crivait une m√©thode pour r√©soudre une seule ligne (comme il s'est av√©r√© plus tard, la m√©thode √©tait plut√¥t lente). </p><br><p>  Lorsque j'ai impl√©ment√© cette m√©thode en Python (mon principal langage de travail) et ajout√© une mise √† jour s√©quentielle de toutes les lignes, j'ai vu que tout cela n'√©tait pas r√©solu tr√®s rapidement.  Apr√®s avoir √©tudi√© le mat√©riel, il s'est av√©r√© que sur ce sujet, il existe de nombreux travaux et impl√©mentations qui proposent diff√©rentes approches pour cette t√¢che. </p><br><p>  Il m'a sembl√© que le travail le plus ambitieux sur l'analyse de diverses impl√©mentations de solveurs a √©t√© effectu√© par Jan Wolter, publiant sur son site (qui, √† ma connaissance, reste le plus grand r√©f√©rentiel public de nonogrammes sur Internet), une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©tude d√©taill√©e</a> contenant une multitude d'informations et de liens qui peuvent aider √† cr√©er votre propre solveur. </p><br><p>  En √©tudiant de nombreuses sources (elles seront √† la fin de l'article), j'ai progressivement am√©lior√© la vitesse et la fonctionnalit√© de mon solveur.  En cons√©quence, j'√©tais accro et j'√©tais engag√© dans la mise en ≈ìuvre, la refactorisation, le d√©bogage d'algorithmes pendant environ 10 mois dans un temps libre du travail. </p><br><h3 id="osnovnye-algoritmy">  Algorithmes de base </h3><br><p>  Le solveur r√©sultant peut √™tre repr√©sent√© sous la forme de quatre niveaux de d√©cision: </p><br><ul><li><p>  ( <strong>ligne</strong> ) solveur lin√©aire: en entr√©e, une ligne de cellules et une ligne de description (indices), en sortie, une ligne partiellement r√©solue.  Dans la solution python, j'ai impl√©ment√© 4 algorithmes diff√©rents (3 d'entre eux sont adapt√©s aux mots crois√©s couleur).  Le plus rapide s'est av√©r√© √™tre l'algorithme BguSolver, nomm√© d'apr√®s la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">source d'origine</a> .  Il s'agit d'une m√©thode tr√®s efficace et pratiquement standard pour r√©soudre des cha√Ænes de nonogrammes en utilisant la programmation dynamique.  Le pseudocode de cette m√©thode se trouve, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans cet article</a> . </p><br></li><li><p>  ( <strong>propagation</strong> ) nous mettons toutes les lignes et colonnes dans une file d'attente, nous les parcourons avec un solveur lin√©aire, lorsque nous recevons de nouvelles informations lors de la r√©solution d'une ligne (colonne), nous mettons √† jour la file d'attente, respectivement, avec de nouvelles colonnes (lignes).  Continuez jusqu'√† ce que la ligne soit vide. </p><br><div class="spoiler">  <b class="spoiler_title">Exemple et code</b> <div class="spoiler_text"><p> Nous prenons la t√¢che suivante √† r√©soudre √† partir de la file d'attente.  Soit une cha√Æne vide (non r√©solue) de longueur 7 (nous la d√©signons comme <code>???????</code> ) avec une description des blocs <code>[2, 3]</code> .  Le solveur lin√©aire produira une cha√Æne partiellement r√©solue <code>?X??XX?</code>  o√π <code>X</code> est la cellule remplie.  Lors de la mise √† jour de la ligne, nous voyons que les colonnes avec les num√©ros 1, 4, 5 ont chang√© (l'indexation commence √† 0).  Cela signifie que de nouvelles informations sont apparues dans les colonnes indiqu√©es et peuvent √™tre renvoy√©es au solveur ¬´lin√©aire¬ª.  Nous mettons ces colonnes dans la file d'attente des t√¢ches avec une priorit√© plus √©lev√©e (afin de les donner ensuite au solveur lin√©aire). </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">propagation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(board)</span></span></span><span class="hljs-function">:</span></span> line_jobs = PriorityDict() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row_index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(board.height): new_job = (<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, row_index) line_jobs[new_job] = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> column_index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(board.width): new_job = (<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, column_index) line_jobs[new_job] = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (is_column, index), priority <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> line_jobs.sorted_iter(): new_jobs = solve_and_update(board, index, is_column) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> new_job <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_jobs: <span class="hljs-comment"><span class="hljs-comment"># upgrade priority new_priority = priority - 1 line_jobs[new_job] = new_priority def solve_and_update(board, index, is_column): if is_column: row_desc = board.columns_descriptions[index] row = tuple(board.get_column(index)) else: row_desc = board.rows_descriptions[index] row = tuple(board.get_row(index)) updated = line_solver(row_desc, row) if row != updated: for i, (pre, post) in enumerate(zip(row, updated)): if _is_pixel_updated(pre, post): yield (not is_column, i) if is_column: board.set_column(index, updated) else: board.set_row(index, updated)</span></span></code> </pre> <br></div></div><br></li></ul><br><ul><li><p>  ( <strong>sondage</strong> ) pour chaque cellule non r√©solue, nous trions toutes les options de couleur et essayons la propagation avec ces nouvelles informations.  Si nous obtenons une contradiction, nous jetons cette couleur hors des options de couleur pour la cellule et essayons d'en profiter √† nouveau en utilisant la propagation.  S'il est r√©solu jusqu'au bout, nous ajoutons la solution √† la liste des solutions, mais continuons d'exp√©rimenter avec d'autres couleurs (il peut y avoir plusieurs solutions).  Si nous arrivons √† une situation o√π il est impossible de r√©soudre davantage, nous ignorons simplement et r√©p√©tons la proc√©dure avec une couleur / cellule diff√©rente. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><p>  Renvoie True si une contradiction est re√ßue √† la suite de l'√©chantillon. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">probe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, cell_state)</span></span></span><span class="hljs-function">:</span></span> board = self.board pos, assumption = cell_state.position, cell_state.color <span class="hljs-comment"><span class="hljs-comment"># already solved if board.is_cell_solved(pos): return False if assumption not in board.cell_colors(pos): LOG.warning("The probe is useless: color '%s' already unset", assumption) return False save = board.make_snapshot() try: board.set_color(cell_state) propagation( board, row_indexes=(cell_state.row_index,), column_indexes=(cell_state.column_index,)) except NonogramError: LOG.debug('Contradiction', exc_info=True) # rollback solved cells board.restore(save) else: if board.is_solved_full: self._add_solution() board.restore(save) return False LOG.info('Found contradiction at (%i, %i)', *pos) try: board.unset_color(cell_state) except ValueError as ex: raise NonogramError(str(ex)) propagation( board, row_indexes=(pos.row_index,), column_indexes=(pos.column_index,)) return True</span></span></code> </pre> <br></div></div><br></li></ul><br><ul><li><p>  ( <strong>retour arri√®re</strong> ) si pendant le sondage vous n'ignorez pas un puzzle partiellement r√©solu, mais continuez √† invoquer r√©cursivement la m√™me proc√©dure, nous obtenons un retour arri√®re (en d'autres termes, une marche compl√®te dans la profondeur de l'arbre de d√©cision potentiel).  Ici, un grand r√¥le commence √† jouer, laquelle des cellules sera choisie comme la prochaine extension de la solution potentielle.  De bonnes recherches sur ce sujet figurent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans cette publication</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><p>  Le retour arri√®re est assez compliqu√© avec moi, mais ces deux fonctions d√©crivent approximativement ce qui se passe lors d'une recherche r√©cursive </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, search_directions, path=</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Return False if the given path is a dead end (no solutions can be found) """</span></span> board = self.board depth = len(path) save = board.make_snapshot() <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> search_directions: state = search_directions.popleft() assumption, pos = state.color, state.position cell_colors = board.cell_colors(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> assumption <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cell_colors: LOG.warning(<span class="hljs-string"><span class="hljs-string">"The assumption '%s' is already expired. "</span></span> <span class="hljs-string"><span class="hljs-string">"Possible colors for %s are %s"</span></span>, assumption, pos, cell_colors) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(cell_colors) == <span class="hljs-number"><span class="hljs-number">1</span></span>: LOG.warning(<span class="hljs-string"><span class="hljs-string">'Only one color for cell %r left: %s. Solve it unconditionally'</span></span>, pos, assumption) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: self._solve_without_search() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> NonogramError: LOG.warning( <span class="hljs-string"><span class="hljs-string">"The last possible color '%s' for the cell '%s' "</span></span> <span class="hljs-string"><span class="hljs-string">"lead to the contradiction. "</span></span> <span class="hljs-string"><span class="hljs-string">"The path %s is invalid"</span></span>, assumption, pos, path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> board.is_solved_full: self._add_solution() LOG.warning( <span class="hljs-string"><span class="hljs-string">"The only color '%s' for the cell '%s' lead to full solution. "</span></span> <span class="hljs-string"><span class="hljs-string">"No need to traverse the path %s anymore"</span></span>, assumption, pos, path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> rate = board.solution_rate guess_save = board.make_snapshot() <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: LOG.warning(<span class="hljs-string"><span class="hljs-string">'Trying state: %s (depth=%d, rate=%.4f, previous=%s)'</span></span>, state, depth, rate, path) success = self._try_state(state, path) <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: board.restore(guess_save) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> success: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: LOG.warning( <span class="hljs-string"><span class="hljs-string">"Unset the color %s for cell '%s'. Solve it unconditionally"</span></span>, assumption, pos) board.unset_color(state) self._solve_without_search() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError: LOG.warning( <span class="hljs-string"><span class="hljs-string">"The last possible color '%s' for the cell '%s' "</span></span> <span class="hljs-string"><span class="hljs-string">"lead to the contradiction. "</span></span> <span class="hljs-string"><span class="hljs-string">"The whole branch (depth=%d) is invalid. "</span></span>, assumption, pos, depth) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> board.is_solved_full: self._add_solution() LOG.warning( <span class="hljs-string"><span class="hljs-string">"The negation of color '%s' for the cell '%s' lead to full solution. "</span></span> <span class="hljs-string"><span class="hljs-string">"No need to traverse the path %s anymore"</span></span>, assumption, pos, path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: <span class="hljs-comment"><span class="hljs-comment"># do not restore the solved cells on a root path - they are really solved! if path: board.restore(save) return True def _try_state(self, state, path): board = self.board full_path = path + (state,) probe_jobs = self._get_all_unsolved_jobs(board) try: # update with more prioritized cells for new_job, priority in self._set_guess(state): probe_jobs[new_job] = priority __, best_candidates = self._solve_jobs(probe_jobs) except NonogramError as ex: LOG.warning('Dead end found (%s): %s', full_path[-1], str(ex)) return False rate = board.solution_rate LOG.info('Reached rate %.4f on %s path', rate, full_path) if rate == 1: return True cells_left = round((1 - rate) * board.width * board.height) LOG.info('Unsolved cells left: %d', cells_left) if best_candidates: return self.search(best_candidates, path=full_path) return True</span></span></code> </pre> <br></div></div><br></li></ul><br><p>  Ainsi, nous commen√ßons √† r√©soudre notre puzzle de mots crois√©s √† partir du deuxi√®me niveau (le premier ne convient que pour le cas d√©g√©n√©r√©, alors que dans le puzzle de mots crois√©s entier, il n'y a qu'une seule ligne ou colonne) et montons progressivement les niveaux.  Comme vous pouvez le deviner, chaque niveau provoque le niveau sous-jacent plusieurs fois, donc pour une solution efficace, il est imp√©ratif d'avoir des premier et deuxi√®me niveaux rapides, qui peuvent √™tre appel√©s des millions de fois pour des puzzles complexes. </p><br><p>  √Ä ce stade, il s'av√®re (plut√¥t attendu) que python n'est pas du tout l'outil qui convient aux performances maximales dans une telle t√¢che gourmande en CPU: tous les calculs y sont extr√™mement inefficaces par rapport aux langages de bas niveau.  Par exemple, le solveur BGU le plus proche algorithmiquement (en Java), selon les r√©sultats des mesures, s'est av√©r√© 7 √† 17 (parfois jusqu'√† 27) fois plus rapide sur une vari√©t√© de t√¢ches. </p><br><div class="spoiler">  <b class="spoiler_title">Plus de d√©tails</b> <div class="spoiler_text"><pre>         pynogram_my BGU_my speedup
 Danseur 0,976 0,141 6,921986      
 Cat 1.064 0.110 9.672727      
 Skid 1.084 0.101 10.732673     
 Bucks 1.116 0.118 9.457627      
 Bord 1,208 0,094 12,851064     
 Fum√©e 1,464 0,120 12.200000     
 N≈ìud 1,332 0,140 9,514286      
 Balan√ßoire 1,784 0,138 12,927536     
 Maman 2.108 0.147 14.340136     
 DiCap 2.076 0.176 11.795455     
 Tragic 2,368 0,265 8,935849      
 Merka 2.084 0.196 10.632653     
 Petro 2,948 0,219 13,461187     
 M&amp;M 3,588 0,375 9,568000      
 Sign√© 4.068 0.242 16.809917     
 L√©ger 3,848 0,488 7,885246      
 Forever 111.000 13.570 8.179808  
 Centre 5,700 0,327 17,431193     
 Chaud 3.150 0.278 11.330935     
 Karat√© 2.500 0.219 11.415525     
 9-Dom 510.000 70.416 7.242672      
 Drapeau 149.000 5.628 26.474769     
 Lion 71,000 2,895 24,525043     
 Marley 12.108 4.405 2.748695      
 Chose 321.000 46.166 6.953169      
 Nature inf 433.138 inf     
 Sierp inf inf NaN      
 Gettys inf inf NaN      
</pre><br><p>  Les mesures ont √©t√© effectu√©es sur ma voiture, les puzzles sont tir√©s de l'ensemble standard que Jan Wolter a utilis√© dans sa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comparaison</a> </p></div></div><br><p>  Et c'est d√©j√† apr√®s avoir commenc√© √† utiliser PyPy, et sur CPython standard, le temps de calcul √©tait plus long que sur PyPy 4-5 fois!  Nous pouvons dire que les performances d'un solveur Java similaire √©taient 28 √† 85 fois sup√©rieures √† celles du code CPython. </p><br><p>  Les tentatives pour am√©liorer les performances de mon solveur √† l'aide du profilage (cProfile, SnakeViz, line_profiler) ont conduit √† une certaine acc√©l√©ration, mais bien s√ªr, elles n'ont pas donn√© un r√©sultat √©trange. </p><br><h3 id="itogihttpsgithubcomtsionyxpynogram">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">R√©sum√©</a> : </h3><br><p>  <strong>+ le</strong> solveur peut r√©soudre tous les puzzles des sites <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://webpbn.com</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://nonograms.org</a> et son propre format (bas√© sur l'ini) </p><br><p>  <strong>+</strong> r√©sout les nonogrammes en noir et blanc et en couleur avec n'importe quel nombre de couleurs (le nombre maximum de couleurs rencontr√©es est de 10) </p><br><p>  <strong>+</strong> r√©sout des puzzles avec des tailles de blocs manquantes (blott).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un exemple d'un tel puzzle</a> . </p><br><p>  <strong>+</strong> peut restituer des puzzles √† la console / aux curses / fen√™tre du navigateur (lors de l'installation de l'option <em>pynogram-web</em> suppl√©mentaire).  Pour tous les modes, la visualisation de la progression de la solution en temps r√©el est prise en charge. </p><br><p>  <strong>-</strong> calculs lents (par rapport aux impl√©mentations d√©crites dans l'article-comparaison des solveurs, voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tableau</a> ). </p><br><p>  <strong>-</strong> retour arri√®re inefficace: certains casse-t√™te peuvent √™tre r√©solus pendant des heures (lorsque l'arbre de d√©cision est tr√®s grand). </p><br><h2 id="rust">  Rouille </h2><br><p>  Au d√©but de l'ann√©e, j'ai commenc√© √† √©tudier Rust.  J'ai commenc√©, comme d'habitude, avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">The Book</a> , j'ai d√©couvert WASM, j'ai suivi le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tutoriel propos√©</a> .  Cependant, je voulais une t√¢che r√©elle dans laquelle vous pouvez vous impliquer dans les points forts du langage (principalement sa super-performance), et non des exemples invent√©s par quelqu'un.  Je suis donc retourn√© aux nonogrammes.  Mais maintenant, j'avais d√©j√† une version de travail de tous les algorithmes en Python, il ne restait plus qu'√† "r√©√©crire". </p><br><p>  La bonne nouvelle m'attendait depuis le tout d√©but: il s'est av√©r√© que Rust, avec son syst√®me de type, d√©crit parfaitement les structures de donn√©es pour ma t√¢che.  Par exemple, l'une des correspondances de base <em>BinaryColor + BinaryBlock</em> / <em>MultiColor + ColoredBlock vous</em> permet de s√©parer de fa√ßon permanente les nonogrammes noir et blanc et couleur.  Si, quelque part dans le code, nous essayons de r√©soudre une cha√Æne color√©e √† l'aide de blocs de description binaires ordinaires, nous obtenons une erreur de compilation sur la non-concordance de type. </p><br><div class="spoiler">  <b class="spoiler_title">Les types de base ressemblent √† ceci</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">blank</span></span></span></span>() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_solved</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">solution_rate</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_updated_with</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, new: &amp;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">variants</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_color_id</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;ColorId&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_color_ids</span></span></span></span>(ids: &amp;[ColorId]) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Block</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span>: Color; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_str_and_color</span></span></span></span>(s: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, color: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;ColorId&gt;) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> size = s.parse::&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;().expect(<span class="hljs-string"><span class="hljs-string">"Non-integer block size given"</span></span>); Self::from_size_and_color(size, color) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_size_and_color</span></span></span></span>(size: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, color: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;ColorId&gt;) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">color</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Self::Color; } <span class="hljs-meta"><span class="hljs-meta">#[derive(Debug, PartialEq, Eq, Hash, Clone)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Description</span></span></span></span>&lt;T: Block&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T: Block, { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> vec: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;T&gt;, } <span class="hljs-comment"><span class="hljs-comment">// for black-and-white puzzles #[derive(Debug, PartialEq, Eq, Hash, Copy, Clone, PartialOrd)] pub enum BinaryColor { Undefined, White, Black, BlackOrWhite, } impl Color for BinaryColor { // omitted } #[derive(Debug, PartialEq, Eq, Hash, Default, Clone)] pub struct BinaryBlock(pub usize); impl Block for BinaryBlock { type Color = BinaryColor; // omitted } // for multicolor puzzles #[derive(Debug, PartialEq, Eq, Hash, Default, Copy, Clone, PartialOrd, Ord)] pub struct MultiColor(pub ColorId); impl Color for MultiColor { // omitted } #[derive(Debug, PartialEq, Eq, Hash, Default, Clone)] pub struct ColoredBlock { size: usize, color: ColorId, } impl Block for ColoredBlock { type Color = MultiColor; // omitted }</span></span></code> </pre> </div></div><br><p>  Lors du portage du code, certains points ont clairement indiqu√© qu'un langage typ√© statiquement tel que Rust (enfin, ou, par exemple, C ++) est plus appropri√© pour cette t√¢che.  Plus pr√©cis√©ment, les g√©n√©riques et les traits d√©crivent un domaine mieux que les hi√©rarchies de classes.  Donc, dans le code Python, j'avais deux classes pour un <code>BguSolver</code> lin√©aire, <code>BguSolver</code> et <code>BguColoredSolver</code> qui r√©solvaient respectivement une ligne en noir et blanc et une ligne en couleur.  Dans le code Rust, j'ai toujours la seule <code>struct DynamicSolver&lt;B: Block, S = &lt;B as Block&gt;::Color&gt;</code> g√©n√©rique <code>struct DynamicSolver&lt;B: Block, S = &lt;B as Block&gt;::Color&gt;</code> , qui peut r√©soudre les deux types de t√¢ches, selon le type pass√© lors de la cr√©ation ( <code>DynamicSolver&lt;BinaryBlock&gt;, DynamicSolver&lt;ColoredBlock&gt;</code> ).  Bien s√ªr, cela ne signifie pas que quelque chose de similaire ne peut pas √™tre fait en Python, juste dans Rust, le syst√®me de type m'a clairement indiqu√© que si vous n'alliez pas de cette fa√ßon, vous auriez √† √©crire une tonne de code r√©p√©titif. </p><br><p>  De plus, quiconque a essay√© d'√©crire dans Rust, a sans aucun doute remarqu√© l'effet de la ¬´confiance¬ª dans le compilateur, lorsque le processus d'√©criture du code se r√©sume √† l'algorithme pseudo-m√©ta suivant: </p><br><pre> write_initial_code
 while (compiler_hints = $ (cargo check))! = 0;  faire
     fix_errors (compiler_hints)
 fin
</pre><br><p>  Lorsque le compilateur cesse d'√©mettre des erreurs et des avertissements, votre code sera coh√©rent avec le syst√®me de type et le v√©rificateur d'emprunt et vous pr√©viendrez √† l'avance l'occurrence d'un tas de bogues potentiels (bien s√ªr, sous r√©serve d'une conception soign√©e des types de donn√©es). </p><br><p>  Je vais donner quelques exemples de fonctions qui montrent √† quel point le code Rust peut √™tre concis (par rapport aux √©quivalents Python). </p><br><div class="spoiler">  <b class="spoiler_title">unsolved_neighbours</b> <div class="spoiler_text"><p>  Donne une liste de "voisins" non r√©solus pour un point donn√© (x, y) </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsolved_neighbours</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, position)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.neighbours(position): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.is_cell_solved(*pos): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> pos</code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsolved_neighbours</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, point: &amp;Point) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Iterator</span></span>&lt;Item = Point&gt; + <span class="hljs-symbol"><span class="hljs-symbol">'_</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.neighbours(&amp;point) .into_iter() .filter(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |n| !<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cell(n).is_solved()) }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">partial_sums</b> <div class="spoiler_text"><p>  Pour un ensemble de blocs d√©crivant une ligne, donnez des sommes partielles (en tenant compte des espaces requis entre les blocs). Les indices r√©sultants indiqueront la position minimale √† laquelle le bloc peut se terminer (cette information sera utilis√©e plus tard pour un solveur lin√©aire). </p><br><p>  Par exemple, pour un tel ensemble de blocs <code>[2, 3, 1]</code> nous avons √† la sortie <code>[2, 6, 8]</code> , ce qui signifie que le premier bloc peut √™tre d√©plac√© au maximum vers la gauche afin que son bord droit occupe la 2e cellule, de m√™me pour le reste blocs: </p><br><pre>             1 2 3 4 5 6 7 8 9 
             _ _ _ _ _ _ _ _ _ _
      2 3 1 | _ | _ | _ | _ | _ | _ | _ | _ | _ | 
               ^ ^ ^
               |  |  |
 fin d'un bloc |  |  | 
 fin du bloc 2 -------- |
 fin du bloc 3 ------------
</pre><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@expand_generator def partial_sums(blocks): if not blocks: return sum_so_far = blocks[0] yield sum_so_far for block in blocks[1:]: sum_so_far += block + 1 yield sum_so_far</span></span></code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">partial_sums</span></span></span></span>(desc: &amp;[<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>]) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { desc.iter() .scan(<span class="hljs-literal"><span class="hljs-literal">None</span></span>, |prev, block| { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> current = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> prev_size) = prev { prev_size + block.<span class="hljs-number"><span class="hljs-number">0</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { block.<span class="hljs-number"><span class="hljs-number">0</span></span> }; *prev = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(current); *prev }) .collect() }</code> </pre> </div></div><br><p>  Lors du portage, j'ai apport√© plusieurs modifications </p><br><ul><li>  le noyau du solveur (algorithmes) a subi des modifications mineures (principalement pour prendre en charge les types g√©n√©riques pour les cellules et les blocs) </li><li>  laiss√© le seul algorithme (le plus rapide) pour le solveur lin√©aire </li><li>  au lieu du format ini, introduit un format TOML l√©g√®rement modifi√© </li><li>  n'a pas ajout√© la prise en charge des mots crois√©s effac√©s, car, √† proprement parler, il s'agit d'une classe de t√¢ches diff√©rente </li><li><p>  laiss√© le seul moyen de sortie - juste √† la console, mais maintenant les cellules color√©es dans la console sont dessin√©es vraiment color√©es (gr√¢ce √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette caisse</a> ) </p><br><div class="spoiler">  <b class="spoiler_title">comme √ßa</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xm/fd/ez/xmfdezlfahkoksuj3h0djom3p9k.png" alt="Jack moineau"></p><br></div></div><br></li></ul><br><h3 id="poleznye-instrumenty">  Des outils utiles </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">clippy</a> est un analyseur statique standard qui peut m√™me parfois donner des conseils augmentant l√©g√®rement les performances du code. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">valgrind</a> est un outil d'analyse dynamique des applications.  Je l'ai utilis√© comme profileur pour rechercher des botneks ( <code>valrgind --tool=callgrind</code> ) et en particulier des sections de code <code>valrgind --tool=massif</code> ( <code>valrgind --tool=massif</code> ).  Astuce: d√©finissez <em>[profile.release] debug = true</em> sur Cargo.toml avant de d√©marrer le profileur.  Cela laissera des caract√®res de d√©bogage dans l'ex√©cutable. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">kcachegrind</a> pour afficher les fichiers de callgrind.  Un outil tr√®s utile pour trouver les endroits les plus probl√©matiques en termes de performances. </li></ul><br><h3 id="proizvoditelnost">  Performances </h3><br><p>  C'est pour √ßa que la r√©√©criture sur Rust a commenc√©.  Nous prenons les mots crois√©s du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tableau de comparaison</a> d√©j√† mentionn√© et les ex√©cutons √† travers les meilleurs solveurs d√©crits dans l'article d'origine.  R√©sultats et description des runs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Nous prenons le <a href="">fichier</a> r√©sultant et construisons quelques graphiques dessus. Comme le temps de r√©solution varie de quelques millisecondes √† des dizaines de minutes, le graphique est fait avec une √©chelle logarithmique. </p><br><div class="spoiler">  <b class="spoiler_title">courir dans un ordinateur portable jupyter</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt %matplotlib inline <span class="hljs-comment"><span class="hljs-comment"># strip the spaces df = pd.read_csv('perf.csv', skipinitialspace=True) df.columns = df.columns.str.strip() df['name'] = df['name'].str.strip() # convert to numeric df = df.replace('\+\ *', np.inf, regex=True) ALL_SOLVERS = list(df.columns[3:]) df.loc[:,ALL_SOLVERS] = df.loc[:,ALL_SOLVERS].apply(pd.to_numeric) # it cannot be a total zero df = df.replace(0, 0.001) #df.set_index('name', inplace=True) SURVEY_SOLVERS = [s for s in ALL_SOLVERS if not s.endswith('_my')] MY_MACHINE_SOLVERS = [s for s in ALL_SOLVERS if s.endswith('_my') and s[:-3] in SURVEY_SOLVERS] MY_SOLVERS = [s for s in ALL_SOLVERS if s.endswith('_my') and s[:-3] not in SURVEY_SOLVERS] bar_width = 0.17 df_compare = df.replace(np.inf, 10000, regex=True) plt.rcParams.update({'font.size': 20}) def compare(first, others): bars = [first] + list(others) index = np.arange(len(df)) fig, ax = plt.subplots(figsize=(30,10)) df_compare.sort_values(first, inplace=True) for i, column in enumerate(bars): ax.bar(index + bar_width*i, df_compare[column], bar_width, label=column[:-3]) ax.set_xlabel("puzzles") ax.set_ylabel("Time, s (log)") ax.set_title("Compare '{}' with others (lower is better)".format(first[:-3])) ax.set_xticks(index + bar_width / 2) ax.set_xticklabels("#" + df_compare['ID'].astype(str) + ": " + df_compare['name'].astype(str)) ax.legend() plt.yscale('log') plt.xticks(rotation=90) plt.show() fig.savefig(first[:-3] + '.png', bbox_inches='tight') for my in MY_SOLVERS: compare(my, MY_MACHINE_SOLVERS) compare(MY_SOLVERS[0], MY_SOLVERS[1:])</span></span></code> </pre> </div></div><br><h5 id="python-solver">  solveur python </h5><br><p> <a href=""><img src="https://habrastorage.org/webt/si/qb/5o/siqb5ohxk_bjjaulmkohy1uhzkw.png" alt="performances du pynogramme"><br></a> <br>  (l' <em>image est cliquable</em> ) </p><br><p>  Nous voyons que le <em>pynogramme</em> ici est plus lent que tous les solveurs pr√©sent√©s.  La seule exception √† cette r√®gle est le solveur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tamura / Copris</a> bas√© sur SAT, qui r√©sout les puzzles les plus simples (la partie gauche du graphique) plus longtemps que le n√¥tre.  Cependant, c'est une caract√©ristique des solveurs SAT: ils sont con√ßus pour des mots crois√©s super complexes dans lesquels un solveur r√©gulier est coinc√© dans le retour arri√®re pendant une longue p√©riode.  Ceci est clairement visible sur le c√¥t√© droit du graphique, o√π <em>Tamura / Copris</em> r√©sout les puzzles les plus difficiles des dizaines et des centaines de fois plus rapidement que tout le monde. </p><br><h5 id="rust-solver">  solveur de rouille </h5><br><p> <a href=""><img src="https://habrastorage.org/webt/bh/be/cb/bhbecb0ccinpwfhysauyjkrcx24.png" alt="performance non-grille"><br></a> <br>  (l' <em>image est cliquable</em> ) </p><br><p>  Ce graphique montre que les <em>non</em> - <em>grids</em> sur des t√¢ches simples <em>supportent</em> √©galement ou l√©g√®rement pire que les solveurs hautes performances √©crits en C et C ++ ( <em>Wolter</em> et <em>Syromolotov</em> ).  Avec la complication des t√¢ches, notre solveur r√©p√®te approximativement la trajectoire du solveur <em>BGU</em> (Java), mais presque toujours devant lui d'environ un ordre de grandeur.  Sur les t√¢ches les plus difficiles, <em>Tamura / Copris</em> est toujours en avance sur tout le monde. </p><br><h5 id="rust-vs-python">  rouille vs python </h5><br><p> <a href=""><img src="https://habrastorage.org/webt/ih/0b/2r/ih0b2rnmyk5o_rpgckz_5hkkifc.png" alt="py-vs-rust-performance"><br></a> <br>  (l' <em>image est cliquable</em> ) </p><br><p>  Et enfin, une comparaison de nos deux solveurs d√©crits ici.  On peut voir que le solveur Rust est presque toujours √† 1 √† 3 ordres de grandeur devant le solveur Python. </p><br><h3 id="itogihttpsgithubcomtsionyxnonogrid">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">R√©sum√©</a> : </h3><br><p>  <strong>+ le</strong> solveur peut r√©soudre tous les puzzles des sites <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://webpbn.com</a> (sauf buvard - avec des tailles de bloc partiellement masqu√©es), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://nonograms.org</a> et son propre format (bas√© sur TOML) </p><br><p>  <strong>+</strong> r√©sout les nonogrammes noir et blanc et couleur avec n'importe quel nombre de couleurs </p><br><p>  <strong>+</strong> peut rendre des puzzles sur la console (la couleur c webpbn.com dessine la vraie couleur) </p><br><p>  <strong>+</strong> fonctionne rapidement (en comparaison avec les impl√©mentations d√©crites dans l'article-comparaison des solveurs, voir tableau). </p><br><p>  <strong>- le</strong> retour en arri√®re est rest√© inefficace, comme dans la solution Python: certains casse-t√™te (par exemple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">, un tel 20x20 inoffensif</a> ) peuvent √™tre r√©solus pendant des heures (lorsque l'arbre de d√©cision est tr√®s grand).  Peut-√™tre qu'au lieu de revenir en arri√®re, vous devriez utiliser les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">solveurs SAT</a> d√©j√† mentionn√©s sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le concentrateur</a> .  Certes, le seul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">solveur SAT</a> que j'ai trouv√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur Rust</a> √† premi√®re vue semble inachev√© et abandonn√©. </p><br><h2 id="webassembly">  Webassembly </h2><br><p>  La r√©√©criture du code dans Rust a donc port√© ses fruits: le solveur est devenu beaucoup plus rapide.  Cependant, Rust nous offre une autre fonctionnalit√© incroyablement cool: la compilation dans WebAssembly et la possibilit√© d'ex√©cuter votre code directement dans le navigateur. </p><br><p>  Pour impl√©menter cette fonctionnalit√©, il existe un outil sp√©cial pour Rust qui fournit les liants n√©cessaires et g√©n√®re un passe-partout pour que vous puissiez ex√©cuter sans douleur les fonctions Rust en code JS - ce <em>wasm-pack</em> (+ <em>wasm-bindgen</em> ).  La plupart du travail avec celui-ci et d'autres outils importants est d√©j√† d√©crit dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">didacticiel Rust et WebAssembly</a> .  Cependant, il y a quelques points que j'ai d√ª comprendre par moi-m√™me: </p><br><ul><li><p>  lors de la lecture, cela donne l'impression que le tutoriel est principalement √©crit pour un d√©veloppeur JS qui souhaite acc√©l√©rer son code avec Rust.  Eh bien, ou du moins pour quelqu'un qui conna√Æt bien <em>npm</em> .  Pour moi, en tant que personne loin du front-end, il √©tait surprenant de constater que m√™me l'exemple standard du livre ne voulait pas fonctionner avec un serveur Web tiers diff√©rent de <code>npm run start</code> . </p><br><p>  Heureusement, wasm-pack dispose d'un mode qui vous permet de g√©n√©rer du code JS standard (qui n'est pas un module npm).  <code>wasm-pack build --target no-modules --no-typescript</code> ne donnera que deux fichiers dans la sortie: <em>project-name.wasm</em> - le binaire du code Rust compil√© dans WebAssembly et <em>project-name.js</em> .  Le dernier fichier peut √™tre ajout√© √† n'importe quelle page HTML <code>&lt;script src="project-name.js"&gt;&lt;/script&gt;</code> et utiliser les fonctions WASM sans se soucier de npm, webpack, ES6, des modules et autres joies du d√©veloppeur JS moderne.  Le mode <code>no-modules</code> est id√©al pour les d√©veloppeurs non frontaux lors du d√©veloppement d'une application WASM, ainsi que pour les exemples et les d√©mos, car il ne n√©cessite aucune infrastructure frontale suppl√©mentaire. </p><br></li><li><p>  WebAssembly convient aux t√¢ches trop lourdes pour JavaScript.  Tout d'abord, ce sont des t√¢ches qui effectuent de nombreux calculs.  Et si c'est le cas, une telle t√¢che peut √™tre effectu√©e pendant longtemps m√™me avec WebAssembly et ainsi violer le principe asynchrone du web moderne.  Je parle de toutes sortes d' <em>avertissement: script ne r√©pondant pas</em> que j'ai observ√© lorsque mon solveur fonctionnait.  Pour r√©soudre ce probl√®me, vous pouvez utiliser le m√©canisme de <em>travail Web</em> .  Dans ce cas, le sch√©ma de travail avec les fonctions WASM "lourdes" peut ressembler √† ceci: </p><br><ol><li>  √† partir du script principal d'un √©v√©nement (par exemple, en cliquant sur un bouton) envoyer un message au travailleur avec la t√¢che de lancer une fonction lourde. </li><li>   ,        . </li><li>      -   () </li></ol><br></li></ul><br><p>   WASM-         JS,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  WASM</a> .      -   (       ),     <code>HashMap</code>       ,     .    ( JS)    ,          /   . </p><br><p>       ,  <a href="">  Mutex</a> ,        thread-safe.       smart-    .   thread-safe     <em>Rc</em>  <em>Arc</em>  <em>RefCell</em>  <em>RwLock</em> .         :         30%.         <code>--features=threaded</code>      thread-safe ,     WASM-. </p><br><p>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6574</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">8098</a>    (     10 ): </p><br><div class="scrollable-table"><table><thead><tr><th> id </th><th> non-thread-safe </th><th> thread-safe </th><th> web-interface </th></tr></thead><tbody><tr><td> 6574 </td><td>  5.4 </td><td> 7.4 </td><td>  9.2 </td></tr><tr><td> 8098 </td><td> 21.5 </td><td> 28.4 </td><td> 29.9 </td></tr></tbody></table></div><br><p> ,   -    40..70% ,       ,      (32..37%)      thread-safe  ( <code>cargo build --release --features=threaded</code> ). </p><br><p>    Firefox 67.0  Chromium 74.0. </p><br><p> WASM-   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ).            <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://webpbn.com/</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://www.nonograms.org/</a> </p><br><h3 id="todo"> TODO </h3><br><ul><li><p> ""  /,  /    . </p><br></li><li><p>     ,     .      "" ,    ,        .      . </p><br></li><li><p>     (    ,      3600 ).  WASM     ,     (  ,   (!) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ,   ,     WASM). ,  , -  ,       nonogrid  . </p><br></li><li><p>   .      : ,       ,      WASM   .    ,         ( )    ,    JS  ,      . </p><br></li><li><p>     JS.         backtrace,       . </p><br></li><li><p>        (     <a href="">TOML-</a> ) </p><br></li></ul><br><h2 id="itogi">  R√©sum√© </h2><br><ul><li><p>           ,    (, , etc). </p><br></li><li><p>   Rust  1-3     PyPy       1.5-2  (  ). </p><br></li><li><p>    Python  Rust  ,            Python (, , comprehensions),      Rust-. </p><br></li><li><p>   Rust  WebAssembly   .     Rust ,   WASM,      (     1.5  ). </p><br></li></ul><br><h2 id="osnovnye-istochniki">   </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">The 'pbnsolve' Paint-by-Number Puzzle Solver by Jan Wolter</a> and the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">survey</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">The BGU Nonograms Project</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Solving Nonograms by combining relaxations</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">An Efficient Approach to Solving Nonograms</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">      </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Color and black and white Japanese crosswords on-line</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">      </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">'Nonolib' library by Dr. Steven Simpson</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rust and WebAssembly</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454586/">https://habr.com/ru/post/fr454586/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454574/index.html">Apprentissage automatique en microfinance: construire un mod√®le de notation pour les clients avec un historique de cr√©dit vide</a></li>
<li><a href="../fr454576/index.html">Les auteurs de GandCrab cessent de travailler: ils pr√©tendent en avoir assez vol√©</a></li>
<li><a href="../fr454578/index.html">Comment connecter la galerie PhotoSwipe dans la vue Web Android</a></li>
<li><a href="../fr454582/index.html">La longueur du tableau doit-elle √™tre stock√©e dans une variable locale en C #?</a></li>
<li><a href="../fr454584/index.html">√âcole de d√©veloppement d'interface: analyse des t√¢ches pour Minsk et un nouvel ensemble √† Moscou</a></li>
<li><a href="../fr454588/index.html">Gazprom Neft vous invite √† visiter: GPN Data Science Meetup</a></li>
<li><a href="../fr454590/index.html">Zimbra Collaboration Suite et Mobile Control avec ABQ</a></li>
<li><a href="../fr454592/index.html">WAF √† travers les yeux des pirates</a></li>
<li><a href="../fr454596/index.html">Mod√®les mentaux en s√©curit√© de l'information</a></li>
<li><a href="../fr454598/index.html">Architecture sans serveur et microservices: l'accord parfait?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>