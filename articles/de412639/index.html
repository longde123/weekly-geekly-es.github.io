<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≥üèø üë®üèæ‚Äçü§ù‚Äçüë®üèº üßõüèª Worauf Sie warten m√ºssen, um Strategien f√ºr den Handel an der B√∂rse zu entwickeln: Wie effizient maschinelles Lernen ist üßï üé§ üêè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In unserem Blog √ºber Habr√© haben wir angepasste √úbersetzungen von Materialien aus dem Blog The Financial Hacker ver√∂ffentlicht, die sich mit Fragen de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Worauf Sie warten m√ºssen, um Strategien f√ºr den Handel an der B√∂rse zu entwickeln: Wie effizient maschinelles Lernen ist</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/iticapital/blog/412639/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/pq/lc/zm/pqlczmojlxuisfxberyvpnismeu.png"></a> <br><br>  In unserem Blog √ºber Habr√© haben wir angepasste √úbersetzungen von Materialien aus dem Blog The Financial Hacker ver√∂ffentlicht, die sich mit Fragen der Entwicklung von Strategien f√ºr den Handel an der B√∂rse befassen.  Zuvor haben wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Suche nach Marktineffizienzen</a> , die Erstellung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Modellen f√ºr Handelsstrategien</a> und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prinzipien ihrer Programmierung</a> er√∂rtert.  Heute konzentrieren wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">uns</a> auf die Verwendung von Ans√§tzen des maschinellen Lernens, um die Effizienz von Handelssystemen zu verbessern. <br><br>  Der erste Computer, der die Schachweltmeisterschaft gewann, war Deep Blue.  Das war 1996 und weitere zwanzig Jahre vergingen, bis es einem anderen Programm, Alpha Go, gelang, den besten Spieler in Go zu besiegen.  Deep Blue war ein modellorientiertes System mit eingebetteten Schachregeln.  AplhaGo ist ein Data Mining-System, ein tiefes neuronales Netzwerk, das mit Tausenden von Spielen in Go trainiert wurde.  Das hei√üt, um einen Schritt von Siegen √ºber Schachmeister zu machen und die Top-Spieler in Go zu dominieren, war kein verbessertes St√ºck Eisen notwendig, sondern ein Durchbruch im Bereich Software. <br><br>  Im aktuellen Artikel werden wir die Anwendung des Data Mining-Ansatzes zur Erstellung von Handelsstrategien in Betracht ziehen.  Diese Methode ber√ºcksichtigt keine Marktmechanismen, sondern scannt einfach Preiskurven und andere Datenquellen, um nach Vorhersagemustern zu suchen.  Maschinelles Lernen oder ‚Äûk√ºnstliche Intelligenz‚Äú sind hierf√ºr nicht immer erforderlich.  Im Gegenteil, sehr oft funktionieren die beliebtesten und rentabelsten Methoden des Data Mining ohne Schnickschnack in Form von neuronalen Netzen oder Unterst√ºtzung f√ºr Vektormethoden. <a name="habracut"></a><br><br><h2>  Prinzipien des maschinellen Lernens </h2><br>  Der trainierte Algorithmus wird mit Datenproben gespeist, die normalerweise irgendwie aus historischen Wechselkursen extrahiert werden.  Jede Stichprobe besteht aus n Variablen x1 ... xn, die √ºblicherweise als Pr√§diktoren, Funktionen, Signale oder einfacher als Eingabedaten bezeichnet werden.  Diese Pr√§diktoren k√∂nnen die Preise der letzten n Balken im Preisdiagramm oder eine Reihe von Werten klassischer Indikatoren oder andere Funktionen der Preiskurve sein (es gibt sogar F√§lle, in denen einzelne Pixel des Preisdiagramms als Pr√§diktoren f√ºr ein neuronales Netzwerk verwendet werden!).  Jede Stichprobe enth√§lt normalerweise auch eine bestimmte Zielvariable y, beispielsweise das Ergebnis der n√§chsten Transaktion nach Analyse der Stichprobe oder der n√§chsten Preisbewegung. <br><br>  In der Literatur wird y oft als Bezeichnung oder Ziel bezeichnet.  W√§hrend des Lernprozesses lernt der Algorithmus, das Ziel y basierend auf den Pr√§diktoren x1 ... xn vorherzusagen.  Was sich das System im Prozess ‚Äûmerkt‚Äú, wird in einer Datenstruktur gespeichert, die als Modell bezeichnet wird, das f√ºr einen bestimmten Algorithmus spezifisch ist (es ist wichtig, dieses Konzept nicht mit einem Finanzmodell oder einer modellorientierten Strategie zu verwechseln).  Ein maschinelles Lernmodell kann Funktionen mit Vorhersageregeln sein, die unter Verwendung von C-Code geschrieben wurden, der durch den Lernprozess erzeugt wird.  Oder es k√∂nnte sich um eine Reihe von Gewichten handeln, die mit dem neuronalen Netzwerk zusammenh√§ngen: <br><br><blockquote>  Training: x1 ... xn, y =&gt; Modell <br><br>  Vorhersage: x1 ... xn, Modell =&gt; y <br></blockquote><br>  Pr√§diktoren, Funktionen oder wie auch immer Sie sie aufrufen m√∂chten, sollten Informationen enthalten, die ausreichen, um Vorhersagen √ºber den Wert des Ziels y mit einer bestimmten Genauigkeit zu generieren.  Sie m√ºssen au√üerdem zwei formale Kriterien erf√ºllen.  Erstens m√ºssen alle Pr√§diktorwerte im gleichen Bereich liegen, z. B. -1 ... +1 (f√ºr die meisten Algorithmen auf R) oder -100 ... +100 (f√ºr Algorithmen in den Skriptsprachen Zorro oder TSSB).  Bevor Sie Daten an das System senden, m√ºssen Sie sie normalisieren.  Zweitens m√ºssen die Abtastwerte ausgeglichen sein, dh gleichm√§√üig √ºber die Werte der Zielvariablen verteilt sein.  Das hei√üt, Sie sollten die gleiche Anzahl von Stichproben haben, die zu einem positiven Ergebnis f√ºhren und S√§tze verlieren.  Wenn diese beiden Anforderungen nicht erf√ºllt werden, sind gute Ergebnisse nicht erfolgreich. <br><br>  Regressionsalgorithmen generieren Vorhersagen √ºber numerische Werte wie die Gr√∂√üe oder das Vorzeichen der n√§chsten Preisbewegung.  Klassifizierungsalgorithmen sagen quantitative Klassen von Stichproben voraus, beispielsweise, ob sie dem Gewinn oder Verlust von Geldern vorausgehen.  Einige Algorithmen wie neuronale Netze, Entscheidungsb√§ume oder Unterst√ºtzungsvektormethoden k√∂nnen in beiden Modi ausgef√ºhrt werden. <br><br>  Es gibt auch Algorithmen, die lernen k√∂nnen, aus Klassenproben zu extrahieren, ohne dass ein Ziel y erforderlich ist.  Dies wird als unbeaufsichtigtes Lernen bezeichnet, im Gegensatz zu √ºberwachtem Lernen.  Irgendwo zwischen diesen beiden Methoden befindet sich das ‚ÄûVerst√§rkungslernen‚Äú, bei dem das System durch Ausf√ºhren von Simulationen mit bestimmten Funktionen trainiert und das Ergebnis als Ziel verwendet.  Ein Anh√§nger von AlphaGo, einem System namens AlphaZero, nutzte verst√§rktes Lernen und spielte eine Million Go-Spiele mit sich selbst.  Im Finanzbereich sind solche Systeme oder Produkte, die unbeaufsichtigtes Lernen verwenden, √§u√üerst selten.  99% der Systeme verwenden √ºberwachtes Lernen. <br><br>  Unabh√§ngig davon, welche Signale wir f√ºr Pr√§diktoren im Finanzbereich verwenden, enthalten sie in den meisten F√§llen viel Rauschen und wenig Informationen und sind dar√ºber hinaus instabil.  Finanzielle Prognosen sind daher eine der schwierigsten Aufgaben des maschinellen Lernens.  Komplexere Algorithmen erzielen hier bessere Ergebnisse.  Die Auswahl der Pr√§diktoren ist entscheidend f√ºr den Erfolg.  Es m√ºssen nicht unbedingt viele vorhanden sein, da dies zu Umschulungen und Fehlfunktionen f√ºhrt.  Daher verwenden Data Mining-Strategien h√§ufig einen vorgew√§hlten Algorithmus, der eine kleine Anzahl von Pr√§diktoren aus einem gr√∂√üeren Pool extrahiert.  Eine solche vorl√§ufige Auswahl kann auf der Korrelation zwischen Pr√§diktoren, ihrer Bedeutung, ihrem Informationsreichtum oder einfach auf dem Erfolg / Misserfolg der Verwendung der Testsuite beruhen.  Praktische Experimente zur Zielauswahl finden Sie beispielsweise im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Robot Wealth-</a> Blog. <br><br>  Nachfolgend finden Sie eine Liste der beliebtesten Methoden des Data Mining im Finanzbereich. <br><br><h2>  1. Suppe von Indikatoren </h2><br>  Die meisten Handelssysteme basieren nicht auf Finanzmodellen.  Oft ben√∂tigen H√§ndler nur Handelssignale, die von bestimmten technischen Indikatoren generiert werden und die von anderen Indikatoren in Kombination mit zus√§tzlichen technischen Indikatoren gefiltert werden.  Wenn er einen H√§ndler fragt, wie eine solche Mischung von Indikatoren zu einer Art Gewinn f√ºhren kann, antwortet er normalerweise wie folgt: ‚ÄûGlaub mir, ich tausche meine H√§nde und alles funktioniert.‚Äú <br><br>  Und das ist die Wahrheit.  Zumindest manchmal.  Obwohl die meisten dieser Systeme den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WFA-Test</a> nicht bestehen (und einige lediglich historische Daten testen), funktioniert eine √ºberraschend gro√üe Anzahl solcher Systeme letztendlich und erzielt einen Gewinn.  Der Autor des Blogs Financial Hacker besch√§ftigt sich mit der Entwicklung kundenspezifischer Handelssysteme und erz√§hlt die Geschichte eines Kunden, der systematisch mit technischen Indikatoren experimentierte, bis er eine Kombination fand, die f√ºr bestimmte Arten von Verm√∂genswerten funktioniert.  Diese Trial-and-Error-Methode ist ein klassischer Ansatz f√ºr das Data Mining. F√ºr den Erfolg ben√∂tigen Sie sie nur, viel Gl√ºck und viel Geld f√ºr Tests.  Daher k√∂nnen Sie manchmal mit einem profitablen System rechnen. <br><br><h2>  2. Kerzenmuster </h2><br>  Nicht zu verwechseln mit Kerzenmustern, die es seit Hunderten von Jahren gibt.  Das moderne √Ñquivalent dieses Ansatzes ist der Handel auf der Grundlage von Preisbewegungen.  Sie analysieren auch die offenen, hohen, niedrigen und geschlossenen Indikatoren f√ºr jede Kerze im Diagramm.  Jetzt verwenden Sie Data Mining, um die Kerzen der Preiskurve zu analysieren und Muster hervorzuheben, mit denen Vorhersagen √ºber die Richtung der Preisbewegung in der Zukunft erstellt werden k√∂nnen. <br><br>  Zu diesem Zweck gibt es ganze Softwarepakete.  Sie suchen nach Mustern, die in Bezug auf benutzerdefinierte Kriterien rentabel sind, und verwenden sie, um eine Mustererkennungsfunktion aufzubauen.  All dies k√∂nnte ungef√§hr so ‚Äã‚Äãaussehen: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">detect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">* sig)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">0</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">5</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">7</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">7</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">8</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">8</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">1</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">2</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">5</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">3</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">7</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">8</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">4</span></span>] &amp;&amp; eqF(sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]-sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]) &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">2</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">3</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">7</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">8</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">4</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">5</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">2</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">0</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">7</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">8</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">5</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">3</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">7</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">7</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">8</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">8</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Diese C-Funktion gibt 1 zur√ºck, wenn das Signal mit einem der Muster √ºbereinstimmt, andernfalls gibt sie 0 zur√ºck. Der lange Code scheint darauf hinzudeuten, dass dies nicht der schnellste Weg ist, nach Mustern zu suchen.  Es ist besser, einen Ansatz zu verwenden, bei dem die Erkennungsfunktion nicht exportiert werden muss, sondern die Signale nach ihrer Wichtigkeit sortieren und sortieren kann.  Ein Beispiel f√ºr ein solches System finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unter dem Link</a> . <br><br>  Kann Handel zu einem Preis funktionieren?  Wie im vorherigen Fall basiert diese Methode nicht auf einem rationalen Finanzmodell.  Gleichzeitig versteht jeder, dass wirklich bestimmte Ereignisse auf dem Markt seine Teilnehmer beeinflussen k√∂nnen, wodurch kurzfristige Vorhersagemuster entstehen.  Die Anzahl solcher Muster kann jedoch nicht gro√ü sein, wenn Sie nur die Reihenfolge mehrerer aufeinanderfolgender Kerzen in der Tabelle untersuchen.  Dann m√ºssen Sie das Ergebnis mit den Daten der Kerzen vergleichen, die nicht in der N√§he sind, sondern im Gegenteil √ºber einen l√§ngeren Zeitraum zuf√§llig ausgew√§hlt werden.  In diesem Fall erhalten Sie eine nahezu unbegrenzte Anzahl von Mustern - und l√∂sen sich erfolgreich von den Konzepten von Realit√§t und Rationalit√§t.  Es ist schwer vorstellbar, wie der zuk√ºnftige Preis auf der Grundlage einiger seiner Werte in der letzten Woche vorhergesagt werden kann.  Trotzdem arbeiten viele H√§ndler in diese Richtung. <br><br><h2>  3. Lineare Regression </h2><br>  Eine einfache Basis f√ºr viele komplexe Algorithmen f√ºr maschinelles Lernen: Vorhersage der Zielvariablen y unter Verwendung einer linearen Kombination von Pr√§diktoren x1 ... xn. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3d0/230/0e1/3d02300e11bdf79ba483a647d5089421.png" alt="Bild"><br><br>  Gewinnchancen - das ist das Modell.  Sie werden berechnet, um die Summe der quadratischen Abweichungen zwischen realen y-Werten, Trainingswerten und vorhergesagtem y gem√§√ü der folgenden Formel zu minimieren: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc7/06c/d46/bc706cd46620a7d8682eb18e16daeeda.png" alt="Bild"><br><br>  Bei normalverteilten Stichproben ist eine Minimierung mithilfe von Matrixoperationen m√∂glich, sodass keine Iterationen erforderlich sind.  In dem Fall, in dem n = 1 ist - mit nur einem Pr√§diktor x, wird die Regressionsformel reduziert auf: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/adc/a79/e98/adca79e98f1193be9b631dbfe51dbc96.png" alt="Bild"><br><br>  - das hei√üt, vor einer einfachen linearen Regression und wenn n&gt; 1 ist, ist die lineare Regression multivariant.  Auf den meisten Handelsplattformen ist eine einfache lineare Regression verf√ºgbar, beispielsweise der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LinReg-</a> Indikator in TA-Lib.  Wenn y = Preis und x = Zeit, kann es als Alternative zu gleitenden Durchschnitten verwendet werden.  In der R-Plattform wird eine solche Regression durch die Standardlieferfunktion lm (..) implementiert.  Es kann auch durch Polynomregression dargestellt werden.  Wie im einfachsten Fall verwenden wir hier eine Vorhersagevariable x, aber auch deren Quadrat und nachfolgende Grade, also xn == xn: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/248/b3c/bd4/248b3cbd40c637b1a15376d227432e81.png" alt="Bild"><br><br>  Wenn n = 2 oder n = 3 ist, wird h√§ufig eine Polynomregression verwendet, um den n√§chsten Durchschnittspreis aus den gegl√§tteten Preisen der letzten Balken vorherzusagen.  F√ºr die Polynomregression kann die Polyfit-Funktion von MatLab, R, Zorro und vielen anderen Plattformen verwendet werden. <br><br><h2>  4. Perceptron </h2><br>  Oft wird es ein neuronales Netzwerk mit nur einem Neuron genannt.  Tats√§chlich ist das Perzeptron eine Regressionsfunktion, wie oben beschrieben, jedoch mit einem bin√§ren Ergebnis, aufgrund dessen es als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">logistische Regression bezeichnet wird</a> .  Dies ist zwar im Allgemeinen keine Regression, sondern ein Klassifizierungsalgorithmus.  Beispielsweise generiert die Beratungsfunktion (PERCEPTRON, ...) des Zorro-Frameworks C-Code, der 100 oder -100 zur√ºckgibt, je nachdem, ob das vorhergesagte Ergebnis ein Schwellenwert ist oder nicht: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">predict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">* sig)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">-27.99</span></span>*sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-number"><span class="hljs-number">1.24</span></span>*sig[<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">3.54</span></span>*sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">-21.50</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-100</span></span>; }</code> </pre> <br>  Wie Sie sehen k√∂nnen, entspricht das Sig-Array den Funktionen xn in der Regressionsformel, und die Koeffizienten an sind die digitalen Faktoren. <br><br><h2>  5. Neuronale Netze </h2><br>  Lineare oder logistische Regression kann nur lineare Probleme l√∂sen.  Gleichzeitig passen Handelsaufgaben oft nicht in diese Kategorie.  Ein ber√ºhmtes Beispiel ist die Vorhersage der Ausgabe einer einfachen XOR-Funktion.  Dies beinhaltet auch die Vorhersage des Gewinns aus Transaktionen.  Ein k√ºnstliches neuronales Netzwerk (ANN) kann nichtlineare Probleme l√∂sen.  Dies ist eine Reihe von Perzeptronen, die zu einer Reihe verschiedener Ebenen verbunden sind.  Jedes Perzeptron ist ein Netzwerkneuron.  Seine Ausgabe wird in andere Neuronen der folgenden Ebene eingegeben: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/050/d12/c5d/050d12c5da82f4f97fdd942d7777b8e4.png" alt="Bild"><br><br>  Wie das Perzeptron wird das neuronale Netzwerk trainiert, indem Koeffizienten bestimmt werden, die den Fehler zwischen der Vorhersage und dem Ziel in der Probe minimieren.  Dies erfordert einen Approximationsprozess, normalerweise mit der R√ºckausbreitung des Fehlers von der Ausgabe zur Eingabe mit der Optimierung der Gewichte auf dem Weg.  Dieser Prozess hat zwei Einschr√§nkungen.  Erstens sollte die Ausgabe von Neuronen eine kontinuierlich differenzierbare Funktion anstelle einer einfachen Schwelle f√ºr das Perzeptron sein.  Zweitens sollte das Netzwerk nicht sehr tief sein - das Vorhandensein einer gro√üen Anzahl versteckter Ebenen von Neuronen zwischen den Eingabe- und Ausgabedaten schadet nur.  Diese zweite Einschr√§nkung begrenzt die Komplexit√§t der Probleme, die ein neuronales Standardnetzwerk l√∂sen kann. <br><br>  Wenn Sie neuronale Netze zur Vorhersage von Transaktionen verwenden, k√∂nnen Sie viele Parameter manipulieren, die bei ungenauer Ausf√ºhrung zu einer Auswahlverzerrung (Auswahlverzerrung) f√ºhren k√∂nnen: <br><br><ul><li>  Anzahl der versteckten Ebenen; </li><li>  die Anzahl der Neuronen in jeder verborgenen Ebene; </li><li>  die Anzahl der Backpropagation-Zyklen - Epochen; </li><li>  Ausbildungsgrad, Schrittweite der √Ñra; </li><li>  Impuls, Tr√§gheitsfaktor zur Anpassung von Gewichten; </li><li>  Aktivierungsfunktion. </li></ul><br>  Die Aktivierungsfunktion emuliert die Perzeptronschwelle.  F√ºr die R√ºckausbreitung ben√∂tigen Sie eine st√§ndig differenzierbare Funktion, die einen weichen Schritt f√ºr einen bestimmten Wert von x erzeugt.  Typischerweise werden hierf√ºr Sigmoid-, Tanh- oder Softmax-Funktionen verwendet.  Manchmal wird eine lineare Funktion verwendet, die die gewichtete Summe aller Eingabedaten zur√ºckgibt.  In diesem Fall kann das Netzwerk zur Regression und Vorhersage numerischer Werte anstelle der bin√§ren Ausgabe verwendet werden. <br><br>  Neuronale Netze sind in der Standardpaketlieferung von R (z. B. nnet ist ein Netzwerk mit einer verborgenen Ebene) sowie in vielen anderen Paketen (wie RSNNS und FCNN4R) enthalten. <br><br><h2>  6. Tiefes Lernen </h2><br>  Deep-Learning-Methoden verwenden neuronale Netze mit vielen verborgenen Ebenen und Tausenden von Neuronen, die mit einfacher R√ºckausbreitung nicht effektiv trainiert werden k√∂nnen.  In den letzten Jahren sind verschiedene Methoden zum Trainieren derart gro√üer Netzwerke popul√§r geworden.  Sie beinhalten normalerweise das Vor-Training verborgener Ebenen von Neuronen, um die Effektivit√§t des grundlegenden Lernens zu erh√∂hen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die</a> Restricted Boltzmann Machine (RBM) ist ein unkontrollierter Klassifizierungsalgorithmus mit einer speziellen Netzwerkstruktur, bei der keine Verbindungen zwischen versteckten Neuronen bestehen.  Sparse Auto Encoder (SAE) verwendet die √ºbliche Netzwerkstruktur, trainiert jedoch verborgene Pegel auf eine bestimmte Weise vor und reproduziert Eingangssignale auf den Ausgangspegeln mit so wenig aktiven Verbindungen wie m√∂glich.  Mit diesen Methoden k√∂nnen Sie sehr komplexe Netzwerke implementieren, um sehr komplexe Lernprobleme zu l√∂sen.  Zum Beispiel die Aufgabe, die beste Person zu besiegen, die Go spielt. <br><br>  Deep-Learning-Netzwerke sind in den Deepnet- und Darch-Paketen f√ºr R enthalten. Deepnet enth√§lt den Auto-Encoder und Darch die Boltzmann-Maschine.  Unten finden Sie ein Beispiel f√ºr Code, der Deepnet mit drei versteckten Ebenen verwendet, um Handelssignale √ºber die neor () -Funktion des Zorro-Frameworks zu verarbeiten: <br><br><pre> <code class="cpp hljs">library(<span class="hljs-string"><span class="hljs-string">'deepnet'</span></span>, quietly = T) library(<span class="hljs-string"><span class="hljs-string">'caret'</span></span>, quietly = T) <span class="hljs-meta"><span class="hljs-meta"># called by Zorro for training neural.train = function(model,XY) { XY </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;- as.matrix(XY) X &lt;- XY[,-ncol(XY)] # predictors Y &lt;- XY[,ncol(XY)] # target Y &lt;- ifelse(Y &gt; 0,1,0) # convert -1..1 to 0..1 Models[[model]] &lt;&lt;- sae.dnn.train(X,Y, hidden = c(50,100,50), activationfun = "tanh", learningrate = 0.5, momentum = 0.5, learningrate_scale = 1.0, output = "sigm", sae_output = "linear", numepochs = 100, batchsize = 100, hidden_dropout = 0, visible_dropout = 0) } # called by Zorro for prediction neural.predict = function(model,X) { if(is.vector(X)) X &lt;- t(X) # transpose horizontal vector return(nn.predict(Models[[model]],X)) } # called by Zorro for saving the models neural.save = function(name) { save(Models,file=name) # save trained models } # called by Zorro for initialization neural.init = function() { set.seed(365) Models &lt;&lt;- vector("list") } # quick OOS test for experimenting with the settings Test = function() { neural.init() XY &lt;&lt;- read.csv('C:/Project/Zorro/Data/signals0.csv',header = F) splits &lt;- nrow(XY)*0.8 XY.tr &lt;&lt;- head(XY,splits) # training set XY.ts &lt;&lt;- tail(XY,-splits) # test set neural.train(1,XY.tr) X &lt;&lt;- XY.ts[,-ncol(XY.ts)] Y &lt;&lt;- XY.ts[,ncol(XY.ts)] Y.ob &lt;&lt;- ifelse(Y &gt; 0,1,0) Y &lt;&lt;- neural.predict(1,X) Y.pr &lt;&lt;- ifelse(Y &gt; 0.5,1,0) confusionMatrix(Y.pr,Y.ob) # display prediction accuracy }</span></span></span></span></code> </pre> <br><h2>  7. Vektoren unterst√ºtzen </h2><br>  Wie bei neuronalen Netzen ist die Support-Vektor-Methode eine weitere Erweiterung der linearen Regression.  Wenn Sie sich die Regressionsformel noch einmal ansehen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3d0/230/0e1/3d02300e11bdf79ba483a647d5089421.png" alt="Bild"><br><br>  Dann kann man die Funktionen xn als Koordinaten eines n-dimensionalen Raums interpretieren.  Wenn Sie die Zielvariable y auf einen festen Wert setzen, wird die Ebene in diesem Raum bestimmt. Sie wird als Hyperebene bezeichnet, da sie tats√§chlich zwei (sogar n-1) Gr√∂√üen hat.  Die Hyperebene trennt die Abtastwerte mit y&gt; 0 von denen, bei denen y &lt;0 ist. Die Koeffizienten an k√∂nnen als der Pfad berechnet werden, der die Ebene von den n√§chsten Abtastwerten trennt - ihren Unterst√ºtzungsvektoren, daher der Name des Algorithmus.  So erhalten wir einen bin√§ren Klassifikator mit der optimalen Trennung von Gewinn- und Verlustproben. <br><br>  Problem: Normalerweise k√∂nnen diese Stichproben nicht linear geteilt werden - sie werden zuf√§llig in einem Funktionsraum gruppiert.  Es ist unm√∂glich, eine glatte Ebene zwischen den Gewinn- und Verlustoptionen zu ziehen. Wenn dies m√∂glich w√§re, k√∂nnte man f√ºr die Berechnung einfachere Methoden wie die lineare Diskriminanzanalyse verwenden.  Im allgemeinen Fall k√∂nnen Sie jedoch den Trick anwenden: F√ºgen Sie dem Raum weitere Gr√∂√üen hinzu.  In diesem Fall kann der Support-Vektor-Algorithmus mehr Parameter mit einer Kernfunktion generieren, die zwei beliebige Pr√§diktoren kombiniert - √§hnlich wie beim √úbergang von der einfachen Regression zum Polynom.  Je mehr Gr√∂√üen Sie hinzuf√ºgen, desto einfacher ist es, die Samples mit einer Hyperebene zu teilen.  Dann kann es wieder in den urspr√ºnglichen n-dimensionalen Raum umgewandelt werden. <br><br>  Referenzvektoren k√∂nnen wie neuronale Netze nicht nur zur Klassifizierung, sondern auch zur Regression verwendet werden.  Sie bieten auch eine Reihe von Optionen zur Optimierung und m√∂glichen Umschulung: <br><br><ul><li>  Kernelfunktion - Der RBF-Kernel (radiale Basisfunktion, symmetrischer Kernel) wird normalerweise verwendet, es k√∂nnen jedoch auch andere Kernel ausgew√§hlt werden, z. B. Sigmoid, Polynom und Linear. </li><li>  Gamma - RBF Kernbreite. </li><li>  Kostenparameter C, ‚ÄûStrafe‚Äú f√ºr falsche Klassifizierungen von Trainingsmustern. </li></ul><br>  Die libsvm-Bibliothek wird h√§ufig verwendet, die im e1071-Paket f√ºr R verf√ºgbar ist. <br><br><h2>  8. Algorithmus der k-n√§chsten Nachbarn </h2><br>  Im Vergleich zu schwerem ANN und SVM ist dies ein einfacher und angenehmer Algorithmus mit einer einzigartigen Eigenschaft: Er muss nicht trainiert werden.  Muster werden das Modell sein.  Dieser Algorithmus kann f√ºr ein Handelssystem verwendet werden, das st√§ndig durch Hinzuf√ºgen neuer Stichproben trainiert wird.  Dieser Algorithmus berechnet die Abst√§nde im Funktionsraum vom aktuellen Wert zu den k-n√§chsten Abtastwerten.  Der Abstand im n-dimensionalen Raum zwischen den beiden Mengen (x1 ... xn) und (y1 ... yn) wird nach folgender Formel berechnet: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/66e/322/2bc/66e3222bce4b5e79d460e20b612eadcb.png" alt="Bild"><br><br>  Der Algorithmus sagt das Ziel einfach aus dem Durchschnitt von k Zielvariablen der n√§chsten Abtastwerte voraus, gewichtet mit ihren R√ºckgabeabst√§nden.  Es kann sowohl f√ºr die Klassifizierung als auch f√ºr die Regression verwendet werden.  Um die n√§chsten Nachbarn vorherzusagen, k√∂nnen Sie die Funktion knn in R aufrufen oder zu diesem Zweck selbst C-Code schreiben. <br><br><h2>  9. K-Mittel </h2><br>  Dies ist ein Approximationsalgorithmus f√ºr die unkontrollierte Klassifizierung.  Es ist dem vorherigen Algorithmus etwas √§hnlich.  Um Stichproben zu klassifizieren, platziert der Algorithmus zun√§chst k zuf√§llige Punkte im Funktionsraum.  Dann ordnet er einem dieser Punkte alle Proben mit dem geringsten Abstand zu.  Dann verschiebt sich der Punkt in die Mitte dieser n√§chsten Werte.  Dies erzeugt neue Probenbindungen, da einige von ihnen jetzt n√§her an anderen Punkten liegen.  Der Vorgang wird wiederholt, bis die erneute Referenzierung infolge der Verschiebung der Punkte aufh√∂rt, dh bis jeder Punkt f√ºr die n√§chsten Abtastwerte durchschnittlich ist.  Jetzt haben wir k Beispielklassen, die sich jeweils neben einem k-Punkt befinden. <br><br>  Dieser einfache Algorithmus kann √ºberraschend gute Ergebnisse liefern.  In R wird die kmeans-Funktion verwendet, um sie zu implementieren. Ein Beispiel f√ºr den Algorithmus finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h2>  10. Naive Bayes </h2><br>  Dieser Algorithmus verwendet den Bayes'schen Satz zum Klassifizieren von Stichproben nicht numerischer Funktionen (Ereignisse), wie beispielsweise der oben erw√§hnten Kerzenmuster.  Angenommen, Ereignis X (z. B. der Open-Parameter des vorherigen Balkens unter dem Open-Parameter des aktuellen Balkens) wird in 80% der Gewinner-Samples angezeigt.  Wie hoch ist dann die Wahrscheinlichkeit, die Stichprobe bei Vorhandensein von Ereignis X zu gewinnen?  Dies ist nicht 0,8, wie Sie vielleicht denken.  Diese Wahrscheinlichkeit wird nach folgender Formel berechnet: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/727/e4e/7ab/727e4e7abb69e9b8ef5334558a753a70.png" alt="Bild"><br><br>  P (Y | X) ist die Wahrscheinlichkeit, dass das Y-Ereignis (Gewinn) in allen Stichproben auftritt, die das X-Ereignis enthalten (in unserem Beispiel Open (1) &lt;Open (0)).  In √úbereinstimmung mit der Formel ist es gleich der Wahrscheinlichkeit des Auftretens von Ereignis X in allen Gewinnerstichproben (in unserem Fall 0,8), multipliziert mit der Wahrscheinlichkeit Y in allen Stichproben (ungef√§hr 0,5, wenn Sie die Tipps zum Ausgleichen von Stichproben befolgen) und dividiert durch die Wahrscheinlichkeit des Auftretens von X in alle Proben. <br><br>  Wenn wir naiv sind und annehmen, dass alle Ereignisse von X unabh√§ngig voneinander sind, k√∂nnen wir die Gesamtwahrscheinlichkeit berechnen, mit der die Stichprobe gewinnt, indem wir einfach die Wahrscheinlichkeiten P (X | gewinnen) f√ºr jedes Ereignis X multiplizieren. Dann kommen wir zu der folgenden Formel: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b0/c54/d51/7b0c54d515098b06b54e7446d9097954.png" alt="Bild"><br><br>  Mit Skalierungsfaktor s.  Damit eine Formel funktioniert, m√ºssen Funktionen so ausgew√§hlt werden, dass sie so unabh√§ngig wie m√∂glich sind.  Dies wird ein Hindernis f√ºr die Verwendung von naiven Bayes f√ºr den Handel sein.  Beispielsweise sind zwei Ereignisse Schlie√üen (1) &lt;Schlie√üen (0) und √ñffnen (1) &lt;√ñffnen (0) h√∂chstwahrscheinlich nicht unabh√§ngig voneinander.  Numerische Pr√§diktoren k√∂nnen in Ereignisse umgewandelt werden, indem die Anzahl in separate Bereiche unterteilt wird.  Naive Bayes ist im Paket e1071 f√ºr R erh√§ltlich. <br><br><h2>  11. Entscheidungs- und Regressionsb√§ume </h2><br>  Solche B√§ume sagen das Ergebnis numerischer Werte basierend auf einer Entscheidungskette im Ja / Nein-Format in der Struktur von √Ñsten voraus.  Jede Entscheidung repr√§sentiert das Vorhandensein oder Fehlen von Ereignissen (bei nicht numerischen Werten) oder den Vergleich von Werten mit einem festen Schwellenwert.  Eine typische Baumfunktion, die beispielsweise vom Zorro-Framework generiert wird, sieht folgenderma√üen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">* sig)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">12.938</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">0.953</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-70</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">43</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">25</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">0.962</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-67</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">0.732</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-71</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">30.61</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">27</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">46</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-62</span></span>; } } } }</code> </pre> <br>  Wie wird ein solcher Baum aus einer Reihe von Proben erhalten?  Hierf√ºr kann es verschiedene Methoden geben, einschlie√ülich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shannons Informationsentropie</a> . <br><br>  Entscheidungsb√§ume k√∂nnen weit verbreitet sein.  Sie eignen sich beispielsweise zur Erzeugung von Vorhersagen, die genauer sind, als sie mit neuronalen Netzen oder Referenzvektoren erzielt werden k√∂nnen.  Dies ist jedoch keine universelle L√∂sung.  Der bekannteste Algorithmus dieses Typs ist C5.0, der im C50-Paket f√ºr R verf√ºgbar ist. <br><br>  Um die Qualit√§t der Vorhersagen weiter zu verbessern, k√∂nnen Sie Baumgruppen verwenden, die als zuf√§llige Gesamtstruktur bezeichnet werden.  Dieser Algorithmus ist in R-Paketen mit den Namen randomForest, ranger und Rborist verf√ºgbar. <br><br><h2>  Fazit </h2><br>  Es gibt viele Methoden des Data Mining und des maschinellen Lernens.  Die entscheidende Frage lautet hier: Welche sind bessere, modellbasierte oder maschinelle Lernstrategien?  Es besteht kein Zweifel, dass maschinelles Lernen eine Reihe von Vorteilen hat.  Zum Beispiel m√ºssen Sie sich nicht um die Mikrostruktur des Marktes, die Wirtschaft, k√ºmmern, die Philosophie der Marktteilnehmer oder √§hnliche Dinge ber√ºcksichtigen.  Sie k√∂nnen sich auf reine Mathematik konzentrieren.  Maschinelles Lernen ist eine viel elegantere und attraktivere M√∂glichkeit, Handelssysteme zu erstellen.  Auf seiner Seite sind alle Vorteile bis auf einen - zus√§tzlich zu den Geschichten in den Foren der H√§ndler - der Erfolg dieser Methode im realen Handel schwer nachzuvollziehen. <br><br>  Fast jede Woche werden neue Artikel √ºber den Handel mit maschinellem Lernen ver√∂ffentlicht.  Solche Materialien sollten mit einer gewissen Skepsis aufgenommen werden.  Einige Autoren behaupten fantastische Gewinnraten von 70%, 80% oder sogar 85%.  Allerdings sagen nur wenige, dass Sie Geld verlieren k√∂nnen, selbst wenn die Vorhersagen gewinnen.  Eine Genauigkeit von 85% f√ºhrt normalerweise zu einem Rentabilit√§tsindikator √ºber 5 - wenn alles so einfach w√§re, w√ºrden die Entwickler eines solchen Systems bereits zu Milliard√§ren.  Aus irgendeinem Grund schl√§gt es jedoch fehl, dieselben Ergebnisse einfach durch Wiederholen der in den Artikeln beschriebenen Methoden zu reproduzieren. <br><br>  Im Vergleich zu modellbasierten Systemen gibt es nur sehr wenige wirklich erfolgreiche maschinelle Lernsysteme.  Beispielsweise werden sie von erfolgreichen Hedgefonds selten eingesetzt.  Vielleicht wird sich in Zukunft etwas √§ndern, wenn die Rechenleistung noch zug√§nglicher wird, aber Deep-Learning-Algorithmen bleiben f√ºr Geeks vorerst ein interessanteres Hobby als ein echtes Geldverdienungsinstrument an der B√∂rse. <br><br><h2>  Sonstige finanz- und b√∂rsenbezogene Materialien von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ITI Capital</a> : </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Analytics und Markt√ºberpr√ºfungen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zur√ºck in die Zukunft: √úberpr√ºfung der Leistung eines Handelsroboters anhand historischer Daten</a> </li><li>  Ereignisgesteuertes Python-Backtesting Schritt f√ºr Schritt ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 4</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 5</a> ) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de412639/">https://habr.com/ru/post/de412639/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de412625/index.html">So finden Sie schnell KI- und Data Science-Spezialisten und verlieren sie nicht</a></li>
<li><a href="../de412627/index.html">Internationale Ausstellung CMEF & ICMD 2018 Fr√ºhling in Shanghai (Teil 2)</a></li>
<li><a href="../de412629/index.html">Adaptive Wellenform f√ºr Ihren Audiodienst</a></li>
<li><a href="../de412633/index.html">Erfahrung in der Konfiguration und Verwendung von WSL (Linux-Subsystem in Windows 10)</a></li>
<li><a href="../de412637/index.html">Logos neu gestalten oder nicht? Das ist die Frage</a></li>
<li><a href="../de412641/index.html">Was haben Bergbau, Georgien und Irkutsk gemeinsam?</a></li>
<li><a href="../de412643/index.html">Wie wir das Zahlungssystem in das russische Projekt integriert haben</a></li>
<li><a href="../de412645/index.html">Objekt, Eigentum, Aktivit√§t: Modelle und Methoden ihrer Konstruktion</a></li>
<li><a href="../de412647/index.html">Neue Beweise f√ºr die Existenz des neunten Planeten</a></li>
<li><a href="../de412649/index.html">Aufbau eines Teams und Prozesse, die auf schnelles Wachstum ausgerichtet sind</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>