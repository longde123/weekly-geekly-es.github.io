<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛰️ 😮 🕥 Utilisation des comptes intelligents Waves: des enchères aux programmes de bonus 😆 📜 👩🏽‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La blockchain est souvent associée uniquement aux crypto-monnaies, mais le champ d'application de la technologie DLT est beaucoup plus large. L'un des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Utilisation des comptes intelligents Waves: des enchères aux programmes de bonus</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/waves/blog/442238/"><img src="https://habrastorage.org/webt/pi/sa/8g/pisa8gy_wbapc-kdf-n026wjuko.png" alt="image"><br><br>  <i>La blockchain est souvent associée uniquement aux crypto-monnaies, mais le champ d'application de la technologie DLT est beaucoup plus large.</i>  <i>L'un des domaines les plus prometteurs pour l'utilisation de la blockchain est un contrat intelligent qui s'exécute automatiquement et ne nécessite pas de confiance entre les parties qui l'ont conclue.</i> <i><br></i> <br>  <b>RIDE - langage pour les contrats intelligents</b> <br><br>  Waves a développé un langage spécial pour les contrats intelligents - RIDE.  Sa documentation complète est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Et ici - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article sur ce sujet</a> sur Habré. <br><br>  Le contrat sur RIDE est un prédicat et renvoie «vrai» ou «faux» sur la sortie.  En conséquence, une transaction est soit écrite dans la blockchain, soit rejetée.  Un contrat intelligent garantit pleinement le respect des conditions spécifiées.  La génération de transactions à partir d'un contrat dans RIDE n'est actuellement pas possible. <br><a name="habracut"></a><br>  Aujourd'hui, il existe deux types de contrats intelligents Waves: les comptes intelligents et les actifs intelligents.  Un compte intelligent est un compte d'utilisateur normal, mais un script est défini pour celui-ci qui contrôle toutes les transactions.  Un script de compte intelligent pourrait ressembler à ceci: <br><br><pre><code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> | <span class="hljs-type"><span class="hljs-type">MassTransferTransaction</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br>  tx est une transaction traitée que nous autorisons à utiliser le mécanisme de correspondance de modèle uniquement s'il ne s'agit pas d'une transaction de transfert.  La correspondance de motifs RIDE est utilisée pour vérifier le type de transaction.  Dans le script de compte intelligent, tous les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">types de transactions</a> existants peuvent être traités. <br><br>  De plus, des variables peuvent être déclarées dans le script, des constructions «if-then-else» et d'autres méthodes pour la vérification complète des conditions peuvent être utilisées.  Pour que les contrats aient une fin et une complexité (coût) prouvables, ce qui est facile à prévoir avant le début du contrat, RIDE ne contient pas de boucles et d'opérateurs comme jump. <br><br>  Parmi les autres caractéristiques des comptes Waves, il y a la présence d'un «état», c'est-à-dire l'état du compte.  Un nombre infini de paires (clé, valeur) peut être écrit dans l'état du compte à l'aide de transactions de données (DataTransaction).  De plus, ces informations peuvent être traitées à la fois via l'API REST et directement dans le contrat intelligent. <br><br>  Chaque transaction peut contenir un tableau d’épreuves, dans lequel vous pouvez saisir la signature du participant, l’identifiant de la transaction nécessaire, etc. <br><br>  Travailler avec RIDE via l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IDE</a> vous permet de voir la forme compilée du contrat (s'il est compilé), de créer de nouveaux comptes et de définir des scripts pour celui-ci, ainsi que d'envoyer des transactions via la ligne de commande. <br><br>  Pour un cycle complet, y compris la création d'un compte, l'installation d'un contrat intelligent et l'envoi de transactions, vous pouvez également utiliser la bibliothèque pour interagir avec l'API REST (par exemple, C #, C, Java, JavaScript, Python, Rust, Elixir).  Pour commencer à travailler avec l'IDE, cliquez simplement sur le bouton NOUVEAU. <br><br>  Les possibilités d'utilisation des contrats intelligents sont larges: de l'interdiction des transactions à certaines adresses (la "liste noire") aux dApps complexes. <br><br>  <i>Examinons maintenant des exemples spécifiques de l'utilisation de contrats intelligents dans les entreprises: lors des enchères, de l'assurance et de la création de programmes de fidélité.</i> <i><br></i> <br>  <b>Enchères</b> <br><br>  Une des conditions de réussite des enchères est la transparence: les soumissionnaires doivent être sûrs qu'il est impossible de manipuler les enchères.  Cela peut être réalisé grâce à la blockchain, où des données inchangées sur tous les paris et l'heure à laquelle ils ont été effectués seront disponibles pour tous les participants. <br><br>  Sur la blockchain Waves, les offres peuvent être enregistrées dans l'état du compte d'enchères via DataTransaction. <br><br>  Vous pouvez également définir l'heure de début et de fin de l'enchère à l'aide de numéros de bloc: la fréquence de génération de bloc dans la chaîne de blocs Waves est d'environ <b>60</b> secondes. <br><br>  <i><b>1. Vente aux enchères en hausse en anglais</b></i> <br><br>  Les participants à l'enchère anglaise, en concurrence les uns avec les autres.  Chaque nouveau pari doit dépasser le précédent.  L'enchère se termine lorsqu'il n'y a plus de volonté de dépasser la dernière enchère.  Dans ce cas, le plus offrant doit fournir le montant déclaré. <br><br>  Il existe également une option d'enchère dans laquelle le vendeur fixe le prix minimum du lot et le prix final doit le dépasser.  Sinon, le lot reste invendu. <br><br>  Dans cet exemple, nous travaillons avec un compte spécialement créé pour l'enchère.  La durée de l'enchère est de 3000 blocs et le prix initial du lot est de 0,001 ONDES.  Un participant peut faire un pari en envoyant une DataTransaction avec la clé «prix» et la valeur de son offre, dans les preuves de transaction, vous devez ajouter la clé publique et la signature de l'expéditeur. <br><br>  Le prix du nouveau pari doit être supérieur au prix actuel de cette clé, et le participant doit avoir au moins [new_state + commission] jetons sur le compte.  L'adresse du soumissionnaire doit être entrée dans le champ "expéditeur" dans DataTransaction, et la hauteur actuelle du bloc d'enchères doit être comprise dans la période de l'enchère. <br><br>  Si à la fin de l'enchère, l'enchérisseur a fixé le prix le plus élevé, il peut envoyer ExchangeTransaction pour payer le lot correspondant au prix et à la paire de devises indiqués. <br><br><pre> <code class="scala hljs">let startHeight = <span class="hljs-number"><span class="hljs-number">384120</span></span> let finishHeight = startHeight + <span class="hljs-number"><span class="hljs-number">3000</span></span> let startPrice = <span class="hljs-number"><span class="hljs-number">100000</span></span> #     let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) let token = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d : <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; #,      let currentPrice = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isDefined(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) #    then extract(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> startPrice #    let newPrice = extract(getInteger(d.data, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) #       let pk = d.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>] let address = addressFromPublicKey(pk) let priceIsBigger = newPrice &gt; currentPrice let fee = <span class="hljs-number"><span class="hljs-number">700000</span></span> let hasMoney = wavesBalance(address) + fee &gt;= newPrice let correctFields = size(d.data) == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; extract(getString(d.data, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>)) == toBase58String(address.bytes) startHeight &lt;= height &amp;&amp; height &lt;= finishHeight &amp;&amp; priceIsBigger &amp;&amp; hasMoney &amp;&amp; correctFields &amp;&amp; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> o : <span class="hljs-type"><span class="hljs-type">Order</span></span> =&gt; #       let pk = o.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>] let address = addressFromPublicKey(pk) let senderIsWinner = address == addressFromString(extract(getString(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>))) #,    ,    let correctAssetPair = o.assetPair.amountAsset == token &amp;&amp; ! isDefined(o.assetPair.priceAsset) let correctAmount = o.amount == <span class="hljs-number"><span class="hljs-number">1</span></span> let correctPrice = o.price == extract(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) height &gt; finishHeight &amp;&amp; senderIsWinner &amp;&amp; correctAssetPair &amp;&amp; correctAmount &amp;&amp; correctPrice &amp;&amp; sigVerify(o.bodyBytes, o.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], o.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  <i><b>2. Vente aux enchères néerlandaise de prix en baisse</b></i> <br><br>  Lors d'une vente aux enchères néerlandaise, un lot est initialement proposé à un prix supérieur à ce que l'acheteur est prêt à payer.  Le prix est réduit progressivement jusqu'à ce que l'un des participants accepte d'acheter le lot au prix actuel. <br><br>  Dans cet exemple, nous utilisons les mêmes constantes que dans la précédente, ainsi que le pas de prix lors de l'abaissement du delta.  Le script de compte vérifie si le participant est vraiment le premier à parier.  Dans les preuves de transaction, vous devez ajouter la clé publique et la signature de l'expéditeur, sinon DataTransaction n'est pas accepté par la blockchain. <br><br><pre> <code class="scala hljs">let startHeight = <span class="hljs-number"><span class="hljs-number">384120</span></span> let finishHeight = startHeight + <span class="hljs-number"><span class="hljs-number">3000</span></span> let startPrice = <span class="hljs-number"><span class="hljs-number">100000000</span></span> let delta = <span class="hljs-number"><span class="hljs-number">100</span></span> #     let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) let token = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d : <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; let currentPrice = startPrice - delta * (height - startHeight) #   -  <span class="hljs-string"><span class="hljs-string">"price"</span></span> let newPrice = extract(getInteger(d.data, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) #       let pk = d.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>] let address = addressFromPublicKey(pk) let correctFields = extract(getString(d.data, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>)) == toBase58String(address.bytes) &amp;&amp; size(d.data) == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; newPrice == currentPrice #,         <span class="hljs-string"><span class="hljs-string">"sender"</span></span> let noBetsBefore = !isDefined(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>)) let fee = <span class="hljs-number"><span class="hljs-number">700000</span></span> let hasMoney = wavesBalance(address) - fee &gt;= newPrice startHeight &lt;= height &amp;&amp; height &lt;= finishHeight &amp;&amp; noBetsBefore &amp;&amp; hasMoney &amp;&amp; correctFields &amp;&amp; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> o : <span class="hljs-type"><span class="hljs-type">Order</span></span> =&gt; #       let pk = o.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>] let address = addressFromPublicKey(pk) #,           sender let senderIsWinner = address == addressFromString(extract(getString(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>))) #,  mount   ,   - - waves let correctAssetPair = o.assetPair.amountAsset == token &amp;&amp; ! isDefined(o.assetPair.priceAsset) let correctAmount = o.amount == <span class="hljs-number"><span class="hljs-number">1</span></span> let correctPrice = o.price == extract(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) height &gt; finishHeight &amp;&amp; senderIsWinner &amp;&amp; correctAssetPair &amp;&amp; correctAmount &amp;&amp; correctPrice &amp;&amp; sigVerify(o.bodyBytes, o.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], o.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br>  <i><b>3. Enchères entièrement payantes</b></i> <br><br>  «Tout payer» - une enchère, dont tous les participants paient l'enchère, quelle que soit la personne qui remporte le lot.  Chaque nouveau participant paie la mise, et le participant qui a fait la mise maximale remporte le lot. <br><br>  Dans notre exemple, chaque participant à une enchère fait une offre via une DataTransaction avec (clé, valeur) * = ("gagnant", adresse), ("prix", prix).  Une telle DataTransaction n'est approuvée que si pour ce participant il existe déjà une TransferTransaction avec sa signature et son tarif est supérieur à tous les précédents.  L'enchère se poursuit jusqu'à la fin de la hauteur. <br><br><pre> <code class="scala hljs">let startHeight = <span class="hljs-number"><span class="hljs-number">1000</span></span> let endHeight = <span class="hljs-number"><span class="hljs-number">2000</span></span> let token = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d: <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; #   -  <span class="hljs-string"><span class="hljs-string">"price"</span></span> let newPrice = extract(getInteger(d.data, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) #       let pk = d.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>] let address = addressFromPublicKey(pk) #        let proofTx = extract(transactionById(d.proofs[<span class="hljs-number"><span class="hljs-number">2</span></span>])) height &gt; startHeight &amp;&amp; height &lt; endHeight &amp;&amp; size(d.data) == <span class="hljs-number"><span class="hljs-number">2</span></span> #,   ,    ,   ,    &amp;&amp; extract(getString(d.data, <span class="hljs-string"><span class="hljs-string">"winner"</span></span>)) == toBase58String(address.bytes) &amp;&amp; newPrice &gt; extract(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) #,    &amp;&amp; sigVerify(d.bodyBytes, d.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], d.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) #  ,    &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> proofTx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> tr : <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; tr.sender == address &amp;&amp; tr.amount == newPrice <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.senderPublicKey) || ( height &gt; endHeight &amp;&amp; extract(getString(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"winner"</span></span>)) == toBase58String((addressFromRecipient(t.recipient)).bytes) &amp;&amp; t.assetId == token &amp;&amp; t.amount == <span class="hljs-number"><span class="hljs-number">1</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.senderPublicKey) }</code> </pre> <br>  <b>Assurance / Crowdfunding</b> <br><br>  Considérez une situation où vous devez assurer les actifs des utilisateurs contre les pertes financières.  Par exemple, l'utilisateur souhaite obtenir la garantie que si le jeton se déprécie, il sera en mesure de rembourser le montant total payé pour ces jetons et est prêt à payer un montant d'assurance raisonnable. <br><br>  Pour mettre en œuvre cela, vous devez émettre des "jetons d'assurance".  Ensuite, un script est installé sur le compte du titulaire de police qui vous permet d'exécuter uniquement les ExchangeTransactions qui remplissent certaines conditions. <br><br>  Pour éviter les doubles dépenses, vous devez demander à l'utilisateur d'envoyer DataTransaction à l'avance au compte de l'assuré avec (clé, valeur) = (PurchaseTransactionId, sellOrderId) et interdire l'envoi de DataTransactions avec la clé déjà utilisée. <br><br>  Par conséquent, les preuves utilisateur doivent contenir l'ID de transaction de l'achat du jeton d'assurance.  La paire de devises doit être la même que lors de la transaction d'achat.  Le coût doit également être égal à celui enregistré au moment de l'achat, moins le prix de l'assurance. <br><br>  Il est entendu que par la suite le compte d'assurance rachète les jetons d'assurance à l'utilisateur à un prix non inférieur au prix auquel il les a achetés: le compte d'assurance crée ExchangeTransaction, l'utilisateur signe la commande (si la transaction est correctement effectuée), le compte d'assurance signe la deuxième commande et la transaction entière et l'envoie à la blockchain . <br><br>  Si l'achat ne se produit pas, l'utilisateur peut créer une commande conformément aux règles décrites dans le script et envoyer la transaction à la blockchain.  Ainsi, l'utilisateur peut restituer l'argent dépensé pour l'achat de jetons assurés. <br><br><pre> <code class="scala hljs">let insuranceToken = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' #     let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) let freezePeriod = <span class="hljs-number"><span class="hljs-number">150000</span></span> let insurancePrice = <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { #, ,   -,              <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d : <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; size(d.data) == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; !isDefined(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, d.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key)) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> o : <span class="hljs-type"><span class="hljs-type">Order</span></span> =&gt; #     ,    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !isDefined(o.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>]) then sigVerify(o.bodyBytes, o.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], o.senderPublicKey) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> #     ,         let purchaseTx = transactionById(o.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>]) let purchaseTxHeight = extract(transactionHeightById(o.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>])) #    <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> purchaseTx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> purchase : <span class="hljs-type"><span class="hljs-type">ExchangeTransaction</span></span> =&gt; let correctSender = purchase.sender == o.sender let correctAssetPair = o.assetPair.amountAsset == insuranceToken &amp;&amp; purchase.sellOrder.assetPair.amountAsset == insuranceToken &amp;&amp; o.assetPair.priceAsset == purchase.sellOrder.assetPair.priceAsset let correctPrice = o.price == purchase.price - insurancePrice &amp;&amp; o.amount == purchase.amount let correctHeight = height &gt; purchaseTxHeight + freezePeriod #,   -   <span class="hljs-type"><span class="hljs-type">ID</span></span>   let correctProof = extract(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, toBase58String(purchase.id))) == o.id correctSender &amp;&amp; correctAssetPair &amp;&amp; correctPrice &amp;&amp; correctHeight &amp;&amp; correctProof <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.senderPublicKey) }</code> </pre><br>  Un jeton d'assurance peut devenir un actif intelligent, par exemple, pour interdire son transfert à des tiers. <br><br>  Ce système peut également être mis en œuvre pour les jetons de financement participatif, qui sont retournés aux propriétaires si le montant nécessaire n'a pas été collecté. <br><br>  <b>Taxes sur les transactions</b> <br><br>  Les contrats intelligents sont également applicables dans les cas où il est nécessaire de collecter la taxe sur chaque transaction avec plusieurs types d'actifs.  Cela peut être fait via un nouvel actif <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sponsorisé</a> pour les transactions avec des actifs intelligents: <br><br>  1. Nous publions FeeCoin, qui sera envoyé aux utilisateurs à un prix fixe: 0,01 WAVES = 0,001 FeeCoin. <br><br>  2. Nous avons mis en place un parrainage pour FeeCoin et un taux de change: 0,001 WAVES = 0,001 FeeCoin. <br><br>  3. Nous définissons le script suivant pour l'actif intelligent: <br><br><pre> <code class="scala hljs">let feeAssetId = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' let taxDivisor = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; t.feeAssetId == feeAssetId &amp;&amp; t.fee == t.amount / taxDivisor <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> e: <span class="hljs-type"><span class="hljs-type">ExchangeTransaction</span></span>| <span class="hljs-type"><span class="hljs-type">MassTransferTransaction</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br>  Maintenant, chaque fois que quelqu'un transfère N actifs intelligents, il vous donnera des FeeCoins d'un montant de N / taxDivisor (qui peut être acheté auprès de vous pour 10 * N / taxDivisor WAVES), et vous donnerez au mineur N / taxDivisor WAVES.  En conséquence, votre bénéfice (impôt) sera de 9 * N / impôt du diviseur d'ondes. <br><br>  Vous pouvez également taxer à l'aide d'un script d'actif intelligent et de MassTransferTransaction: <br><br><pre> <code class="scala hljs">let taxDivisor = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t : <span class="hljs-type"><span class="hljs-type">MassTransferTransaction</span></span> =&gt; let twoTransfers = size(t.transfers) == <span class="hljs-number"><span class="hljs-number">2</span></span> let issuerIsRecipient = t.transfers[<span class="hljs-number"><span class="hljs-number">0</span></span>].recipient == addressFromString(<span class="hljs-string"><span class="hljs-string">"3MgkTXzD72BTfYpd9UW42wdqTVg8HqnXEfc"</span></span>) let taxesPaid = t.transfers[<span class="hljs-number"><span class="hljs-number">0</span></span>].amount &gt;= t.transfers[<span class="hljs-number"><span class="hljs-number">1</span></span>].amount / taxDivisor twoTransfers &amp;&amp; issuerIsRecipient &amp;&amp; taxesPaid <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br>  <b>Programmes de cashback et de fidélité</b> <br><br>  La remise en argent est un type de programme de fidélisation dans lequel une partie du montant dépensé pour un produit ou un service est retournée à l'acheteur. <br><br>  Lors de la mise en œuvre de ce cas à l'aide d'un compte intelligent, nous devons vérifier les preuves de la même manière que nous l'avons fait dans le cas de l'assurance.  Pour éviter de doubler les dépenses, avant de recevoir un cashback, l'utilisateur doit envoyer un DataTransaction avec (clé, valeur) = (PurchaseTransactionId, cashbackTransactionId). <br><br>  Nous devons également interdire les clés existantes à l'aide d'une DataTransaction.  cashbackDivisor - une unité divisée par la part de cashback.  C'est-à-dire  si la part de cashback est de 0,1, alors cashbackDivisor 1 / 0,1 = 10. <br><br><pre> <code class="scala hljs">let cashbackToken = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' #     let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) let cashbackDivisor = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { #, ,   -,              <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d : <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; size(d.data) == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; !isDefined(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, d.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key)) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> e : <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; #     ,    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !isDefined(e.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>]) then sigVerify(e.bodyBytes, e.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], e.senderPublicKey) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> #     ,         let purchaseTx = transactionById(e.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>]) let purchaseTxHeight = extract(transactionHeightById(e.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>])) #    <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> purchaseTx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> purchase : <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; let correctSender = purchase.sender == e.sender let correctAsset = e.assetId == cashbackToken let correctPrice = e.amount == purchase.amount / cashbackDivisor #,   -   <span class="hljs-type"><span class="hljs-type">ID</span></span>   let correctProof = extract(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, toBase58String(purchase.id))) == e.id correctSender &amp;&amp; correctAsset &amp;&amp; correctPrice &amp;&amp; correctProof <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.senderPublicKey) }</code> </pre> <br>  <b>Échange atomique</b> <br><br>  Le swap atomique permet aux utilisateurs d'échanger des actifs sans l'aide d'un échange.  Dans un échange atomique, les deux participants à la transaction doivent la confirmer dans un certain délai. <br><br>  Si au moins l'un des participants ne fournit pas la confirmation correcte de la transaction dans le délai imparti pour la transaction, la transaction est annulée et aucun échange n'a lieu. <br><br>  Dans notre exemple, nous utiliserons le script de compte intelligent suivant: <br><br><pre> <code class="scala hljs">let <span class="hljs-type"><span class="hljs-type">Bob</span></span> = <span class="hljs-type"><span class="hljs-type">Address</span></span>(base58<span class="hljs-symbol"><span class="hljs-symbol">'3NBVqYXrapgJP9atQccdBPAgJPwHDKkh6A</span></span>8') let <span class="hljs-type"><span class="hljs-type">Alice</span></span> = <span class="hljs-type"><span class="hljs-type">Address</span></span>(base58<span class="hljs-symbol"><span class="hljs-symbol">'3PNX6XwMeEXaaP1rf5MCk8weYeF7z2vJZB</span></span>g') let beforeHeight = <span class="hljs-number"><span class="hljs-number">100000</span></span> let secret = base58<span class="hljs-symbol"><span class="hljs-symbol">'BN6RTYGWcwektQfSFzH8raYo9awaLgQ7pLyWLQY4S4F</span></span>5' <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; let txToBob = t.recipient == <span class="hljs-type"><span class="hljs-type">Bob</span></span> &amp;&amp; sha256(t.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>]) == secret &amp;&amp; <span class="hljs-number"><span class="hljs-number">20</span></span> + beforeHeight &gt;= height let backToAliceAfterHeight = height &gt;= <span class="hljs-number"><span class="hljs-number">21</span></span> + beforeHeight &amp;&amp; t.recipient == <span class="hljs-type"><span class="hljs-type">Alice</span></span> txToBob || backToAliceAfterHeight <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  <i>Dans le prochain article, nous considérerons l'utilisation de comptes intelligents dans les instruments financiers - tels que les options, les futures et les factures.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr442238/">https://habr.com/ru/post/fr442238/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr442226/index.html">Ce contenu n'est pas disponible dans votre pays: des nouvelles que vous ne pouvez pas apprendre de la Russie</a></li>
<li><a href="../fr442230/index.html">Lequel des développeurs vivant dans la même ville gagne le plus: travailler à distance ou au bureau?</a></li>
<li><a href="../fr442232/index.html">Enregistreur de bobines Slf4j alternatif</a></li>
<li><a href="../fr442234/index.html">Colonie. Épilogue</a></li>
<li><a href="../fr442236/index.html">Pourquoi Dodo Pizza a besoin de 250 développeurs?</a></li>
<li><a href="../fr442242/index.html">Dernières nouvelles: Inauguration de la plus grande usine de cellules solaires de l'hémisphère occidental</a></li>
<li><a href="../fr442244/index.html">Rust 1.33 Release</a></li>
<li><a href="../fr442248/index.html">La NASA a approuvé le lancement du test sans pilote de Dragon-2</a></li>
<li><a href="../fr442250/index.html">React and Vue: Forces</a></li>
<li><a href="../fr442252/index.html">Cycle de vie du code Python - Modèle d'exécution CPython</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>