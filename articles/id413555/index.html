<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ”˜ ğŸš´ ğŸ–ğŸ¾ Interoperabilitas yang Aman dalam Sistem Terdistribusi ğŸ‘¨ğŸ¾â€ğŸ¤â€ğŸ‘¨ğŸ» ğŸ““ ğŸ™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai Habr! 

 Nama saya Alexey Solodky, saya adalah pengembang PHP di Badoo. Dan hari ini saya akan membagikan versi teks dari ceramah saya untuk Perte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interoperabilitas yang Aman dalam Sistem Terdistribusi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/413555/"><img src="https://habrastorage.org/webt/ag/m-/8r/agm-8r1daffwnqqhzqagmayd4uc.png" width="800"><br><br>  Hai Habr! <br><br>  Nama saya Alexey Solodky, saya adalah pengembang PHP di Badoo.  Dan hari ini saya akan membagikan versi teks dari ceramah saya untuk Pertemuan PHP Badoo pertama.  Video tentang ini dan laporan lain dari mitap dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Sistem apa pun yang terdiri dari setidaknya dua komponen (dan jika Anda memiliki PHP dan database, maka ini adalah dua komponen), menghadapi seluruh kelas risiko dalam interaksi antara komponen-komponen ini. <br><br>  Departemen platform tempat saya bekerja mengintegrasikan layanan internal baru dengan aplikasi kami.  Dan menyelesaikan masalah ini, kami telah mengumpulkan pengalaman, yang ingin saya bagikan. <br><br>  Backend kami adalah monolit PHP yang berinteraksi dengan banyak layanan (saat ini ada sekitar 50 di antaranya).  Layanan jarang berinteraksi satu sama lain.  Tetapi masalah yang saya bicarakan dalam artikel ini juga relevan untuk arsitektur layanan mikro.  Memang, dalam hal ini, layanan berinteraksi sangat aktif satu sama lain, dan semakin banyak interaksi yang Anda miliki, semakin banyak masalah yang Anda miliki. <br><br>  Pertimbangkan apa yang harus dilakukan ketika layanan macet atau kusam, bagaimana mengatur kumpulan metrik dan apa yang harus dilakukan ketika semua hal di atas tidak menyelamatkan Anda. <br><a name="habracut"></a><br><h2>  Layanan macet </h2><br>  Cepat atau lambat, server tempat layanan Anda diinstal akan jatuh.  Itu pasti akan terjadi, dan Anda tidak dapat bertahan melawannya - hanya kurangi kemungkinannya.  Anda dapat dikecewakan oleh perangkat keras, jaringan, kode, penerapan yang tidak berhasil - apa pun.  Dan semakin banyak server yang Anda miliki, semakin sering ini akan terjadi. <br><br>  Bagaimana membuat layanan Anda bertahan di dunia di mana server terus-menerus mogok?  Pendekatan umum untuk memecahkan kelas masalah ini adalah redundansi. <br><br>  Redundansi digunakan di mana-mana pada tingkat yang berbeda: dari besi ke seluruh pusat data.  Misalnya, RAID1 untuk melindungi dari kegagalan hard drive atau catu daya cadangan untuk server Anda jika terjadi kegagalan yang pertama.  Juga, skema ini diterapkan secara luas ke database.  Misalnya, Anda dapat menggunakan master-slave untuk ini. <br><br>  Mari kita pertimbangkan masalah khas dengan redundansi menggunakan skema paling sederhana sebagai contoh: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/9b/rb/lo9brbsy29ca8b0i-1ygtyckncq.png" width="300"></div><br>  Aplikasi berkomunikasi secara eksklusif dengan master, sementara di latar belakang, secara tidak sinkron, data ditransfer ke slave.  Ketika master crash, kita akan beralih ke slave dan terus bekerja. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ga/lt/o5/galto5cgws3ed44dfwhnqq9zvd4.png" width="300"></div><br><br>  Setelah memulihkan master, kita hanya membuat budak baru darinya, dan yang lama berubah menjadi master. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6h/c8/gc/6hc8gc6qzhzso3xscnjblfn1frm.png" width="300"></div><br>  Skema ini sederhana, tetapi bahkan memiliki banyak nuansa karakteristik dari skema yang berlebihan. <br><br><h3>  Muat </h3><br>  Katakanlah satu server dari contoh di atas dapat menahan sekitar 100k RPS.  Sekarang bebannya adalah 60k RPS, dan semuanya bekerja seperti jam. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/99/gw/j1/99gwj19rezs-ywa-hdopmqcudk8.png" width="300"></div><br>  Namun seiring waktu, beban pada aplikasi, dan karenanya beban pada master, meningkat.  Anda mungkin ingin menyeimbangkannya dengan memindahkan sebagian bacaan ke seorang budak. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sv/r4/si/svr4sicizgym8gqndznsygpi0-o.png" width="300"></div><br>  Terlihat bagus.  Menahan beban, server tidak lagi menganggur.  Tapi ini ide yang buruk.  Penting untuk mengingat mengapa Anda awalnya mengangkat budak - untuk beralih jika terjadi masalah dengan yang utama.  Jika Anda mulai memuat kedua server, maka ketika master Anda crash - dan cepat atau lambat crash - Anda harus mengalihkan lalu lintas utama dari master ke server cadangan, dan itu sudah dimuat.  Kelebihan seperti itu akan membuat sistem Anda sangat lambat, atau sepenuhnya menonaktifkannya. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9t/py/la/9tpylanqp3whk7tcr4csdln6yo0.png" width="300"></div><br><h3>  Data </h3><br>  Masalah utama saat menambahkan toleransi kesalahan ke layanan adalah keadaan setempat.  Jika layanan Anda tidak memiliki kewarganegaraan, mis. Tidak menyimpan data yang dapat berubah, maka mengubah skala itu tidak menimbulkan masalah.  Kami hanya meningkatkan sebanyak contoh yang kami butuhkan dan menyeimbangkan permintaan di antara mereka. <br><br>  Jika layanan ini stateful, kami tidak dapat melakukan ini lagi.  Anda perlu memikirkan cara menyimpan data yang sama di semua mesin virtual layanan kami sehingga tetap konsisten. <br><br>  Untuk mengatasi masalah ini, salah satu dari dua pendekatan digunakan: replikasi sinkron atau asinkron.  Dalam kasus umum, saya menyarankan Anda untuk menggunakan opsi asinkron, karena umumnya lebih mudah dan lebih cepat untuk menulis, dan, sesuai dengan keadaan, lihat apakah Anda perlu beralih ke sinkron. <br><br>  Nuansa penting untuk dipertimbangkan ketika bekerja dengan replikasi asinkron adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konsistensi akhirnya</a> .  Ini berarti bahwa pada titik waktu tertentu pada budak yang berbeda, data dapat tertinggal di belakang master dengan interval waktu yang tidak terduga dan berbeda. <br>  Oleh karena itu, Anda tidak dapat membaca data setiap kali dari server acak, karena jawaban yang berbeda dapat datang ke permintaan pengguna yang sama.  Untuk mengatasi masalah ini, mekanisme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sesi lengket digunakan</a> , yang memastikan bahwa semua permintaan dari satu pengguna masuk ke satu instance. <br><br>  Keuntungan dari pendekatan sinkron adalah bahwa data selalu dalam keadaan konsisten, dan risiko kehilangan data lebih rendah (karena dianggap dicatat hanya setelah semua server melakukannya).  Namun, Anda harus membayar untuk ini dengan kecepatan tulis dan kompleksitas sistem itu sendiri (misalnya, berbagai algoritma kuorum untuk perlindungan terhadap <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">split-brain</a> ). <br><br><h3>  Kesimpulan </h3><br><ul><li>  <b>Cadangan.</b>  Jika data itu sendiri dan ketersediaan layanan tertentu penting, maka pastikan bahwa layanan Anda akan selamat dari kejatuhan mesin tertentu. <br></li><li>  <b>Saat menghitung beban, pertimbangkan jatuhnya beberapa server.</b>  Jika cluster Anda memiliki empat server, pastikan bahwa ketika satu jatuh, tiga yang tersisa akan menarik beban. <br></li><li>  <b>Pilih jenis replikasi tergantung pada tugas.</b> <br></li><li>  <b>Jangan menaruh semua telur Anda dalam satu keranjang.</b>  Pastikan server Anda terpisah cukup jauh.  Tergantung pada kekritisan ketersediaan layanan, server Anda dapat berada di rak yang berbeda di satu pusat data, atau di pusat data yang berbeda di berbagai negara.  Itu semua tergantung pada seberapa besar bencana global yang Anda inginkan dan siap untuk bertahan hidup. <br></li></ul><br><h2>  Layanan Diam </h2><br>  Pada titik tertentu, layanan Anda mungkin mulai bekerja sangat lambat.  Masalah ini dapat terjadi karena berbagai alasan: beban berlebihan, keterlambatan jaringan, masalah perangkat keras, atau kesalahan kode.  Sepertinya masalah yang tidak terlalu mengerikan, tetapi sebenarnya itu lebih berbahaya dari yang terlihat. <br><br>  Bayangkan: pengguna meminta halaman.  Kami secara simultan dan berurutan mengakses keempat setan untuk menggambarnya.  Mereka merespons dengan cepat, semuanya bekerja dengan baik. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vo/u9/q5/vou9q5svtrqqptnxti-vkeuhmbm.png" width="400"></div><br>  Misalkan kasus ini ditangani menggunakan nginx dengan jumlah tetap pekerja PHP FPM (dengan sepuluh, misalnya).  Jika setiap permintaan diproses kurang lebih 20 ms, maka dengan bantuan perhitungan sederhana dapat dipahami bahwa sistem kami mampu memproses sekitar lima ratus permintaan per detik. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tq/h2/o2/tqh2o239lvw7qiobm8scwzrjma4.png" width="450"></div><br>  Apa yang terjadi ketika salah satu dari empat layanan ini mulai tumpul, dan pemrosesan permintaan untuk itu meningkat dari 20 ms menjadi habisnya 1000 ms?  Penting untuk diingat bahwa ketika kita bekerja dengan jaringan, penundaannya bisa sangat besar.  Oleh karena itu, Anda harus selalu menetapkan batas waktu (dalam hal ini, sama dengan satu detik). <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rn/uq/ae/rnuqaevpyknuwpgd9a94oygknia.png" width="400"></div><br>  Ternyata backend dipaksa untuk menunggu batas waktu berakhir dan menerima dan memproses kesalahan dari daemon.  Ini berarti bahwa pengguna menerima halaman dalam satu detik, bukan sepuluh milidetik.  Lambat, tapi tidak fatal. <br><br>  Tapi apa masalah sebenarnya di sini?  Faktanya adalah ketika kita meminta setiap permintaan diproses per detik, throughputnya secara tragis turun menjadi sepuluh permintaan per detik.  Dan pengguna kesebelas tidak akan lagi bisa mendapatkan respons, bahkan jika ia meminta halaman yang sama sekali tidak terkait dengan layanan yang membosankan.  Hanya karena kesepuluh pekerja sedang menunggu batas waktu, dan tidak dapat memproses permintaan baru. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sk/tn/dz/sktndzfsfdbjsgobqxmm5sy_xkw.png" width="450"></div><br>  Penting untuk dipahami bahwa masalah ini tidak dapat diselesaikan dengan menambah jumlah pekerja.  Bagaimanapun, setiap pekerja memerlukan sejumlah RAM untuk pekerjaannya, bahkan jika dia tidak melakukan pekerjaan nyata, tetapi hanya menunggu untuk waktu tunggu.  Karena itu, jika Anda tidak membatasi jumlah pekerja sesuai dengan kemampuan server Anda, maka meningkatkan lebih banyak pekerja baru akan menempatkan seluruh server.  Kasus ini adalah contoh kegagalan cascading, ketika jatuhnya salah satu layanan, bahkan jika tidak kritis untuk pengguna, menyebabkan kegagalan seluruh sistem. <br><br><h3>  Solusi </h3><br>  Ada pola yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">circuit breaker</a> .  Tugasnya cukup sederhana: suatu saat ia harus mengurangi layanan yang membosankan.  Untuk ini, proxy ditempatkan antara layanan dan pekerja.  Ini bisa berupa kode PHP dengan penyimpanan atau daemon di host lokal.  Penting untuk dicatat bahwa jika Anda memiliki beberapa instance (layanan Anda direplikasi), maka proxy ini harus secara terpisah melacak masing-masing. <br><br>  Kami telah menulis implementasi pola ini.  Tetapi bukan karena kami suka menulis kode, tetapi karena ketika kami memecahkan masalah ini bertahun-tahun yang lalu, tidak ada solusi yang siap pakai. <br><br>  Sekarang saya akan menjabarkan secara umum tentang implementasi kami dan bagaimana hal ini membantu untuk menghindari masalah ini.  Dan lebih banyak tentang dia dan perbedaannya dari solusi lain dapat didengar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam sebuah laporan oleh Mikhail Kurmaev tentang Highload Siberia</a> pada akhir Juni.  Transkrip laporannya juga akan ada di blog ini. <br><br>  Itu terlihat seperti ini: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dz/em/-d/dzem-dkkbiq6qx04cknxzdo99bc.png" width="500"></div><br>  Ada layanan Sphinx abstrak, yang dihadapi oleh pemutus sirkuit.  Pemutus sirkuit menyimpan jumlah koneksi aktif ke daemon tertentu.  Segera setelah nilai ini mencapai ambang batas, yang kami tetapkan sebagai persentase dari pekerja FPM yang tersedia di mesin, kami percaya bahwa layanan mulai melambat.  Setelah mencapai ambang pertama, kami mengirim pemberitahuan kepada orang yang bertanggung jawab atas layanan ini.  Situasi seperti itu merupakan tanda bahwa batas perlu ditinjau, atau pertanda masalah dengan kebodohan. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_g/ou/k6/_gouk6h_xfurcn_o04rslmiwsh8.png" width="500"></div><br>  Jika situasinya memburuk, dan jumlah pekerja yang menghambat mencapai nilai ambang kedua - dalam produksi kami sekitar 10% - kami benar-benar mengurangi host ini.  Lebih tepatnya, layanan ini sebenarnya terus berfungsi, tetapi kami berhenti mengirimkan permintaan kepadanya.  Browser Sirkuit menolak mereka dan segera memberi pekerja kesalahan, seolah-olah layanan itu bohong. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/co/ao/pd/coaopdx7tp0swvu8qu0t01jf81u.png" width="500"></div><br>  Dari waktu ke waktu, kami secara otomatis melompati permintaan dari seorang pekerja untuk melihat apakah layanan tersebut menjadi hidup.  Jika dia menjawab dengan memadai, maka kita kembali memasukkannya ke dalam pekerjaan. <br><br>  Semua ini dilakukan untuk mengurangi situasi ke skema replikasi sebelumnya.  Alih-alih menunggu sebentar sebelum menyadari bahwa host tidak tersedia, kami segera mendapatkan kesalahan dan pergi ke host cadangan. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9c/s8/iz/9cs8iz-aepaztqroslluwwregt0.png" width="400"></div><br><br><h3>  Implementasi </h3><br>  Untungnya, Open Source tidak berhenti, dan hari ini Anda dapat mengambil solusi turnkey di Github. <br><br>  Ada dua pendekatan utama untuk mengimplementasikan pemutus sirkuit: pustaka tingkat kode, dan daemon mandiri yang proksi permintaan melalui dirinya sendiri. <br><br>  Opsi dengan perpustakaan lebih cocok jika Anda memiliki satu monolit utama di PHP, yang berinteraksi dengan beberapa layanan, dan layanan tersebut hampir tidak saling berkomunikasi.  Berikut adalah beberapa implementasi yang tersedia: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ganesha</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemutus Sirkuit PHP</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Phystrix</a> <br></li></ul><br>  Jika Anda memiliki banyak layanan dalam bahasa yang berbeda, dan mereka semua berinteraksi satu sama lain, maka opsi di tingkat kode harus diduplikasi dalam semua bahasa ini.  Ini tidak nyaman dalam dukungan, dan pada akhirnya mengarah pada perbedaan dalam implementasi. <br><br>  Memasukkan satu daemon dalam kasus ini jauh lebih mudah.  Dalam hal ini, Anda tidak perlu mengedit kode secara khusus.  Setan berusaha membuat interaksi transparan.  Namun, opsi ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jauh lebih rumit secara arsitektur</a> . <br><br>  Berikut adalah beberapa opsi (fungsinya lebih kaya di sana, tetapi ada pemutus sirkuit juga): <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Utusan</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Linkerd</a> <br></li></ul><br><h3>  Kesimpulan </h3><br><ul><li>  Jangan mengandalkan jaringan. <br></li><li>  Semua permintaan jaringan harus memiliki batas waktu, karena jaringan dapat memberikan waktu yang sangat lama. <br></li><li>  Gunakan pemutus sirkuit jika Anda ingin menghindari aplikasi runtuh karena fakta bahwa satu layanan kecil melambat. <br></li></ul><br><h2>  Pemantauan dan telemetri </h2><br><h3>  Apa yang diberikannya </h3><br><ul><li>  <b>Prediktabilitas.</b>  Penting untuk memperkirakan apa muatannya dan berapa dalam satu bulan untuk meningkatkan jumlah layanan secara tepat waktu.  Ini terutama benar jika Anda berurusan dengan infrastruktur besi, karena memesan server baru membutuhkan waktu. </li><li>  <b>Investigasi insiden.</b>  Cepat atau lambat, sesuatu akan salah, dan Anda harus menyelidikinya.  Dan penting untuk memiliki data yang cukup untuk memahami masalah dan dapat mencegah situasi seperti itu di masa depan. </li><li>  <b>Pencegahan kecelakaan.</b>  Idealnya, Anda harus memahami pola mana yang menyebabkan crash.  Penting untuk melacak pola-pola ini dan memberi tahu tim tentang hal itu secara tepat waktu. </li></ul><br><br><h3>  Apa yang diukur </h3><br>  <b>Metrik integrasi</b> <br><br>  Karena kita berbicara tentang interaksi antara layanan, kami memantau segala sesuatu yang mungkin terkait dengan komunikasi layanan dengan aplikasi.  Sebagai contoh: <br><br><ul><li>  jumlah permintaan; <br></li><li>  meminta waktu pemrosesan (termasuk persentil); <br></li><li>  jumlah kesalahan logika; <br></li><li>  jumlah kesalahan sistem. <br></li></ul><br>  Penting untuk membedakan kesalahan logika dari kesalahan sistem.  Jika layanan jatuh, ini adalah situasi biasa: kami cukup beralih ke yang kedua.  Tapi itu tidak terlalu menakutkan.  Jika Anda memulai beberapa jenis kesalahan logika, misalnya, data aneh masuk ke layanan atau meninggalkannya, maka ini sudah perlu diselidiki.  Kemungkinan besar, kesalahan terkait dengan bug dalam kode.  Dia sendiri tidak akan lulus. <br><br>  <b>Metrik internal</b> <br><br>  Secara default, layanan ini adalah kotak hitam yang melakukan tugasnya dengan tidak dapat dimengerti.  Masih diinginkan untuk memahami dan mengumpulkan data maksimum yang dapat diberikan layanan.  Jika layanan adalah basis data khusus yang menyimpan beberapa data dari logika bisnis Anda, catat dengan tepat berapa banyak data, tipe apa itu, dan metrik konten lainnya.  Jika Anda memiliki interaksi yang tidak sinkron, penting juga untuk memantau antrian di mana layanan Anda berkomunikasi: kecepatan kedatangan dan keberangkatan mereka, waktu pada tahap yang berbeda (jika Anda memiliki beberapa titik perantara), jumlah acara dalam antrian. <br><br>  Mari kita lihat metrik apa yang dapat dikumpulkan menggunakan memcached sebagai contoh: <br><br><ul><li>  rasio hit / miss; <br></li><li>  waktu respons untuk berbagai operasi; <br></li><li>  RPS dari berbagai operasi; <br></li><li>  penguraian data yang sama pada kunci yang berbeda; <br></li><li>  kunci yang dimuat atas; <br></li><li>  semua metrik internal yang diberikan oleh perintah statistik. <br></li></ul><br><br><h3>  Bagaimana cara melakukannya </h3><br>  Jika Anda memiliki perusahaan kecil, proyek kecil, dan beberapa server, maka itu adalah solusi yang baik untuk menghubungkan semacam SaaS untuk pengumpulan dan melihat - lebih mudah dan lebih murah.  Dalam hal ini, biasanya SaaS memiliki fungsi yang luas, dan tidak perlu khawatir tentang banyak hal.  Contoh layanan tersebut: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Datadog</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rollbar</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Peninggalan baru</a> <br></li></ul><br>  Atau, Anda selalu dapat menginstal Zabbix, Grafana, atau solusi self-host lainnya di mesin Anda sendiri. <br><br><h3>  Kesimpulan </h3><br><ul><li>  <b>Kumpulkan semua metrik yang Anda bisa.</b>  Data tidak berlebihan.  Ketika Anda harus menyelidiki sesuatu, Anda akan mengucapkan terima kasih atas pemikiran Anda. </li><li>  <b>Jangan lupakan interaksi asinkron.</b>  Jika Anda memiliki garis yang mencapai secara bertahap, penting untuk memahami seberapa cepat mereka mencapai, apa yang terjadi pada acara Anda di persimpangan antara layanan. </li><li>  <b>Jika Anda menulis layanan Anda, ajarkan untuk memberikan statistik tentang pekerjaan.</b>  Bagian dari data dapat diukur pada lapisan integrasi ketika kita berkomunikasi dengan layanan ini.  Sisa layanan harus dapat memberikan statistik sesuai dengan perintah kondisional.  Misalnya, di semua layanan kami di Go, fungsi ini standar. </li><li>  <b>Kustomisasi pemicu.</b>  <b>Bagan itu bagus, tetapi hanya saat Anda melihatnya.</b>  Penting bahwa Anda memiliki sistem khusus yang akan memberi tahu Anda jika ada masalah. </li></ul><br><h2>  Memento mori </h2><br>  Dan sekarang sedikit tentang hal-hal yang menyedihkan.  Anda mungkin merasa bahwa di atas adalah obat mujarab, dan sekarang tidak ada yang akan jatuh.  Tetapi meskipun Anda menerapkan semua yang dijelaskan di atas, bagaimanapun, sesuatu akan pernah jatuh.  Penting untuk mempertimbangkan ini. <br>  Banyak alasan untuk jatuh.  Misalnya, Anda mungkin memilih skema replikasi paranoid yang tidak cukup.  Meteorit jatuh di pusat data Anda, dan kemudian di yang kedua.  Atau Anda hanya menggunakan kode dengan kesalahan rumit yang muncul tiba-tiba. <br><br>  Misalnya, di Badoo ada halaman "Orang-orang terdekat."  Di sana, pengguna mencari orang lain di dekatnya untuk mengobrol dengan mereka. <br><br><img src="https://habrastorage.org/webt/3q/l4/xm/3ql4xmmqeobxu4vsrqygagstflw.png"><br><br>  Sekarang, untuk merender halaman, backend melakukan panggilan sinkron ke sekitar tujuh layanan.  Untuk kejelasan, kurangi angka ini menjadi dua.  Satu layanan bertanggung jawab untuk memberikan blok pusat dengan foto.  Yang kedua adalah untuk blok iklan di kiri bawah.  Mereka yang ingin menjadi lebih terlihat bisa sampai di sana.  Jika kami memiliki layanan yang menampilkan iklan ini, blok itu hilang begitu saja. <br><br><img src="https://habrastorage.org/webt/rg/tu/pj/rgtupjtztftw7pgvxpwg7auwa1q.png"><br><br>  Sebagian besar pengguna bahkan tidak tahu tentang fakta ini: tim kami merespons dengan cepat, dan segera blok itu muncul kembali. <br><br>  Tetapi tidak setiap fungsionalitas dapat kita hapus dengan tenang.  Jika kami kehilangan layanan yang bertanggung jawab untuk bagian tengah halaman, ini tidak akan berhasil disembunyikan.  Karena itu, penting untuk memberi tahu pengguna dalam bahasanya apa yang terjadi. <br><br><img src="https://habrastorage.org/webt/eh/1q/c3/eh1qc3sr6laokkydqscq_ydilue.png"><br><br>  Juga diharapkan bahwa kegagalan satu layanan tidak menyebabkan kegagalan berjenjang.  Untuk setiap layanan, kode harus ditulis yang menangani kejatuhannya, jika tidak aplikasi akan macet secara keseluruhan. <br><br>  Tapi itu belum semuanya.  Terkadang sesuatu jatuh, tanpanya Anda tidak bisa hidup sama sekali dengan cara apa pun.  Misalnya, pusat data atau layanan sesi pusat.  Penting untuk menyelesaikannya dengan benar dan menunjukkan kepada pengguna sesuatu yang memadai, entah bagaimana menghiburnya, untuk mengatakan bahwa semuanya terkendali.  Pada saat yang sama, penting bahwa semuanya benar-benar terkendali, dan monitor diberitahu tentang masalah tersebut. <br><br><img src="https://habrastorage.org/webt/e6/hs/wt/e6hswt9cdlv2kfnt47zuujzyoyq.png"><br><br><img src="https://habrastorage.org/webt/lr/ch/g9/lrchg9mdfortw-jjnzi9ejdzr8u.png"><br><br><h3>  Mati begitu benar </h3><br><ul><li>  <b>Bersiaplah untuk musim gugur.</b>  Tidak ada peluru perak, jadi selalu sedotan jika layanan turun sepenuhnya, bahkan jika Anda menggunakan redundansi. </li><li>  <b>Hindari kegagalan cascading</b> ketika masalah dengan salah satu layanan mematikan seluruh aplikasi. </li><li>  <b>Nonaktifkan fungsionalitas pengguna yang tidak kritis.</b>  Ini normal.  Banyak layanan yang hanya digunakan untuk kebutuhan internal dan tidak memengaruhi fungsionalitas yang disediakan.  Misalnya, layanan statistik.  Sama sekali tidak masalah bagi pengguna apakah statistik dikumpulkan dari Anda atau tidak.  Penting baginya bahwa situs itu berfungsi. </li></ul><br><h2>  Ringkasan </h2><br>  Untuk mengintegrasikan layanan baru dengan andal ke dalam sistem, kami menulis API pembungkus khusus di sekitarnya di Badoo, yang mengambil tugas-tugas berikut: <br><br><ul><li>  load balancing; </li><li>  batas waktu; </li><li>  kegagalan logika; </li><li>  pemutus sirkuit; </li><li>  pemantauan dan telemetri; </li><li>  logika otorisasi; </li><li>  serialisasi dan deserialisasi data. </li></ul><br>  Lebih baik memastikan bahwa semua item ini juga tercakup dalam lapisan integrasi Anda.  Terutama jika Anda menggunakan klien Open-Source API yang sudah jadi.  Penting untuk diingat bahwa lapisan integrasi adalah sumber peningkatan risiko kegagalan aplikasi Anda. <br><br>  Terima kasih atas perhatian anda! <br><br>  <b>Sastra</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lepaskan!</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rekayasa Keandalan Situs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Membuat layanan microser</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id413555/">https://habr.com/ru/post/id413555/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id413545/index.html">Humor dalam branding - mengapa itu tidak selalu baik</a></li>
<li><a href="../id413547/index.html">Alami 2 juta sesi tanpa kepala</a></li>
<li><a href="../id413549/index.html">Kursus Kuliah Pengembangan Web</a></li>
<li><a href="../id413551/index.html">Scrolling dan perhatian (studi 2018)</a></li>
<li><a href="../id413553/index.html">Registrar REG.RU menghilangkan mitra akses ke 70 ribu domain dan mengambil layanan mereka sendiri</a></li>
<li><a href="../id413557/index.html">NewSQL: SQL tidak ke mana-mana</a></li>
<li><a href="../id413559/index.html">Degradasi web atau cara membuat web manusia dapat dibaca</a></li>
<li><a href="../id413561/index.html">Kecepatan Linq Expression Tree dikompilasi</a></li>
<li><a href="../id413563/index.html">4 cara untuk mengimpor paket ke Go</a></li>
<li><a href="../id413565/index.html">Analisis hack Kubernetes - backdoor via kubelet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>