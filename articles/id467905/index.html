<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎧 😮 🚘 Bagaimana kami membuat pengakuan tengara di Cloud Mail.ru, dan mengapa 🛵 🙍🏽 🦉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dengan munculnya ponsel dengan kamera berkualitas tinggi, kami mulai membuat lebih banyak dan lebih banyak gambar dan video momen yang cerah dan menge...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kami membuat pengakuan tengara di Cloud Mail.ru, dan mengapa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/467905/"><img src="https://habrastorage.org/webt/vz/bg/ov/vzbgovf2e5gessaexiyl0rnhvay.jpeg"><br><br>  Dengan munculnya ponsel dengan kamera berkualitas tinggi, kami mulai membuat lebih banyak dan lebih banyak gambar dan video momen yang cerah dan mengesankan dalam hidup kita.  Banyak dari kita memiliki arsip foto yang terbentang selama puluhan tahun dan terdiri dari ribuan gambar yang membuatnya semakin sulit untuk dijelajahi.  Hanya ingat berapa lama untuk menemukan gambar yang menarik hanya beberapa tahun yang lalu. <br><br>  Salah satu tujuan Mail.ru Cloud adalah untuk menyediakan sarana paling mudah untuk mengakses dan mencari arsip foto dan video Anda sendiri.  Untuk tujuan ini, kami di Mail.ru Computer Vision Team telah menciptakan dan menerapkan sistem untuk pemrosesan gambar cerdas: pencarian berdasarkan objek, berdasarkan adegan, berdasarkan wajah, dll.  Teknologi spektakuler lainnya adalah pengenalan tengara.  Hari ini, saya akan memberi tahu Anda bagaimana kami mewujudkan ini menggunakan Deep Learning. <br><a name="habracut"></a><br>  Bayangkan situasinya: Anda kembali dari liburan dengan membawa banyak foto.  Berbicara dengan teman-teman Anda, Anda diminta untuk menunjukkan gambar tempat yang layak dilihat, seperti istana, kastil, piramida, candi, danau, air terjun, gunung, dan sebagainya.  Anda terburu-buru untuk menggulir folder galeri Anda mencoba menemukan yang benar-benar bagus.  Kemungkinan besar, itu hilang di antara ratusan gambar, dan Anda mengatakan Anda akan menunjukkannya nanti. <br><br>  Kami mengatasi masalah ini dengan mengelompokkan foto pengguna dalam album.  Ini akan memungkinkan Anda menemukan gambar yang Anda butuhkan hanya dalam beberapa klik.  Sekarang kami memiliki album yang disusun berdasarkan wajah, objek dan adegan, dan juga oleh tengara. <br><br>  Foto dengan tengara sangat penting karena sering menangkap sorotan kehidupan kita (misalnya, perjalanan).  Ini dapat berupa gambar dengan beberapa arsitektur atau hutan belantara di latar belakang.  Inilah sebabnya kami mencari lokasi gambar tersebut dan membuatnya tersedia untuk pengguna. <br><br><h2>  Keunikan pengakuan tengara </h2><br>  Ada nuansa di sini: seseorang tidak hanya mengajarkan model dan membuatnya mengenali landmark segera - ada sejumlah tantangan. <br><br>  Pertama, kita tidak bisa mengatakan dengan jelas apa sebenarnya "tengara" itu.  Kita tidak bisa mengatakan mengapa bangunan adalah landmark, sedangkan bangunan lain di sampingnya tidak.  Ini bukan konsep formal, yang membuatnya lebih rumit untuk menyatakan tugas pengenalan. <br><br>  Kedua, landmark sangat beragam.  Ini bisa berupa bangunan bernilai sejarah atau budaya, seperti kuil, istana, atau kastil.  Atau, ini mungkin semua jenis monumen.  Atau fitur alami: danau, ngarai, air terjun, dan sebagainya.  Juga, ada model tunggal yang harus dapat menemukan semua landmark itu. <br><br>  Ketiga, gambar dengan landmark sangat sedikit.  Menurut perkiraan kami, mereka hanya menyumbang 1 hingga 3 persen dari foto pengguna.  Itulah sebabnya kami tidak mampu membuat kesalahan dalam pengakuan karena jika kami menunjukkan foto tanpa tanda pada seseorang, itu akan sangat jelas dan akan menyebabkan reaksi yang merugikan.  Atau, sebaliknya, bayangkan Anda menunjukkan gambar dengan tempat menarik di New York kepada orang yang belum pernah ke Amerika Serikat.  Dengan demikian, model pengakuan harus memiliki FPR rendah (false positive rate). <br><br>  Keempat, sekitar 50% pengguna atau bahkan lebih biasanya menonaktifkan penyimpanan data geografis.  Kita perlu mempertimbangkan ini dan hanya menggunakan gambar itu sendiri untuk mengidentifikasi lokasi.  Saat ini, sebagian besar layanan dapat menangani landmark dengan cara tertentu menggunakan geodata dari properti gambar.  Namun, persyaratan awal kami lebih ketat. <br><br>  Sekarang saya tunjukkan beberapa contoh. <br><br>  Berikut adalah tiga benda yang mirip, tiga katedral Gotik di Prancis.  Di sebelah kiri adalah katedral Amiens, yang di tengah adalah katedral Reims, dan Notre-Dame de Paris di sebelah kanan. <br><br><img src="https://habrastorage.org/webt/bh/4f/ej/bh4fejtind2ngdha-cgxdgkqf9g.jpeg"><br><br>  Bahkan manusia membutuhkan waktu untuk melihat dari dekat dan melihat bahwa ini adalah katedral yang berbeda, tetapi mesinnya harus dapat melakukan hal yang sama, dan bahkan lebih cepat daripada manusia. <br><br>  Inilah tantangan lain: ketiga foto di sini menampilkan gambar Notre-Dame de Paris dari berbagai sudut.  Foto-fotonya sangat berbeda, tetapi masih perlu dikenali dan diambil. <br><br><img src="https://habrastorage.org/webt/vx/de/wr/vxdewr0j1vdlm8knfq2_z_6n95u.jpeg"><br><br>  Fitur alami sama sekali berbeda dari arsitektur.  Di sebelah kiri adalah Kaisarea di Israel, di sebelah kanan adalah Englischer Garten di Munich. <br><br><img src="https://habrastorage.org/webt/y6/6o/mb/y66ombyco0nzwj3ghhjumufaiz4.jpeg"><br><br>  Foto-foto ini memberikan sedikit petunjuk pada model untuk ditebak. <br><br><h2>  Metode kami </h2><br>  Metode kami didasarkan sepenuhnya pada jaringan saraf convolutional yang mendalam.  Strategi pelatihan yang kami pilih disebut pembelajaran kurikulum yang berarti belajar dalam beberapa langkah.  Untuk mencapai efisiensi yang lebih besar baik dengan maupun tanpa data geografis, kami membuat kesimpulan khusus.  Biarkan saya memberi tahu Anda tentang setiap langkah secara lebih rinci. <br><br><h2>  Kumpulan data </h2><br>  Data adalah bahan bakar pembelajaran mesin.  Pertama-tama, kami harus mengumpulkan set data untuk mengajarkan model. <br><br>  Kami membagi dunia menjadi 4 wilayah, masing-masing digunakan pada langkah tertentu dalam proses pembelajaran.  Kemudian, kami memilih negara di setiap wilayah, memilih daftar kota untuk setiap negara, dan mengumpulkan bank foto.  Berikut ini beberapa contohnya. <br><br><img src="https://habrastorage.org/webt/cm/al/en/cmalenos8kpuchcb7ridv6m5rge.jpeg"><br><br>  Pertama, kami berusaha membuat model kami belajar dari basis data yang diperoleh.  Hasilnya buruk.  Analisis kami menunjukkan bahwa data itu kotor.  Terlalu banyak suara mengganggu pengakuan setiap tengara.  Apa yang harus kita lakukan?  Akan mahal, rumit, dan tidak terlalu bijak untuk meninjau semua data secara manual.  Jadi, kami merancang proses pembersihan basis data otomatis di mana penanganan manual hanya digunakan pada satu langkah: kami memilih sendiri 3 hingga 5 foto referensi untuk setiap tengara yang pasti menunjukkan objek yang diinginkan pada sudut yang kurang lebih sesuai.  Ini bekerja cukup cepat karena jumlah data referensi tersebut kecil dibandingkan dengan seluruh database.  Kemudian pembersihan otomatis berdasarkan jaringan saraf convolutional yang mendalam dilakukan. <br><br>  Selanjutnya, saya akan menggunakan istilah "embedding" yang saya maksudkan sebagai berikut.  Kami memiliki jaringan saraf convolutional.  Kami melatihnya untuk mengklasifikasikan objek, lalu kami memotong layer klasifikasi terakhir, mengambil beberapa gambar, menganalisisnya dengan jaringan, dan memperoleh vektor numerik pada output.  Inilah yang akan saya sebut embedding. <br><br>  Seperti yang saya katakan sebelumnya, kami mengatur proses pembelajaran kami dalam beberapa langkah yang sesuai dengan bagian-bagian dari basis data kami.  Jadi, pertama, kami mengambil jaringan saraf dari langkah sebelumnya atau jaringan inisialisasi. <br><br>  Kami memiliki foto referensi tengara, memprosesnya dengan jaringan dan mendapatkan beberapa embeddings.  Sekarang kita bisa melanjutkan ke pembersihan data.  Kami mengambil semua gambar dari kumpulan data untuk tengara dan masing-masing telah diproses oleh jaringan.  Kami memperoleh beberapa embeddings dan menentukan jarak ke referensi embeddings untuk masing-masing.  Kemudian, kami menentukan jarak rata-rata dan, jika melebihi beberapa ambang batas yang merupakan parameter algoritma, perlakukan objek tersebut sebagai non-landmark.  Jika jarak rata-rata kurang dari ambang, kami menyimpan foto itu. <br><br><img src="https://habrastorage.org/webt/cl/s7/xu/cls7xusqgmt6mmx5uoyksvkvg4s.jpeg"><br><br>  Sebagai hasilnya, kami memiliki database yang berisi lebih dari 11 ribu landmark dari lebih dari 500 kota di 70 negara, lebih dari 2,3 juta foto.  Ingatlah bahwa sebagian besar foto tidak memiliki landmark sama sekali.  Kita perlu menceritakannya kepada model kita.  Karena alasan ini, kami menambahkan 900 ribu foto tanpa landmark ke basis data kami dan melatih model kami dengan kumpulan data yang dihasilkan. <br><br>  Kami memperkenalkan tes offline untuk mengukur kualitas pembelajaran.  Mengingat bahwa tengara hanya terjadi pada 1 hingga 3% dari semua foto, kami secara manual menyusun satu set 290 gambar yang memang menampilkan tengara.  Foto-foto itu cukup beragam dan kompleks, dengan sejumlah besar objek ditembak dari sudut yang berbeda untuk membuat pengujian sesulit mungkin untuk model.  Mengikuti pola yang sama, kami mengambil 11 ribu foto tanpa landmark, agak rumit juga, dan kami mencoba menemukan objek yang mirip landmark dalam database kami. <br><br>  Untuk mengevaluasi kualitas pembelajaran, kami mengukur akurasi model kami menggunakan foto baik dengan dan tanpa landmark.  Ini adalah dua metrik utama kami. <br><br><h2>  Pendekatan yang ada </h2><br>  Ada relatif sedikit informasi tentang pengakuan tengara dalam literatur.  Sebagian besar solusi didasarkan pada fitur-fitur lokal.  Gagasan utamanya adalah kami memiliki beberapa gambar permintaan dan gambar dari database.  Fitur lokal - poin utama - ditemukan dan kemudian dicocokkan.  Jika jumlah kecocokan cukup besar, kami menyimpulkan bahwa kami telah menemukan tengara. <br><br>  Saat ini, metode terbaik adalah DELF (fitur lokal mendalam) yang ditawarkan oleh Google, yang menggabungkan fitur lokal yang sesuai dengan pembelajaran mendalam.  Dengan meminta gambar input diproses oleh jaringan convolutional, kami memperoleh beberapa fitur DELF. <br><br><img src="https://habrastorage.org/webt/i9/-5/g-/i9-5g-dj0fkjpxlgnjpwaadwyec.jpeg"><br><br>  Bagaimana cara kerja pengenalan tengara?  Kami memiliki bank foto dan gambar input, dan kami ingin tahu apakah itu menunjukkan tengara atau tidak.  Dengan menjalankan jaringan DELF dari semua foto, fitur-fitur yang sesuai untuk database dan gambar input dapat diperoleh.  Kemudian kami melakukan pencarian dengan metode tetangga terdekat dan memperoleh gambar kandidat dengan fitur di output.  Kami menggunakan verifikasi geometris untuk mencocokkan fitur: jika berhasil, kami menyimpulkan bahwa gambar menunjukkan tengara. <br><br><h2>  Jaringan saraf convolutional </h2><br>  Pra-pelatihan sangat penting untuk Deep Learning.  Jadi kami menggunakan basis data adegan untuk melatih jaringan saraf kami.  Kenapa begini?  Adegan adalah beberapa objek yang terdiri dari sejumlah besar objek lain.  Landmark adalah contoh adegan.  Dengan pra-pelatihan model dengan database seperti itu, kami dapat memberikan gambaran tentang beberapa fitur tingkat rendah yang kemudian dapat digeneralisasi untuk pengakuan landmark yang sukses. <br><br>  Kami menggunakan jaringan saraf dari keluarga jaringan Residual sebagai model.  Perbedaan kritis dari jaringan tersebut adalah mereka menggunakan blok residual yang mencakup koneksi skip yang memungkinkan sinyal melompati layer dengan bobot dan lewat dengan bebas.  Arsitektur semacam itu memungkinkan untuk melatih jaringan yang dalam dengan kualitas tinggi dan mengontrol efek gradien yang hilang, yang penting untuk pelatihan. <br><br>  Model kami adalah Wide ResNet-50-2, versi ResNet-50 di mana jumlah konvolusi dalam blok bottleneck internal digandakan. <br><br><img src="https://habrastorage.org/webt/s0/mg/ra/s0mgravn9tobelwyraas7v-umfi.jpeg"><br><br>  Jaringan berkinerja sangat baik.  Kami mengujinya dengan database adegan kami, dan berikut hasilnya: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Model <br></th><th>  1 err teratas <br></th><th>  5 err teratas <br></th></tr><tr><td>  ResNet-50 <br></td><td>  46,1% <br></td><td>  15,7% <br></td></tr><tr><td>  ResNet-200 <br></td><td>  42,6% <br></td><td>  12,9% <br></td></tr><tr><td>  SE-ResNext-101 <br></td><td>  42% <br></td><td>  12,1% <br></td></tr><tr><td>  WRN-50-2 (cepat!) <br></td><td>  41,8% <br></td><td>  11,8% <br></td></tr></tbody></table></div><br>  Wide ResNet bekerja hampir dua kali lebih cepat dari ResNet-200.  Bagaimanapun, ini adalah kecepatan lari yang sangat penting untuk produksi.  Mengingat semua pertimbangan ini, kami memilih Wide ResNet-50-2 sebagai jaringan saraf utama kami. <br><br><h2>  Pelatihan </h2><br>  Kami membutuhkan fungsi kehilangan untuk melatih jaringan kami.  Kami memutuskan untuk menggunakan pendekatan pembelajaran metrik untuk mengambilnya: jaringan saraf dilatih sehingga item-item dari kelas yang sama berbondong-bondong ke satu cluster, sementara cluster untuk kelas yang berbeda harus ditempatkan terpisah sejauh mungkin.  Untuk landmark, kami menggunakan Center loss yang menarik elemen satu kelas ke arah beberapa center.  Fitur penting dari pendekatan ini adalah bahwa ia tidak memerlukan pengambilan sampel negatif, yang menjadi hal yang agak sulit dilakukan di zaman kemudian. <br><br><img src="https://habrastorage.org/webt/ix/xd/if/ixxdifizq_hbvfbz6vloiqc_ppk.jpeg"><br><br>  Ingatlah bahwa kita memiliki n kelas landmark dan satu lagi kelas "non-landmark" yang tidak digunakan Center loss.  Kami menyiratkan bahwa tengara adalah satu dan objek yang sama, dan memiliki struktur, jadi masuk akal untuk menentukan pusatnya.  Adapun non-landmark, itu bisa merujuk pada apa pun, jadi tidak masuk akal untuk menentukan pusat untuk itu. <br><br>  Kami kemudian menggabungkan semua ini, dan ada model kami untuk pelatihan.  Ini terdiri dari tiga bagian utama: <br><br><ul><li>  Wide NeNet 50-2 jaringan saraf convolutional yang sudah dilatih sebelumnya dengan basis data adegan; </li><li>  Bagian penyisipan yang terdiri dari lapisan yang terhubung sepenuhnya dan lapisan norma batch; </li><li>  Klasifikasi yang merupakan lapisan yang terhubung penuh, diikuti oleh pasangan yang terdiri dari kerugian Softmax dan kerugian Pusat. </li></ul><br><img src="https://habrastorage.org/webt/pt/k0/g_/ptk0g_0cyy3qgfw0wp8d4zqfd3k.jpeg"><br><br>  Seperti yang Anda ingat, basis data kami dibagi menjadi 4 bagian berdasarkan wilayah.  Kami menggunakan 4 bagian ini dalam paradigma pembelajaran kurikulum.  Kami memiliki dataset saat ini, dan pada setiap tahap pembelajaran, kami menambahkan bagian lain dunia untuk mendapatkan dataset baru untuk pelatihan. <br><br>  Model ini terdiri dari tiga bagian, dan kami menggunakan tingkat pembelajaran khusus untuk masing-masing bagian dalam proses pelatihan.  Ini diperlukan agar jaringan dapat mempelajari tengara dari bagian dataset baru yang telah kami tambahkan dan mengingat data yang telah dipelajari.  Banyak percobaan membuktikan pendekatan ini sebagai yang paling efisien. <br><br>  Jadi, kami telah melatih model kami.  Sekarang kita perlu menyadari cara kerjanya.  Mari kita gunakan peta aktivasi kelas untuk menemukan bagian dari gambar yang paling mudah bereaksi jaringan saraf kita.  Gambar di bawah ini menunjukkan gambar input di baris pertama, dan gambar yang sama dilapis dengan peta aktivasi kelas dari jaringan yang telah kami latih pada langkah sebelumnya ditunjukkan di baris kedua. <br><br><img src="https://habrastorage.org/webt/_e/p6/x0/_ep6x0-7sjfjfkrmyyrxfhlunsq.jpeg"><br><br>  Peta panas menunjukkan bagian gambar mana yang lebih banyak dihadiri oleh jaringan.  Seperti yang ditunjukkan oleh peta aktivasi kelas, jaringan saraf kami telah mempelajari konsep landmark dengan sukses. <br><br><h2>  Kesimpulan </h2><br>  Sekarang kita perlu menggunakan pengetahuan ini untuk menyelesaikan sesuatu.  Karena kami telah menggunakan kehilangan Center untuk pelatihan, dalam kasus inferensi, tampaknya cukup logis untuk menentukan centroid untuk landmark juga. <br><br>  Untuk melakukan ini, kami mengambil bagian dari gambar dari set pelatihan untuk beberapa tengara, katakanlah, Penunggang Kuda Perunggu di Saint Petersburg.  Lalu kami minta mereka diproses oleh jaringan, mendapatkan embeddings, mengeluarkan rata-rata, dan mendapatkan centroid. <br><br><img src="https://habrastorage.org/webt/zy/di/6f/zydi6frte3yxetvtnnkwak2t9y4.jpeg"><br><br>  Namun, ini adalah sebuah pertanyaan: berapa banyak centroid per landmark yang masuk akal untuk diturunkan?  Awalnya, tampak jelas dan logis untuk mengatakan: satu centroid.  Tidak juga, ternyata.  Kami awalnya memutuskan untuk membuat centroid tunggal juga, dan hasilnya tidak buruk.  Jadi mengapa beberapa centroid? <br><br>  Pertama, data yang kami miliki tidak begitu bersih.  Meskipun kami telah membersihkan dataset, kami hanya menghapus data limbah yang jelas.  Namun, mungkin masih ada gambar yang tidak sia-sia tetapi berdampak buruk pada hasilnya. <br><br>  Misalnya, saya memiliki kelas Istana Musim Dingin di Saint Petersburg.  Saya ingin mendapatkan centroid untuk itu.  Namun, set datanya mencakup beberapa foto dengan Palace Square dan lengkungan Kantor Pusat Umum, karena objek-objek ini saling berdekatan.  Jika centroid akan ditentukan untuk semua gambar, hasilnya tidak akan terlalu stabil.  Yang perlu kita lakukan adalah mengelompokkan entah bagaimana embeddings mereka berasal dari jaringan saraf, hanya mengambil centroid yang berhubungan dengan Istana Musim Dingin, dan rata-rata menggunakan data yang dihasilkan. <br><br><img src="https://habrastorage.org/webt/do/2n/lz/do2nlzvg9awjggqsodeuxn9hz3o.jpeg"><br><br>  Kedua, foto mungkin diambil dari berbagai sudut. <br><br>  Berikut adalah contoh perilaku seperti yang diilustrasikan dengan Belfry of Bruges.  Dua centroid telah diturunkan untuk itu.  Di baris atas pada gambar, ada foto-foto yang lebih dekat ke centroid pertama, dan di baris kedua - yang lebih dekat ke centroid kedua. <br><br><img src="https://habrastorage.org/webt/34/uo/n5/34uon5ifrysj8l9xlh3wwykzw6o.jpeg"><br><br>  Centroid pertama berkaitan dengan lebih banyak foto "besar" yang diambil di pasar di Bruges dalam jarak dekat.  Penawaran centroid kedua dengan foto yang diambil dari jarak jauh di jalan-jalan tertentu. <br><br>  Ternyata, dengan menurunkan beberapa centroid per kelas landmark, kita dapat merefleksikan inferensi sudut kamera yang berbeda untuk landmark tersebut. <br><br>  Jadi, bagaimana kita mendapatkan set itu untuk mendapatkan centroid?  Kami menerapkan pengelompokan hierarkis (tautan lengkap) ke kumpulan data untuk setiap tengara.  Kami menggunakannya untuk menemukan kelompok yang valid dari mana centroid akan diturunkan.  Yang kami maksud adalah kluster yang valid, yang terdiri dari setidaknya 50 foto sebagai hasil pengelompokan.  Cluster lainnya ditolak.  Hasilnya, kami memperoleh sekitar 20% landmark dengan lebih dari satu centroid. <br><br>  Sekarang untuk menarik kesimpulan.  Itu diperoleh dalam dua langkah: pertama, kami memberi makan gambar input ke jaringan saraf convolutional kami dan mendapatkan embedding, dan kemudian mencocokkan embedding dengan centroid menggunakan produk titik.  Jika gambar memiliki data geo, kami membatasi pencarian untuk centroid, yang merujuk ke landmark yang terletak dalam 1x1 km persegi dari lokasi gambar.  Ini memungkinkan pencarian yang lebih akurat dan ambang yang lebih rendah untuk pencocokan berikutnya.  Jika jarak yang dihasilkan melebihi ambang batas yang merupakan parameter algoritma, maka kami menyimpulkan bahwa foto memiliki tengara dengan nilai produk titik maksimum.  Jika kurang, maka foto tersebut bukan foto tengara. <br><br><img src="https://habrastorage.org/webt/mi/pl/os/miplosde7vmgj1ty5qlsjzabc2u.png"><br><br>  Misalkan foto memiliki tengara.  Jika kami memiliki data geo, maka kami menggunakannya dan memperoleh jawaban.  Jika data geografis tidak tersedia, maka kami menjalankan pemeriksaan tambahan.  Ketika kami sedang membersihkan dataset, kami membuat satu set gambar referensi untuk setiap kelas.  Kami dapat menentukan embeddings untuk mereka, dan kemudian mendapatkan jarak rata-rata dari mereka ke embedding gambar permintaan.  Jika melebihi beberapa ambang batas, maka verifikasi dilewati, dan kami membawa metadata dan memperoleh hasilnya.  Penting untuk dicatat bahwa kita dapat menjalankan prosedur ini untuk beberapa landmark yang telah ditemukan dalam gambar. <br><br><img src="https://habrastorage.org/webt/rw/kd/ht/rwkdhtwi78ko9fohfgj2dex-lro.png"><br><br><h2>  Hasil tes </h2><br>  Kami membandingkan model kami dengan DELF, dan kami mengambil parameter yang akan menunjukkan kinerja terbaik dalam pengujian kami.  Hasilnya hampir identik. <br><br><div class="scrollable-table"><table><tbody><tr><th>  Model <br></th><th>  Landmark <br></th><th>  Non-landmark <br></th></tr><tr><td>  Model kami <br></td><td>  80% <br></td><td>  99% <br></td></tr><tr><td>  Delf <br></td><td>  80,1% <br></td><td>  99% <br></td></tr></tbody></table></div><br>  Kemudian kami mengklasifikasikan landmark menjadi dua jenis: sering (lebih dari 100 foto dalam database), yang merupakan 87% dari semua landmark dalam pengujian, dan langka.  Model kami berfungsi baik dengan model yang sering: presisi 85,3%.  Dengan landmark yang langka, kami memiliki 46% yang juga tidak buruk sama sekali, yang berarti bahwa pendekatan kami bekerja dengan cukup baik bahkan dengan sedikit data. <br><br><div class="scrollable-table"><table><tbody><tr><th>  Jenis <br></th><th>  Presisi <br></th><th>  Bagikan jumlah total <br></th></tr><tr><td>  Sering <br></td><td>  85,3% <br></td><td>  87% <br></td></tr><tr><td>  Jarang <br></td><td>  46% <br></td><td>  13% <br></td></tr></tbody></table></div><br>  Kemudian kami menjalankan uji A / B dengan foto pengguna.  Akibatnya, tingkat konversi pembelian ruang cloud tumbuh sebesar 10%, tingkat konversi penghapusan aplikasi seluler berkurang sebesar 3%, dan jumlah tampilan album meningkat sebesar 13%. <br><br>  Mari kita bandingkan kecepatan kami dengan DELF.  Dengan GPU, DELF membutuhkan 7 network run karena menggunakan 7 skala gambar, sementara pendekatan kami hanya menggunakan 1. Dengan CPU, DELF menggunakan pencarian yang lebih panjang dengan metode tetangga terdekat dan verifikasi geometris yang sangat panjang.  Pada akhirnya, metode kami 15 kali lebih cepat dengan CPU.  Pendekatan kami menunjukkan kecepatan yang lebih tinggi dalam kedua kasus, yang sangat penting untuk produksi. <br><br><h2>  Hasil: kenangan dari liburan </h2><br>  Di awal artikel ini, saya menyebutkan solusi untuk menggulir dan menemukan gambar tengara yang diinginkan.  Ini dia. <br><br><img src="https://habrastorage.org/webt/ps/x_/7x/psx_7x8ptraq4s_tjodrfhi3g6o.jpeg"><br><br>  Ini cloud saya di mana semua foto diklasifikasikan ke dalam album.  Ada album "People", "Objects", dan "Attraction".  Di album Atraksi, tengara diklasifikasikan ke dalam album yang dikelompokkan berdasarkan kota.  Klik pada Dresdner Zwinger membuka album dengan foto-foto tengara ini saja. <br><br><img src="https://habrastorage.org/webt/sf/qa/bz/sfqabzwvyehdtq9nv4ko85rbnnu.jpeg" width="400"><br><br>  Fitur praktis: Anda dapat pergi berlibur, mengambil beberapa foto dan menyimpannya di cloud Anda.  Kemudian, ketika Anda ingin mengunggahnya ke Instagram atau berbagi dengan teman dan keluarga, Anda tidak perlu mencari dan memilih terlalu lama - foto yang diinginkan akan tersedia hanya dengan beberapa klik. <br><br><h2>  Kesimpulan </h2><br>  Biarkan saya mengingatkan Anda tentang fitur utama dari solusi kami. <br><br><ol><li>  Pembersihan basis data semi-otomatis.  Sedikit pekerjaan manual diperlukan untuk pemetaan awal, dan kemudian jaringan saraf akan melakukan sisanya.  Ini memungkinkan untuk membersihkan data baru dengan cepat dan menggunakannya untuk melatih ulang model. </li><li>  Kami menggunakan jaringan saraf convolutional yang mendalam dan pembelajaran metrik mendalam yang memungkinkan kami mempelajari struktur di kelas secara efisien. </li><li>  Kami telah menggunakan pembelajaran kurikulum, yaitu pelatihan di bagian-bagian, sebagai paradigma pelatihan.  Pendekatan ini sangat membantu kami.  Kami menggunakan beberapa centroid pada inferensi, yang memungkinkan penggunaan data yang lebih bersih dan menemukan berbagai tampilan tengara. </li></ol><br>  Mungkin tampak bahwa pengenalan objek adalah tugas yang sepele.  Namun, menjelajahi kebutuhan pengguna kehidupan nyata, kami menemukan tantangan baru seperti pengakuan tengara.  Teknik ini memungkinkan untuk memberi tahu orang-orang sesuatu yang baru tentang dunia menggunakan jaringan saraf.  Ini sangat menggembirakan dan memotivasi! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467905/">https://habr.com/ru/post/id467905/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467893/index.html">Hanya pembungkus Qt lain untuk gRPC dan protobuf</a></li>
<li><a href="../id467895/index.html">Pola apa yang ditemukan jaringan saraf?</a></li>
<li><a href="../id467897/index.html">Alat uji otomatis, integrasi Yandex Mapkit 3, desain keren, dan pendekatan UI Berbasis Server - Pengumuman mitap Android</a></li>
<li><a href="../id467901/index.html">Sanggah empat stereotip tentang bahasa pemrograman Rust</a></li>
<li><a href="../id467903/index.html">20 fitur navigasi teratas di IntelliJ IDEA. Bagian 1</a></li>
<li><a href="../id467907/index.html">Pro dan kontra dari outsourcing</a></li>
<li><a href="../id467909/index.html">Obrolan di iOS: menggunakan soket</a></li>
<li><a href="../id467913/index.html">Cara meningkatkan "mineral bajingan", atau antarmuka baru untuk panel surya</a></li>
<li><a href="../id467915/index.html">Memantau postgres di dalam OpenShift</a></li>
<li><a href="../id467917/index.html">Template Manajemen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>