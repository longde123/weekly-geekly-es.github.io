<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍨 🧔🏾 🧑🏿‍🤝‍🧑🏾 5 secretos ocultos en Java 🕴🏻 🤹🏾 🛣️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Les presento la traducción del artículo " 5 secretos ocultos en Java " de Justin Albano . 

 ¿Quieres convertirte en un Jedi de Java? Descu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 secretos ocultos en Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480544/"> Hola Habr!  Les presento la traducción del artículo " <a href="https://dzone.com/articles/5-hidden-secrets-in-java">5 secretos ocultos en Java</a> " de <a href="https://dzone.com/users/1144561/albanoj2.html">Justin Albano</a> . <br><br>  ¿Quieres convertirte en un Jedi de Java?  Descubre los antiguos secretos de Java.  Nos centraremos en ampliar las anotaciones, la inicialización, los comentarios y las interfaces de enumeración. <br><br>  Con el desarrollo de lenguajes de programación, las funciones ocultas también comienzan a aparecer, y las construcciones en las que los fundadores nunca pensaron se están extendiendo cada vez más para uso general.  Algunas de estas funciones se aceptan generalmente en el idioma, mientras que otras se trasladan a los rincones más oscuros de la comunidad lingüística.  En este artículo, veremos cinco secretos que a menudo pasan por alto muchos desarrolladores de Java (para ser justos, algunos de ellos tienen buenas razones para esto).  Consideraremos tanto las opciones para su uso como las razones que llevaron a la aparición de cada función, así como algunos ejemplos que demuestran cuándo es aconsejable usar estas funciones. <br><a name="habracut"></a><br>  El lector debe comprender que no todas estas funciones están realmente ocultas, simplemente no se usan con frecuencia en la programación diaria.  Algunos de ellos pueden ser muy útiles en el momento adecuado, mientras que usar otros es casi siempre una mala idea, y se muestran en este artículo para interesar al lector (y posiblemente hacer que se ría).  El lector también debe decidir cuándo usar las funciones descritas en este artículo: "El hecho de que esto se pueda hacer no significa que deba hacerse". <br><br><h3>  1. Implementar anotaciones </h3><br>  Comenzando con el Java Development Kit (JDK) 5, las anotaciones son una parte integral de muchas aplicaciones y entornos Java.  En la gran mayoría de los casos, las anotaciones se aplican a construcciones como clases, campos, métodos, etc.  Sin embargo, también se pueden usar como interfaces implementadas.  Por ejemplo, supongamos que tenemos la siguiente definición de anotación: <br><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-meta"><span class="hljs-meta">@Target</span></span>(ElementType.METHOD) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Test { <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br>  Usualmente aplicamos esta anotación a un método como se muestra a continuación: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyTestFixure</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">givenFooWhenBarThenBaz</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre> <br>  Entonces podemos procesar esta anotación como se describe en <a href="https://dzone.com/articles/creating-custom-annotations-in-java">Creación de anotaciones en Java</a> .  Si también quisiéramos crear una interfaz que nos permita crear pruebas como objetos, tendríamos que crear una nueva interfaz, llamándola de otra manera, y no Prueba: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestInstance</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br>  A continuación, podemos crear una instancia del objeto TestInstance: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooTestInstance</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestInstance</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Foo"</span></span>; } } TestInstance myTest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FooTestInstance();</code> </pre> <br>  Aunque nuestra anotación e interfaz son casi idénticas, con una duplicación muy notable, parece que no hay forma de combinar estas dos construcciones.  Afortunadamente, las apariencias engañan, y hay un método para combinar estas dos construcciones: Implementación de anotaciones: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Foo"</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Class&lt;? extends Annotation&gt; annotationType() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Test.class; } }</code> </pre> <br>  Tenga en cuenta que debemos implementar el método annotationType y también devolver el tipo de anotación, ya que esta es una parte implícita de la interfaz Annotation.  Aunque en la mayoría de los casos la implementación de anotaciones no es la solución adecuada para el diseño (el compilador de Java mostrará una advertencia al implementar la interfaz), esto puede ser útil en algunos casos, por ejemplo, en el marco basado en anotaciones. <br><br><h3>  2. Bloques de inicialización no estáticos. </h3><br>  En Java, como en la mayoría de los lenguajes de programación orientados a objetos, los objetos se crean exclusivamente utilizando el constructor (con algunas excepciones, como deserializar objetos Java).  Incluso cuando creamos métodos de fábrica estáticos para crear objetos, simplemente encerramos una llamada en el constructor del objeto para instanciarlo.  Por ejemplo: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Foo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">withName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(name); } } Foo foo = Foo.withName(<span class="hljs-string"><span class="hljs-string">"Bar"</span></span>);</code> </pre> <br>  Por lo tanto, cuando queremos inicializar un objeto, combinamos la lógica de inicialización en el constructor del objeto.  Por ejemplo, establecemos el campo de nombre de la clase Foo en su constructor parametrizado.  Aunque puede parecer razonable suponer que toda la lógica de inicialización está en el constructor o conjunto de constructores para la clase, este no es el caso en Java.  En cambio, podemos usar <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/initial.html">bloques de inicialización no estáticos</a> para ejecutar código al crear un objeto: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:instance 1"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:constructor"</span></span>); } }</code> </pre> <br>  Los bloques de inicialización no estáticos se especifican agregando lógica de inicialización a un conjunto de llaves en la definición de clase.  Cuando se crea un objeto, primero se llaman los bloques de inicialización no estáticos y luego los constructores del objeto.  Tenga en cuenta que puede especificar más de un bloque de inicialización no estático, en cuyo caso cada uno se llama en el orden en que se especifica en la definición de clase.  Además de los bloques de inicialización no estáticos, también podemos crear bloques estáticos que se ejecutan cuando la clase se carga en la memoria.  Para crear un bloque de inicialización estática, simplemente agregamos la palabra clave estática: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:instance 1"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:static 1"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:constructor"</span></span>); } }</code> </pre> <br>  Cuando los tres métodos de inicialización están presentes en la clase (constructores, bloques de inicialización no estáticos y bloques de inicialización estática), los estáticos siempre se ejecutan primero (cuando la clase se carga en la memoria) en el orden de su declaración, luego los bloques de inicialización no estáticos se ejecutan en el orden en que se declaran, y después de ellos, los diseñadores.  Cuando se introduce una superclase, el orden de ejecución cambia un poco: <br><br><ol><li>  Bloques de inicialización de superclase estática, en el orden de su declaración </li><li>  Bloques de inicialización de subclase estática, en el orden de su declaración </li><li>  Bloques de inicialización de superclase no estáticos, en el orden en que se declaran </li><li>  Constructor de superclase </li><li>  Bloques de inicialización de subclase no estáticos, en el orden en que se declaran </li><li>  Constructor de subclase </li></ol><br>  Por ejemplo, podemos crear la siguiente aplicación: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:static 1"</span></span>); } { System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:instance 1"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:static 2"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:constructor"</span></span>); } { System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:instance 2"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:name-constructor"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:static 1"</span></span>); } { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:instance 1"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:static 2"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:constructor"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(name); System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:name-constructor"</span></span>); } { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:instance 2"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(); System.out.println(); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(<span class="hljs-string"><span class="hljs-string">"Baz"</span></span>); } }</code> </pre> <br>  Si ejecutamos este código, obtenemos el siguiente resultado: <br><br><pre> <code class="java hljs">Bar:<span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> Bar:<span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> Foo:<span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> Foo:<span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> Bar:instance <span class="hljs-number"><span class="hljs-number">1</span></span> Bar:instance <span class="hljs-number"><span class="hljs-number">2</span></span> Bar:constructor Foo:instance <span class="hljs-number"><span class="hljs-number">1</span></span> Foo:instance <span class="hljs-number"><span class="hljs-number">2</span></span> Foo:constructor Bar:instance <span class="hljs-number"><span class="hljs-number">1</span></span> Bar:instance <span class="hljs-number"><span class="hljs-number">2</span></span> Bar:name-constructor Foo:instance <span class="hljs-number"><span class="hljs-number">1</span></span> Foo:instance <span class="hljs-number"><span class="hljs-number">2</span></span> Foo:name-constructor</code> </pre> <br>  Tenga en cuenta que los bloques de inicialización estática se ejecutaron solo una vez, incluso si se crearon dos objetos Foo.  Aunque los bloques de inicialización no estadísticos y estáticos pueden ser útiles, la lógica de inicialización debe colocarse en los constructores, y los métodos (o métodos estáticos) deben usarse en casos donde la lógica compleja requiere inicializar el estado del objeto. <br><br><h3>  3. Inicialización de paréntesis doble </h3><br>  Muchos lenguajes de programación incluyen algún tipo de mecanismo de sintaxis para crear rápida y brevemente una lista o mapa (o diccionario) sin usar un código de plantilla detallado.  Por ejemplo, C ++ incluye la <a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization">inicialización de paréntesis</a> , que permite a los desarrolladores crear rápidamente una lista de valores enumerados o incluso inicializar objetos completos si el constructor del objeto admite esta función.  Desafortunadamente, antes de JDK 9, dicha función no se implementó (más sobre eso más adelante).  Para crear simplemente una lista de objetos, haríamos lo siguiente: <br><br><pre> <code class="java hljs">List&lt;Integer&gt; myInts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); myInts.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); myInts.add(<span class="hljs-number"><span class="hljs-number">2</span></span>); myInts.add(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  Aunque esto cumple nuestro objetivo de crear una nueva lista inicializada con tres valores, es demasiado detallada, lo que requiere que el desarrollador repita el nombre de la variable de lista para cada adición.  Para acortar este código, podemos usar la <a href="https://stackoverflow.com/questions/1958636/what-is-double-brace-initialization-in-java">inicialización doble de corchetes</a> : <br><br><pre> <code class="java hljs">List &lt; Integer &gt;List&lt;Integer&gt; myInts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;() {{ add(<span class="hljs-number"><span class="hljs-number">1</span></span>); add(<span class="hljs-number"><span class="hljs-number">2</span></span>); add(<span class="hljs-number"><span class="hljs-number">3</span></span>); }};</code> </pre> <br>  Una inicialización de doble paréntesis, que deriva su nombre de un conjunto de dos llaves rizadas abiertas y cerradas, es en realidad una colección de varios elementos de sintaxis.  Primero, creamos <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html">una clase interna anónima</a> que extiende la clase ArrayList.  Como ArrayList no tiene métodos abstractos, podemos crear un cuerpo vacío para una implementación anónima: <br><br><pre> <code class="java hljs">List&lt;Integer&gt; myInts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;() {};</code> </pre> <br>  Usando este código, esencialmente creamos una subclase anónima, ArrayList es exactamente la misma que la ArrayList original.  Una de las principales diferencias es que nuestra clase interna tiene una referencia implícita a la clase que lo contiene (en forma de una variable capturada por esto), porque  Creamos una clase interna no estática.  Esto nos permite escribir una lógica interesante, si no confusa.  Por ejemplo, al agregar esta variable a una clase interna anónima inicializada con un paréntesis doble: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Foo&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getListWithMeIncluded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Foo&gt;() {{ add(Foo.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }}; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ Foo foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(); List&lt;Foo&gt; fooList = foo.getListWithMeIncluded(); System.out.println(foo.equals(fooList.get(<span class="hljs-number"><span class="hljs-number">0</span></span>))); } }</code> </pre> <br>  Si esta clase interna se definiera como estática, no tendríamos acceso a Foo.this.  Por ejemplo, el siguiente código que crea una clase interna FooArrayList estática no tiene acceso al enlace Foo.this y, por lo tanto, no se compila: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Foo&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getListWithMeIncluded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FooArrayList(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooArrayList</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArrayList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class">&gt; </span></span>{{ add(Foo.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }} }</code> </pre> <br>  Al reanudar la construcción con nuestra ArrayList inicializada con dos corchetes, una vez que se ha creado una clase interna no estática, utilizamos bloques de inicialización no estática, como se describió anteriormente, para agregar los tres elementos iniciales al instanciar una clase interna anónima.  Cuando se crea una clase interna anónima y cuando solo hay un objeto de una clase interna anónima, podemos decir que creamos un objeto interno no estático que agrega tres elementos iniciales cuando se crea.  Esto se verá si separamos un par de llaves, donde una llave representa la definición de una clase interna anónima y la otra marca el comienzo de la lógica de inicialización de la instancia: <br><br><pre> <code class="java hljs">List&lt;Integer&gt; myInts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;() { { add(<span class="hljs-number"><span class="hljs-number">1</span></span>); add(<span class="hljs-number"><span class="hljs-number">2</span></span>); add(<span class="hljs-number"><span class="hljs-number">3</span></span>); } };</code> </pre> <br>  Aunque este truco puede ser útil, JDK 9 ( <a href="http://openjdk.java.net/jeps/269">JEP 269</a> ) ha reemplazado la utilidad de este truco con un conjunto de métodos de fábrica estáticos para List (así como muchos otros tipos de colecciones).  Por ejemplo, podríamos crear una Lista anteriormente usando estos métodos de fábrica estáticos, como se muestra a continuación: <br><br><pre> <code class="java hljs">List&lt;Integer&gt; myInts = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  Esta técnica de fábrica estática se usa por dos razones principales: (1) no se crea una clase interna anónima y (2) para reducir el código estándar necesario para crear una Lista.  Debe recordarse que en este caso el resultado de la Lista no cambia y no se puede cambiar después de su creación.  Para crear un archivo de Lista mutable con cualquier elemento inicial, tenemos que usar un método regular o un método con un paréntesis de inicialización doble. <br><br>  Tenga en cuenta que la inicialización simple, el paréntesis doble y los métodos de fábrica estáticos JDK 9 no solo están disponibles para List.  Están disponibles para establecer y asignar objetos, como se muestra en el siguiente fragmento de código: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   Map&lt;String, Integer&gt; myMap = new HashMap&lt;&gt;(); myMap.put("Foo", 10); myMap.put("Bar", 15); //     Map&lt;String, Integer&gt; myMap = new HashMap&lt;&gt;() {{ put("Foo", 10); put("Bar", 15); }}; //    Map&lt;String, Integer&gt; myMap = Map.of("Foo", 10, "Bar", 15);</span></span></code> </pre> <br>  Es importante comprender cómo se inicializa el paréntesis doble antes de decidir sobre su uso.  Esto mejora la legibilidad del código, pero pueden aparecer algunos efectos secundarios. <br><br><h3>  4. Comentarios ejecutables </h3><br>  Los comentarios son una parte integral de casi todos los programas, y la principal ventaja de los comentarios es que no se ejecutan.  Esto se vuelve aún más obvio cuando comentamos una línea de código en nuestro programa: queremos guardar el código en nuestra aplicación, pero no queremos que se ejecute.  Por ejemplo, el siguiente programa muestra "5" como resultado: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// value = 8; System.out.println(value); }</span></span></code> </pre> <br>  Mucha gente piensa que los comentarios nunca se ejecutan, pero esto no es del todo cierto.  Por ejemplo, ¿cuál será el resultado del siguiente fragmento de código? <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// \u000dvalue = 8; System.out.println(value); }</span></span></code> </pre> <br>  Podría suponer que esto es nuevamente 5, pero si ejecutamos el código anterior, veremos 8 en la salida.  La razón de este "error" es el carácter Unicode \ u000d;  Este carácter es en realidad un <a href="https://www.compart.com/en/unicode/U%2B000D">retorno de carro Unicode</a> , y el compilador utiliza el código fuente de Java como archivos de texto en formato Unicode.  Su adición al código establece el valor = 8 en la línea que sigue al comentario, asegurando su ejecución.  Esto significa que el fragmento de código anterior es en realidad igual al siguiente: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// value = 8; System.out.println(value); }</span></span></code> </pre> <br>  Aunque esto parece un error de Java, en realidad es una característica especialmente agregada al lenguaje.  El objetivo inicial era crear un lenguaje independiente de la plataforma (de ahí la creación de una máquina virtual Java o JVM), y la interoperabilidad del código fuente es un aspecto clave de este objetivo.  Al permitir que el código fuente de Java contenga caracteres Unicode, podemos usar caracteres no latinos de manera universal.  Esto garantiza que el código escrito en una región del mundo (que puede contener caracteres no latinos, como en los comentarios), se pueda ejecutar en cualquier otra.  Consulte la <a href="https://docs.oracle.com/javase/specs/jls/se9/html/jls-3.html">Sección 3.3 Especificaciones del lenguaje Java o JLS</a> para obtener más información. <br><br>  Podemos llevar esto al extremo e incluso escribir una aplicación completa en Unicode.  Por ejemplo, ¿qué hace el siguiente programa (código fuente, derivado de <a href="https://programming.guide/java/executing-code-in-comments.html">Java: ¿Ejecución de código en comentarios?</a> ) <br><br><pre> <code class="java hljs">\u0070\u0075\u0062\u006c\u0069\u0063\u0020\u0020\u0020\u0020 \u0063\u006c\u0061\u0073\u0073\u0020\u0055\u0067\u006c\u0079 \u007b\u0070\u0075\u0062\u006c\u0069\u0063\u0020\u0020\u0020 \u0020\u0020\u0020\u0020\u0073\u0074\u0061\u0074\u0069\u0063 \u0076\u006f\u0069\u0064\u0020\u006d\u0061\u0069\u006e\u0028 \u0053\u0074\u0072\u0069\u006e\u0067\u005b\u005d\u0020\u0020 \u0020\u0020\u0020\u0020\u0061\u0072\u0067\u0073\u0029\u007b \u0053\u0079\u0073\u0074\u0065\u006d\u002e\u006f\u0075\u0074 \u002e\u0070\u0072\u0069\u006e\u0074\u006c\u006e\u0028\u0020 \u0022\u0048\u0065\u006c\u006c\u006f\u0020\u0077\u0022\u002b \u0022\u006f\u0072\u006c\u0064\u0022\u0029\u003b\u007d\u007d</code> </pre> <br>  Si coloca el código anterior en un archivo llamado Ugly.java y lo ejecuta, Hello world se imprimirá en la salida estándar.  Si convertimos estos caracteres Unicode en caracteres del <a href="https://en.wikipedia.org/wiki/ASCII">Código Estándar Americano para el Intercambio de Información (ASCII)</a> , obtenemos el siguiente programa: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ugly</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hello w"</span></span>+<span class="hljs-string"><span class="hljs-string">"orld"</span></span>); } }</code> </pre> <br>  Por lo tanto, los caracteres Unicode se pueden incluir en el código fuente de Java, sin embargo, si no son necesarios, se recomienda encarecidamente no usarlos (por ejemplo, para incluir caracteres no latinos en los comentarios).  Sin embargo, si se requieren, asegúrese de que no incluyan caracteres, como retornos de carro, que modifiquen el comportamiento esperado del código fuente. <br><br><h3>  5. Implementación de la interfaz Enum </h3><br>  Una de las limitaciones de las enumeraciones (una lista de enumeración) en comparación con otras clases en Java es que las enumeraciones no pueden extender otra clase o enumeraciones por sí mismas.  Por ejemplo, no puede hacer lo siguiente: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Speaker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hi"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Person extends Speaker { JOE(<span class="hljs-string"><span class="hljs-string">"Joseph"</span></span>), JIM(<span class="hljs-string"><span class="hljs-string">"James"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } } Person.JOE.speak();</code> </pre> <br>  Sin embargo, podemos obligar a nuestras enumeraciones a implementar la interfaz y proporcionar una implementación para sus métodos abstractos de la siguiente manera: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Speaker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Person implements Speaker { JOE(<span class="hljs-string"><span class="hljs-string">"Joseph"</span></span>), JIM(<span class="hljs-string"><span class="hljs-string">"James"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hi"</span></span>); } } Person.JOE.speak();</code> </pre> <br>  Ahora podemos usar una instancia de Persona donde se requiera un objeto Speaker.  Además, también podemos garantizar la implementación de métodos abstractos de interfaz de forma continua (los llamados métodos específicos de las constantes): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Speaker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Person implements Speaker { JOE(<span class="hljs-string"><span class="hljs-string">"Joseph"</span></span>) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hi, my name is Joseph"</span></span>); } }, JIM(<span class="hljs-string"><span class="hljs-string">"James"</span></span>){ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hey, what's up?"</span></span>); } }; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hi"</span></span>); } } Person.JOE.speak();</code> </pre> <br>  A diferencia de algunos de los otros secretos de este artículo, esta técnica solo debe usarse cuando sea necesario.  Por ejemplo, si se puede usar una constante enum, como JOE o JIM, en lugar de una interfaz como Speaker, entonces la definición de una constante debe implementar este tipo de interfaz.  Consulte el Párrafo 38 (p. 176-9) <a href="https://www.amazon.com/Effective-Java-3rd-Joshua-Bloch/dp/0134685997">Java efectivo, 3a edición</a> para obtener más información. <br><br><h3>  Conclusión </h3><br>  En este artículo, examinamos cinco secretos ocultos en Java, a saber: (1) las anotaciones se pueden extender, (2) los bloques de inicialización no estáticos se pueden usar para configurar un objeto cuando se crea, (3) la inicialización con corchetes dobles se puede usar para ejecutar instrucciones al crear una clase interna anónima, (4) los comentarios a veces se pueden ejecutar, y (5) las enumeraciones pueden implementar interfaces.  Aunque estas funciones son utilizadas por cierto tipo de tarea, algunas de ellas deben evitarse (por ejemplo, crear comentarios ejecutables).  Cuando decida usar estos secretos, asegúrese de observar la regla: "El hecho de que esto se pueda hacer no significa que deba hacerse". </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/480544/">https://habr.com/ru/post/480544/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../480530/index.html">IoT no es un juguete para niños. Cómo los ataques de hackers en Internet de las cosas asustan no solo a las grandes corporaciones, sino también a las familias comunes</a></li>
<li><a href="../480532/index.html">EDA desde un ángulo diferente</a></li>
<li><a href="../480534/index.html">16 consejos de desarrollo para Android en Kotlin. Parte 2</a></li>
<li><a href="../480540/index.html">Lanzamiento de Umbraco 8.4: CMS es aún más conveniente</a></li>
<li><a href="../480542/index.html">Conciencia de seguridad para adultos: cómo cerrar una vulnerabilidad de phishing</a></li>
<li><a href="../480550/index.html">Hola mundo de Bytecode para JVM</a></li>
<li><a href="../480552/index.html">Firefox lucha por el futuro de la web</a></li>
<li><a href="../480554/index.html">El futuro de la computación en la nube de Sun que nunca llegó</a></li>
<li><a href="../480556/index.html">NGINX: Verificación de la comunidad rusa de TI</a></li>
<li><a href="../480560/index.html">ICD parte robótica de las funciones en el departamento de operaciones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>