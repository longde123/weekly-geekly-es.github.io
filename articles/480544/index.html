<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç® üßîüèæ üßëüèø‚Äçü§ù‚Äçüßëüèæ 5 secretos ocultos en Java üï¥üèª ü§πüèæ üõ£Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Les presento la traducci√≥n del art√≠culo " 5 secretos ocultos en Java " de Justin Albano . 

 ¬øQuieres convertirte en un Jedi de Java? Descu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 secretos ocultos en Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480544/"> Hola Habr!  Les presento la traducci√≥n del art√≠culo " <a href="https://dzone.com/articles/5-hidden-secrets-in-java">5 secretos ocultos en Java</a> " de <a href="https://dzone.com/users/1144561/albanoj2.html">Justin Albano</a> . <br><br>  ¬øQuieres convertirte en un Jedi de Java?  Descubre los antiguos secretos de Java.  Nos centraremos en ampliar las anotaciones, la inicializaci√≥n, los comentarios y las interfaces de enumeraci√≥n. <br><br>  Con el desarrollo de lenguajes de programaci√≥n, las funciones ocultas tambi√©n comienzan a aparecer, y las construcciones en las que los fundadores nunca pensaron se est√°n extendiendo cada vez m√°s para uso general.  Algunas de estas funciones se aceptan generalmente en el idioma, mientras que otras se trasladan a los rincones m√°s oscuros de la comunidad ling√º√≠stica.  En este art√≠culo, veremos cinco secretos que a menudo pasan por alto muchos desarrolladores de Java (para ser justos, algunos de ellos tienen buenas razones para esto).  Consideraremos tanto las opciones para su uso como las razones que llevaron a la aparici√≥n de cada funci√≥n, as√≠ como algunos ejemplos que demuestran cu√°ndo es aconsejable usar estas funciones. <br><a name="habracut"></a><br>  El lector debe comprender que no todas estas funciones est√°n realmente ocultas, simplemente no se usan con frecuencia en la programaci√≥n diaria.  Algunos de ellos pueden ser muy √∫tiles en el momento adecuado, mientras que usar otros es casi siempre una mala idea, y se muestran en este art√≠culo para interesar al lector (y posiblemente hacer que se r√≠a).  El lector tambi√©n debe decidir cu√°ndo usar las funciones descritas en este art√≠culo: "El hecho de que esto se pueda hacer no significa que deba hacerse". <br><br><h3>  1. Implementar anotaciones </h3><br>  Comenzando con el Java Development Kit (JDK) 5, las anotaciones son una parte integral de muchas aplicaciones y entornos Java.  En la gran mayor√≠a de los casos, las anotaciones se aplican a construcciones como clases, campos, m√©todos, etc.  Sin embargo, tambi√©n se pueden usar como interfaces implementadas.  Por ejemplo, supongamos que tenemos la siguiente definici√≥n de anotaci√≥n: <br><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-meta"><span class="hljs-meta">@Target</span></span>(ElementType.METHOD) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Test { <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br>  Usualmente aplicamos esta anotaci√≥n a un m√©todo como se muestra a continuaci√≥n: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyTestFixure</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">givenFooWhenBarThenBaz</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre> <br>  Entonces podemos procesar esta anotaci√≥n como se describe en <a href="https://dzone.com/articles/creating-custom-annotations-in-java">Creaci√≥n de anotaciones en Java</a> .  Si tambi√©n quisi√©ramos crear una interfaz que nos permita crear pruebas como objetos, tendr√≠amos que crear una nueva interfaz, llam√°ndola de otra manera, y no Prueba: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestInstance</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br>  A continuaci√≥n, podemos crear una instancia del objeto TestInstance: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooTestInstance</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestInstance</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Foo"</span></span>; } } TestInstance myTest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FooTestInstance();</code> </pre> <br>  Aunque nuestra anotaci√≥n e interfaz son casi id√©nticas, con una duplicaci√≥n muy notable, parece que no hay forma de combinar estas dos construcciones.  Afortunadamente, las apariencias enga√±an, y hay un m√©todo para combinar estas dos construcciones: Implementaci√≥n de anotaciones: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Foo"</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Class&lt;? extends Annotation&gt; annotationType() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Test.class; } }</code> </pre> <br>  Tenga en cuenta que debemos implementar el m√©todo annotationType y tambi√©n devolver el tipo de anotaci√≥n, ya que esta es una parte impl√≠cita de la interfaz Annotation.  Aunque en la mayor√≠a de los casos la implementaci√≥n de anotaciones no es la soluci√≥n adecuada para el dise√±o (el compilador de Java mostrar√° una advertencia al implementar la interfaz), esto puede ser √∫til en algunos casos, por ejemplo, en el marco basado en anotaciones. <br><br><h3>  2. Bloques de inicializaci√≥n no est√°ticos. </h3><br>  En Java, como en la mayor√≠a de los lenguajes de programaci√≥n orientados a objetos, los objetos se crean exclusivamente utilizando el constructor (con algunas excepciones, como deserializar objetos Java).  Incluso cuando creamos m√©todos de f√°brica est√°ticos para crear objetos, simplemente encerramos una llamada en el constructor del objeto para instanciarlo.  Por ejemplo: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Foo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">withName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(name); } } Foo foo = Foo.withName(<span class="hljs-string"><span class="hljs-string">"Bar"</span></span>);</code> </pre> <br>  Por lo tanto, cuando queremos inicializar un objeto, combinamos la l√≥gica de inicializaci√≥n en el constructor del objeto.  Por ejemplo, establecemos el campo de nombre de la clase Foo en su constructor parametrizado.  Aunque puede parecer razonable suponer que toda la l√≥gica de inicializaci√≥n est√° en el constructor o conjunto de constructores para la clase, este no es el caso en Java.  En cambio, podemos usar <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/initial.html">bloques de inicializaci√≥n no est√°ticos</a> para ejecutar c√≥digo al crear un objeto: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:instance 1"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:constructor"</span></span>); } }</code> </pre> <br>  Los bloques de inicializaci√≥n no est√°ticos se especifican agregando l√≥gica de inicializaci√≥n a un conjunto de llaves en la definici√≥n de clase.  Cuando se crea un objeto, primero se llaman los bloques de inicializaci√≥n no est√°ticos y luego los constructores del objeto.  Tenga en cuenta que puede especificar m√°s de un bloque de inicializaci√≥n no est√°tico, en cuyo caso cada uno se llama en el orden en que se especifica en la definici√≥n de clase.  Adem√°s de los bloques de inicializaci√≥n no est√°ticos, tambi√©n podemos crear bloques est√°ticos que se ejecutan cuando la clase se carga en la memoria.  Para crear un bloque de inicializaci√≥n est√°tica, simplemente agregamos la palabra clave est√°tica: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:instance 1"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:static 1"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:constructor"</span></span>); } }</code> </pre> <br>  Cuando los tres m√©todos de inicializaci√≥n est√°n presentes en la clase (constructores, bloques de inicializaci√≥n no est√°ticos y bloques de inicializaci√≥n est√°tica), los est√°ticos siempre se ejecutan primero (cuando la clase se carga en la memoria) en el orden de su declaraci√≥n, luego los bloques de inicializaci√≥n no est√°ticos se ejecutan en el orden en que se declaran, y despu√©s de ellos, los dise√±adores.  Cuando se introduce una superclase, el orden de ejecuci√≥n cambia un poco: <br><br><ol><li>  Bloques de inicializaci√≥n de superclase est√°tica, en el orden de su declaraci√≥n </li><li>  Bloques de inicializaci√≥n de subclase est√°tica, en el orden de su declaraci√≥n </li><li>  Bloques de inicializaci√≥n de superclase no est√°ticos, en el orden en que se declaran </li><li>  Constructor de superclase </li><li>  Bloques de inicializaci√≥n de subclase no est√°ticos, en el orden en que se declaran </li><li>  Constructor de subclase </li></ol><br>  Por ejemplo, podemos crear la siguiente aplicaci√≥n: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:static 1"</span></span>); } { System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:instance 1"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:static 2"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:constructor"</span></span>); } { System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:instance 2"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:name-constructor"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:static 1"</span></span>); } { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:instance 1"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:static 2"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:constructor"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(name); System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:name-constructor"</span></span>); } { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:instance 2"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(); System.out.println(); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(<span class="hljs-string"><span class="hljs-string">"Baz"</span></span>); } }</code> </pre> <br>  Si ejecutamos este c√≥digo, obtenemos el siguiente resultado: <br><br><pre> <code class="java hljs">Bar:<span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> Bar:<span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> Foo:<span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> Foo:<span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> Bar:instance <span class="hljs-number"><span class="hljs-number">1</span></span> Bar:instance <span class="hljs-number"><span class="hljs-number">2</span></span> Bar:constructor Foo:instance <span class="hljs-number"><span class="hljs-number">1</span></span> Foo:instance <span class="hljs-number"><span class="hljs-number">2</span></span> Foo:constructor Bar:instance <span class="hljs-number"><span class="hljs-number">1</span></span> Bar:instance <span class="hljs-number"><span class="hljs-number">2</span></span> Bar:name-constructor Foo:instance <span class="hljs-number"><span class="hljs-number">1</span></span> Foo:instance <span class="hljs-number"><span class="hljs-number">2</span></span> Foo:name-constructor</code> </pre> <br>  Tenga en cuenta que los bloques de inicializaci√≥n est√°tica se ejecutaron solo una vez, incluso si se crearon dos objetos Foo.  Aunque los bloques de inicializaci√≥n no estad√≠sticos y est√°ticos pueden ser √∫tiles, la l√≥gica de inicializaci√≥n debe colocarse en los constructores, y los m√©todos (o m√©todos est√°ticos) deben usarse en casos donde la l√≥gica compleja requiere inicializar el estado del objeto. <br><br><h3>  3. Inicializaci√≥n de par√©ntesis doble </h3><br>  Muchos lenguajes de programaci√≥n incluyen alg√∫n tipo de mecanismo de sintaxis para crear r√°pida y brevemente una lista o mapa (o diccionario) sin usar un c√≥digo de plantilla detallado.  Por ejemplo, C ++ incluye la <a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization">inicializaci√≥n de par√©ntesis</a> , que permite a los desarrolladores crear r√°pidamente una lista de valores enumerados o incluso inicializar objetos completos si el constructor del objeto admite esta funci√≥n.  Desafortunadamente, antes de JDK 9, dicha funci√≥n no se implement√≥ (m√°s sobre eso m√°s adelante).  Para crear simplemente una lista de objetos, har√≠amos lo siguiente: <br><br><pre> <code class="java hljs">List&lt;Integer&gt; myInts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); myInts.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); myInts.add(<span class="hljs-number"><span class="hljs-number">2</span></span>); myInts.add(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  Aunque esto cumple nuestro objetivo de crear una nueva lista inicializada con tres valores, es demasiado detallada, lo que requiere que el desarrollador repita el nombre de la variable de lista para cada adici√≥n.  Para acortar este c√≥digo, podemos usar la <a href="https://stackoverflow.com/questions/1958636/what-is-double-brace-initialization-in-java">inicializaci√≥n doble de corchetes</a> : <br><br><pre> <code class="java hljs">List &lt; Integer &gt;List&lt;Integer&gt; myInts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;() {{ add(<span class="hljs-number"><span class="hljs-number">1</span></span>); add(<span class="hljs-number"><span class="hljs-number">2</span></span>); add(<span class="hljs-number"><span class="hljs-number">3</span></span>); }};</code> </pre> <br>  Una inicializaci√≥n de doble par√©ntesis, que deriva su nombre de un conjunto de dos llaves rizadas abiertas y cerradas, es en realidad una colecci√≥n de varios elementos de sintaxis.  Primero, creamos <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html">una clase interna an√≥nima</a> que extiende la clase ArrayList.  Como ArrayList no tiene m√©todos abstractos, podemos crear un cuerpo vac√≠o para una implementaci√≥n an√≥nima: <br><br><pre> <code class="java hljs">List&lt;Integer&gt; myInts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;() {};</code> </pre> <br>  Usando este c√≥digo, esencialmente creamos una subclase an√≥nima, ArrayList es exactamente la misma que la ArrayList original.  Una de las principales diferencias es que nuestra clase interna tiene una referencia impl√≠cita a la clase que lo contiene (en forma de una variable capturada por esto), porque  Creamos una clase interna no est√°tica.  Esto nos permite escribir una l√≥gica interesante, si no confusa.  Por ejemplo, al agregar esta variable a una clase interna an√≥nima inicializada con un par√©ntesis doble: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Foo&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getListWithMeIncluded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Foo&gt;() {{ add(Foo.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }}; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ Foo foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(); List&lt;Foo&gt; fooList = foo.getListWithMeIncluded(); System.out.println(foo.equals(fooList.get(<span class="hljs-number"><span class="hljs-number">0</span></span>))); } }</code> </pre> <br>  Si esta clase interna se definiera como est√°tica, no tendr√≠amos acceso a Foo.this.  Por ejemplo, el siguiente c√≥digo que crea una clase interna FooArrayList est√°tica no tiene acceso al enlace Foo.this y, por lo tanto, no se compila: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Foo&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getListWithMeIncluded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FooArrayList(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooArrayList</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArrayList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class">&gt; </span></span>{{ add(Foo.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }} }</code> </pre> <br>  Al reanudar la construcci√≥n con nuestra ArrayList inicializada con dos corchetes, una vez que se ha creado una clase interna no est√°tica, utilizamos bloques de inicializaci√≥n no est√°tica, como se describi√≥ anteriormente, para agregar los tres elementos iniciales al instanciar una clase interna an√≥nima.  Cuando se crea una clase interna an√≥nima y cuando solo hay un objeto de una clase interna an√≥nima, podemos decir que creamos un objeto interno no est√°tico que agrega tres elementos iniciales cuando se crea.  Esto se ver√° si separamos un par de llaves, donde una llave representa la definici√≥n de una clase interna an√≥nima y la otra marca el comienzo de la l√≥gica de inicializaci√≥n de la instancia: <br><br><pre> <code class="java hljs">List&lt;Integer&gt; myInts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;() { { add(<span class="hljs-number"><span class="hljs-number">1</span></span>); add(<span class="hljs-number"><span class="hljs-number">2</span></span>); add(<span class="hljs-number"><span class="hljs-number">3</span></span>); } };</code> </pre> <br>  Aunque este truco puede ser √∫til, JDK 9 ( <a href="http://openjdk.java.net/jeps/269">JEP 269</a> ) ha reemplazado la utilidad de este truco con un conjunto de m√©todos de f√°brica est√°ticos para List (as√≠ como muchos otros tipos de colecciones).  Por ejemplo, podr√≠amos crear una Lista anteriormente usando estos m√©todos de f√°brica est√°ticos, como se muestra a continuaci√≥n: <br><br><pre> <code class="java hljs">List&lt;Integer&gt; myInts = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  Esta t√©cnica de f√°brica est√°tica se usa por dos razones principales: (1) no se crea una clase interna an√≥nima y (2) para reducir el c√≥digo est√°ndar necesario para crear una Lista.  Debe recordarse que en este caso el resultado de la Lista no cambia y no se puede cambiar despu√©s de su creaci√≥n.  Para crear un archivo de Lista mutable con cualquier elemento inicial, tenemos que usar un m√©todo regular o un m√©todo con un par√©ntesis de inicializaci√≥n doble. <br><br>  Tenga en cuenta que la inicializaci√≥n simple, el par√©ntesis doble y los m√©todos de f√°brica est√°ticos JDK 9 no solo est√°n disponibles para List.  Est√°n disponibles para establecer y asignar objetos, como se muestra en el siguiente fragmento de c√≥digo: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   Map&lt;String, Integer&gt; myMap = new HashMap&lt;&gt;(); myMap.put("Foo", 10); myMap.put("Bar", 15); //     Map&lt;String, Integer&gt; myMap = new HashMap&lt;&gt;() {{ put("Foo", 10); put("Bar", 15); }}; //    Map&lt;String, Integer&gt; myMap = Map.of("Foo", 10, "Bar", 15);</span></span></code> </pre> <br>  Es importante comprender c√≥mo se inicializa el par√©ntesis doble antes de decidir sobre su uso.  Esto mejora la legibilidad del c√≥digo, pero pueden aparecer algunos efectos secundarios. <br><br><h3>  4. Comentarios ejecutables </h3><br>  Los comentarios son una parte integral de casi todos los programas, y la principal ventaja de los comentarios es que no se ejecutan.  Esto se vuelve a√∫n m√°s obvio cuando comentamos una l√≠nea de c√≥digo en nuestro programa: queremos guardar el c√≥digo en nuestra aplicaci√≥n, pero no queremos que se ejecute.  Por ejemplo, el siguiente programa muestra "5" como resultado: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// value = 8; System.out.println(value); }</span></span></code> </pre> <br>  Mucha gente piensa que los comentarios nunca se ejecutan, pero esto no es del todo cierto.  Por ejemplo, ¬øcu√°l ser√° el resultado del siguiente fragmento de c√≥digo? <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// \u000dvalue = 8; System.out.println(value); }</span></span></code> </pre> <br>  Podr√≠a suponer que esto es nuevamente 5, pero si ejecutamos el c√≥digo anterior, veremos 8 en la salida.  La raz√≥n de este "error" es el car√°cter Unicode \ u000d;  Este car√°cter es en realidad un <a href="https://www.compart.com/en/unicode/U%2B000D">retorno de carro Unicode</a> , y el compilador utiliza el c√≥digo fuente de Java como archivos de texto en formato Unicode.  Su adici√≥n al c√≥digo establece el valor = 8 en la l√≠nea que sigue al comentario, asegurando su ejecuci√≥n.  Esto significa que el fragmento de c√≥digo anterior es en realidad igual al siguiente: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// value = 8; System.out.println(value); }</span></span></code> </pre> <br>  Aunque esto parece un error de Java, en realidad es una caracter√≠stica especialmente agregada al lenguaje.  El objetivo inicial era crear un lenguaje independiente de la plataforma (de ah√≠ la creaci√≥n de una m√°quina virtual Java o JVM), y la interoperabilidad del c√≥digo fuente es un aspecto clave de este objetivo.  Al permitir que el c√≥digo fuente de Java contenga caracteres Unicode, podemos usar caracteres no latinos de manera universal.  Esto garantiza que el c√≥digo escrito en una regi√≥n del mundo (que puede contener caracteres no latinos, como en los comentarios), se pueda ejecutar en cualquier otra.  Consulte la <a href="https://docs.oracle.com/javase/specs/jls/se9/html/jls-3.html">Secci√≥n 3.3 Especificaciones del lenguaje Java o JLS</a> para obtener m√°s informaci√≥n. <br><br>  Podemos llevar esto al extremo e incluso escribir una aplicaci√≥n completa en Unicode.  Por ejemplo, ¬øqu√© hace el siguiente programa (c√≥digo fuente, derivado de <a href="https://programming.guide/java/executing-code-in-comments.html">Java: ¬øEjecuci√≥n de c√≥digo en comentarios?</a> ) <br><br><pre> <code class="java hljs">\u0070\u0075\u0062\u006c\u0069\u0063\u0020\u0020\u0020\u0020 \u0063\u006c\u0061\u0073\u0073\u0020\u0055\u0067\u006c\u0079 \u007b\u0070\u0075\u0062\u006c\u0069\u0063\u0020\u0020\u0020 \u0020\u0020\u0020\u0020\u0073\u0074\u0061\u0074\u0069\u0063 \u0076\u006f\u0069\u0064\u0020\u006d\u0061\u0069\u006e\u0028 \u0053\u0074\u0072\u0069\u006e\u0067\u005b\u005d\u0020\u0020 \u0020\u0020\u0020\u0020\u0061\u0072\u0067\u0073\u0029\u007b \u0053\u0079\u0073\u0074\u0065\u006d\u002e\u006f\u0075\u0074 \u002e\u0070\u0072\u0069\u006e\u0074\u006c\u006e\u0028\u0020 \u0022\u0048\u0065\u006c\u006c\u006f\u0020\u0077\u0022\u002b \u0022\u006f\u0072\u006c\u0064\u0022\u0029\u003b\u007d\u007d</code> </pre> <br>  Si coloca el c√≥digo anterior en un archivo llamado Ugly.java y lo ejecuta, Hello world se imprimir√° en la salida est√°ndar.  Si convertimos estos caracteres Unicode en caracteres del <a href="https://en.wikipedia.org/wiki/ASCII">C√≥digo Est√°ndar Americano para el Intercambio de Informaci√≥n (ASCII)</a> , obtenemos el siguiente programa: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ugly</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hello w"</span></span>+<span class="hljs-string"><span class="hljs-string">"orld"</span></span>); } }</code> </pre> <br>  Por lo tanto, los caracteres Unicode se pueden incluir en el c√≥digo fuente de Java, sin embargo, si no son necesarios, se recomienda encarecidamente no usarlos (por ejemplo, para incluir caracteres no latinos en los comentarios).  Sin embargo, si se requieren, aseg√∫rese de que no incluyan caracteres, como retornos de carro, que modifiquen el comportamiento esperado del c√≥digo fuente. <br><br><h3>  5. Implementaci√≥n de la interfaz Enum </h3><br>  Una de las limitaciones de las enumeraciones (una lista de enumeraci√≥n) en comparaci√≥n con otras clases en Java es que las enumeraciones no pueden extender otra clase o enumeraciones por s√≠ mismas.  Por ejemplo, no puede hacer lo siguiente: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Speaker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hi"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Person extends Speaker { JOE(<span class="hljs-string"><span class="hljs-string">"Joseph"</span></span>), JIM(<span class="hljs-string"><span class="hljs-string">"James"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } } Person.JOE.speak();</code> </pre> <br>  Sin embargo, podemos obligar a nuestras enumeraciones a implementar la interfaz y proporcionar una implementaci√≥n para sus m√©todos abstractos de la siguiente manera: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Speaker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Person implements Speaker { JOE(<span class="hljs-string"><span class="hljs-string">"Joseph"</span></span>), JIM(<span class="hljs-string"><span class="hljs-string">"James"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hi"</span></span>); } } Person.JOE.speak();</code> </pre> <br>  Ahora podemos usar una instancia de Persona donde se requiera un objeto Speaker.  Adem√°s, tambi√©n podemos garantizar la implementaci√≥n de m√©todos abstractos de interfaz de forma continua (los llamados m√©todos espec√≠ficos de las constantes): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Speaker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Person implements Speaker { JOE(<span class="hljs-string"><span class="hljs-string">"Joseph"</span></span>) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hi, my name is Joseph"</span></span>); } }, JIM(<span class="hljs-string"><span class="hljs-string">"James"</span></span>){ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hey, what's up?"</span></span>); } }; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hi"</span></span>); } } Person.JOE.speak();</code> </pre> <br>  A diferencia de algunos de los otros secretos de este art√≠culo, esta t√©cnica solo debe usarse cuando sea necesario.  Por ejemplo, si se puede usar una constante enum, como JOE o JIM, en lugar de una interfaz como Speaker, entonces la definici√≥n de una constante debe implementar este tipo de interfaz.  Consulte el P√°rrafo 38 (p. 176-9) <a href="https://www.amazon.com/Effective-Java-3rd-Joshua-Bloch/dp/0134685997">Java efectivo, 3a edici√≥n</a> para obtener m√°s informaci√≥n. <br><br><h3>  Conclusi√≥n </h3><br>  En este art√≠culo, examinamos cinco secretos ocultos en Java, a saber: (1) las anotaciones se pueden extender, (2) los bloques de inicializaci√≥n no est√°ticos se pueden usar para configurar un objeto cuando se crea, (3) la inicializaci√≥n con corchetes dobles se puede usar para ejecutar instrucciones al crear una clase interna an√≥nima, (4) los comentarios a veces se pueden ejecutar, y (5) las enumeraciones pueden implementar interfaces.  Aunque estas funciones son utilizadas por cierto tipo de tarea, algunas de ellas deben evitarse (por ejemplo, crear comentarios ejecutables).  Cuando decida usar estos secretos, aseg√∫rese de observar la regla: "El hecho de que esto se pueda hacer no significa que deba hacerse". </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/480544/">https://habr.com/ru/post/480544/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../480530/index.html">IoT no es un juguete para ni√±os. C√≥mo los ataques de hackers en Internet de las cosas asustan no solo a las grandes corporaciones, sino tambi√©n a las familias comunes</a></li>
<li><a href="../480532/index.html">EDA desde un √°ngulo diferente</a></li>
<li><a href="../480534/index.html">16 consejos de desarrollo para Android en Kotlin. Parte 2</a></li>
<li><a href="../480540/index.html">Lanzamiento de Umbraco 8.4: CMS es a√∫n m√°s conveniente</a></li>
<li><a href="../480542/index.html">Conciencia de seguridad para adultos: c√≥mo cerrar una vulnerabilidad de phishing</a></li>
<li><a href="../480550/index.html">Hola mundo de Bytecode para JVM</a></li>
<li><a href="../480552/index.html">Firefox lucha por el futuro de la web</a></li>
<li><a href="../480554/index.html">El futuro de la computaci√≥n en la nube de Sun que nunca lleg√≥</a></li>
<li><a href="../480556/index.html">NGINX: Verificaci√≥n de la comunidad rusa de TI</a></li>
<li><a href="../480560/index.html">ICD parte rob√≥tica de las funciones en el departamento de operaciones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>