<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🤝‍👨🏿 💵 👩🏻‍🤝‍👨🏾 Schnelles Compiler-Gerät. Teil 4 🖇️ 📜 🌎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist der letzte Teil meiner Überprüfung des Swift-Compilers. Ich werde Ihnen zeigen, wie Sie LLVM-IR aus AST generieren und was ein echtes Fronten...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schnelles Compiler-Gerät. Teil 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/e-Legion/blog/440078/"><img src="https://habrastorage.org/webt/aw/ag/tw/awagtwhs7e5-czijhggzhqpl3gq.png"><br><p>  Dies ist der letzte Teil meiner Überprüfung des Swift-Compilers.  Ich werde Ihnen zeigen, wie Sie LLVM-IR aus AST generieren und was ein echtes Frontend ist.  Wenn Sie die vorherigen Teile nicht gelesen haben, folgen Sie den Links: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Allgemeine Komponentenübersicht</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Analysieren der Quelldatei</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schnelle Zwischensprache</a> <a name="habracut"></a></li></ul><br><h1 id="llvm-ir-gen">  LLVM IR Gen. </h1><br><p>  Für das Frontend ist dies der letzte Schritt.  Der LLVM-IR-Generator wandelt das SIL in eine LLVM-Zwischendarstellung um.  Es wird zur weiteren Optimierung und Generierung von Maschinencode an das Backend übergeben. </p><br><h3 id="primer-realizacii">  Implementierungsbeispiel </h3><br><p>  Um eine Zwischenansicht zu generieren, müssen Sie mit der LLVM-Bibliothek interagieren.  Es ist in C ++ geschrieben, aber da Sie es nicht von Swift aus aufrufen können, müssen Sie die C-Schnittstelle verwenden.  Sie können sich jedoch nicht einfach an die C-Bibliothek wenden. </p><br><p>  Es muss in ein Modul eingeschlossen werden.  Mach es einfach.  Hier ist eine gute Anleitung.  Für LLVM ist ein solcher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wrapper</a> bereits gemeinfrei, sodass es einfacher ist, ihn zu verwenden. </p><br><p>  Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Swift-Wrapper</a> über die LLVM-C-Bibliothek wird auf demselben Konto veröffentlicht, wird jedoch in diesem Artikel nicht verwendet. </p><br><p>  Um eine Zwischenansicht zu generieren, wurde die entsprechende <b>LLVMIRGen-</b> Klasse erstellt.  Im Initialisierer wird der vom Parser erstellte AST verwendet: </p><br><pre><code class="plaintext hljs">import cllvm class LLVMIRGen { private let ast: ASTNode init(ast: ASTNode) { self.ast = ast }</code> </pre> <br><p>  Die <b>printTo (_, dump)</b> -Methode startet die Generierung und speichert sie in lesbarer Form in einer Datei.  Der Parameter <b>dump</b> wird verwendet, um optional dieselben Informationen an die Konsole auszugeben: </p><br><pre> <code class="plaintext hljs">func printTo(_ fileName: String, dump: Bool) {</code> </pre> <br><p>  Zuerst müssen Sie ein Modul erstellen.  Die Erstellung sowie die Erstellung anderer Entitäten werden in separate Methoden unterteilt und im Folgenden erörtert.  Da dies C ist, müssen Sie den Speicher manuell verwalten.  Verwenden Sie die Funktion <b>LLVMDisposeModule (),</b> um ein Modul aus dem Speicher zu entfernen: </p><br><pre> <code class="plaintext hljs">let module = generateModule() defer { LLVMDisposeModule(module) }</code> </pre> <br><p>  Die Namen aller LLVM-Funktionen und -Typen beginnen mit dem entsprechenden Präfix.  Beispielsweise ist ein Zeiger auf ein Modul vom Typ <b>LLVMModuleRef</b> und auf einen Builder vom <b>Typ LLVMBuilderRef</b> .  Der Builder ist eine Hilfsklasse (schließlich sind unter der unbequemen C-Schnittstelle gewöhnliche Klassen und Methoden verborgen), mit deren Hilfe IR generiert werden kann: </p><br><pre> <code class="plaintext hljs">let builder = generateBuilder() defer { LLVMDisposeBuilder(builder) }</code> </pre> <br><p>  Die Ausgabe der Nummer aus Klammern an die Konsole erfolgt mit der Standard- <strong>Puts-</strong> Funktion.  Um sie zu kontaktieren, müssen Sie es deklarieren.  Dies geschieht in der <b>generateExternalPutsFunction-</b> Methode.  Das Modul wird an es übergeben, da die Deklaration hinzugefügt werden muss.  Die <strong>Konstante putFunction</strong> speichert einen Zeiger auf eine Funktion, auf die zugegriffen werden kann: </p><br><pre> <code class="plaintext hljs">let putsFunction = generateExternalPutsFunction(module: module)</code> </pre> <br><p>  Der Swift-Compiler hat die Hauptfunktion in der SIL-Phase erstellt.  Da der Klammer-Compiler keine solche Zwischendarstellung hat, wird die Funktion sofort in LLVM IR generiert. </p><br><p>  Verwenden Sie dazu die <b>generateMainFunction-</b> Methode <b>(Builder, Modul, mainInternalGenerator)</b> .  Die Hauptfunktion wird nicht aufgerufen.  Daher müssen Sie keinen Zeiger darauf speichern: </p><br><pre> <code class="plaintext hljs">generateMainFunction(builder: builder, module: module) { // ... }</code> </pre> <br><p>  Der letzte Parameter der Methode ist der Abschluss, in dem der AST in den entsprechenden LLVM-IR konvertiert wird.  Zu diesem <b>Zweck</b> wurde eine separate Methode <b>handleAST (_, putFunction, builder) erstellt</b> : </p><br><pre> <code class="plaintext hljs">generateMainFunction(builder: builder, module: module) { handleAST(ast, putsFunction: putsFunction, builder: builder) }</code> </pre> <br><p>  Am Ende der Methode wird die resultierende Zwischendarstellung an die Konsole ausgegeben und in der Datei gespeichert: </p><br><pre> <code class="plaintext hljs">if dump { LLVMDumpModule(module) } LLVMPrintModuleToFile(module, fileName, nil)</code> </pre> <br><p>  Nun mehr zu den Methoden.  Das Modul wird durch Aufrufen der Funktion <b>LLVMModuleCreateWithName ()</b> mit dem gewünschten Namen generiert: </p><br><pre> <code class="plaintext hljs">private func generateModule() -&gt; LLVMModuleRef { let moduleName = "BraceCompiller" return LLVMModuleCreateWithName(moduleName) }</code> </pre> <br><p>  Der Builder wird noch einfacher erstellt.  Er braucht überhaupt keine Parameter: </p><br><pre> <code class="plaintext hljs">private func generateBuilder() -&gt; LLVMBuilderRef { return LLVMCreateBuilder() }</code> </pre> <br><p>  Um eine Funktion zu deklarieren, müssen Sie zuerst Speicher für ihren Parameter zuweisen und einen Zeiger auf Int8 darin speichern.  Rufen <b>Sie als</b> Nächstes <b>LLVMFunctionType ()</b> auf, um den Typ der Funktion zu erstellen, und übergeben Sie ihm den Typ des Rückgabewerts, ein Array von Argumenttypen (C-Array ist ein Zeiger auf die entsprechende Folge von Werten) und deren Nummer.  <b>LLVMAddFunction ()</b> fügt dem Modul die Funktion <b>put</b> hinzu und gibt einen Zeiger darauf zurück: </p><br><pre> <code class="plaintext hljs">private func generateExternalPutsFunction(module: LLVMModuleRef) -&gt; LLVMValueRef { var putParamTypes = UnsafeMutablePointer&lt;LLVMTypeRef?&gt;.allocate(capacity: 1) defer { putParamTypes.deallocate() } putParamTypes[0] = LLVMPointerType(LLVMInt8Type(), 0) let putFunctionType = LLVMFunctionType(LLVMInt32Type(), putParamTypes, 1, 0) return LLVMAddFunction(module, "puts", putFunctionType) }</code> </pre> <br><p>  <b>main</b> wird auf ähnliche Weise erstellt, aber ein Körper wird hinzugefügt.  Wie SIL besteht es aus Basisblöcken.  Rufen Sie dazu die Methode <b>LLVMAppendBasicBlock () auf</b> und übergeben Sie die Funktion und den Namen des Blocks. </p><br><p>  Jetzt kommt der Erbauer ins Spiel.  <b>Durch Aufrufen von LLVMPositionBuilderAtEnd () wird</b> an das Ende des noch leeren Blocks <b>verschoben</b> , und innerhalb des Abschlusses <b>mainInternalGenerator ()</b> wird der Funktionskörper hinzugefügt. </p><br><p>  Am Ende der Methode wird der konstante Wert 0 von <b>main zurückgegeben</b> . Dies ist die letzte Anweisung in dieser Funktion: </p><br><pre> <code class="plaintext hljs">private func generateMainFunction(builder: LLVMBuilderRef, module: LLVMModuleRef, mainInternalGenerator: () -&gt; Void) { let mainFunctionType = LLVMFunctionType(LLVMInt32Type(), nil, 0, 0) let mainFunction = LLVMAddFunction(module, "main", mainFunctionType) let mainEntryBlock = LLVMAppendBasicBlock(mainFunction, "entry") LLVMPositionBuilderAtEnd(builder, mainEntryBlock) mainInternalGenerator() let zero = LLVMConstInt(LLVMInt32Type(), 0, 0) LLVMBuildRet(builder, zero) }</code> </pre> <br><p>  Das Generieren von IR gemäß AST im Klammer-Compiler ist sehr einfach, da die einzige Aktion, die in dieser "Programmiersprache" ausgeführt werden kann, darin besteht, eine einzelne Nummer an die Konsole auszugeben.  Sie müssen den gesamten Baum rekursiv durchlaufen. Wenn Sie den <b>Nummernknoten gefunden haben</b> , fügen Sie der <b>Puts-</b> Funktion einen Aufruf hinzu.  Wenn dieser Knoten nicht vorhanden ist, enthält die <b>Hauptfunktion</b> nur eine Rückgabe mit dem Wert Null: </p><br><pre> <code class="plaintext hljs">private func handleAST(_ ast: ASTNode, putsFunction: LLVMValueRef, builder: LLVMBuilderRef) { switch ast { case let .brace(childNode): guard let childNode = childNode else { break } handleAST(childNode, putsFunction: putsFunction, builder: builder) case let .number(value): generatePrint(value: value, putsFunction: putsFunction, builder: builder) } }</code> </pre> <br><p>  Der <b>Puts-</b> Aufruf wird mit der Funktion <b>LLVMBuildCall () generiert</b> .  Es muss einen Builder, einen Zeiger auf eine Funktion, Argumente und deren Nummer übergeben.  <b>LLVMBuildGlobalStringPtr ()</b> erstellt eine globale Konstante für eine Zeichenfolge.  Sie wird das einzige Argument sein: </p><br><pre> <code class="plaintext hljs">private func generatePrint(value: Int, putsFunction: LLVMValueRef, builder: LLVMBuilderRef) { let putArgumentsSize = MemoryLayout&lt;LLVMValueRef?&gt;.size let putArguments = UnsafeMutablePointer&lt;LLVMValueRef?&gt;.allocate(capacity: 1) defer { putArguments.deallocate() } putArguments[0] = LLVMBuildGlobalStringPtr(builder, "\(value)", "print") _ = LLVMBuildCall(builder, putsFunction, putArguments, 1, "put") }</code> </pre> <br><p>  Um die LLVM-IR-Generierung zu starten, müssen Sie eine Instanz der <b>LLVMIRGen-</b> Klasse <b>erstellen</b> und die <b>printTo (_, dump)</b> -Methode aufrufen: </p><br><pre> <code class="plaintext hljs">let llvmIRGen = LLVMIRGen(ast: ast) llvmIRGen.printTo(outputFilePath, dump: false)</code> </pre> <br><p>  Da der Klammer-Compiler jetzt vollständig bereit ist, können Sie ihn über die Befehlszeile starten.  Dazu müssen Sie es sammeln ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anweisung</a> ) und den Befehl ausführen: </p><br><pre> <code class="plaintext hljs">build/debug/BraceCompiler Example/input.b Example/output.ll</code> </pre> <br><p>  Das Ergebnis ist diese Zwischendarstellung: </p><br><pre> <code class="plaintext hljs">; ModuleID = 'BraceCompiller' source_filename = "BraceCompiller" @print = private unnamed_addr constant [5 x i8] c"5678\00" declare i32 @puts(i8*) define i32 @main() { entry: %put = call i32 @puts(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @print, i32 0, i32 0)) ret i32 0 }</code> </pre> <br><h3 id="ispolzovanie-generatora-llvm-ir-swift">  Verwenden des LLVM IR Swift Generator </h3><br><p>  LLVM IR hat auch eine SSA-Form, ist jedoch auf niedriger Ebene und ähnelt eher einem Assembler.  Eine Beschreibung der Anleitung finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> . </p><br><p>  Globale Bezeichner beginnen mit <a href="">b&gt; @ &lt;/ b</a> , lokal mit <b>%</b> .  Im obigen Beispiel wird die Zeichenfolge <b>"5678 \ 00"</b> in der globalen Konstante <a href="">b&gt; @print &lt;/ b</a> gespeichert und dann zum Aufrufen der Funktion <a href="">b&gt; @puts &lt;/ b</a> mithilfe der <b>call-</b> Anweisung verwendet. </p><br><p>  Um etwas Interessantes in der vom Swift-Compiler generierten LLVM-IR zu sehen, müssen Sie den Code etwas komplizierter machen.  Fügen Sie beispielsweise einen Zusatz hinzu: </p><br><pre> <code class="plaintext hljs">let x = 16 let y = x + 7</code> </pre> <br><p>  Das <b>Flag -emit-ir</b> ist für die Erzeugung von LLVM-IR verantwortlich: </p><br><pre> <code class="plaintext hljs">swiftc -emit-ir main.swift</code> </pre> <br><p>  Das Ergebnis des Befehls: </p><br><pre> <code class="plaintext hljs">; ModuleID = '-' source_filename = "-" target datalayout = "em:o-i64:64-f80:128-n8:16:32:64-S128" target triple = "x86_64-apple-macosx10.14.0" %TSi = type &lt;{ i64 }&gt; @"$S4main1xSivp" = hidden global %TSi zeroinitializer, align 8 @"$S4main1ySivp" = hidden global %TSi zeroinitializer, align 8 @__swift_reflection_version = linkonce_odr hidden constant i16 3 @llvm.used = appending global [1 x i8*] [i8* bitcast (i16* @__swift_reflection_version to i8*)], section "llvm.metadata", align 8 define i32 @main(i32, i8**) #0 { entry: %2 = bitcast i8** %1 to i8* store i64 16, i64* getelementptr inbounds (%TSi, %TSi* @"$S4main1xSivp", i32 0, i32 0), align 8 %3 = load i64, i64* getelementptr inbounds (%TSi, %TSi* @"$S4main1xSivp", i32 0, i32 0), align 8 %4 = call { i64, i1 } @llvm.sadd.with.overflow.i64(i64 %3, i64 7) %5 = extractvalue { i64, i1 } %4, 0 %6 = extractvalue { i64, i1 } %4, 1 br i1 %6, label %8, label %7 ; &lt;label&gt;:7: ; preds = %entry store i64 %5, i64* getelementptr inbounds (%TSi, %TSi* @"$S4main1ySivp", i32 0, i32 0), align 8 ret i32 0 ; &lt;label&gt;:8: ; preds = %entry call void @llvm.trap() unreachable } ; Function Attrs: nounwind readnone speculatable declare { i64, i1 } @llvm.sadd.with.overflow.i64(i64, i64) #1 ; Function Attrs: noreturn nounwind declare void @llvm.trap() #2 attributes #0 = { "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" } attributes #1 = { nounwind readnone speculatable } attributes #2 = { noreturn nounwind } !llvm.module.flags = !{!0, !1, !2, !3, !4, !5, !6, !7} !llvm.linker.options = !{!8, !9, !10} !llvm.asan.globals = !{!11} !0 = !{i32 1, !"Objective-C Version", i32 2} !1 = !{i32 1, !"Objective-C Image Info Version", i32 0} !2 = !{i32 1, !"Objective-C Image Info Section", !"__DATA,__objc_imageinfo,regular,no_dead_strip"} !3 = !{i32 4, !"Objective-C Garbage Collection", i32 1536} !4 = !{i32 1, !"Objective-C Class Properties", i32 64} !5 = !{i32 1, !"wchar_size", i32 4} !6 = !{i32 7, !"PIC Level", i32 2} !7 = !{i32 1, !"Swift Version", i32 6} !8 = !{!"-lswiftSwiftOnoneSupport"} !9 = !{!"-lswiftCore"} !10 = !{!"-lobjc"} !11 = !{[1 x i8*]* @llvm.used, null, null, i1 false, i1 true}</code> </pre> <br><p>  Die Zwischendarstellung eines echten Compilers ist etwas komplizierter.  Es gibt zusätzliche Operationen, aber die erforderlichen Anweisungen sind nicht schwer zu finden.  Hier werden die globalen Konstanten <b>x</b> und <b>y</b> mit fehlerhaften Namen deklariert: </p><br><pre> <code class="plaintext hljs">@"$S4main1xSivp" = hidden global %TSi zeroinitializer, align 8 @"$S4main1ySivp" = hidden global %TSi zeroinitializer, align 8</code> </pre> <br><p>  Hier beginnt die Definition der Hauptfunktion: </p><br><pre> <code class="plaintext hljs">define i32 @main(i32, i8**) #0 {</code> </pre> <br><p>  Zunächst wird der Wert 16 in der Konstanten <b>x</b> gespeichert: </p><br><pre> <code class="plaintext hljs">store i64 16, i64* getelementptr inbounds (%TSi, %TSi* @"$S4main1xSivp", i32 0, i32 0), align 8</code> </pre> <br><p>  Dann wird es in Register 3 geladen und verwendet, um Addition zusammen mit Literal 7 aufzurufen: </p><br><pre> <code class="plaintext hljs">%3 = load i64, i64* getelementptr inbounds (%TSi, %TSi* @"$S4main1xSivp", i32 0, i32 0), align 8 %4 = call { i64, i1 } @llvm.sadd.with.overflow.i64(i64 %3, i64 7)</code> </pre> <br><p>  Durch Hinzufügen der Überlaufprüfung wird die Struktur zurückgegeben.  Der erste Wert ist das Ergebnis der Addition, und der zweite Wert ist ein Flag, das angibt, ob ein Überlauf aufgetreten ist. </p><br><p>  Die Struktur in LLVM ähnelt eher einem Tupel in Swift.  Es gibt keine Namen für die Felder, und Sie müssen den Wert mithilfe der <b>Anweisung extractvalue abrufen</b> .  Sein erster Parameter gibt die Feldtypen in der Struktur an, der zweite - die Struktur selbst und nach dem Komma - den Index des Feldes, dessen Wert herausgezogen werden muss: </p><br><pre> <code class="plaintext hljs">%5 = extractvalue { i64, i1 } %4, 0 %6 = extractvalue { i64, i1 } %4, 1</code> </pre> <br><p>  Jetzt wird das Überlaufzeichen im sechsten Register gespeichert.  Dieser Wert wird mit der Verzweigungsanweisung überprüft.  Wenn es einen Überlauf gab, erfolgt ein Übergang zum <b>label8-</b> Block, wenn nicht, zu <b>label7</b> : </p><br><pre> <code class="plaintext hljs">br i1 %6, label %8, label %7</code> </pre> <br><p>  Im ersten <b>Fall</b> wird die Programmausführung durch einen Aufruf von <b>trap ()</b> unterbrochen.  In der zweiten wird das Ergebnis der Addition in der Konstanten <b>y</b> gespeichert und 0 wird von der Hauptfunktion zurückgegeben: </p><br><pre> <code class="plaintext hljs">; &lt;label&gt;:7: ; preds = %entry store i64 %5, i64* getelementptr inbounds (%TSi, %TSi* @"$S4main1ySivp", i32 0, i32 0), align 8 ret i32 0 ; &lt;label&gt;:8: ; preds = %entry call void @llvm.trap() unreachable</code> </pre> <br><h3 id="generaciya-assemblernogo-koda">  Assembly-Code-Generierung </h3><br><p>  Der Swift-Compiler kann auch Assemblycode anzeigen.  <b>Übergeben Sie dazu das</b> Flag <b>-emit-Assembly</b> : </p><br><pre> <code class="plaintext hljs">swiftc -emit-assembly main.swift</code> </pre> <br><p>  Das Ergebnis des Befehls: </p><br><pre> <code class="plaintext hljs"> .section __TEXT,__text,regular,pure_instructions .build_version macos, 10, 14 .globl _main .p2align 4, 0x90 _main: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset %rbp, -16 movq %rsp, %rbp .cfi_def_cfa_register %rbp movq $16, _$S4main1xSivp(%rip) movq _$S4main1xSivp(%rip), %rax addq $7, %rax seto %cl movl %edi, -4(%rbp) movq %rsi, -16(%rbp) movq %rax, -24(%rbp) movb %cl, -25(%rbp) jo LBB0_2 xorl %eax, %eax movq -24(%rbp), %rcx movq %rcx, _$S4main1ySivp(%rip) popq %rbp retq LBB0_2: ud2 .cfi_endproc .private_extern _$S4main1xSivp .globl _$S4main1xSivp .zerofill __DATA,__common,_$S4main1xSivp,8,3 .private_extern _$S4main1ySivp .globl _$S4main1ySivp .zerofill __DATA,__common,_$S4main1ySivp,8,3 .private_extern ___swift_reflection_version .section __TEXT,__const .globl ___swift_reflection_version .weak_definition ___swift_reflection_version .p2align 1 ___swift_reflection_version: .short 3 .no_dead_strip ___swift_reflection_version .linker_option "-lswiftSwiftOnoneSupport" .linker_option "-lswiftCore" .linker_option "-lobjc" .section __DATA,__objc_imageinfo,regular,no_dead_strip L_OBJC_IMAGE_INFO: .long 0 .long 1600 .subsections_via_symbols</code> </pre> <br><p>  Nachdem Sie den oben beschriebenen Code der Zwischendarstellung verstanden haben, finden Sie die Assembler-Anweisungen, die er generiert.  Hier wird 16 in einer Konstanten gespeichert und in das <b>% rax-Register geladen</b> : </p><br><pre> <code class="plaintext hljs">movq $16, _$S4main1xSivp(%rip) movq _$S4main1xSivp(%rip), %rax</code> </pre> <br><p>  Hier ist Addition 7 und der Wert der Konstante.  Das Ergebnis der Addition wird in das <b>% rax-Register eingetragen</b> : </p><br><pre> <code class="plaintext hljs">addq $7, %rax</code> </pre> <br><p>  Und so sieht das Laden des Ergebnisses in die Konstante <b>y</b> aus: </p><br><pre> <code class="plaintext hljs">movq %rax, -24(%rbp) movq -24(%rbp), %rcx movq %rcx, _$S4main1ySivp(%rip)</code> </pre> <br><p>  Quellcode: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IR Gen.</a> </li></ul><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  Swift ist ein gut strukturierter Compiler, und es war nicht schwierig, seine allgemeine Architektur herauszufinden.  Ich war auch überrascht, dass Sie mit LLVM problemlos Ihre eigene Programmiersprache schreiben können.  Natürlich ist der Klammer-Compiler ziemlich primitiv, aber die Kaleidoskop-Implementierung ist auch wirklich real.  Ich empfehle, mindestens die ersten drei Kapitel des Tutorials zu lesen. </p><br><p>  Vielen Dank an alle, die gelesen haben.  Ich werde den Swift-Compiler weiter studieren und vielleicht darüber schreiben, was daraus geworden ist.  Welche Themen, die ihn betreffen, würden Sie interessieren? </p><br><h3 id="poleznye-ssylki">  Nützliche Links: </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Offizielle Swift-Website</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Offizielles Forum</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schnelle Entwicklung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Primäres Repository</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LLVM</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kaleidoskop-Tutorial</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klammer-Compiler</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440078/">https://habr.com/ru/post/de440078/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440066/index.html">VSCode-Erweiterungen zur Vereinfachung der JavaScript- und Vue-Entwicklung</a></li>
<li><a href="../de440070/index.html">Julia, Gradientenabstieg und Simplex-Methode</a></li>
<li><a href="../de440072/index.html">AresDB-Demo: Uber GPU-basiertes Open Source-Echtzeitanalysetool</a></li>
<li><a href="../de440074/index.html">Roskomos hält es für falsch, die Raptor-Motoren Ilona Mask und RD-180 zu vergleichen</a></li>
<li><a href="../de440076/index.html">Übersetzung und Interpretation von Werbung aus dem Englischen ins Russische</a></li>
<li><a href="../de440084/index.html">10 Milliarden Softwareexporte sind vernachlässigbar</a></li>
<li><a href="../de440086/index.html">MS-DOS Virus World</a></li>
<li><a href="../de440088/index.html">bobaflu - Programmierzubehör auf Flattern</a></li>
<li><a href="../de440090/index.html">Wie funktionieren technische Indikatoren an der Börse tatsächlich?</a></li>
<li><a href="../de440092/index.html">Eine mathematische Untersuchung darüber, wie gefälschte Gouverneurwahlen in Primorje am 16. September 2018 vorgetäuscht wurden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>