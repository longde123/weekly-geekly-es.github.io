<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎶 🕞 💷 Su propio convertidor JSON o un poco más sobre ExpressionTrees ☮️ 🚠 👼🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La serialización y la deserialización son operaciones típicas que el desarrollador moderno trata como triviales. Nos comunicamos con bases de datos, g...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Su propio convertidor JSON o un poco más sobre ExpressionTrees</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464525/"><img src="https://habrastorage.org/webt/ud/qn/kd/udqnkdpyauh-0k7h5d-g_hgzrys.png"><br><br>  La serialización y la deserialización son operaciones típicas que el desarrollador moderno trata como triviales.  Nos comunicamos con bases de datos, generamos solicitudes HTTP, recibimos datos a través de la API REST y, a menudo, ni siquiera pensamos en cómo funciona.  Hoy sugiero escribir mi serializador y deserializador para JSON para averiguar qué hay debajo del capó. <br><a name="habracut"></a><br><h2>  Descargo de responsabilidad </h2><br>  Como la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">última vez</a> , lo notaré: escribiremos un serializador primitivo, se podría decir, una bicicleta.  Si necesita una solución llave en mano, use <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Json.NET</a> .  Estos chicos lanzaron un producto maravilloso que es altamente personalizable, puede hacer mucho y <i>ya</i> está <i>resolviendo los problemas</i> que surgen al trabajar con JSON.  Usar tu propia solución es realmente genial, pero solo si necesitas el máximo rendimiento, una personalización especial o si te gustan las bicicletas como a mí me gustan. <br><br><h2>  Área temática </h2><br>  El servicio para convertir de JSON a una representación de objeto consta de al menos dos subsistemas.  Deserializer es un subsistema que convierte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JSON</a> (texto) válido en una representación de objeto dentro de nuestro programa.  La deserialización implica la tokenización, es decir, analizar JSON en elementos lógicos.  El serializador es un subsistema que realiza la tarea inversa: convierte la representación de datos de objetos en JSON. <br><br>  El consumidor suele ver la siguiente interfaz.  Lo simplifiqué deliberadamente para resaltar los principales métodos que se usan con mayor frecuencia. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IJsonConverter</span></span> { T Deserialize&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> json); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Serialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> source</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br>  "Bajo el capó", la deserialización incluye la tokenización (análisis de un texto JSON) y la construcción de algunas primitivas que facilitan la creación de una representación de objeto más adelante.  Para fines de capacitación, omitiremos la construcción de primitivas intermedias (por ejemplo, JObject, JProperty de Json.NET) e inmediatamente escribiremos datos en el objeto.  Esto es un inconveniente, ya que reduce las opciones de personalización, pero es imposible crear una biblioteca completa dentro del marco de un artículo. <br><br><h2>  Tokenización </h2><br>  Permítame recordarle que el proceso de tokenización o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">análisis léxico</a> es un análisis del texto con el objetivo de obtener una representación diferente y más estricta de los datos contenidos en él.  Típicamente, esta representación se llama <b>tokens</b> o tokens.  Para analizar JSON, debemos resaltar las propiedades, sus valores, los símbolos del principio y el final de las estructuras, es decir, los tokens que se pueden representar como JsonToken en el código. <br><br>  <a href="">JsonToken</a> es una estructura que contiene un valor (texto), así como un tipo de token.  JSON es una notación estricta, por lo que todos los tipos de tokens se pueden reducir a la <a href="">siguiente enumeración</a> .  Por supuesto, sería genial agregar al token sus coordenadas en los datos entrantes (fila y columna), pero la depuración está más allá del alcance de la implementación, lo que significa que JsonToken no contiene estos datos. <br><br>  Entonces, la forma más fácil de analizar el texto en tokens es leer cada carácter secuencialmente y compararlo con patrones.  Necesitamos entender qué significa este o aquel símbolo.  Es posible que la palabra clave (verdadero, falso, nulo) comience con este carácter, es posible que este sea el comienzo de la línea (carácter de comillas), y tal vez este carácter en sí sea un token ([,], {,}).  La idea general se ve así: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tokens = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;JsonToken&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; json.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch = json[i]; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ch) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'['</span></span>: tokens.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JsonToken(JsonTokenType.ArrayStart)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">']'</span></span>: tokens.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JsonToken(JsonTokenType.ArrayEnd)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'"'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> stringValue = ReadString(); tokens.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JsonToken(JsonTokenType.String, stringValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; ... } }</code> </pre><br>  Al mirar el código, parece que puede leer e inmediatamente hacer algo con los datos leídos.  No necesitan ser almacenados, deben ser enviados inmediatamente al consumidor.  Por lo tanto, un cierto IEnumerator pide, que analizará el texto en pedazos.  En primer lugar, esto reducirá la asignación, ya que no necesitamos almacenar resultados intermedios (una matriz de tokens).  En segundo lugar, aumentaremos la velocidad del trabajo: sí, en nuestro ejemplo, la entrada es una cadena, pero en una situación real, será <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">reemplazada por Stream</a> (de un archivo o una red), que leemos secuencialmente. <br><br>  He preparado el código <b>JsonTokenizer</b> , que se puede <a href="">encontrar aquí</a> .  La idea es la misma: el tokenizador va secuencialmente a lo largo de la línea, tratando de determinar a qué se refiere el símbolo o su secuencia.  Si logramos comprender, entonces creamos un token y transferimos el control al consumidor.  Si aún no está claro, sigue leyendo. <br><br><h2>  Preparándose para deserializar objetos </h2><br>  Muy a menudo, una solicitud para convertir datos de JSON es una llamada al método genérico Deserialize, donde <b>TOut</b> es el tipo de datos con el que se deben asignar los tokens JSON.  Donde <a href="">Tipo es</a> : es hora de aplicar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reflection</a> and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ExpressionTrees</a> .  Los conceptos básicos de trabajar con ExpressionTrees, así como por qué las expresiones compiladas son mejores que la reflexión "desnuda", describí en un artículo anterior sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cómo hacer su AutoMapper</a> .  Si no sabe nada sobre Expression.Labmda.Compile (), le recomiendo leerlo.  Me parece que el ejemplo del mapeador resultó bastante comprensible. <br><br>  Entonces, el plan para crear un deserializador de objetos se basa en el conocimiento de que podemos obtener tipos de propiedad del tipo TOut en cualquier momento, es decir, la colección <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PropertyInfo</a> .  Al mismo tiempo, los tipos de propiedad están limitados por la notación JSON: números, cadenas, matrices y objetos.  Incluso si no nos olvidamos de nulo, esto no es tanto como podría parecer a primera vista.  Y si para cada tipo primitivo nos veremos obligados a crear un deserializador separado, entonces para las matrices y los objetos podemos hacer clases genéricas.  Si piensa un poco, todos los serializadores-deserializadores (o <b>convertidores</b> ) se pueden reducir a la siguiente interfaz: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IJsonConverter</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deserialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">JsonTokenizer tokenizer</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Serialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, StringBuilder builder</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre><br>  El código de un convertidor de tipos primitivos fuertemente tipado es lo más simple posible: extraemos el JsonToken actual del tokenizador y lo convertimos en un valor mediante análisis.  Por ejemplo, float.Parse (currentToken.Value).  Eche un vistazo a <a href="">BoolConverter</a> o <a href="">FloatConverter</a> , nada complicado.  A continuación, si necesita un deserializador para bool?  o flotante ?, también se puede agregar. <br><br><h2>  Deserialización de matriz </h2><br>  <a href="">El código de clase genérico</a> para convertir una matriz de JSON también es relativamente simple.  Está parametrizado por el tipo de elemento que podemos extraer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Type.GetElementType ()</a> .  Determinar que un tipo es una matriz también es simple: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Type.IsArray</a> .  La deserialización de la matriz se reduce a decir tokenizer.MoveNext () hasta que se alcanza un token de tipo ArrayEnd.  La deserialización de los elementos de la matriz es la deserialización del tipo de elemento de la matriz, por lo tanto, al crear un ArrayConverter, se le pasa el deserializador del elemento. <br><br>  A veces hay dificultades con la creación de instancias de implementaciones genéricas, por lo que le diré de inmediato cómo hacerlo.  Reflection le permite crear tipos genéricos en tiempo real, lo que significa que podemos usar el tipo creado como argumento para Activator.CreateInstance.  Aprovecha esto: <br><br><pre> <code class="cs hljs">Type elementType = arrayType.GetElementType(); Type converterType = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(ArrayConverter&lt;&gt;).MakeGenericType(elementType); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> converterInstance = Activator.CreateInstance(converterType, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] args);</code> </pre><br>  Al finalizar los preparativos para crear un deserializador de objetos, puede colocar todo el código de infraestructura asociado con la creación y el almacenamiento de deserializadores en la fachada de <a href="">JConverter</a> .  Será responsable de todas las operaciones de serialización y deserialización de JSON y está disponible para los consumidores como un servicio. <br><br><h2>  Deserialización de objeto </h2><br>  Permítame recordarle que puede obtener todas las propiedades de tipo T de esta manera: typeof (T) .GetProperties ().  Para cada propiedad, puede extraer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PropertyInfo.PropertyType</a> , lo que nos dará la oportunidad de crear un IJsonConverter escrito para serializar y deserializar datos de un tipo en particular.  Si el tipo de propiedad es una matriz, crearemos una instancia de ArrayConverter o encontraremos una adecuada entre las existentes.  Si el tipo de propiedad es un tipo primitivo, entonces los deserializadores (convertidores) ya están creados para ellos en el constructor JConverter. <br><br>  El código resultante se puede ver en la clase genérica <a href="">ObjectConverter</a> .  Se crea un activador en su constructor, las propiedades se extraen de un diccionario especialmente preparado y para cada uno de ellos se crea un método de deserialización: Acción &lt;TObject, JsonTokenizer&gt;.  Es necesario, en primer lugar, para asociar inmediatamente el IJsonConverter con la propiedad deseada, y en segundo lugar, para evitar el boxeo al extraer y escribir tipos primitivos.  Cada método de deserialización sabe qué propiedad del objeto saliente se registrará, el deserializador del valor se escribe estrictamente y devuelve el valor exactamente en la forma en que se necesita. <br><br>  El enlace de un IJsonConverter a una propiedad es el siguiente: <br><br><pre> <code class="cs hljs">Type converterType = propertyValueConverter.GetType(); ConstantExpression Expression.Constant(propertyValueConverter, converterType); MethodInfo deserializeMethod = converterType.GetMethod(<span class="hljs-string"><span class="hljs-string">"Deserialize"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = Expression.Call(converter, deserializeMethod, tokenizer);</code> </pre><br>  La constante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Expression.Constant</a> se crea directamente en la expresión, que almacena una referencia a la instancia del deserializador para el valor de la propiedad.  Esta no es exactamente la constante que escribimos en "C # normal", ya que puede almacenar un tipo de referencia.  A continuación, el método Deserialize se recupera del tipo deserializador, que devuelve el valor del tipo deseado, y luego se llama - <a href="">Expression.Call</a> .  Por lo tanto, obtenemos un método que sabe exactamente dónde y qué escribir.  Queda por ponerlo en el diccionario y llamarlo cuando un token del tipo de propiedad con el nombre deseado "viene" del tokenizer.  Otra ventaja es que todo funciona muy rápido. <br><br><h2>  Que rapido </h2><br>  Las bicicletas, como se señaló al principio, tiene sentido escribir en varios casos: si esto es un intento de comprender cómo funciona la tecnología, o si necesita lograr algunos resultados especiales.  Por ejemplo, la velocidad.  Puede asegurarse de que el deserializador realmente se deserialice <a href="">con las pruebas preparadas</a> (uso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AutoFixture</a> para obtener datos de prueba).  Por cierto, probablemente notaste que también escribí la serialización de objetos.  Pero como el artículo resultó ser bastante extenso, no lo describiré, solo daré puntos de referencia.  Sí, al igual que con el artículo anterior, escribí puntos de referencia utilizando la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BenchmarkDotNet</a> . <br><br>  Por supuesto, comparé la velocidad de deserialización con Newtonsoft (Json.NET), como la solución más común y recomendada para trabajar con JSON.  Además, justo en su sitio web está escrito: 50% más rápido que DataContractJsonSerializer y 250% más rápido que JavaScriptSerializer.  En resumen, quería saber cuánto perdería mi código.  Los resultados me sorprendieron: tenga en cuenta que la asignación de datos es casi tres veces menor, y la tasa de deserialización es aproximadamente dos veces más rápida. <br><div class="scrollable-table"><table><thead><tr><th>  Método </th><th>  Media </th><th>  Error </th><th>  Stddev </th><th>  Ratio </th><th>  Asignado </th></tr></thead><tbody><tr><td>  Newtonsoft </td><td>  75,39 ms </td><td>  0,3027 ms </td><td>  0,2364 ms </td><td>  1.00 </td><td>  35,47 MB </td></tr><tr><td>  Velo </td><td>  31,78 ms </td><td>  0.1135 ms </td><td>  0,1062 ms </td><td>  0,42 </td><td>  12,36 MB </td></tr></tbody></table></div><br>  La comparación de la velocidad y la asignación <a href="">durante la serialización de datos</a> arrojó resultados aún más interesantes.  Resulta que el serializador de bicicletas asignó casi cinco veces menos y trabajó casi tres veces más rápido.  Si la velocidad realmente me molestara (realmente), sería un claro éxito. <br><div class="scrollable-table"><table><thead><tr><th>  Método </th><th>  Media </th><th>  Error </th><th>  Stddev </th><th>  Ratio </th><th>  Asignado </th></tr></thead><tbody><tr><td>  Newtonsoft </td><td>  54,83 ms </td><td>  0,5552 ms </td><td>  0,5222 ms </td><td>  1.00 </td><td>  25,44 MB </td></tr><tr><td>  Velo </td><td>  20,66 ms </td><td>  0,0484 ms </td><td>  0,0429 ms </td><td>  0,38 </td><td>  5.93 MB </td></tr></tbody></table></div><br>  Sí, al medir la velocidad, no utilicé los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">consejos para aumentar la productividad</a> publicados en el sitio web de Json.NET.  Tomé medidas fuera de la caja, es decir, de acuerdo con el escenario más utilizado: JsonConvert.DeserializeObject.  Puede haber otras formas de mejorar el rendimiento, pero no las conozco. <br><br><h2>  Conclusiones </h2><br>  A pesar de la velocidad relativamente alta de serialización y deserialización, no recomendaría abandonar Json.NET en favor de mi propia solución.  La ganancia en velocidad se calcula en milisegundos, y se "ahogan" fácilmente en retrasos de red, disco o código, que se encuentra jerárquicamente sobre el lugar donde se aplica la serialización.  Apoyar tales soluciones propietarias es un infierno, donde solo se pueden permitir desarrolladores que estén bien versados ​​en el tema. <br><br>  El alcance de tales bicicletas son aplicaciones que están completamente diseñadas con miras a un alto rendimiento, o proyectos favoritos donde entiendes cómo funciona esta o aquella tecnología.  Espero haberte ayudado un poco en todo esto. <br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/464525/">https://habr.com/ru/post/464525/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../464511/index.html">Cómo recopilar cohortes de usuarios en forma de gráficos en Grafana [+ imagen acoplable con un ejemplo]</a></li>
<li><a href="../464513/index.html">Duffle: transformador de XD Design</a></li>
<li><a href="../464515/index.html">Cómo hacer correos electrónicos y no desordenar: consejos prácticos</a></li>
<li><a href="../464517/index.html">Nuevas tarjetas CUBA</a></li>
<li><a href="../464523/index.html">Sistemas de pago (PSP) para negocios de TI: jugamos a lo grande</a></li>
<li><a href="../464529/index.html">Para publicidad contextual por los nombres de los competidores ahora se puede multar con 500,000 rublos</a></li>
<li><a href="../464535/index.html">Detalles sobre el dispositivo y las funciones del scooter eléctrico KickScooter T60</a></li>
<li><a href="../464537/index.html">Arduino DIY Demonic Carrousel</a></li>
<li><a href="../464539/index.html">Estudios clínicos. Cómo ingresar al grupo experimental, obtener tratamiento gratuito contra el cáncer y ayudar a la ciencia</a></li>
<li><a href="../464543/index.html">Qué es y qué no está en Go. Parte 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>