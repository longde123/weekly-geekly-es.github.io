<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>◽️ 🤙🏼 👪 在10分钟内创建一个用于文本识别的Android应用程序。 移动视觉CodeLab 👩 👩🏼 👧🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="教程的视频版本 
 
 

 光学字符识别 （ OCR ）使计算机能够读取图像中的文本，从而使应用程序能够理解符号，文章，传单，文本页面，菜单或任何文本形式的东西。 Mobile Vision Text API为Android开发人员提供了功能强大且可靠的OCR功能，该功能支持大多数Android设...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在10分钟内创建一个用于文本识别的Android应用程序。 移动视觉CodeLab</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412679/"><h2> 教程的视频版本 </h2><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/mIEfqtn9nts" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<p> <em>光学字符识别</em> （ <strong>OCR</strong> ）使计算机能够读取图像中的文本，从而使应用程序能够理解符号，文章，传单，文本页面，菜单或任何文本形式的东西。  <code>Mobile Vision Text API</code>为<code>Android</code>开发人员提供了功能强大且可靠的<code>OCR</code>功能，该功能支持大多数<code>Android</code>设备，并且不会增加应用程序的大小。 </p><br><p> 在本教程中，您将创建一个应用程序，在该应用程序中，将在视频录制过程中识别并播放掉落到框架中的所有文本。 <a name="habracut"></a></p><br><p> 我们还发布了有关其他Mobile Vision功能的文章： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">识别物体和人类的情感</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">人脸识别</a> ; </li></ul><br><p> 源代码可以在<a href="">这里</a>下载。 </p><br><p> 或从命令行克隆<code>GitHub</code>存储库： </p><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/googlesamples/android-vision.git</code> </pre> <br><p>  <code>visionSamples</code>存储库包含许多与<code>Mobile Vision</code>相关的示例项目。 本课仅使用两个： </p><br><ul><li> <strong><img src="https://habrastorage.org/getpro/habr/post_images/1e8/d51/ef8/1e8d51ef802bcde6a7d36bf83490b24d.png" width="22" height="22"></strong>  <strong>ocr-codelab / ocr-reader-start</strong>是本课程中将使用的初始代码。 </li><li> <strong><img src="https://habrastorage.org/getpro/habr/post_images/1e8/d51/ef8/1e8d51ef802bcde6a7d36bf83490b24d.png" width="22" height="22"></strong>  <strong>ocr-codelab / ocr-reader-complete-</strong>完成的应用程序的完整代码。 您可以使用它来进行故障排除或直接转到正在运行的应用程序。 </li></ul><br><h2>  Google Play服务更新 </h2><br><p> 您可能需要升级已安装的<code>Google Repository</code>版本才能使用<code>Mobile Vision Text API</code> 。 </p><br><p> 打开<code>Android Studio</code>并打开<code>SDK Manager</code> ： </p><br><img src="https://habrastorage.org/getpro/habr/post_images/c09/c24/18f/c09c2418f842d747bb135a7d868c4931.png" width="240" height="117"><br><p><br> 确保<code>Google Repository</code>最新的。 它必须至少是版本<code>26</code> 。 </p><br><img src="https://habrastorage.org/getpro/habr/post_images/55f/a3f/0ee/55fa3f0ee048bc97f5b14b9fff7734ea.png" width="750" height="502"><br><p></p><br><h2> 添加Google Play服务依赖项并创建要运行的应用程序 </h2><br><p> 现在您可以打开入门项目： </p><br><ol><li><p> 选择启动目录 <strong><img src="https://habrastorage.org/getpro/habr/post_images/1e8/d51/ef8/1e8d51ef802bcde6a7d36bf83490b24d.png" width="22" height="22"></strong> 下载的代码中的<code>ocr-reader</code> （ <strong>文件</strong> &gt; <strong>打开</strong> &gt; <code>ocr-codelab/ocr-reader-start</code> ）。 </p><br></li><li><p> 将<code>Google Play Services</code>依赖项添加到应用程序。 没有这种依赖性， <code>Text API</code>将不可用。 </p><br></li></ol><br><p> 该项目可能表明缺少<strong>整数/ google_play_services_version文件</strong>并给出了错误。 这是正常现象，我们将在下一步中进行修复。 </p><br><p> 在<code>app</code>模块中打开<code>build.gradle</code>文件，然后更改依赖关系块以在其中包含<code>play-services-vision</code>依赖关系。 一切准备就绪后，文件应如下所示： </p><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">dependencies</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">implementation</span></span> fileTree(dir: <span class="hljs-string"><span class="hljs-string">'libs'</span></span>, include: [<span class="hljs-string"><span class="hljs-string">'*.jar'</span></span>]) implementation <span class="hljs-string"><span class="hljs-string">'com.android.support:support-v4:26.1.0'</span></span> implementation <span class="hljs-string"><span class="hljs-string">'com.android.support:design:26.1.0'</span></span> implementation <span class="hljs-string"><span class="hljs-string">'com.google.android.gms:play-services-vision:15.0.0'</span></span> }</code> </pre> <br><ol><li><p> 请点击 <img src="https://habrastorage.org/getpro/habr/post_images/f7d/f74/7c5/f7df747c534410a9c0391d47de0bb0e3.png" width="21" height="21">  <code>Gradle</code>同步按钮。 </p><br></li><li><p> 请点击 <img src="https://habrastorage.org/getpro/habr/post_images/82f/7df/0d1/82f7df0d1dce3d570e7c35d7d8fb4575.png" width="22" height="23"> 开始按钮。 </p><br></li></ol><br><p> 几秒钟后，您将看到“读取文本”屏幕，但这只是一个黑屏。 </p><br><img src="https://habrastorage.org/getpro/habr/post_images/c41/e98/6dc/c41e986dc883fb67fe0caf0760e99378.png" width="349" height="621"><br><p><br> 由于未配置<code>CameraSource</code>没有任何反应。 来吧 </p><br><p> 如果不成功，您可以打开一个项目 <strong><img src="https://habrastorage.org/getpro/habr/post_images/1e8/d51/ef8/1e8d51ef802bcde6a7d36bf83490b24d.png" width="22" height="22"></strong>  <code>ocr-reader-complete</code>并确保其正常运行。 该项目是课程的现成版本，如果该版本不起作用，则应检查设备和<code>Android Studio</code>设置是否一切正常。 </p><br><h2> 配置TextRecognizer和CameraSource </h2><br><p> 首先，我们将创建<code>TextRecognizer</code> 。 该检测器对象处理图像并确定其中显示哪些文本。 初始化后， <code>TextRecognizer</code>可用于检测所有类型的图像中的文本。 找到<code>createCameraSource</code>方法并创建一个<code>TextRecognizer</code> ： </p><br><p>  <em>OcrCaptureActivity.java</em> </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createCameraSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> autoFocus, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> useFlash)</span></span></span><span class="hljs-function"> </span></span>{ Context context = getApplicationContext(); <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Create the TextRecognizer TextRecognizer textRecognizer = new TextRecognizer.Builder(context).build(); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Set the TextRecognizer's Processor. // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Check if the TextRecognizer is operational. // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Create the mCameraSource using the TextRecognizer. }</span></span></code> </pre> <br><p> 现在<code>TextRecognizer</code>准备就绪。 但是，它可能还无法正常工作。 如果设备的内存不足或<code>Google Play Services</code>无法加载<code>OCR</code>依赖项，则<code>TextRecognizer</code>对象将无法工作。 在开始将其用于文本识别之前，我们必须验证它已准备就绪。 初始化<code>TextRecognizer</code>之后，我们将把此检查添加到<code>createCameraSource</code> ： </p><br><p>  <em>OcrCaptureActivity.java</em> </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Check if the TextRecognizer is operational. if (!textRecognizer.isOperational()) { Log.w(TAG, "Detector dependencies are not yet available."); // Check for low storage. If there is low storage, the native library will not be // downloaded, so detection will not become operational. IntentFilter lowstorageFilter = new IntentFilter(Intent.ACTION_DEVICE_STORAGE_LOW); boolean hasLowStorage = registerReceiver(null, lowstorageFilter) != null; if (hasLowStorage) { Toast.makeText(this, R.string.low_storage_error, Toast.LENGTH_LONG).show(); Log.w(TAG, getString(R.string.low_storage_error)); } }</span></span></code> </pre> <br><p> 现在，我们已经验证了<code>TextRecognizer</code>准备就绪，可以使用它来识别单个帧。 但是我们想做一些更有趣的事情：以视频模式阅读文本。 为此，我们将创建一个预先配置为控制摄像机的<code>CameraSource</code> 。 我们需要为拍摄设置高分辨率，并启用自动对焦以应对识别小文本的任务。 如果您确定用户会看到大块的文本（例如符号），则可以使用较低的分辨率，然后帧处理会更快： </p><br><p>  <em>OcrCaptureActivity.java</em> </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Create the cameraSource using the TextRecognizer. cameraSource = new CameraSource.Builder(getApplicationContext(), textRecognizer) .setFacing(CameraSource.CAMERA_FACING_BACK) .setRequestedPreviewSize(1280, 1024) .setRequestedFps(15.0f) .setFlashMode(useFlash ? Camera.Parameters.FLASH_MODE_TORCH : null) .setFocusMode(autoFocus ? Camera.Parameters.FOCUS_MODE_CONTINUOUS_VIDEO : null) .build();</span></span></code> </pre> <br><p> 完成后，这是<code>createCameraSource</code>方法的外观： </p><br><p>  <em>OcrCaptureActivity.java</em> </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createCameraSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> autoFocus, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> useFlash)</span></span></span><span class="hljs-function"> </span></span>{ Context context = getApplicationContext(); <span class="hljs-comment"><span class="hljs-comment">// Create the TextRecognizer TextRecognizer textRecognizer = new TextRecognizer.Builder(context).build(); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Set the TextRecognizer's Processor. // Check if the TextRecognizer is operational. if (!textRecognizer.isOperational()) { Log.w(TAG, "Detector dependencies are not yet available."); // Check for low storage. If there is low storage, the native library will not be // downloaded, so detection will not become operational. IntentFilter lowstorageFilter = new IntentFilter(Intent.ACTION_DEVICE_STORAGE_LOW); boolean hasLowStorage = registerReceiver(null, lowstorageFilter) != null; if (hasLowStorage) { Toast.makeText(this, R.string.low_storage_error, Toast.LENGTH_LONG).show(); Log.w(TAG, getString(R.string.low_storage_error)); } } // Create the cameraSource using the TextRecognizer. cameraSource = new CameraSource.Builder(getApplicationContext(), textRecognizer) .setFacing(CameraSource.CAMERA_FACING_BACK) .setRequestedPreviewSize(1280, 1024) .setRequestedFps(15.0f) .setFlashMode(useFlash ? Camera.Parameters.FLASH_MODE_TORCH : null) .setFocusMode(autoFocus ? Camera.Parameters.FOCUS_MODE_CONTINUOUS_VIDEO : null) .build(); }</span></span></code> </pre> <br><p> 如果您运行该应用程序，您将看到视频已经开始！ 但是要处理来自摄像机的图像，我们需要将最后一个<code>TODO</code>添加到<code>createCameraSource</code> ：创建一个<code>Processor</code>来处理文本到达时的内容。 </p><br><h2> 创建OcrDetectorProcessor </h2><br><p> 您的应用程序现在可以使用<code>TextRecognizer</code>的发现方法来检测单个框架上的文本。 因此，您可以在例如照片中找到文本。 但是，为了在视频拍摄期间直接读取文本，您需要实现一个<code>Processor</code> ，该<code>Processor</code>将在屏幕上显示文本后立即对其进行处理。 </p><br><p> 转到<code>OcrDetectorProcessor</code>类<code>OcrDetectorProcessor</code>实现<code>Detector.Processor</code>接口： </p><br><p>  <em>OcrDetectorProcessor.java</em> </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OcrDetectorProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Detector</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Processor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TextBlock</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GraphicOverlay&lt;OcrGraphic&gt; graphicOverlay; OcrDetectorProcessor(GraphicOverlay&lt;OcrGraphic&gt; ocrGraphicOverlay) { graphicOverlay = ocrGraphicOverlay; } }</code> </pre> <br><p> 要实现此接口，您需要重写两个方法。 第一个方法<code>receiveDetections</code>在检测到它们时从<code>TextRecognizer</code>接收<code>TextBlocks</code> 。 第二个<code>release</code> ，用于在销毁<code>TextRecognizer</code>时释放资源。 在这种情况下，我们只需要清除图形画布，这将导致删除所有<code>OcrGraphic</code>对象。 </p><br><p> 我们将获取<code>TextBlocks</code>并为处理器检测到的每个文本块创建<code>OcrGraphic</code>对象。 我们将在下一步中实现其绘制的逻辑。 </p><br><p>  <em>OcrDetectorProcessor.java</em> </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receiveDetections</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Detector.Detections&lt;TextBlock&gt; detections)</span></span></span><span class="hljs-function"> </span></span>{ graphicOverlay.clear(); SparseArray&lt;TextBlock&gt; items = detections.getDetectedItems(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; items.size(); ++i) { TextBlock item = items.valueAt(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; item.getValue() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { Log.d(<span class="hljs-string"><span class="hljs-string">"Processor"</span></span>, <span class="hljs-string"><span class="hljs-string">"Text detected! "</span></span> + item.getValue()); OcrGraphic graphic = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OcrGraphic(graphicOverlay, item); graphicOverlay.add(graphic); } } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">release</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ graphicOverlay.clear(); }</code> </pre> <br><p> 现在处理器已经准备就绪，我们需要配置<code>textRecognizer</code>以使用它。 返回到<code>OcrCaptureActivity</code>中的<code>createCameraSource</code>方法中最后剩余的<code>TODO</code> ： </p><br><p>  <em>OcrCaptureActivity.java</em> </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Create the TextRecognizer TextRecognizer textRecognizer = new TextRecognizer.Builder(context).build(); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Set the TextRecognizer's Processor. textRecognizer.setProcessor(new OcrDetectorProcessor(graphicOverlay));</span></span></code> </pre> <br><p> 现在运行该应用程序。 此时，将相机悬停在文本上方时，您将看到调试消息“检测到文本！” 在<code>Android Monitor Logcat</code> ！ 但这不是一种直观的方法来可视化<code>TextRecognizer</code>看到的内容，对吗？ </p><br><p> 在下一步中，我们将在屏幕上绘制此文本。 </p><br><h2> 在屏幕上绘制文字 </h2><br><p> 让我们在<code>OcrGraphic</code>实现<code>draw</code>方法。 我们需要了解图像中是否有文本，将其边界的坐标转换为画布框架，然后绘制边界和文本。 </p><br><p>  <em>OcrGraphic.java</em> </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Canvas canvas)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Draw the text onto the canvas. if (text == null) { return; } // Draws the bounding box around the TextBlock. RectF rect = new RectF(text.getBoundingBox()); rect = translateRect(rect); canvas.drawRect(rect, rectPaint); // Render the text at the bottom of the box. canvas.drawText(text.getValue(), rect.left, rect.bottom, textPaint); }</span></span></code> </pre> <br><p> 启动应用程序并在以下示例文本上对其进行测试： </p><br><img src="https://habrastorage.org/getpro/habr/post_images/9f9/62d/41d/9f962d41d7ee963958a8bbc2f88b97ec.png" width="663" height="169"><br><p> 您应该看到屏幕上出现一个带有文本的框架！ 您可以使用<code>TEXT_COLOR</code>来处理文本的颜色。 </p><br><p> 这样呢 </p><br><img src="https://habrastorage.org/getpro/habr/post_images/8f2/09a/d7c/8f209ad7cd7ae77245abaa3250ea91d2.png" width="621" height="441"><br><p> 文本周围的框架看起来正确，但是文本在其底部。 </p><br><img src="https://habrastorage.org/getpro/habr/post_images/8dc/0ef/ec1/8dc0efec1d11dadff02a2ca7aa83d752.png" width="351" height="622"><br><p><br> 这是因为即使看到的句子分为几行，引擎也会将其在<code>TextBlock</code>识别的所有文本作为单个句子传输。 如果您需要获得全部报价，那么这非常方便。 但是，如果您想知道每一行文本在哪里，该怎么办？ </p><br><p> 您可以通过调用<code>getComponents</code>从<code>TextBlock</code>获得<code>Lines</code> ，然后对每一行进行排序，从而轻松获得其位置和其中的文本。 这使您可以在实际显示的位置绘制文本。 </p><br><p>  <em>OcrGraphic.java</em> </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Canvas canvas)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Draw the text onto the canvas. if (text == null) { return; } // Draws the bounding box around the TextBlock. RectF rect = new RectF(text.getBoundingBox()); rect = translateRect(rect); canvas.drawRect(rect, rectPaint); // Break the text into multiple lines and draw each one according to its own bounding box. List&lt;? extends Text&gt; textComponents = text.getComponents(); for(Text currentText : textComponents) { float left = translateX(currentText.getBoundingBox().left); float bottom = translateY(currentText.getBoundingBox().bottom); canvas.drawText(currentText.getValue(), left, bottom, textPaint); } }</span></span></code> </pre> <br><p> 重试此文本： </p><br><img src="https://habrastorage.org/getpro/habr/post_images/8f2/09a/d7c/8f209ad7cd7ae77245abaa3250ea91d2.png" width="655" height="465"><br><p> 太好了！ 您甚至可以根据需要将找到的文本分解成更小的部分。 您可以在每一行上调用<code>getComponents</code>并获取<code>Elements</code> （拉丁词）。 可以配置<code>textSize</code> ，使文本占用屏幕上实际文本的空间。 </p><br><img src="https://habrastorage.org/getpro/habr/post_images/102/3e0/2d2/1023e02d2d8659ec0a4d51662241037e.png" width="349" height="620"><br><p></p><br><h2> 单击时播放文本 </h2><br><p> 现在，来自摄像机的文本将转换为结构化的行，并将这些行显示在屏幕上。 让我们对他们做些其他的事情。 </p><br><p> 使用<code>Android</code>内置的<code>TextToSpeech API</code>和<code>OcrGraphic</code>的<code>contains</code>方法，当您单击文本时，我们可以教应用程序大声说出来。 </p><br><p> 首先，让我们在<code>OcrGraphic</code>实现<code>contains</code>方法。 我们只需要检查<code>x</code>和<code>y</code>坐标是否在显示的文本范围内。 <br>  <em>OcrGraphic.java</em> </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Check if this graphic's text contains this point. if (text == null) { return false; } RectF rect = new RectF(text.getBoundingBox()); rect = translateRect(rect); return rect.contans(x, y); }</span></span></code> </pre> <br><p> 您可能会注意到<code>Draw</code>方法有很多共同点！ 在这个项目中，您应该能够重用代码，但是在这里，我们将所有内容保留为例。 </p><br><p> 现在，让我们转到<code>OcrCaptureActivity</code>的<code>onTap</code>方法，并处理对文本的单击（如果该位置有一个单击）。 </p><br><p>  <em>OcrCaptureActivity.java</em> </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onTap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rawX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rawY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Speak the text when the user taps on screen. OcrGraphic graphic = graphicOverlay.getGraphicAtLocation(rawX, rawY); TextBlock text = null; if (graphic != null) { text = graphic.getTextBlock(); if (text != null &amp;&amp; text.getValue() != null) { Log.d(TAG, "text data is being spoken! " + text.getValue()); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Speak the string. } else { Log.d(TAG, "text data is null"); } } else { Log.d(TAG,"no text detected"); } return text != null; }</span></span></code> </pre> <br><p> 您可以运行该应用程序，并确保实际上通过<code>Android Monitor Logcat</code>处理了单击文本的<code>Android Monitor Logcat</code> 。 </p><br><p> 让我们来谈谈应用程序吧！ 转到“ <code>Activity</code>的开头并找到<code>onCreate</code>方法。 启动应用程序时，我们必须初始化<code>TextToSpeech</code>引擎以备将来使用。 </p><br><p>  <em>OcrCaptureActivity.java</em> </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle bundle)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// (Portions of this method omitted) // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Set up the Text To Speech engine. TextToSpeech.OnInitListener listener = new TextToSpeech.OnInitListener() { @Override public void onInit(final int status) { if (status == TextToSpeech.SUCCESS) { Log.d("TTS", "Text to speech engine started successfully."); tts.setLanguage(Locale.US); } else { Log.d("TTS", "Error starting the text to speech engine."); } } }; tts = new TextToSpeech(this.getApplicationContext(), listener); }</span></span></code> </pre> <br><p> 尽管事实上我们正确地初始化了<code>TextToSpeech</code> ，但仍然需要处理一般错误，例如，当您第一次单击文本时引擎仍未就绪时。 </p><br><p>  <code>TextToSpeech</code>也取决于语言。 您可以根据识别的文本的语言来更改语言。 语言识别没有内置在<code>Mobile Vision Text API</code> ，但是可以通过<code>Google Translate API</code> 。 作为用于文本识别的语言，您可以使用用户设备的语言。 </p><br><p> 很好，剩下的就是在<code>onTap</code>方法中添加文本播放代码。 </p><br><p>  <em>OcrCaptureActivity.java</em> </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onTap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rawX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rawY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Speak the text when the user taps on screen. OcrGraphic graphic = graphicOverlay.getGraphicAtLocation(rawX, rawY); TextBlock text = null; if (graphic != null) { text = graphic.getTextBlock(); if (text != null &amp;&amp; text.getValue() != null) { Log.d(TAG, "text data is being spoken! " + text.getValue()); // Speak the string. tts.speak(text.getValue(), TextToSpeech.QUEUE_ADD, null, "DEFAULT"); } else { Log.d(TAG, "text data is null"); } } else { Log.d(TAG,"no text detected"); } return text != null; }</span></span></code> </pre> <br><p> 现在，当您启动应用程序并单击检测到的文本时，设备将播放它。 试试看！ </p><br><h2> 完成时间 </h2><br><p> 现在您有了一个应用程序，可以识别相机中的文字并大声朗读！ </p><br><p> 您可以将获得的文本识别知识应用到其他应用程序中。 例如，从名片中读取地址和电话号码，从各种文档的照片中搜索文本。 简而言之，请在可能需要识别图像中文本的任何地方使用<code>OCR</code> 。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来源</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN412679/">https://habr.com/ru/post/zh-CN412679/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN412667/index.html">Cyber​​group Turla在灭蚊运动中使用Metasploit</a></li>
<li><a href="../zh-CN412669/index.html">时间管理并不可怕：如何做得更多</a></li>
<li><a href="../zh-CN412671/index.html">BLE控制台：与BLE设备交互的全新方法</a></li>
<li><a href="../zh-CN412675/index.html">比特币和以太坊中的Multisig合约和地址</a></li>
<li><a href="../zh-CN412677/index.html">追溯矩阵</a></li>
<li><a href="../zh-CN412681/index.html">十进制算术的二进制计算</a></li>
<li><a href="../zh-CN412683/index.html">在哪里以及如何学习机器学习？</a></li>
<li><a href="../zh-CN412685/index.html">Unity GPU路径跟踪-第2部分</a></li>
<li><a href="../zh-CN412687/index.html">实施IdM。 程序和技术手段-从基础到IdM</a></li>
<li><a href="../zh-CN412689/index.html">预测性IT分析简化了分布式应用程序监视</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>