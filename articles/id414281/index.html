<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👡 🔡 🏏 Pengembangan speedometer sepeda berdasarkan tampilan dari Nokia 3310 👨🏾‍🎨 🚻 🥝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baru-baru ini, apa yang disebut speedometer sepeda digital (komputer siklus) telah menyebar luas di antara aksesoris sepeda. Perangkat ini mampu mengu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengembangan speedometer sepeda berdasarkan tampilan dari Nokia 3310</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414281/">  Baru-baru ini, apa yang disebut speedometer sepeda digital (komputer siklus) telah menyebar luas di antara aksesoris sepeda.  Perangkat ini mampu mengukur banyak parameter, yang utamanya adalah kecepatan dan jarak.  Prinsip pengukuran kecepatan didasarkan pada perhitungan periode revolusi roda, dan jarak dihitung berdasarkan pengukuran jumlah putaran tersebut.  Seringkali sensor putaran roda adalah saklar buluh dalam hubungannya dengan magnet pada roda berbicara.  Tergantung pada fungsinya, harga perangkat tersebut sangat bervariasi.  Speedometer sepeda termurah dapat dibeli sekitar 500 p. <br><br>  Saya selalu memiliki keinginan untuk memiliki perangkat serupa.  Pada saat yang sama, saya merumuskan sejumlah persyaratan saya sendiri, yang harus dipenuhi.  Pertama-tama, saya benar-benar ingin melihat grafik perubahan kecepatan tergantung pada jarak atau waktu yang terakumulasi dalam periode singkat saat bergerak.  Dan juga, untuk merekam pengukuran (log) pada perangkat penyimpanan untuk transfer data statistik lebih lanjut ke komputer, tampilan mereka lebih rinci.  Model murah tidak sepenuhnya memenuhi persyaratan saya, tetapi saya tidak ingin membayar lebih untuk model mahal. <br><a name="habracut"></a><br>  Berdasarkan hal tersebut di atas, saya memutuskan untuk membuat speedometer sepeda sendiri berdasarkan mikrokontroler ATmega8.  Ada banyak pertanyaan, khususnya tentang periferal yang digunakan.  Saya tidak sengaja menemukan artikel tentang menggunakan layar dari ponsel Nokia 3310 yang dulu populer. Setelah membaca datasheet dan memastikan bahwa itu mudah dioperasikan, saya tidak ragu bahwa speedometer akan dibuat di badan ponsel yang disebutkan sebelumnya dengan layarnya sendiri.  Kasingnya cukup bagus, dan perangkat itu sendiri tidak sulit ditemukan. <br><br><img src="https://habrastorage.org/webt/co/vu/d2/covud2fzqkaw8fiojo2mes8xfl4.png"><br><br>  Sebagai ROM untuk merekam statistik pengukuran, saya memutuskan untuk meletakkan ROM 24XX512 klasik (512 Kbps), yang dikendalikan melalui antarmuka I2C.  Saya tidak peduli dengan penggunaan kartu memori SD / MMC.  Fungsi penting lainnya dalam perangkat adalah arloji.  Mereka berfungsi untuk mengikat beberapa parameter spesifik terukur (misalnya, kecepatan maksimum) ke tanggal dan waktu, dan juga diperlukan untuk merekam perangko waktu dalam statistik.  Sebagai jam, saya menggunakan chip real-time clock (RTC) yang terpisah dari mikrokontroler, yang memiliki daya baterai independen dan juga berkomunikasi dengan pengontrol melalui I2C. <br><br>  Saya menerapkan persyaratan sekunder tambahan dalam fungsi perangkat pada tahap penulisan program.  Ini termasuk semua jenis masalah organisasi: jumlah tombol yang terlibat, lokasi pada tampilan berbagai elemen, navigasi pada antarmuka, dan sebagainya.  Dalam hal navigasi, saya memutuskan sebelumnya untuk tidak mempersulit program, misalnya, untuk tidak mengimplementasikan menu pengaturan, khususnya, pengaturan tanggal dan waktu.  Jam disetel sekali.  Jam terus berdetak secara independen dalam chip RTC itu sendiri, berkat kuarsa 32,768 KHz dan baterai yang tahan lama.  Pengaturan tanggal dan waktu dilakukan melalui antarmuka UART dari speedometer, terhubung ke port COM komputer dengan satu klik.  Melalui antarmuka yang sama, seharusnya membaca data statistik dari ROM ke komputer.  Untuk semua ini, Anda harus menulis program yang sesuai untuk komputer.  Namun, seperti yang ditunjukkan oleh latihan lebih lanjut, yang terakhir harus ditinggalkan.  Pertama, ada masalah dalam mengimplementasikan penerimaan data dari controller ke komputer pada tahap penulisan program komputer.  Dan, bahkan lebih signifikan, volume program untuk pengontrol meningkat.  Jauh lebih menarik untuk meletakkan ROM (di perumahan SMIC SOIC-8) pada platform yang dapat dilepas, sepadan dengan kartu SIM, dan menggunakan slot gratis yang sesuai pada ponsel.  Untuk melakukan ini, perlu untuk membuat pembaca ROM berdasarkan pembaca SIM menurut salah satu skema terkenal dari programmer I2C ROM.  Ternyata kemudian, keputusan ini tidak menyebabkan ketidaknyamanan yang tidak perlu. <br><br>  Masalah penting lainnya adalah keluaran informasi simbolik (termasuk digital) pada tampilan grafik.  Ini memerlukan informasi grafis tentang simbol tertentu.  Informasi ini terkait erat dengan parameter seperti ukuran font yang ditampilkan.  Untuk menampilkan parameter utama, kecepatan gerakan, untuk kejelasan yang baik, diinginkan untuk menggunakan font besar.  Namun, seperti yang akan ditampilkan nanti, informasi grafis seperti itu tentang sepuluh digit tidak akan sesuai dengan memori MK, dan penggunaan ROM eksternal yang lebih luas yang sama akan memperlambat kecepatan menggambar font.  Saya memutuskan untuk menggunakan font dengan ketinggian 8 poin sebagai font terbesar.  Saya menarik informasi grafis untuk font ini dari file "8X8.FNT" dari beberapa program dari MS DOS, setelah sebelumnya membongkar strukturnya dan membuat pemrosesan lebih lanjut. <br><br><img src="https://habrastorage.org/webt/wu/eo/ft/wueoftqpob-qnbg5kpd3phvlfes.png"><br><br>  Seperti kemudian dalam prakteknya, ukuran ini cukup untuk kejelasan kecepatan.  Sebagai ukuran untuk font tambahan, saya memilih ukuran 3x5 dan secara mandiri menggambar grafik untuk angka-angka ukuran ini.  Angka-angka kecil ini menampilkan parameter tambahan: tanggal / waktu, kecepatan rata-rata dan maksimum, jalur. <br><br>  Informasi grafis dari kedua font disimpan dalam array dua dimensi tertentu.  Setiap elemen array, berukuran 1 byte, menunjukkan distribusi piksel dari kolom tertentu dari digit tertentu.  Untuk cetakan besar, 8 kolom dialokasikan untuk setiap digit, dan 3 untuk 3. Untuk cetakan kecil, ukuran 3X5, tinggi formal bukan 5, tetapi 8 poin (bulat hingga satu byte).  Ini memungkinkan Anda untuk mengatur terlebih dahulu lokasi font 5-posisi dalam area 8-posisi dalam arah vertikal menggunakan salah satu dari 4 metode yang mungkin.  Fakta-fakta ini ditampilkan dengan baik pada gambar di bawah ini, yang menunjukkan pemodelan grafis untuk dua digit pertama font ini.  Excel terkenal untuk pemodelan.  Data awal adalah pengaturan "unit" di bidang yang sesuai untuk grafik yang diinginkan.  Dari jumlah tersebut, rumus menghitung nilai array, hingga kode bahasa C, yang nantinya dapat disalin ke dalam teks program untuk mikrokontroler. <br><br><img src="https://habrastorage.org/webt/fh/ls/ov/fhlsov48egokegrdbnlteowsxh0.png"><br><br>  Sekarang kita akan berbicara tentang fitur kontrol dari tampilan yang digunakan.  Tampilan ini monokrom dan dimensinya 84 x 48 piksel.  Kontrol tampilan dari MK dilakukan melalui antarmuka SPI.  Bytes yang ditransmisikan oleh SPI ditafsirkan dalam tampilan dalam dua mode: byte untuk tampilan dan byte perintah konfigurasi.  Mode-mode ini diatur oleh MK sendiri untuk pin tampilan tertentu (D / C).  Daftar lengkap perintah diberikan dalam lembar data pada layar.  Beberapa perintah ini digunakan di perangkat saya, dan digunakan untuk menginisialisasi tampilan ketika daya diterapkan ke perangkat: koefisien suhu, kontras, mode gambar berurutan (horizontal atau vertikal), dll.  Saya segera mencatat bahwa mode menggambar horizontal diterapkan.  Ini berarti bahwa ketika mentransfer byte dalam mode tampilan, alamat secara otomatis bertambah satu baris demi baris ke kanan.  Ketika garis berakhir, alamat posisi pergi ke awal baris berikutnya.  Cukup mengirimkan perintah pemosisian khusus ke tampilan ke alamat baris dan kolom tertentu (posisi awal), dan kemudian mengirim byte data secara berurutan satu demi satu untuk menampilkan grafik.  Perlu diperhatikan fitur ruang alamat dan interpretasi grafik, tergantung pada byte yang diterima oleh layar.  Saya perhatikan bahwa untuk grafis monokrom, satu byte berisi informasi sekitar delapan piksel sekaligus. <br><br>  Tampilan yang dimaksud dibagi secara vertikal menjadi 6 zona horisontal dengan masing-masing 8 garis (6 * 8 = 48).  Setiap kolom dari setiap zona akan sesuai dengan byte tertentu, yang dikirim dengan alamat kolom yang sesuai (0 ... 83) dan nomor zona (0 ... 5).  Alamat tidak dihitung dari satu, dari awal.  Misalnya, jika Anda memposisikan diri di alamat (34; 2) dan mengirim byte data 255 (dalam bentuk biner "11111111"), maka semua 8 piksel menyala dari 16 hingga 23 secara vertikal dan di kolom ke-35 secara horizontal.  Menurut pendapat saya, salah satu kelemahan berikut dari fitur ini: ketidakmampuan untuk mengontrol keadaan masing-masing piksel secara individual pada tingkat perangkat keras.  Satu byte adalah bagian terkecil dari data untuk grafik.  Ketika satu byte ditransmisikan ke alamat saat ini, semua 8 piksel yang sesuai di zona saat ini diperbarui.  Layar tidak mendukung pembacaan informasi grafis yang sedang ditampilkan ke arah mikrokontroler.  Oleh karena itu, jika perlu, perlu untuk menyimpan informasi output dalam buffer khusus sebelumnya, dan untuk mengubah keadaan piksel (bit), terapkan masker bit untuk byte dari buffer ini dan transfer ke tampilan lagi. <br><br>  Pemodelan dan pemikiran lokasi informasi grafis tertentu pada tampilan dilakukan dengan mempertimbangkan fitur-fitur di atas.  Ini dilakukan untuk menyederhanakan kode saat menulis program.  Dan bukan kebetulan bahwa ukuran font dianggap dari kategori 8, 16, 24, yaitu kelipatan 8. Saya juga membagi informasi grafis, dengan analogi dengan tampilan, menjadi 6 zona horizontal.  Di zona pertama, nilai absolut dan saat ini (dari saat perangkat dihidupkan) nilai RPM ditampilkan dalam cetakan kecil.  Di zona kedua, nilai absolut dan saat ini dari jalur (dalam kilometer dengan pembulatan ke ratusan).  Di zona ketiga - kecepatan rata-rata.  Di keempat - kecepatan maksimum dan dalam cetakan besar - kecepatan saat ini.  Di zona kelima, dua bilah kemajuan ditampilkan untuk menunjukkan ROM penuh dan jumlah overwrites.  Di zona keenam, terakhir, tanggal dan waktu.  Ini adalah zona kelima yang merupakan pengecualian ketika dalam arah vertikal dari kolom yang diambil ada piksel yang terkait dengan informasi yang berbeda.  Oleh karena itu, informasi ini menggunakan bit mask dikumpulkan dalam buffer, yang isinya kemudian ditampilkan pada zona kelima ini.  Juga, dalam 3-5 zona ada informasi untuk menggambar bingkai di sekitar nilai kecepatan yang ditampilkan.  Di zona terakhir, setiap bit pertama (paling tidak signifikan) pada semua kolom diatur ke "1" untuk menggambar garis pemisah (baris ke-40).  Untuk simulasi dan visualisasi alamat ini, saya menggambarkan semua hal di atas dalam sel Excel. <br><br><img src="https://habrastorage.org/webt/nd/5z/vk/nd5zvk7smre6acj0voalhm5bimi.png"><br><br>  Beginilah tampilan jendela tampilan pertama.  Hanya dua jendela.  Jendela kedua adalah output dari grafik (histogram) pergerakan.  Untuk itu, 5 zona ditetapkan (40 baris) secara vertikal dan 84 kolom secara horizontal.  Zona keenam dengan jam sama untuk kedua jendela. <br><br>  Saat pemrograman, saya memutuskan untuk tidak menggunakan perpustakaan apa pun untuk bekerja dengan tampilan ini.  Secara pribadi, lebih mudah bagi saya untuk memahami lembar data, untuk mengimplementasikan bagian dari fungsi sendiri, daripada memahami perpustakaan.  Selain itu, keuntungan tertentu ditemukan dalam hal ini.  Baru-baru ini, setelah mengunduh salah satu perpustakaan, saya menemukan fitur fungsionalnya.  Ini bersifat universal, dengan bantuannya Anda dapat mengontrol piksel satu per satu dan memposisikan diri Anda pada alamat piksel asli.  Tapi perpustakaan menggunakan buffer berukuran 84 * 6 Bytes, dan buffer timer ini secara berkala dikirim ke layar, memperbarui grafik.  Dengan demikian, penghitung waktu dan bagian dari memori MK sibuk.  Dalam kasus khusus saya, tidak perlu menggunakan perpustakaan, karena ketika memodelkan, saya berhati-hati untuk memaksimalkan pemisahan informasi antara zona yang ditampilkan, yang sepenuhnya sesuai dengan zona tampilan.  Dan tidak perlu memperbarui informasi pada layar secara berkala: informasi diperbarui hanya jika dan hanya ketika itu berubah (dengan setiap putaran roda, dengan setiap penekanan tombol, dll.).  Jadi, saya tekankan sekali lagi: tergantung pada tugasnya, Anda dapat menghindari penggunaan perpustakaan apa pun. <br><br>  Untuk bekerja dengan clock microcircuit dan ROM, saya juga tidak menggunakan perpustakaan: semua fungsi cukup sederhana dan diterapkan oleh saya setelah mempelajari lembar data untuk komponen-komponen ini. <br><br>  Sekarang perhatikan rangkaian listrik perangkat. <br><br><img src="https://habrastorage.org/webt/fj/6h/ry/fj6hryk8yrvhu4wr9ckd9njfkj0.png"><br><br>  Tata letak speedometer relatif sederhana.  Selain semua hal di atas, rangkaian berisi elemen IC5 MAX756, yang berfungsi sebagai konverter daya 3 hingga 5 Volt untuk catu daya andal dari baterai asli ponsel Nokia 3310. Saya tidak menerapkan sirkuit untuk catu daya 3 volt karena kurangnya MK dan periferal yang sesuai.  Saat ini, saya belum mendapatkan MAX756, dan seluruh rangkaian masih ditenagai oleh baterai Krona eksternal menggunakan regulator LM7805 (bukan pilihan terbaik).  Terhubung ke jack headphone di bagian bawah telepon.  Saklar buluh SF1, yang merupakan sensor putaran roda, terhubung ke port interupsi INT0 MK (pin 32).  Menghubungkan dengan aman dari bagian bawah ponsel ke port pengisian daya.  Tombol fungsional S1-S3 yang terhubung ke tombol “1”, “2”, “3” dari ponsel terhubung ke port yang sewenang-wenang (pin 23, 27, 28).  Pin S4 terhubung ke pin 29 dari reset MK, yang bertepatan dengan tombol ujung atas untuk menyalakan ponsel.  Saya melakukannya begitu saja.  Perangkat itu sendiri tidak memiliki mode siaga dan dihidupkan dengan daya.  Tampilan IC2 dan konektor untuk mem-flash X1 terhubung ke port SPI pengontrol (pin 15-17).  Dengan konektor, yang ingin saya buat berdasarkan "bintik-bintik" yang ada pada motherboard asli untuk dipasangkan dengan PC (di tempat yang sama), saya mendapat sedikit hambatan, dan di masa depan saya akan memindahkannya ke tempat lain.  Antarmuka UART untuk koneksi pengguna ke komputer dihubungkan ke konektor yang sama, yang digunakan untuk mengkonfigurasi tanggal dan waktu pada perangkat (pin 30-31, RX / TX).  Layar terhubung ke controller melalui pembagi pada resistor, yang berfungsi untuk mengurangi tegangan, karena layar bekerja pada tegangan 3,3 V. Selain itu, pin display D / C (data / perintah), SCE (strobe) dan RES (display reset) terhubung ke port yang sewenang-wenang MK PB0, PB1 dan PB2, masing-masing (pin 12-14).  Layar ini ditenagai melalui dioda D1-D3 dan resistor R6, yang berfungsi mengurangi tegangan dari 5 menjadi 3,3 V, menghindari penggunaan regulator linier.  Kuarsa Cr1 clock oleh MK dengan nilai nominal 4,5 MHz dipilih secara acak, tetapi sengaja.  Dia jatuh ke lenganku, dan aku memutuskan untuk menggunakannya.  Transistor Q1 dan Q2 terhubung ke porta PD4 dan PD5 MK (pin 2 dan 9), ke mana LED untuk lampu latar layar dan keyboard dimuat.  Pengontrol menyediakan kemampuan untuk mengontrol lampu latar secara terpisah, karena tata letak asli ponsel menyediakan (ini pada tingkat perangkat keras, dan bukan pada tingkat pengguna), meskipun dalam praktiknya ini tidak diperlukan.  Bus I2C terhubung ke port PC2-PC3 (pin 25-26) dan, untuk kesederhanaan, diimplementasikan secara terprogram menggunakan perpustakaan yang sesuai (meskipun terhubung ke port perangkat keras TWI).  ROM IC3 dan real-time clock (RTC) IC4 diskors di bus.  Segera lakukan reservasi agar tidak ada kritik di komentar: Saya tahu bahwa DS1307 bukan solusi terbaik, tetapi pada saat pengembangan sirkuit saya tidak tahu tentang keberadaan DS3231.  ROM terletak pada konektor yang bisa dilepas, mirip dengan kartu SIM.  Port tambahan pada pengontrol PC1 (pin 24) digunakan untuk menerima pulsa dengan frekuensi 1 Hz dengan RTC, yang dengannya waktu pada tampilan diperbarui.  Semua komponen body kit pasif - sesuai dengan lembar data untuk setiap komponen aktif. <br><br>  Pertimbangkan pertimbangan matematis untuk menghitung parameter tertentu.  Seperti yang telah disebutkan di awal, prinsip pengukuran kecepatan didasarkan pada perhitungan periode revolusi roda, dan jarak dihitung berdasarkan pengukuran jumlah revolusi tersebut.  Kontroler mengukur waktu antara pulsa sebelumnya dan yang masuk dari saklar buluh.  Hasil pengukuran dikonversi menjadi nilai kecepatan dengan membagi nilai keliling roda dengan periode revolusi, dan nilai ini diperbarui pada layar dengan setiap pulsa (revolusi roda).  Perlu dicatat di sini bahwa, dari sudut pandang fisika, kecepatan rata-rata sepeda pada bagian lintasan yang sesuai dengan perimeter roda dihitung.  Secara terpisah, jumlah pulsa dihitung, lalu dikonversi ke nilai jarak.  Untuk mengukur periode rotasi roda, pengontrol menggunakan timernya sendiri.  ATmega8 memiliki timer 8-bit dan 16-bit.  Rentang dinamis pengukuran tergantung pada kedalaman bit timer.  Dalam kasus saya, timer 16-bit digunakan, karena 8 bit (jumlah 256 hitungan) secara kategorinya tidak memadai.  Periode pengukuran maksimum (sebelum timer meluap) akan sesuai dengan kecepatan minimum yang diukur.  Anda dapat memasukkan timer perangkat lunak yang disebut, yang akan mengukur periode besar.  Namun, untuk menyederhanakan program, saya tidak melakukan ini.  Dengan kuarsa yang digunakan 4,5 MHz dan nilai pembagi maksimum 1024 dalam konfigurasi timer, kami memiliki: (1 / (4500000/1024)) = 0,000227556 ​​dtk.  Nilai ini sesuai dengan periode minimum akun.  Dan periode akun maksimum adalah 0,000227556 ​​* 65536 = 14.913 detik.  Kecepatan terukur maksimum yang sesuai dengan periode terukur minimum adalah sekitar 30.000 km / jam.  Ini bahkan tidak layak ditetapkan, "cadangan dari atas" sangat besar.     ,    ,  2.26/14.913/1000*3600 = 0.54 /.  2.26 –    ( )   .       .       ,  0.54 /,      (  ).    4.5  UART      2400     .     ,  , UART          (        ).      ,     ,     ,      .    ,      .       . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya perhatikan bahwa nilai periode dan kecepatan berbanding terbalik, dan timer mikrokontroler mengukur periode secara terpisah. Dalam kasus kami, rentang pengukuran (0.000227556 ​​... 14.913) ditandai secara merata dengan titik-titik dalam jumlah 65535, membaginya menjadi banyak interval yang sama. Dan poin-poin ini sesuai dengan semua jenis nilai yang diukur. Menggunakan konversi interval dari waktu ke waktu, sistem interval ini diubah dari seragam menjadi berbanding terbalik. Oleh karena itu, kisaran kecepatan yang diukur beragam dibagi menjadi interval yang tidak rata. Panjang interval ini meningkat dengan meningkatnya nilai kecepatan itu sendiri. Mengingat fakta ini, "cadangan besar dari atas", yang saya tulis sedikit lebih tinggi, tidak akan salah. Dalam praktiknya, cukup untuk mengambil nilai 100 km / jam untuk kecepatan maksimum sepeda yang diukur.Ini hanya untuk tidak memperkenalkan digit baru (ratusan) dan tidak menambah lebar parameter yang ditampilkan pada layar. Kami menghitung berapa panjang interval antara kemungkinan nilai yang berdekatan pada kecepatan di lingkungan sama dengan, misalnya, 90 km / jam. Menggunakan rumus atau seleksi terbalik, mudah untuk menghitung bahwa untuk nilai timer 397 (dari 65536 kemungkinan) kecepatan yang diukur sesuai dengan 90,06 km / jam. Dan dengan nilai timer tetangga 398 - 89.83 km / jam. Dan perbedaan antara kecepatan adalah 0,23 km / jam, yang sudah lebih dari cukup. Dan pada kecepatan yang lebih rendah, perbedaan ini bahkan akan lebih kecil. Layar menunjukkan nilai kecepatan ke keseratus terdekat. Namun, dalam praktiknya, pembulatan ke keseluruhan terdekat atau ke persepuluhan biasanya cukup. Dari hal tersebut di atas, kita dapat menyimpulkan: ketidakseragaman "kisi" kecepatan dapat diabaikan,karena kesalahan pengukuran yang disebabkan olehnya tidak melebihi kesalahan yang diizinkan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menghitung jarak, cukup dengan melipatgandakan jumlah pulsa (putaran) dengan keliling roda. Dalam hal ini, tentu saja, jarak dihitung akurat hingga keliling roda, yang cukup dapat diterima. Kecepatan rata-rata saat ini dihitung sebagai rasio jarak saat ini bepergian dengan nilai waktu dari saat dihidupkan. Ini adalah waktu yang dipertimbangkan oleh pengontrol dengan menghitung jumlah pulsa yang tiba satu kali per detik dengan RTC. Kecepatan rata-rata pada tampilan diperbarui seiring dengan pembaruan waktu (sekali per detik). Semua parameter lain diperbarui dengan setiap putaran roda.</font></font><br><br>      .       (     ).   –    (  )       . ,             .  ,            ( ).          38-  .   ,  65536  (512 ),    .    ,      (  )    .           .      .      ,              .         ,            84  .   –    1   1 /.     40 /,       2    .        . <br><br>           .         .       ,  ,    .        . ,    -     (,   )  ,          .  ,        (,    ).     ,           . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Papan sirkuit tercetak dibuat dengan metode LUT dalam bentuk papan sirkuit asli ponsel bekas. Dalam pembuatan papan sirkuit, saya menggunakan program SLayout. Pada saat yang sama, saya mengambil gambar dari papan asli di kedua sisi pemindai terlebih dahulu dan meletakkan gambar di SLayout sebagai templat. Ini diperlukan untuk menggambar bantalan untuk menghubungkan layar, tombol dan konektor di tempat-tempat yang secara khusus diperlukan. Dalam pembuatan papan, kesalahan sekitar 0,5 mm muncul. Kesalahan ini ternyata dapat diterima dalam hal menggabungkan bantalan dan elemen. Namun, kesalahan ini memengaruhi kualitas cahaya latar: LED tersegel digeser oleh sepersekian milimeter dan tidak jatuh ke dalam fokus mandrel penghambur cahaya. Karena itu, kecerahan lampu latar menurun, mengurangi efisiensi.Gambar-gambar di bawah ini menunjukkan tampilan papan sirkuit di SLayout bersama dengan tiga papan sirkuit kecil yang dicetak untuk ROM dalam bentuk kartu SIM. Juga, pindaian papan sirkuit cetak asli dari dua sisi ditampilkan.</font></font><br><br><img src="https://habrastorage.org/webt/t4/x_/5a/t4x_5ad0pzcc8eyisyxrlmngkvu.png"><br><br><img src="https://habrastorage.org/webt/hj/gm/wp/hjgmwpma4fq8jbfeasauhjgfaqw.jpeg"><br><br>   (, )           .      , ..,      . ,           .        3-   RTC. ,             .     ,      .    ,        . <br><br>            .  ,        (EEPROM)      .         EEPROM. <br><br><table border="1" cellpadding="7"><tbody><tr><td> <b>Address</b> </td><td> <b>Size</b> </td><td> <b>Data</b> </td></tr><tr><td>  0 </td><td>  4 </td><td> n (for S) </td></tr><tr><td>  4 </td><td>  2 </td><td> t_min (for v_max) </td></tr><tr><td>  6 </td><td>  6 </td><td> Date of t_min </td></tr><tr><td>  12 </td><td>  2 </td><td> Address EEPROM </td></tr><tr><td>  14 </td><td>  1 </td><td> EEPROM RW Count </td></tr><tr><td> 128 </td><td> 80 </td><td> Digits 8X8 </td></tr><tr><td> 208 </td><td>  30 </td><td> Digits 3X5 </td></tr></tbody></table> Empat byte pertama menyimpan jarak yang ditempuh sebagai jumlah putaran roda.  Saya secara khusus memilih tipe integer 32-bit untuk variabel ini, karena dalam praktiknya nilai-nilai jalur yang dilalui relatif besar.  Misalnya, variabel bilangan bulat 16-bit dapat menyimpan maksimum 65.536 putaran (sekitar 148 km), yang secara alami kecil.  Dua byte mengikuti untuk mempertahankan kecepatan maksimum absolut.  Bahkan, waktu putaran roda minimum disimpan.  Variabel membutuhkan dua byte, karena nilainya adalah hasil pengukuran timer 16-bit.  6 byte berikutnya adalah tanggal dan waktu ketika kecepatan maksimum di atas tercapai.  Data disajikan persis dalam format yang dibaca dari chip RTC (tidak termasuk hari dalam seminggu).  Selanjutnya, dua byte yang menyimpan nilai alamat saat ini dari ROM eksternal.  Ini adalah semacam penunjuk, yang diperlukan untuk kemungkinan melanjutkan pencatatan statistik pada ROM setelah perangkat dihidupkan berikutnya.  MK harus tahu apa posisi ruang alamat ROM eksternal yang dihentikannya untuk terakhir kalinya.  Dari posisi ini MK akan melanjutkan perekaman.  Nilai ini dialokasikan 2 byte, karena ruang alamat ROM eksternal adalah 16-bit.  Ini mengikuti dari ukuran ROM 64 kB.  Berikutnya adalah variabel byte tunggal yang menyimpan nilai jumlah ROM yang ditimpa.  Timpa adalah kasus ketika pointer di atas mencapai nilai maksimum dan berubah menjadi nol.  Dalam hal ini, informasi yang baru diterima pada ROM akan mulai direkam dari awal, menghapus informasi lama yang tersedia di dalamnya.  Variabel byte tunggal integer mampu menyimpan maksimum 256 nilai.  Saya mengingatkan Anda bahwa nilai-nilai dari penunjuk alamat ROM dan jumlah timpa secara visual ditunjukkan oleh dua bilah kemajuan pada layar.  Selanjutnya, setelah ruang cadangan besar EEPROM MK, mulai dari alamat 128, informasi grafis tentang 8x8 digit disimpan.  Untuk itu, 80 Bytes dialokasikan (8 Bytes untuk setiap digit, seperti yang disebutkan sebelumnya).  Dan akhirnya, mulai dari alamat 208, 30 Bytes disimpan untuk informasi grafis tentang 3x5 digit kecil (tiga byte per digit). <br><br>  Selain program utama untuk mikrokontroler, saya menulis tiga program tambahan untuk komputer, yang akan dibahas di bawah ini.  Semua program tidak memiliki antarmuka grafis dan berfungsi dari baris perintah Windows XP. <br><br>  Program pertama memungkinkan Anda untuk menyalin tanggal dan waktu dari komputer ke speedometer sepeda melalui port COM.  Speedometer sepeda terhubung ke komputer melalui chip MAX232.  Menggunakan WinAPI, program menerima tanggal dan waktu saat ini dalam variabel struktural khusus dari tipe SYSTEMTIME.  Hari saat ini, bulan, tahun, angka hari kerja, jam, menit, detik dalam format desimal diekstraksi dari variabel ini.  Semua angka ini, dengan pengecualian tahun ini, tidak melebihi dua tempat desimal (kurang dari 100) dan berada dalam satu byte.  Nilai tahun diubah menjadi angka dua digit dengan mengurangkannya dari angka 2000, nilai milenium saat ini.  Masing-masing angka desimal dua digit ini dikonversi ke format format desimal biner dari chip RTC.  Dalam format ini, angka dua digit juga menempati volume satu byte.  4 bit paling signifikan dikodekan digit puluhan, dan paling signifikan - jumlah unit.  Selanjutnya, paket 13-byte terbentuk dari angka-angka ini, sesuai dengan protokol yang saya tentukan sebelumnya.  Lima byte pertama mewakili kata "TIME =" sesuai dengan pengkodean ASCII standar.  Kemudian ikuti detik, menit, jam, hari dalam seminggu, hari, bulan, tahun.  Byte terakhir adalah karakter "#", sebagai karakter di akhir pesan.  Paket ini dikirim dari komputer ke perangkat melalui port COM.  Program mikrokontroler menerima paket dan memeriksa kebenarannya, sesuai dengan format di atas.  Jika lima byte pertama adalah "TIME =" dan yang terakhir adalah "#", pengiriman dianggap benar, dan byte di dalam ditafsirkan dalam urutan yang sesuai.  Tanpa mengubah byte string ini, controller mengirimkannya ke chip RTC melalui bus I2C, mengonfigurasinya untuk tanggal dan waktu saat ini.  Saya perhatikan bahwa rangkaian mikro ini mendukung perhitungan hari dalam seminggu dari 1 hingga 7, meskipun dengan demikian kalender yang menentukan korespondensi tanggal dan hari dalam seminggu, itu tidak.  Saya tidak memberikan tampilan informasi tentang hari dalam seminggu di perangkat saya. <br><br>  Program kedua dirancang untuk memproses data dari isi ROM eksternal.  Awalnya, diasumsikan bahwa konten ini harus disalin dari ROM ke file gambar menggunakan beberapa program terkenal yang bekerja dengan pemrogram MK dan ROM terkenal (misalnya, "icprog").  Namun, setelah mempelajari prinsip operasi I2C lebih terinci, saya berhasil mengimplementasikan fungsi ini dan memasukkannya ke dalam program saya.  Skema programmer ROM dari seri ini, yang saya gunakan dalam perangkat, disajikan pada gambar di bawah ini. <br><br><img src="https://habrastorage.org/webt/ke/be/p1/kebep1s6zkpkgf0i5eyxu5jcvbi.png"><br><br>  ROM terhubung ke port COM komputer, yang digunakan bukan sebagai sarana untuk bertukar informasi melalui RS-232 (di mana cukup untuk menggunakan output dari TX, RX, GND), tetapi sebagai sarana input-output sewenang-wenang dari sinyal logis.  Melalui terminal TX, ROM diaktifkan, yang distabilkan hingga 5V oleh regulator 78L05.  Dengan mengontrol output TX dari komputer, kita dapat menghidupkan atau mematikan chip ROM.  Saluran clock searah SCL terkonsentrasi pada pin RTS port COM, dan jalur data dua arah SDA terkonsentrasi pada dua pin: CTS (penerimaan data) dan DTR (transmisi data).  Dioda resistor dan zener D1 dan D2 digunakan untuk membatasi level sinyal ke TTL, tempat ROM bekerja. <br><br>  Saya membuat programmer standar ini untuk kasus khusus saya, di mana alih-alih soket untuk ROM, pembaca SIM dari ponsel yang rusak digunakan. <br><br><img src="https://habrastorage.org/webt/-w/as/0e/-was0enetz2tighj_9_bziqip90.jpeg"><br><br>  Melalui WinAPI, program mengakses pin port COM komputer, menetapkan nilai yang diperlukan untuk mereka (0 atau 1), dan juga menghapus nilai biner yang masuk dari ROM dari pin CTS.  Berdasarkan toolkit ini, fungsionalitas I2C diimplementasikan sesuai dengan spesifikasi yang relevan, yang tidak akan saya bahas lebih detail.  Program dapat membaca isi ROM menjadi gambar file (seperti programmer biasa), dan juga memproses file seperti itu, atau memproses informasi dari ROM secara langsung.  Pemrosesan informasi terdiri dari memperoleh file statistik keluaran dalam format tabel yang telah ditentukan berdasarkan informasi masukan dari ROM.  Setiap file tersebut sesuai dengan satu perjalanan (dari saat saat ini hingga saat berikutnya perangkat dihidupkan).  Pertama, saya akan menjelaskan secara singkat format input yang saya tentukan sebelumnya.  Setiap kali perangkat dihidupkan, dua byte nol ditulis ke alamat saat ini, yang dibaca dari EEPROM mikrokontroler.  Ketika roda mulai berputar (pada impuls pertama) setelah waktu habis atau setelah menyalakan perangkat, tanggal dan waktu saat ini ditulis dalam format desimal biner (karena disimpan dalam register chip RTC).  Dan kemudian dua byte "unit" 0xFF direkam.  Selama rotasi roda, untuk setiap pulsa k-th (k = 2,3, ...), waktu rotasi roda antara (k-1) ke-k dan ke-k pulsa dicatat oleh dua byte (tinggi dan rendah).  Jelas, informasi ini cukup untuk menghubungkan jarak saat ini (bukan absolut) yang ditempuh dan kecepatan dengan tanggal dan waktu.  Format output adalah teks dan tabel tabel dalam file * .csv yang dibuka di Excel dengan mengklik dua kali mouse.  Baris dalam tabel ini sesuai dengan putaran roda, dan nilai kolom ditunjukkan di bawah ini. <br><br><table border="1" cellpadding="7"><tbody><tr><td>  <b>ADR</b> </td><td>  Nilai Alamat ROM </td></tr><tr><td>  <b>TANGGAL / WAKTU</b> </td><td>  Tanggal dan waktu mulai </td></tr><tr><td>  <b>Desember</b> </td><td>  Nilai Timer Desimal </td></tr><tr><td>  <b>waktu</b> </td><td>  Waktu saat ini </td></tr><tr><td>  <b>t</b> </td><td>  Waktu tempuh sejak dinyalakan </td></tr><tr><td>  <b>v</b> </td><td>  Kecepatan </td></tr><tr><td>  <b>n</b> </td><td>  Kecepatan </td></tr><tr><td>  <b>S</b> </td><td>  Jalan </td></tr><tr><td>  <b>sebuah</b> </td><td>  Jumlah absolut revolusi (hanya dalam ROM saat ini) </td></tr><tr><td>  <b>aS</b> </td><td>  Jalur absolut (hanya di dalam ROM saat ini) </td></tr><tr><td>  <b>n_day</b> </td><td>  Jumlah revolusi untuk hari ini </td></tr><tr><td>  <b>S_day</b> </td><td>  Jalan untuk hari ini </td></tr><tr><td>  <b>v_max</b> </td><td>  Kecepatan maksimum untuk perjalanan saat ini </td></tr><tr><td>  <b>av_max</b> </td><td>  Kecepatan maksimum absolut (hanya di dalam ROM saat ini) </td></tr><tr><td>  <b>v_mid</b> </td><td>  Kecepatan rata-rata untuk perjalanan saat ini </td></tr></tbody></table>  Tangkapan layar dari konten file seperti itu di Excel ditunjukkan pada gambar di bawah ini.  Juga grafik perubahan dalam kecepatan saat ini, rata-rata dan maksimum dalam berbagai warna dalam satu sistem koordinat ditampilkan.  Argumen (sumbu X) - kecepatan nilai sebagai data input.  Gambar menunjukkan perubahan parameter untuk 730 putaran pertama.  Jarak yang ditempuh dikaitkan dengan ketergantungan linear variabel ini (730 putaran sesuai dengan sekitar 1650 m).  Oleh karena itu, kita dapat mengatakan bahwa grafik mencerminkan ketergantungan kecepatan pada jarak (akurat terhadap skala horizontal), berbeda dengan ketergantungan tradisional kecepatan pada waktu, yang harus diperhatikan.  Seperti yang telah disebutkan, fitur ini disebabkan oleh ideologi dan prinsip pengukuran kecepatan dengan kecepatan roda.  Tetapi bagaimanapun juga, momen waktu tertentu diberikan pada setiap putaran roda (momen mendekati magnet dan saklar buluh).  Secara alami, urutan cap waktu ini tidak seragam.  Namun, untuk formalitas dan kenyamanan, Excel memiliki kemampuan untuk menentukan array nilai waktu di jalur atau waktu saat ini sebagai argumen untuk grafik.  Tapi semua sama, harus diingat bahwa ketergantungan nyata kecepatan pada waktu (pada interval waktu yang seragam untuk kasus diskrit) akan terlihat berbeda, dengan skala horisontal variabel. <br><br><img src="https://habrastorage.org/webt/fn/af/to/fnaftofg4-o5ihmbxhhn9olwlha.png"><br><br><img src="https://habrastorage.org/webt/lw/ul/qa/lwulqayq1gcskndypndok_opb3i.png"><br><br>  Gambar di bawah ini menunjukkan ketergantungan kecepatan yang sama pada putaran, tetapi sudah menggunakan filter menggunakan metode rata-rata bergerak dengan lebar jendela 11 putaran.  Semua grafik dibuat di Excel menggunakan metode terkenal. <br><br><img src="https://habrastorage.org/webt/gx/xu/qk/gxxuqkk_mqlghugdmrgkhevpeem.png"><br><br>  Membandingkan dua grafik dari perubahan dalam kecepatan, jelas bahwa komponen frekuensi tinggi tidak ada dalam grafik yang difilter, yaitu  kebisingan dihilangkan.  Lebar jendela rata-rata bergerak 11 putaran (sekitar 25 m), menurut saya, terlalu besar.  Jika Anda benar-benar mengajukan pertanyaan untuk memfilter bacaan dari noise, maka cukup untuk mengambil lebar jendela kecil, misalnya, sama dengan tiga.  Algoritma ini dapat dimasukkan ke dalam program speedometer sepeda, karena dapat digunakan tidak hanya untuk menganalisis bacaan, tetapi juga untuk menampilkan bacaan ini secara real time.  Terlepas dari kesederhanaan algoritme ini, saya tidak akan membahas detail uraiannya, karena topik ini dibahas dalam pelajaran matematika dan berada di luar cakupan artikel ini.  Dan di sini ada klarifikasi lain tentang kecepatan rata-rata.  Seperti yang sudah saya tulis, kecepatan rata-rata adalah satu-satunya parameter yang diperbarui bukan dengan setiap putaran roda, tetapi setiap detik.  Saya melakukan ini untuk memastikan bahwa tampilan menunjukkan perubahan dalam kecepatan rata-rata bahkan dengan gerakan yang sangat lambat.  Oleh karena itu, nilai pembacaan pada tampilan secara real time akan sedikit berbeda dari nilai yang dihitung di masa depan oleh program komputer pada tahap pemindaian ROM.  Pembacaan kecepatan absolut, jalur absolut dan kecepatan maksimum absolut juga akan berbeda.  Layar menunjukkan nilai yang sangat absolut (untuk seluruh masa pakai perangkat), dan dalam tabel output - hanya dalam batas ROM yang sedang dibaca. <br><br>  Program ketiga, pada dasarnya, adalah program yang sama untuk mikrokontroler firmware.  Saya bekerja dengan programmer STK 200 paling sederhana yang terhubung ke port LPT komputer, atau lebih tepatnya, dengan analognya, jika Anda bisa menyebutnya begitu, karena dalam kasus yang paling sederhana programmer tidak mengandung elemen aktif apa pun.  Bahkan, MK melalui antarmuka SPI terhubung ke pin spesifik port LPT secara langsung dan berfungsi sebagai budak.  Program mengimplementasikan protokol untuk bertukar data dengan pengontrol ATmega8 menurut datasheet-nya (hlm. 237).  Lapisan fisik SPI diimplementasikan dengan mengelola register port LPT menggunakan pustaka dinamis terkenal “inpout32.dll”.  Perpustakaan saya terhubung bukan sebagai proyek (karena saya menghindari membuat proyek seperti itu di "Dev-cpp" dengan membuat satu "file" sederhana), tetapi menggunakan fungsi LoadLibrary menggunakan tipe struktural HINSTANCE.  Pustaka "inpout32.dll" dipetakan ke variabel jenis ini, dan selanjutnya petunjuk ke fungsi dari pustaka ini diekstraksi ke dalam variabel yang terpisah.  Inpout32.dll hanya memiliki dua fungsi yang bertanggung jawab untuk input dan output data.  Fungsi-fungsi ini diakses menggunakan pointer pra-diekstraksi.  Pin port LPT dikontrol secara individual menggunakan bit mask.  Dalam kasus khusus saya, program yang saya tulis bekerja dengan area EEPROM pada pengontrol dan dirancang untuk membaca, memesan, menulis, memperbaiki, dan memulihkan dari salinan cadangan data yang tersimpan di dalamnya yang saya lukis sebelumnya.  Seperti semua program lain, program dijalankan dari baris perintah.  Dalam kasus seperti itu, untuk mengimplementasikan multifungsi program, fungsi "sakelar" dan dialog pengguna teks digunakan, misalnya, "masukkan '1' untuk operasi No. 1, ..., masukkan '0' untuk keluar dari program."  Data ditampilkan dalam berbagai format yang nyaman bagi saya.  Selain hal di atas, program ini dapat menampilkan dump penuh dari kontroler EEPROM dalam 512 Bytes pada layar.  Selain itu, program ini dapat merekam informasi grafis tentang font yang digunakan dalam memori controller.  Dalam kasus cetakan kecil, ukuran 3X5, program mengambil informasi dari file teks "Fonts 3X5.txt", yang terletak di direktori yang sama dengannya.  File ini berisi tabel tabel 30 byte (3 kali 10) yang ditulis dalam format heksadesimal.  Jika diinginkan, dapat dengan mudah diedit dalam editor teks, sehingga mengubah grafik font ini.  Seperti yang telah disebutkan, cetakan kecil ini sangat sederhana sehingga mengubah grafiknya tidak masuk akal.  Satu-satunya hal adalah bahwa pergeseran vertikal hanya mungkin diperlukan, karena ada stok ruang di ketinggian 8 piksel, dan font memiliki ketinggian sama dengan 5. Dalam kasus font besar, ukuran 8X8, yang menampilkan kecepatan saat ini, saya menyediakan fungsionalitas yang jauh lebih menarik.  Informasi grafis tentang font ini disajikan bukan dalam file teks sebagai tabel byte, tetapi dalam file BMP visual visual.  Setiap digit sesuai dengan satu file tersebut.  Parameternya adalah ukuran 8X8, monokrom dengan palet hitam dan putih.  Di bawah ini adalah tangkapan layar editor grafis terkenal "MS Paint" dengan file "8.bmp" terbuka di dalamnya. <br><br><img src="https://habrastorage.org/webt/s3/7o/ek/s37oekzshuoye0acdpxotluebas.png"><br><br>  Secara empiris, saya mempelajari struktur file BMP monokrom yang diperoleh dari MS Paint ”, dan atas dasar ini saya bisa belajar membaca setiap piksel dari gambar BMP monokrom (tidak termasuk penggunaan struktur dan perpustakaan tambahan).  Pada tahap pembacaan baris demi baris horizontal dari bawah ke atas (beginilah struktur file BMP diatur), program mengubah informasi menjadi format vertikal khusus untuk tampilan yang digunakan.  Operasi ini dilakukan dalam satu pass, di mana bit mask dan akumulasi nilai variabel digunakan.  Di bawah ini saya akan menunjukkan bagian kode ini untuk digit ke-i, dengan memperhatikan kesederhanaan proses. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(k=<span class="hljs-number"><span class="hljs-number">0</span></span>; k&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; k++){ fnt[i][k] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; j++){ fseek(f, <span class="hljs-number"><span class="hljs-number">62</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>*j, SEEK_SET); byte = ~fgetc(f); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(k=<span class="hljs-number"><span class="hljs-number">0</span></span>; k&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; k++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(byte &amp; pow2(<span class="hljs-number"><span class="hljs-number">7</span></span>-k)){ fnt[i][k] += pow2(<span class="hljs-number"><span class="hljs-number">7</span></span>-j); } } }</code> </pre> <br>  Pada loop pertama, elemen array fnt diinisialisasi ke nol.  Selanjutnya, setiap elemen k-th dari array ini (k = 0 ... 7) untuk digit ke-i (i = 0 ... 9) akan membawa informasi grafis tentang setiap kolom yang sesuai dari setiap digit yang sesuai.  Siklus berikutnya adalah menjalankan sepanjang garis gambar file BMP.  Dengan operator fseek, kami memposisikan diri kami byte pada offset 62 + 4 * j dari file BMP yang telah ditentukan f.  Spesifisitas rumus di mana offset dihitung tergantung pada nomor baris j ditentukan oleh struktur file BMP.  Dalam variabel menengah byte, kita mendapatkan nilai byte pada offset di atas.  Byte ini menyimpan informasi tentang semua delapan piksel gambar monokrom di baris saat ini j.  Operator '~' melakukan inversi bitwise pada byte, yang mengarah ke inversi warna dari setiap piksel.  Ini disebabkan oleh fakta bahwa piksel hitam dalam palet file BMP monokrom sesuai dengan "0" logis, dan putih - "1".  Di layar yang diterapkan, sebaliknya.  Dalam loop bersarang, analisis byte dari byte terjadi dan pada saat yang sama, informasi diakumulasikan dalam array keluaran fnt.  Function pow2 - menaikkan dua ke daya integer non-negatif, ditulis secara independen.  Alih-alih fungsi ini, Anda dapat menggunakan operator shift bitwise “&lt;&lt;” yang lebih efisien, tetapi pada saat menulis program ini saya tidak menggunakannya. <br><br>  Selain itu, program ini menyediakan kemampuan untuk menulis ke memori MK salah satu dari beberapa opsi grafik untuk font pilihan saya ini.  Opsi ini diimplementasikan menggunakan direktori (folder) dengan nama dari bentuk "v1", "v2", "v3", dll., Yang terletak di folder "Fonts 8X8" di direktori yang sama dengan program.  Dan sudah di folder ini adalah file BMP yang diperlukan.  Berkat fungsi di atas, dimungkinkan untuk mengoreksi atau menggambar angka dari "lembar kosong" di editor grafis, menyimpan dan mendistribusikannya di antara direktori.  Saya memiliki tiga opsi font.  Opsi pertama adalah yang asli.  Yang kedua - seperti aslinya, tetapi dengan nol dicoret dan unit yang dimodifikasi (tanpa garis bawah).  Yang ketiga adalah font dengan batas persegi panjang. <br><br>  Foto-foto di bawah ini menunjukkan: papan sirkuit buatan perangkat dari belakang;  perangkat di atas meja dengan daya yang terhubung dengannya (dengan versi firmware yang tidak final);  perangkat yang beroperasi dipasang di sepeda dengan grafik perubahan kecepatan yang ditampilkan di sana. <br><br><img src="https://habrastorage.org/webt/zm/5l/ly/zm5llykx8zbjhlpvl9hw72tfd98.jpeg"><br><br><img src="https://habrastorage.org/webt/kx/_b/mz/kx_bmzvxzlw-srwhzbudrpsdcg0.jpeg"><br><br><img src="https://habrastorage.org/webt/ak/lh/gx/aklhgxhxfzvj653rpxh4uqbrbri.jpeg"><br><br>  Namun, dalam proses pengoperasian perangkat, kekurangan kecil diidentifikasi terkait dengan fitur-fitur manufaktur.  Pertama-tama, kontak yang buruk pada display dengan bantalan papan sirkuit cetak.  Di ponsel asli, kontak di papan berlapis emas dan tidak ada oksidasi.  Dalam kasus saya, mereka hanya bisa dikerjakan. <br><br>  Berdasarkan hal tersebut di atas, diputuskan untuk membuat kembali perangkat dalam kasus lain, serta membuat kembali papan sirkuit tercetak, di mana tampilan akan disolder dengan tidak sopan.  Saya memulai proses ini baru-baru ini.  Hasilnya adalah desain yang lebih kuat. <br><br><img src="https://habrastorage.org/webt/el/tw/r1/eltwr1m1zmbt1q5bj11v3a3cxks.png"><br><br><img src="https://habrastorage.org/webt/rh/hs/dw/rhhsdwamztytb2ix0le9mmyj2na.jpeg"><br><br><img src="https://habrastorage.org/webt/mp/rt/-h/mprt-hnrwvztbrvggcj6jhwx0qk.jpeg"><br><br>  Saya membuat case untuk perangkat dari sepotong plexiglass, 17 mm tebal, pada mesin penggilingan CNC.  Untuk melakukan ini, saya membuat sketsa sketsa kasus dalam program SPlan, hampir sama sekali tidak mengetahui subjek gambar, CAD, dll. <br><br><img src="https://habrastorage.org/webt/tn/j6/w-/tnj6w-zgduldrbd4-t9rqw1hihe.jpeg"><br><br>  Sketsa ini diperlukan untuk presentasi umum dan mendapatkan koordinat titik kontrol.  Berdasarkan mereka, sebuah program ditulis untuk mesin CNC, dengan mempertimbangkan prinsip-prinsip umum dan urutan penggilingan.  Saya menulis program CNC secara manual di Excel, menggunakan fungsi autocomplete untuk operasi berulang. <br><br><img src="https://habrastorage.org/webt/eb/g1/ie/ebg1iewnui1ptplfwit3gvrbya0.jpeg"><br><br><img src="https://habrastorage.org/webt/qr/qa/kk/qrqakkmdcsuifjphgg_h8wcqybc.jpeg"><br><br>  Saya juga sedikit memperbaiki tata letak perangkat, ini disajikan pada gambar di bawah ini. <br><br><img src="https://habrastorage.org/webt/wd/e5/lh/wde5lh6inym01_4elygpybkuuqy.png"><br><br>  Alih-alih lampu latar keyboard yang sudah tidak perlu, ada satu LED untuk kecantikan yang berkedip dengan setiap putaran roda.  Konektor juga digambar ulang, dan tidak ada elemen lain yang tidak diperlukan dalam versi desain yang diperbarui.  Selanjutnya, saya menemukan dan menginstal kuarsa 4,433619 MHz, sedikit mengoreksi beberapa konstanta dalam kode sumber program saya sendiri.  Beberapa perubahan kecil pada program juga dibuat. <br><br>  Foto produk jadi disajikan di bawah ini.  Perangkat ini didukung oleh baterai yang berdiri di atas sepeda.  Dari situ, pencahayaan juga disediakan untuk perjalanan dalam gelap. <br><br><img src="https://habrastorage.org/webt/qa/1w/ln/qa1wln2ikvghei7heep_puqn9ay.jpeg"><br><br>  Dalam desain inilah perangkat bekerja sepenuhnya tanpa gangguan.  Satu-satunya kelemahan adalah penggunaan chip RTC yang tidak terlalu berkualitas: di musim dingin pada suhu rendah, waktu terasa terburu-buru, Anda harus menyesuaikannya sebulan sekali. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414281/">https://habr.com/ru/post/id414281/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414269/index.html">"20.000 IOPS per node adalah kinerja yang baik dengan latensi 5 ms." Untuk OLTP - no</a></li>
<li><a href="../id414271/index.html">Cara menjinakkan hard drive di laptop dan mencegah parkir dalam 8 detik downtime</a></li>
<li><a href="../id414273/index.html">Apa yang perlu Anda ketahui sebelum mengembangkan backtester untuk strategi perdagangan: masalah khas, jenis sistem dan parameternya</a></li>
<li><a href="../id414277/index.html">Manusia, lingkungannya dan internet hal-hal</a></li>
<li><a href="../id414279/index.html">Voting untuk laporan pada pertemuan DIY kedelapan di Grup Mail.Ru (07.07.2018)</a></li>
<li><a href="../id414283/index.html">Cara membedakan cryptocurrency dari non-cryptocurrency</a></li>
<li><a href="../id414285/index.html">Kami menggunakan saklar nirkabel 433MHz untuk mengontrol PC</a></li>
<li><a href="../id414289/index.html">SpaceX telah membuka pekerjaan sebagai insinyur roket untuk membuat BFR</a></li>
<li><a href="../id414293/index.html">ReactOS Hackfest tahunan ketiga akan diadakan dari 14 hingga 21 Agustus 2018 di Berlin</a></li>
<li><a href="../id414295/index.html">"Itu mungkin": cara yang tidak biasa, tetapi efektif untuk menggunakan teknologi "audio"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>