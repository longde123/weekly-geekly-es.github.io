<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçü§ù‚Äçüë®üèª üìâ üë®üèø‚Äçü§ù‚Äçüë®üèΩ Types de r√©f√©rence .NET vs types de valeur. 2e partie ü§Ωüèæ üõ≥Ô∏è üé≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Type de base d'objet et impl√©mentation d'interfaces. La boxe 


 Il semble que nous ayons travers√© l'enfer et les hautes eaux et que nous puissions r√©...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Types de r√©f√©rence .NET vs types de valeur. 2e partie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/439490/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img width="350" align="left" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png"></a> </p><br><h2 id="the-object-base-type-and-implementation-of-interfaces-boxing">  Type de base d'objet et impl√©mentation d'interfaces.  La boxe </h2><br><p>  Il semble que nous ayons travers√© l'enfer et les hautes eaux et que nous puissions r√©ussir n'importe quelle interview, m√™me celle de l'√©quipe .NET CLR.  Cependant, ne nous pr√©cipitons pas sur microsoft.com et recherchons des postes vacants.  Maintenant, nous devons comprendre comment les types de valeurs h√©ritent d'un objet s'ils ne contiennent ni r√©f√©rence √† SyncBlockIndex, ni pointeur vers une table de m√©thodes virtuelles.  Cela expliquera compl√®tement notre syst√®me de types et toutes les pi√®ces d'un puzzle trouveront leur place.  Cependant, nous aurons besoin de plus d'une phrase. </p><br><p>  Maintenant, rappelons-nous √† nouveau comment les types de valeurs sont allou√©s en m√©moire.  Ils ont la place en m√©moire l√† o√π ils se trouvent.  Les types de r√©f√©rence obtiennent une allocation sur le tas d'objets petits et grands.  Ils donnent toujours une r√©f√©rence √† l'endroit sur le tas o√π se trouve l'objet.  Chaque type de valeur a des m√©thodes telles que ToString, Equals et GetHashCode.  Ils sont virtuels et rempla√ßables, mais ne permettent pas d'h√©riter d'un type de valeur en rempla√ßant les m√©thodes.  Si les types de valeur utilisaient des m√©thodes rempla√ßables, ils auraient besoin d'une table de m√©thodes virtuelle pour router les appels.  Cela entra√Ænerait des probl√®mes de passage des structures dans un monde non g√©r√©: des champs suppl√©mentaires y iraient.  Par cons√©quent, il existe des descriptions de m√©thodes de type valeur quelque part, mais vous ne pouvez pas y acc√©der directement via une table de m√©thodes virtuelle. </p><br><p>  Cela peut amener l'id√©e que le manque d'h√©ritage est artificiel </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Ce chapitre a √©t√© traduit du russe conjointement par l'auteur et par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des traducteurs professionnels</a> .  Vous pouvez nous aider avec la traduction du russe ou de l'anglais dans n'importe quelle autre langue, principalement en chinois ou en allemand. <br><br>  Aussi, si vous voulez nous remercier, la meilleure fa√ßon de le faire est de nous donner une √©toile sur github ou sur fork repository <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><a name="habracut"></a><br><p>  Cela peut amener l'id√©e que le manque d'h√©ritage est artificiel: </p><br><ul><li>  il y a h√©ritage d'un objet, mais pas direct; </li><li> il y a ToString, Equals et GetHashCode dans un type de base.  Dans les types de valeur, ces m√©thodes ont leur propre comportement.  Cela signifie que les m√©thodes sont remplac√©es par rapport √† un <code>object</code> ; </li><li>  de plus, si vous transtypez un type en un <code>object</code> , vous avez le droit d'appeler ToString, Equals et GetHashCode; </li><li>  lors de l'appel d'une m√©thode d'instance pour un type de valeur, la m√©thode obtient une autre structure qui est une copie d'un original.  Cela signifie que l'appel d'une m√©thode d'instance revient √† appeler une m√©thode statique: <code>Method(ref structInstance, newInternalFieldValue)</code> .  En effet, cet appel r√©ussit, √† une exception pr√®s.  Un JIT doit compiler le corps d'une m√©thode, il serait donc inutile de d√©caler les champs de structure, en sautant par dessus le pointeur vers une table de m√©thodes virtuelle, qui n'existe pas dans la structure.  <em>Il existe pour les types de valeur dans un autre endroit</em> . </li></ul><br><p>  Les types ont un comportement diff√©rent, mais cette diff√©rence n'est pas si grande au niveau de l'impl√©mentation dans le CLR.  Nous en parlerons un peu plus tard. </p><br><p>  √âcrivons la ligne suivante dans notre programme: </p><br><pre> <code class="plaintext hljs">var obj = (object)10;</code> </pre> <br><p>  Cela nous permettra de traiter le num√©ro 10 en utilisant une classe de base.  C'est ce qu'on appelle la boxe.  Cela signifie que nous avons un VMT pour appeler des m√©thodes virtuelles telles que ToString (), Equals et GetHashCode.  En r√©alit√©, la boxe cr√©e une copie d'un type de valeur, mais pas un pointeur vers un original.  En effet, nous pouvons stocker la valeur d'origine partout: sur la pile ou en tant que champ d'une classe.  Si nous le convertissons en type d'objet, nous pouvons stocker une r√©f√©rence √† cette valeur aussi longtemps que nous le souhaitons.  Quand la boxe arrive: </p><br><ul><li>  le CLR alloue de l'espace sur le tas pour une structure + SyncBlockIndex + VMT d'un type valeur (pour appeler ToString, GetHashCode, Equals); </li><li>  il y copie une instance d'un type de valeur. </li></ul><br><p>  Maintenant, nous avons une variante de r√©f√©rence d'un type de valeur.  Une structure a <strong>absolument le m√™me ensemble de champs syst√®me qu'un type de r√©f√©rence</strong> , <br>  devenir un type de r√©f√©rence √† part enti√®re apr√®s la boxe.  La structure est devenue une classe.  Appelons cela un saut p√©rilleux .NET.  Ceci est un nom juste. </p><br><p>  Regardez ce qui se passe si vous utilisez une structure qui impl√©mente une interface utilisant la m√™me interface. </p><br><pre> <code class="plaintext hljs">struct Foo : IBoo { int x; void Boo() { x = 666; } } IBoo boo = new Foo(); boo.Boo();</code> </pre> <br><p>  Lorsque nous cr√©ons l'instance Foo, sa valeur va en fait √† la pile.  Ensuite, nous mettons cette variable dans une variable de type interface et la structure dans une variable de type r√©f√©rence.  Ensuite, il y a la boxe et nous avons le type d'objet en sortie.  Mais c'est une variable de type interface.  Cela signifie que nous avons besoin d'une conversion de type.  Ainsi, l'appel se d√©roule de la mani√®re suivante: </p><br><pre> <code class="plaintext hljs">IBoo boo = (IBoo)(box_to_object)new Foo(); boo.Boo();</code> </pre> <br><p>  L'√©criture d'un tel code n'est pas efficace.  Vous devrez modifier une copie au lieu d'un original: </p><br><pre> <code class="plaintext hljs">void Main() { var foo = new Foo(); foo.a = 1; Console.WriteLite(foo.a); // -&gt; 1 IBoo boo = foo; boo.Boo(); // looks like changing foo.a to 10 Console.WriteLite(foo.a); // -&gt; 1 } struct Foo: IBoo { public int a; public void Boo() { a = 10; } } interface IBoo { void Boo(); }</code> </pre> <br><p>  La premi√®re fois que nous examinons le code, nous n'avons pas besoin de savoir ce que nous traitons dans le code <em>autre que le n√¥tre</em> et de voir une distribution vers l'interface IBoo.  Cela nous fait penser que Foo est une classe et non une structure.  Ensuite, il n'y a pas de division visuelle dans les structures et les classes, ce qui nous fait penser <br>  les r√©sultats de la modification de l'interface doivent entrer dans foo, ce qui ne se produit pas car boo est une copie de foo.  C'est trompeur.  √Ä mon avis, ce code devrait recevoir des commentaires, afin que d'autres d√©veloppeurs puissent y faire face. </p><br><p>  La deuxi√®me chose concerne les pens√©es pr√©c√©dentes selon lesquelles nous pouvons convertir un type d'un objet en IBoo.  Ceci est une autre preuve qu'un type de valeur encadr√© est une variante de r√©f√©rence d'un type de valeur.  Ou, tous les types d'un syst√®me de types sont des types de r√©f√©rence.  Nous pouvons simplement travailler avec des structures comme avec des types de valeur, en passant enti√®rement leur valeur.  D√©r√©f√©rencer un pointeur sur un objet comme vous le diriez dans le monde du C ++. </p><br><p>  Vous pouvez objecter que si c'√©tait vrai, cela ressemblerait √† ceci: </p><br><pre> <code class="plaintext hljs">var referenceToInteger = (IInt32)10;</code> </pre> <br><p>  Nous obtiendrions non seulement un objet, mais une r√©f√©rence typ√©e pour un type de valeur encadr√©e.  Cela d√©truirait l'id√©e globale des types de valeur (c'est-√†-dire l'int√©grit√© de leur valeur) permettant une grande optimisation, en fonction de leurs propri√©t√©s.  Reprenons cette id√©e! </p><br><pre> <code class="plaintext hljs">public sealed class Boxed&lt;T&gt; { public T Value; [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) { return Value.Equals(obj); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() { return Value.ToString(); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() { return Value.GetHashCode(); } }</code> </pre> <br><p>  Nous avons un analogue complet de la boxe.  Cependant, nous pouvons changer son contenu en appelant des m√©thodes d'instance.  Ces modifications affecteront toutes les parties avec une r√©f√©rence √† cette structure de donn√©es. </p><br><pre> <code class="plaintext hljs">var typedBoxing = new Boxed&lt;int&gt; { Value = 10 }; var pureBoxing = (object)10;</code> </pre> <br><p>  La premi√®re variante n'est pas tr√®s attractive.  Au lieu de lancer un type, nous cr√©ons un non-sens.  La deuxi√®me ligne est bien meilleure, mais les deux lignes sont presque identiques.  La seule diff√©rence est qu'il n'y a pas de nettoyage de la m√©moire avec des z√©ros pendant la boxe habituelle apr√®s l'allocation de m√©moire sur le tas.  La structure n√©cessaire prend tout de suite la m√©moire alors que la premi√®re variante a besoin d'√™tre nettoy√©e.  Cela le rend plus long que la boxe habituelle de 10%. </p><br><p>  Au lieu de cela, nous pouvons appeler certaines m√©thodes pour notre valeur encadr√©e. </p><br><pre> <code class="plaintext hljs">struct Foo { public int x; public void ChangeTo(int newx) { x = newx; } } var boxed = new Boxed&lt;Foo&gt; { Value = new Foo { x = 5 } }; boxed.Value.ChangeTo(10); var unboxed = boxed.Value;</code> </pre> <br><p>  Nous avons un nouvel instrument.  Pensons √† ce que nous pouvons en faire. </p><br><ul><li>  Notre type <code>Boxed&lt;T&gt;</code> fait la m√™me chose que le type habituel: alloue de la m√©moire sur le tas, y passe une valeur et permet de l'obtenir, en faisant une sorte de unbox; </li><li>  Si vous perdez une r√©f√©rence √† une structure en bo√Æte, le GC la collectera; </li><li>  Cependant, nous pouvons maintenant travailler avec un type encadr√©, c'est-√†-dire appeler ses m√©thodes; </li><li>  De plus, nous pouvons remplacer une instance d'un type de valeur dans SOH / LOH par une autre.  Nous ne pouvions pas le faire avant, car nous devions faire du d√©ballage, changer la structure en une autre et faire de la boxe, donnant une nouvelle r√©f√©rence aux clients. </li></ul><br><p>  Le principal probl√®me de la boxe est de cr√©er du trafic en m√©moire.  Le trafic d'un nombre inconnu d'objets, dont la partie peut survivre jusqu'√† la premi√®re g√©n√©ration, o√π nous rencontrons des probl√®mes avec la collecte des ordures.  Il y aura beaucoup de d√©chets et nous aurions pu les √©viter.  Mais lorsque nous avons le trafic d'objets de courte dur√©e, la premi√®re solution est la mutualisation.  Il s'agit d'une fin id√©ale du saut p√©rilleux .NET. </p><br><pre> <code class="plaintext hljs">var pool = new Pool&lt;Boxed&lt;Foo&gt;&gt;(maxCount:1000); var boxed = pool.Box(10); boxed.Value=70; // use boxed value here pool.Free(boxed);</code> </pre> <br><p>  D√©sormais, la boxe peut fonctionner √† l'aide d'un pool, ce qui √©limine le trafic m√©moire lors de la boxe.  Nous pouvons m√™me faire revivre les objets dans la m√©thode de finalisation et les replacer dans la piscine.  Cela peut √™tre utile lorsqu'une structure encadr√©e passe √† un code asynchrone autre que le v√¥tre et que vous ne pouvez pas comprendre quand cela est devenu inutile.  Dans ce cas, il reviendra au pool pendant le GC. </p><br><p>  Concluons: </p><br><ul><li>  Si la boxe est accidentelle et ne devrait pas se produire, ne le faites pas.  Cela peut entra√Æner des probl√®mes de performances. </li><li>  Si la boxe est n√©cessaire √† l'architecture d'un syst√®me, il peut y avoir des variantes.  Si le trafic des structures en bo√Æte est petit et presque invisible, vous pouvez utiliser la boxe.  Si le trafic est visible, vous voudrez peut-√™tre faire le regroupement de la boxe, en utilisant l'une des solutions √©nonc√©es ci-dessus.  Il d√©pense quelques ressources, mais fait fonctionner GC sans surcharge; </li></ul><br><p>  En fin de compte, regardons un code totalement impraticable: </p><br><pre> <code class="plaintext hljs">static unsafe void Main() { // here we create boxed int object boxed = 10; // here we get the address of a pointer to a VMT var address = (void**)EntityPtr.ToPointerWithOffset(boxed); unsafe { // here we get a Virtual Methods Table address var structVmt = typeof(SimpleIntHolder).TypeHandle.Value.ToPointer(); // change the VMT address of the integer passed to Heap into a VMT SimpleIntHolder, turning Int into a structure *address = structVmt; } var structure = (IGetterByInterface)boxed; Console.WriteLine(structure.GetByInterface()); } interface IGetterByInterface { int GetByInterface(); } struct SimpleIntHolder : IGetterByInterface { public int value; int IGetterByInterface.GetByInterface() { return value; } }</code> </pre> <br><p>  Le code utilise une petite fonction, qui peut obtenir un pointeur d'une r√©f√©rence √† un objet.  La biblioth√®que est disponible √† l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">adresse github</a> .  Cet exemple montre que la boxe habituelle se transforme en un type de r√©f√©rence typ√©.  On y va <br>  regardez les √©tapes du processus: </p><br><ol><li>  Faites de la boxe pour un entier. </li><li>  Obtenir l'adresse d'un objet obtenu (l'adresse de Int32 VMT) </li><li>  Obtenez le VMT d'un SimpleIntHolder </li><li>  Remplacez le VMT d'un entier encadr√© par le VMT d'une structure. </li><li>  Transformer unboxing en type de structure </li><li>  Afficher la valeur du champ √† l'√©cran, obtenant l'Int32, qui √©tait <br>  en bo√Æte. </li></ol><br><p>  Je le fais via l'interface expr√®s car je veux montrer que cela fonctionnera <br>  de cette fa√ßon. </p><br><h3 id="nullablet">  Nullable \ &lt;T&gt; </h3><br><p>  Il convient de mentionner le comportement de la boxe avec les types de valeur Nullable.  Cette fonctionnalit√© des types de valeur Nullable est tr√®s int√©ressante car la boxe d'un type de valeur qui est une sorte de null renvoie null. </p><br><pre> <code class="plaintext hljs">int? x = 5; int? y = null; var boxedX = (object)x; // -&gt; 5 var boxedY = (object)y; // -&gt; null</code> </pre> <br><p>  Cela nous am√®ne √† une conclusion particuli√®re: comme null n'a pas de type, le <br>  la seule fa√ßon d'obtenir un type diff√©rent de celui en bo√Æte est la suivante: </p><br><pre> <code class="plaintext hljs">int? x = null; var pseudoBoxed = (object)x; double? y = (double?)pseudoBoxed;</code> </pre> <br><p>  Le code fonctionne simplement parce que vous pouvez convertir un type en tout ce que vous aimez <br>  avec null. </p><br><h2 id="going-deeper-in-boxing">  Aller plus loin dans la boxe </h2><br><p>  Pour terminer, je voudrais vous parler du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">type System.Enum</a> .  Logiquement, cela devrait √™tre un type de valeur car c'est une √©num√©ration habituelle: aliaser des nombres en noms dans un langage de programmation.  Toutefois, System.Enum est un type de r√©f√©rence.  Tous les types de donn√©es enum, d√©finis dans votre champ ainsi que dans .NET Framework sont h√©rit√©s de System.Enum.  C'est un type de donn√©es de classe.  De plus, c'est une classe abstraite, h√©rit√©e de <code>System.ValueType</code> . </p><br><pre> <code class="plaintext hljs"> [Serializable] [System.Runtime.InteropServices.ComVisible(true)] public abstract class Enum : ValueType, IComparable, IFormattable, IConvertible { // ... }</code> </pre> <br><p>  Cela signifie-t-il que toutes les √©num√©rations sont allou√©es sur le SOH et lorsque nous les utilisons, nous surchargeons le tas et le GC?  En fait non, car nous les utilisons simplement.  Ensuite, nous supposons qu'il y a un pool d'√©num√©rations quelque part et nous obtenons simplement leurs instances.  Non, encore une fois.  Vous pouvez utiliser des √©num√©rations dans les structures lors du marshaling.  Les √©num√©rations sont des nombres habituels. </p><br><p>  La v√©rit√© est que CLR pirate la structure du type de donn√©es lors de sa formation s'il existe une √©num√©ration <a href="">transformant une classe en type de valeur</a> : </p><br><pre> <code class="plaintext hljs">// Check to see if the class is a valuetype; but we don't want to mark System.Enum // as a ValueType. To accomplish this, the check takes advantage of the fact // that System.ValueType and System.Enum are loaded one immediately after the // other in that order, and so if the parent MethodTable is System.ValueType and // the System.Enum MethodTable is unset, then we must be building System.Enum and // so we don't mark it as a ValueType. if(HasParent() &amp;&amp; ((g_pEnumClass != NULL &amp;&amp; GetParentMethodTable() == g_pValueTypeClass) || GetParentMethodTable() == g_pEnumClass)) { bmtProp-&gt;fIsValueClass = true; HRESULT hr = GetMDImport()-&gt;GetCustomAttributeByName(bmtInternal-&gt;pType-&gt;GetTypeDefToken(), g_CompilerServicesUnsafeValueTypeAttribute, NULL, NULL); IfFailThrow(hr); if (hr == S_OK) { SetUnsafeValueClass(); } }</code> </pre> <br><p>  Pourquoi faire √ßa?  En particulier, parce que l'id√©e d'h√©ritage - pour faire une √©num√©ration personnalis√©e, vous devez, par exemple, sp√©cifier les noms des valeurs possibles.  Cependant, il est impossible d'h√©riter des types de valeur.  Ainsi, les d√©veloppeurs l'ont con√ßu pour √™tre un type de r√©f√©rence qui peut le transformer en type de valeur lors de sa compilation. </p><br><h2 id="what-if-you-want-to-see-boxing-personally">  Et si vous voulez voir la boxe personnellement? </h2><br><p>  Heureusement, vous n'avez pas besoin d'utiliser un d√©sassembleur et d'entrer dans la jungle des codes.  Nous avons les textes de l'ensemble du noyau de la plateforme .NET et beaucoup d'entre eux sont identiques en termes de .NET Framework CLR et CoreCLR.  Vous pouvez cliquer sur les liens ci-dessous et voir imm√©diatement la mise en ≈ìuvre de la boxe: </p><br><ul><li>  Il existe un groupe distinct d'optimisations, chacune utilisant un <br>  type sp√©cifique de processeur: <br><ul><li>  <em><a href="">JIT_BoxFastMP_InlineGetThread</a></em> <br>  (AMD64 - GC multiprocesseur ou serveur, stockage local de thread implicite) </li><li>  <em><a href="">JIT_BoxFastMP</a></em> <br>  (AMD64 - GC multiprocesseur ou serveur) </li><li>  <em><a href="">JIT_BoxFastUP</a></em> <br>  (AMD64 - processeur unique ou GC Workstation) </li><li>  <em><a href="">JIT_TrialAlloc :: GenBox (..)</a></em> <br>  (x86) connect√© via JitHelpers </li></ul></li><li>  Dans les cas g√©n√©raux, un JIT ins√®re un appel d'une fonction d'aide <br>  <a href="">Compilateur :: impImportAndPushBox (..)</a> </li><li>  La version g√©n√©rique utilise moins optimis√©e <br>  <a href="">MethodTable :: Box (..)</a> <br><ul><li>  Enfin, [CopyValueClassUnchecked (..)] est appel√© <br>  ( <a href="">https://github.com/dotnet/coreclr/blob/master/src/vm/object.cpp#L1514-L1581</a> ). <br>  Son code montre pourquoi il est pr√©f√©rable de choisir des structures dont la taille peut atteindre 8 octets. </li></ul></li></ul><br><p>  Ici, la seule m√©thode est utilis√©e pour le d√©ballage: <br>  <em><a href="">JIT_Unbox (..)</a></em> , qui est un wrapper autour de <em><a href="">JIT_Unbox_Helper (..)</a></em> . </p><br><p>  En outre, il est int√©ressant de noter que ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://stackoverflow.com/questions/3743762/unboxing-does-not-create-a-copy-of-the-value-is-this-right</a> ), le d√©ballage ne signifie pas copier donn√©es au tas.  La boxe signifie passer un pointeur vers le tas tout en testant la compatibilit√© des types.  L'opcode IL suivant le d√©ballage d√©finira les actions avec cette adresse.  Les donn√©es peuvent √™tre copi√©es dans une variable locale ou la pile pour appeler une m√©thode.  Sinon, nous aurions une double copie;  d'abord lors de la copie du tas vers quelque part, puis de la copie vers l'emplacement de destination. </p><br><h2 id="questions">  Des questions </h2><br><h3 id="why-net-clr-cant-do-pooling-for-boxing-itself">  Pourquoi .NET CLR ne peut pas faire de pooling pour la boxe elle-m√™me? </h3><br><p>  Si nous parlons √† un d√©veloppeur Java, nous saurons deux choses: </p><br><ul><li>  Tous les types de valeurs en Java sont encadr√©s, ce qui signifie qu'ils ne sont pas essentiellement des types de valeurs.  Les entiers sont √©galement encadr√©s. </li><li>  Pour des raisons d'optimisation, tous les entiers de -128 √† 127 sont pris dans le pool d'objets. </li></ul><br><p>  Alors, pourquoi cela ne se produit-il pas dans .NET CLR pendant la boxe?  C'est simple.  √âtant donn√© que nous pouvons modifier le contenu d'un type de valeur encadr√©e, nous pouvons effectuer les op√©rations suivantes: </p><br><pre> <code class="plaintext hljs">object x = 1; x.GetType().GetField("m_value", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(x, 138); Console.WriteLine(x); // -&gt; 138</code> </pre> <br><p>  Ou comme √ßa (C ++ / CLI): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object^ obj)</span></span></span><span class="hljs-function"> </span></span>{ Int32^ i = (Int32^)obj; *i = <span class="hljs-number"><span class="hljs-number">138</span></span>; }</code> </pre> <br><p>  Si nous nous occupions de la mise en commun, nous changerions tous ceux en application √† 138, ce qui n'est pas bon. </p><br><p>  Le suivant est l'essence des types de valeurs dans .NET.  Ils traitent de la valeur, ce qui signifie qu'ils travaillent plus rapidement.  La boxe est rare et l'ajout de num√©ros en bo√Æte appartient au monde de la fantaisie et de la mauvaise architecture.  Ce n'est pas du tout utile. </p><br><h3 id="why-it-is-not-possible-to-do-boxing-on-stack-instead-of-the-heap-when-you-call-a-method-that-takes-an-object-type-which-is-a-value-type-in-fact">  Pourquoi il n'est pas possible de faire de la boxe sur pile au lieu du tas, lorsque vous appelez une m√©thode qui prend un type d'objet, qui est en fait un type valeur? </h3><br><p>  Si la boxe du type valeur est effectu√©e sur la pile et que la r√©f√©rence ira au tas, la r√©f√©rence √† l'int√©rieur de la m√©thode peut aller ailleurs, par exemple une m√©thode peut mettre la r√©f√©rence dans le champ d'une classe.  La m√©thode s'arr√™tera alors, et la m√©thode qui a fait de la boxe s'arr√™tera √©galement.  Par cons√©quent, la r√©f√©rence pointera vers un espace mort sur la pile. </p><br><h3 id="why-it-is-not-possible-to-use-value-type-as-a-field">  Pourquoi n'est-il pas possible d'utiliser Type de valeur comme champ? </h3><br><p>  Parfois, nous voulons utiliser une structure comme champ d'une autre structure qui utilise la premi√®re.  Ou plus simple: utilisez la structure comme champ de structure.  Ne me demandez pas pourquoi cela peut √™tre utile.  √áa ne peut pas.  Si vous utilisez une structure comme champ ou par d√©pendance avec une autre structure, vous cr√©ez une r√©cursivit√©, ce qui signifie une structure de taille infinie.  Cependant, le .NET Framework a certains endroits o√π vous pouvez le faire.  Un exemple est <code>System.Char</code> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">qui se contient</a> : </p><br><pre> <code class="plaintext hljs">public struct Char : IComparable, IConvertible { // Member Variables internal char m_value; //... }</code> </pre> <br><p>  Tous les types primitifs CLR sont con√ßus de cette fa√ßon.  Nous, simples mortels, ne pouvons pas appliquer ce comportement.  De plus, nous n'en avons pas besoin: cela est fait pour donner aux types primitifs un esprit de POO dans CLR. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Ce charper traduit du russe comme de la langue de l'auteur par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des traducteurs professionnels</a> .  Vous pouvez nous aider √† cr√©er une version traduite de ce texte dans n'importe quelle autre langue, y compris le chinois ou l'allemand, en utilisant les versions russe et anglaise du texte comme source. <br><br>  De plus, si vous voulez dire "merci", la meilleure fa√ßon que vous pouvez choisir est de nous donner une √©toile sur github ou un r√©f√©rentiel de forking <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/sidristij/dotnetbook</a> <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr439490/">https://habr.com/ru/post/fr439490/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr439480/index.html">C√©dez le passage, ou pourquoi votre CRM (et CRM) ralentit-il?</a></li>
<li><a href="../fr439482/index.html">devleads - motivation (non) financi√®re</a></li>
<li><a href="../fr439484/index.html">Obtention de donn√©es d'√©num√©ration dans une perspective Automapper</a></li>
<li><a href="../fr439486/index.html">Types de r√©f√©rence .NET vs types de valeur. Partie 1</a></li>
<li><a href="../fr439488/index.html">Enregistrement vid√©o Meetup QA</a></li>
<li><a href="../fr439492/index.html">10 conseils pour √™tre un bon leader technologique</a></li>
<li><a href="../fr439496/index.html">Comment la facturation se fait-elle: lorsque le client et le d√©veloppeur parlent des langues diff√©rentes</a></li>
<li><a href="../fr439498/index.html">Sur quel mat√©riel analyser un √©norme puits d'informations?</a></li>
<li><a href="../fr439500/index.html">Pourquoi les captchas sont-ils devenus si compliqu√©s</a></li>
<li><a href="../fr439502/index.html">Comportement ind√©fini et v√©rit√© non d√©finie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>