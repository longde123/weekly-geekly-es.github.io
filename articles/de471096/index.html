<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåï üï† ‚ùÑÔ∏è √ñffentlicher Test: L√∂sung f√ºr Datenschutz und Skalierbarkeit in Ethereum üíπ üèÇüèø üìÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Blockchain ist eine innovative Technologie, die verspricht, viele Bereiche des menschlichen Lebens zu verbessern. Es √ºbertr√§gt reale Prozesse und Prod...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√ñffentlicher Test: L√∂sung f√ºr Datenschutz und Skalierbarkeit in Ethereum</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471096/">  <b>Blockchain</b> ist eine innovative Technologie, die verspricht, viele Bereiche des menschlichen Lebens zu verbessern.  Es √ºbertr√§gt reale Prozesse und Produkte in den digitalen Raum, stellt die Geschwindigkeit und Zuverl√§ssigkeit von Finanztransaktionen sicher, senkt deren Kosten und erm√∂glicht Ihnen die Erstellung moderner DAPP-Anwendungen mithilfe intelligenter Vertr√§ge in dezentralen Netzwerken. <br><br>  Angesichts der vielen Vorteile und vielf√§ltigen Verwendungsm√∂glichkeiten der Blockchain mag es seltsam erscheinen, dass diese vielversprechende Technologie noch nicht alle Sektoren durchdrungen hat.  Das Problem ist, dass moderne dezentrale Blockchains nicht skalierbar sind.  Ethereum verarbeitet ungef√§hr 20 Transaktionen pro Sekunde, was nicht ausreicht, um die Anforderungen des heutigen dynamischen Gesch√§fts zu erf√ºllen.  Gleichzeitig trauen sich Unternehmen, die Blockchain-Technologie einsetzen, nicht, Ethereum wegen seines hohen Schutzes vor Hacking und Netzwerkfehlern aufzugeben. <br><br>  Um Dezentralisierung, Sicherheit und Skalierbarkeit in der Blockchain zu gew√§hrleisten und damit das Skalierbarkeitstrilemma zu l√∂sen, hat das Opporty-Entwicklungsteam Plasma Cash erstellt - eine untergeordnete Kette, die aus einem intelligenten Vertrag und einem privaten Netzwerk auf der Basis von Node.js besteht und ihren Status regelm√§√üig an die Stammkette √ºbertr√§gt ( Ethereum). <br><br><img src="https://habrastorage.org/webt/tc/kv/lg/tckvlgw0bbppuvkdlaght7jdwfa.jpeg"><br><a name="habracut"></a><br><h2>  Schl√ºsselprozesse bei Plasma Cash </h2><br>  <b>1. Der</b> Benutzer nennt die Funktion des Smart Contract "Einzahlung" und √ºberweist den Betrag in der ETH, den er in den Plasma Cash Token einlegen m√∂chte.  Die Smart Contract-Funktion erstellt ein Token und generiert ein Ereignis dar√ºber. <br><br>  <b>2.</b> Plasma Cash-Knoten, die die Ereignisse des Smart-Vertrags abonniert haben, erhalten ein Ereignis √ºber die Erstellung einer Einzahlung und f√ºgen dem Pool eine Transaktion √ºber die Erstellung eines Tokens hinzu. <br><br>  <b>3. In</b> regelm√§√üigen Abst√§nden nehmen spezielle Plasma Cash-Knoten alle Transaktionen aus dem Pool (bis zu 1 Million) und bilden einen Block daraus, berechnen den Merkle-Baum und dementsprechend den Hash.  Dieser Block wird zur √úberpr√ºfung an andere Knoten gesendet.  Die Knoten pr√ºfen, ob der Merkle-Hash g√ºltig ist, ob die Transaktionen g√ºltig sind (z. B. wenn der Absender des Tokens sein Eigent√ºmer ist).  Nach √úberpr√ºfung des Blocks ruft der Knoten die Funktion "submitBlock" des Smart Contract auf, in der die Nummer und der Merkle-Hash des Blocks in der Trace-Kette gespeichert sind.  Ein intelligenter Vertrag generiert ein Ereignis √ºber das erfolgreiche Hinzuf√ºgen eines Blocks.  Transaktionen werden aus dem Pool gel√∂scht. <br><br>  <b>4. Die</b> Knoten, die das Ereignis √ºber die √úbermittlung des Blocks erhalten haben, beginnen, die Transaktionen anzuwenden, die dem Block hinzugef√ºgt wurden. <br><br>  <b>5.</b> Irgendwann m√∂chte der Eigent√ºmer (oder Nicht-Eigent√ºmer) des Tokens ihn von Plasma Cash abheben.  Zu diesem Zweck ruft er die Funktion "startExit" auf und √ºbergibt Informationen zu den letzten beiden Transaktionen auf dem Token, die best√§tigen, dass er der Eigent√ºmer des Tokens ist.  Der Smart-Vertrag √ºberpr√ºft mithilfe des Merkle-Hashs, ob Transaktionen in Bl√∂cken vorliegen, und sendet ein Token an die Ausgabe, was in zwei Wochen geschehen wird. <br><br>  <b>6.</b> Wenn der Token-Auszahlungsvorgang bei Verst√∂√üen aufgetreten ist (der Token wurde nach Beginn des Auszahlungsvorgangs ausgegeben oder war der Token vor dem Auszug bereits ein Fremder), kann der Inhaber des Tokens den Auszug innerhalb von zwei Wochen widerlegen. <br><br><img src="https://habrastorage.org/webt/xm/hy/ks/xmhyksifhph5pfmw5ibsnoh_keq.jpeg"><br><br><h2>  Datenschutz wird auf zwei Arten erreicht. </h2><br>  <b>1. Die</b> Stammkette wei√ü nichts √ºber Transaktionen, die innerhalb der untergeordneten Kette gebildet und weitergeleitet werden.  Es bleiben Informationen dar√ºber, wer die ETH zu / von Plasma Cash gestartet und zur√ºckgezogen hat. <br><br>  <b>2.</b> Mit der untergeordneten Kette k√∂nnen Sie anonyme Transaktionen mit zk-SNARKs organisieren. <br><br><h2>  Technologischer Stapel </h2><br><ul><li>  NodeJS </li><li>  Redis </li><li>  Ethereum </li><li>  Soild </li></ul><br><h2>  Testen </h2><br>  Bei der Entwicklung von Plasma Cash haben wir die Geschwindigkeit des Systems getestet und die folgenden Ergebnisse erzielt: <br><br><ul><li>  Dem Pool werden bis zu 35.000 Transaktionen pro Sekunde hinzugef√ºgt. </li><li>  Im Block k√∂nnen bis zu 1.000.000 Transaktionen gespeichert werden. </li></ul><br>  Tests wurden auf den folgenden 3 Servern durchgef√ºhrt: <br><br>  <i>1. Intel Core i7-6700 Quad-Core Skylake inkl.</i>  <i>NVMe SSD - 512 GB, 64 GB DDR4-RAM</i> <br>  Es wurden 3 validierte Plasma Cash-Knoten ausgel√∂st. <br><br>  <i>2. AMD Ryzen 7 1700X Octa-Core ‚ÄûSummit Ridge‚Äú (Zen), SATA-SSD - 500 GB, 64 GB DDR4-RAM</i> <br>  Der Ropsten testnet ETH-Knoten wurde angehoben. <br>  Es wurden 3 validierte Plasma Cash-Knoten ausgel√∂st. <br><br>  <i>3. Intel Core i9-9900K Octa-Core inkl.</i>  <i>NVMe SSD - 1 TB, 64 GB DDR4-RAM</i> <br>  1 Plasma-Cash-Knoten senden wurde ausgel√∂st. <br>  Es wurden 3 validierte Plasma Cash-Knoten ausgel√∂st. <br>  Ein Test wurde gestartet, um Transaktionen zum Plasma Cash-Netzwerk hinzuzuf√ºgen. <br><br>  <b>Insgesamt:</b> 10 Plasma Cash-Knoten in einem privaten Netzwerk. <br><br><h3>  Test 1 </h3><br>  Es gibt ein Limit von 1 Million Transaktionen pro Block.  Daher fallen 1 Million Transaktionen in 2 Bl√∂cke (da das System es schafft, an den Transaktionen teilzunehmen und diese zu senden, w√§hrend sie gesendet werden). <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/VhJAtRlmXVE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Ausgangszustand: letzter Block # 7;  1 Million Transaktionen und Token werden in der Datenbank gespeichert. <br><br>  00:00 - Starten Sie das Transaktionsgenerierungsskript <br>  01:37 - 1 Million Transaktionen wurden erstellt und das Senden an den Knoten begann <br>  01:46 - Der Submit-Knoten hat 240.000 Transaktionen aus dem Pool √ºbernommen und bildet Block 8.  Wir sehen auch, dass 320.000 Transaktionen in 10 Sekunden zum Pool hinzugef√ºgt werden <br>  01:58 - Block 8 wird signiert und zur Validierung gesendet <br>  02:03 - Block 8 wird validiert und die Funktion "submitBlock" des Smart-Vertrags mit dem Merkle-Hash und der Blocknummer wird aufgerufen <br>  02:10 - Das Demo-Skript hat funktioniert und 1 Million Transaktionen in 32 Sekunden gesendet <br>  02:33 - Die Knoten erhielten Informationen dar√ºber, dass Block 8 zur Stammkette hinzugef√ºgt wurde, und begannen, 240.000 Transaktionen durchzuf√ºhren <br>  02:40 - 240.000 Transaktionen wurden aus dem Pool gel√∂scht, die sich bereits in Block 8 befinden <br>  02:56 - Submit Node nahm die verbleibenden 760.000 Transaktionen aus dem Pool und begann mit der Berechnung des Merkle-Hash- und Sign-Blocks Nr. 9 <br>  03:20 - Alle Knoten enthalten 1 Mio. 240.000 Transaktionen und Token <br>  03:35 - Block 9 wird signiert und zur Validierung an andere Knoten gesendet <br>  03:41 - Ein Netzwerkfehler ist aufgetreten <br>  04:40 - Nach einer Zeit√ºberschreitung wurde das Warten auf die Validierung von Block 9 gestoppt <br>  04:54 - Der Submit-Knoten nahm die verbleibenden 760.000 Transaktionen aus dem Pool und begann mit der Berechnung des Merkle-Hash- und Sign-Blocks Nr. 9 <br>  05:32 - Block 9 wird signiert und zur Validierung an andere Knoten gesendet <br>  05:53 - Block 9 wird validiert und an die Stammkette gesendet <br>  06:17 - Knoten erhielten Informationen dar√ºber, dass Block 9 zur Stammkette hinzugef√ºgt wurde, und begannen, 760.000 Transaktionen durchzuf√ºhren <br>  06:47 - Der Pool wurde von Transaktionen in Block 9 gel√∂scht <br>  09:06 - Alle Knoten enthalten 2 Millionen Transaktionen und Token <br><br><h3>  Test 2 </h3><br>  Es gibt ein Limit von 350.000 pro Block.  Als Ergebnis haben wir 3 Bl√∂cke. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/4BNpSYkwRvE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Ausgangszustand: letzter Block # 9;  2 Millionen Transaktionen und Token in der Datenbank gespeichert <br><br>  00:00 - Das Skript zur Transaktionsgenerierung wird bereits ausgef√ºhrt <br>  00:44 - 1 Million Transaktionen wurden erstellt und das Senden an den Knoten begann <br>  00:56 - Der Submit-Knoten hat 320.000 Transaktionen aus dem Pool √ºbernommen und bildet Block Nr. 10.  Wir sehen auch, dass 320.000 Transaktionen in 10 Sekunden zum Pool hinzugef√ºgt werden <br>  01:12 - Block Nr. 10 wird signiert und zur Validierung an andere Knoten gesendet <br>  01:18 - Das Demo-Skript hat funktioniert und 1 Million Transaktionen in 34 Sekunden gesendet <br>  01:20 - Block 10 wird validiert und an die Stammkette gesendet <br>  01:51 - Alle Knoten haben Informationen von der Stammkette erhalten, dass Block 10 hinzugef√ºgt wurde, und sie beginnen, 320.000 Transaktionen anzuwenden <br>  02:01 - Der Pool wurde f√ºr 320.000 Transaktionen gel√∂scht, die zu Block 10 hinzugef√ºgt wurden <br>  02:15 - Der Submit-Knoten hat 350.000 Transaktionen aus dem Pool √ºbernommen und bildet Block Nr. 11 <br>  02:34 - Block Nr. 11 wird signiert und zur Validierung an andere Knoten gesendet <br>  02:51 - Block Nr. 11 wird validiert und an die Stammkette gesendet <br>  02:55 - Der letzte Knoten hat Transaktionen aus Block 10 ausgef√ºhrt <br>  10:59 - Eine sehr lange Zeit in der Stammkette wurde eine Transaktion mit einer Block # 9-√úbermittlung ausgef√ºhrt, aber sie wurde abgeschlossen und alle Knoten erhielten Informationen dar√ºber und begannen mit der Ausf√ºhrung von 350.000 Transaktionen <br>  11:05 - Der Pool wurde f√ºr 320.000 Transaktionen gel√∂scht, die zu Block 11 hinzugef√ºgt wurden <br>  12:10 - Alle Knoten enthalten 1 Million 670.000 Transaktionen und Token <br>  12:17 - Der Submit-Knoten hat 330.000 Transaktionen aus dem Pool √ºbernommen und bildet Block Nr. 12 <br>  12:32 - Block Nr. 12 wird signiert und zur Validierung an andere Knoten gesendet <br>  12:39 - Block Nr. 12 wird validiert und an die Stammkette gesendet <br>  13:44 - Alle Knoten haben Informationen von der Stammkette erhalten, dass Block Nr. 12 hinzugef√ºgt wurde, und beginnen, 330.000 Transaktionen anzuwenden <br>  14:50 - Alle Knoten enthalten 2 Millionen Transaktionen und Token <br><br><h3>  Test 3 </h3><br>  Auf dem ersten und zweiten Server wurde ein Validierungsknoten durch einen √úbermittlungsknoten ersetzt. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/w5QHab3heIc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Ausgangszustand: letzter Block # 84;  0 Transaktionen und Token werden in der Datenbank gespeichert <br><br>  00:00 - Es werden 3 Skripte gestartet, die 1 Million Transaktionen generieren und senden <br>  01:38 - 1 Million Transaktionen wurden erstellt und das Senden an Submit Node # 3 begann <br>  01:50 - Submit Node # 3 hat 330.000 Transaktionen aus dem Pool genommen und bildet Block # 85 (f21).  Wir sehen auch, dass 350.000 Transaktionen in 10 Sekunden zum Pool hinzugef√ºgt werden <br>  01:53 - 1 Million Transaktionen wurden erstellt und das Senden an Submit Node # 1 begann <br>  01:50 - Submit Node # 3 hat 330.000 Transaktionen aus dem Pool genommen und bildet Block # 85 (f21).  Wir sehen auch, dass 350.000 Transaktionen in 10 Sekunden zum Pool hinzugef√ºgt werden <br>  02:01 - Submit Node # 1 hat 250.000 Transaktionen aus dem Pool genommen und bildet Block # 85 (65e) <br>  02:06 - Block Nr. 85 (f21) wird signiert und zur Validierung an andere Knoten gesendet <br>  02:08 - Das Demo-Skript f√ºr Server 3 funktioniert nicht mehr und hat in 30 Sekunden 1 Mio. Transaktionen gesendet <br>  02:14 - Block # 85 (f21) wird validiert und an die Wurzelkette gesendet <br>  02:19 - Block Nr. 85 (65e) wird signiert und zur Validierung an andere Knoten gesendet <br>  02:22 - 1 Million Transaktionen wurden erstellt und das Senden an Submit Node # 2 begann <br>  02:27 - Block # 85 (65e) wird validiert und an die Wurzelkette gesendet <br>  02:29 - Submit Node # 2 hat aus dem Pool 111855 Transaktionen entnommen und Block # 85 (256) gebildet. <br>  02:36 - Block Nr. 85 (256) wird signiert und zur Validierung an andere Knoten gesendet <br>  02:36 - Das Demo-Skript von Server Nr. 1 hat seine Arbeit beendet und 1 Mio. Transaktionen in 42,5 Sekunden gesendet <br>  02:38 - Block # 85 (256) wird validiert und an die Stammkette gesendet <br>  03:08 - Das Serverskript Nr. 2, das in 47 Sekunden 1 Million Transaktionen gesendet hat, hat seine Arbeit beendet <br>  03:38 - Alle Knoten haben Informationen von der Stammkette erhalten, dass die Bl√∂cke # 85 (f21), # 86 (65e), # 87 (256) hinzugef√ºgt wurden und beginnen, 330k, 250k, 111855 Transaktionen anzuwenden <br>  03:49 - Der Pool wurde bei 330.000, 250.000, 111855 Transaktionen gel√∂scht, die zu den Bl√∂cken Nr. 85 (f21), Nr. 86 (65e), Nr. 87 (256) hinzugef√ºgt wurden. <br>  03:59 - √úbermittlungsknoten Nr. 1 aus dem Pool 888145 Transaktionen und Formularblock Nr. 88 (214), √úbermittlungsknoten Nr. 2 aus dem Pool 750.000 Transaktionen und Formularblock Nr. 88 (50a), √úbermittlungsknoten Nr. 3 aus dem Pool 670.000 Transaktionen und bildet Block # 88 (d3b) <br>  04:44 - Block # 88 (d3b) wird signiert und zur Validierung an andere Knoten gesendet <br>  04:58 - Block # 88 (214) wird signiert und zur Validierung an andere Knoten gesendet <br>  05:11 - Block # 88 (50a) wird signiert und zur Validierung an andere Knoten gesendet <br>  05:11 - Block # 85 (d3b) wird validiert und an die Wurzelkette gesendet <br>  05:36 - Block Nr. 85 (214) wird validiert und an die Stammkette gesendet <br>  05:43 - Alle Knoten haben Informationen von der Stammkette erhalten, dass die Bl√∂cke # 88 (d3b), # 89 (214) hinzugef√ºgt wurden und beginnen, 670.000, 750.000 Transaktionen anzuwenden <br>  06:50 - Aufgrund einer Unterbrechung wurde Block Nr. 85 (50a) nicht validiert <br>  06:55 - Submit Node # 2 hat 888145 Transaktionen aus dem Pool genommen und bildet Block # 90 (50a) <br>  08:14 - Block Nr. 90 (50a) wird signiert und zur Validierung an andere Knoten gesendet <br>  09:04 - Block Nr. 90 (50a) wird validiert und an die Stammkette gesendet <br>  11:23 - Alle Knoten erhielten Informationen von der Stammkette, dass Block Nr. 90 (50a) hinzugef√ºgt wurde, und 888145 Transaktionen wurden angewendet.  Gleichzeitig hat Server Nr. 3 lange Zeit Transaktionen aus den Bl√∂cken Nr. 88 (d3b), Nr. 89 (214) angewendet. <br>  12:11 - Alle Pools sind leer <br>  13:41 - Alle Serverknoten Nr. 3 enthalten 3 Millionen Transaktionen und Token <br>  14:35 - Alle Serverknoten Nr. 1 enthalten 3 Millionen Transaktionen und Token <br>  19:24 - Alle Serverknoten Nr. 2 enthalten 3 Millionen Transaktionen und Token <br><br><h2>  Hindernisse </h2><br>  W√§hrend der Entwicklung von Plasma Cash sind wir auf folgende Probleme gesto√üen, die wir nach und nach gel√∂st haben und l√∂sen: <br><br>  <b>1.</b> Der Konflikt der Interaktion verschiedener Funktionen des Systems.  Beispielsweise blockierte die Funktion zum Hinzuf√ºgen von Transaktionen zum Pool die √úbermittlung und Validierung von Bl√∂cken und umgekehrt, was zu einem Geschwindigkeitsabfall f√ºhrte. <br><br>  <b>2.</b> Es war nicht sofort klar, wie eine gro√üe Anzahl von Transaktionen gesendet und gleichzeitig die Kosten f√ºr die Daten√ºbertragung minimiert werden sollten. <br><br>  <b>3.</b> Es war nicht klar, wie und wo Daten gespeichert werden sollten, um hohe Ergebnisse zu erzielen. <br><br>  <b>4.</b> Es war nicht klar, wie ein Netzwerk zwischen Knoten organisiert werden soll, da die Blockgr√∂√üe mit 1 Million Transaktionen etwa 100 MB betr√§gt. <br><br>  <b>5.</b> Wenn Sie im Single-Thread-Modus arbeiten, wird die Verbindung zwischen Knoten unterbrochen, wenn lange Berechnungen durchgef√ºhrt werden (z. B. Erstellen eines Merkle-Baums und Berechnen seines Hashs). <br><br><h2>  Wie sind wir damit umgegangen? </h2><br>  Die erste Version des Plasma Cash-Knotens war eine Art M√§hdrescher, der alles gleichzeitig ausf√ºhren konnte: Transaktionen akzeptieren, Bl√∂cke senden und validieren, eine API f√ºr den Zugriff auf Daten bereitstellen.  Da NodeJS urspr√ºnglich Single-Threaded war, blockierte die Berechnungsfunktion f√ºr den schweren Merkle-Baum die Funktion zum Hinzuf√ºgen von Transaktionen.  Wir haben zwei M√∂glichkeiten zur L√∂sung dieses Problems gesehen: <br><br>  <b>1.</b> F√ºhren Sie mehrere NodeJS-Prozesse aus, von denen jeder bestimmte Funktionen ausf√ºhrt. <br><br>  <b>2.</b> Verwenden Sie worker_threads und f√ºgen Sie die Ausf√ºhrung des Codes in Threads ein. <br><br>  Infolgedessen haben wir beide Optionen gleichzeitig verwendet: Einen Knoten logisch in drei Teile unterteilt, die separat, aber gleichzeitig synchron arbeiten k√∂nnen <br><br>  <b>1.</b> Senden Sie einen Knoten, der Transaktionen akzeptiert, an den Pool und erstellen Sie Bl√∂cke. <br><br>  <b>2.</b> √úberpr√ºfen des Knotens, der die G√ºltigkeit der Knoten √ºberpr√ºft. <br><br>  <b>3.</b> Knoten-API - Bietet eine API f√ºr den Zugriff auf Daten. <br><br>  Gleichzeitig k√∂nnen Sie mit cli √ºber einen Unix-Socket eine Verbindung zu jedem Knoten herstellen. <br><br>  Schwere Operationen wie die Berechnung des Merkle-Baumes haben wir in einem separaten Stream durchgef√ºhrt. <br><br>  So haben wir den normalen Betrieb aller Plasma Cash-Funktionen gleichzeitig und fehlerfrei erreicht. <br><br>  Sobald das System funktionierte, haben wir mit dem Testen der Geschwindigkeit begonnen und leider unbefriedigende Ergebnisse erzielt: 5.000 Transaktionen pro Sekunde und bis zu 50.000 Transaktionen in einem Block.  Ich musste herausfinden, was falsch implementiert wurde. <br><br>  Zun√§chst haben wir begonnen, den Kommunikationsmechanismus mit Plasma Cash zu testen, um die Spitzenleistung des Systems herauszufinden.  Zuvor haben wir geschrieben, dass der Plasma Cash-Knoten eine Unix-Socket-Schnittstelle bietet.  Es war urspr√ºnglich in Textform.  JSON-Objekte wurden mit "JSON.parse ()" und "JSON.stringify ()" gesendet. <br><br><pre><code class="plaintext hljs">```json { "action": "sendTransaction", "payload":{ "prevHash": "0x8a88cc4217745fd0b4eb161f6923235da10593be66b841d47da86b9cd95d93e0", "prevBlock": 41, "tokenId": "57570139642005649136210751546585740989890521125187435281313126554130572876445", "newOwner": "0x200eabe5b26e547446ae5821622892291632d4f4", "type": "pay", "data": "", "signature": "0xd1107d0c6df15e01e168e631a386363c72206cb75b233f8f3cf883134854967e1cd9b3306cc5c0ce58f0a7397ae9b2487501b56695fe3a3c90ec0f61c7ea4a721c" } } ```</code> </pre> <br>  Wir haben die √úbertragungsgeschwindigkeit solcher Objekte gemessen und ~ 130.000 pro Sekunde erhalten.  Sie versuchten, die Standardfunktionen durch json zu ersetzen, aber die Leistung verbesserte sich nicht.  Es muss einen V8-Motor geben, der f√ºr diese Operationen gut optimiert ist. <br><br>  Die Arbeit mit Transaktionen, Token und Bl√∂cken wurde durch Klassen ausgef√ºhrt.  Beim Erstellen solcher Klassen hat sich die Leistung um das Zweifache verringert, was darauf hinweist, dass OOP f√ºr uns nicht geeignet ist.  Ich musste alles rein funktional umschreiben. <br><br><h2>  Schreiben Sie in die Datenbank </h2><br>  Urspr√ºnglich wurde Redis f√ºr die Datenspeicherung als eine der produktivsten L√∂sungen ausgew√§hlt, die unsere Anforderungen erf√ºllen: Schl√ºsselwertspeicherung, Arbeit mit Hash-Tabellen und vieles mehr.  Wir haben den Redis-Benchmark gestartet und ~ 80.000 Operationen pro Sekunde in einem Pipelining-Modus durchgef√ºhrt. <br><br>  F√ºr eine hohe Leistung haben wir Redis feiner abgestimmt: <br><br><ul><li>  Unix-Socket-Verbindung hergestellt. </li><li>  Deaktivieren Sie das Speichern des Status auf der Festplatte (aus Gr√ºnden der Zuverl√§ssigkeit k√∂nnen Sie das Replikat konfigurieren und bereits in einem separaten Redis auf der Festplatte speichern). </li></ul><br>  In Redis ist ein Pool eine Hash-Tabelle, da wir die F√§higkeit ben√∂tigen, alle Transaktionen in einer Anfrage zu empfangen und Transaktionen einzeln zu l√∂schen.  Wir haben versucht, eine regul√§re Liste zu verwenden, diese funktioniert jedoch beim Entladen der gesamten Liste langsamer. <br><br>  Mit der Standard-NodeJS-Bibliothek erzielten Redis-Bibliotheken eine Leistung von 18.000 Transaktionen pro Sekunde.  Die Geschwindigkeit sank 9 Mal. <br><br>  Da der Benchmark uns die M√∂glichkeiten deutlich f√ºnfmal deutlicher zeigte, begannen sie zu optimieren.  Wir haben die Bibliothek auf ioredis umgestellt und eine Leistung von 25.000 pro Sekunde erzielt.  Wir haben Transaktionen einzeln mit dem Befehl `hset` hinzugef√ºgt.  Daher haben wir in Redis viele Anfragen generiert.  Es gab die Idee, Transaktionen zu Bundles zusammenzuf√ºhren und mit einem hmset-Befehl zu senden.  Das Ergebnis ist 32k pro Sekunde. <br><br>  Aus mehreren Gr√ºnden, die im Folgenden beschrieben werden, arbeiten wir mit Daten unter Verwendung von "Puffer". Wie sich herausstellte, k√∂nnen Sie zus√§tzliche Leistung erzielen, wenn Sie diese vor dem Schreiben in Text ("buffer.toString (" hex ")") √ºbersetzen.  Somit wurde die Geschwindigkeit auf 35 km / s erh√∂ht.  Im Moment haben wir beschlossen, die weitere Optimierung auszusetzen. <br><br>  Wir mussten auf das Bin√§rprotokoll umsteigen, weil: <br><br>  <b>1.</b> Das System berechnet h√§ufig Hashes, Signaturen usw. und ben√∂tigt daf√ºr Daten in `Buffer. <br><br>  <b>2.</b> Bei der √úbertragung zwischen Diensten wiegen Bin√§rdaten weniger als Text.  Wenn Sie beispielsweise einen Block mit 1 Million Transaktionen senden, k√∂nnen die Daten im Text mehr als 300 Megabyte belegen. <br><br>  <b>3.</b> Kontinuierliche Datenkonvertierung beeintr√§chtigt die Leistung. <br><br>  Aus diesem Grund haben wir unser eigenes Bin√§rprotokoll zum Speichern und √úbertragen von Daten zugrunde gelegt, das auf der Grundlage der wunderbaren Bin√§rdatenbibliothek entwickelt wurde. <br><br>  Als Ergebnis haben wir die folgenden Datenstrukturen: <br><br><h3>  - Transaktion </h3><br><pre> <code class="plaintext hljs"> ```json { prevHash: BD.types.buffer(20), prevBlock: BD.types.uint24le, tokenId: BD.types.string(null), type: BD.types.uint8, newOwner: BD.types.buffer(20), dataLength: BD.types.uint24le, data: BD.types.buffer(({current}) =&gt; current.dataLength), signature: BD.types.buffer(65), hash: BD.types.buffer(32), blockNumber: BD.types.uint24le, timestamp: BD.types.uint48le, } ```</code> </pre><br><h3>  - Token </h3><br><pre> <code class="plaintext hljs"> ```json { id: BD.types.string(null), owner: BD.types.buffer(20), block: BD.types.uint24le, amount: BD.types.string(null), } ```</code> </pre><br><h3>  - Blockieren </h3><br><pre> <code class="plaintext hljs"> ```json { number: BD.types.uint24le, merkleRootHash: BD.types.buffer(32), signature: BD.types.buffer(65), countTx: BD.types.uint24le, transactions: BD.types.array(Transaction.Protocol, ({current}) =&gt; current.countTx), timestamp: BD.types.uint48le, } ```</code> </pre><br>  Mit den √ºblichen Befehlen "BD.encode (Block, Protokoll) .slice ()" und "BD.decode (Puffer, Protokoll)" konvertieren wir die Daten in "Puffer", um sie in Redis zu speichern oder auf einen anderen Knoten zu √ºbertragen und die Daten zur√ºckzurufen. <br><br>  Wir haben auch 2 bin√§re Protokolle f√ºr die √úbertragung von Daten zwischen Diensten: <br><br>  <i>- Protokoll f√ºr die Interaktion mit Plasma Node √ºber Unix-Socket</i> <br><br><pre> <code class="plaintext hljs"> ```json { type: BD.types.uint8, messageId: BD.types.uint24le, error: BD.types.uint8, length: BD.types.uint24le, payload: BD.types.buffer(({node}) =&gt; node.length) } ```</code> </pre><br>  wo: <br><br><ul><li>  <b>`type`</b> - <b>auszuf√ºhrende</b> Aktion, zum Beispiel 1 - sendTransaction, 2 - getTransaction; </li><li>  <b>`payload`</b> - Daten, die an die entsprechende Funktion √ºbertragen werden sollen; </li><li>  <b>`messageId`</b> - Nachrichten-ID, damit die Antwort identifiziert werden kann. </li></ul><br>  <i>- Protokoll der Interaktion zwischen Knoten</i> <br><br><pre> <code class="plaintext hljs"> ```json { code: BD.types.uint8, versionProtocol: BD.types.uint24le, seq: BD.types.uint8, countChunk: BD.types.uint24le, chunkNumber: BD.types.uint24le, length: BD.types.uint24le, payload: BD.types.buffer(({node}) =&gt; node.length) } ```</code> </pre><br>  wo: <br><br><ul><li>  <b>`code`</b> - Nachrichtencode, zum Beispiel 6 - PREPARE_NEW_BLOCK, 7 - BLOCK_VALID, 8 - BLOCK_COMMIT; </li><li>  <b>`versionProtocol`</b> - Protokollversion, da Knoten mit unterschiedlichen Versionen im Netzwerk ausgel√∂st werden k√∂nnen und auf unterschiedliche Weise arbeiten k√∂nnen; </li><li>  <b>`seq`</b> - Nachrichtenkennung; </li><li>  <b>`countChunk` und`</b> <b>chunkNumber` werden</b> ben√∂tigt, um gro√üe Nachrichten aufzuteilen. </li><li>  <b>`L√§nge` und`</b> <b>Nutzlast` die</b> L√§nge und die Daten selbst. </li></ul><br>  Da wir die Daten zuvor eingegeben haben, ist das endg√ºltige System viel schneller als die "rlp" -Bibliothek von Ethereum.  Leider konnten wir es noch nicht ablehnen, da es notwendig ist, den Smart-Vertrag abzuschlie√üen, den wir in Zukunft planen. <br><br>  Wenn es uns gelungen ist, eine Geschwindigkeit von <b>35.000</b> Transaktionen pro Sekunde zu erreichen, m√ºssen wir diese auch zum optimalen Zeitpunkt verarbeiten.  Da die ungef√§hre Formationszeit des Blocks 30 Sekunden betr√§gt, m√ºssen <b>1.000.000</b> Transaktionen in den Block aufgenommen werden, was bedeutet, dass mehr als <b>100</b> MB Daten gesendet werden. <br><br>  Anfangs haben wir die Bibliothek "ethereumjs-devp2p" verwendet, um Knoten zu kommunizieren, aber sie konnte nicht mit so vielen Daten umgehen.  Infolgedessen haben wir die `ws`-Bibliothek verwendet und die bin√§re Daten√ºbertragung auf dem Websocket eingerichtet.  Nat√ºrlich sind auch beim Senden gro√üer Datenpakete Probleme aufgetreten, aber wir haben sie in Bl√∂cke unterteilt, und jetzt gibt es keine derartigen Probleme mehr. <br><br>  Auch die Bildung des Merkle-Baums und die Berechnung des Hash <b>von 1.000.000</b> Transaktionen erfordert etwa <b>10</b> Sekunden kontinuierliche Berechnung.  W√§hrend dieser Zeit kann die Verbindung mit allen Knoten unterbrochen werden.  Es wurde beschlossen, diese Berechnung in einen separaten Thread zu √ºbertragen. <br><br><h2>  Schlussfolgerungen: </h2><br>  Tats√§chlich sind unsere Ergebnisse nicht neu, aber aus irgendeinem Grund vergessen viele Experten sie w√§hrend der Entwicklung. <br><br><ul><li>  Die Verwendung der funktionalen Programmierung anstelle der objektorientierten Programmierung erh√∂ht die Leistung. </li><li>  Ein Monolith ist schlechter als eine Servicearchitektur f√ºr ein Produktionssystem auf NodeJS. </li><li>  Die Verwendung von `worker_threads` f√ºr Heavy Computing verbessert die Reaktionsf√§higkeit des Systems, insbesondere bei der Arbeit mit E / A-Vorg√§ngen. </li><li>  Unix-Socket ist stabiler und schneller als http-Anforderungen. </li><li>  Wenn Sie gro√üe Datenmengen schnell √ºber das Netzwerk √ºbertragen m√ºssen, ist es besser, Websockets zu verwenden und Bin√§rdaten zu senden, die in Bl√∂cke unterteilt sind, die weitergeleitet werden k√∂nnen, wenn sie nicht erreicht werden, und dann zu einer einzigen Nachricht zusammengef√ºhrt werden. </li></ul><br>  Wir laden Sie ein, das <b>GitHub-</b> Projekt zu besuchen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/opporty-com/Plasma-Cash/tree/new-version</a> <br><br>  Der Artikel wurde von <i>Alexander Nashivan</i> , Senior Developer von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Clever Solution Inc.,</a> <i>mitgeschrieben</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471096/">https://habr.com/ru/post/de471096/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471086/index.html">Python-Musik-Cover-Generator in Blender</a></li>
<li><a href="../de471088/index.html">Burn-out-IT-Spezialisten: 4 Geschichten von Manager, Entwickler, Produkt und Administrator. Und das Rezept von Southbridge</a></li>
<li><a href="../de471090/index.html">[Nicht] CDN verwenden</a></li>
<li><a href="../de471092/index.html">Befehl Cp: Kopieren von Dateiordnern nach * nix korrekt</a></li>
<li><a href="../de471094/index.html">Tutu.ru und der Moskauer Club der Programmierer sind am 17. Oktober zu einem Backend-Meeting eingeladen</a></li>
<li><a href="../de471098/index.html">Digitaler Durchbruch - wie es war</a></li>
<li><a href="../de471100/index.html">Interaktion zwischen Winkelkomponenten mit RxJS</a></li>
<li><a href="../de471102/index.html">Benutzerdefiniertes dynamisches DNS mit CloudFlare</a></li>
<li><a href="../de471104/index.html">Oktober IT Events Digest (Teil 2)</a></li>
<li><a href="../de471112/index.html">Dummer Grund, warum Ihre listige Bildverarbeitungsanwendung nicht funktioniert: Orientierung in EXIF</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>