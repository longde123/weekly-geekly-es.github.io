<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üàÇÔ∏è üë®üèæ‚Äçüé® üñêüèΩ Eine √úbersicht √ºber Bildsegmentierungsmethoden in der Scikit-Bildbibliothek üßëüèæ‚Äçü§ù‚ÄçüßëüèΩ üó°Ô∏è üë®‚Äçüöí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Schwellenwert 
 Dies ist der einfachste Weg, um Objekte vom Hintergrund zu trennen, indem Sie Pixel √ºber oder unter einem bestimmten Schwellenwert aus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eine √úbersicht √ºber Bildsegmentierungsmethoden in der Scikit-Bildbibliothek</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441006/"><h2>  Schwellenwert </h2><br>  Dies ist der einfachste Weg, um Objekte vom Hintergrund zu trennen, indem Sie Pixel √ºber oder unter einem bestimmten Schwellenwert ausw√§hlen.  Dies ist normalerweise n√ºtzlich, wenn wir Objekte nach ihrem Hintergrund segmentieren.  Weitere Informationen zum Schwellenwert finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Leute, die mit dem Film Terminator vertraut sind, werden wahrscheinlich zustimmen, dass es der gr√∂√üte Science-Fiction-Film der √Ñra war.  In dem Film stellte James Cameron ein interessantes Konzept visueller Effekte vor, das es den Zuschauern erm√∂glichte, sich hinter den Augen eines Cyborgs namens Terminator zu verstecken.  Dieser Effekt wurde als "Terminator Vision" (englische Terminator Vision) bekannt.  In gewisser Weise trennte er die Silhouetten von Menschen vom Hintergrund.  Das mag damals v√∂llig unangemessen klingen, aber die Bildsegmentierung ist heute ein wichtiger Bestandteil vieler Bildverarbeitungstechniken. <br><br><h2>  Bildsegmentierung </h2><br>  Es gibt eine Reihe von Bibliotheken, die f√ºr die Bildanalyse geschrieben wurden.  In diesem Artikel werden wir scikit-image, eine Python-Bildverarbeitungsbibliothek, ausf√ºhrlich behandeln. <br><br><h2>  Scikit-Bild </h2><br><img src="https://habrastorage.org/webt/g2/fm/vh/g2fmvhs1nha3wxsoofyblton3hq.png" alt="Bild"><br><br>  Scikit-image ist eine Python-Bibliothek f√ºr die Bildverarbeitung. <br><br><h2>  Installation </h2><br>  scikit-image wird wie folgt installiert: <br><br><pre><code class="python hljs">pip install -U scikit-image(Linux <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> OSX) pip install scikit-image(Windows) <span class="hljs-comment"><span class="hljs-comment"># For Conda-based distributions conda install scikit-image</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/hy/at/nt/hyatntvr-9i-awiwo2yxcvx_vym.png"><br><a name="habracut"></a><br><h2>  Python-Bild√ºbersicht </h2><br>  Bevor wir uns mit den technischen Aspekten der Bildsegmentierung befassen, ist es wichtig, sich mit dem Scikit-Bild√∂kosystem und dessen Verarbeitung vertraut zu machen. <br><br><h3>  Importieren Sie GrayScale Image aus der Skimage-Bibliothek </h3><br>  Das Skimage-Datenmodul enth√§lt mehrere integrierte Beispiele f√ºr Datens√§tze, die normalerweise im JPEG- oder PNG-Format gespeichert sind. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> skimage <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt image = data.binary_blobs() plt.imshow(image, cmap=<span class="hljs-string"><span class="hljs-string">'gray'</span></span>)</code> </pre> <br><h3>  Importieren Sie ein Farbbild aus der Skimage-Bibliothek </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> skimage <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt image = data.astronaut() plt.imshow(image)</code> </pre> <br><img src="https://habrastorage.org/webt/j2/8b/x5/j28bx5eailfqsuainwhmyskx4ek.png"><br><br><h3>  Importieren Sie ein Bild von einer externen Quelle </h3><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># The I/O module is used for importing the image from skimage import data import numpy as np import matplotlib.pyplot as plt from skimage import io image = io.imread('skimage_logo.png') plt.imshow(image);</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/bx/ho/xe/bxhoxercb7yo1soyfgduy9asuwk.png"><br><br><h3>  Laden Sie mehrere Bilder herunter </h3><br><pre> <code class="python hljs">images = io.ImageCollection(<span class="hljs-string"><span class="hljs-string">'../images/*.png:../images/*.jpg'</span></span>) print(<span class="hljs-string"><span class="hljs-string">'Type:'</span></span>, type(images)) images.files Out[]: Type: &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skimage</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">io</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">collection</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImageCollection</span></span></span><span class="hljs-class">'&gt;</span></span></code> </pre> <br><h3>  Bilder speichern </h3><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#Saving file as 'logo.png' io.imsave('logo.png', logo)</span></span></code> </pre> <br><h2>  Bildsegmentierung </h2><br>  Nachdem wir eine Vorstellung von Scikit-Image haben, bieten wir an, die Details der Bildsegmentierung zu ber√ºcksichtigen.  Bei der Bildsegmentierung wird ein digitales Bild in mehrere Segmente unterteilt, um die Bilddarstellung zu vereinfachen und / oder in etwas aussagekr√§ftigeres und leichter zu analysierendes zu √§ndern. <br><br>  In diesem Artikel werden Algorithmen f√ºr Modelle betrachtet, die sowohl mit einem Lehrer (√ºberwacht) als auch ohne Lehrer (unbeaufsichtigt) unterrichtet werden. <br><br><img src="https://habrastorage.org/webt/zi/93/f7/zi93f7mpnuzuyo_evzeu6jqzxgo.png"><br>  <i>Einige der Segmentierungsalgorithmen sind in der Scikit-Bildbibliothek verf√ºgbar.</i> <br><br>  Segmentierung mit einem Lehrer: Einige vorl√§ufige Kenntnisse, m√∂glicherweise aus menschlichen Eingaben, werden verwendet, um den Algorithmus zu steuern. <br><br>  Segmentierung ohne Lehrer: Vorkenntnisse sind nicht erforderlich.  Diese Algorithmen versuchen, die Bilder automatisch in signifikante Bereiche zu unterteilen.  Der Benutzer kann weiterhin bestimmte Parameter konfigurieren, um die gew√ºnschten Ergebnisse zu erzielen. <br><br>  Versuchen wir dies an einem Tutorial-Bild, das mit einem vordefinierten Scikit-Bild-Dataset geliefert wird. <br><br><h3>  Regelm√§√üiger Import </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.data <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.segmentation <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> seg <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.filters <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> filters <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.draw <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> draw <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.color <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> color</code> </pre> <br>  Einfache Bildgebungsfunktion <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image, nrows=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, ncols=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, cmap=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'gray'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> fig, ax = plt.subplots(nrows=nrows, ncols=ncols, figsize=(<span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>)) ax.imshow(image, cmap=<span class="hljs-string"><span class="hljs-string">'gray'</span></span>) ax.axis(<span class="hljs-string"><span class="hljs-string">'off'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fig, ax</code> </pre> <br><h3>  Bild </h3><br><pre> <code class="python hljs">text = data.page() image_show(text)</code> </pre> <br><img src="https://habrastorage.org/webt/hr/ci/ac/hrciacrdvu72qvq8yhivtvt1e78.png"><br><br>  Dieses Bild ist etwas dunkler, aber vielleicht k√∂nnen wir trotzdem einen Wert ausw√§hlen, der uns eine vern√ºnftige Segmentierung ohne komplizierte Algorithmen erm√∂glicht.  Um uns bei der Auswahl dieses Werts zu helfen, verwenden wir ein Histogramm. <br><br>  In diesem Fall zeigt das Histogramm die Anzahl der Pixel im Bild mit unterschiedlichen Intensit√§ten, die in diesem Bild gefunden wurden.  Einfach ausgedr√ºckt ist ein Histogramm ein Diagramm, in dem die X-Achse alle Werte im Bild und die Y-Achse die H√§ufigkeit dieser Werte anzeigt. <br><br><pre> <code class="python hljs">fig, ax = plt.subplots(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) ax.hist(text.ravel(), bins=<span class="hljs-number"><span class="hljs-number">32</span></span>, range=[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>]) ax.set_xlim(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/8c/ha/nc/8chanc-jg5519ms6yk0w-h90lfc.png"><br><br>  Unser Beispiel stellte sich als 8-Bit-Bild heraus, sodass wir 256 m√∂gliche Werte entlang der X-Achse haben. Das Histogramm zeigt, dass eine Konzentration von ziemlich hellen Pixeln vorliegt (0: Schwarz, 255: Wei√ü).  Dies ist h√∂chstwahrscheinlich unser ziemlich heller Texthintergrund, aber der Rest ist etwas verschwommen.  Ein ideales Segmentierungshistogramm w√§re bimodal, sodass wir eine Zahl genau in der Mitte ausw√§hlen k√∂nnen.  Versuchen wir nun, einige segmentierte Bilder basierend auf einem einfachen Schwellenwert zu erstellen. <br><br><h3>  Kontrollierte Schwelle </h3><br>  Da wir selbst einen Schwellenwert w√§hlen, nennen wir ihn einen kontrollierten Schwellenwert. <br><br><pre> <code class="python hljs">text_segmented = text &gt; (value concluded <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> histogram ie <span class="hljs-number"><span class="hljs-number">50</span></span>,<span class="hljs-number"><span class="hljs-number">70</span></span>,<span class="hljs-number"><span class="hljs-number">120</span></span> ) image_show(text_segmented);</code> </pre> <br><table><tbody><tr><td><img src="https://habrastorage.org/webt/iv/2l/gr/iv2lgrmmcgef-0geutdoybn85t0.png"></td><td><img src="https://habrastorage.org/webt/rl/k3/on/rlk3oneyt6yvcuq9mqkwel7jg3k.png"></td><td><img src="https://habrastorage.org/webt/e5/o8/fw/e5o8fwm7cs7xzneo-v29k1_vf7e.png"></td></tr></tbody></table><br>  <i>Links: Text&gt; 50 |</i>  <i>Mitte: Text&gt; 70 |</i>  <i>Rechts: Text&gt; 120</i> <br><br>  Wir haben keine perfekten Ergebnisse erzielt, da der Schatten links Probleme verursacht.  Versuchen wir es jetzt mit der unbeaufsichtigten Schwelle. <br><br><h3>  Unkontrollierte Schwelle </h3><br>  Unkontrollierter Schwellenwert Scikit-image verf√ºgt √ºber eine Reihe automatischer Schwellenwertbestimmungsmethoden, die bei der Auswahl des optimalen Schwellenwerts keine Eingabe erfordern.  Hier sind einige der Methoden: otsu, li, local. <br><br><pre> <code class="python hljs">text_threshold = filters.threshold_ <span class="hljs-comment"><span class="hljs-comment"># Hit tab with the cursor after the underscore to get all the methods. image_show(text &lt; text_threshold);</span></span></code> </pre> <br><table><tbody><tr><td><img src="https://habrastorage.org/webt/zo/zb/ne/zozbnecnzak8i_-chy9ghhwa7e0.png"></td><td><img src="https://habrastorage.org/webt/h0/ik/-m/h0ik-mxys3qwdruh-gefraebnto.png"></td></tr></tbody></table><br>  <i>Links otsu ||</i>  <i>Richtig: li</i> <br><br>  Im Fall von local m√ºssen wir auch block_size angeben.  Der Versatz hilft, das Bild f√ºr bessere Ergebnisse anzupassen. <br><br><pre> <code class="python hljs">text_threshold = filters.threshold_local(text,block_size=<span class="hljs-number"><span class="hljs-number">51</span></span>, offset=<span class="hljs-number"><span class="hljs-number">10</span></span>) image_show(text &gt; text_threshold);</code> </pre> <br><img src="https://habrastorage.org/webt/en/ns/zp/ennszp_rpslshqnd0y78mqax76w.png"><br><br>  Diese Methode ergibt einen ziemlich guten Effekt.  Zu einem gro√üen Teil kann man die lauten Regionen loswerden. <br><br><h2>  Segmentierung mit einem Algorithmus f√ºr ein Modell mit einem Lehrer </h2><br>  Thresholding ist ein sehr einfacher Segmentierungsprozess, der bei kontrastreichen Bildern, f√ºr die wir erweiterte Tools ben√∂tigen, nicht ordnungsgem√§√ü funktioniert. <br><br>  In diesem Abschnitt verwenden wir ein Beispielbild, das frei verf√ºgbar ist, und versuchen, den Kopfteil mithilfe von Methoden mit dem Lehrer zu segmentieren. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># import the image from skimage import io image = io.imread('girl.jpg') plt.imshow(image);</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/g6/dw/ga/g6dwgagldj71bqemwgosylqkusw.png"><br><br>  <i>Bevor Sie eine Bildsegmentierung durchf√ºhren, wird empfohlen, mit einigen Filtern Rauschen zu entfernen.</i> <br><br>  In unserem Fall weist das Bild jedoch kein signifikantes Rauschen auf, sodass wir es so akzeptieren, wie es ist.  Der n√§chste Schritt besteht darin, das Bild mit rgb2gray in Graustufen zu konvertieren. <br><br><pre> <code class="python hljs">image_gray = color.rgb2gray(image) image_show(image_gray);</code> </pre> <br><img src="https://habrastorage.org/webt/qx/jl/qs/qxjlqspqdsqiaxu6px23j4q7mvs.png"><br><br>  Wir werden zwei Segmentierungsmethoden verwenden, die nach v√∂llig unterschiedlichen Prinzipien arbeiten. <br><br><h3>  Aktive Kontursegmentierung </h3><br>  Die Segmentierung des aktiven Pfads wird auch als Schlange bezeichnet und mithilfe eines benutzerdefinierten Pfads oder einer benutzerdefinierten Linie um einen interessierenden Bereich initialisiert. Anschlie√üend wird dieser Pfad langsam komprimiert und durch Licht und Kanten angezogen oder abgesto√üen. <br><br>  Zeichnen wir f√ºr unser Beispielbild einen Kreis um den menschlichen Kopf, um die Schlange zu initialisieren. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">circle_points</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolution, center, radius)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Generate points which define a circle on an image.Centre refers to the centre of the circle """</span></span> radians = np.linspace(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>*np.pi, resolution) c = center[<span class="hljs-number"><span class="hljs-number">1</span></span>] + radius*np.cos(radians)<span class="hljs-comment"><span class="hljs-comment">#polar co-ordinates r = center[0] + radius*np.sin(radians) return np.array([c, r]).T # Exclude last point because a closed path should not have duplicate points points = circle_points(200, [80, 250], 80)[:-1]</span></span></code> </pre> <br>  Die obigen Berechnungen berechnen die x- und y-Koordinaten der Punkte am Umfang des Kreises.  Da wir eine Aufl√∂sung von 200 angegeben haben, werden 200 solcher Punkte berechnet. <br><br><pre> <code class="python hljs">fig, ax = image_show(image) ax.plot(points[:, <span class="hljs-number"><span class="hljs-number">0</span></span>], points[:, <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'--r'</span></span>, lw=<span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/4o/f1/bu/4of1buz3h2boatz5lpfpnlogh6g.png"><br><br>  Der Algorithmus segmentiert dann das Gesicht der Person vom Rest des Bildes und passt eine geschlossene Kurve an die R√§nder des Gesichts an. <br><br><img src="https://habrastorage.org/webt/z_/o1/ep/z_o1epmu9zcrxuyju7tr85p9n1o.png"><br><br>  Wir k√∂nnen Parameter namens Alpha und Beta konfigurieren.  H√∂here Alpha-Werte f√ºhren dazu, dass sich die Kurve schneller zusammenzieht, w√§hrend Beta die Kurve glatter macht. <br><br><pre> <code class="python hljs">snake = seg.active_contour(image_gray, points,alpha=<span class="hljs-number"><span class="hljs-number">0.06</span></span>,beta=<span class="hljs-number"><span class="hljs-number">0.3</span></span>) fig, ax = image_show(image) ax.plot(points[:, <span class="hljs-number"><span class="hljs-number">0</span></span>], points[:, <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'--r'</span></span>, lw=<span class="hljs-number"><span class="hljs-number">3</span></span>) ax.plot(snake[:, <span class="hljs-number"><span class="hljs-number">0</span></span>], snake[:, <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'-b'</span></span>, lw=<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/ne/pw/vw/nepwvw8xqanbj61fikjg6qorxq0.png"><br><br><h3>  Random Walker Segmentierung </h3><br>  Bei dieser Methode erfolgt die Segmentierung mithilfe einer interaktiven Beschriftung, die als Beschriftungen bezeichnet wird.  Indem Sie jedes Pixel auf das Etikett zeichnen, f√ºr das die h√∂chste Wahrscheinlichkeit berechnet wird, erhalten Sie eine qualitativ hochwertige Bildsegmentierung.  Weitere Details zu dieser Methode finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser</a> Arbeit. <br><br>  Als n√§chstes werden wir wieder die vorherigen Werte aus unserem Beispiel verwenden.  Wir h√§tten verschiedene Initialisierungen durchf√ºhren k√∂nnen, aber der Einfachheit halber bleiben wir beim Prinzip der Kreise. <br><br><pre> <code class="python hljs">image_labels = np.zeros(image_gray.shape, dtype=np.uint8)</code> </pre> <br>  Der Random-Pass-Algorithmus akzeptiert Beschriftungen als Eingabe.  Somit haben wir einen gro√üen Kreis, der das gesamte Gesicht der Person bedeckt, und einen weiteren kleineren Kreis nahe der Mitte des Gesichts. <br><br><pre> <code class="python hljs">indices = draw.circle_perimeter(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">250</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>)<span class="hljs-comment"><span class="hljs-comment">#from here image_labels[indices] = 1 image_labels[points[:, 1].astype(np.int), points[:, 0].astype(np.int)] = 2 image_show(image_labels);</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/ol/2n/nw/ol2nnwq0un_qzngiv25atfh3d5g.png"><br>  Verwenden wir nun Random Walker und sehen, was passiert. <br><br><pre> <code class="python hljs">image_segmented = seg.random_walker(image_gray, image_labels) <span class="hljs-comment"><span class="hljs-comment"># Check our results fig, ax = image_show(image_gray) ax.imshow(image_segmented == 1, alpha=0.3);</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/au/bs/jn/aubsjn1b1uedkiorghu5izwbbha.png"><br><br>  Das Ergebnis ist nicht das beste, die R√§nder des Gesichts blieben unerreicht.  Um diese Situation zu korrigieren, k√∂nnen wir den Durchgangsparameter anpassen, bis wir das gew√ºnschte Ergebnis erhalten.  Nach mehreren Versuchen haben wir den Wert auf 3000 gesetzt, was recht gut funktioniert. <br><br><pre> <code class="plaintext hljs">image_segmented = seg.random_walker(image_gray, image_labels, beta = 3000) # Check our results fig, ax = image_show(image_gray) ax.imshow(image_segmented == 1, alpha=0.3);</code> </pre><br><img src="https://habrastorage.org/webt/ii/4s/h1/ii4sh1n0rxcwgply9xmafyerk5a.png"><br><br>  Dies ist alles f√ºr die Segmentierung mit dem Lehrer, wo wir bestimmte Eingabedaten bereitstellen und einige Parameter konfigurieren mussten.  Es ist jedoch nicht immer m√∂glich, dass eine Person das Bild betrachtet und dann entscheidet, welchen Beitrag sie leisten soll und wo sie anfangen soll.  Gl√ºcklicherweise haben wir f√ºr solche Situationen unkontrollierte Segmentierungsmethoden. <br><br><h2>  Segmentierung ohne Lehrer </h2><br>  F√ºr die Segmentierung ohne Lehrer sind keine Vorkenntnisse erforderlich.  Stellen Sie sich ein Bild vor, das so gro√ü ist, dass nicht alle Pixel gleichzeitig angezeigt werden k√∂nnen.  In solchen F√§llen kann die Segmentierung ohne Lehrer das Bild in mehrere Unterregionen aufteilen, sodass Sie anstelle von Millionen von Pixeln Dutzende oder Hunderte von Bereichen haben.  Schauen wir uns zwei solcher Algorithmen an: <br><br><h3>  Einfaches lineares iteratives Clustering </h3><br>  Die Methode (English Simple Linear Iterative Clustering oder SLIC) verwendet einen Algorithmus f√ºr maschinelles Lernen namens K-Means.  Es nimmt alle Pixelwerte des Bildes und versucht, sie in eine bestimmte Anzahl von Subdom√§nen zu unterteilen.  Lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese</a> Arbeit f√ºr detaillierte Informationen. <br><br>  SLIC arbeitet mit verschiedenen Farben, daher verwenden wir das Originalbild. <br><br><pre> <code class="python hljs">image_slic = seg.slic(image,n_segments=<span class="hljs-number"><span class="hljs-number">155</span></span>)</code> </pre> <br>  Alles, was wir tun m√ºssen, ist einfach einen Durchschnittswert f√ºr jedes Segment festzulegen, das wir finden, wodurch es eher wie ein Bild aussieht. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># label2rgb replaces each discrete label with the average interior color image_show(color.label2rgb(image_slic, image, kind='avg'));</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/7_/kn/b4/7_knb4b5fgefv0vsg3bed3dtx3o.png"><br><br>  Wir haben dieses Bild von 512 * 512 = 262.000 Pixel auf 155 Segmente reduziert. <br><br><h3>  Felzenszwalb </h3><br>  Diese Methode verwendet auch einen Algorithmus f√ºr maschinelles Lernen, der als Minimum-Spanning-Tree-Clustering bezeichnet wird.  Felzenszwaib gibt nicht die genaue Anzahl der Cluster an, in die das Bild unterteilt wird.  Er wird so viele Cluster generieren, wie er daf√ºr f√ºr richtig h√§lt. <br><br><pre> <code class="python hljs">image_felzenszwalb = seg.felzenszwalb(image) image_show(image_felzenszwalb);</code> </pre> <br><img src="https://habrastorage.org/webt/ht/bk/ao/htbkaotqhcgg_xlbys0_z_0bwie.png"><br><br>  Es gibt zu viele Regionen im Bild.  Z√§hlen wir die Anzahl der eindeutigen Segmente. <br><br><pre> <code class="python hljs">np.unique(image_felzenszwalb).size <span class="hljs-number"><span class="hljs-number">3368</span></span></code> </pre> <br>  Lassen Sie uns sie nun mit dem Durchschnittswert √ºber dem Segment neu einf√§rben, wie wir es im SLIC-Algorithmus getan haben. <br><br><pre> <code class="python hljs">image_felzenszwalb_colored = color.label2rgb(image_felzenszwalb, image, kind=<span class="hljs-string"><span class="hljs-string">'avg'</span></span>) image_show(image_felzenszwalb_colored);</code> </pre> <br>  Jetzt bekommen wir weniger Segmente.  Wenn wir noch weniger Segmente wollen, k√∂nnen wir den Skalierungsparameter √§ndern.  Dieser Ansatz wird manchmal als √úber-Segmentierung bezeichnet. <br><br><img src="https://habrastorage.org/webt/dw/-2/3-/dw-23-xllphmwajmn1sg-sk-nws.png"><br><br>  Dies √§hnelt eher einem posterisierten Bild, bei dem es sich im Wesentlichen nur um eine Verringerung der Anzahl der Farben handelt.  Um sie wieder zu kombinieren (RAG). <br><br><h2>  Fazit </h2><br>  Die Bildsegmentierung ist ein sehr wichtiger Schritt in der Bildverarbeitung.  Dies ist ein aktives Forschungsgebiet mit einer Vielzahl von Anwendungen, die von Computer Vision √ºber medizinische Bilder bis hin zu Verkehrs- und Video√ºberwachung reichen.  Python bietet eine robuste Scikit-Bildbibliothek mit einer Vielzahl von Bildverarbeitungsalgorithmen.  Es ist kostenlos und ohne Einschr√§nkungen verf√ºgbar und wird von einer aktiven Community unterst√ºtzt.  Ich empfehle Ihnen, die Dokumentation zu lesen.  Den Originalartikel finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441006/">https://habr.com/ru/post/de441006/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440994/index.html">K√ºmmern Sie sich schon in jungen Jahren um Ihr Unternehmen oder wie Sie ein schlankes Startup schaffen</a></li>
<li><a href="../de440998/index.html">OpenStack erweitert das Portfolio und aktiviert CI / CD</a></li>
<li><a href="../de441000/index.html">Promotion: Bringen Sie ein Papierbuch mit und erhalten Sie einen Rabatt auf jeden ONYX BOOX E-Reader</a></li>
<li><a href="../de441002/index.html">Was den 3. Turing-Test beendete: Statistiken, interessante Dialoge und Gesamteindruck</a></li>
<li><a href="../de441004/index.html">Splunk verl√§sst Russland (komplett)</a></li>
<li><a href="../de441008/index.html">Kaninchen MQ im Verarbeitungssystem der Bewohner</a></li>
<li><a href="../de441010/index.html">Geh runter auf die sterbliche Erde ...</a></li>
<li><a href="../de441012/index.html">Interessante Fakten √ºber die Geschichte des chinesischen Mondprogramms und der Weltraummission Chang'e-4</a></li>
<li><a href="../de441014/index.html">Low-Budget-Stereo-Rendering in wenigen Codezeilen (Stereogramm, Anaglyphe, Stereoskop)</a></li>
<li><a href="../de441018/index.html">Tools zur Entwicklung und Spezifikation von NanoCAD Mechanics-Programmen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>