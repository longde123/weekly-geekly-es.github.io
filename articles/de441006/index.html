<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈂️ 👨🏾‍🎨 🖐🏽 Eine Übersicht über Bildsegmentierungsmethoden in der Scikit-Bildbibliothek 🧑🏾‍🤝‍🧑🏽 🗡️ 👨‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Schwellenwert 
 Dies ist der einfachste Weg, um Objekte vom Hintergrund zu trennen, indem Sie Pixel über oder unter einem bestimmten Schwellenwert aus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eine Übersicht über Bildsegmentierungsmethoden in der Scikit-Bildbibliothek</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441006/"><h2>  Schwellenwert </h2><br>  Dies ist der einfachste Weg, um Objekte vom Hintergrund zu trennen, indem Sie Pixel über oder unter einem bestimmten Schwellenwert auswählen.  Dies ist normalerweise nützlich, wenn wir Objekte nach ihrem Hintergrund segmentieren.  Weitere Informationen zum Schwellenwert finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Leute, die mit dem Film Terminator vertraut sind, werden wahrscheinlich zustimmen, dass es der größte Science-Fiction-Film der Ära war.  In dem Film stellte James Cameron ein interessantes Konzept visueller Effekte vor, das es den Zuschauern ermöglichte, sich hinter den Augen eines Cyborgs namens Terminator zu verstecken.  Dieser Effekt wurde als "Terminator Vision" (englische Terminator Vision) bekannt.  In gewisser Weise trennte er die Silhouetten von Menschen vom Hintergrund.  Das mag damals völlig unangemessen klingen, aber die Bildsegmentierung ist heute ein wichtiger Bestandteil vieler Bildverarbeitungstechniken. <br><br><h2>  Bildsegmentierung </h2><br>  Es gibt eine Reihe von Bibliotheken, die für die Bildanalyse geschrieben wurden.  In diesem Artikel werden wir scikit-image, eine Python-Bildverarbeitungsbibliothek, ausführlich behandeln. <br><br><h2>  Scikit-Bild </h2><br><img src="https://habrastorage.org/webt/g2/fm/vh/g2fmvhs1nha3wxsoofyblton3hq.png" alt="Bild"><br><br>  Scikit-image ist eine Python-Bibliothek für die Bildverarbeitung. <br><br><h2>  Installation </h2><br>  scikit-image wird wie folgt installiert: <br><br><pre><code class="python hljs">pip install -U scikit-image(Linux <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> OSX) pip install scikit-image(Windows) <span class="hljs-comment"><span class="hljs-comment"># For Conda-based distributions conda install scikit-image</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/hy/at/nt/hyatntvr-9i-awiwo2yxcvx_vym.png"><br><a name="habracut"></a><br><h2>  Python-Bildübersicht </h2><br>  Bevor wir uns mit den technischen Aspekten der Bildsegmentierung befassen, ist es wichtig, sich mit dem Scikit-Bildökosystem und dessen Verarbeitung vertraut zu machen. <br><br><h3>  Importieren Sie GrayScale Image aus der Skimage-Bibliothek </h3><br>  Das Skimage-Datenmodul enthält mehrere integrierte Beispiele für Datensätze, die normalerweise im JPEG- oder PNG-Format gespeichert sind. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> skimage <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt image = data.binary_blobs() plt.imshow(image, cmap=<span class="hljs-string"><span class="hljs-string">'gray'</span></span>)</code> </pre> <br><h3>  Importieren Sie ein Farbbild aus der Skimage-Bibliothek </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> skimage <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt image = data.astronaut() plt.imshow(image)</code> </pre> <br><img src="https://habrastorage.org/webt/j2/8b/x5/j28bx5eailfqsuainwhmyskx4ek.png"><br><br><h3>  Importieren Sie ein Bild von einer externen Quelle </h3><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># The I/O module is used for importing the image from skimage import data import numpy as np import matplotlib.pyplot as plt from skimage import io image = io.imread('skimage_logo.png') plt.imshow(image);</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/bx/ho/xe/bxhoxercb7yo1soyfgduy9asuwk.png"><br><br><h3>  Laden Sie mehrere Bilder herunter </h3><br><pre> <code class="python hljs">images = io.ImageCollection(<span class="hljs-string"><span class="hljs-string">'../images/*.png:../images/*.jpg'</span></span>) print(<span class="hljs-string"><span class="hljs-string">'Type:'</span></span>, type(images)) images.files Out[]: Type: &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skimage</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">io</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">collection</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImageCollection</span></span></span><span class="hljs-class">'&gt;</span></span></code> </pre> <br><h3>  Bilder speichern </h3><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#Saving file as 'logo.png' io.imsave('logo.png', logo)</span></span></code> </pre> <br><h2>  Bildsegmentierung </h2><br>  Nachdem wir eine Vorstellung von Scikit-Image haben, bieten wir an, die Details der Bildsegmentierung zu berücksichtigen.  Bei der Bildsegmentierung wird ein digitales Bild in mehrere Segmente unterteilt, um die Bilddarstellung zu vereinfachen und / oder in etwas aussagekräftigeres und leichter zu analysierendes zu ändern. <br><br>  In diesem Artikel werden Algorithmen für Modelle betrachtet, die sowohl mit einem Lehrer (überwacht) als auch ohne Lehrer (unbeaufsichtigt) unterrichtet werden. <br><br><img src="https://habrastorage.org/webt/zi/93/f7/zi93f7mpnuzuyo_evzeu6jqzxgo.png"><br>  <i>Einige der Segmentierungsalgorithmen sind in der Scikit-Bildbibliothek verfügbar.</i> <br><br>  Segmentierung mit einem Lehrer: Einige vorläufige Kenntnisse, möglicherweise aus menschlichen Eingaben, werden verwendet, um den Algorithmus zu steuern. <br><br>  Segmentierung ohne Lehrer: Vorkenntnisse sind nicht erforderlich.  Diese Algorithmen versuchen, die Bilder automatisch in signifikante Bereiche zu unterteilen.  Der Benutzer kann weiterhin bestimmte Parameter konfigurieren, um die gewünschten Ergebnisse zu erzielen. <br><br>  Versuchen wir dies an einem Tutorial-Bild, das mit einem vordefinierten Scikit-Bild-Dataset geliefert wird. <br><br><h3>  Regelmäßiger Import </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.data <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.segmentation <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> seg <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.filters <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> filters <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.draw <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> draw <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.color <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> color</code> </pre> <br>  Einfache Bildgebungsfunktion <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image, nrows=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, ncols=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, cmap=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'gray'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> fig, ax = plt.subplots(nrows=nrows, ncols=ncols, figsize=(<span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>)) ax.imshow(image, cmap=<span class="hljs-string"><span class="hljs-string">'gray'</span></span>) ax.axis(<span class="hljs-string"><span class="hljs-string">'off'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fig, ax</code> </pre> <br><h3>  Bild </h3><br><pre> <code class="python hljs">text = data.page() image_show(text)</code> </pre> <br><img src="https://habrastorage.org/webt/hr/ci/ac/hrciacrdvu72qvq8yhivtvt1e78.png"><br><br>  Dieses Bild ist etwas dunkler, aber vielleicht können wir trotzdem einen Wert auswählen, der uns eine vernünftige Segmentierung ohne komplizierte Algorithmen ermöglicht.  Um uns bei der Auswahl dieses Werts zu helfen, verwenden wir ein Histogramm. <br><br>  In diesem Fall zeigt das Histogramm die Anzahl der Pixel im Bild mit unterschiedlichen Intensitäten, die in diesem Bild gefunden wurden.  Einfach ausgedrückt ist ein Histogramm ein Diagramm, in dem die X-Achse alle Werte im Bild und die Y-Achse die Häufigkeit dieser Werte anzeigt. <br><br><pre> <code class="python hljs">fig, ax = plt.subplots(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) ax.hist(text.ravel(), bins=<span class="hljs-number"><span class="hljs-number">32</span></span>, range=[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>]) ax.set_xlim(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/8c/ha/nc/8chanc-jg5519ms6yk0w-h90lfc.png"><br><br>  Unser Beispiel stellte sich als 8-Bit-Bild heraus, sodass wir 256 mögliche Werte entlang der X-Achse haben. Das Histogramm zeigt, dass eine Konzentration von ziemlich hellen Pixeln vorliegt (0: Schwarz, 255: Weiß).  Dies ist höchstwahrscheinlich unser ziemlich heller Texthintergrund, aber der Rest ist etwas verschwommen.  Ein ideales Segmentierungshistogramm wäre bimodal, sodass wir eine Zahl genau in der Mitte auswählen können.  Versuchen wir nun, einige segmentierte Bilder basierend auf einem einfachen Schwellenwert zu erstellen. <br><br><h3>  Kontrollierte Schwelle </h3><br>  Da wir selbst einen Schwellenwert wählen, nennen wir ihn einen kontrollierten Schwellenwert. <br><br><pre> <code class="python hljs">text_segmented = text &gt; (value concluded <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> histogram ie <span class="hljs-number"><span class="hljs-number">50</span></span>,<span class="hljs-number"><span class="hljs-number">70</span></span>,<span class="hljs-number"><span class="hljs-number">120</span></span> ) image_show(text_segmented);</code> </pre> <br><table><tbody><tr><td><img src="https://habrastorage.org/webt/iv/2l/gr/iv2lgrmmcgef-0geutdoybn85t0.png"></td><td><img src="https://habrastorage.org/webt/rl/k3/on/rlk3oneyt6yvcuq9mqkwel7jg3k.png"></td><td><img src="https://habrastorage.org/webt/e5/o8/fw/e5o8fwm7cs7xzneo-v29k1_vf7e.png"></td></tr></tbody></table><br>  <i>Links: Text&gt; 50 |</i>  <i>Mitte: Text&gt; 70 |</i>  <i>Rechts: Text&gt; 120</i> <br><br>  Wir haben keine perfekten Ergebnisse erzielt, da der Schatten links Probleme verursacht.  Versuchen wir es jetzt mit der unbeaufsichtigten Schwelle. <br><br><h3>  Unkontrollierte Schwelle </h3><br>  Unkontrollierter Schwellenwert Scikit-image verfügt über eine Reihe automatischer Schwellenwertbestimmungsmethoden, die bei der Auswahl des optimalen Schwellenwerts keine Eingabe erfordern.  Hier sind einige der Methoden: otsu, li, local. <br><br><pre> <code class="python hljs">text_threshold = filters.threshold_ <span class="hljs-comment"><span class="hljs-comment"># Hit tab with the cursor after the underscore to get all the methods. image_show(text &lt; text_threshold);</span></span></code> </pre> <br><table><tbody><tr><td><img src="https://habrastorage.org/webt/zo/zb/ne/zozbnecnzak8i_-chy9ghhwa7e0.png"></td><td><img src="https://habrastorage.org/webt/h0/ik/-m/h0ik-mxys3qwdruh-gefraebnto.png"></td></tr></tbody></table><br>  <i>Links otsu ||</i>  <i>Richtig: li</i> <br><br>  Im Fall von local müssen wir auch block_size angeben.  Der Versatz hilft, das Bild für bessere Ergebnisse anzupassen. <br><br><pre> <code class="python hljs">text_threshold = filters.threshold_local(text,block_size=<span class="hljs-number"><span class="hljs-number">51</span></span>, offset=<span class="hljs-number"><span class="hljs-number">10</span></span>) image_show(text &gt; text_threshold);</code> </pre> <br><img src="https://habrastorage.org/webt/en/ns/zp/ennszp_rpslshqnd0y78mqax76w.png"><br><br>  Diese Methode ergibt einen ziemlich guten Effekt.  Zu einem großen Teil kann man die lauten Regionen loswerden. <br><br><h2>  Segmentierung mit einem Algorithmus für ein Modell mit einem Lehrer </h2><br>  Thresholding ist ein sehr einfacher Segmentierungsprozess, der bei kontrastreichen Bildern, für die wir erweiterte Tools benötigen, nicht ordnungsgemäß funktioniert. <br><br>  In diesem Abschnitt verwenden wir ein Beispielbild, das frei verfügbar ist, und versuchen, den Kopfteil mithilfe von Methoden mit dem Lehrer zu segmentieren. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># import the image from skimage import io image = io.imread('girl.jpg') plt.imshow(image);</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/g6/dw/ga/g6dwgagldj71bqemwgosylqkusw.png"><br><br>  <i>Bevor Sie eine Bildsegmentierung durchführen, wird empfohlen, mit einigen Filtern Rauschen zu entfernen.</i> <br><br>  In unserem Fall weist das Bild jedoch kein signifikantes Rauschen auf, sodass wir es so akzeptieren, wie es ist.  Der nächste Schritt besteht darin, das Bild mit rgb2gray in Graustufen zu konvertieren. <br><br><pre> <code class="python hljs">image_gray = color.rgb2gray(image) image_show(image_gray);</code> </pre> <br><img src="https://habrastorage.org/webt/qx/jl/qs/qxjlqspqdsqiaxu6px23j4q7mvs.png"><br><br>  Wir werden zwei Segmentierungsmethoden verwenden, die nach völlig unterschiedlichen Prinzipien arbeiten. <br><br><h3>  Aktive Kontursegmentierung </h3><br>  Die Segmentierung des aktiven Pfads wird auch als Schlange bezeichnet und mithilfe eines benutzerdefinierten Pfads oder einer benutzerdefinierten Linie um einen interessierenden Bereich initialisiert. Anschließend wird dieser Pfad langsam komprimiert und durch Licht und Kanten angezogen oder abgestoßen. <br><br>  Zeichnen wir für unser Beispielbild einen Kreis um den menschlichen Kopf, um die Schlange zu initialisieren. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">circle_points</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolution, center, radius)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Generate points which define a circle on an image.Centre refers to the centre of the circle """</span></span> radians = np.linspace(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>*np.pi, resolution) c = center[<span class="hljs-number"><span class="hljs-number">1</span></span>] + radius*np.cos(radians)<span class="hljs-comment"><span class="hljs-comment">#polar co-ordinates r = center[0] + radius*np.sin(radians) return np.array([c, r]).T # Exclude last point because a closed path should not have duplicate points points = circle_points(200, [80, 250], 80)[:-1]</span></span></code> </pre> <br>  Die obigen Berechnungen berechnen die x- und y-Koordinaten der Punkte am Umfang des Kreises.  Da wir eine Auflösung von 200 angegeben haben, werden 200 solcher Punkte berechnet. <br><br><pre> <code class="python hljs">fig, ax = image_show(image) ax.plot(points[:, <span class="hljs-number"><span class="hljs-number">0</span></span>], points[:, <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'--r'</span></span>, lw=<span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/4o/f1/bu/4of1buz3h2boatz5lpfpnlogh6g.png"><br><br>  Der Algorithmus segmentiert dann das Gesicht der Person vom Rest des Bildes und passt eine geschlossene Kurve an die Ränder des Gesichts an. <br><br><img src="https://habrastorage.org/webt/z_/o1/ep/z_o1epmu9zcrxuyju7tr85p9n1o.png"><br><br>  Wir können Parameter namens Alpha und Beta konfigurieren.  Höhere Alpha-Werte führen dazu, dass sich die Kurve schneller zusammenzieht, während Beta die Kurve glatter macht. <br><br><pre> <code class="python hljs">snake = seg.active_contour(image_gray, points,alpha=<span class="hljs-number"><span class="hljs-number">0.06</span></span>,beta=<span class="hljs-number"><span class="hljs-number">0.3</span></span>) fig, ax = image_show(image) ax.plot(points[:, <span class="hljs-number"><span class="hljs-number">0</span></span>], points[:, <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'--r'</span></span>, lw=<span class="hljs-number"><span class="hljs-number">3</span></span>) ax.plot(snake[:, <span class="hljs-number"><span class="hljs-number">0</span></span>], snake[:, <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'-b'</span></span>, lw=<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/ne/pw/vw/nepwvw8xqanbj61fikjg6qorxq0.png"><br><br><h3>  Random Walker Segmentierung </h3><br>  Bei dieser Methode erfolgt die Segmentierung mithilfe einer interaktiven Beschriftung, die als Beschriftungen bezeichnet wird.  Indem Sie jedes Pixel auf das Etikett zeichnen, für das die höchste Wahrscheinlichkeit berechnet wird, erhalten Sie eine qualitativ hochwertige Bildsegmentierung.  Weitere Details zu dieser Methode finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser</a> Arbeit. <br><br>  Als nächstes werden wir wieder die vorherigen Werte aus unserem Beispiel verwenden.  Wir hätten verschiedene Initialisierungen durchführen können, aber der Einfachheit halber bleiben wir beim Prinzip der Kreise. <br><br><pre> <code class="python hljs">image_labels = np.zeros(image_gray.shape, dtype=np.uint8)</code> </pre> <br>  Der Random-Pass-Algorithmus akzeptiert Beschriftungen als Eingabe.  Somit haben wir einen großen Kreis, der das gesamte Gesicht der Person bedeckt, und einen weiteren kleineren Kreis nahe der Mitte des Gesichts. <br><br><pre> <code class="python hljs">indices = draw.circle_perimeter(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">250</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>)<span class="hljs-comment"><span class="hljs-comment">#from here image_labels[indices] = 1 image_labels[points[:, 1].astype(np.int), points[:, 0].astype(np.int)] = 2 image_show(image_labels);</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/ol/2n/nw/ol2nnwq0un_qzngiv25atfh3d5g.png"><br>  Verwenden wir nun Random Walker und sehen, was passiert. <br><br><pre> <code class="python hljs">image_segmented = seg.random_walker(image_gray, image_labels) <span class="hljs-comment"><span class="hljs-comment"># Check our results fig, ax = image_show(image_gray) ax.imshow(image_segmented == 1, alpha=0.3);</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/au/bs/jn/aubsjn1b1uedkiorghu5izwbbha.png"><br><br>  Das Ergebnis ist nicht das beste, die Ränder des Gesichts blieben unerreicht.  Um diese Situation zu korrigieren, können wir den Durchgangsparameter anpassen, bis wir das gewünschte Ergebnis erhalten.  Nach mehreren Versuchen haben wir den Wert auf 3000 gesetzt, was recht gut funktioniert. <br><br><pre> <code class="plaintext hljs">image_segmented = seg.random_walker(image_gray, image_labels, beta = 3000) # Check our results fig, ax = image_show(image_gray) ax.imshow(image_segmented == 1, alpha=0.3);</code> </pre><br><img src="https://habrastorage.org/webt/ii/4s/h1/ii4sh1n0rxcwgply9xmafyerk5a.png"><br><br>  Dies ist alles für die Segmentierung mit dem Lehrer, wo wir bestimmte Eingabedaten bereitstellen und einige Parameter konfigurieren mussten.  Es ist jedoch nicht immer möglich, dass eine Person das Bild betrachtet und dann entscheidet, welchen Beitrag sie leisten soll und wo sie anfangen soll.  Glücklicherweise haben wir für solche Situationen unkontrollierte Segmentierungsmethoden. <br><br><h2>  Segmentierung ohne Lehrer </h2><br>  Für die Segmentierung ohne Lehrer sind keine Vorkenntnisse erforderlich.  Stellen Sie sich ein Bild vor, das so groß ist, dass nicht alle Pixel gleichzeitig angezeigt werden können.  In solchen Fällen kann die Segmentierung ohne Lehrer das Bild in mehrere Unterregionen aufteilen, sodass Sie anstelle von Millionen von Pixeln Dutzende oder Hunderte von Bereichen haben.  Schauen wir uns zwei solcher Algorithmen an: <br><br><h3>  Einfaches lineares iteratives Clustering </h3><br>  Die Methode (English Simple Linear Iterative Clustering oder SLIC) verwendet einen Algorithmus für maschinelles Lernen namens K-Means.  Es nimmt alle Pixelwerte des Bildes und versucht, sie in eine bestimmte Anzahl von Subdomänen zu unterteilen.  Lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese</a> Arbeit für detaillierte Informationen. <br><br>  SLIC arbeitet mit verschiedenen Farben, daher verwenden wir das Originalbild. <br><br><pre> <code class="python hljs">image_slic = seg.slic(image,n_segments=<span class="hljs-number"><span class="hljs-number">155</span></span>)</code> </pre> <br>  Alles, was wir tun müssen, ist einfach einen Durchschnittswert für jedes Segment festzulegen, das wir finden, wodurch es eher wie ein Bild aussieht. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># label2rgb replaces each discrete label with the average interior color image_show(color.label2rgb(image_slic, image, kind='avg'));</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/7_/kn/b4/7_knb4b5fgefv0vsg3bed3dtx3o.png"><br><br>  Wir haben dieses Bild von 512 * 512 = 262.000 Pixel auf 155 Segmente reduziert. <br><br><h3>  Felzenszwalb </h3><br>  Diese Methode verwendet auch einen Algorithmus für maschinelles Lernen, der als Minimum-Spanning-Tree-Clustering bezeichnet wird.  Felzenszwaib gibt nicht die genaue Anzahl der Cluster an, in die das Bild unterteilt wird.  Er wird so viele Cluster generieren, wie er dafür für richtig hält. <br><br><pre> <code class="python hljs">image_felzenszwalb = seg.felzenszwalb(image) image_show(image_felzenszwalb);</code> </pre> <br><img src="https://habrastorage.org/webt/ht/bk/ao/htbkaotqhcgg_xlbys0_z_0bwie.png"><br><br>  Es gibt zu viele Regionen im Bild.  Zählen wir die Anzahl der eindeutigen Segmente. <br><br><pre> <code class="python hljs">np.unique(image_felzenszwalb).size <span class="hljs-number"><span class="hljs-number">3368</span></span></code> </pre> <br>  Lassen Sie uns sie nun mit dem Durchschnittswert über dem Segment neu einfärben, wie wir es im SLIC-Algorithmus getan haben. <br><br><pre> <code class="python hljs">image_felzenszwalb_colored = color.label2rgb(image_felzenszwalb, image, kind=<span class="hljs-string"><span class="hljs-string">'avg'</span></span>) image_show(image_felzenszwalb_colored);</code> </pre> <br>  Jetzt bekommen wir weniger Segmente.  Wenn wir noch weniger Segmente wollen, können wir den Skalierungsparameter ändern.  Dieser Ansatz wird manchmal als Über-Segmentierung bezeichnet. <br><br><img src="https://habrastorage.org/webt/dw/-2/3-/dw-23-xllphmwajmn1sg-sk-nws.png"><br><br>  Dies ähnelt eher einem posterisierten Bild, bei dem es sich im Wesentlichen nur um eine Verringerung der Anzahl der Farben handelt.  Um sie wieder zu kombinieren (RAG). <br><br><h2>  Fazit </h2><br>  Die Bildsegmentierung ist ein sehr wichtiger Schritt in der Bildverarbeitung.  Dies ist ein aktives Forschungsgebiet mit einer Vielzahl von Anwendungen, die von Computer Vision über medizinische Bilder bis hin zu Verkehrs- und Videoüberwachung reichen.  Python bietet eine robuste Scikit-Bildbibliothek mit einer Vielzahl von Bildverarbeitungsalgorithmen.  Es ist kostenlos und ohne Einschränkungen verfügbar und wird von einer aktiven Community unterstützt.  Ich empfehle Ihnen, die Dokumentation zu lesen.  Den Originalartikel finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441006/">https://habr.com/ru/post/de441006/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440994/index.html">Kümmern Sie sich schon in jungen Jahren um Ihr Unternehmen oder wie Sie ein schlankes Startup schaffen</a></li>
<li><a href="../de440998/index.html">OpenStack erweitert das Portfolio und aktiviert CI / CD</a></li>
<li><a href="../de441000/index.html">Promotion: Bringen Sie ein Papierbuch mit und erhalten Sie einen Rabatt auf jeden ONYX BOOX E-Reader</a></li>
<li><a href="../de441002/index.html">Was den 3. Turing-Test beendete: Statistiken, interessante Dialoge und Gesamteindruck</a></li>
<li><a href="../de441004/index.html">Splunk verlässt Russland (komplett)</a></li>
<li><a href="../de441008/index.html">Kaninchen MQ im Verarbeitungssystem der Bewohner</a></li>
<li><a href="../de441010/index.html">Geh runter auf die sterbliche Erde ...</a></li>
<li><a href="../de441012/index.html">Interessante Fakten über die Geschichte des chinesischen Mondprogramms und der Weltraummission Chang'e-4</a></li>
<li><a href="../de441014/index.html">Low-Budget-Stereo-Rendering in wenigen Codezeilen (Stereogramm, Anaglyphe, Stereoskop)</a></li>
<li><a href="../de441018/index.html">Tools zur Entwicklung und Spezifikation von NanoCAD Mechanics-Programmen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>