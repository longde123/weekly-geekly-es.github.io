<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¾â€ğŸ”§ ğŸ… ğŸ· Saluran pemrosesan data deklaratif di atas aktor? Kenapa tidak ğŸ…ğŸ¼ ğŸ’‡ ğŸ‘µğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa waktu lalu, dalam sebuah diskusi di salah satu rilis SObjectizer, kami ditanya: "Apakah mungkin membuat DSL untuk menggambarkan pipa pemroses...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Saluran pemrosesan data deklaratif di atas aktor? Kenapa tidak</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460123/"><p>  Beberapa waktu lalu, dalam sebuah diskusi di salah satu rilis SObjectizer, kami ditanya: "Apakah mungkin membuat DSL untuk menggambarkan pipa pemrosesan data?"  Dengan kata lain, apakah mungkin untuk menulis sesuatu seperti itu: </p><br><p><code>A | B | C | D</code> </p> <br><p>  dan dapatkan jalur pipa yang berfungsi di mana pesan pergi dari A ke B, lalu ke C, dan kemudian ke D. Dengan kontrol B menerima persis tipe yang dikembalikan A.  Dan C menerima persis tipe yang dikembalikan B.  Dan sebagainya. </p><br><p>  Itu adalah tugas yang menarik dengan solusi yang sangat sederhana.  Misalnya, begitulah pembuatan saluran pipa terlihat seperti: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pipeline = make_pipeline(env, stage(A) | stage(B) | stage(C) | stage(D));</code> </pre> <br><p>  Atau, dalam kasus yang lebih kompleks (yang akan dibahas di bawah): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(archiving), stage(distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(alarm_initiator), stage( []( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> alarm_detected &amp; v ) { alarm_distribution( <span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span>, v ); } ) ) ) );</code> </pre> <br><p>  Pada artikel ini, kita akan berbicara tentang implementasi DSL pipeline tersebut.  Kami akan membahas sebagian besar bagian yang terkait dengan fungsi <code>stage()</code> , <code>broadcast()</code> dan <code>operator|()</code> dengan beberapa contoh penggunaan templat C ++.  Jadi saya berharap ini akan menarik bahkan bagi pembaca yang tidak tahu tentang SObjectizer (jika Anda belum pernah mendengar tentang SObjectizer di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> adalah gambaran umum alat ini). </p><a name="habracut"></a><br><h1 id="a-couple-of-words-about-the-used-demo">  Beberapa kata tentang demo yang digunakan </h1><br><p>  Contoh yang digunakan dalam artikel ini dipengaruhi oleh pengalaman saya yang lama (dan agak terlupakan) di area SCADA. </p><br><p>  Ide dari demo adalah penanganan data yang dibaca dari beberapa sensor.  Data diperoleh dari sensor dengan beberapa periode, maka data tersebut harus divalidasi (data yang salah harus diabaikan) dan dikonversi menjadi beberapa nilai aktual.  Misalnya, data mentah yang dibaca dari sensor dapat berupa dua nilai integer 8-bit dan nilai-nilai tersebut harus dikonversi menjadi satu angka floating-point. </p><br><p>  Kemudian nilai yang valid dan dikonversi harus diarsipkan, didistribusikan di suatu tempat (pada node yang berbeda untuk visualisasi, misalnya), diperiksa untuk "alarm" (jika nilai berada di luar rentang aman maka itu harus ditangani secara khusus).  Operasi-operasi ini independen dan dapat dilakukan secara paralel. </p><br><p>  Operasi yang terkait dengan alarm yang terdeteksi dapat dilakukan secara paralel juga: "alarm" harus dimulai (sehingga bagian SCADA pada node saat ini dapat bereaksi padanya) dan informasi tentang "alarm" harus didistribusikan di tempat lain (misalnya : disimpan ke database historis dan / atau divisualisasikan pada layar operator SCADA). </p><br><p>  Logika ini dapat diekspresikan dalam bentuk tekstual seperti itu: </p><br><pre> <code class="plaintext hljs">optional(valid_raw_data) = validate(raw_data); if valid_raw_data is not empty then { converted_value = convert(valid_raw_data); do_async archive(converted_value); do_async distribute(converted_value); do_async { optional(suspicious_value) = check_range(converted_value); if suspicious_value is not empty then { optional(alarm) = detect_alarm(suspicious_value); if alarm is not empty then { do_async initiate_alarm(alarm); do_async distribute_alarm(alam); } } } }</code> </pre> <br><p>  Atau, dalam bentuk grafis: </p><br><p><img src="https://habrastorage.org/webt/5z/nm/vv/5znmvvaqnou_qwh808t8vkbrdc8.jpeg"></p><br><p>  Ini contoh yang agak tiruan, tetapi ada beberapa hal menarik yang ingin saya perlihatkan.  Yang pertama adalah adanya tahapan paralel dalam pipa ( <code>broadcast()</code> operasi <code>broadcast()</code> ada hanya karena itu).  Yang kedua adalah kehadiran suatu negara dalam beberapa tahap.  Sebagai contoh, alarm_detector adalah stateful stage. </p><br><h1 id="pipeline-capabilities">  Kemampuan saluran pipa </h1><br><p>  Saluran pipa dibangun dari tahapan terpisah.  Setiap tahap adalah fungsi atau fungsi dari format berikut: </p><br><pre> <code class="cpp hljs">opt&lt;Out&gt; func(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> In &amp;);</code> </pre> <br><p>  atau </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> In &amp;)</span></span></span></span>;</code> </pre> <br><p>  Tahapan yang mengembalikan <code>void</code> hanya dapat digunakan sebagai tahap terakhir dari pipa. </p><br><p>  Tahapan terikat ke dalam rantai.  Setiap tahap berikutnya menerima objek yang dikembalikan oleh tahap sebelumnya.  Jika tahap sebelumnya mengembalikan nilai <code>opt&lt;Out&gt;</code> kosong <code>opt&lt;Out&gt;</code> maka tahap selanjutnya tidak dipanggil. </p><br><p>  Ada panggung <code>broadcast</code> khusus.  Itu dibangun dari beberapa pipa.  Tahap <code>broadcast</code> menerima objek dari tahap sebelumnya dan menyiarkannya ke setiap pipa anak perusahaan. </p><br><p>  Dari sudut pandang pipa, tahap <code>broadcast</code> tampak seperti fungsi dari format berikut: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> In &amp;)</span></span></span></span>;</code> </pre> <br><p>  Karena tidak ada nilai balik dari tahap <code>broadcast</code> tahap <code>broadcast</code> hanya bisa menjadi tahap terakhir dalam saluran pipa. </p><br><h2 id="why-does-the-pipeline-stage-return-an-optional-value">  Mengapa tahap pipa mengembalikan nilai opsional? </h2><br><p>  Itu karena ada kebutuhan untuk menjatuhkan beberapa nilai yang masuk.  Misalnya, tahap <code>validate</code> tidak mengembalikan apa pun jika nilai mentah salah, dan tidak ada gunanya menanganinya. </p><br><p>  Contoh lain: tahap <code>alarm_detector</code> tidak mengembalikan apa pun jika nilai mencurigakan saat ini tidak menghasilkan kasus alarm baru. </p><br><h1 id="implementation-details">  Detail implementasi </h1><br><h2 id="types-and-functions-related-to-the-application-logic">  Jenis dan fungsi yang terkait dengan logika aplikasi </h2><br><p>  Mari kita mulai dari tipe data dan fungsi yang terkait dengan logika aplikasi.  Dalam contoh yang dibahas, tipe data berikut digunakan untuk meneruskan informasi dari satu tahap ke tahap lainnya: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Raw data from a sensor. struct raw_measure { int m_meter_id; uint8_t m_high_bits; uint8_t m_low_bits; }; // Type of input for validation stage with raw data from a sensor. struct raw_value { raw_measure m_data; }; // Type of input for conversion stage with valid raw data from a sensor. struct valid_raw_value { raw_measure m_data; }; // Data from a sensor after conversion to Celsius degrees. struct calculated_measure { int m_meter_id; float m_measure; }; // The type for result of conversion stage with converted data from a sensor. struct sensor_value { calculated_measure m_data; }; // Type with value which could mean a dangerous level of temperature. struct suspicious_value { calculated_measure m_data; }; // Type with information about detected dangerous situation. struct alarm_detected { int m_meter_id; };</span></span></code> </pre> <br><p>  Sebuah instance dari <code>raw_value</code> akan menuju ke tahap pertama dari pipeline kami.  Nilai <code>raw_value</code> ini berisi informasi yang diperoleh dari sensor dalam bentuk objek <code>raw_measure</code> .  Kemudian <code>raw_value</code> ditransformasikan menjadi <code>valid_raw_value</code> .  Kemudian <code>valid_raw_value</code> ditransformasikan menjadi <code>sensor_value</code> dengan nilai sensor aktual dalam bentuk <code>calulated_measure</code> .  Jika instance <code>sensor_value</code> berisi nilai mencurigakan, maka instance <code>suspicious_value</code> diproduksi.  Dan <code>suspicious_value</code> dapat diubah menjadi instance <code>alarm_detected</code> nanti. </p><br><p>  Atau, dalam bentuk grafis: </p><br><p><img src="https://habrastorage.org/webt/dp/dx/rz/dpdxrzpp-rvo05zk-8rwdwucszo.jpeg"></p><br><p>  Sekarang kita bisa melihat implementasi dari tahapan pipeline kami: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // The first stage of a pipeline. Validation of raw data from a sensor. // // Returns valid_raw_value or nothing if value is invalid. // stage_result_t&lt; valid_raw_value &gt; validation( const raw_value &amp; v ) { if( 0x7 &gt;= v.m_data.m_high_bits ) return make_result&lt; valid_raw_value &gt;( v.m_data ); else return make_empty&lt; valid_raw_value &gt;(); } // // The second stage of a pipeline. Conversion from raw data to a value // in Celsius degrees. // stage_result_t&lt; sensor_value &gt; conversion( const valid_raw_value &amp; v ) { return make_result&lt; sensor_value &gt;( calculated_measure{ v.m_data.m_meter_id, 0.5f * ((static_cast&lt; uint16_t &gt;( v.m_data.m_high_bits ) &lt;&lt; 8) + v.m_data.m_low_bits) } ); } // // Simulation of the data archiving. // void archiving( const sensor_value &amp; v ) { clog &lt;&lt; "archiving (" &lt;&lt; v.m_data.m_meter_id &lt;&lt; "," &lt;&lt; v.m_data.m_measure &lt;&lt; ")" &lt;&lt; endl; } // // Simulation of the data distribution. // void distribution( const sensor_value &amp; v ) { clog &lt;&lt; "distributing (" &lt;&lt; v.m_data.m_meter_id &lt;&lt; "," &lt;&lt; v.m_data.m_measure &lt;&lt; ")" &lt;&lt; endl; } // // The first stage of a child pipeline at third level of the main pipeline. // // Checking for to high value of the temperature. // // Returns suspicious_value message or nothing. // stage_result_t&lt; suspicious_value &gt; range_checking( const sensor_value &amp; v ) { if( v.m_data.m_measure &gt;= 45.0f ) return make_result&lt; suspicious_value &gt;( v.m_data ); else return make_empty&lt; suspicious_value &gt;(); } // // The next stage of a child pipeline. // // Checks for two suspicious_value-es in 25ms time window. // class alarm_detector { using clock = chrono::steady_clock; public : stage_result_t&lt; alarm_detected &gt; operator()( const suspicious_value &amp; v ) { if( m_previous ) if( *m_previous + chrono::milliseconds(25) &gt; clock::now() ) { m_previous = nullopt; return make_result&lt; alarm_detected &gt;( v.m_data.m_meter_id ); } m_previous = clock::now(); return make_empty&lt; alarm_detected &gt;(); } private : optional&lt; clock::time_point &gt; m_previous; }; // // One of last stages of a child pipeline. // Imitates beginning of the alarm processing. // void alarm_initiator( const alarm_detected &amp; v ) { clog &lt;&lt; "=== alarm (" &lt;&lt; v.m_meter_id &lt;&lt; ") ===" &lt;&lt; endl; } // // Another of last stages of a child pipeline. // Imitates distribution of the alarm. // void alarm_distribution( ostream &amp; to, const alarm_detected &amp; v ) { to &lt;&lt; "alarm_distribution (" &lt;&lt; v.m_meter_id &lt;&lt; ")" &lt;&lt; endl; }</span></span></code> </pre> <br><p>  <code>stage_result_t</code> saja hal-hal seperti <code>stage_result_t</code> , <code>make_result</code> dan <code>make_empty</code> , kita akan membahasnya di bagian selanjutnya. </p><br><p>  Saya harap kode tahapan itu agak sepele.  Satu-satunya bagian yang memerlukan penjelasan tambahan adalah implementasi tahap <code>alarm_detector</code> . </p><br><p>  Dalam contoh itu, alarm dimulai hanya jika setidaknya ada dua nilai <code>suspicious_values</code> dalam jendela waktu 25 ms.  Jadi kita harus mengingat waktu instance <code>suspicious_value</code> sebelumnya pada tahap <code>alarm_detector</code> .  Itu karena <code>alarm_detector</code> diimplementasikan sebagai functor stateful dengan operator panggilan fungsi. </p><br><h2 id="stages-return-sobjectizers-type-instead-of-stdoptional">  Tahapan mengembalikan jenis SObjectizer bukannya std :: opsional </h2><br><p>  Saya katakan sebelumnya bahwa tahap dapat mengembalikan nilai opsional.  Tetapi <code>std::optional</code> tidak digunakan dalam kode, tipe <code>stage_result_t</code> berbeda dapat dilihat dalam implementasi tahapan. </p><br><p>  Itu karena beberapa spesifik SObjectizer memainkan perannya di sini.  Nilai yang dikembalikan akan didistribusikan sebagai pesan antara agen SObjectizer (alias aktor).  Setiap pesan dalam SObjectizer dikirim sebagai objek yang dialokasikan secara dinamis.  Jadi kami memiliki beberapa "optimasi" di sini: alih-alih mengembalikan <code>std::optional</code> dan kemudian mengalokasikan objek pesan baru, kami hanya mengalokasikan objek pesan dan mengembalikan pointer pintar ke sana. </p><br><p>  Faktanya, <code>stage_result_t</code> hanyalah sebuah typedef untuk analog shared_ptr SObjectizer: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt; M &gt;;</code> </pre> <br><p>  Dan <code>make_result</code> dan <code>make_empty</code> hanyalah fungsi pembantu untuk membangun <code>stage_result_t</code> dengan atau tanpa nilai aktual di dalamnya: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt; make_result( Args &amp;&amp;... args ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt;::make(forward&lt; Args &gt;(args)...); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt; make_empty() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt;(); }</code> </pre> <br><p>  Untuk kesederhanaan, aman untuk mengatakan tahap <code>validation</code> dapat dinyatakan seperti itu: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; valid_raw_value &gt; validation( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> raw_value &amp; v ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0x7</span></span> &gt;= v.m_data.m_high_bits ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt; valid_raw_value &gt;( v.m_data ); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; valid_raw_value &gt;{}; }</code> </pre> <br><p>  Tetapi, karena spesifik SObjectizer, kita tidak dapat menggunakan <code>std::shared_ptr</code> dan harus berurusan dengan <code>so_5::message_holder_t</code> .  Dan kami menyembunyikan itu di belakang <code>stage_result_t</code> , <code>make_result</code> , dan <code>make_empty</code> helpers. </p><br><h2 id="stage_handler_t-and-stage_builder_t-separation">  pemisahan stage_handler_t dan stage_builder_t </h2><br><p>  Poin penting dari implementasi pipeline adalah pemisahan konsep <em>stage handler</em> dan <em>stage builder</em> .  Ini dilakukan untuk kesederhanaan.  Kehadiran konsep-konsep ini memungkinkan saya untuk memiliki dua langkah dalam definisi pipa. </p><br><p>  Pada langkah pertama, seorang pengguna menjelaskan tahapan-tahapan pipa.  Sebagai hasilnya, saya menerima contoh <code>stage_t</code> yang menampung semua tahapan pipa di dalamnya. </p><br><p>  Pada langkah kedua, serangkaian agen SObjectizer yang mendasarinya dibuat.  Agen tersebut menerima pesan dengan hasil dari tahap sebelumnya dan memanggil <em>penangan tahap yang</em> sebenarnya, kemudian mengirimkan hasilnya ke tahap berikutnya. </p><br><p>  Tetapi untuk membuat set agen ini setiap tahap harus memiliki <em>pembangun panggung</em> .  <em>Pembangun panggung</em> dapat dilihat sebagai pabrik yang menciptakan agen SObjectizer yang mendasarinya. </p><br><p>  Jadi kita memiliki hubungan berikut: setiap tahap pipa menghasilkan dua objek: <em>stage handler</em> yang memegang logika terkait <em>tahap</em> , dan <em>stage builder</em> yang menciptakan agen SObjectizer yang mendasari untuk memanggil <em>stage handler</em> pada waktu yang tepat: </p><br><p><img src="https://habrastorage.org/webt/gl/tp/nn/gltpnnqhjqslsscxvellndh6n0u.jpeg"></p><br><p>  <em>Pawang ditangani</em> dengan cara berikut: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stage_handler_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> traits = <span class="hljs-keyword"><span class="hljs-keyword">handler_traits_t</span></span>&lt; In, Out &gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> func_type = function&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> traits::output(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> traits::input &amp;) &gt;; <span class="hljs-keyword"><span class="hljs-keyword">stage_handler_t</span></span>( func_type handler ) : m_handler( move(handler) ) {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Callable &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_handler_t</span></span>( Callable handler ) : m_handler( handler ) {} <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> traits::<span class="hljs-function"><span class="hljs-function">output </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> traits::input &amp; a )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_handler( a ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> : func_type m_handler; };</code> </pre> <br><p>  Di mana <code>handler_traits_t</code> didefinisikan dengan cara berikut: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // We have to deal with two types of stage handlers: // - intermediate handlers which will return some result (eg some new // message); // - terminal handlers which can return nothing (eg void instead of // stage_result_t&lt;M&gt;); // // This template with specialization defines `input` and `output` // aliases for both cases. // template&lt; typename In, typename Out &gt; struct handler_traits_t { using input = In; using output = stage_result_t&lt; Out &gt;; }; template&lt; typename In &gt; struct handler_traits_t&lt; In, void &gt; { using input = In; using output = void; };</span></span></code> </pre> <br><p>  <em>Builder panggung</em> diwakili oleh just <code>std::function</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> = function&lt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp;, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>) &gt;;</code> </pre> <br><h2 id="helper-types-lambda_traits_t-and-callable_traits_t">  Jenis pembantu lambda_traits_t dan callable_traits_t </h2><br><p>  Karena tahapan dapat diwakili oleh fungsi atau fungsi bebas (seperti instance dari kelas <code>alarm_detector</code> atau kelas yang dihasilkan kompiler anonim yang mewakili lambdas), kami membutuhkan beberapa pembantu untuk mendeteksi jenis argumen panggung dan nilai pengembalian.  Saya menggunakan kode berikut untuk tujuan itu: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // Helper type for `arg_type` and `result_type` alises definition. // template&lt; typename R, typename A &gt; struct callable_traits_typedefs_t { using arg_type = A; using result_type = R; }; // // Helper type for dealing with stateful objects with operator() // (they could be user-defined objects or generated by compiler // like lambdas). // template&lt; typename T &gt; struct lambda_traits_t; template&lt; typename M, typename A, typename T &gt; struct lambda_traits_t&lt; stage_result_t&lt; M &gt;(T::*)(const A &amp;) const &gt; : public callable_traits_typedefs_t&lt; M, A &gt; {}; template&lt; typename A, typename T &gt; struct lambda_traits_t&lt; void (T::*)(const A &amp;) const &gt; : public callable_traits_typedefs_t&lt; void, A &gt; {}; template&lt; typename M, typename A, typename T &gt; struct lambda_traits_t&lt; stage_result_t&lt; M &gt;(T::*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; M, A &gt; {}; template&lt; typename A, typename T &gt; struct lambda_traits_t&lt; void (T::*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; void, A &gt; {}; // // Main type for definition of `arg_type` and `result_type` aliases. // With specialization for various cases. // template&lt; typename T &gt; struct callable_traits_t : public lambda_traits_t&lt; decltype(&amp;T::operator()) &gt; {}; template&lt; typename M, typename A &gt; struct callable_traits_t&lt; stage_result_t&lt; M &gt;(*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; M, A &gt; {}; template&lt; typename A &gt; struct callable_traits_t&lt; void(*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; void, A &gt; {};</span></span></code> </pre> <br><p>  Saya harap kode ini akan cukup dimengerti bagi pembaca dengan pengetahuan yang baik tentang C ++.  Jika tidak, jangan ragu untuk bertanya kepada saya di komentar, saya akan dengan senang hati menjelaskan logika di balik <code>lambda_traits_t</code> dan <code>callable_traits_t</code> secara detail. </p><br><h2 id="stage-broadcast-and-operator-functions">  fungsi stage (), broadcast () dan operator | () </h2><br><p>  Sekarang kita bisa melihat ke dalam fungsi-fungsi pembangunan pipa utama.  Tetapi sebelum itu, perlu untuk melihat definisi dari kelas template <code>stage_t</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stage_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> m_builder; };</code> </pre> <br><p>  Ini adalah struct yang sangat sederhana yang hanya <code>stage_bulder_t</code> instance <code>stage_bulder_t</code> .  Parameter template tidak digunakan di dalam <code>stage_t</code> , jadi mengapa mereka ada di sini? </p><br><p>  Mereka diperlukan untuk pemeriksaan kompilasi waktu kompatibilitas tipe antara tahap-tahap pipa.  Kami akan segera melihatnya. </p><br><p>  Mari kita lihat fungsi pembangunan saluran pipa yang paling sederhana, <code>stage()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Callable, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::arg_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::result_type &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out &gt; stage( Callable handler ) { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [h = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(handler)]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">a_stage_point_t</span></span>&lt;In, Out&gt; &gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(h), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ) -&gt;so_direct_mbox(); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(builder) }; }</code> </pre> <br><p>  Ini menerima <em>penangan panggung yang</em> sebenarnya sebagai parameter tunggal.  Ini bisa menjadi pointer ke fungsi atau fungsi lambda atau functor.  Jenis-jenis input dan output stage disimpulkan secara otomatis karena "templat magic" di balik templat <code>callable_traits_t</code> . </p><br><p>  Sebuah instance dari <em>builder panggung</em> dibuat di dalam dan instance itu dikembalikan dalam objek <code>stage_t</code> baru sebagai hasil dari fungsi <code>stage()</code> .  <em>Pawang panggung yang</em> sebenarnya ditangkap oleh lambda <em>pembangun panggung</em> , kemudian akan digunakan untuk pembangunan agen SObjectizer yang mendasarinya (kita akan membicarakannya di bagian berikutnya). </p><br><p>  Fungsi selanjutnya untuk ditinjau adalah <code>operator|()</code> yang menggabungkan dua tahap bersama dan mengembalikan tahap baru: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out2 &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out2 &gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>|( <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out1 &gt; &amp;&amp; prev, <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; Out1, Out2 &gt; &amp;&amp; next ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span>{ [prev, next]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage ) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = next.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(m) ); } } }; }</code> </pre> <br><p>  Cara paling sederhana untuk menjelaskan logika <code>operator|()</code> adalah mencoba menggambar.  Anggaplah kita memiliki ungkapan: </p><br><pre> <code class="cpp hljs">stage(A) | stage(B) | stage(C) | stage(B)</code> </pre> <br><p>  Ungkapan ini akan diubah seperti itu: </p><br><p><img src="https://habrastorage.org/webt/jo/rr/aq/jorraqaawl6y7ju3om7zfq3java.jpeg"></p><br><p>  Di sana kita juga dapat melihat bagaimana pengecekan tipe waktu kompilasi bekerja: definisi <code>operator|()</code> mensyaratkan bahwa tipe keluaran dari tahap pertama adalah input dari tahap kedua.  Jika ini bukan masalahnya, kode tidak akan dikompilasi. </p><br><p>  Dan sekarang kita bisa melihat fungsi pembangunan saluran pipa yang paling kompleks, <code>broadcast()</code> .  Fungsi itu sendiri agak sederhana: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Rest &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> &gt; broadcast( <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out &gt; &amp;&amp; first, Rest &amp;&amp;... stages ) { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [broadcasts = collect_sink_builders( move(first), forward&lt; Rest &gt;(stages)...)] ( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> ) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> &gt; mboxes; mboxes.reserve( broadcasts.size() ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; b : broadcasts ) mboxes.emplace_back( b( coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>{} ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">broadcast_mbox_t</span></span>::make( coop.environment(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(mboxes) ); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(builder) }; }</code> </pre> <br><p>  Perbedaan utama antara tahap biasa dan tahap siaran adalah bahwa tahap siaran harus memiliki vektor <em>pembangun panggung</em> anak perusahaan.  Jadi kita harus membuat vektor itu dan mengirimkannya ke <em>pembangun panggung</em> utama siaran-panggung.  Karena itu, kita dapat melihat panggilan ke <code>collect_sink_builders</code> di daftar tangkap lambda di dalam fungsi <code>broadcast()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [broadcasts = collect_sink_builders( move(first), forward&lt; Rest &gt;(stages)...)]</code> </pre> <br><p>  Jika kita melihat ke <code>collect_sink_builder</code> kita akan melihat kode berikut: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // Serie of helper functions for building description for // `broadcast` stage. // // Those functions are used for collecting // `builders` functions for every child pipeline. // // Please note that this functions checks that each child pipeline has the // same In type. // template&lt; typename In, typename Out, typename... Rest &gt; void move_sink_builder_to( vector&lt; stage_builder_t &gt; &amp; receiver, stage_t&lt; In, Out &gt; &amp;&amp; first, Rest &amp;&amp;... rest ) { receiver.emplace_back( move( first.m_builder ) ); if constexpr( 0u != sizeof...(rest) ) move_sink_builder_to&lt;In&gt;( receiver, forward&lt; Rest &gt;(rest)... ); } template&lt; typename In, typename Out, typename... Rest &gt; vector&lt; stage_builder_t &gt; collect_sink_builders( stage_t&lt; In, Out &gt; &amp;&amp; first, Rest &amp;&amp;... stages ) { vector&lt; stage_builder_t &gt; receiver; receiver.reserve( 1 + sizeof...(stages) ); move_sink_builder_to&lt;In&gt;( receiver, move(first), std::forward&lt;Rest&gt;(stages)... ); return receiver; }</span></span></code> </pre> <br><p>  Pengecekan tipe waktu kompilasi juga berfungsi di sini: itu karena panggilan untuk <code>move_sink_builder_to</code> secara eksplisit diparameterisasi berdasarkan tipe 'In'.  Ini berarti bahwa panggilan dalam bentuk <code>collect_sink_builders(stage_t&lt;In1, Out1&gt;, stage_t&lt;In2, Out2&gt;, ...)</code> akan menyebabkan kesalahan kompilasi karena kompiler melarang panggilan <code>move_sink_builder_to&lt;In1&gt;(receiver, stage_t&lt;In2, Out2&gt;, ...)</code> . </p><br><p>  Saya juga dapat mencatat bahwa karena jumlah saluran pipa anak perusahaan untuk <code>broadcast()</code> diketahui pada waktu kompilasi kita dapat menggunakan <code>std::array</code> bukan <code>std::vector</code> dan dapat menghindari beberapa alokasi memori.  Tetapi <code>std::vector</code> digunakan di sini hanya untuk kesederhanaan. </p><br><h2 id="relation-between-stages-and-sobjectizers-agentsmboxes">  Hubungan antara tahapan dan agen / mbox SObjectizer </h2><br><p>  Gagasan di balik pelaksanaan pipa adalah penciptaan agen terpisah untuk setiap tahap pipa.  Agen menerima pesan masuk, meneruskannya ke <em>penangan tahap yang</em> sesuai, menganalisis hasilnya dan, jika hasilnya tidak kosong, mengirimkan hasilnya sebagai pesan masuk ke tahap berikutnya.  Itu dapat diilustrasikan oleh diagram urutan berikut: </p><br><p><img src="https://habrastorage.org/webt/om/pn/wy/ompnwye792gjgad7zzgphpv4ctu.png"></p><br><p>  Beberapa hal terkait SObjectizer harus didiskusikan, setidaknya secara singkat.  Jika Anda tidak tertarik pada detail seperti itu, Anda dapat melewati bagian di bawah ini dan langsung menuju ke kesimpulan. </p><br><h3 id="coop-is-a-group-of-agents-to-work-together">  Coop adalah sekelompok agen untuk bekerja bersama </h3><br><p>  Agen dimasukkan ke dalam SObjectizer tidak secara individu tetapi dalam kelompok bernama coops.  Koperasi adalah sekelompok agen yang harus bekerja sama dan tidak masuk akal untuk melanjutkan pekerjaan jika salah satu agen grup hilang. </p><br><p>  Jadi pengenalan agen untuk SObjectizer seperti pembuatan instance coop, mengisi instance tersebut dengan agen yang sesuai dan kemudian mendaftarkan coop di SObjectizer. </p><br><p>  Karena itu argumen pertama untuk <em>pembangun panggung</em> adalah referensi ke kandang baru.  <code>make_pipeline()</code> ini dibuat di fungsi <code>make_pipeline()</code> (dibahas di bawah), kemudian diisi oleh <em>pembuat stage</em> dan kemudian didaftarkan (lagi di fungsi <code>make_pipeline()</code> ). </p><br><h3 id="message-boxes">  Kotak pesan </h3><br><p>  SObjectizer mengimplementasikan beberapa model yang terkait dengan konkurensi.  Model Aktor hanyalah salah satunya.  Karena itu, SObjectizer dapat berbeda secara signifikan dari kerangka aktor lain.  Salah satu perbedaannya adalah skema pengalamatan untuk pesan. </p><br><p>  Pesan di SObjectizer ditujukan bukan untuk aktor, tetapi <em>kotak pesan</em> (mboxes).  Aktor harus berlangganan pesan dari mbox.  Jika aktor berlangganan jenis pesan tertentu dari mbox, ia akan menerima pesan jenis itu: </p><br><p><img src="https://habrastorage.org/webt/o4/bf/ee/o4bfee0lp8hdvks68cas4yjlkgu.png"></p><br><p>  Fakta ini sangat penting karena perlu untuk mengirim pesan dari satu tahap ke tahap lainnya.  Ini berarti bahwa setiap tahap harus memiliki mbox-nya dan mbox itu harus diketahui untuk tahap sebelumnya. </p><br><p>  Setiap aktor (agen alias) di SObjectizer memiliki <em>mbox langsung</em> .  Mbox ini hanya dikaitkan dengan agen pemilik dan tidak dapat digunakan oleh agen lain.  Kotak langsung agen yang dibuat untuk tahap akan digunakan untuk interaksi tahap. </p><br><p>  Fitur spesifik SObjectizer ini menentukan beberapa detail implementasi pipeline. </p><br><p>  Yang pertama adalah fakta bahwa <em>pembangun panggung</em> memiliki prototipe berikut: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> builder(<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp;, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>);</code> </pre> <br><p>  Ini berarti <em>pembangun panggung</em> menerima mbox dari tahap berikutnya dan harus membuat agen baru yang akan mengirim hasil panggung ke mbox itu.  Mbox agen baru harus dikembalikan oleh <em>pembangun panggung</em> .  Mbox itu akan digunakan untuk pembuatan agen untuk tahap sebelumnya. </p><br><p>  Yang kedua adalah fakta bahwa agen untuk tahapan dibuat dalam urutan cadangan.  Itu berarti bahwa jika kita memiliki pipa: </p><br><pre> <code class="cpp hljs">stage(A) | stage(B) | stage(C)</code> </pre> <br><p>  Agen untuk tahap C akan dibuat terlebih dahulu, kemudian mbox-nya akan digunakan untuk pembuatan agen untuk tahap B, dan kemudian mbox dari agen tahap-B akan digunakan untuk pembuatan agen untuk tahap A. </p><br><p>  Perlu juga dicatat bahwa <code>operator|()</code> tidak membuat agen: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span>{ [prev, next]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage ) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = next.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(m) ); } }</code> </pre> <br><p>  <code>operator|()</code> membuat pembangun yang hanya memanggil pembangun lain tetapi tidak memperkenalkan agen tambahan.  Jadi untuk kasus ini: </p><br><pre> <code class="cpp hljs">stage(A) | stage(B)</code> </pre> <br><p>  hanya dua agen yang akan dibuat (untuk A-stage dan B-stage) dan kemudian mereka akan dihubungkan bersama dalam <em>pembangun panggung yang</em> dibuat oleh <code>operator|()</code> . </p><br><h3 id="there-is-no-agent-for-broadcast-implementation">  Tidak ada agen untuk implementasi <code>broadcast()</code> </h3><br><p>  Cara yang jelas untuk mengimplementasikan tahap penyiaran adalah membuat agen khusus yang akan menerima pesan masuk dan kemudian mengirim ulang pesan itu ke daftar mboxes tujuan.  Cara <a href="">itu digunakan dalam implementasi pertama</a> dari pipeline DSL yang dijelaskan. </p><br><p>  Tetapi proyek pendamping kami, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">so5extra</a> , sekarang memiliki varian khusus mbox: broadcasting.  Mbox itu melakukan apa yang diperlukan di sini: ia mengambil pesan baru dan mengirimkannya ke sekumpulan mbox tujuan. </p><br><p>  Karena itu tidak perlu membuat agen penyiaran yang terpisah, kita bisa menggunakan mbox penyiaran dari so5extra: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // A special mbox for broadcasting of a message to a set of destination // mboxes. // using broadcast_mbox_t = so_5::extra::mboxes::broadcast::fixed_mbox_template_t&lt;&gt;; ... // // Inside the broadcast() function: // stage_builder_t builder{ [broadcasts = collect_sink_builders( move(first), forward&lt; Rest &gt;(stages)...)] ( coop_t &amp; coop, mbox_t ) -&gt; mbox_t { vector&lt; mbox_t &gt; mboxes; mboxes.reserve( broadcasts.size() ); for( const auto &amp; b : broadcasts ) mboxes.emplace_back( b( coop, mbox_t{} ) ); // That is the creation of broadcasting mbox instance. return broadcast_mbox_t::make( coop.environment(), std::move(mboxes) ); } };</span></span></code> </pre> <br><h3 id="implementation-of-stage-agent">  Implementasi agen tahap </h3><br><p>  Sekarang kita bisa melihat implementasi agen tahap: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // An agent which will be used as intermediate or terminal pipeline stage. // It will receive input message, call the stage handler and pass // handler result to the next stage (if any). // template&lt; typename In, typename Out &gt; class a_stage_point_t final : public agent_t { public : a_stage_point_t( context_t ctx, stage_handler_t&lt; In, Out &gt; handler, mbox_t next_stage ) : agent_t{ ctx } , m_handler{ move( handler ) } , m_next{ move(next_stage) } {} void so_define_agent() override { if( m_next ) // Because there is the next stage the appropriate // message handler will be used. so_subscribe_self().event( [=]( const In &amp; evt ) { auto r = m_handler( evt ); if( r ) so_5::send( m_next, r ); } ); else // There is no next stage. A very simple message handler // will be used for that case. so_subscribe_self().event( [=]( const In &amp; evt ) { m_handler( evt ); } ); } private : const stage_handler_t&lt; In, Out &gt; m_handler; const mbox_t m_next; }; // // A specialization of a_stage_point_t for the case of terminal stage of // a pipeline. This type will be used for stage handlers with void // return type. // template&lt; typename In &gt; class a_stage_point_t&lt; In, void &gt; final : public agent_t { public : a_stage_point_t( context_t ctx, stage_handler_t&lt; In, void &gt; handler, mbox_t next_stage ) : agent_t{ ctx } , m_handler{ move( handler ) } { if( next_stage ) throw std::runtime_error( "sink point cannot have next stage" ); } void so_define_agent() override { so_subscribe_self().event( [=]( const In &amp; evt ) { m_handler( evt ); } ); } private : const stage_handler_t&lt; In, void &gt; m_handler; };</span></span></code> </pre> <br><p>  Agak sepele jika Anda memahami dasar-dasar SObjectizer.  Jika tidak, akan sangat sulit untuk dijelaskan dalam beberapa kata (jadi silakan bertanya di komentar). </p><br><p>  Implementasi utama agen <code>a_stage_point_t</code> menciptakan langganan ke pesan bertipe In.  Ketika pesan jenis ini tiba, <em>pawang panggung</em> dipanggil.  Jika <em>penangan panggung</em> mengembalikan hasil aktual, hasilnya dikirim ke tahap berikutnya (jika tahap itu ada). </p><br><p>  Ada juga versi <code>a_stage_point_t</code> untuk kasus ketika tahap yang sesuai adalah tahap terminal dan tidak mungkin ada tahap berikutnya. </p><br><p>  Implementasi <code>a_stage_point_t</code> dapat terlihat sedikit rumit tetapi percayalah, ini adalah salah satu agen paling sederhana yang saya tulis. </p><br><h2 id="make_pipeline-function">  fungsi make_pipeline () </h2><br><p>  Saatnya untuk membahas fungsi pembangunan saluran pipa terakhir, <code>make_pipeline()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> make_pipeline( <span class="hljs-comment"><span class="hljs-comment">// SObjectizer Environment to work in. so_5::environment_t &amp; env, // Definition of a pipeline. stage_t&lt; In, Out &gt; &amp;&amp; sink, // Optional args to be passed to make_coop() function. Args &amp;&amp;... args ) { auto coop = env.make_coop( forward&lt; Args &gt;(args)... ); auto mbox = sink.m_builder( *coop, mbox_t{} ); env.register_coop( move(coop) ); return mbox; }</span></span></code> </pre> <br><p>  Tidak ada keajaiban atau kejutan di sini.  Kita hanya perlu membuat kandang baru untuk agen yang mendasari pipa, mengisi kandang itu dengan agen dengan memanggil <em>pembangun tahap</em> tingkat <em>atas</em> , dan kemudian mendaftarkan kandang itu ke dalam SObjectizer.  Itu saja. </p><br><p>  Hasil dari <code>make_pipeline()</code> adalah mbox dari tahap paling kiri (pertama) dari pipeline.  Mbox itu harus digunakan untuk mengirim pesan ke saluran pipa. </p><br><h1 id="the-simulation-and-experiments-with-it">  Simulasi dan eksperimen dengannya </h1><br><p>  Jadi sekarang kita memiliki tipe data dan fungsi untuk logika aplikasi kita dan alat untuk menghubungkan fungsi-fungsi tersebut ke dalam pipa pemrosesan data.  Mari kita lakukan dan lihat hasilnya: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Launch SObjectizer in a separate thread. wrapped_env_t sobj; // Make a pipeline. auto pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(archiving), stage(distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(alarm_initiator), stage( []( const alarm_detected &amp; v ) { alarm_distribution( cerr, v ); } ) ) ) ); // Send messages to a pipeline in a loop with 10ms delays. for( uint8_t i = 0; i &lt; static_cast&lt; uint8_t &gt;(250); i += 10 ) { send&lt; raw_value &gt;( pipeline, raw_measure{ 0, 0, i } ); std::this_thread::sleep_for( chrono::milliseconds{10} ); } }</span></span></code> </pre> <br><p>  Jika kita menjalankan contoh itu, kita akan melihat output berikut: </p><br><pre> <code class="plaintext hljs">archiving (0,0) distributing (0,0) archiving (0,5) distributing (0,5) archiving (0,10) distributing (0,10) archiving (0,15) distributing (0,15) archiving (0,20) distributing (0,20) archiving (0,25) distributing (0,25) archiving (0,30) distributing (0,30) ... archiving (0,105) distributing (0,105) archiving (0,110) distributing (0,110) === alarm (0) === alarm_distribution (0) archiving (0,115) distributing (0,115) archiving (0,120) distributing (0,120) === alarm (0) === alarm_distribution (0)</code> </pre> <br><p>  Itu bekerja. </p><br><p>  Tetapi tampaknya tahap-tahap dari saluran pipa kami bekerja secara berurutan, satu demi satu, bukan? </p><br><p>  Ya, benar.  Ini karena semua agen pipa terikat ke operator SObjectizer default.  Dan operator itu hanya menggunakan satu utas pekerja untuk melayani pemrosesan pesan semua agen. </p><br><p>  Tapi ini bisa dengan mudah diubah.  Cukup berikan argumen tambahan untuk panggilan <code>make_pipeline()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Make a pipeline. auto pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(archiving), stage(distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(alarm_initiator), stage( []( const alarm_detected &amp; v ) { alarm_distribution( cerr, v ); } ) ) ), disp::thread_pool::make_dispatcher( sobj.environment() ).binder( disp::thread_pool::bind_params_t{}.fifo( disp::thread_pool::fifo_t::individual ) ) );</span></span></code> </pre> <br><p>  Ini menciptakan kumpulan utas baru dan mengikat semua agen pipa ke kumpulan itu.  Setiap agen akan dilayani oleh kolam independen dari agen lain. </p><br><p>  Jika kita menjalankan contoh yang dimodifikasi, kita dapat melihat sesuatu seperti itu: </p><br><pre> <code class="plaintext hljs">archiving (0,0) distributing (0,0) distributing (0,5) archiving (0,5) archiving (0,10) distributing (0,10) distributing (archiving (0,15) 0,15) archiving (0,20) distributing (0,20) archiving (0,25) distributing (0,25) archiving (0,distributing (030) ,30) ... archiving (0,distributing (0,105) 105) archiving (0,alarm_distribution (0) distributing (0,=== alarm (0) === 110) 110) archiving (distributing (0,0,115) 115) archiving (distributing (=== alarm (0) === 0alarm_distribution (0) 0,120) ,120)</code> </pre> <br><p>  Jadi kita dapat melihat bahwa berbagai tahapan kerja pipeline paralel. </p><br><p>  Tetapi apakah mungkin untuk melangkah lebih jauh dan memiliki kemampuan untuk mengikat tahapan ke operator yang berbeda? </p><br><p>  Ya, itu mungkin, tapi kami harus mengimplementasikan fungsi <code>stage()</code> berlebih: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Callable, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::arg_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::result_type &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out &gt; stage( <span class="hljs-keyword"><span class="hljs-keyword">disp_binder_shptr_t</span></span> disp_binder, Callable handler ) { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [binder = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(disp_binder), h = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(handler)]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">a_stage_point_t</span></span>&lt;In, Out&gt; &gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(binder), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(h), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ) -&gt;so_direct_mbox(); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(builder) }; }</code> </pre> <br><p> This version of <code>stage()</code> accepts not only a <em>stage handler</em> but also a dispatcher binder. Dispatcher binder is a way to bind an agent to the particular dispatcher. So to assign a stage to a specific working context we can create an appropriate dispatcher and then pass the binder to that dispatcher to <code>stage()</code> function. Let's do that: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// An active_obj dispatcher to be used for some stages. auto ao_disp = disp::active_obj::make_dispatcher( sobj.environment() ); // Make a pipeline. auto pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(ao_disp.binder(), archiving), stage(ao_disp.binder(), distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(ao_disp.binder(), alarm_initiator), stage(ao_disp.binder(), []( const alarm_detected &amp; v ) { alarm_distribution( cerr, v ); } ) ) ), disp::one_thread::make_dispatcher( sobj.environment() ).binder() );</span></span></code> </pre> <br><p> In that case stages <code>archiving</code> , <code>distribution</code> , <code>alarm_initiator</code> and <code>alarm_distribution</code> will work on own worker threads. All other stages will work on the same single worker thread. </p><br><h1 id="the-conclusion"> The conclusion </h1><br><p> This was an interesting experiment and I was surprised how easy SObjectizer could be used in something like reactive programming or data-flow programming. </p><br><p> However, I don't think that pipeline DSL can be practically meaningful. It's too simple and, maybe not flexible enough. But, I hope, it can be a base for more interesting experiments for those why need to deal with different workflows and data-processing pipelines. At least as a base for some ideas in that area. C++ language a rather good here and some (not so complicated) template magic can help to catch various errors at compile-time. </p><br><p> In conclusion, I want to say that we see SObjectizer not as a specialized tool for solving a particular problem, but as a basic set of tools to be used in solutions for different problems. And, more importantly, that basic set can be extended for your needs. Just take a look at <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SObjectizer</a> , try it, and share your feedback. Maybe you missed something in SObjectizer? Perhaps you don't like something? <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tell us</a> , and we can try to help you. </p><br><p> If you want to help further development of SObjectizer, please share a reference to it or to this article somewhere you want (Reddit, HackerNews, LinkedIn, Facebook, Twitter, ...). The more attention and the more feedback, the more new features will be incorporated into SObjectizer. </p><br><p> And many thanks for reading this ;) </p><br><p>  PS. The source code for that example can be found in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">that repository</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460123/">https://habr.com/ru/post/id460123/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460113/index.html">Beberapa cerita dari kehidupan JSOC CERT, atau forensik Unbanal</a></li>
<li><a href="../id460115/index.html">Sepuluh tahun pemrograman di Erlang</a></li>
<li><a href="../id460117/index.html">Apakah pelanggan terbesar di Rusia jackpot besar atau sakit kepala? Pengalaman AGIMA</a></li>
<li><a href="../id460119/index.html">Kesalahan yang tidak ditemukan oleh analisis kode statis karena tidak digunakan</a></li>
<li><a href="../id460121/index.html">Kesalahan yang tidak ditemukan oleh analisis kode statis karena tidak digunakan</a></li>
<li><a href="../id460125/index.html">Node.js atau Java: kinerja, sumber daya, kontrol aliran, popularitas, dan pengalaman pribadi</a></li>
<li><a href="../id460129/index.html">Robot dan Stroberi: Bagaimana AI Meningkatkan Hasil Lapangan</a></li>
<li><a href="../id460131/index.html">Sophos XG Firewall: Dari ME klasik ke NGFW dengan respons otomatis terhadap insiden keamanan informasi</a></li>
<li><a href="../id460133/index.html">Kotlin / Di Mana Saja - Latihan showcase: 31 Juli</a></li>
<li><a href="../id460135/index.html">Minggu Keamanan 29: Zoom, Keamanan, dan Kerentanan Drama</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>