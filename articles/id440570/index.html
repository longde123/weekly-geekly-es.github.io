<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ•™ ğŸ”€ ğŸ“¯ Peta Bayangan Reflektif: Bagian 2 - Implementasi ğŸ™‡ğŸ¾ ğŸ‘‰ ğŸ¦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Artikel ini menyajikan implementasi sederhana Peta Bayangan Reflektif (algoritme dijelaskan dalam artikel sebelumnya ). Selanjutnya, saya ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Peta Bayangan Reflektif: Bagian 2 - Implementasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440570/">  Halo, Habr!  Artikel ini menyajikan implementasi sederhana <b>Peta Bayangan Reflektif</b> (algoritme dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya</a> ).  Selanjutnya, saya akan menjelaskan bagaimana saya melakukannya dan apa jebakan itu.  Beberapa kemungkinan optimasi juga akan dipertimbangkan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/80f/588/6da/80f5886da498099f2e9716d4c0a53e3d.png" alt="gambar"><br>  <i>Gambar 1: Dari kiri ke kanan: tanpa RSM, dengan RSM, perbedaan</i> <br><a name="habracut"></a><br><h2>  Hasil </h2><br>  Pada <i>Gambar 1,</i> Anda dapat melihat hasil yang diperoleh menggunakan <b>RSM</b> .  Untuk membuat gambar-gambar ini, "Stanford Rabbit" dan tiga segi empat digunakan.  Pada gambar di sebelah kiri Anda dapat melihat hasil rendering tanpa <b>RSM</b> , hanya menggunakan <b>lampu spot</b> .  Segala sesuatu di tempat teduh benar-benar hitam.  Gambar di tengah menunjukkan hasil dengan <b>RSM</b> .  Perbedaan berikut terlihat: di mana-mana ada warna yang lebih cerah, merah muda, membanjiri lantai dan kelinci, bayangan tidak sepenuhnya hitam.  Gambar terakhir menunjukkan perbedaan antara yang pertama dan kedua, dan oleh karena itu kontribusi <b>RSM</b> .  Tepi dan artefak yang lebih kencang terlihat di gambar tengah, tetapi ini dapat diatasi dengan menyesuaikan ukuran inti, intensitas pencahayaan tidak langsung, dan jumlah sampel. <br><br><h2>  Implementasi </h2><br>  Algoritma diimplementasikan pada mesinnya sendiri.  Shader ditulis dalam HLSL, dan rendernya ada di DirectX 11. Saya sudah menyiapkan <b>pemetaan bayangan</b> dan <b>bayangan</b> untuk pencahayaan terarah (sumber cahaya terarah) sebelum menulis artikel ini.  Pertama, saya menerapkan <b>RSM</b> untuk lampu arah dan hanya setelah saya menambahkan dukungan untuk <b>peta bayangan</b> dan <b>RSM</b> untuk lampu sorot. <br><br><h3>  Ekstensi peta bayangan </h3><br>  Secara tradisional, <b>Shadow Maps</b> (SM) tidak lebih dari peta kedalaman.  Ini berarti Anda bahkan tidak memerlukan pixel / fragmen shader untuk mengisi SM.  Namun, untuk <b>RSM</b> Anda membutuhkan beberapa buffer tambahan.  Anda perlu menyimpan <b>posisi</b> ruang-dunia, ruang-dunia <b>normal</b> dan <b>fluks</b> (keluaran cahaya).  Ini berarti bahwa Anda memerlukan pixel / fragmen shader dengan beberapa target render.  Ingatlah bahwa untuk teknik ini, Anda perlu memotong <b>pemusnahan wajah</b> , bukan bagian depan. <br><br>  Menggunakan tepi depan <b>pemusnahan wajah</b> adalah cara yang banyak digunakan untuk menghindari artefak bayangan, tetapi ini tidak bekerja dengan <b>RSM</b> . <br><br>  Anda melewati posisi ruang-dunia dan normals ke pixel shader dan menulisnya ke buffer yang sesuai.  Jika Anda menggunakan <b>pemetaan normal</b> , maka hitung juga dalam pixel shader.  <b>Fluks</b> dihitung di sana, dengan mengalikan bahan albedo dengan warna sumber cahaya.  Untuk <b>cahaya spot,</b> Anda perlu mengalikan nilai yang dihasilkan dengan sudut kejadian.  Untuk <b>cahaya arah,</b> gambar yang tidak diarsir diperoleh. <br><br><h3>  Mempersiapkan perhitungan pencahayaan </h3><br>  Ada beberapa hal yang perlu Anda lakukan untuk bagian utama.  Anda harus mengikat semua buffer yang digunakan dalam shadow pass sebagai tekstur.  Anda juga membutuhkan nomor acak.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel resmi</a> mengatakan bahwa Anda perlu melakukan pra-perhitungan angka-angka ini dan menyimpannya dalam buffer untuk mengurangi jumlah operasi dalam pengambilan sampel <b>RSM</b> .  Karena algoritma ini berat dalam hal kinerja, saya sepenuhnya setuju dengan artikel resmi.  Disarankan juga untuk mematuhi koherensi temporal (gunakan pola pengambilan sampel yang sama untuk semua perhitungan pencahayaan tidak langsung).  Ini akan mencegah berkedip ketika setiap frame menggunakan bayangan yang berbeda. <br><br>  Anda memerlukan dua angka floating point acak dalam rentang [0, 1] untuk setiap sampel.  Angka acak ini akan digunakan untuk menentukan koordinat sampel.  Anda juga akan membutuhkan matriks yang sama yang Anda gunakan untuk mengubah posisi dari ruang dunia (ruang dunia) ke ruang bayangan (ruang sumber cahaya).  Anda juga akan memerlukan parameter seperti itu untuk pengambilan sampel, yang akan memberi warna hitam jika Anda mengambil sampel di luar batas tekstur. <br><br><h3>  Passing Lighting </h3><br>  Sekarang bagian yang sulit untuk dipahami.  Saya sarankan Anda menghitung pencahayaan tidak langsung setelah Anda menghitung pencahayaan langsung untuk sumber cahaya tertentu.  Ini karena Anda memerlukan quad layar penuh untuk <b>cahaya directional</b> .  Namun, untuk <b>cahaya</b> <b>spot</b> dan <b>point,</b> Anda biasanya ingin menggunakan jerat dengan bentuk tertentu dengan <b>pemusnahan</b> untuk mengisi lebih sedikit piksel. <br><br>  Dalam kode di bawah ini, penerangan tidak langsung dihitung untuk piksel.  Selanjutnya, saya akan menjelaskan apa yang terjadi di sana. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoReflectiveShadowMapping</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 P, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divideByW, float3 N)</span></span></span><span class="hljs-function"> </span></span>{ float4 textureSpacePosition = mul(lightViewProjectionTextureMatrix, float4(P, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (divideByW) textureSpacePosition.xyz /= textureSpacePosition.w; float3 indirectIllumination = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rMax = rsmRMax; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; rsmSampleCount; ++i) { float2 rnd = rsmSamples[i].xy; float2 coords = textureSpacePosition.xy + rMax * rnd; float3 vplPositionWS = g_rsmPositionWsMap .Sample(g_clampedSampler, coords.xy).xyz; float3 vplNormalWS = g_rsmNormalWsMap .Sample(g_clampedSampler, coords.xy).xyz; float3 flux = g_rsmFluxMap.Sample(g_clampedSampler, coords.xy).xyz; float3 result = flux * ((max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dot(vplNormalWS, P â€“ vplPositionWS)) * max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dot(N, vplPositionWS â€“ P))) / <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(length(P â€“ vplPositionWS), <span class="hljs-number"><span class="hljs-number">4</span></span>)); result *= rnd.x * rnd.x; indirectIllumination += result; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saturate(indirectIllumination * rsmIntensity); }</code> </pre> <br>  Argumen pertama untuk fungsi adalah <b>P</b> , yang merupakan posisi ruang-dunia (dalam ruang dunia) untuk piksel tertentu.  <b>DivideByW</b> digunakan untuk divisi prospektif yang diperlukan untuk mendapatkan nilai <b>Z yang</b> benar.  <b>N</b> adalah ruang-dunia normal. <br><br><pre> <code class="cpp hljs">float4 textureSpacePosition = mul(lightViewProjectionTextureMatrix, float4(P, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (divideByW) textureSpacePosition.xyz /= textureSpacePosition.w; float3 indirectIllumination = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rMax = rsmRMax;</code> </pre><br>  Pada bagian kode ini, posisi ruang-cahaya (relatif terhadap sumber cahaya) dihitung, variabel pencahayaan tidak langsung diinisialisasi, di mana nilai-nilai yang dihitung dari setiap sampel akan dijumlahkan, dan variabel <b>rMax diatur</b> dari persamaan pencahayaan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel resmi</a> , nilai yang akan saya jelaskan di bagian berikutnya. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; rsmSampleCount; ++i) { float2 rnd = rsmSamples[i].xy; float2 coords = textureSpacePosition.xy + rMax * rnd; float3 vplPositionWS = g_rsmPositionWsMap .Sample(g_clampedSampler, coords.xy).xyz; float3 vplNormalWS = g_rsmNormalWsMap .Sample(g_clampedSampler, coords.xy).xyz; float3 flux = g_rsmFluxMap.Sample(g_clampedSampler, coords.xy).xyz;</code> </pre><br>  Di sini kita memulai siklus dan menyiapkan variabel kita untuk persamaan.  Untuk keperluan optimasi, sampel acak yang saya hitung sudah mengandung offset koordinat, yaitu, untuk mendapatkan koordinat UV, saya hanya perlu menambahkan <b>rMax * rnd</b> ke koordinat ruang-cahaya.  Jika UV yang dihasilkan di luar kisaran [0,1], sampel harus berwarna hitam.  Itu logis, karena mereka melampaui jangkauan pencahayaan. <br><br><pre> <code class="cpp hljs"> float3 result = flux * ((max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dot(vplNormalWS, P â€“ vplPositionWS)) * max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dot(N, vplPositionWS â€“ P))) / <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(length(P â€“ vplPositionWS), <span class="hljs-number"><span class="hljs-number">4</span></span>)); result *= rnd.x * rnd.x; indirectIllumination += result; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saturate(indirectIllumination * rsmIntensity);</code> </pre><br>  Ini adalah bagian di mana persamaan pencahayaan tidak langsung dihitung ( <i>Gambar 2</i> ), dan juga ditimbang sesuai dengan jarak dari koordinat ruang-cahaya ke sampel.  Persamaannya terlihat menakutkan, dan kodenya tidak membantu untuk memahami segalanya, jadi saya akan menjelaskan lebih detail. <br><br>  Variabel <b>Î¦</b> (phi) adalah <b>fluks</b> cahaya, yang merupakan intensitas radiasi.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel sebelumnya</a> menjelaskan <b>fluks</b> lebih terinci. <br><br>  Timbangan <b>fluks</b> dengan dua karya seni skalar.  Yang pertama adalah antara normal sumber cahaya (texel) dan arah dari sumber cahaya ke posisi saat ini.  Yang kedua adalah antara arus normal dan vektor arah dari posisi saat ini ke posisi sumber cahaya (texel).  Agar tidak memberikan kontribusi negatif pada pencahayaan (ternyata jika pikselnya tidak menyala), produk skalar terbatas pada kisaran [0, âˆ].  Dalam persamaan ini, normalisasi dilakukan pada akhirnya, saya kira, untuk alasan kinerja.  Hal yang sama dapat diterima untuk menormalkan vektor arah sebelum melakukan produk skalar. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ab4/dd3/258/ab4dd3258620fc3bae4a044df4072cf5.png" alt="gambar"><br>  <i>Gambar 2: Persamaan pencahayaan titik dengan posisi <b>x</b> dan sumber cahaya normal <b>n</b> pixel arah <b>p</b></i> <br><br>  Hasil pass ini dapat dicampur dengan backbuffer (pencahayaan langsung), dan hasilnya akan seperti pada <i>Gambar 1</i> . <br><br><h2>  Perangkap </h2><br>  Ketika menerapkan algoritma ini, saya mengalami beberapa masalah.  Saya akan berbicara tentang masalah ini sehingga Anda tidak menginjak penggaruk yang sama. <br><br><h3>  Sampler salah </h3><br>  Saya menghabiskan banyak waktu untuk mencari tahu mengapa pencahayaan tidak langsung saya terlihat berulang.  Tekstur Crytek Sponza disembunyikan, jadi Anda perlu sampler terbungkus untuk itu.  Tetapi untuk <b>RSM</b> itu sangat tidak cocok. <br><br><div class="spoiler">  <b class="spoiler_title">Opengl</b> <div class="spoiler_text">  OpenGL menetapkan tekstur <b>RSM</b> ke GL_CLAMP_TO_BORDER <br></div></div><br><h3>  Nilai khusus </h3><br>  Untuk meningkatkan alur kerja, penting untuk dapat mengubah beberapa variabel dengan menekan tombol.  Misalnya, intensitas iluminasi tidak langsung dan rentang pengambilan sampel ( <b>rMax</b> ).  Parameter ini harus disesuaikan untuk setiap sumber cahaya.  Jika Anda memiliki rentang pengambilan sampel yang besar, maka Anda mendapatkan pencahayaan tidak langsung dari mana-mana, yang berguna untuk adegan besar.  Untuk pencahayaan tidak langsung yang lebih lokal, Anda akan membutuhkan rentang yang lebih kecil.  <i>Gambar 3</i> menunjukkan pencahayaan tidak langsung global dan lokal. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a08/c98/7f7/a08c987f7a9bf46344a623bafebfc903.png" alt="gambar"><br>  <i>Gambar 3: Demonstrasi ketergantungan <b>rMax</b> .</i> <br><br><h3>  Bagian yang terpisah </h3><br>  Pada awalnya, saya berpikir bahwa saya bisa membuat pencahayaan tidak langsung dalam shader, di mana saya mempertimbangkan pencahayaan langsung.  Untuk <b>cahaya directional,</b> ini berfungsi karena Anda masih menggambar quad layar penuh.  Namun, untuk <b>cahaya</b> <b>spot</b> dan <b>point,</b> Anda perlu mengoptimalkan perhitungan pencahayaan tidak langsung.  Karena itu, saya menganggap pencahayaan tidak langsung sebagai bagian terpisah, yang diperlukan jika Anda juga ingin melakukan <b>interpolasi layar-ruang</b> . <br><br><h3>  Cache </h3><br>  Algoritma ini tidak ramah dengan cache sama sekali.  Ini melakukan pengambilan sampel pada titik-titik acak dalam beberapa tekstur.  Jumlah sampel tanpa optimisasi juga sangat besar.  Dengan resolusi 1280 * 720 dan jumlah sampel <b>RSM</b> 400, Anda akan menghasilkan 1.105.920.000 sampel untuk setiap sumber cahaya. <br><br><h3>  Pro dan kontra </h3><br>  Saya akan mendaftar pro dan kontra dari algoritma perhitungan pencahayaan tidak langsung ini. <br><table><tbody><tr><td>  Untuk </td><td>  <b>Terhadap</b> </td></tr><tr><td>  Algoritma mudah dimengerti </td><td>  Sama sekali tidak berteman dengan cache </td></tr><tr><td>  Terintegrasi dengan baik dengan penyaji tangguhan </td><td>  Diperlukan pengaturan variabel </td></tr><tr><td>  Dapat digunakan dalam algoritma lain ( <b>LPV</b> ) </td><td>  Pilihan paksa antara penerangan tidak langsung lokal dan global </td></tr></tbody></table><h2>  Optimalisasi </h2><br>  Saya melakukan beberapa upaya untuk meningkatkan kecepatan algoritma ini.  Seperti dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel resmi</a> , Anda dapat menerapkan <b>interpolasi layar-ruang</b> .  Saya melakukan ini, dan rendering sedikit lebih cepat.  Di bawah ini saya akan menjelaskan beberapa optimasi, dan membuat perbandingan (dalam bingkai per detik) antara implementasi berikut, menggunakan adegan dengan 3 dinding dan kelinci: tanpa <b>RSM</b> , implementasi naif <b>RSM</b> , diinterpolasi oleh <b>RSM</b> . <br><br><h3>  Periksa-Z </h3><br>  Salah satu alasan <b>RSM</b> saya bekerja tidak efisien adalah karena saya juga menghitung pencahayaan tidak langsung untuk piksel yang merupakan bagian dari skybox.  Skybox jelas tidak membutuhkannya. <br><br><h3>  Pengambilan sampel CPU secara acak </h3><br>  Perhitungan awal sampel tidak hanya akan memberikan koherensi temporal yang lebih besar, tetapi juga menyelamatkan Anda dari keharusan untuk menghitung kembali sampel-sampel ini dalam shader. <br><br><h3>  Interpolasi layar-ruang </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel resmi</a> menyarankan menggunakan target render resolusi rendah untuk menghitung pencahayaan tidak langsung.  Untuk adegan dengan banyak normal normal dan dinding lurus, informasi pencahayaan dapat dengan mudah diinterpolasi antara titik dengan resolusi lebih rendah.  Saya tidak akan menjelaskan interpolasi secara rinci sehingga artikel ini sedikit lebih pendek. <br><br><h2>  Kesimpulan </h2><br>  Di bawah ini adalah hasil untuk jumlah sampel yang berbeda.  Saya punya beberapa komentar mengenai hasil ini: <br><br><ul><li>  Secara logis, FPS tetap sekitar 700 untuk jumlah sampel yang berbeda ketika perhitungan <b>RSM</b> tidak dilakukan. </li><li>  Interpolasi memberikan beberapa overhead dan tidak terlalu berguna dengan sejumlah kecil sampel. </li><li>  Bahkan dengan 100 sampel, gambar akhir terlihat cukup bagus.  Ini mungkin disebabkan oleh interpolasi, yang â€œmengaburkanâ€ pencahayaan tidak langsung. </li></ul><br><table><tbody><tr><td>  Jumlah sampel </td><td>  FPS untuk Tanpa RSM </td><td>  FPS untuk RSM Naif </td><td>  FPS untuk RSM Terinterpolasi </td></tr><tr><td>  100 </td><td>  ~ 700 </td><td>  152 </td><td>  264 </td></tr><tr><td>  200 </td><td>  ~ 700 </td><td>  89 </td><td>  179 </td></tr><tr><td>  300 </td><td>  ~ 700 </td><td>  62 </td><td>  138 </td></tr><tr><td>  400 </td><td>  ~ 700 </td><td>  44 </td><td>  116 </td></tr></tbody></table></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id440570/">https://habr.com/ru/post/id440570/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id440560/index.html">Alexander Belokrylov dan Dmitry Chuyko tentang Liberica JDK di jug.msk.ru</a></li>
<li><a href="../id440562/index.html">Windows Phone - SEMUANYA, Ini Lagi atau Lagi</a></li>
<li><a href="../id440564/index.html">GPT-2 neural network dari OpenAI. Mulai cepat</a></li>
<li><a href="../id440566/index.html">Mempercepat tanpa hambatan atau mengenal SIMD</a></li>
<li><a href="../id440568/index.html">Kami sedang menulis aplikasi pembelajaran di Go dan Javascript untuk mengevaluasi pengembalian stok riil. Bagian 2 - Menguji backend</a></li>
<li><a href="../id440574/index.html">Piala AI Rusia 2018, sejarah 9 tempat</a></li>
<li><a href="../id440576/index.html">Perubahan penting pada CTE di PostgreSQL 12</a></li>
<li><a href="../id440582/index.html">Apakah mobil listrik ditarik ke bawah perusahaan mobil?</a></li>
<li><a href="../id440584/index.html">Apa yang salah dengan Raspberry Pi</a></li>
<li><a href="../id440586/index.html">Konsensus Eksonum: Cara Kerjanya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>