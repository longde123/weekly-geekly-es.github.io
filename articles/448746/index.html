<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游꾼游 游 驕쉺잺 칈ndices en PostgreSQL - 7 (GIN) 游 游녦游낕 游댯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ya nos hemos familiarizado con el motor de indexaci칩n PostgreSQL y la interfaz de los m칠todos de acceso y hemos discutido los 칤ndices hash , los 치rbol...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>칈ndices en PostgreSQL - 7 (GIN)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/448746/">  Ya nos hemos familiarizado con el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">motor de indexaci칩n</a> PostgreSQL y la interfaz de los m칠todos de acceso y hemos discutido los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">칤ndices hash</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">los 치rboles B</a> , as칤 como los 칤ndices <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GiST</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SP-GiST</a> .  Y este art칤culo presentar치 el 칤ndice GIN. <br><br><h1>  Ginebra </h1><br>  <em>"Gin? ... Gin es, al parecer, un licor tan americano? .."</em> <em><br></em>  <em>"No soy un trago, 춰oh, chico curioso!"</em>  <em>Una vez m치s, el viejo se encendi칩, otra vez se dio cuenta de s칤 mismo y otra vez se tom칩 de la mano.</em>  <em>"No soy un trago, sino un esp칤ritu poderoso e imp치vido, y no hay tal magia en el mundo que no pueda hacer".</em> <br>  - Lazar Lagin, "Viejo Khottabych". <br><br>  <em>Gin significa 칤ndice invertido generalizado y debe considerarse como un genio, no una bebida.</em> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">L칄AME</a> <br><a name="habracut"></a><br><h2>  Concepto general </h2><br>  GIN es el 칤ndice invertido generalizado abreviado.  Este es un llamado <em>칤ndice invertido</em> .  Manipula los tipos de datos cuyos valores no son at칩micos, sino que consisten en elementos.  Llamaremos a estos tipos compuestos.  Y estos no son los valores que se indexan, sino elementos individuales;  cada elemento hace referencia a los valores en los que ocurre. <br><br>  Una buena analog칤a de este m칠todo es el 칤ndice al final de un libro, que para cada t칠rmino, proporciona una lista de p치ginas donde aparece este t칠rmino.  El m칠todo de acceso debe garantizar una b칰squeda r치pida de elementos indexados, al igual que el 칤ndice de un libro.  Por lo tanto, estos elementos se almacenan como un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">치rbol B</a> familiar (se usa una implementaci칩n diferente y m치s simple, pero no importa en este caso).  Un conjunto ordenado de referencias a las filas de la tabla que contienen valores compuestos con el elemento est치 vinculado a cada elemento.  El orden no es esencial para la recuperaci칩n de datos (el orden de clasificaci칩n de los TID no significa mucho), pero es importante para la estructura interna del 칤ndice. <br><br>  Los elementos nunca se eliminan del 칤ndice GIN.  Se supone que los valores que contienen elementos pueden desaparecer, surgir o variar, pero el conjunto de elementos de los que est치n compuestos es m치s o menos estable.  Esta soluci칩n simplifica significativamente los algoritmos para el trabajo concurrente de varios procesos con el 칤ndice. <br><br>  Si la lista de TID es bastante peque침a, puede caber en la misma p치gina que el elemento (y se llama "la lista de publicaci칩n").  Pero si la lista es grande, se necesita una estructura de datos m치s eficiente, y ya estamos conscientes de ello: es B-tree nuevamente.  Dicho 치rbol se encuentra en p치ginas de datos separadas (y se llama "el 치rbol de publicaci칩n"). <br><br>  Entonces, el 칤ndice GIN consiste en el 치rbol B de elementos, y los 치rboles B o listas planas de TID est치n vinculados a las filas de hojas de ese 치rbol B. <br><br>  Al igual que los 칤ndices GiST y SP-GiST, discutidos anteriormente, GIN proporciona un desarrollador de aplicaciones con la interfaz para admitir varias operaciones sobre tipos de datos compuestos. <br><br><h2>  B칰squeda de texto completo </h2><br>  El 치rea principal de aplicaci칩n para el m칠todo GIN es acelerar la b칰squeda de texto completo, lo que, por lo tanto, es razonable usar como ejemplo en una discusi칩n m치s detallada de este 칤ndice. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El art칤culo relacionado con GiST</a> ya ha proporcionado una peque침a introducci칩n a la b칰squeda de texto completo, as칤 que vayamos directamente al grano sin repeticiones.  Est치 claro que los valores compuestos en este caso son <em>documentos</em> , y los elementos de estos documentos son <em>lexemas</em> . <br><br>  Consideremos el ejemplo del art칤culo relacionado con GiST: <br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> ts(doc <span class="hljs-type"><span class="hljs-type">text</span></span>, doc_tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ts(doc) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'Can a sheet slitter slit sheets?'</span></span>), (<span class="hljs-string"><span class="hljs-string">'How many sheets could a sheet slitter slit?'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I slit a sheet, a sheet I slit.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Upon a slitted sheet I sit.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Whoever slit the sheets is a good sheet slitter.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I am a sheet slitter.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I slit sheets.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I am the sleekest sheet slitter that ever slit sheets.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'She slits the sheet she sits on.'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> doc_tsv = to_tsvector(doc); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(doc_tsv);</code> </pre> <br>  Una posible estructura de este 칤ndice se muestra en la figura: <br><br><img src="https://habrastorage.org/webt/lc/nh/m-/lcnhm-vqquxgvzpklv8kemu6z-a.png"><br><br>  A diferencia de todas las figuras anteriores, las referencias a las filas de la tabla (TID) se denotan con valores num칠ricos sobre un fondo oscuro (el n칰mero de p치gina y la posici칩n en la p치gina) en lugar de con flechas. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ctid, left(doc,<span class="hljs-number"><span class="hljs-number">20</span></span>), doc_tsv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts;</code> </pre><pre> <code class="plaintext hljs"> ctid | left | doc_tsv -------+----------------------+--------------------------------------------------------- (0,1) | Can a sheet slitter | 'sheet':3,6 'slit':5 'slitter':4 (0,2) | How many sheets coul | 'could':4 'mani':2 'sheet':3,6 'slit':8 'slitter':7 (0,3) | I slit a sheet, a sh | 'sheet':4,6 'slit':2,8 (1,1) | Upon a slitted sheet | 'sheet':4 'sit':6 'slit':3 'upon':1 (1,2) | Whoever slit the she | 'good':7 'sheet':4,8 'slit':2 'slitter':9 'whoever':1 (1,3) | I am a sheet slitter | 'sheet':4 'slitter':5 (2,1) | I slit sheets. | 'sheet':3 'slit':2 (2,2) | I am the sleekest sh | 'ever':8 'sheet':5,10 'sleekest':4 'slit':9 'slitter':6 (2,3) | She slits the sheet | 'sheet':4 'sit':6 'slit':2 (9 rows)</code> </pre><br>  En este ejemplo especulativo, la lista de TID se ajusta a p치ginas regulares para todos los lexemas, excepto "hoja", "rendija" y "cortadora".  Estos lexemas aparecieron en muchos documentos, y las listas de TID para ellos se han colocado en 치rboles B individuales. <br><br>  Por cierto, 쯖칩mo podemos determinar cu치ntos documentos contienen un lexema?  Para una mesa peque침a, una t칠cnica "directa", que se muestra a continuaci칩n, funcionar치, pero aprenderemos m치s qu칠 hacer con las m치s grandes. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (unnest(doc_tsv)).lexeme, count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>;</code> </pre><pre> <code class="plaintext hljs"> lexeme | count ----------+------- sheet | 9 slit | 8 slitter | 5 sit | 2 upon | 1 mani | 1 whoever | 1 sleekest | 1 good | 1 could | 1 ever | 1 (11 rows)</code> </pre><br>  Tenga en cuenta tambi칠n que, a diferencia de un 치rbol B normal, las p치ginas del 칤ndice GIN est치n conectadas por una lista unidireccional en lugar de una bidireccional.  Esto es suficiente ya que el recorrido de un 치rbol se realiza de una sola manera. <br><br><h3>  Ejemplo de consulta </h3><br>  쮺칩mo se realizar치 la siguiente consulta para nuestro ejemplo? <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> doc_tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'many &amp; slitter'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------- Bitmap Heap Scan on ts Recheck Cond: (doc_tsv @@ to_tsquery('many &amp; slitter'::text)) -&gt; Bitmap Index Scan on ts_doc_tsv_idx Index Cond: (doc_tsv @@ to_tsquery('many &amp; slitter'::text)) (4 rows)</code> </pre><br>  Los lexemas individuales (claves de b칰squeda) se extraen primero de la consulta: "mani" y "slitter".  Esto se realiza mediante una funci칩n API especializada que tiene en cuenta el tipo de datos y la estrategia determinados por la clase de operador: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'tsvector_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gin'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amopstrategy -----------------------+-------------- @@(tsvector,tsquery) | 1 matching search query @@@(tsvector,tsquery) | 2 synonym for @@ (for backward compatibility) (2 rows)</code> </pre><br>  En el 치rbol B de lexemas, a continuaci칩n encontramos ambas claves y revisamos listas listas de TID.  Obtenemos: <br><br>  para "mani" - (0,2). <br>  para "cortadora" - (0,1), (0,2), (1,2), (1,3), (2,2). <br><br><img src="https://habrastorage.org/webt/mg/qc/do/mgqcdou-xlhsztvkxii5qluc5rq.png"><br><br>  Finalmente, para cada TID encontrado, se llama a una funci칩n de coherencia API, que debe determinar cu치l de las filas encontradas coincide con la consulta de b칰squeda.  Dado que los lexemas en nuestra consulta est치n unidos por Boolean "y", la 칰nica fila devuelta es (0,2): <br><br><pre> <code class="plaintext hljs"> | | | consistency | | | function TID | mani | slitter | slit &amp; slitter -------+------+---------+---------------- (0,1) | f | T | f (0,2) | T | T | T (1,2) | f | T | f (1,3) | f | T | f (2,2) | f | T | f</code> </pre><br>  Y el resultado es: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> doc_tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'many &amp; slitter'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> doc --------------------------------------------- How many sheets could a sheet slitter slit? (1 row)</code> </pre><br>  Si comparamos este enfoque con el ya discutido para GiST, la ventaja de GIN para la b칰squeda de texto completo parece evidente.  Pero hay m치s en esto de lo que parece. <br><br><h3>  El problema de una actualizaci칩n lenta </h3><br>  La cuesti칩n es que la inserci칩n o actualizaci칩n de datos en el 칤ndice GIN es bastante lenta.  Cada documento generalmente contiene muchos lexemas para indexar.  Por lo tanto, cuando solo se agrega o actualiza un documento, tenemos que actualizar masivamente el 치rbol de 칤ndice. <br><br>  Por otro lado, si varios documentos se actualizan simult치neamente, algunos de sus lexemas pueden ser iguales, y la cantidad total de trabajo ser치 menor que cuando se actualizan los documentos uno por uno. <br><br>  El 칤ndice GIN tiene un par치metro de almacenamiento "fastupdate", que podemos especificar durante la creaci칩n del 칤ndice y actualizarlo m치s tarde: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(doc_tsv) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (fastupdate = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>);</code> </pre><br>  Con este par치metro activado, las actualizaciones se acumular치n en una lista desordenada separada (en p치ginas conectadas individuales).  Cuando esta lista se hace lo suficientemente grande o durante la aspiraci칩n, todas las actualizaciones acumuladas se realizan instant치neamente en el 칤ndice.  La lista para considerar "suficientemente grande" est치 determinada por el par치metro de configuraci칩n "gin_pending_list_limit" o por el par치metro de almacenamiento del mismo nombre del 칤ndice. <br><br>  Pero este enfoque tiene inconvenientes: primero, la b칰squeda se ralentiza (ya que la lista desordenada debe revisarse adem치s del 치rbol) y, en segundo lugar, una pr칩xima actualizaci칩n puede llevar mucho tiempo inesperadamente si la lista desordenada se ha desbordado. <br><br><h3>  B칰squeda de una coincidencia parcial </h3><br>  Podemos usar la coincidencia parcial en la b칰squeda de texto completo.  Por ejemplo, considere la siguiente consulta: <br><br><pre> <code class="pgsql hljs">gin=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> doc_tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'slit:*'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> doc -------------------------------------------------------- Can a sheet slitter slit sheets? How many sheets could a sheet slitter slit? I slit a sheet, a sheet I slit. Upon a slitted sheet I sit. Whoever slit the sheets is a good sheet slitter. I am a sheet slitter. I slit sheets. I am the sleekest sheet slitter that ever slit sheets. She slits the sheet she sits on. (9 rows)</code> </pre><br>  Esta consulta encontrar치 documentos que contienen lexemas que comienzan con "hendidura".  En este ejemplo, tales lexemas son "slit" y "slitter". <br><br>  Una consulta ciertamente funcionar치 de todos modos, incluso sin 칤ndices, pero GIN tambi칠n permite acelerar la siguiente b칰squeda: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> doc_tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'slit:*'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------- Bitmap Heap Scan on ts Recheck Cond: (doc_tsv @@ to_tsquery('slit:*'::text)) -&gt; Bitmap Index Scan on ts_doc_tsv_idx Index Cond: (doc_tsv @@ to_tsquery('slit:*'::text)) (4 rows)</code> </pre><br>  Aqu칤, todos los lexemas que tienen el prefijo especificado en la consulta de b칰squeda se buscan en el 치rbol y se unen mediante booleano "o". <br><br><h3>  Lexemas frecuentes e infrecuentes </h3><br>  Para ver c칩mo funciona la indexaci칩n en los datos en vivo, tomemos el archivo del correo electr칩nico "pgsql-hackers", que ya hemos utilizado al analizar GiST.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Esta versi칩n del archivo</a> contiene 356125 mensajes con la fecha de env칤o, asunto, autor y texto. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> tsv = to_tsvector(body_plain);</code> </pre><pre> <code class="plaintext hljs">NOTICE: word is too long to be indexed DETAIL: Words longer than 2047 characters are ignored. ... UPDATE 356125</code> </pre><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(tsv);</code> </pre><br>  Consideremos un lexema que ocurre en muchos documentos.  La consulta que utiliza "unnest" no funcionar치 en un tama침o de datos tan grande, y la t칠cnica correcta es utilizar la funci칩n "ts_stat", que proporciona la informaci칩n sobre lexemas, la cantidad de documentos donde ocurrieron y la cantidad total de ocurrencias. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> word, ndoc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts_stat(<span class="hljs-string"><span class="hljs-string">'select tsv from mail_messages'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ndoc <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><pre> <code class="plaintext hljs"> word | ndoc -------+-------- re | 322141 wrote | 231174 use | 176917 (3 rows)</code> </pre><br>  Vamos a elegir "escribi칩". <br><br>  Y tomaremos algunas palabras que no son frecuentes para el correo electr칩nico de los desarrolladores, digamos "tatuaje": <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> word, ndoc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts_stat(<span class="hljs-string"><span class="hljs-string">'select tsv from mail_messages'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> word = <span class="hljs-string"><span class="hljs-string">'tattoo'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> word | ndoc --------+------ tattoo | 2 (1 row)</code> </pre><br>  쮿ay alg칰n documento donde ocurran ambos lexemas?  Parece que hay: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote &amp; tattoo'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 1 (1 row)</code> </pre><br>  Surge una pregunta sobre c칩mo realizar esta consulta.  Si obtenemos listas de TID para ambos lexemas, como se describi칩 anteriormente, la b칰squeda evidentemente ser치 ineficiente: tendremos que pasar por m치s de 200 mil valores, de los cuales solo quedar치 uno.  Afortunadamente, utilizando las estad칤sticas del planificador, el algoritmo comprende que el lexema "escrito" ocurre con frecuencia, mientras que el "tatuaje" ocurre con poca frecuencia.  Por lo tanto, se realiza la b칰squeda del lexema infrecuente, y los dos documentos recuperados se comprueban para detectar la aparici칩n del lexema "escrito".  Y esto queda claro en la consulta, que se realiza r치pidamente: <br><br><pre> <code class="pgsql hljs">fts=# \<span class="hljs-keyword"><span class="hljs-keyword">timing</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote &amp; tattoo'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 1 (1 row) Time: 0,959 ms</code> </pre><br>  La b칰squeda de "escrito" solo lleva mucho m치s tiempo: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count -------- 231174 (1 row) Time: 2875,543 ms (00:02,876)</code> </pre><br>  Esta optimizaci칩n ciertamente funciona no solo para dos lexemas, sino tambi칠n en casos m치s complejos. <br><br><h3>  Limitar el resultado de la consulta </h3><br>  Una caracter칤stica del m칠todo de acceso GIN es que el resultado siempre se devuelve como un mapa de bits: este m칠todo no puede devolver el resultado TID por TID.  Es por esto que todos los planes de consulta en este art칤culo usan escaneo de mapa de bits. <br><br>  Por lo tanto, la limitaci칩n del resultado del an치lisis de 칤ndice utilizando la cl치usula LIMIT no es del todo eficiente.  Preste atenci칩n al costo previsto de la operaci칩n (campo "costo" del nodo "L칤mite"): <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------------------------------------- Limit (cost=1283.61..1285.13 rows=1) -&gt; Bitmap Heap Scan on mail_messages (cost=1283.61..209975.49 rows=137207) Recheck Cond: (tsv @@ to_tsquery('wrote'::text)) -&gt; Bitmap Index Scan on mail_messages_tsv_idx (cost=0.00..1249.30 rows=137207) Index Cond: (tsv @@ to_tsquery('wrote'::text)) (5 rows)</code> </pre><br>  El costo se estima en 1285.13, que es un poco mayor que el costo de construir todo el mapa de bits 1249.30 (campo "costo" del nodo Escaneo de 칤ndice de mapa de bits). <br><br>  Por lo tanto, el 칤ndice tiene una capacidad especial para limitar el n칰mero de resultados.  El valor umbral se especifica en el par치metro de configuraci칩n "gin_fuzzy_search_limit" y es igual a cero de forma predeterminada (no tiene lugar ninguna limitaci칩n).  Pero podemos establecer el valor umbral: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> gin_fuzzy_search_limit = <span class="hljs-number"><span class="hljs-number">1000</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 5746 (1 row)</code> </pre><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> gin_fuzzy_search_limit = <span class="hljs-number"><span class="hljs-number">10000</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 14726 (1 row)</code> </pre><br>  Como podemos ver, el n칰mero de filas devueltas por la consulta difiere para diferentes valores de par치metros (si se utiliza el acceso al 칤ndice).  La limitaci칩n no es estricta: se pueden devolver m치s filas de las especificadas, lo que justifica la parte "difusa" del nombre del par치metro. <br><br><h3>  Representaci칩n compacta </h3><br>  Entre el resto, los 칤ndices GIN son buenos gracias a su compacidad.  Primero, si se produce el mismo lexema en varios documentos (y este suele ser el caso), se almacena en el 칤ndice solo una vez.  En segundo lugar, los TID se almacenan en el 칤ndice de forma ordenada, y esto nos permite usar una compresi칩n simple: cada TID siguiente de la lista se almacena realmente como su diferencia del anterior;  Esto suele ser un n칰mero peque침o, que requiere muchos menos bits que un TID completo de seis bytes. <br><br>  Para tener una idea del tama침o, construyamos un 치rbol B a partir del texto de los mensajes.  Pero una comparaci칩n justa ciertamente no va a suceder: <br><br><ul><li>  GIN est치 construido en un tipo de datos diferente ("tsvector" en lugar de "texto"), que es m치s peque침o, </li><li>  Al mismo tiempo, el tama침o de los mensajes para el 치rbol B debe acortarse a aproximadamente dos kilobytes. </li></ul><br>  Sin embargo, continuamos: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> mail_messages_btree <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages(substring(body_plain <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">2048</span></span>));</code> </pre><br>  Construiremos tambi칠n el 칤ndice GiST: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> mail_messages_gist <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(tsv);</code> </pre><br>  El tama침o de los 칤ndices al "vac칤o completo": <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_relation_size(<span class="hljs-string"><span class="hljs-string">'mail_messages_tsv_idx'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> gin, pg_size_pretty(pg_relation_size(<span class="hljs-string"><span class="hljs-string">'mail_messages_gist'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> gist, pg_size_pretty(pg_relation_size(<span class="hljs-string"><span class="hljs-string">'mail_messages_btree'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> btree;</code> </pre><pre> <code class="plaintext hljs"> gin | gist | btree --------+--------+-------- 179 MB | 125 MB | 546 MB (1 row)</code> </pre><br>  Debido a la compacidad de la representaci칩n, podemos intentar usar el 칤ndice GIN durante la migraci칩n desde Oracle como un reemplazo para los 칤ndices de mapa de bits (sin entrar en detalles, proporciono <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una referencia a la publicaci칩n de Lewis</a> para mentes curiosas).  Como regla general, los 칤ndices de mapa de bits se usan para campos que tienen pocos valores 칰nicos, lo cual es excelente tambi칠n para GIN.  Y, como se muestra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el primer art칤culo</a> , PostgreSQL puede construir un mapa de bits basado en cualquier 칤ndice, incluido GIN, sobre la marcha. <br><br><h3>  GiST o GIN? </h3><br>  Para muchos tipos de datos, las clases de operador est치n disponibles tanto para GiST como para GIN, lo que plantea una pregunta sobre qu칠 칤ndice utilizar.  Quiz치s, ya podamos sacar algunas conclusiones. <br><br>  Como regla, GIN supera a GiST en precisi칩n y velocidad de b칰squeda.  Si los datos no se actualizan con frecuencia y se necesita una b칰squeda r치pida, lo m치s probable es que GIN sea una opci칩n. <br><br>  Por otro lado, si los datos se actualizan intensamente, los costos generales de actualizar GIN pueden parecer demasiado grandes.  En este caso, tendremos que comparar ambas opciones y elegir la que tenga caracter칤sticas m치s equilibradas. <br><br><h2>  Matrices </h2><br>  Otro ejemplo de uso de GIN es la indexaci칩n de matrices.  En este caso, los elementos de la matriz entran en el 칤ndice, lo que permite acelerar una serie de operaciones sobre las matrices: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'array_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gin'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amopstrategy -----------------------+-------------- &amp;&amp;(anyarray,anyarray) | 1 intersection @&gt;(anyarray,anyarray) | 2 contains array &lt;@(anyarray,anyarray) | 3 contained in array =(anyarray,anyarray) | 4 equality (4 rows)</code> </pre><br>  Nuestra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">base de datos de demostraci칩n</a> tiene una vista de "rutas" con informaci칩n sobre vuelos.  Entre el resto, esta vista contiene la columna "days_of_week", una variedad de d칤as de la semana en que se realizan los vuelos.  Por ejemplo, un vuelo de Vnukovo a Gelendzhik sale los martes, jueves y domingos: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> departure_airport_name, arrival_airport_name, days_of_week <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> flight_no = <span class="hljs-string"><span class="hljs-string">'PG0049'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> departure_airport_name | arrival_airport_name | days_of_week ------------------------+----------------------+-------------- Vnukovo | Gelendzhik | {2,4,7} (1 row)</code> </pre><br>  Para construir el 칤ndice, "materialicemos" la vista en una tabla: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes; demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(days_of_week);</code> </pre><br><br>  Ahora podemos usar el 칤ndice para conocer todos los vuelos que salen los martes, jueves y domingos: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> days_of_week = <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>];</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------- Bitmap Heap Scan on routes_t Recheck Cond: (days_of_week = '{2,4,7}'::integer[]) -&gt; Bitmap Index Scan on routes_t_days_of_week_idx Index Cond: (days_of_week = '{2,4,7}'::integer[]) (4 rows)</code> </pre><br>  Parece que hay seis de ellos: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> flight_no, departure_airport_name, arrival_airport_name, days_of_week <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> days_of_week = <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>];</code> </pre><pre> <code class="plaintext hljs"> flight_no | departure_airport_name | arrival_airport_name | days_of_week -----------+------------------------+----------------------+-------------- PG0005 | Domodedovo | Pskov | {2,4,7} PG0049 | Vnukovo | Gelendzhik | {2,4,7} PG0113 | Naryan-Mar | Domodedovo | {2,4,7} PG0249 | Domodedovo | Gelendzhik | {2,4,7} PG0449 | Stavropol | Vnukovo | {2,4,7} PG0540 | Barnaul | Vnukovo | {2,4,7} (6 rows)</code> </pre><br>  쮺칩mo se realiza esta consulta?  Exactamente de la misma manera que la descrita anteriormente: <br><br><ol><li>  Desde la matriz {2,4,7}, que desempe침a el papel de la consulta de b칰squeda aqu칤, se extraen elementos (palabras clave de b칰squeda).  Evidentemente, estos son los valores de "2", "4" y "7". <br></li><li>  En el 치rbol de elementos, se encuentran las claves extra칤das, y para cada una de ellas se selecciona la lista de TID. <br></li><li>  De todos los TID encontrados, la funci칩n de coherencia selecciona aquellos que coinciden con el operador de la consulta.  Para <code>=</code> operador, solo los TID coinciden con los que ocurrieron en las tres listas (en otras palabras, la matriz inicial debe contener todos los elementos).  Pero esto no es suficiente: tambi칠n es necesario que la matriz no contenga ning칰n otro valor, y no podemos verificar esta condici칩n con el 칤ndice.  Por lo tanto, en este caso, el m칠todo de acceso le pide al motor de indexaci칩n que vuelva a verificar todos los TID devueltos con la tabla. <br></li></ol><br>  Curiosamente, hay estrategias (por ejemplo, "contenidas en una matriz") que no pueden verificar nada y tienen que volver a verificar todos los TID encontrados con la tabla. <br><br>  Pero, 쯤u칠 hacer si necesitamos saber los vuelos que salen de Mosc칰 los martes, jueves y domingos?  El 칤ndice no admitir치 la condici칩n adicional, que entrar치 en la columna "Filtro". <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> days_of_week = <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> departure_city = <span class="hljs-string"><span class="hljs-string">'Moscow'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------- Bitmap Heap Scan on routes_t Recheck Cond: (days_of_week = '{2,4,7}'::integer[]) Filter: (departure_city = 'Moscow'::text) -&gt; Bitmap Index Scan on routes_t_days_of_week_idx Index Cond: (days_of_week = '{2,4,7}'::integer[]) (5 rows)</code> </pre><br>  Aqu칤 est치 bien (el 칤ndice selecciona solo seis filas de todos modos), pero en los casos en que la condici칩n adicional aumenta la capacidad selectiva, se desea tener dicho soporte.  Sin embargo, no podemos simplemente crear el 칤ndice: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(days_of_week,departure_city);</code> </pre><pre> <code class="plaintext hljs">ERROR: data type text has no default operator class for access method "gin" HINT: You must specify an operator class for the index or define a default operator class for the data type.</code> </pre><br>  Pero la extensi칩n " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">btree_gin</a> " ayudar치, lo que agrega clases de operador GIN que simulan el trabajo de un 치rbol B normal. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> btree_gin; demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(days_of_week,departure_city); demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> days_of_week = <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> departure_city = <span class="hljs-string"><span class="hljs-string">'Moscow'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------- Bitmap Heap Scan on routes_t Recheck Cond: ((days_of_week = '{2,4,7}'::integer[]) AND (departure_city = 'Moscow'::text)) -&gt; Bitmap Index Scan on routes_t_days_of_week_departure_city_idx Index Cond: ((days_of_week = '{2,4,7}'::integer[]) AND (departure_city = 'Moscow'::text)) (4 rows)</code> </pre><br><h2>  Jsonb </h2><br>  Un ejemplo m치s de un tipo de datos compuesto que tiene soporte GIN incorporado es JSON.  Para trabajar con valores JSON, actualmente se definen varios operadores y funciones, algunos de los cuales se pueden acelerar utilizando 칤ndices: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> opc.opcname, amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> str <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-string"><span class="hljs-string">'jsonb_ops'</span></span>,<span class="hljs-string"><span class="hljs-string">'jsonb_path_ops'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gin'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> opcname | amopopr | str ----------------+------------------+----- jsonb_ops | ?(jsonb,text) | 9 top-level key exists jsonb_ops | ?|(jsonb,text[]) | 10 some top-level key exists jsonb_ops | ?&amp;(jsonb,text[]) | 11 all top-level keys exist jsonb_ops | @&gt;(jsonb,jsonb) | 7 JSON value is at top level jsonb_path_ops | @&gt;(jsonb,jsonb) | 7 (5 rows)</code> </pre><br>  Como podemos ver, hay dos clases de operadores disponibles: "jsonb_ops" y "jsonb_path_ops". <br><br>  La primera clase de operador "jsonb_ops" se usa por defecto.  Todas las claves, valores y elementos de matriz llegan al 칤ndice como elementos del documento JSON inicial.  Se agrega un atributo a cada uno de estos elementos, que indica si este elemento es una clave (esto es necesario para estrategias "existentes", que distinguen entre claves y valores). <br><br>  Por ejemplo, representemos algunas filas de "rutas" como JSON de la siguiente manera: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> routes_jsonb <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_jsonb(t) route <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> departure_airport_name, arrival_airport_name, days_of_week <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> flight_no <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> ) t; demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ctid, jsonb_pretty(route) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_jsonb;</code> </pre><pre> <code class="plaintext hljs"> ctid | jsonb_pretty -------+------------------------------------------------- (0,1) | { + | "days_of_week": [ + | 1 + | ], + | "arrival_airport_name": "Surgut", + | "departure_airport_name": "Ust-Ilimsk" + | } (0,2) | { + | "days_of_week": [ + | 2 + | ], + | "arrival_airport_name": "Ust-Ilimsk", + | "departure_airport_name": "Surgut" + | } (0,3) | { + | "days_of_week": [ + | 1, + | 4 + | ], + | "arrival_airport_name": "Sochi", + | "departure_airport_name": "Ivanovo-Yuzhnyi"+ | } (0,4) | { + | "days_of_week": [ + | 2, + | 5 + | ], + | "arrival_airport_name": "Ivanovo-Yuzhnyi", + | "departure_airport_name": "Sochi" + | } (4 rows)</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> routes_jsonb <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(route);</code> </pre><br><br>  El 칤ndice puede verse de la siguiente manera: <br><br><img src="https://habrastorage.org/webt/oo/yi/x3/ooyix34gx7mrpiwdcol3a3ewnwu.png"><br><br>  Ahora, una consulta como esta, por ejemplo, se puede realizar utilizando el 칤ndice: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> jsonb_pretty(route) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_jsonb <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> route @&gt; <span class="hljs-string"><span class="hljs-string">'{"days_of_week": [5]}'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------- Bitmap Heap Scan on routes_jsonb Recheck Cond: (route @&gt; '{"days_of_week": [5]}'::jsonb) -&gt; Bitmap Index Scan on routes_jsonb_route_idx Index Cond: (route @&gt; '{"days_of_week": [5]}'::jsonb) (4 rows)</code> </pre><br>  Comenzando con la ra칤z del documento JSON, el operador <code>@&gt;</code> verifica si se produce la ruta especificada ( <code>"days_of_week": [5]</code> ).  Aqu칤 la consulta devolver치 una fila: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> jsonb_pretty(route) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_jsonb <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> route @&gt; <span class="hljs-string"><span class="hljs-string">'{"days_of_week": [5]}'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> jsonb_pretty ------------------------------------------------ { + "days_of_week": [ + 2, + 5 + ], + "arrival_airport_name": "Ivanovo-Yuzhnyi",+ "departure_airport_name": "Sochi" + } (1 row)</code> </pre><br>  La consulta se realiza de la siguiente manera: <br><br><ol><li>  En la consulta de b칰squeda ( <code>"days_of_week": [5]</code> ) se extraen elementos (claves de b칰squeda): "days_of_week" y "5". <br></li><li>  En el 치rbol de elementos se encuentran las claves extra칤das, y para cada una de ellas se selecciona la lista de TID: para "5" - (0.4), y para "days_of_week" - (0,1), (0,2 ), (0.3), (0.4). <br></li><li>  De todos los TID encontrados, la funci칩n de coherencia selecciona aquellos que coinciden con el operador de la consulta.  Para el operador <code>@&gt;</code> , los documentos que no contienen todos los elementos de la consulta de b칰squeda no ser치n seguros, por lo que solo queda (0,4).  Pero a칰n necesitamos volver a verificar el TID que queda con la tabla, ya que no est치 claro en el 칤ndice en qu칠 orden se producen los elementos encontrados en el documento JSON. <br></li></ol><br>  Para descubrir m치s detalles de otros operadores, puede leer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la documentaci칩n</a> . <br><br>  Adem치s de las operaciones convencionales para tratar con JSON, la extensi칩n "jsquery" ha estado disponible durante mucho tiempo, que define un lenguaje de consulta con capacidades m치s ricas (y ciertamente, con soporte de 칤ndices GIN).  Adem치s, en 2016, se emiti칩 un nuevo est치ndar SQL, que define su propio conjunto de operaciones y lenguaje de consulta "Ruta SQL / JSON".  Ya se ha logrado una implementaci칩n de este est치ndar, y creemos que aparecer치 en PostgreSQL 11. <br><br><blockquote>  El parche de ruta SQL / JSON finalmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se</a> confirm칩 en PostgreSQL 12, mientras que otras piezas a칰n est치n en camino.  Con suerte, veremos la caracter칤stica completamente implementada en PostgreSQL 13. <br></blockquote><br><h2>  Internos </h2><br>  Podemos mirar dentro del 칤ndice GIN usando la extensi칩n " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pageinspect</a> ". <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> pageinspect;</code> </pre><br>  La informaci칩n de la p치gina meta muestra estad칤sticas generales: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gin_metapage_info(get_raw_page(<span class="hljs-string"><span class="hljs-string">'mail_messages_tsv_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----+----------- pending_head | 4294967295 pending_tail | 4294967295 tail_free_size | 0 n_pending_pages | 0 n_pending_tuples | 0 n_total_pages | 22968 n_entry_pages | 13751 n_data_pages | 9216 n_entries | 1423598 version | 2</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La estructura de la p치gina</a> proporciona un 치rea especial donde los m칠todos de acceso almacenan su informaci칩n;  esta 치rea es "opaca" para programas ordinarios como el vac칤o.  La funci칩n "Gin_page_opaque_info" muestra estos datos para GIN.  Por ejemplo, podemos conocer el conjunto de p치ginas de 칤ndice: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> flags, count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">22967</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> g(id), <span class="hljs-comment"><span class="hljs-comment">-- n_total_pages gin_page_opaque_info(get_raw_page('mail_messages_tsv_idx',g.id)) group by flags;</span></span></code> </pre><pre> <code class="plaintext hljs"> flags | count ------------------------+------- {meta} | 1 meta page {} | 133 internal page of element B-tree {leaf} | 13618 leaf page of element B-tree {data} | 1497 internal page of TID B-tree {data,leaf,compressed} | 7719 leaf page of TID B-tree (5 rows)</code> </pre><br>  La funci칩n "Gin_leafpage_items" proporciona informaci칩n sobre los TID almacenados en las p치ginas {datos, hoja, comprimido}: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gin_leafpage_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'mail_messages_tsv_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">2672</span></span>));</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]--------------------------------------------------------------------- first_tid | (239,44) nbytes | 248 tids | {"(239,44)","(239,47)","(239,48)","(239,50)","(239,52)","(240,3)",... -[ RECORD 2 ]--------------------------------------------------------------------- first_tid | (247,40) nbytes | 248 tids | {"(247,40)","(247,41)","(247,44)","(247,45)","(247,46)","(248,2)",... ...</code> </pre><br>  Tenga en cuenta que las p치ginas del 치rbol de TID en realidad contienen peque침as listas comprimidas de punteros a filas de tabla en lugar de punteros individuales. <br><br><h2>  Propiedades </h2><br>  Veamos las propiedades del m칠todo de acceso GIN ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ya se han proporcionado consultas</a> ). <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- gin | can_order | f gin | can_unique | f gin | can_multi_col | t gin | can_exclude | f</code> </pre><br>  Curiosamente, GIN admite la creaci칩n de 칤ndices de varias columnas.  Sin embargo, a diferencia de un 치rbol B normal, en lugar de claves compuestas, un 칤ndice de varias columnas seguir치 almacenando elementos individuales, y el n칰mero de columna se indicar치 para cada elemento. <br><br>  Las siguientes propiedades de capa de 칤ndice est치n disponibles: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | f bitmap_scan | t backward_scan | f</code> </pre><br>  Tenga en cuenta que no se admite la devoluci칩n de resultados TID por TID (exploraci칩n de 칤ndice);  solo es posible el escaneo de mapa de bits. <br><br>  La exploraci칩n hacia atr치s tampoco es compatible: esta funci칩n es esencial solo para la exploraci칩n de 칤ndice, pero no para la exploraci칩n de mapa de bits. <br><br>  Y las siguientes son propiedades de capa de columna: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | f returnable | f search_array | f search_nulls | f</code> </pre><br>  Aqu칤 no hay nada disponible: sin clasificaci칩n (lo que est치 claro), sin uso del 칤ndice como cobertura (ya que el documento en s칤 no est치 almacenado en el 칤ndice), sin manipulaci칩n de NULL (ya que no tiene sentido para elementos de tipo compuesto) . <br><br><h2>  Otros tipos de datos </h2><br>  Hay algunas extensiones m치s disponibles que agregan soporte de GIN para algunos tipos de datos. <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pg_trgm</a> " nos permite determinar la "similitud" de las palabras al comparar cu치ntas secuencias iguales de tres letras (trigramas) est치n disponibles.  Se a침aden dos clases de operadores, "gist_trgm_ops" y "gin_trgm_ops", que admiten varios operadores, incluida la comparaci칩n mediante expresiones LIKE y regulares.  Podemos usar esta extensi칩n junto con la b칰squeda de texto completo para sugerir opciones de palabras para corregir errores tipogr치ficos. <br></li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hstore</a> " implementa el almacenamiento "clave-valor".  Para este tipo de datos, hay disponibles clases de operador para varios m칠todos de acceso, incluido GIN.  Sin embargo, con la introducci칩n del tipo de datos "jsonb", no hay razones especiales para usar "hstore". <br></li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">intarray</a> " ampl칤a la funcionalidad de las matrices de enteros.  El soporte de 칤ndice incluye GiST, as칤 como GIN (clase de operador "gin__int_ops"). <br></li></ul><br>  Y estas dos extensiones ya se han mencionado anteriormente: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">btree_gin</a> " agrega soporte GIN para los tipos de datos regulares para que puedan usarse en un 칤ndice de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">varias columnas</a> junto con los tipos compuestos. <br></li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">jsquery</a> " define un idioma para las consultas JSON y una clase de operador para el soporte de 칤ndice de este idioma.  Esta extensi칩n no est치 incluida en una entrega est치ndar de PostgreSQL. <br></li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sigue leyendo</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/448746/">https://habr.com/ru/post/448746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448732/index.html">Hernia intervertebral? Trabajar en ella</a></li>
<li><a href="../448734/index.html">Drones y robots que ayudan a salvar la Catedral de Notre Dame de Par칤s</a></li>
<li><a href="../448738/index.html">쯈ui칠n caza startups?</a></li>
<li><a href="../448740/index.html">Escuchamos m칰sica SID (Commodore 64) a trav칠s de OPL3 en PC modernas</a></li>
<li><a href="../448744/index.html">쮺칩mo transferir una variable de fragmento a actividad en Android?</a></li>
<li><a href="../448748/index.html">Reflexiones sobre belleza y c칩digo</a></li>
<li><a href="../448750/index.html">Sobre una vulnerabilidad que no es</a></li>
<li><a href="../448754/index.html">Qui칠n es qui칠n en c칩digo abierto: biograf칤as geek</a></li>
<li><a href="../448756/index.html">Antecedentes: por qu칠 Apple y Qualcomm se pelearon y luego se reconciliaron</a></li>
<li><a href="../448758/index.html">Reloj inteligente con BASIC en 6502 f칤sico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>