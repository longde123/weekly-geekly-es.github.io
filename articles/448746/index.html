<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎅🏾 🏠 ☮️ Índices en PostgreSQL - 7 (GIN) 📟 👋🏻 🔵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ya nos hemos familiarizado con el motor de indexación PostgreSQL y la interfaz de los métodos de acceso y hemos discutido los índices hash , los árbol...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Índices en PostgreSQL - 7 (GIN)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/448746/">  Ya nos hemos familiarizado con el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">motor de indexación</a> PostgreSQL y la interfaz de los métodos de acceso y hemos discutido los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">índices hash</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">los árboles B</a> , así como los índices <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GiST</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SP-GiST</a> .  Y este artículo presentará el índice GIN. <br><br><h1>  Ginebra </h1><br>  <em>"Gin? ... Gin es, al parecer, un licor tan americano? .."</em> <em><br></em>  <em>"No soy un trago, ¡oh, chico curioso!"</em>  <em>Una vez más, el viejo se encendió, otra vez se dio cuenta de sí mismo y otra vez se tomó de la mano.</em>  <em>"No soy un trago, sino un espíritu poderoso e impávido, y no hay tal magia en el mundo que no pueda hacer".</em> <br>  - Lazar Lagin, "Viejo Khottabych". <br><br>  <em>Gin significa índice invertido generalizado y debe considerarse como un genio, no una bebida.</em> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LÉAME</a> <br><a name="habracut"></a><br><h2>  Concepto general </h2><br>  GIN es el índice invertido generalizado abreviado.  Este es un llamado <em>índice invertido</em> .  Manipula los tipos de datos cuyos valores no son atómicos, sino que consisten en elementos.  Llamaremos a estos tipos compuestos.  Y estos no son los valores que se indexan, sino elementos individuales;  cada elemento hace referencia a los valores en los que ocurre. <br><br>  Una buena analogía de este método es el índice al final de un libro, que para cada término, proporciona una lista de páginas donde aparece este término.  El método de acceso debe garantizar una búsqueda rápida de elementos indexados, al igual que el índice de un libro.  Por lo tanto, estos elementos se almacenan como un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">árbol B</a> familiar (se usa una implementación diferente y más simple, pero no importa en este caso).  Un conjunto ordenado de referencias a las filas de la tabla que contienen valores compuestos con el elemento está vinculado a cada elemento.  El orden no es esencial para la recuperación de datos (el orden de clasificación de los TID no significa mucho), pero es importante para la estructura interna del índice. <br><br>  Los elementos nunca se eliminan del índice GIN.  Se supone que los valores que contienen elementos pueden desaparecer, surgir o variar, pero el conjunto de elementos de los que están compuestos es más o menos estable.  Esta solución simplifica significativamente los algoritmos para el trabajo concurrente de varios procesos con el índice. <br><br>  Si la lista de TID es bastante pequeña, puede caber en la misma página que el elemento (y se llama "la lista de publicación").  Pero si la lista es grande, se necesita una estructura de datos más eficiente, y ya estamos conscientes de ello: es B-tree nuevamente.  Dicho árbol se encuentra en páginas de datos separadas (y se llama "el árbol de publicación"). <br><br>  Entonces, el índice GIN consiste en el árbol B de elementos, y los árboles B o listas planas de TID están vinculados a las filas de hojas de ese árbol B. <br><br>  Al igual que los índices GiST y SP-GiST, discutidos anteriormente, GIN proporciona un desarrollador de aplicaciones con la interfaz para admitir varias operaciones sobre tipos de datos compuestos. <br><br><h2>  Búsqueda de texto completo </h2><br>  El área principal de aplicación para el método GIN es acelerar la búsqueda de texto completo, lo que, por lo tanto, es razonable usar como ejemplo en una discusión más detallada de este índice. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El artículo relacionado con GiST</a> ya ha proporcionado una pequeña introducción a la búsqueda de texto completo, así que vayamos directamente al grano sin repeticiones.  Está claro que los valores compuestos en este caso son <em>documentos</em> , y los elementos de estos documentos son <em>lexemas</em> . <br><br>  Consideremos el ejemplo del artículo relacionado con GiST: <br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> ts(doc <span class="hljs-type"><span class="hljs-type">text</span></span>, doc_tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ts(doc) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'Can a sheet slitter slit sheets?'</span></span>), (<span class="hljs-string"><span class="hljs-string">'How many sheets could a sheet slitter slit?'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I slit a sheet, a sheet I slit.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Upon a slitted sheet I sit.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Whoever slit the sheets is a good sheet slitter.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I am a sheet slitter.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I slit sheets.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I am the sleekest sheet slitter that ever slit sheets.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'She slits the sheet she sits on.'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> doc_tsv = to_tsvector(doc); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(doc_tsv);</code> </pre> <br>  Una posible estructura de este índice se muestra en la figura: <br><br><img src="https://habrastorage.org/webt/lc/nh/m-/lcnhm-vqquxgvzpklv8kemu6z-a.png"><br><br>  A diferencia de todas las figuras anteriores, las referencias a las filas de la tabla (TID) se denotan con valores numéricos sobre un fondo oscuro (el número de página y la posición en la página) en lugar de con flechas. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ctid, left(doc,<span class="hljs-number"><span class="hljs-number">20</span></span>), doc_tsv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts;</code> </pre><pre> <code class="plaintext hljs"> ctid | left | doc_tsv -------+----------------------+--------------------------------------------------------- (0,1) | Can a sheet slitter | 'sheet':3,6 'slit':5 'slitter':4 (0,2) | How many sheets coul | 'could':4 'mani':2 'sheet':3,6 'slit':8 'slitter':7 (0,3) | I slit a sheet, a sh | 'sheet':4,6 'slit':2,8 (1,1) | Upon a slitted sheet | 'sheet':4 'sit':6 'slit':3 'upon':1 (1,2) | Whoever slit the she | 'good':7 'sheet':4,8 'slit':2 'slitter':9 'whoever':1 (1,3) | I am a sheet slitter | 'sheet':4 'slitter':5 (2,1) | I slit sheets. | 'sheet':3 'slit':2 (2,2) | I am the sleekest sh | 'ever':8 'sheet':5,10 'sleekest':4 'slit':9 'slitter':6 (2,3) | She slits the sheet | 'sheet':4 'sit':6 'slit':2 (9 rows)</code> </pre><br>  En este ejemplo especulativo, la lista de TID se ajusta a páginas regulares para todos los lexemas, excepto "hoja", "rendija" y "cortadora".  Estos lexemas aparecieron en muchos documentos, y las listas de TID para ellos se han colocado en árboles B individuales. <br><br>  Por cierto, ¿cómo podemos determinar cuántos documentos contienen un lexema?  Para una mesa pequeña, una técnica "directa", que se muestra a continuación, funcionará, pero aprenderemos más qué hacer con las más grandes. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (unnest(doc_tsv)).lexeme, count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>;</code> </pre><pre> <code class="plaintext hljs"> lexeme | count ----------+------- sheet | 9 slit | 8 slitter | 5 sit | 2 upon | 1 mani | 1 whoever | 1 sleekest | 1 good | 1 could | 1 ever | 1 (11 rows)</code> </pre><br>  Tenga en cuenta también que, a diferencia de un árbol B normal, las páginas del índice GIN están conectadas por una lista unidireccional en lugar de una bidireccional.  Esto es suficiente ya que el recorrido de un árbol se realiza de una sola manera. <br><br><h3>  Ejemplo de consulta </h3><br>  ¿Cómo se realizará la siguiente consulta para nuestro ejemplo? <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> doc_tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'many &amp; slitter'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------- Bitmap Heap Scan on ts Recheck Cond: (doc_tsv @@ to_tsquery('many &amp; slitter'::text)) -&gt; Bitmap Index Scan on ts_doc_tsv_idx Index Cond: (doc_tsv @@ to_tsquery('many &amp; slitter'::text)) (4 rows)</code> </pre><br>  Los lexemas individuales (claves de búsqueda) se extraen primero de la consulta: "mani" y "slitter".  Esto se realiza mediante una función API especializada que tiene en cuenta el tipo de datos y la estrategia determinados por la clase de operador: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'tsvector_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gin'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amopstrategy -----------------------+-------------- @@(tsvector,tsquery) | 1 matching search query @@@(tsvector,tsquery) | 2 synonym for @@ (for backward compatibility) (2 rows)</code> </pre><br>  En el árbol B de lexemas, a continuación encontramos ambas claves y revisamos listas listas de TID.  Obtenemos: <br><br>  para "mani" - (0,2). <br>  para "cortadora" - (0,1), (0,2), (1,2), (1,3), (2,2). <br><br><img src="https://habrastorage.org/webt/mg/qc/do/mgqcdou-xlhsztvkxii5qluc5rq.png"><br><br>  Finalmente, para cada TID encontrado, se llama a una función de coherencia API, que debe determinar cuál de las filas encontradas coincide con la consulta de búsqueda.  Dado que los lexemas en nuestra consulta están unidos por Boolean "y", la única fila devuelta es (0,2): <br><br><pre> <code class="plaintext hljs"> | | | consistency | | | function TID | mani | slitter | slit &amp; slitter -------+------+---------+---------------- (0,1) | f | T | f (0,2) | T | T | T (1,2) | f | T | f (1,3) | f | T | f (2,2) | f | T | f</code> </pre><br>  Y el resultado es: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> doc_tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'many &amp; slitter'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> doc --------------------------------------------- How many sheets could a sheet slitter slit? (1 row)</code> </pre><br>  Si comparamos este enfoque con el ya discutido para GiST, la ventaja de GIN para la búsqueda de texto completo parece evidente.  Pero hay más en esto de lo que parece. <br><br><h3>  El problema de una actualización lenta </h3><br>  La cuestión es que la inserción o actualización de datos en el índice GIN es bastante lenta.  Cada documento generalmente contiene muchos lexemas para indexar.  Por lo tanto, cuando solo se agrega o actualiza un documento, tenemos que actualizar masivamente el árbol de índice. <br><br>  Por otro lado, si varios documentos se actualizan simultáneamente, algunos de sus lexemas pueden ser iguales, y la cantidad total de trabajo será menor que cuando se actualizan los documentos uno por uno. <br><br>  El índice GIN tiene un parámetro de almacenamiento "fastupdate", que podemos especificar durante la creación del índice y actualizarlo más tarde: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(doc_tsv) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (fastupdate = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>);</code> </pre><br>  Con este parámetro activado, las actualizaciones se acumularán en una lista desordenada separada (en páginas conectadas individuales).  Cuando esta lista se hace lo suficientemente grande o durante la aspiración, todas las actualizaciones acumuladas se realizan instantáneamente en el índice.  La lista para considerar "suficientemente grande" está determinada por el parámetro de configuración "gin_pending_list_limit" o por el parámetro de almacenamiento del mismo nombre del índice. <br><br>  Pero este enfoque tiene inconvenientes: primero, la búsqueda se ralentiza (ya que la lista desordenada debe revisarse además del árbol) y, en segundo lugar, una próxima actualización puede llevar mucho tiempo inesperadamente si la lista desordenada se ha desbordado. <br><br><h3>  Búsqueda de una coincidencia parcial </h3><br>  Podemos usar la coincidencia parcial en la búsqueda de texto completo.  Por ejemplo, considere la siguiente consulta: <br><br><pre> <code class="pgsql hljs">gin=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> doc_tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'slit:*'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> doc -------------------------------------------------------- Can a sheet slitter slit sheets? How many sheets could a sheet slitter slit? I slit a sheet, a sheet I slit. Upon a slitted sheet I sit. Whoever slit the sheets is a good sheet slitter. I am a sheet slitter. I slit sheets. I am the sleekest sheet slitter that ever slit sheets. She slits the sheet she sits on. (9 rows)</code> </pre><br>  Esta consulta encontrará documentos que contienen lexemas que comienzan con "hendidura".  En este ejemplo, tales lexemas son "slit" y "slitter". <br><br>  Una consulta ciertamente funcionará de todos modos, incluso sin índices, pero GIN también permite acelerar la siguiente búsqueda: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> doc_tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'slit:*'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------- Bitmap Heap Scan on ts Recheck Cond: (doc_tsv @@ to_tsquery('slit:*'::text)) -&gt; Bitmap Index Scan on ts_doc_tsv_idx Index Cond: (doc_tsv @@ to_tsquery('slit:*'::text)) (4 rows)</code> </pre><br>  Aquí, todos los lexemas que tienen el prefijo especificado en la consulta de búsqueda se buscan en el árbol y se unen mediante booleano "o". <br><br><h3>  Lexemas frecuentes e infrecuentes </h3><br>  Para ver cómo funciona la indexación en los datos en vivo, tomemos el archivo del correo electrónico "pgsql-hackers", que ya hemos utilizado al analizar GiST.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Esta versión del archivo</a> contiene 356125 mensajes con la fecha de envío, asunto, autor y texto. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> tsv = to_tsvector(body_plain);</code> </pre><pre> <code class="plaintext hljs">NOTICE: word is too long to be indexed DETAIL: Words longer than 2047 characters are ignored. ... UPDATE 356125</code> </pre><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(tsv);</code> </pre><br>  Consideremos un lexema que ocurre en muchos documentos.  La consulta que utiliza "unnest" no funcionará en un tamaño de datos tan grande, y la técnica correcta es utilizar la función "ts_stat", que proporciona la información sobre lexemas, la cantidad de documentos donde ocurrieron y la cantidad total de ocurrencias. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> word, ndoc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts_stat(<span class="hljs-string"><span class="hljs-string">'select tsv from mail_messages'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ndoc <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><pre> <code class="plaintext hljs"> word | ndoc -------+-------- re | 322141 wrote | 231174 use | 176917 (3 rows)</code> </pre><br>  Vamos a elegir "escribió". <br><br>  Y tomaremos algunas palabras que no son frecuentes para el correo electrónico de los desarrolladores, digamos "tatuaje": <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> word, ndoc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts_stat(<span class="hljs-string"><span class="hljs-string">'select tsv from mail_messages'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> word = <span class="hljs-string"><span class="hljs-string">'tattoo'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> word | ndoc --------+------ tattoo | 2 (1 row)</code> </pre><br>  ¿Hay algún documento donde ocurran ambos lexemas?  Parece que hay: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote &amp; tattoo'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 1 (1 row)</code> </pre><br>  Surge una pregunta sobre cómo realizar esta consulta.  Si obtenemos listas de TID para ambos lexemas, como se describió anteriormente, la búsqueda evidentemente será ineficiente: tendremos que pasar por más de 200 mil valores, de los cuales solo quedará uno.  Afortunadamente, utilizando las estadísticas del planificador, el algoritmo comprende que el lexema "escrito" ocurre con frecuencia, mientras que el "tatuaje" ocurre con poca frecuencia.  Por lo tanto, se realiza la búsqueda del lexema infrecuente, y los dos documentos recuperados se comprueban para detectar la aparición del lexema "escrito".  Y esto queda claro en la consulta, que se realiza rápidamente: <br><br><pre> <code class="pgsql hljs">fts=# \<span class="hljs-keyword"><span class="hljs-keyword">timing</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote &amp; tattoo'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 1 (1 row) Time: 0,959 ms</code> </pre><br>  La búsqueda de "escrito" solo lleva mucho más tiempo: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count -------- 231174 (1 row) Time: 2875,543 ms (00:02,876)</code> </pre><br>  Esta optimización ciertamente funciona no solo para dos lexemas, sino también en casos más complejos. <br><br><h3>  Limitar el resultado de la consulta </h3><br>  Una característica del método de acceso GIN es que el resultado siempre se devuelve como un mapa de bits: este método no puede devolver el resultado TID por TID.  Es por esto que todos los planes de consulta en este artículo usan escaneo de mapa de bits. <br><br>  Por lo tanto, la limitación del resultado del análisis de índice utilizando la cláusula LIMIT no es del todo eficiente.  Preste atención al costo previsto de la operación (campo "costo" del nodo "Límite"): <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------------------------------------- Limit (cost=1283.61..1285.13 rows=1) -&gt; Bitmap Heap Scan on mail_messages (cost=1283.61..209975.49 rows=137207) Recheck Cond: (tsv @@ to_tsquery('wrote'::text)) -&gt; Bitmap Index Scan on mail_messages_tsv_idx (cost=0.00..1249.30 rows=137207) Index Cond: (tsv @@ to_tsquery('wrote'::text)) (5 rows)</code> </pre><br>  El costo se estima en 1285.13, que es un poco mayor que el costo de construir todo el mapa de bits 1249.30 (campo "costo" del nodo Escaneo de índice de mapa de bits). <br><br>  Por lo tanto, el índice tiene una capacidad especial para limitar el número de resultados.  El valor umbral se especifica en el parámetro de configuración "gin_fuzzy_search_limit" y es igual a cero de forma predeterminada (no tiene lugar ninguna limitación).  Pero podemos establecer el valor umbral: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> gin_fuzzy_search_limit = <span class="hljs-number"><span class="hljs-number">1000</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 5746 (1 row)</code> </pre><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> gin_fuzzy_search_limit = <span class="hljs-number"><span class="hljs-number">10000</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 14726 (1 row)</code> </pre><br>  Como podemos ver, el número de filas devueltas por la consulta difiere para diferentes valores de parámetros (si se utiliza el acceso al índice).  La limitación no es estricta: se pueden devolver más filas de las especificadas, lo que justifica la parte "difusa" del nombre del parámetro. <br><br><h3>  Representación compacta </h3><br>  Entre el resto, los índices GIN son buenos gracias a su compacidad.  Primero, si se produce el mismo lexema en varios documentos (y este suele ser el caso), se almacena en el índice solo una vez.  En segundo lugar, los TID se almacenan en el índice de forma ordenada, y esto nos permite usar una compresión simple: cada TID siguiente de la lista se almacena realmente como su diferencia del anterior;  Esto suele ser un número pequeño, que requiere muchos menos bits que un TID completo de seis bytes. <br><br>  Para tener una idea del tamaño, construyamos un árbol B a partir del texto de los mensajes.  Pero una comparación justa ciertamente no va a suceder: <br><br><ul><li>  GIN está construido en un tipo de datos diferente ("tsvector" en lugar de "texto"), que es más pequeño, </li><li>  Al mismo tiempo, el tamaño de los mensajes para el árbol B debe acortarse a aproximadamente dos kilobytes. </li></ul><br>  Sin embargo, continuamos: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> mail_messages_btree <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages(substring(body_plain <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">2048</span></span>));</code> </pre><br>  Construiremos también el índice GiST: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> mail_messages_gist <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(tsv);</code> </pre><br>  El tamaño de los índices al "vacío completo": <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_relation_size(<span class="hljs-string"><span class="hljs-string">'mail_messages_tsv_idx'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> gin, pg_size_pretty(pg_relation_size(<span class="hljs-string"><span class="hljs-string">'mail_messages_gist'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> gist, pg_size_pretty(pg_relation_size(<span class="hljs-string"><span class="hljs-string">'mail_messages_btree'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> btree;</code> </pre><pre> <code class="plaintext hljs"> gin | gist | btree --------+--------+-------- 179 MB | 125 MB | 546 MB (1 row)</code> </pre><br>  Debido a la compacidad de la representación, podemos intentar usar el índice GIN durante la migración desde Oracle como un reemplazo para los índices de mapa de bits (sin entrar en detalles, proporciono <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una referencia a la publicación de Lewis</a> para mentes curiosas).  Como regla general, los índices de mapa de bits se usan para campos que tienen pocos valores únicos, lo cual es excelente también para GIN.  Y, como se muestra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el primer artículo</a> , PostgreSQL puede construir un mapa de bits basado en cualquier índice, incluido GIN, sobre la marcha. <br><br><h3>  GiST o GIN? </h3><br>  Para muchos tipos de datos, las clases de operador están disponibles tanto para GiST como para GIN, lo que plantea una pregunta sobre qué índice utilizar.  Quizás, ya podamos sacar algunas conclusiones. <br><br>  Como regla, GIN supera a GiST en precisión y velocidad de búsqueda.  Si los datos no se actualizan con frecuencia y se necesita una búsqueda rápida, lo más probable es que GIN sea una opción. <br><br>  Por otro lado, si los datos se actualizan intensamente, los costos generales de actualizar GIN pueden parecer demasiado grandes.  En este caso, tendremos que comparar ambas opciones y elegir la que tenga características más equilibradas. <br><br><h2>  Matrices </h2><br>  Otro ejemplo de uso de GIN es la indexación de matrices.  En este caso, los elementos de la matriz entran en el índice, lo que permite acelerar una serie de operaciones sobre las matrices: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'array_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gin'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amopstrategy -----------------------+-------------- &amp;&amp;(anyarray,anyarray) | 1 intersection @&gt;(anyarray,anyarray) | 2 contains array &lt;@(anyarray,anyarray) | 3 contained in array =(anyarray,anyarray) | 4 equality (4 rows)</code> </pre><br>  Nuestra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">base de datos de demostración</a> tiene una vista de "rutas" con información sobre vuelos.  Entre el resto, esta vista contiene la columna "days_of_week", una variedad de días de la semana en que se realizan los vuelos.  Por ejemplo, un vuelo de Vnukovo a Gelendzhik sale los martes, jueves y domingos: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> departure_airport_name, arrival_airport_name, days_of_week <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> flight_no = <span class="hljs-string"><span class="hljs-string">'PG0049'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> departure_airport_name | arrival_airport_name | days_of_week ------------------------+----------------------+-------------- Vnukovo | Gelendzhik | {2,4,7} (1 row)</code> </pre><br>  Para construir el índice, "materialicemos" la vista en una tabla: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes; demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(days_of_week);</code> </pre><br><br>  Ahora podemos usar el índice para conocer todos los vuelos que salen los martes, jueves y domingos: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> days_of_week = <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>];</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------- Bitmap Heap Scan on routes_t Recheck Cond: (days_of_week = '{2,4,7}'::integer[]) -&gt; Bitmap Index Scan on routes_t_days_of_week_idx Index Cond: (days_of_week = '{2,4,7}'::integer[]) (4 rows)</code> </pre><br>  Parece que hay seis de ellos: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> flight_no, departure_airport_name, arrival_airport_name, days_of_week <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> days_of_week = <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>];</code> </pre><pre> <code class="plaintext hljs"> flight_no | departure_airport_name | arrival_airport_name | days_of_week -----------+------------------------+----------------------+-------------- PG0005 | Domodedovo | Pskov | {2,4,7} PG0049 | Vnukovo | Gelendzhik | {2,4,7} PG0113 | Naryan-Mar | Domodedovo | {2,4,7} PG0249 | Domodedovo | Gelendzhik | {2,4,7} PG0449 | Stavropol | Vnukovo | {2,4,7} PG0540 | Barnaul | Vnukovo | {2,4,7} (6 rows)</code> </pre><br>  ¿Cómo se realiza esta consulta?  Exactamente de la misma manera que la descrita anteriormente: <br><br><ol><li>  Desde la matriz {2,4,7}, que desempeña el papel de la consulta de búsqueda aquí, se extraen elementos (palabras clave de búsqueda).  Evidentemente, estos son los valores de "2", "4" y "7". <br></li><li>  En el árbol de elementos, se encuentran las claves extraídas, y para cada una de ellas se selecciona la lista de TID. <br></li><li>  De todos los TID encontrados, la función de coherencia selecciona aquellos que coinciden con el operador de la consulta.  Para <code>=</code> operador, solo los TID coinciden con los que ocurrieron en las tres listas (en otras palabras, la matriz inicial debe contener todos los elementos).  Pero esto no es suficiente: también es necesario que la matriz no contenga ningún otro valor, y no podemos verificar esta condición con el índice.  Por lo tanto, en este caso, el método de acceso le pide al motor de indexación que vuelva a verificar todos los TID devueltos con la tabla. <br></li></ol><br>  Curiosamente, hay estrategias (por ejemplo, "contenidas en una matriz") que no pueden verificar nada y tienen que volver a verificar todos los TID encontrados con la tabla. <br><br>  Pero, ¿qué hacer si necesitamos saber los vuelos que salen de Moscú los martes, jueves y domingos?  El índice no admitirá la condición adicional, que entrará en la columna "Filtro". <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> days_of_week = <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> departure_city = <span class="hljs-string"><span class="hljs-string">'Moscow'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------- Bitmap Heap Scan on routes_t Recheck Cond: (days_of_week = '{2,4,7}'::integer[]) Filter: (departure_city = 'Moscow'::text) -&gt; Bitmap Index Scan on routes_t_days_of_week_idx Index Cond: (days_of_week = '{2,4,7}'::integer[]) (5 rows)</code> </pre><br>  Aquí está bien (el índice selecciona solo seis filas de todos modos), pero en los casos en que la condición adicional aumenta la capacidad selectiva, se desea tener dicho soporte.  Sin embargo, no podemos simplemente crear el índice: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(days_of_week,departure_city);</code> </pre><pre> <code class="plaintext hljs">ERROR: data type text has no default operator class for access method "gin" HINT: You must specify an operator class for the index or define a default operator class for the data type.</code> </pre><br>  Pero la extensión " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">btree_gin</a> " ayudará, lo que agrega clases de operador GIN que simulan el trabajo de un árbol B normal. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> btree_gin; demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(days_of_week,departure_city); demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> days_of_week = <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> departure_city = <span class="hljs-string"><span class="hljs-string">'Moscow'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------- Bitmap Heap Scan on routes_t Recheck Cond: ((days_of_week = '{2,4,7}'::integer[]) AND (departure_city = 'Moscow'::text)) -&gt; Bitmap Index Scan on routes_t_days_of_week_departure_city_idx Index Cond: ((days_of_week = '{2,4,7}'::integer[]) AND (departure_city = 'Moscow'::text)) (4 rows)</code> </pre><br><h2>  Jsonb </h2><br>  Un ejemplo más de un tipo de datos compuesto que tiene soporte GIN incorporado es JSON.  Para trabajar con valores JSON, actualmente se definen varios operadores y funciones, algunos de los cuales se pueden acelerar utilizando índices: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> opc.opcname, amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> str <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-string"><span class="hljs-string">'jsonb_ops'</span></span>,<span class="hljs-string"><span class="hljs-string">'jsonb_path_ops'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gin'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> opcname | amopopr | str ----------------+------------------+----- jsonb_ops | ?(jsonb,text) | 9 top-level key exists jsonb_ops | ?|(jsonb,text[]) | 10 some top-level key exists jsonb_ops | ?&amp;(jsonb,text[]) | 11 all top-level keys exist jsonb_ops | @&gt;(jsonb,jsonb) | 7 JSON value is at top level jsonb_path_ops | @&gt;(jsonb,jsonb) | 7 (5 rows)</code> </pre><br>  Como podemos ver, hay dos clases de operadores disponibles: "jsonb_ops" y "jsonb_path_ops". <br><br>  La primera clase de operador "jsonb_ops" se usa por defecto.  Todas las claves, valores y elementos de matriz llegan al índice como elementos del documento JSON inicial.  Se agrega un atributo a cada uno de estos elementos, que indica si este elemento es una clave (esto es necesario para estrategias "existentes", que distinguen entre claves y valores). <br><br>  Por ejemplo, representemos algunas filas de "rutas" como JSON de la siguiente manera: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> routes_jsonb <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_jsonb(t) route <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> departure_airport_name, arrival_airport_name, days_of_week <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> flight_no <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> ) t; demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ctid, jsonb_pretty(route) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_jsonb;</code> </pre><pre> <code class="plaintext hljs"> ctid | jsonb_pretty -------+------------------------------------------------- (0,1) | { + | "days_of_week": [ + | 1 + | ], + | "arrival_airport_name": "Surgut", + | "departure_airport_name": "Ust-Ilimsk" + | } (0,2) | { + | "days_of_week": [ + | 2 + | ], + | "arrival_airport_name": "Ust-Ilimsk", + | "departure_airport_name": "Surgut" + | } (0,3) | { + | "days_of_week": [ + | 1, + | 4 + | ], + | "arrival_airport_name": "Sochi", + | "departure_airport_name": "Ivanovo-Yuzhnyi"+ | } (0,4) | { + | "days_of_week": [ + | 2, + | 5 + | ], + | "arrival_airport_name": "Ivanovo-Yuzhnyi", + | "departure_airport_name": "Sochi" + | } (4 rows)</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> routes_jsonb <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(route);</code> </pre><br><br>  El índice puede verse de la siguiente manera: <br><br><img src="https://habrastorage.org/webt/oo/yi/x3/ooyix34gx7mrpiwdcol3a3ewnwu.png"><br><br>  Ahora, una consulta como esta, por ejemplo, se puede realizar utilizando el índice: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> jsonb_pretty(route) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_jsonb <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> route @&gt; <span class="hljs-string"><span class="hljs-string">'{"days_of_week": [5]}'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------- Bitmap Heap Scan on routes_jsonb Recheck Cond: (route @&gt; '{"days_of_week": [5]}'::jsonb) -&gt; Bitmap Index Scan on routes_jsonb_route_idx Index Cond: (route @&gt; '{"days_of_week": [5]}'::jsonb) (4 rows)</code> </pre><br>  Comenzando con la raíz del documento JSON, el operador <code>@&gt;</code> verifica si se produce la ruta especificada ( <code>"days_of_week": [5]</code> ).  Aquí la consulta devolverá una fila: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> jsonb_pretty(route) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_jsonb <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> route @&gt; <span class="hljs-string"><span class="hljs-string">'{"days_of_week": [5]}'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> jsonb_pretty ------------------------------------------------ { + "days_of_week": [ + 2, + 5 + ], + "arrival_airport_name": "Ivanovo-Yuzhnyi",+ "departure_airport_name": "Sochi" + } (1 row)</code> </pre><br>  La consulta se realiza de la siguiente manera: <br><br><ol><li>  En la consulta de búsqueda ( <code>"days_of_week": [5]</code> ) se extraen elementos (claves de búsqueda): "days_of_week" y "5". <br></li><li>  En el árbol de elementos se encuentran las claves extraídas, y para cada una de ellas se selecciona la lista de TID: para "5" - (0.4), y para "days_of_week" - (0,1), (0,2 ), (0.3), (0.4). <br></li><li>  De todos los TID encontrados, la función de coherencia selecciona aquellos que coinciden con el operador de la consulta.  Para el operador <code>@&gt;</code> , los documentos que no contienen todos los elementos de la consulta de búsqueda no serán seguros, por lo que solo queda (0,4).  Pero aún necesitamos volver a verificar el TID que queda con la tabla, ya que no está claro en el índice en qué orden se producen los elementos encontrados en el documento JSON. <br></li></ol><br>  Para descubrir más detalles de otros operadores, puede leer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la documentación</a> . <br><br>  Además de las operaciones convencionales para tratar con JSON, la extensión "jsquery" ha estado disponible durante mucho tiempo, que define un lenguaje de consulta con capacidades más ricas (y ciertamente, con soporte de índices GIN).  Además, en 2016, se emitió un nuevo estándar SQL, que define su propio conjunto de operaciones y lenguaje de consulta "Ruta SQL / JSON".  Ya se ha logrado una implementación de este estándar, y creemos que aparecerá en PostgreSQL 11. <br><br><blockquote>  El parche de ruta SQL / JSON finalmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se</a> confirmó en PostgreSQL 12, mientras que otras piezas aún están en camino.  Con suerte, veremos la característica completamente implementada en PostgreSQL 13. <br></blockquote><br><h2>  Internos </h2><br>  Podemos mirar dentro del índice GIN usando la extensión " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pageinspect</a> ". <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> pageinspect;</code> </pre><br>  La información de la página meta muestra estadísticas generales: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gin_metapage_info(get_raw_page(<span class="hljs-string"><span class="hljs-string">'mail_messages_tsv_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----+----------- pending_head | 4294967295 pending_tail | 4294967295 tail_free_size | 0 n_pending_pages | 0 n_pending_tuples | 0 n_total_pages | 22968 n_entry_pages | 13751 n_data_pages | 9216 n_entries | 1423598 version | 2</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La estructura de la página</a> proporciona un área especial donde los métodos de acceso almacenan su información;  esta área es "opaca" para programas ordinarios como el vacío.  La función "Gin_page_opaque_info" muestra estos datos para GIN.  Por ejemplo, podemos conocer el conjunto de páginas de índice: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> flags, count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">22967</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> g(id), <span class="hljs-comment"><span class="hljs-comment">-- n_total_pages gin_page_opaque_info(get_raw_page('mail_messages_tsv_idx',g.id)) group by flags;</span></span></code> </pre><pre> <code class="plaintext hljs"> flags | count ------------------------+------- {meta} | 1 meta page {} | 133 internal page of element B-tree {leaf} | 13618 leaf page of element B-tree {data} | 1497 internal page of TID B-tree {data,leaf,compressed} | 7719 leaf page of TID B-tree (5 rows)</code> </pre><br>  La función "Gin_leafpage_items" proporciona información sobre los TID almacenados en las páginas {datos, hoja, comprimido}: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gin_leafpage_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'mail_messages_tsv_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">2672</span></span>));</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]--------------------------------------------------------------------- first_tid | (239,44) nbytes | 248 tids | {"(239,44)","(239,47)","(239,48)","(239,50)","(239,52)","(240,3)",... -[ RECORD 2 ]--------------------------------------------------------------------- first_tid | (247,40) nbytes | 248 tids | {"(247,40)","(247,41)","(247,44)","(247,45)","(247,46)","(248,2)",... ...</code> </pre><br>  Tenga en cuenta que las páginas del árbol de TID en realidad contienen pequeñas listas comprimidas de punteros a filas de tabla en lugar de punteros individuales. <br><br><h2>  Propiedades </h2><br>  Veamos las propiedades del método de acceso GIN ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ya se han proporcionado consultas</a> ). <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- gin | can_order | f gin | can_unique | f gin | can_multi_col | t gin | can_exclude | f</code> </pre><br>  Curiosamente, GIN admite la creación de índices de varias columnas.  Sin embargo, a diferencia de un árbol B normal, en lugar de claves compuestas, un índice de varias columnas seguirá almacenando elementos individuales, y el número de columna se indicará para cada elemento. <br><br>  Las siguientes propiedades de capa de índice están disponibles: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | f bitmap_scan | t backward_scan | f</code> </pre><br>  Tenga en cuenta que no se admite la devolución de resultados TID por TID (exploración de índice);  solo es posible el escaneo de mapa de bits. <br><br>  La exploración hacia atrás tampoco es compatible: esta función es esencial solo para la exploración de índice, pero no para la exploración de mapa de bits. <br><br>  Y las siguientes son propiedades de capa de columna: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | f returnable | f search_array | f search_nulls | f</code> </pre><br>  Aquí no hay nada disponible: sin clasificación (lo que está claro), sin uso del índice como cobertura (ya que el documento en sí no está almacenado en el índice), sin manipulación de NULL (ya que no tiene sentido para elementos de tipo compuesto) . <br><br><h2>  Otros tipos de datos </h2><br>  Hay algunas extensiones más disponibles que agregan soporte de GIN para algunos tipos de datos. <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pg_trgm</a> " nos permite determinar la "similitud" de las palabras al comparar cuántas secuencias iguales de tres letras (trigramas) están disponibles.  Se añaden dos clases de operadores, "gist_trgm_ops" y "gin_trgm_ops", que admiten varios operadores, incluida la comparación mediante expresiones LIKE y regulares.  Podemos usar esta extensión junto con la búsqueda de texto completo para sugerir opciones de palabras para corregir errores tipográficos. <br></li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hstore</a> " implementa el almacenamiento "clave-valor".  Para este tipo de datos, hay disponibles clases de operador para varios métodos de acceso, incluido GIN.  Sin embargo, con la introducción del tipo de datos "jsonb", no hay razones especiales para usar "hstore". <br></li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">intarray</a> " amplía la funcionalidad de las matrices de enteros.  El soporte de índice incluye GiST, así como GIN (clase de operador "gin__int_ops"). <br></li></ul><br>  Y estas dos extensiones ya se han mencionado anteriormente: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">btree_gin</a> " agrega soporte GIN para los tipos de datos regulares para que puedan usarse en un índice de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">varias columnas</a> junto con los tipos compuestos. <br></li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">jsquery</a> " define un idioma para las consultas JSON y una clase de operador para el soporte de índice de este idioma.  Esta extensión no está incluida en una entrega estándar de PostgreSQL. <br></li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sigue leyendo</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/448746/">https://habr.com/ru/post/448746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448732/index.html">Hernia intervertebral? Trabajar en ella</a></li>
<li><a href="../448734/index.html">Drones y robots que ayudan a salvar la Catedral de Notre Dame de París</a></li>
<li><a href="../448738/index.html">¿Quién caza startups?</a></li>
<li><a href="../448740/index.html">Escuchamos música SID (Commodore 64) a través de OPL3 en PC modernas</a></li>
<li><a href="../448744/index.html">¿Cómo transferir una variable de fragmento a actividad en Android?</a></li>
<li><a href="../448748/index.html">Reflexiones sobre belleza y código</a></li>
<li><a href="../448750/index.html">Sobre una vulnerabilidad que no es</a></li>
<li><a href="../448754/index.html">Quién es quién en código abierto: biografías geek</a></li>
<li><a href="../448756/index.html">Antecedentes: por qué Apple y Qualcomm se pelearon y luego se reconciliaron</a></li>
<li><a href="../448758/index.html">Reloj inteligente con BASIC en 6502 físico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>