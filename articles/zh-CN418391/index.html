<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎳 👨🏼‍🎤 💄 OSPF（第一部分） 🥈 ⏏️ 👼🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本文是为我自己写的，因此，如有必要，可以快速刷新我的记忆并理解理论。 我决定发布它，也许对某人有用，或者我误会了某些东西。 

 在本文中，我们将尝试了解OSPF协议理论。 我们不会深入研究创建协议的历史和过程；有关OSPF的几乎每篇文章中都包含丰富的信息。 我们将尝试更详细地了解OSPF如何工作以...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OSPF（第一部分）</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418391/">本文是为我自己写的，因此，如有必要，可以快速刷新我的记忆并理解理论。 我决定发布它，也许对某人有用，或者我误会了某些东西。 <br><br> 在本文中，我们将尝试了解OSPF协议理论。 我们不会深入研究创建协议的历史和过程；有关OSPF的几乎每篇文章中都包含丰富的信息。 我们将尝试更详细地了解OSPF如何工作以及如何构建其路由表。 给出协议的一般定义很重要： <br><br>  <b>OSPF</b> （开放式最短路径优先）是一种基于链接状态技术的动态路由协议，并使用Dijkstra算法查找最短路径。 <br><br> 问题立即出现-什么是频道跟踪技术？ 我认为这个名字并不完全成功。 碰巧有两种类型的动态路由协议：链接状态和距离矢量。 考虑他们的工作原则： <br><br> 在距离矢量协议中，路由器通过直接连接到同一网段的路由器识别路由信息。 即，路由器仅在其相邻路由器的边界之内具有关于拓扑的信息，并且不知道如何布置这些路由器后面的拓扑，仅关注度量。 在链路状态协议中，每个路由器都不应轻易知道通往所有远程网络的最佳路由，而应在内存中具有一个完整的网络图，其中包括其他路由器之间的所有现有连接。 这是通过建立一个特殊的LSDB基础来实现的，但稍后会介绍更多。 <br><a name="habracut"></a><br> 那么，让我们从如何构建LSDB入手，路由器从中了解所有路由。 我们构建用于研究的初始拓扑。 看起来像这样： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea4/c83/539/ea4c835392207c07ca33dd8ec883a707.jpg" alt="图片"><br><br> 我们将配置OSPF。  OSPF从哪里开始？  C在路由器之间建立邻居-在路由器接口上激活OSPF之后，路由器开始发送Hello消息。 该消息每10秒发送一次到多播地址-224.0.0.5（Hello Timer）。 我们将首先在vIOS1路由器上启用OSPF。 <br><br> 让我们看一下Hello包的样子： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ca/3bf/881/6ca3bf881cddaf569bdfb54bd3913666.jpg" alt="图片"><br><br> 在消息中，重要的是要注意诸如“区域ID”，“源OSPF路由器”之类的字段。  OSPF进程启动时，将选择“路由器ID”，这是在其他OSPF路由器之间标识路由器所必需的。 选择此参数的规则如下： <br><br>  1.由特殊的router-id命令ABCD配置-IP地址格式。 <br>  2.配置了一个环回接口和多个具有不同地址的接口： <br><br><ul><li> 分配给环回接口的地址将是路由器ID。 </li></ul><br>  3.配置了多个环回接口，每个接口都有多个IP地址： <br><br><ul><li> 分配给任何环回接口的最高IP地址将是路由器ID。 </li></ul><br>  4.配置了多个接口，每个接口上都有一个IP地址： <br><br><ul><li> 所有活动接口中最大的IP地址将是路由器ID。 </li></ul><br> 现在让我们继续到Area ID字段-这是OSPF中一个更重要的基础概念。 为了与大量路由器一起使用，OSPF使用区域。 每个路由器接口必须属于任何一个区域。 在我们的拓扑中，vIOS1，vIOS2，vIOS3，vIOS4路由器的Gi0 / 0接口属于区域0。区域0称为主干，并且是所有其他区域的中心。 每个其他区域都必须连接到骨干区域（尚未考虑虚拟链接）。 在进一步分析中，这些概念将变得更加清晰。 <br><br> 因此，我们在vIOS1上打开了OSPF，它开始每10秒发送一次Hello数据包。 在vIOS2上打开OSPF并查看如何建立邻居关系。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9c3/721/8d4/9c37218d473f4f96d9c762300ed21bd1.jpg" alt="图片"><br><br> 因此，我们仔细监视消息的顺序。 首先，Hello只发送路由器1.1.1.1（192.168.1.1），一旦我们在192.168.1.2上启用OSPF，就会发送一个Hello数据包。  vIOS1和vIOS2将彼此接收Hello数据包，为了使邻居发生，重要的是在两个路由器的OSPF配置中，以下参数必须相同： <br><br><ul><li>  Hello间隔-发送Hello消息的频率 </li><li> 路由器失效间隔-一段时间后，如果没有Hello，则认为邻居不可用。 </li><li> 区域ID-只能通过一个区域中的接口建立邻居。 </li><li> 身份验证-用于身份验证的密码和身份验证类型（如果有）。 </li><li> 存根区域标志-在属于存根区域的所有路由器上设置的可选标志 </li></ul><br> 如果查看上面显示的Hello包，则所有这些参数都在Hello包中指示。 一台路由器（vIOS1）收到一个新的Hello数据包并检查所有条件后，它将立即发送一个Hello数据包，该数据包将在“活动邻居”字段中指示新路由器（vIOS2）的地址，vIOS2将会接收并在邻居字段中看到它自己，将添加vIOS1到邻居，并将单播数据包发送到192.168.1.1（vIOS1），在此处将其指示为邻居。 可以这么说，他们已经成为邻居，现在乐趣就开始了-信息交换和基础LSDB的构建。 为了建立社区，我建议您阅读以下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a> 。 <br><br>  LSDB库将包含有关路由的信息，并且在邻居建立后，该LSDB在同一区域内的所有路由器上都应相同。 并且，首先，路由器在建立邻居后开始其数据库彼此同步的过程（vIOS1与vIOS2）。 如您所见，这一切都始于消息DB Description（DBD）的交换。 为了更加清楚，让我们谈谈OSPF使用的消息类型： <br><br><ul><li> 您好-用于发现邻居，检查参数，与邻居建立邻居关系并监视可用性。 </li><li> 数据库描述（DBD）-检查路由器上数据库同步的状态。 </li><li> 链接状态请求（LSR）-请求有关从路由器到路由器的通道状态的特定记录以进行同步。 </li><li> 链接状态更新（LSU）-发送特定的通道状态记录以响应请求。 </li><li> 链路状态确认（LSAck）-确认收到其他类型的数据包。 </li></ul><br> 引入诸如LSA之类的概念也很重要： <br><br>  <b>链路状态公告（LSA）</b> -描述路由器或网络的本地状态的数据单位。 许多描述路由器和网络的LSA形成一个链接状态数据库（LSDB）。  LSDB由几种类型的LSA组成。 本文详细介绍了每个LSA。  DBD消息使用许多标志来确定同步状态，并且这些消息包含有关其自身数据库的信息。 也就是说，vIOS1在这些消息中报告说，在我的数据库中有关于诸如192.168.0 / 24、1.1.1.0 / 24（LSA类型1）之类的网络的信息，而vIOS2则报告了它具有有关以下内容的记录：网络：192.168.2.0/24、2.2.2.0/24（LSA类型1）。 收到DBD消息后，每个路由器都会发送LSAck以确认接收到的消息，然后将邻居数据库中的信息与自己的信息进行比较。 如果发现没有可用信息，则路由器会发送LS请求，并在其中请求有关任何LSA的完整信息。 例如，vIOS1向vIOS2请求了LS请求，vIOS2以LS Update进行了响应，该更新已包含有关每个路由的详细信息。 以下是LS更新： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a79/2cc/672/a792cc672c63e0a95c5b17951567b565.jpg" alt="图片"><br><br> 如您所见，在这篇文章中，vIOS2讨论了他所知道的子网以及与之相关的信息。 另外，vIOS1谈论其LSDB。 最后，路由器具有相同的LSDB。 该过程完成后，将启动Dijkstra的算法（最短路径优先）。 它计算来自LSDB的所有已知路由，并将其中的最佳路由放入路由表中。 指标越低越好，但后来又更多。 <br><br> 让我们考虑一个问题，如果在vIOS3上激活OSPF会发生什么？ 由于vIOS3将必须构建LSDB并将其与其他路由器同步，因此出现了一个问题：确切地与谁同步？ 使用vIOS1还是vIOS2？ 与每个单独？ 这有多理想？ 因此，在OSPF中有诸如DR（指定路由器）之类的东西。 我们介绍这个概念： <br><br>  <b>专用路由器（指定路由器，DR）</b> -管理网络上的LSA分发过程。 每个网络路由器都与DR建立邻居关系。 有关网络更改的信息由DR（检测到此更改的路由器）发送，DR负责确保将此信息发送到网络中的其他路由器。 <br><br> 换句话说，如果新路由器出现在该网段中，则它将其LSDB与DR同步。 同样重要的是要注意，当网络更改或出现新路由时，不仅新路由器，而且所有其他路由器都将通知DR有关此信息，其余路由器将从DR中获取此信息。 但是随后出现了问题-如果DR失败会发生什么？ 如何选择灾难恢复？ <br><br> 失败时，必须选择新的DR。 必须形成新的邻居关系，并且在路由器数据库与新的DR数据库同步之前，网络将不可用于数据包转发。 为消除此缺点，请选择“ BDR-备份指定路由器”： <br><br>  <b>备份指定路由器（BDR）。</b> 每个网络路由器不仅与DR建立邻居关系，而且与BDR建立邻居关系。  DR和BDR还彼此建立邻居关系。 当DR失败时，BDR成为DR并执行其所有功能。 由于网络路由器已与BDR建立了邻居关系，因此网络不可用时间得以最小化。 因此，在我们的网络中，我们不仅获得了DR，还获得了BDR。 其他路由器将仅通过它们来接收和报告有关网络的相关信息。  DR和BDR只能在一个段中选择，而不能在一个区域中选择！ 也就是说，对于vIOS1，vIOS2，vIOS3，vIOS4路由器，将选择一个DR和BDR，例如，在vIOS和vIOS1之间，即使它们位于同一区域0中，也将相对于其网段确定其DR和BDR。对于DR和BDR，路由器使用224.0.0.6的多播地址。 <br><br> 下一个问题是：如何选择DR / BDR？ 适用以下条件： <br><br><ol><li>  DR：OSPF接口最高优先级的路由器。 </li><li>  BDR：具有OSPF接口第二高优先级的路由器。 </li><li> 如果OSPF接口的优先级相等，则使用最高的路由器ID进行选择。 正如我们所说，路由器定义了它们的路由器ID。 最初，当在vIOS1和vIOS2上启动OSPF时，除了建立邻居外，还进行了DR / BDR选举。  ID为-2.2.2.2的VIOS2在此争议中获胜，而vIOS1的ID为-1.1.1.1。  vIOS1被选为BDR。 重要的是要注意，选择DR和BDR的过程不会在从第二个路由器接收到第一个Hello数据包后立即进行。 为此，有一个特殊的计时器等于路由器死间隔-40秒。 如果在此期间未收到具有最佳ID的Hello数据包，则将基于现有的Hello数据包进行选择。 </li></ol><br> 直到现在，我们可以回到问题-如果在vIOS3上激活OSPF会发生什么？ 激活OSPF后，vIOS3将开始发送和侦听Hello数据包。 它将接收来自vIOS1和vIOS2的Hello数据包，该数据包将指示哪些路由器是DR和BDR，并了解应与谁同步LSDB。 重要的是要注意，当出现具有更好ID的路由器时，DR / BDR不会更改，直到其中一个崩溃。 之后，vIOS3开始将其LSDB与这些路由器同步。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f8e/8b2/35a/f8e8b235a0eb24d311d6b745dac5910e.jpg" alt="图片"><br><br> 从vIOS3接收到新信息后，DR将LS Update消息发送到所有路由器，到达地址224.0.0.5，其他收到数据包的路由器将LS确认发送到DR，但到达地址224.0.0.6（DR / BDR的地址）。 <br><br> 根据相同的方案，我们还连接了vIOS4。 同步后，所有路由器都具有相同的LSDB。 让我们看看vIOS3的邻居状态如何。 显示ip ospf neighbor命令： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bf2/3eb/51f/bf23eb51f7a7ab94f64be8726dae9370.jpg" alt="图片"><br><br> 如我们所见，DR是2.2.2.2，BDR是1.1.1.1，并且在vIOS4中选择了2WAY / DROTHER。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上面</a>提到了邻国。 <br><br> 以下是vIOS1上的邻居状态以及已建立的带有vIOS的邻居： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f3c/583/7e7/f3c5837e7b1d99243357857cc4cb1352.jpg" alt="图片"><br><br> 如您所见，他有两个DR，因为他在网络的另一个网段中有一个邻居。 <br><br><h3> 多区域 </h3><br> 考虑使用多个区域时OSPF的工作方式。 通过添加新路由器来更改拓扑： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/54c/b16/f0c/54cb16f0c9293e15b65544b3b89573a4.jpg" alt="图片"><br><br> 首先，我们将在vIOS1和vIOS上配置OSPF，以便它们在vIOS和vIOS1上的Gi0 / 1接口位于区域1中。让我们看看有什么变化。  vIOS1现在在区域0（Gi0 / 0）和区域1（Gi0 / 0）中都具有接口。 这样的路由器称为ABR-区域边界路由器（下面我们将为ABR提供更正确的定义）。  ABR将路由信息从一个区域发送到另一个区域。 这是通过LSA类型3完成的： <br><br>  <b>类型3 LSA-网络摘要LSA-</b>网络通道状态的摘要公告： <br><br><ul><li> 边缘路由器传播的广告 </li><li> 公告描述了到本地以外网络的路由 </li><li> 包含有关网络以及通往这些网络的路径成本的信息，但不发送有关网络拓扑的信息 </li><li> 默认情况下，边缘路由器会为它知道的每个网络发送一个单独的公告。 如有必要，可以对ABR网络进行总结 </li><li> 链接状态ID-目标网络号。 </li></ul><br> 该协议的核心是在区域之间，其操作原理类似于距离矢量协议的原理，只传输带有度量的路由信息​​。 这是区域0中来自vIOS1的LS更新，其中包含3个LSA类型3件： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3f3/681/fa8/3f3681fa87bb1a94778d4bec031f37a1.jpg" alt="图片"><br><br>  LSA Type 3的核心与LSA Type 1的结构没有太大不同，但是它们以不同的方式影响协议。 当收到更新的LSA或丢失任何类型1和2的LSA时，将重新启动SPF（最短路径算法）并重新计算LSDB。 <br><br> 收到类型3的LSA时，不会发生此过程-获取具有类型3的度量值的路由该LSA存储通过ABR接收到给定路由的数据（在“广告路由器”字段中指定了ABR）和实现该ABR的度量值LSDB中已经可用。 因此，来自LSA类型3的度量标准与到达ABR的路由度量标准进行了汇总，我们无需重新启动SPF即可获得完成的路由。 此过程称为<b>部分SPF计算</b> 。 这非常重要，因为在大型网络上，LSDB的大小可能很大，并且运行SPF常常不好。 同样，LSA类型3的创建表明更改和重新计算LSDB是一个领域。  ABR仅报告某些路由发生了变化。 <br><br> 同样重要的是要注意，从非零区域到任何非零区域的任何路由都将通过区域0。如果存在ABR，则无法将其连接到区域0（我们排除了带有虚拟链接的选项）。 区域0是连接所有其他区域并在区域之间提供路由的核心。  ABR的定义如下所示： <br><br>  <b>边界路由器（区域边界路由器，ABR）</b> -将一个或多个区域连接到中继区域，并充当区域间流量的网关。 边缘路由器在主干区域中始终至少具有一个接口。 对于每个连接的区域，路由器维护一个单独的通道状态数据库。 <br> 我们处理社区的建立，LSDB和SPF以及常规区域的创建。 现在让我们看一下OSPF对拓扑变化的收敛和响应。 <br><br> 让我们看一下拓扑，并想象vIOS3停止工作（通道的状态未更改）。 这将有助于重建Dead Interval Timer拓扑-40秒。 如果在此时间间隔内，路由器未收到邻居的Hello数据包，则邻居会崩溃。 在我们的情况下，DR将发送具有LSA类型2的LS Update，这表明所连接的路由器之间不存在vIOS3，这将导致SPF启动并重新计数LSDB，而不会从vIOS3接收到LSA。 重要的是要注意，在常规的vIOS4路由器上，即使耗尽间隔计时器和失去与vIOS3的邻近性也不会导致拓扑的重新计算，这是LSA Type 2的LS Update消息开始的。 <br><br>  <b>类型2 LSA-网络LSA-网络链接</b>状态公告： <br><br><ul><li> 由DR在多路访问网络中分发 </li><li> 没有为未选择DR的网络创建网络LSA </li><li> 仅在一个区域内分布 </li><li> 链路状态ID-DR接口的IP地址 </li></ul><br> 因此，在此消息的帮助下，将忽略已停止工作的数据。 邻居的指示是丢弃无关路由的触发因素。 <br><br> 重新打开vIOS3并再次建立邻居。 下一个实验是对在vIOS3上禁用Gi0 / 1接口的反应。  vIOS3一旦检测到链路断开，就会立即将LS Update发送到DR到地址224.0.0.6，在该地址中，通过在LSA中设置标记LS Age等于3600秒来报告某些路由已掉线。 对于LSDB，这是Max Age，并且SPF中不考虑所有具有Max Age的LSA，因此它们将不在路由表中。 问题是：当Age LSA自然达到Max Age时，会发生什么？ 为此，OSPF具有LSRefreshTime-等于最大使用期限的一半，每1800秒从路由器发送一次LS Update来更新计时器数据： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/43a/dd0/8c4/43add08c439f2826bb85e434a2280ae5.jpg" alt="图片"><br><br> 此外，已经处理了该LS更新的DR将LS LS发送到所有其他路由器到地址224.0.0.5。 路由器一获得新信息，便立即发送LSAck。 这样可以确保OSPF的良好收敛性。 <br><br><h3> 选择最佳路线 </h3><br> 路由器根据最低的度量值选择最佳的路由。 但是，OSPF在选择路由时还考虑了其​​他几个因素。 在这种情况下，路由源及其类型很重要。 优先级路由选择如下： <br><br><ul><li> 区域的内部路由（区域内） </li><li> 区域之间的路由（区域间） </li><li> 外部路由类型1（E1） </li><li> 外部路由类型2（E2） </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管按区域转移E2路由的成本不会改变（不添加到ASBR的路径的成本），但是当E2路由的成本重合时，将比较宣告该路由的到ASBR的路径的成本。当您必须从相同类型的路由中选择时，将考虑该度量标准。作为度量，使用诸如成本的概念。它由以下公式计算：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">成本=参考带宽/链路带宽。参考带宽-带宽的基础。默认情况下，在Cisco上它等于100Mbit。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ABR环路预防。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如上所述，区域之间的OSPF操作原理类似于距离矢量协议。</font><font style="vertical-align: inherit;">使用环路预防机制，我们可以得出选择了非最佳路径的信息。</font><font style="vertical-align: inherit;">例如，在区域之间，存在距离矢量协议中的“水平分割”之类的规则。</font><font style="vertical-align: inherit;">以这个示例为例，如果我们如下更改区域0和4的边界处的拓扑：</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/318/d56/328/318d56328823c86abf8df0b5439e76b7.jpg" alt="图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">那么我们得到vIOS18将通过Gi0 / 0接口选择度量为100的非最优路径。</font><font style="vertical-align: inherit;">发生这种情况是由于vIOS18不会考虑不是从区域0接收到的LSA类型3。而且，上述规则禁止将该LSA类型3传送回区域0。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN418391/">https://habr.com/ru/post/zh-CN418391/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN418381/index.html">Chrome 68版中的DevTools的新增功能</a></li>
<li><a href="../zh-CN418383/index.html">基于Kotlin和RxJava的Android动画</a></li>
<li><a href="../zh-CN418385/index.html">我如何组装旧游戏计算机</a></li>
<li><a href="../zh-CN418387/index.html">物理学家关于灵魂的对话</a></li>
<li><a href="../zh-CN418389/index.html">RabbitMQ vs. Kafka：在面向事件的应用程序中使用Kafka</a></li>
<li><a href="../zh-CN418393/index.html">[星期五]我们如何看待3D Web</a></li>
<li><a href="../zh-CN418395/index.html">伊隆·马斯克（Elon Musk）：当地的电磁场发生器将保护火星上的殖民者</a></li>
<li><a href="../zh-CN418397/index.html">星期五管理：免费的Skillbox网络研讨会</a></li>
<li><a href="../zh-CN418399/index.html">在Selectel FM的浪潮中</a></li>
<li><a href="../zh-CN418401/index.html">我怎么没成为你：对系统管理员的厚爱</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>