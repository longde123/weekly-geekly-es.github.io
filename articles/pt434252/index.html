<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÖ üêæ üë©‚Äçüëß‚Äçüëß Experi√™ncia na implementa√ß√£o de automa√ß√£o no processo de teste manual no exemplo de um aplicativo Android ü§Ωüèª üë©üèº‚Äçüåæ üõåüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Um bom testador com habilidades de pensamento cr√≠tico n√£o pode ser completamente substitu√≠do pela automa√ß√£o. Tornar o trabalho mais eficiente √© f√°cil....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Experi√™ncia na implementa√ß√£o de automa√ß√£o no processo de teste manual no exemplo de um aplicativo Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434252/">  <i>Um bom testador com habilidades de pensamento cr√≠tico n√£o pode ser completamente substitu√≠do pela automa√ß√£o.</i>  <i>Tornar o trabalho mais eficiente √© f√°cil.</i>  <i>Com essa convic√ß√£o, fui ao nosso departamento de testes com uma nova tarefa, onde n√≥s, juntamente com Pavel, assumimos sua implementa√ß√£o.</i>  <i>Vamos ver o que aconteceu.</i> <br><br>  Juntamente com nossos parceiros, estamos ativamente desenvolvendo, testando e dando suporte a uma fam√≠lia de aplicativos para diferentes plataformas: Android, iOS, Windows.  Os aplicativos est√£o se desenvolvendo ativamente, juntamente com os quais o volume de testes est√° aumentando, principalmente a regress√£o. <br><br>  Decidimos tentar facilitar e acelerar o teste automatizando a maioria dos casos de teste.  Ao mesmo tempo, n√£o quer√≠amos abandonar completamente o processo de teste manual, mas modific√°-lo. <br><br>  A implementa√ß√£o dessa abordagem come√ßou com um dos aplicativos Android, sobre o qual falarei.  O artigo ser√° de interesse para autores iniciantes de testes de interface do usu√°rio, principalmente para aplicativos m√≥veis, bem como aqueles que desejam automatizar o processo de teste manual at√© certo ponto. <br><br>  Vamos l√°! <a name="habracut"></a><br><br><h2>  Ponto de partida </h2><br>  Para cada plataforma, temos v√°rias similares que executam o mesmo processo de neg√≥cios principal de aplicativos.  No entanto, eles diferem um do outro em um conjunto de pequenas funcionalidades auxiliares, s√£o feitas sob marcas diferentes, dependendo do cliente (devido ao qual a interface muda de aplicativo para aplicativo), e o processo de neg√≥cios pode ser personalizado adicionando etapas adicionais. <br><br>  Estamos diante de certos problemas que precisam ser abordados.  Dificuldades semelhantes podem surgir em uma situa√ß√£o diferente da nossa.  Por exemplo, se voc√™ tiver um aplicativo volumoso com l√≥gica comercial dif√≠cil, cheio de muitos testes. <br><br><h4>  Problema # 1: muitos testes de regress√£o </h4><br>  Os conjuntos de cen√°rios de teste para cada aplicativo s√£o simultaneamente semelhantes e diferentes entre si, o que contribui para um aumento na regress√£o e a torna ainda mais chata.  No entanto, voc√™ precisa testar todos os aplicativos individualmente. <br><br>  Considerando que os aplicativos j√° em execu√ß√£o s√£o atualizados regularmente e, no futuro, haver√° apenas mais, o n√∫mero total de testes aumentar√° inexoravelmente. <br><br><h4>  Problema n√∫mero 2: voc√™ precisa testar em todas as vers√µes do sistema operacional m√≥vel </h4><br>  Um requisito importante √© a disponibilidade de nossos aplicativos m√≥veis em uma ampla variedade de vers√µes de sistemas operacionais.  Por exemplo, no caso do Android no momento da escrita, esses s√£o n√≠veis de API de 17 a 28. <br><br>  Idealmente, devemos testar em cada vers√£o do Android, o que complica ainda mais nossa regress√£o.  O processo de teste direto do aplicativo adquire uma rotina adicional multiplicada pelo n√∫mero de dispositivos: instala√ß√£o e execu√ß√£o do aplicativo, trazendo-o ao seu estado original ap√≥s cada remo√ß√£o individual de teste.  Ao mesmo tempo, a manuten√ß√£o de seu pr√≥prio farm de dispositivos exige bastante trabalho. <br><br><h4>  Solu√ß√£o: integre a automa√ß√£o ao processo de teste manual </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ts/gc/pf/tsgcpf5ughy1cerkbpdpkkuqxww.jpeg"></div><br>  Uma tarefa t√≠pica da automa√ß√£o de teste √© automatizar testes de regress√£o.  Ent√£o, queremos melhorar a efici√™ncia do processo de teste hoje e evitar as poss√≠veis conseq√º√™ncias do crescimento amanh√£. <br><br>  Ao mesmo tempo, estamos cientes de que √© imposs√≠vel e desnecess√°rio erradicar completamente os testes manuais por automa√ß√£o.  O pensamento cr√≠tico e o olho humano s√£o dif√≠ceis de substituir por algo.  H√° um bom artigo sobre esse assunto no blog de Michael Bolton, The <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">End of Manual Testing</a> (ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tradu√ß√£o</a> de Anna Rodionova). <br><br>  N√≥s pensamos que seria √∫til ter um conjunto de testes automatizados que cobrissem as partes est√°veis ‚Äã‚Äãdo aplicativo e, no futuro, escrevesse testes para erros encontrados e novas funcionalidades.  Ao mesmo tempo, queremos associar os autotestes aos conjuntos de testes existentes em nosso sistema de gerenciamento de testes (usamos o TestRail) e tamb√©m permitir que os testadores executem facilmente autotestes em dispositivos f√≠sicos na nuvem (escolhemos o Firebase Test Lab como a infraestrutura na nuvem). <br><br>  Para come√ßar e tentar, pegamos um de nossos aplicativos Android.  Era importante considerar que, se a solu√ß√£o fosse bem-sucedida, suas pr√°ticas recomendadas poderiam ser aplicadas a outros aplicativos, inclusive em outras plataformas. <br><br>  O que queremos obter como resultado: <br><br><ol><li>  Automa√ß√£o de testes de regress√£o. </li><li>  Integra√ß√£o com o sistema de gerenciamento de testes. </li><li>  Possibilidade de in√≠cio manual parametrizado de autoteste em dispositivos na nuvem. </li><li>  A possibilidade de reutilizar a solu√ß√£o no futuro. </li></ol><br>  A seguir, falarei separadamente sobre a implementa√ß√£o de cada um desses pontos com um pouco de imers√£o no componente t√©cnico. <br><br><h2>  Esquema geral de implementa√ß√£o da solu√ß√£o </h2><br>  Mas primeiro, um esbo√ßo geral do que obtivemos: <br><br><img src="https://habrastorage.org/webt/k3/dc/yf/k3dcyf4d-az9yt4ce0dqgseko6m.png" alt="imagem"><br><br>  Os testes autom√°ticos s√£o executados de duas maneiras: <br><br><ol><li>  Do IC ap√≥s mesclar ou puxar solicita√ß√£o para mestre. </li><li>  Teste manualmente a partir da interface da web do Jenkins Job. </li></ol><br>  No caso de uma inicializa√ß√£o manual, o testador deve indicar o n√∫mero da compila√ß√£o correspondente ou fazer o download de 2 APKs no computador: com o aplicativo e com os testes.  Este m√©todo √© necess√°rio para que voc√™ possa executar os testes necess√°rios a qualquer momento em qualquer dispositivo dispon√≠vel. <br><br>  Durante os testes, seus resultados s√£o enviados para o TestRail.  Isso acontece da mesma maneira como se o testador executasse o teste manualmente e inserisse os resultados de uma maneira familiar a ele. <br><br>  Assim, deixamos o processo estabelecido de teste manual, mas adicionamos automa√ß√£o a ele, que executa um conjunto espec√≠fico de testes.  O testador "capta" o que foi feito automaticamente e: <br><br><ul><li>  v√™ o resultado de casos de teste em cada dispositivo que foi selecionado; </li><li>  pode verificar manualmente qualquer caso de teste; </li><li>  executa casos de teste que ainda n√£o foram automatizados ou que n√£o podem ser otimizados por qualquer motivo; </li><li>  toma a decis√£o final no teste atual. </li></ul><br>  Agora vamos para a descri√ß√£o prometida da implementa√ß√£o. <br><br><h2>  1. Auto testes </h2><br><h4>  As ferramentas </h4><br>  Usamos tr√™s ferramentas para interagir com a interface do usu√°rio: <br><br><ul><li>  Espresso </li><li>  Barista. </li><li>  UI Automator. </li></ul><br>  A principal ferramenta e a que come√ßamos √© o Espresso.  O principal argumento a favor de sua escolha foi o fato de o Espresso permitir que voc√™ teste usando o m√©todo da caixa branca, fornecendo acesso √† Instrumenta√ß√£o Android.  O c√≥digo de teste est√° no mesmo projeto que o c√≥digo do aplicativo. <br><br>  O acesso ao c√≥digo do aplicativo Android √© necess√°rio para chamar seus m√©todos nos testes.  Podemos preparar nosso aplicativo para um teste espec√≠fico com anteced√™ncia, executando-o no estado correto.  Caso contr√°rio, precisamos atingir esse estado atrav√©s da interface, que priva os testes de atomicidade, tornando-os dependentes um do outro, e simplesmente consome muito tempo. <br><br>  Durante a implementa√ß√£o, outra ferramenta foi adicionada ao Espresso - UI Automator.  Ambas as estruturas fazem parte da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Biblioteca de suporte a testes</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Google, do Google</a> .  Usando o UI Automator, podemos interagir com v√°rias caixas de di√°logo do sistema ou, por exemplo, Gaveta de Notifica√ß√µes. <br><br>  E o √∫ltimo em nosso arsenal foi o quadro Barista.  √â um inv√≥lucro do Espresso, economizando o c√≥digo padr√£o ao implementar a√ß√µes comuns do usu√°rio. <br><br>  Tendo em mente o desejo de poder reutilizar a solu√ß√£o em outros aplicativos, √© importante observar que as ferramentas listadas destinam-se exclusivamente a aplicativos Android.  Se voc√™ n√£o precisar acessar o c√≥digo do aplicativo em teste, provavelmente preferir√° usar uma estrutura diferente.  Por exemplo, o Appium muito popular hoje.  Embora voc√™ tamb√©m possa tentar acessar o c√≥digo do aplicativo com a ajuda de backdoors, √© um bom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> no blog do Badoo.  A escolha √© sua. <br><br><h4>  Implementa√ß√£o </h4><br>  Como padr√£o de design, escolhemos o Testing Robots, proposto por Jake Wharton no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">relat√≥rio</a> hom√¥nimo.  A id√©ia dessa abordagem √© semelhante ao padr√£o de design de objeto de p√°gina comum usado no teste de sistemas da web.  A linguagem de programa√ß√£o √© Java. <br><br>  Para cada fragmento independente do aplicativo, √© criada uma classe de rob√¥ especial na qual a l√≥gica de neg√≥cios √© implementada.  A intera√ß√£o com cada elemento do fragmento √© descrita em um m√©todo separado.  Al√©m disso, todas as asser√ß√µes realizadas neste fragmento tamb√©m s√£o descritas aqui. <br><br>  Considere um exemplo simples.  O fragmento descrito cont√©m v√°rios campos para inserir dados e um bot√£o de a√ß√£o: <br><br><img src="https://habrastorage.org/webt/po/-a/il/po-ail1n2mqlusukvegg9ry1tdm.png" alt="imagem"><br><br>  O c√≥digo da funcionalidade de login √© o pr√≥prio teste: <br><br><img src="https://habrastorage.org/webt/s2/ot/sd/s2otsd2q-li_26a9vkx_-s_9__g.png" alt="imagem"><br><br>  Aqui, verificamos o cen√°rio positivo quando os dados de autentica√ß√£o inseridos est√£o corretos.  Os dados em si s√£o submetidos aos testes de entrada ou os valores padr√£o s√£o usados.  Assim, o testador tem a capacidade de parametrizar em termos de dados de teste. <br><br>  Essa estrutura fornece, em primeiro lugar, excelente legibilidade aos testes quando todo o script √© dividido nas principais etapas de execu√ß√£o.  Tamb√©m gostamos muito da ideia de transferir afirma√ß√µes para os m√©todos individuais do rob√¥ correspondente.  A afirma√ß√£o se torna a mesma etapa, sem quebrar a cadeia geral, e seus testes ainda n√£o sabem nada sobre o aplicativo. <br><br>  No relat√≥rio mencionado, Jake Wharton faz uma implementa√ß√£o em Kotlin, onde √© finito.  J√° tentamos em outro projeto e gostamos muito. <br><br><h2>  2. Integra√ß√£o com o sistema de gerenciamento de testes </h2><br>  Antes da introdu√ß√£o da automa√ß√£o, realizamos todos os nossos testes no sistema de gerenciamento de testes TestRail.  A boa not√≠cia foi que existe uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">API TestRail</a> bastante boa, com a qual conseguimos conectar casos de teste j√° estabelecidos no sistema com autotestes. <br><br>  Durante a execu√ß√£o do teste usando o JUnit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RunListener</a> , v√°rios eventos s√£o capturados, como <code>testRunStarted</code> , <code>testFailure</code> , <code>testFinished</code> , nos quais enviamos os resultados para o TestRail.  Se voc√™ usa o AndroidJUnitRunner, ele precisa informar sobre o seu RunListener de uma certa maneira, descrita na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o</a> oficial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">.</a> <br><br>  Voc√™ tamb√©m precisa se comunicar com v√°rias entidades do TestRail por seu ID.  Portanto, para conectar o teste ao caso de teste correspondente, criamos uma anota√ß√£o simples <code>@CaseId</code> , cujo uso √© mostrado no exemplo de implementa√ß√£o de teste acima. <br><br>  C√≥digo para implementar a anota√ß√£o em si: <br><br><img src="https://habrastorage.org/webt/oq/pz/2m/oqpz2mc9f_lfnujvzaj2ohpuicc.png" alt="imagem"><br><br>  Resta apenas obter seu valor no lugar certo a partir de Descri√ß√£o: <br><br><img src="https://habrastorage.org/webt/4h/bb/wa/4hbbwa2srlfwol2yies25mm07a8.png" alt="imagem"><br><br><h2>  3. In√≠cio manual de autotestes em dispositivos na nuvem </h2><br><h4>  Parametriza√ß√£o de inicializa√ß√£o no trabalho Jenkins </h4><br>  Para organizar o in√≠cio manual dos autotestes, usamos o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">trabalho Jenkins de estilo livre</a> .  Essa op√ß√£o foi escolhida porque a empresa j√° possu√≠a alguma experi√™ncia com trabalhos semelhantes com a Jenkins Job em outras √°reas, em particular com os engenheiros do DevOps, que eles compartilharam com prazer. <br><br>  O trabalho de Jenkins executa um script com base nos dados transferidos da interface da web.  Assim, a parametriza√ß√£o das execu√ß√µes de teste √© implementada.  No nosso caso, o script Bash inicia o lan√ßamento de testes nos dispositivos em nuvem do Firebase. <br><br>  A parametriza√ß√£o inclui: <br><br><ul><li>  Selecionando o APK desejado, especificando o n√∫mero da compila√ß√£o correspondente ou fazendo o download manualmente. </li><li>  Digite todos os tipos de dados de teste. </li><li>  Inserindo dados personalizados adicionais para TestRail. </li><li>  Selecione dispositivos f√≠sicos baseados na nuvem nos quais os testes ser√£o executados na lista dispon√≠vel no Firebase Test Lab. </li><li>  A sele√ß√£o de kits de teste a serem realizados. </li></ul><br>  Vejamos uma parte da p√°gina da Web do nosso trabalho Jenkins usando um exemplo de uma interface de sele√ß√£o de dispositivo e su√≠tes de teste: <br><br><img src="https://habrastorage.org/webt/lm/d9/_p/lmd9_pih-p4lu5i_7gd6d2rcazc.png" alt="imagem"><br><br>  Cada elemento em que voc√™ pode inserir ou selecionar qualquer dado √© implementado por plugins Jenkins especiais.  Por exemplo, a interface de sele√ß√£o de dispositivo √© feita usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">plug-in de op√ß√µes ativas</a> .  Usando um script groovy do Firebase, √© obtida uma lista de dispositivos dispon√≠veis, que s√£o exibidos no formul√°rio desejado na p√°gina da web. <br><br>  Ap√≥s a inser√ß√£o de todos os dados necess√°rios, o script correspondente √© iniciado, cujo progresso podemos observar na se√ß√£o Sa√≠da do console: <br><br><img src="https://habrastorage.org/webt/vo/ie/ul/voieulwwrlhexdhsxpw2wwg-qga.png" alt="imagem"><br><br>  A partir daqui, o testador que iniciou a execu√ß√£o do teste pode acessar o TestRail ou o console do Firebase usando os URLs recebidos, que cont√™m muitas informa√ß√µes √∫teis sobre a execu√ß√£o de testes em cada um dos dispositivos selecionados. <br><br><h4>  Matriz de teste final no Firebase Test Lab </h4><br>  A matriz do dispositivo no Firebase cont√©m a distribui√ß√£o de testes pelos dispositivos nos quais eles foram executados: <br><br><img src="https://habrastorage.org/webt/um/bs/5w/umbs5w2ehvo69ih127ep8i6ulvo.png" alt="imagem"><br><br>  Para cada dispositivo, voc√™ pode visualizar o registro completo, o v√≠deo da execu√ß√£o do teste, v√°rios indicadores de desempenho.  Al√©m disso, voc√™ pode acessar todos os arquivos que podem ter sido criados durante a execu√ß√£o dos testes.  Usamos isso para baixar indicadores de cobertura de teste do dispositivo. <br><br>  Escolhemos o Firebase, pois j√° usamos esse servi√ßo para solucionar outros problemas e estamos satisfeitos com a pol√≠tica de pre√ßos.  Se voc√™ encontrar 30 minutos de tempo puro para testes por dia, n√£o precisar√° pagar nada.  Esse pode ser um motivo adicional pelo qual √© importante poder executar apenas determinados testes. <br><br>  Voc√™ pode preferir uma infraestrutura de nuvem diferente que tamb√©m se adapte bem ao seu processo de teste. <br><br><h2>  4. Reutiliza√ß√£o </h2><br>  Como tudo isso pode ser usado no futuro?  Do ponto de vista da base de c√≥digo, esta solu√ß√£o √© aplic√°vel apenas a aplicativos Android.  Por exemplo, durante a implementa√ß√£o, adicionamos as classes auxiliares <code>EspressoExtensions</code> e <code>UiAutomatorExtensions</code> , nas quais encapsulamos v√°rias op√ß√µes para interagir com a interface e aguardamos que os elementos estejam prontos.  Isso tamb√©m inclui a classe RunListener, respons√°vel pela integra√ß√£o com o TestRail.  J√° os colocamos em m√≥dulos separados e os usamos para automatizar outros aplicativos. <br><br>  Se falamos de outras plataformas, a experi√™ncia adquirida pode ser muito √∫til para criar e implementar processos semelhantes.  Estamos fazendo isso ativamente na √°rea do iOS e estamos pensando no Windows. <br><br><h2>  Conclus√£o </h2><br>  Existem muitas op√ß√µes para implementar e usar a automa√ß√£o de teste.  Entendemos que a automa√ß√£o √© principalmente uma ferramenta projetada para facilitar o processo tradicional de teste "humano" e n√£o para erradic√°-lo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt434252/">https://habr.com/ru/post/pt434252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt434236/index.html">A rede neural com uma ameba resolveu o problema do vendedor ambulante em 8 cidades</a></li>
<li><a href="../pt434238/index.html">Intel OpenVINO no Raspberry Pi: colheita de 2018</a></li>
<li><a href="../pt434244/index.html">Sou comerciante de algo da m√£e: procurando estruturas gratuitas para testar hip√≥teses e iniciar no modo de batalha (Python)</a></li>
<li><a href="../pt434246/index.html">Apple confirma que iPad Pro √© ligeiramente curvado, mas diz que est√° tudo bem</a></li>
<li><a href="../pt434250/index.html">2019 tend√™ncias de seguran√ßa de rede</a></li>
<li><a href="../pt434254/index.html">Perseguindo o melhor</a></li>
<li><a href="../pt434258/index.html">Est√°gio de inverno para desenvolvedores m√≥veis na Redmadrobot</a></li>
<li><a href="../pt434260/index.html">Microsoft realiza concurso de agente AI no Minecraft</a></li>
<li><a href="../pt434262/index.html">Escrevendo e compilando um √°lbum para Linux (Ubuntu 16.04, Ardour, Hydrogen, Kontakt)</a></li>
<li><a href="../pt434264/index.html">Intel ‚ùÑ 2018. Resultados do ano</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>