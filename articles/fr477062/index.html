<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òùüèø üßúüèº üèÇüèº Fonctionnement du compilateur d'optimisation üßòüèæ üë®‚Äç‚öïÔ∏è ‚¨ÖÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'optimisation des compilateurs est la base des logiciels modernes: ils permettent aux programmeurs d'√©crire du code dans un langage qu'ils comprennen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fonctionnement du compilateur d'optimisation</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/477062/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/uc/uq/bo/ucuqbo4tluzynnptop1pdmdvjhc.jpeg"></div><br>  L'optimisation des compilateurs est la base des logiciels modernes: ils permettent aux programmeurs d'√©crire du code dans un langage qu'ils comprennent, puis de le convertir en code qui peut √™tre ex√©cut√© efficacement par l'√©quipement.  L'optimisation des compilateurs consiste √† comprendre ce que fait le programme d'entr√©e que vous avez √©crit et √† cr√©er un programme de sortie qui fait la m√™me chose, mais plus rapidement. <br><br>  Dans cet article, nous examinerons certaines des techniques d'inf√©rence de base dans l'optimisation des compilateurs: comment concevoir un programme avec lequel le compilateur peut facilement travailler;  quelles r√©ductions peuvent √™tre faites dans votre programme et comment les utiliser pour le r√©duire et l'acc√©l√©rer. <br><a name="habracut"></a><br>  Les optimiseurs de programme peuvent fonctionner n'importe o√π: dans le cadre d'un processus de compilation important ( <a href="https://www.lightbend.com/blog/scala-inliner-optimizer">Scala Optimizer</a> );  en tant que programme distinct, lanc√© apr√®s le compilateur et avant ex√©cution ( <a href="https://www.guardsquare.com/en/products/proguard">Proguard</a> );  ou dans le cadre d'un environnement d'ex√©cution qui optimise un programme lors de son ex√©cution ( <a href="https://aboullaite.me/understanding-jit-compiler-just-in-time-compiler/">compilateur JVM JIT</a> ).  Les limitations dans le travail des optimiseurs varient selon la situation, mais ils ont une t√¢che: prendre le programme d'entr√©e et le convertir en celui de sortie, ce qui fait la m√™me chose, mais plus rapidement. <br><br>  Tout d'abord, nous allons examiner quelques exemples d'optimisations pour le projet de programme afin que vous compreniez ce que les optimiseurs font habituellement et comment le faire manuellement.  Ensuite, nous examinerons plusieurs fa√ßons de pr√©senter les programmes, et enfin nous analyserons les algorithmes et les techniques avec lesquels vous pouvez analyser les programmes, puis les rendre plus petits et plus rapides. <br><br><h2>  Projet de programme </h2><br>  Tous les exemples seront donn√©s en Java.  Ce langage est tr√®s courant et se compile en un assembleur relativement simple - <a href="https://en.wikipedia.org/wiki/Java_bytecode">Java Bytecode</a> .  Nous allons donc cr√©er une bonne base, gr√¢ce √† laquelle nous pouvons explorer des techniques d'optimisation de la compilation √† l'aide d'exemples r√©els et ex√©cutables.  Toutes les techniques d√©crites ci-dessous sont applicables dans presque tous les autres langages de programmation. <br><br>  Examinons d'abord un projet de programme.  Il contient diverses logiques, enregistre le r√©sultat standard dans le processus et renvoie le r√©sultat calcul√©.  Le programme lui-m√™me n'a pas de sens, mais sera utilis√© comme illustration de ce qui peut √™tre optimis√© tout en conservant le comportement existant: <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>, total = <span class="hljs-number"><span class="hljs-number">0</span></span>, multiplied = <span class="hljs-number"><span class="hljs-number">0</span></span>; Logger logger = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrintLogger(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(count &lt; n){ count += <span class="hljs-number"><span class="hljs-number">1</span></span>; multiplied *= count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (multiplied &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>) logger.log(count); total += ackermann(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); total += ackermann(multiplied, n); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d1 = ackermann(n, <span class="hljs-number"><span class="hljs-number">1</span></span>); total += d1 * multiplied; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d2 = ackermann(n, count); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) total += d2; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total; } <span class="hljs-comment"><span class="hljs-comment">// https://en.wikipedia.org/wiki/Ackermann_function static int ackermann(int m, int n){ if (m == 0) return n + 1; else if (n == 0) return ackermann(m - 1, 1); else return ackermann(m - 1, ackermann(m, n - 1)); } interface Logger{ public Logger log(Object a); } static class PrintLogger implements Logger{ public PrintLogger log(Object a){ System.out.println(a); return this; } } static class ErrLogger implements Logger{ public ErrLogger log(Object a){ System.err.println(a); return this; } }</span></span></code> </pre> <br>  Pour l'instant, nous supposons que ce programme est tout ce que nous avons, aucune autre partie du code ne l'appelle.  Il saisit simplement les donn√©es dans <code>main</code> , l'ex√©cute et renvoie le r√©sultat.  Maintenant, optimisons ce programme. <br><br><h2>  Exemples d'optimisation </h2><br><h4>  Type coul√©e et inlining </h4><br>  Vous avez peut-√™tre remarqu√© que la variable de l' <code>logger</code> a un type inexact: malgr√© l'√©tiquette de l' <code>Logger</code> , bas√©e sur le code, nous pouvons conclure qu'il s'agit d'une sous-classe sp√©cifique - <code>PrintLogger</code> : <br><br><pre> <code class="java hljs">- Logger logger = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrintLogger(); + PrintLogger logger = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrintLogger();</code> </pre> <br>  Nous savons maintenant que <code>logger</code> est <code>PrintLogger</code> et nous savons que l'appel √† <code>logger.log</code> peut avoir une seule impl√©mentation.  Vous pouvez incorporer: <br><br><pre> <code class="java hljs">- <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (multiplied &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>) logger.logcount(); + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (multiplied &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>) System.out.println(count);</code> </pre> <br>  Cela r√©duira le programme en supprimant la classe <code>ErrLogger</code> inutile, qui n'est pas utilis√©e, ainsi qu'en supprimant diverses m√©thodes du <code>log</code> <code>public Logger</code> , car nous l'int√©grons au m√™me endroit de l'appel. <br><br><h2>  Constantes de coagulation </h2><br>  Pendant l'ex√©cution du programme, le <code>count</code> et <code>total</code> changement <code>total</code> , mais pas <code>multiplied</code> : il commence √† <code>0</code> et est multipli√© √† chaque fois par <code>multiplied = multiplied * count</code> , restant √©gal √† <code>0</code> .  Vous pouvez donc le remplacer dans tout le programme par <code>0</code> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ - <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>, total = <span class="hljs-number"><span class="hljs-number">0</span></span>, multiplied = <span class="hljs-number"><span class="hljs-number">0</span></span>; + <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>, total = <span class="hljs-number"><span class="hljs-number">0</span></span>; PrintLogger logger = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrintLogger(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(count &lt; n){ count += <span class="hljs-number"><span class="hljs-number">1</span></span>; - multiplied *= count; - <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (multiplied &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>) System.out.println(count); + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>) logger.log(count); total += ackermann(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); - total += ackermann(multiplied, n); + total += ackermann(<span class="hljs-number"><span class="hljs-number">0</span></span>, n); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d1 = ackermann(n, <span class="hljs-number"><span class="hljs-number">1</span></span>); - total += d1 * multiplied; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d2 = ackermann(n, count); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) total += d2; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total; }</code> </pre> <br>  En cons√©quence, nous voyons que <code>d1 * multiplied</code> toujours <code>0</code> , ce qui signifie que le <code>total += d1 * multiplied</code> ne fait rien et peut √™tre supprim√©: <br><br><pre> <code class="java hljs">- total += d1 * multiplied</code> </pre><br><h4>  Suppression du code mort </h4><br>  Apr√®s avoir pli√© <code>multiplied</code> et r√©alis√© que le <code>total += d1 * multiplied</code> ne fait rien, vous pouvez supprimer la d√©finition de <code>int d1</code> : <br><br><pre> <code class="java hljs">- <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d1 = ackermann(n, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Cela ne fait plus partie du programme, et comme <code>ackermann</code> est une fonction pure, la d√©sinstallation n'affectera pas le r√©sultat du programme. <br><br>  De m√™me, apr√®s avoir ins√©r√© <code>logger.log</code> , l' <code>logger</code> lui-m√™me n'est plus utilis√© et peut √™tre supprim√©: <br><br><pre> <code class="java hljs">- PrintLogger logger = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrintLogger();</code> </pre><br><h4>  Suppression de branche </h4><br>  Maintenant, la premi√®re transition conditionnelle de notre cycle d√©pend de <code>0 &lt; 100</code> .  Comme cela est toujours vrai, vous pouvez simplement supprimer la condition: <br><br><pre> <code class="java hljs">- <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>) System.out.println(count); + System.out.println(count);</code> </pre> <br>  Toute transition conditionnelle toujours vraie peut √™tre ins√©r√©e dans le corps de la condition, et pour les transitions toujours incorrectes, vous pouvez supprimer la condition avec son corps. <br><br><h4>  Calcul partiel </h4><br>  Nous analysons maintenant les trois appels restants √† <code>ackermann</code> : <br><br><pre> <code class="java hljs"> total += ackermann(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); total += ackermann(<span class="hljs-number"><span class="hljs-number">0</span></span>, n); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d2 = ackermann(n, count);</code> </pre><br><ul><li>  Le premier a deux arguments constants.  La fonction est pure, et lors du calcul pr√©liminaire, <code>ackermann(2, 2)</code> doit √™tre √©gal √† <code>7.</code> </li><li>  Le deuxi√®me appel a un argument constant <code>0</code> et un <code>n</code> inconnu.  Vous pouvez le passer √† la d√©finition de <code>ackermann</code> , et il s'av√®re que lorsque <code>m</code> est <code>0</code> , la fonction retourne toujours <code>n + 1.</code> <br></li><li>  Dans le troisi√®me appel, les deux arguments sont inconnus: <code>n</code> et <code>count</code> .  Laissons-les en place pour l'instant. <br></li></ul><br>  √âtant donn√© que l'appel √† <code>ackermann</code> est d√©fini comme suit: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ackermann</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermann(m - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermann(m - <span class="hljs-number"><span class="hljs-number">1</span></span>, ackermann(m, n - <span class="hljs-number"><span class="hljs-number">1</span></span>)); }</code> </pre> <br>  Vous pouvez le simplifier pour: <br><br><pre> <code class="java hljs">- total += ackermann(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); + total += <span class="hljs-number"><span class="hljs-number">7</span></span> - total += ackermann(<span class="hljs-number"><span class="hljs-number">0</span></span>, n); + total += n + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d2 = ackermann(n, count);</code> </pre><br><h4>  Planification tardive </h4><br>  La d√©finition de <code>d2</code> utilis√©e que dans le <code>if (count % 2 == 0)</code> conditionnel <code>if (count % 2 == 0)</code> .  √âtant donn√© que le calcul <code>ackermann</code> est propre, vous pouvez transf√©rer cet appel vers une <code>ackermann</code> conditionnelle afin qu'il ne soit trait√© que lorsqu'il est utilis√©: <br><br><pre> <code class="java hljs">- <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d2 = ackermann(n, count); - <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) total += d2; + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d2 = ackermann(n, count); + total += d2; + }</code> </pre> <br>  Cela √©vitera la moiti√© des appels √† <code>ackermann(n, count)</code> , acc√©l√©rant ainsi l'ex√©cution du programme. <br><br>  √Ä titre de comparaison, la fonction <code>System.out.println</code> n'est pas propre, ce qui signifie qu'elle ne peut pas √™tre transf√©r√©e √† l'int√©rieur ou √† l'ext√©rieur des sauts conditionnels sans modifier la s√©mantique du programme. <br><br><h2>  R√©sultat optimis√© </h2><br>  Apr√®s avoir collect√© toutes les optimisations, nous obtenons le code source suivant: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>, total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(count &lt; n){ count += <span class="hljs-number"><span class="hljs-number">1</span></span>; System.out.println(count); total += <span class="hljs-number"><span class="hljs-number">7</span></span>; total += n + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) { total += d2; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d2 = ackermann(n, count); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ackermann</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermann(m - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermann(m - <span class="hljs-number"><span class="hljs-number">1</span></span>, ackermann(m, n - <span class="hljs-number"><span class="hljs-number">1</span></span>)); }</code> </pre> <br>  Bien que nous ayons optimis√© manuellement, tout cela peut se faire automatiquement.  Voici le r√©sultat d√©compil√© de l'optimiseur de prototype que j'ai √©crit pour les programmes JVM: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> var0)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Demo.PrintLogger(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> var1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> var3; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> var2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; var2 &lt; var0; var2 = var3) { System.out.println(var3 = <span class="hljs-number"><span class="hljs-number">1</span></span> + var2); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> var10000 = var3 % <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> var7 = var1 + <span class="hljs-number"><span class="hljs-number">7</span></span> + var0 + <span class="hljs-number"><span class="hljs-number">1</span></span>; var1 = var10000 == <span class="hljs-number"><span class="hljs-number">0</span></span> ? var7 + ackermann(var0, var3) : var7; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> var1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ackermann__I__TI1__I</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> var0)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (var0 == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermann(var0 - <span class="hljs-number"><span class="hljs-number">1</span></span>, var0 == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span> : ackermann__I__TI1__I(var0 - <span class="hljs-number"><span class="hljs-number">1</span></span>);); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ackermann</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> var0, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> var1)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (var0 == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> var1 + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> var1 == <span class="hljs-number"><span class="hljs-number">0</span></span> ? ackermann__I__TI1__I(var0 - <span class="hljs-number"><span class="hljs-number">1</span></span>) : ackermann(var0 - <span class="hljs-number"><span class="hljs-number">1</span></span>, ackermann(var0, var1 - <span class="hljs-number"><span class="hljs-number">1</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrintLogger</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre> <br>  Le code d√©compil√© est l√©g√®rement diff√©rent de la version optimis√©e manuellement.  Quelque chose que le compilateur n'a pas pu optimiser (par exemple, un appel inutilis√© √† <code>new PrintLogger</code> ), mais quelque chose a √©t√© fait un peu diff√©remment (par exemple, <code>ackermann</code> et <code>ackermann__I__TI1__I</code> ).  Mais pour le reste, l'optimiseur automatique a fait la m√™me chose que moi, en utilisant la logique int√©gr√©e. <br><br>  La question se pose: comment? <br><br><h2>  Vues interm√©diaires </h2><br>  Si vous essayez de cr√©er votre propre optimiseur, la premi√®re question qui se posera sera peut-√™tre la plus importante: qu'est-ce qu'un ¬´programme¬ª? <br><br>  Sans aucun doute, vous avez l'habitude d'√©crire et de modifier des programmes sous forme de code source.  Vous les avez certainement ex√©cut√©s sous forme de binaires compil√©s, peut-√™tre m√™me d√©bogu√© les binaires.  Vous avez peut-√™tre rencontr√© des programmes sous la forme d'une <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B1%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B0%25D0%25BA%25D1%2581%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">arborescence de syntaxe</a> , d'un <a href="https://en.wikipedia.org/wiki/Three-address_code">code √† trois adresses</a> , d'un <a href="https://en.wikipedia.org/wiki/A-normal_form">A-Normal</a> , d'un <a href="https://en.wikipedia.org/wiki/Continuation-passing_style">style de passage continu</a> ou d' <a href="https://ru.wikipedia.org/wiki/SSA">une affectation statique unique</a> . <br><br>  Il y a tout un zoo de diff√©rentes repr√©sentations de programmes.  Ici, nous allons discuter des fa√ßons les plus importantes de repr√©senter un ¬´programme¬ª √† l'int√©rieur de l'optimiseur. <br><br><h2>  Code source </h2><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ackermann</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermann(m - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermann(m - <span class="hljs-number"><span class="hljs-number">1</span></span>, ackermann(m, n - <span class="hljs-number"><span class="hljs-number">1</span></span>)); }</code> </pre> <br>  Le code source non compil√© est √©galement une repr√©sentation de votre programme.  Il est relativement compact, lisible par l'homme, mais il pr√©sente deux inconv√©nients: <br><br><ul><li>  Le code source contient tous les d√©tails des noms et du formatage, qui sont importants pour le programmeur, mais inutiles pour l'ordinateur. <br></li><li>  Il y a beaucoup plus de programmes erron√©s sous forme de code source que de programmes corrects, et pendant l'optimisation, vous devez vous assurer que votre programme est converti du code source d'entr√©e correct au code source de sortie correct. <br></li></ul><br>  Ces facteurs rendent difficile pour l'optimiseur de travailler avec le programme sous forme de code source.  Oui, vous <i>pouvez</i> convertir un tel programme, par exemple, en utilisant <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B3%25D1%2583%25D0%25BB%25D1%258F%25D1%2580%25D0%25BD%25D1%258B%25D0%25B5_%25D0%25B2%25D1%258B%25D1%2580%25D0%25B0%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">des expressions r√©guli√®res pour</a> identifier et remplacer des mod√®les.  Cependant, le premier des deux facteurs rend difficile l'identification fiable de mod√®les avec une abondance de d√©tails √©trangers.  Et le deuxi√®me facteur augmente consid√©rablement les risques de confusion et d'obtenir un programme r√©sultant incorrect. <br><br>  Ces restrictions sont acceptables pour les convertisseurs de programme ex√©cut√©s sous supervision humaine, par exemple, lorsque vous pouvez utiliser <a href="https://github.com/facebook/codemod">Codemod</a> pour refactoriser et transformer la base de code.  Cependant, vous ne pouvez pas utiliser le code source comme mod√®le principal d'un optimiseur automatis√©. <br><br><h2>  Arbres de syntaxe abstraite </h2><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ackermann</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermann(m - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermann(m - <span class="hljs-number"><span class="hljs-number">1</span></span>, ackermann(m, n - <span class="hljs-number"><span class="hljs-number">1</span></span>)); } IfElse( cond = BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"m"</span></span>), <span class="hljs-string"><span class="hljs-string">"="</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">0</span></span>)), then = Return(BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"n"</span></span>), <span class="hljs-string"><span class="hljs-string">"+"</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> = IfElse( cond = BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"n"</span></span>), <span class="hljs-string"><span class="hljs-string">"="</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">0</span></span>)), then = Return(Call(<span class="hljs-string"><span class="hljs-string">"ackermann"</span></span>, BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"m"</span></span>), <span class="hljs-string"><span class="hljs-string">"-"</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>)), Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> = Return( Call( <span class="hljs-string"><span class="hljs-string">"ackermann"</span></span>, BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"m"</span></span>), <span class="hljs-string"><span class="hljs-string">"-"</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>)), Call(<span class="hljs-string"><span class="hljs-string">"ackermann"</span></span>, Ident(<span class="hljs-string"><span class="hljs-string">"m"</span></span>), BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"n"</span></span>), <span class="hljs-string"><span class="hljs-string">"-"</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>))) ) ) ) )</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/e01/019/324/e0101932411807ddb7abb9c120033f58.png"><br><br>  Les arbres de syntaxe abstraite (AST) sont un autre format interm√©diaire commun.  Ils sont situ√©s √† l'√©tape suivante de l'√©chelle d'abstraction par rapport au code source.  En r√®gle g√©n√©rale, AST ignore la mise en forme, l'indentation et les commentaires du code source, mais conserve les noms des variables locales qui sont ignor√©es dans les repr√©sentations plus abstraites. <br><br>  Comme le code source, AST souffre de la possibilit√© d'encoder des informations inutiles qui n'affectent pas la s√©mantique r√©elle du programme.  Par exemple, les deux fragments de code suivants sont s√©mantiquement identiques;  ils ne diff√®rent que par le nom des variables locales, mais ont toujours des AST diff√©rents: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ackermannA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> p = n; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = m; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (q == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermannA(q - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermannA(q - <span class="hljs-number"><span class="hljs-number">1</span></span>, ackermannA(q, p - <span class="hljs-number"><span class="hljs-number">1</span></span>)); } Block( Assign(<span class="hljs-string"><span class="hljs-string">"p"</span></span>, Ident(<span class="hljs-string"><span class="hljs-string">"n"</span></span>)), Assign(<span class="hljs-string"><span class="hljs-string">"q"</span></span>, Ident(<span class="hljs-string"><span class="hljs-string">"m"</span></span>)), IfElse( cond = BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"q"</span></span>), <span class="hljs-string"><span class="hljs-string">"=="</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">0</span></span>)), then = Return(BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"p"</span></span>), <span class="hljs-string"><span class="hljs-string">"+"</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> = IfElse( cond = BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"p"</span></span>), <span class="hljs-string"><span class="hljs-string">"=="</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">0</span></span>)), then = Return(Call(<span class="hljs-string"><span class="hljs-string">"ackermann"</span></span>, BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"q"</span></span>), <span class="hljs-string"><span class="hljs-string">"-"</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>)), Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> = Return( Call( <span class="hljs-string"><span class="hljs-string">"ackermann"</span></span>, BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"q"</span></span>), <span class="hljs-string"><span class="hljs-string">"-"</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>)), Call(<span class="hljs-string"><span class="hljs-string">"ackermann"</span></span>, Ident(<span class="hljs-string"><span class="hljs-string">"q"</span></span>), BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"p"</span></span>), <span class="hljs-string"><span class="hljs-string">"-"</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>))) ) ) ) ) ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ackermannB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = n; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s = m; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermannB(s - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermannB(s - <span class="hljs-number"><span class="hljs-number">1</span></span>, ackermannB(s, r - <span class="hljs-number"><span class="hljs-number">1</span></span>)); } Block( Assign(<span class="hljs-string"><span class="hljs-string">"r"</span></span>, Ident(<span class="hljs-string"><span class="hljs-string">"n"</span></span>)), Assign(<span class="hljs-string"><span class="hljs-string">"s"</span></span>, Ident(<span class="hljs-string"><span class="hljs-string">"m"</span></span>)), IfElse( cond = BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"s"</span></span>), <span class="hljs-string"><span class="hljs-string">"=="</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">0</span></span>)), then = Return(BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"r"</span></span>), <span class="hljs-string"><span class="hljs-string">"+"</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> = IfElse( cond = BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"r"</span></span>), <span class="hljs-string"><span class="hljs-string">"=="</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">0</span></span>)), then = Return(Call(<span class="hljs-string"><span class="hljs-string">"ackermann"</span></span>, BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"s"</span></span>), <span class="hljs-string"><span class="hljs-string">"-"</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>)), Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> = Return( Call( <span class="hljs-string"><span class="hljs-string">"ackermann"</span></span>, BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"s"</span></span>), <span class="hljs-string"><span class="hljs-string">"-"</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>)), Call(<span class="hljs-string"><span class="hljs-string">"ackermann"</span></span>, Ident(<span class="hljs-string"><span class="hljs-string">"s"</span></span>), BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"r"</span></span>), <span class="hljs-string"><span class="hljs-string">"-"</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>))) ) ) ) ) )</code> </pre> <br>  Le point cl√© est que, bien que les AST aient une structure arborescente, ils contiennent des n≈ìuds qui se comportent s√©mantiquement pas comme des arbres: les valeurs de <code>Ident("r")</code> et <code>Ident("s")</code> d√©termin√©es non pas par le contenu de leurs sous-arbres, mais par les n≈ìuds <code>Assign("r", ...)</code> node <code>Assign("r", ...)</code> amont) <code>Assign("r", ...)</code> et <code>Assign("s", ...)</code> .  En fait, il existe des relations s√©mantiques suppl√©mentaires entre les <code>Ident</code> et les <code>Assign</code> qui sont tout aussi importantes que les ar√™tes dans la structure arborescente AST: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a17/62a/9a0/a1762a9a0a21d0b0e4fac6afb4f23335.png"><br><br>  Ces connexions forment une structure graphique g√©n√©ralis√©e, comprenant des cycles en pr√©sence de d√©finitions r√©cursives de fonctions. <br><br><h2>  Bytecode </h2><br>  Depuis que nous avons choisi Java comme langue principale, les programmes compil√©s sont enregistr√©s en tant que bytecode Java dans des fichiers .class. <br><br>  Rappelons notre fonction <code>ackermann</code> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ackermann</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermann(m - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermann(m - <span class="hljs-number"><span class="hljs-number">1</span></span>, ackermann(m, n - <span class="hljs-number"><span class="hljs-number">1</span></span>)); }</code> </pre> <br>  Il compile ce bytecode: <br><br><pre> <code class="java hljs"> <span class="hljs-number"><span class="hljs-number">0</span></span>: iload_0 <span class="hljs-number"><span class="hljs-number">1</span></span>: ifne <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: iload_1 <span class="hljs-number"><span class="hljs-number">5</span></span>: iconst_1 <span class="hljs-number"><span class="hljs-number">6</span></span>: iadd <span class="hljs-number"><span class="hljs-number">7</span></span>: ireturn <span class="hljs-number"><span class="hljs-number">8</span></span>: iload_1 <span class="hljs-number"><span class="hljs-number">9</span></span>: ifne <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span>: iload_0 <span class="hljs-number"><span class="hljs-number">13</span></span>: iconst_1 <span class="hljs-number"><span class="hljs-number">14</span></span>: isub <span class="hljs-number"><span class="hljs-number">15</span></span>: iconst_1 <span class="hljs-number"><span class="hljs-number">16</span></span>: invokestatic ackermann:(II)I <span class="hljs-number"><span class="hljs-number">19</span></span>: ireturn <span class="hljs-number"><span class="hljs-number">20</span></span>: iload_0 <span class="hljs-number"><span class="hljs-number">21</span></span>: iconst_1 <span class="hljs-number"><span class="hljs-number">22</span></span>: isub <span class="hljs-number"><span class="hljs-number">23</span></span>: iload_0 <span class="hljs-number"><span class="hljs-number">24</span></span>: iload_1 <span class="hljs-number"><span class="hljs-number">25</span></span>: iconst_1 <span class="hljs-number"><span class="hljs-number">26</span></span>: isub <span class="hljs-number"><span class="hljs-number">27</span></span>: invokestatic ackermann:(II)I <span class="hljs-number"><span class="hljs-number">30</span></span>: invokestatic ackermann:(II)I <span class="hljs-number"><span class="hljs-number">33</span></span>: ireturn</code> </pre> <br>  La machine virtuelle Java (JVM), qui ex√©cute le bytecode Java, est une machine avec une combinaison d'une pile et de registres: il y a une pile d'op√©randes (STACK) dans laquelle les valeurs sont manipul√©es et un tableau de variables locales (LOCALS) dans lesquelles ces valeurs peuvent √™tre stock√©es.  La fonction d√©marre avec N param√®tres dans les N premiers intervalles de variables locales.  Lors de son ex√©cution, la fonction d√©place les donn√©es sur la pile, les op√®re, les replace dans des variables, appelant <code>return</code> pour renvoyer la valeur √† l'appelant √† partir de la pile d'op√©randes. <br><br>  Si vous annotez le bytecode ci-dessus pour repr√©senter les valeurs qui se d√©placent entre la pile et la table de variables locale, cela ressemblera √† ceci: <br><br><pre> <code class="java hljs"> BYTECODE LOCALS STACK |a0|a1| | <span class="hljs-number"><span class="hljs-number">0</span></span>: iload_0 |a0|a1| |a0| <span class="hljs-number"><span class="hljs-number">1</span></span>: ifne <span class="hljs-number"><span class="hljs-number">8</span></span> |a0|a1| | <span class="hljs-number"><span class="hljs-number">4</span></span>: iload_1 |a0|a1| |a1| <span class="hljs-number"><span class="hljs-number">5</span></span>: iconst_1 |a0|a1| |a1| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">6</span></span>: iadd |a0|a1| |v1| <span class="hljs-number"><span class="hljs-number">7</span></span>: ireturn |a0|a1| | <span class="hljs-number"><span class="hljs-number">8</span></span>: iload_1 |a0|a1| |a1| <span class="hljs-number"><span class="hljs-number">9</span></span>: ifne <span class="hljs-number"><span class="hljs-number">20</span></span> |a0|a1| | <span class="hljs-number"><span class="hljs-number">12</span></span>: iload_0 |a0|a1| |a0| <span class="hljs-number"><span class="hljs-number">13</span></span>: iconst_1 |a0|a1| |a0| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">14</span></span>: isub |a0|a1| |v2| <span class="hljs-number"><span class="hljs-number">15</span></span>: iconst_1 |a0|a1| |v2| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">16</span></span>: invokestatic ackermann:(II)I |a0|a1| |v3| <span class="hljs-number"><span class="hljs-number">19</span></span>: ireturn |a0|a1| | <span class="hljs-number"><span class="hljs-number">20</span></span>: iload_0 |a0|a1| |a0| <span class="hljs-number"><span class="hljs-number">21</span></span>: iconst_1 |a0|a1| |a0| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">22</span></span>: isub |a0|a1| |v4| <span class="hljs-number"><span class="hljs-number">23</span></span>: iload_0 |a0|a1| |v4|a0| <span class="hljs-number"><span class="hljs-number">24</span></span>: iload_1 |a0|a1| |v4|a0|a1| <span class="hljs-number"><span class="hljs-number">25</span></span>: iconst_1 |a0|a1| |v4|a0|a1| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">26</span></span>: isub |a0|a1| |v4|a0|v5| <span class="hljs-number"><span class="hljs-number">27</span></span>: invokestatic ackermann:(II)I |a0|a1| |v4|v6| <span class="hljs-number"><span class="hljs-number">30</span></span>: invokestatic ackermann:(II)I |a0|a1| |v7| <span class="hljs-number"><span class="hljs-number">33</span></span>: ireturn |a0|a1| |</code> </pre> <br>  Ici, en utilisant <code>a0</code> et <code>a1</code> pr√©sent√© les arguments de la fonction, qui sont stock√©s dans la table LOCALS au tout d√©but de la fonction.  <code>1</code> repr√©sente les constantes charg√©es via <code>iconst_1</code> , et de <code>v1</code> √† <code>v7</code> , les valeurs interm√©diaires calcul√©es.  Il y a trois instructions <code>ireturn</code> retournant <code>v1</code> , <code>v3</code> et <code>v7</code> .  Cette fonction ne d√©finit pas d'autres variables locales, donc le tableau LOCALS stocke uniquement les arguments d'entr√©e. <br><br>  Ci-dessus, nous avons vu deux variantes de notre fonction - <code>ackermannA</code> et <code>ackermannB</code> .  Ils regardent donc en bytecode: <br><br><pre> <code class="java hljs"> BYTECODE LOCALS STACK |a0|a1| | <span class="hljs-number"><span class="hljs-number">0</span></span>: iload_1 |a0|a1| |a1| <span class="hljs-number"><span class="hljs-number">1</span></span>: istore_2 |a0|a1|a1| | <span class="hljs-number"><span class="hljs-number">2</span></span>: iload_0 |a0|a1|a1| |a0| <span class="hljs-number"><span class="hljs-number">3</span></span>: istore_3 |a0|a1|a1|a0| | <span class="hljs-number"><span class="hljs-number">4</span></span>: iload_3 |a0|a1|a1|a0| |a0| <span class="hljs-number"><span class="hljs-number">5</span></span>: ifne <span class="hljs-number"><span class="hljs-number">12</span></span> |a0|a1|a1|a0| | <span class="hljs-number"><span class="hljs-number">8</span></span>: iload_2 |a0|a1|a1|a0| |a1| <span class="hljs-number"><span class="hljs-number">9</span></span>: iconst_1 |a0|a1|a1|a0| |a1| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">10</span></span>: iadd |a0|a1|a1|a0| |v1| <span class="hljs-number"><span class="hljs-number">11</span></span>: ireturn |a0|a1|a1|a0| | <span class="hljs-number"><span class="hljs-number">12</span></span>: iload_2 |a0|a1|a1|a0| |a1| <span class="hljs-number"><span class="hljs-number">13</span></span>: ifne <span class="hljs-number"><span class="hljs-number">24</span></span> |a0|a1|a1|a0| | <span class="hljs-number"><span class="hljs-number">16</span></span>: iload_3 |a0|a1|a1|a0| |a0| <span class="hljs-number"><span class="hljs-number">17</span></span>: iconst_1 |a0|a1|a1|a0| |a0| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">18</span></span>: isub |a0|a1|a1|a0| |v2| <span class="hljs-number"><span class="hljs-number">19</span></span>: iconst_1 |a0|a1|a1|a0| |v2| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">20</span></span>: invokestatic ackermannA:(II)I |a0|a1|a1|a0| |v3| <span class="hljs-number"><span class="hljs-number">23</span></span>: ireturn |a0|a1|a1|a0| | <span class="hljs-number"><span class="hljs-number">24</span></span>: iload_3 |a0|a1|a1|a0| |a0| <span class="hljs-number"><span class="hljs-number">25</span></span>: iconst_1 |a0|a1|a1|a0| |a0| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">26</span></span>: isub |a0|a1|a1|a0| |v4| <span class="hljs-number"><span class="hljs-number">27</span></span>: iload_3 |a0|a1|a1|a0| |v4|a0| <span class="hljs-number"><span class="hljs-number">28</span></span>: iload_2 |a0|a1|a1|a0| |v4|a0|a1| <span class="hljs-number"><span class="hljs-number">29</span></span>: iconst_1 |a0|a1|a1|a0| |v4|a0|a1| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">30</span></span>: isub |a0|a1|a1|a0| |v4|a0|v5| <span class="hljs-number"><span class="hljs-number">31</span></span>: invokestatic ackermannA:(II)I |a0|a1|a1|a0| |v4|v6| <span class="hljs-number"><span class="hljs-number">34</span></span>: invokestatic ackermannA:(II)I |a0|a1|a1|a0| |v7| <span class="hljs-number"><span class="hljs-number">37</span></span>: ireturn |a0|a1|a1|a0| |</code> </pre> <br>  √âtant donn√© que le code source prend deux arguments et les place dans des variables locales, le bytecode a les instructions correspondantes pour charger les valeurs d'argument √† partir des index LOCAL 0 et 1 et les enregistrer sous les index 2 et 3. Cependant, le bytecode n'est pas int√©ress√© par les noms de vos variables locales: il fonctionne avec par eux exclusivement comme avec les index du tableau LOCALS.  Par cons√©quent, <code>ackermannA</code> et <code>ackermannB</code> auront des sous- <code>ackermannB</code> identiques.  C'est logique, car ils sont s√©mantiquement √©quivalents! <br><br>  Cependant, <code>ackermannA</code> et <code>ackermannB</code> ne sont pas compil√©s dans le m√™me bytecode que l' <code>ackermann</code> origine: bien que le bytecode soit extrait des noms des variables locales, il n'√©carte toujours pas compl√®tement le chargement et l'enregistrement vers / depuis ces variables.  Il est toujours important pour nous de savoir comment les valeurs se d√©placent le long de LOCALS et STACK, bien qu'elles n'affectent pas le comportement r√©el du programme. <br><br>  En plus de l'absence d'abstraction du chargement / enregistrement, le bytecode a un autre inconv√©nient: comme la plupart des assembleurs lin√©aires, il est tr√®s optimis√© en termes de compacit√©, et il peut √™tre tr√®s difficile de le modifier lorsqu'il s'agit d'optimisations. <br><br>  Pour le rendre plus clair, regardons le bytecode de la fonction <code>ackermann</code> originale: <br><br><pre> <code class="java hljs"> BYTECODE LOCALS STACK |a0|a1| | <span class="hljs-number"><span class="hljs-number">0</span></span>: iload_0 |a0|a1| |a0| <span class="hljs-number"><span class="hljs-number">1</span></span>: ifne <span class="hljs-number"><span class="hljs-number">8</span></span> |a0|a1| | <span class="hljs-number"><span class="hljs-number">4</span></span>: iload_1 |a0|a1| |a1| <span class="hljs-number"><span class="hljs-number">5</span></span>: iconst_1 |a0|a1| |a1| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">6</span></span>: iadd |a0|a1| |v1| <span class="hljs-number"><span class="hljs-number">7</span></span>: ireturn |a0|a1| | <span class="hljs-number"><span class="hljs-number">8</span></span>: iload_1 |a0|a1| |a1| <span class="hljs-number"><span class="hljs-number">9</span></span>: ifne <span class="hljs-number"><span class="hljs-number">20</span></span> |a0|a1| | <span class="hljs-number"><span class="hljs-number">12</span></span>: iload_0 |a0|a1| |a0| <span class="hljs-number"><span class="hljs-number">13</span></span>: iconst_1 |a0|a1| |a0| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">14</span></span>: isub |a0|a1| |v2| <span class="hljs-number"><span class="hljs-number">15</span></span>: iconst_1 |a0|a1| |v2| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">16</span></span>: invokestatic ackermann:(II)I |a0|a1| |v3| <span class="hljs-number"><span class="hljs-number">19</span></span>: ireturn |a0|a1| | <span class="hljs-number"><span class="hljs-number">20</span></span>: iload_0 |a0|a1| |a0| <span class="hljs-number"><span class="hljs-number">21</span></span>: iconst_1 |a0|a1| |a0| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">22</span></span>: isub |a0|a1| |v4| <span class="hljs-number"><span class="hljs-number">23</span></span>: iload_0 |a0|a1| |v4|a0| <span class="hljs-number"><span class="hljs-number">24</span></span>: iload_1 |a0|a1| |v4|a0|a1| <span class="hljs-number"><span class="hljs-number">25</span></span>: iconst_1 |a0|a1| |v4|a0|a1| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">26</span></span>: isub |a0|a1| |v4|a0|v5| <span class="hljs-number"><span class="hljs-number">27</span></span>: invokestatic ackermann:(II)I |a0|a1| |v4|v6| <span class="hljs-number"><span class="hljs-number">30</span></span>: invokestatic ackermann:(II)I |a0|a1| |v7| <span class="hljs-number"><span class="hljs-number">33</span></span>: ireturn |a0|a1| |</code> </pre> <br>  Faisons un changement approximatif: que la fonction appelle <code>30: invokestatic ackermann:(II)I</code> n'utilise pas son premier argument.  Et puis cet appel peut √™tre remplac√© par l'appel √©quivalent <code>30: invokestatic ackermann2:(I)I</code> , qui ne prend qu'un seul argument.  Il s'agit d'une optimisation courante, qui permet d'utiliser la ¬´suppression de code mort¬ª pour jeter tout code utilis√© pour calculer le premier argument <code>30: invokestatic ackermann:(II)I</code> <br><br>  Pour ce faire, nous devons non seulement remplacer l'instruction <code>30</code> , mais √©galement regarder la liste des instructions et comprendre o√π le premier argument est calcul√© ( <code>v4</code> dans <code>STACK</code> ), et aussi le supprimer.  Nous revenons des instructions <code>30</code> √† <code>22</code> , et des <code>22</code> √† <code>21</code> et <code>20</code> .  La version finale: <br><br><pre> <code class="java hljs"> BYTECODE LOCALS STACK |a0|a1| | <span class="hljs-number"><span class="hljs-number">0</span></span>: iload_0 |a0|a1| |a0| <span class="hljs-number"><span class="hljs-number">1</span></span>: ifne <span class="hljs-number"><span class="hljs-number">8</span></span> |a0|a1| | <span class="hljs-number"><span class="hljs-number">4</span></span>: iload_1 |a0|a1| |a1| <span class="hljs-number"><span class="hljs-number">5</span></span>: iconst_1 |a0|a1| |a1| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">6</span></span>: iadd |a0|a1| |v1| <span class="hljs-number"><span class="hljs-number">7</span></span>: ireturn |a0|a1| | <span class="hljs-number"><span class="hljs-number">8</span></span>: iload_1 |a0|a1| |a1| <span class="hljs-number"><span class="hljs-number">9</span></span>: ifne <span class="hljs-number"><span class="hljs-number">20</span></span> |a0|a1| | <span class="hljs-number"><span class="hljs-number">12</span></span>: iload_0 |a0|a1| |a0| <span class="hljs-number"><span class="hljs-number">13</span></span>: iconst_1 |a0|a1| |a0| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">14</span></span>: isub |a0|a1| |v2| <span class="hljs-number"><span class="hljs-number">15</span></span>: iconst_1 |a0|a1| |v2| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">16</span></span>: invokestatic ackermann:(II)I |a0|a1| |v3| <span class="hljs-number"><span class="hljs-number">19</span></span>: ireturn |a0|a1| | - <span class="hljs-number"><span class="hljs-number">20</span></span>: iload_0 |a0|a1| | - <span class="hljs-number"><span class="hljs-number">21</span></span>: iconst_1 |a0|a1| | - <span class="hljs-number"><span class="hljs-number">22</span></span>: isub |a0|a1| | <span class="hljs-number"><span class="hljs-number">23</span></span>: iload_0 |a0|a1| |a0| <span class="hljs-number"><span class="hljs-number">24</span></span>: iload_1 |a0|a1| |a0|a1| <span class="hljs-number"><span class="hljs-number">25</span></span>: iconst_1 |a0|a1| |a0|a1| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">26</span></span>: isub |a0|a1| |a0|v5| <span class="hljs-number"><span class="hljs-number">27</span></span>: invokestatic ackermann:(II)I |a0|a1| |v6| - <span class="hljs-number"><span class="hljs-number">30</span></span>: invokestatic ackermann:(II)I |a0|a1| |v7| + <span class="hljs-number"><span class="hljs-number">30</span></span>: invokestatic ackermann2:(I)I |a0|a1| |v7| <span class="hljs-number"><span class="hljs-number">33</span></span>: ireturn |a0|a1| |</code> </pre> <br>  Nous pouvons toujours apporter une modification aussi simple √† une simple fonction <code>ackermann</code> .  Mais dans les grandes fonctions utilis√©es dans les projets r√©els, il sera beaucoup plus difficile d'effectuer de nombreux changements interconnect√©s.  En g√©n√©ral, toute petite modification s√©mantique de votre programme peut n√©cessiter de nombreuses modifications tout au long du bytecode. <br><br>  Vous remarquerez peut-√™tre que nous avons effectu√© le changement d√©crit ci-dessus en analysant les valeurs dans LOCALS et STACK: nous avons observ√© comment <code>v4</code> pass√© √† l'instruction <code>30</code> de l'instruction <code>22</code> , et <code>22</code> prend les donn√©es √† <code>a0</code> et <code>1</code> , qui proviennent des instructions <code>21</code> et <code>20</code> .  Ces valeurs sont transf√©r√©es entre LOCALS et STACK selon le principe du graphe: de l'instruction calculant la valeur au lieu de son utilisation ult√©rieure. <br><br>  Comme les paires <code>Ident</code> / <code>Assign</code> dans nos AST, les valeurs transmises entre LOCALS et STACK forment un graphique entre les points qui calculent les valeurs et les points qui sont utilis√©s.  Alors pourquoi ne commen√ßons-nous pas √† travailler directement avec le graphique? <br><br><h2>  Graphiques de flux de donn√©es </h2><br>  Les graphiques de flux de donn√©es sont le prochain niveau d'abstraction apr√®s le bytecode.  Si nous d√©veloppons notre arbre de syntaxe avec des relations <code>Ident</code> / <code>Assign</code> , ou si nous suivons comment le bytecode d√©place les valeurs entre LOCALS et STACK, nous pouvons construire un graphique.  Pour la fonction <code>ackermann</code> cela ressemble √† ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ad/217/5f7/5ad2175f73cf13fa7e47fb521a9aab1a.png"><br><br>  Contrairement au bytecode AST ou Java stack-bytecode, les graphiques de flux de donn√©es n'utilisent pas le concept de ¬´variable locale¬ª: au lieu de cela, le graphique contient des connexions directes entre chaque valeur et l'endroit o√π elle est utilis√©e.  Lors de l'analyse du bytecode, il est souvent n√©cessaire d'interpr√©ter de mani√®re abstraite LOCALS et STACK afin de comprendre comment les valeurs se d√©placent;  L'analyse AST implique le suivi de l'arbre et l'utilisation d'une table de symboles contenant les associations <code>Assign</code> / <code>Ident</code> ;  et l'analyse des graphiques de flux de donn√©es est souvent un suivi direct des transitions - l'id√©e pure de ¬´valeurs en mouvement¬ª sans les enveloppes de la pr√©sentation d'un programme. <br><br>  <code>ackermann</code> √©galement plus faciles √† manipuler que le bytecode lin√©aire: remplacer un n≈ìud par un appel <code>ackermann</code> appel <code>ackermann</code> et <code>ackermann2</code> un des arguments revient simplement √† modifier le n≈ìud du graphique (marqu√© en vert) et √† supprimer l'un des liens d'entr√©e avec les n≈ìuds de transit (marqu√©s en rouge): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b70/c2d/90d/b70c2d90d886bd7c90cdfbb3cb03b42d.png"><br><br>  Comme vous pouvez le voir, un petit changement dans le programme (en rempla√ßant <code>ackermann(int n, int m)</code> par <code>ackermann2(int m)</code> ) se transforme en un changement relativement localis√© dans le graphique du flux de donn√©es. <br><br>  En g√©n√©ral, travailler avec des graphiques est beaucoup plus facile qu'avec un bytecode lin√©aire ou AST: ils sont faciles √† analyser et √† modifier. <br><br>  Il n'y a pas beaucoup de d√©tails dans cette description des graphiques: en plus de la repr√©sentation physique r√©elle du graphique, il existe de nombreuses autres fa√ßons de mod√©liser l'√©tat et le contr√¥le de flux, qui sont plus difficiles √† travailler avec et au-del√† de la port√©e de l'article.  J'ai √©galement omis un certain nombre de d√©tails sur la transformation de graphiques, par exemple, l'ajout et la suppression de liens, les transitions avant et arri√®re, les transitions horizontales et verticales (en largeur et en profondeur), etc. Si vous avez √©tudi√© les algorithmes, tout cela devrait vous √™tre familier . <br><br>  Enfin, nous avons omis les algorithmes de conversion du bytecode lin√©aire en graphique, puis du graphique en retour en bytecode.  C'est en soi une t√¢che int√©ressante, mais nous vous laissons le soin d'√©tudier de mani√®re ind√©pendante. <br><br><h2>  Analyse </h2><br>  Apr√®s avoir eu l'id√©e du programme, nous devons l'analyser: d√©couvrez quelques faits qui vous permettront de transformer le programme sans changer son comportement.  Bon nombre des optimisations discut√©es ci-dessus sont bas√©es sur l'analyse du programme: <br><br><ul><li>  Pliage constant: le r√©sultat de l'expression fonctionne-t-il avec une valeur constante connue?  Le calcul de l'expression est-il pur? <br></li><li>  Casting et inlining de type: un appel de m√©thode est-il un type avec une seule impl√©mentation de la m√©thode appel√©e? <br></li><li>  :     ? <br></li><li>   :    ¬´¬ª?    -     ?  ? <br></li><li>  :  ,        ? <br></li></ul><br>       ,    ,      ,      .       , ,   ,       . <br><br> , , ,  ‚Äî      ,       .              . <br><br><h2>   (Inference Lattice) </h2><br>    ,       .  , ¬´¬ª  -    : <br><br><ul><li>   <code>Integer</code> ? <code>String</code> ? <code>Array[Float]</code> ? <code>PrintLogger</code> ? <br></li><li>  <code>CharSequence</code> ?      <code>String</code> ,     -  <code>StringBuilder</code> ? <br></li><li>   <code>Any</code> ,     ,    ? <br></li></ul><br>             : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/258/4b1/b4d/2584b1b4d5769ebd78d1dcd84e4f686a.png"><br><br>        :   ,    <code>"hello"</code>   <code>String</code> ,    <code>String</code>   <code>CharSequence</code> .        <code>"hello"</code> ,      (Singleton Type) ‚Äî .    : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/416/872/547/416872547323d84b9b682852ea1f4dcc.png"><br><br>       ,  ,      .   ,   .   ,        , , <code>String</code>  <code>StringBuilder</code> ,    ,       : <code>CharSequence</code> .   ,    <code>0</code> ,  <code>1</code> ,  <code>2</code> ,    ,   <code>Integer</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/76a/79c/cc2/76a79ccc288b609397bdc4013a33f7b5.png"><br><br>      , ,     : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/479/112/0ef/4791120ef75231854b348596b49ab700.png"><br><br>   ,    ,        .  ,     . <br><br><h2>  count </h2><br>      <code>main</code> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>, multiplied = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(count &lt; n){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (multiplied &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>) logger.log(count); count += <span class="hljs-number"><span class="hljs-number">1</span></span>; multiplied *= count; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ...; }</code> </pre> <br>      <code>ackermann</code> ,    <code>count</code> , <code>multiplied</code>  <code>logger</code> .     : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/383/aa5/a19/383aa5a19df21ddbbe6f13555fb4ea1d.png"><br><br>  ,  <code>count</code>   <code>0</code>  <code>block0</code> .      <code>block1</code> ,   ,    <code>count &lt; n</code> :  ,    <code>block3</code>  <code>return</code> ,    <code>block2</code> ,   <code>count</code>  <code>1</code>     <code>count</code> ,    <code>block1</code>   .      ,  <code>&lt;</code>   <code>false</code> ,     <code>block3</code>   . <br><br>   ? <br><br><ul><li>   <code>block0</code> .  ,  <code>count = 0.</code> <br></li><li>   <code>block1</code> ,   ,   <code>n</code> (  ,      <code>Integer</code> ),     ,   <code>if</code> .   <code>block2</code>  <code>block3.</code> </li><li>  <code>block3</code> ,   ,    <code>block1b</code> ,      <code>block2</code> ,   ,     <code>block1c</code> .  ,  <code>block2</code>  <code>count</code> ,    1      <code>count.</code> </li><li>  ,  <code>count</code>    <code>0</code>  <code>1</code> :        <code>count</code>  <code>Integer.</code> </li><li>  :   <code>block1</code>   <code>n</code>  <code>count</code>  <code>Integer</code> . <br></li><li>    <code>block2</code> ,  <code>count</code>   <code>Integer + 1 -&gt; Integer</code> .   ,  <code>count</code>  <code>Integer</code> ,    . <br></li></ul><br><h2>  multiplied </h2><br>      ,   <code>multiplied</code> : <br><br><ul><li>   <code>block0</code> .  ,  <code>multiplied</code>   <code>0.</code> <br></li><li>   <code>block1</code> ,     ,      .   <code>block2</code>  <code>block3</code> (  ). <br></li><li>  <code>block2</code> ,    <code>block2</code> ( <code>0</code> )  <code>count</code> (    <code>Integer</code> ).  <code>0 * Integer -&gt; 0</code> ,   <code>multiplied</code>   <code>0.</code> <br></li><li>    <code>block1</code>  <code>block2</code> . <code>multiplied</code>     <code>0</code> ,    . <br></li></ul><br>  <code>multiplied</code>   <code>0</code> ,  , : <br><br><ul><li> <code>multiplied &lt; 100</code>    <code>true.</code> <br></li><li> <code>if (multiplied &lt; 100) logger.log(count);</code>    <code>logger.log(count)</code> . <br></li><li>    ,    <code>multiplied</code> ,     ,      <code>0</code> . <br></li></ul><br>    : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e9f/5f2/e95/e9f5f2e95c4dc3bfc64d54834c2a19ea.png"><br><br>     : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd4/625/fdb/fd4625fdb669e5d9e0c4d28a71e67f85.png"><br><br>       : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(count &lt; n){ logger.log(count); count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ...; }</code> </pre> <br>       ,      ,   ,  ,      . <br><br>  <code>multiplied -&gt; 0</code>      , ,   .  ,     ,      .         ,           . <br><br>     ,       .  : <br><br><ul><li>              . <br></li><li>        . <br></li><li>             . <br></li><li>        :        . <br></li></ul><br>        <code>count</code> ,   <code>multiplied</code> .    ,  <code>multiplied</code>   <code>count</code> ,  <code>count</code>    <code>multiplied</code> .        ,      . <br><br>  ,   ‚Äî  :       ,      .  ,      ( )      .          . <br><br>         <code>while</code> ,    ,    <code>O(  )</code> .     (,       )    ,     ,    . <br><br>           ,    . <br><br><h2>    </h2><br>        ,        .      ,   ,                 ,    ,           . <br><br><h2>    </h2><br>       .    : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> called(n, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">called</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * y; }</code> </pre> <br>         : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/45a/a32/471/45aa32471c28271c2755e5494a590891.png"><br><br>    <code>main</code> : <br><br><ul><li>  <code>main(n)</code> <br><ul><li>  <code>called(n, 0)</code> <br><ul><li>  <code>x * y</code>  <code>x = n</code>  <code>y = 0</code> </li><li> <code>n * 0</code>  <code>0</code> </li></ul></li><li> <code>called(n, 0)</code>  <code>0</code> </li></ul></li><li> <code>main(n)</code>  <code>0</code> <br></li></ul><br>        ,    ,     .              . <br><br>  ,  <code>called(n, 0)</code>  <code>0</code> ,         : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e8/484/17d/3e848417db361dae9f39425ddeed1a13.png"><br><br>    : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>     :  A  B,  C,  D,  D     C, B, D  A.    A  B  B  A,   A   A,    ,     ! <br><br><h2>    </h2><br>    ,    Java: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Any </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre> <br>   <code>n</code>    <code>int</code> ,      <code>Any</code> :     .  ,  <code>factorial</code>  <code>int</code> ( <code>Integer</code>   ).        <code>factorial</code> ,      <code>factorial</code>      <code>factorial</code> ,      !         ? <br><br><h2>   Bottom </h2><br>        <code>Bottom</code> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/abe/520/44e/abe52044e569bfe201c2d0f6998761ec.png"><br><br>   ¬´   ,  ,      ¬ª.  <code>Bottom</code>      <code>factorial</code> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/50b/347/73b/50b34773b36ec9470e3bdb03efaec5eb.png"><br><br><ul><li>   <code>block0</code> . <code>n</code>   <code>Integer</code> , <code>1</code>  <code>1</code> ,   <code>n == 1</code>  ,      <code>true</code>  <code>false</code> . <br></li><li>  <code>true</code>  : <code>return</code>  <code>1</code> . <br></li><li>   <code>false</code>  <code>n - 1</code>  <code>n</code>   <code>Integer</code> . <br></li><li> <code>factorial</code> ‚Äî   ,      <code>Bottom</code> . <br></li><li> <code>*</code>  <code>n: Integer</code>  <code>factorial</code> : <code>Bottom</code>   <code>Bottom</code> . <br></li><li> <code>return</code>  <code>Bottom</code> . </li><li>   <code>factorial</code>  <code>1</code>  <code>Bottom</code> ,           <code>1</code> . <br></li><li>  <code>1</code>      <code>factorial</code> ,      <code>Bottom</code> . <br></li><li> <code>Integer * 1</code>  <code>Integer</code> . <br></li><li> <code>return</code>   <code>Integer</code> . </li><li> <code>factorial</code>   <code>Integer</code>  <code>1</code> ,        <code>Integer</code> . <br></li><li> <i></i>    <code>factorial</code> ,      <code>Integer</code> .  <code>*</code>  <code>n: Integer</code>  <code>factorial: Integer</code> ,    <code>Integer</code> ,     . <br></li></ul><br>     <code>factorial</code>   <code>Integer</code> ,   ,        . <br><br>     ,        .           <code>Bottom</code> ,     ,                   . <br><br>     <code>*</code>  : <br><br><ol><li> <code>(n: Integer) * (factorial: Bottom)</code> <br> </li><li> <code>(n: Integer) * (factorial: 1)</code> <br> </li><li> <code>(n: Integer) * (factorial: Integer)</code> <br> </li></ol><br>        <code>multiplied</code>  ,        <code>O(  )</code> .            , , . <br><br><h2>     </h2><br>     ‚Äî   ,     ¬´  ¬ª.      ,        (¬´ ¬ª),  ,        (¬´ ¬ª).     . <br><br>        <code>main</code> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>, total = <span class="hljs-number"><span class="hljs-number">0</span></span>, multiplied = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(count &lt; n){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (multiplied &gt; <span class="hljs-number"><span class="hljs-number">100</span></span>) count += <span class="hljs-number"><span class="hljs-number">1</span></span>; count += <span class="hljs-number"><span class="hljs-number">1</span></span>; multiplied *= <span class="hljs-number"><span class="hljs-number">2</span></span>; total += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; }</code> </pre> <br>     ,       <code>if (multiplied &gt; 100)</code>   <code>multiplied *= count</code>  <code>multiplied *= 2</code> .        . <br><br><h2>       </h2><br>   ,       : <br><br><ul><li> <code>multiplied &gt; 100</code>    <code>true</code> ,  <code>count += 1</code>     (¬´¬ª). <br></li><li> <code>total</code>    ,       (¬´¬ª). <br></li></ul><br>  ,    : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(count &lt; n){ count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; }</code> </pre> <br>   ,     . <br><br>      : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0f1/2a1/af5/0f12a1af57586674b9e1a7fb1ae13c86.png"><br><br>    ,    ,    :   <code>block0</code> ,   <code>block1</code> ,    ,    <code>block1b</code> ,    ,    <code>block1c</code> ,   ,      <code>return</code>  <code>block3</code> . <br><br><h2>      </h2><br>        ,     <code>multiplied -&gt; 0</code> ,   : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/92a/1dd/f90/92a1ddf903dcc52cc9966220c56db876.png"><br><br>   : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/906/1ef/09c/9061ef09c209275be5158a8b3184a5bc.png"><br><br>  ,     <code>block1b</code> ( <code>0 &gt; 100</code> )    <code>true</code> .   <code>false</code>   <code>block1c</code> <i></i>     (   <code>if</code> ): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/587/21e/8e4/58721e8e43fb326379c796593f9bd2a7.png"><br><br> ,   ¬´ ¬ª <code>total</code>  <code>&gt;</code> ,  - ,         ,    .   ,       <code>return</code> ,   <i></i>    : <code>&gt;</code> , <code>100</code> , <code>0</code>  <code>block1b</code> , <code>total</code> , <code>0</code> ,  <code>+ 1</code> ,   <code>total</code>  <code>block0</code>  <code>block2</code> .   : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/55b/508/e16/55b508e164d0c4421aa525dcab56e122.png"><br><br>      ¬´¬ª : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(count &lt; n){ count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; }</code> </pre><br><h2>  Conclusion </h2><br>          : <br><br><ul><li>    -. <br></li><li> ,         . <br></li><li>   ,               .           . <br></li><li>   : ¬´¬ª      ¬´¬ª   , , . <br></li><li>      :   ,      . <br></li><li>         ,         . <br></li></ul><br>  ,         ,       . <br><br>        ,     .     .    ,    : <br><br><ul><li> <a href="https://www.amazon.com/Engineering-Compiler-Keith-Cooper/dp/012088478X">Engineering a Compiler by Keith D Cooper &amp; Linda Torczon</a> <br></li><li> <a href="https://www.researchgate.net/profile/Cliff_Click/publication/2394127_Combining_Analyses_Combining_Optimizations/links/0a85e537233956f6dd000000.pdf">Combining Analyses, Combining Optimizations by Cliff Noel Click Jr.</a> <br></li><li> <a href="https://www.amazon.com/Advanced-Compiler-Design-Implementation-Muchnick/dp/1558603204">Advanced Compiler Design and Implementation by Steven Muchnick</a> <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr477062/">https://habr.com/ru/post/fr477062/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr477050/index.html">Black Friday 2019 pour la vid√©osurveillance et les nuages.</a></li>
<li><a href="../fr477052/index.html">Reactor, WebFlux, Kotlin Coroutines ou Asynchrony avec un exemple simple</a></li>
<li><a href="../fr477054/index.html">Webasto annonce un syst√®me de batterie automobile modulaire</a></li>
<li><a href="../fr477058/index.html">Enterprise Agile Russia √† Raiffeisenbank 26/11 + Broadcast</a></li>
<li><a href="../fr477060/index.html">DataArt accueillera une conf√©rence ouverte d'Andrei Terekhov, chef du d√©partement de programmation syst√®me, Matmekh, Universit√© d'√âtat de Saint-P√©tersbourg</a></li>
<li><a href="../fr477072/index.html">D√©veloppement client ou comment lancer un produit sans √©chec?</a></li>
<li><a href="../fr477074/index.html">Fil d'Ariane: comment tomber amoureux de JSR-133. Rapport Yandex</a></li>
<li><a href="../fr477078/index.html">WebStorm 2019.3: lancement plus rapide, prise en charge am√©lior√©e de Vue.js et autres am√©liorations</a></li>
<li><a href="../fr477082/index.html">Congr√®s am√©ricain contre Zuckerberg: quelles all√©gations les r√©gulateurs font-ils contre la balance stable de Facebook</a></li>
<li><a href="../fr477084/index.html">Le cerveau de l'entreprise. 2e partie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>