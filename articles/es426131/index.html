<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôåüèΩ üî∞ üß§ Descargue la configuraci√≥n a FPGA a trav√©s de USB o desmonte FTDI MPSSE ‚ûñ üë®üèΩ‚Äç‚öñÔ∏è ‚òØÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En la vida de cada caj√≥n, llega un momento en que desea escribir su propio cargador del archivo de configuraci√≥n en el FPGA. Tuve que participar en el...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Descargue la configuraci√≥n a FPGA a trav√©s de USB o desmonte FTDI MPSSE</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426131/"><img src="https://habrastorage.org/webt/dx/i7/px/dxi7pxs820_gc9p_q_1m6zoaakm.jpeg"><br><br>  En la vida de cada caj√≥n, llega un momento en que desea escribir su propio cargador del archivo de configuraci√≥n en el FPGA.  Tuve que participar en el desarrollo de un stand de capacitaci√≥n para el departamento de una universidad t√©cnica.  El soporte est√° dise√±ado para estudiar el procesamiento de se√±ales digitales, aunque esto no es de particular importancia en el marco de este art√≠culo.  Y lo importante es que el FPGA (Altera Cyclone IV) est√° en el centro del stand, en el que los estudiantes recopilan todo tipo de esquemas DSP, tal como los concibi√≥ el autor del stand.  El soporte est√° conectado a la computadora a trav√©s de USB.  Necesita descargar el FPGA de la computadora a trav√©s de USB. <br><p>  Se tom√≥ la decisi√≥n de conectarse a una PC usando FTDI en su encarnaci√≥n de doble canal: FT2232H.  Un canal se usar√° para la configuraci√≥n de FPGA, el otro se puede usar para el intercambio FIFO de alta velocidad. </p><a name="habracut"></a><br><p>  FTDI tiene una placa de depuraci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MORPH-IC-II</a> , donde el FPGA Cyclone II se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">flashea a</a> trav√©s de USB.  Conceptos en el dominio p√∫blico.  El c√≥digo fuente del gestor de arranque est√° parcialmente abierto: el gestor de arranque est√° disponible, sin embargo, toda la l√≥gica de trabajar con FTDI se traslada a una biblioteca privada y no se puede modificar.  En verdad, originalmente plane√© usar este gestor de arranque en mi proyecto o, en casos extremos, hacer que mi shell se base en su dll.  El firmware se carga en el FPGA en modo serie pasivo (serie pasiva - PS), FTDI funciona en modo MPSSE.  En el tablero, el rendimiento de la soluci√≥n MORPH-IC-II se confirm√≥ por completo, pero el problema, como suele suceder, no vino de d√≥nde.  Result√≥ que durante la operaci√≥n del dll MORPH-IC-II, todos los dispositivos FTDI conectados est√°n bloqueados, y como parte del complejo de entrenamiento hay dos dispositivos m√°s con convertidores similares: un generador y un analizador de se√±al.  El trabajo simult√°neo con ellos no es posible.  Maldita sea raro y molesto. </p><br><p>  Un caso similar fue implementado por los chicos del rover Mars: el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">programador USB JTAG MBFTDI</a> .  FTDI tambi√©n se usa all√≠ en modo MPSSE, pero a diferencia de MORPH-IC-II, las operaciones FPGA se realizan en modo JTAG.  Las fuentes est√°n disponibles gratuitamente, pero no encontr√© una indicaci√≥n clara de su estado (licencia).  Por lo tanto, para usarlos en un proyecto comercial, mi mano no se levant√≥. </p><br><p>  Corregir√© tal error, todo lo que se presentar√° en el marco de este art√≠culo se publica en un repositorio abierto bajo la licencia BSD. </p><br><h2 id="zagruzka-fayla-konfiguracii-v-mikroshemu-plis">  Descargar el archivo de configuraci√≥n al chip FPGA </h2><br><p>  En primer lugar, debe tratar con el modo de arranque FPGA.  Para aquellos que reci√©n est√°n comenzando a familiarizarse con el tema, les dar√© una peque√±a excursi√≥n.  Aunque los FPGA Altera (Intel) de la familia Cyclone IV E est√°n instalados en mi placa, los m√©todos de carga son similares para todo el grupo Cyclone FPGA, y existe la sospecha de que de una forma u otra son adecuados para muchas otras familias. </p><br><p>  Este tipo de FPGA utiliza SRAM vol√°til para almacenar datos de configuraci√≥n.  Estos datos de configuraci√≥n determinan la funcionalidad del dispositivo resultante.  En la jerga profesional, estos datos a menudo se denominan "firmware".  Por lo tanto, el firmware se almacena en una RAM especial y cada vez que se enciende el dispositivo, debe cargarse en el chip FPGA.  Hay varias formas (esquemas de configuraci√≥n) por las cuales el firmware se puede cargar en SRAM (la lista es relevante para el Cicl√≥n IV E): </p><br><ol><li>  Serie activa (AS). </li><li>  Paralelo activo (AP) </li><li>  Serie pasiva (PS) </li><li>  Paralelo pasivo r√°pido (FPP). </li><li>  JTAG </li></ol><br><p>  La elecci√≥n de un modo de arranque espec√≠fico se realiza utilizando los terminales externos del FPGA (grupo MSEL).  El modo JTAG siempre est√° disponible.  El modo activo implica que cuando se aplica energ√≠a, el FPGA lee de forma independiente los datos de la memoria externa (en serie o en paralelo).  En modo pasivo, el FPGA espera a que un medio externo le transfiera proactivamente los datos de configuraci√≥n.  Estos esquemas encajan bien en el concepto de maestro (maestro) - esclavo (esclavo).  En modos activos, el FPGA act√∫a como maestro y en modos pasivos como esclavo. </p><br><p>  En este problema, no es el FPGA, pero el usuario debe decidir cu√°ndo se debe actualizar el firmware, por lo que el modo de arranque debe ser pasivo.  Y para salvar las patas del chip, elegimos una interfaz en serie.  El modo serie pasivo (PS) y JTAG son adecuados aqu√≠.  La l√≥gica del JTAG es algo m√°s complicada, as√≠ que centr√©monos en la primera opci√≥n. <br>  La siguiente figura muestra el esquema de conexi√≥n del FPGA a un controlador externo para descargar en modo PS. </p><br><img width="400" src="https://habrastorage.org/webt/q-/rj/pe/q-rjpeqe5y8ojlu8ywedoejklxq.png"><br><p>  Para iniciar la configuraci√≥n, el maestro externo debe generar una transici√≥n de baja a alta en la l√≠nea <em>nCONFIG</em> .  Tan pronto como el FPGA est√© listo para recibir datos, formar√° un alto nivel en la l√≠nea <em>nSTATUS</em> .  Despu√©s de eso, el maestro puede comenzar a transmitir datos en la l√≠nea <em>DATA [0]</em> y los pulsos de reloj correspondientes en la l√≠nea <em>DCLK</em> .  Los datos deben transmitirse al dispositivo de destino hasta que se establezca un nivel alto en la l√≠nea <em>CONF_DONE</em> (o los datos no finalizan), y el FPGA cambia al estado de inicializaci√≥n.  Cabe se√±alar que despu√©s de que <em>CONF_DONE se</em> establece en uno, se deben aplicar dos pulsos de reloj m√°s para que comience la inicializaci√≥n de FPGA. </p><br><p>  Los datos se transmiten por el bit menos significativo ( <abbr title="Poco significativo">LSB</abbr> ) hacia adelante, es decir, si el archivo de configuraci√≥n contiene la secuencia 02 1B EE 01 FA (tome el ejemplo como est√° en el Manual), la secuencia debe formarse en la l√≠nea de datos: </p><br><pre><code class="hljs powershell"><span class="hljs-number"><span class="hljs-number">0100</span></span><span class="hljs-literal"><span class="hljs-literal">-0000</span></span> <span class="hljs-number"><span class="hljs-number">1101</span></span><span class="hljs-literal"><span class="hljs-literal">-1000</span></span> <span class="hljs-number"><span class="hljs-number">0111</span></span><span class="hljs-literal"><span class="hljs-literal">-0111</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span><span class="hljs-literal"><span class="hljs-literal">-0000</span></span> <span class="hljs-number"><span class="hljs-number">0101</span></span><span class="hljs-literal"><span class="hljs-literal">-1111</span></span></code> </pre> <br><p>  Por lo tanto, solo se utilizan cinco l√≠neas: l√≠neas <em>DATA [0]</em> y <em>DCLK</em> para la transmisi√≥n en serie, <em>l√≠neas nCONFIG</em> , <em>nSTATUS</em> , <em>CONF_DONE</em> para el control. <br>  En esencia, el modo PS no es m√°s que SPI con manipulaci√≥n adicional de banderas. <br>  La velocidad de transferencia de datos debe ser inferior a la frecuencia m√°xima indicada en la documentaci√≥n; para la serie Cyclone IV E utilizada en el proyecto, es de 66 MHz. </p><br><p>  La frecuencia m√≠nima de transmisi√≥n no existe, te√≥ricamente es posible suspender la configuraci√≥n por un tiempo indefinido.  Esto brinda excelentes oportunidades para la depuraci√≥n paso a paso con la participaci√≥n de un osciloscopio, que ciertamente utilizaremos. </p><br><p>  La siguiente figura muestra el diagrama de tiempos de la interfaz con los tiempos m√°s significativos. </p><br><img width="720" src="https://habrastorage.org/webt/54/et/uy/54etuy0yva1est_qtdqp9yopqj8.png"><br><h2 id="hitryy-zver-mpsse">  Sly Beast MPSSE </h2><br><p>  Considere la operaci√≥n de FTDI en modo MPSSE.  El modo MPSSE (Multi-Protocol Synchronous Serial Engine), en mi opini√≥n, es un intento m√°s o menos exitoso de crear un cierto dise√±ador de interfaz en serie, para darle al desarrollador la oportunidad de implementar protocolos de transferencia de datos generalizados, como SPI, I2C, JTAG, 1 cable y muchos otros basados ‚Äã‚Äãen ellos. </p><br><p>  Actualmente, el modo est√° disponible para microcircuitos: FT232H, FT2232D, FT2232H, FT4232H.  En mi proyecto utilizo FT2232H, por lo que en mayor medida estamos hablando de eso.  Para el modo MPSSE, se asignan 16 tramos, divididos en dos bytes: el L m√°s bajo y el m√°s alto H. Cada byte se puede leer o configurar.  Las cuatro patas inferiores del byte L tienen funciones especiales: la transmisi√≥n de datos en serie puede ocurrir a trav√©s de ellas.  Cada tramo se puede configurar como entrada o salida, se puede establecer un valor predeterminado para la salida.  Para la transmisi√≥n secuencial, el orden de los bits ( <abbr title="Bit m√°s significativo">MSB</abbr> / <abbr title="Poco significativo">LSB</abbr> ), la longitud de la palabra transmitida, la frecuencia de los pulsos de reloj, la sincronizaci√≥n frontal - frontal (ascendente) o posterior (descendente), puede elegir transmitir solo pulsos de reloj sin datos, o seleccionar reloj trif√°sico (relevante para I2C) y mucho m√°s. </p><br><p>  Pasar sin problemas a la programaci√≥n.  Hay dos formas alternativas de interacci√≥n de software con chips FTDI: la primera, llam√©mosla cl√°sica, en este caso, cuando se conecta a un puerto USB, el chip en el sistema se define como un puerto serie virtual (COM), el sistema operativo utiliza el controlador VCP (puerto COM virtual).  Toda la programaci√≥n adicional no difiere de la programaci√≥n del puerto COM cl√°sico: abierto - transmitido / contado - cerrado.  Y esto es cierto para varios sistemas operativos, incluidos Linux y Mac OS.  Sin embargo, con este enfoque, no ser√° posible realizar todas las caracter√≠sticas del controlador FTDI: el chip funcionar√° como un adaptador USB-UART.  El segundo m√©todo lo proporciona la biblioteca patentada FTD2XX, esta interfaz proporciona funciones especiales que no est√°n disponibles en la API del puerto COM est√°ndar, en particular, es posible configurar y utilizar modos de operaci√≥n especiales, como MPSSE, 245 FIFO, Bit-bang.  La biblioteca API FTD2XX est√° bien documentada por la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gu√≠a del Programador de Desarrollo de Aplicaciones de Software D2XX</a> , ampliamente conocida por mucho tiempo en c√≠rculos estrechos.  Y s√≠, FTD2XX tambi√©n est√° disponible para varios sistemas operativos. </p><br><p>  Los desarrolladores de FTDI se enfrentaron a la tarea de integrar el relativamente nuevo MPSSE en el modelo de interacci√≥n de software D2XX existente.  Y tuvieron √©xito, para trabajar en el modo MPSSE se usa el mismo conjunto de funciones que para otros modos "cl√°sicos", se usa la misma biblioteca FTD2XX API. </p><br><p>  En resumen, el algoritmo para operar en el modo MPSSE se puede describir de la siguiente manera: </p><br><ol><li>  Encuentre el dispositivo en el sistema y √°bralo. </li><li>  Inicialice el chip y p√≥ngalo en modo MPSSE. </li><li>  Establezca el modo de operaci√≥n de MPSEE. </li><li>  Trabajo directo con datos: transmitir, recibir, administrar GPIO: implementamos el protocolo de intercambio de destino. </li><li>  Cierra el dispositivo. </li></ol><br><h2 id="pishem-zagruzchik">  Escribir un gestor de arranque </h2><br><p>  Pasemos a la parte pr√°ctica.  En mis experimentos, usar√© la versi√≥n Eclipse de Oxygen.3a Release (4.7.3a) como IDE, y mingw32-gcc (6.3.0) como compilador.  Sistema operativo Win7. </p><br><p>  Desde el sitio web de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FTDI</a> descargamos la √∫ltima versi√≥n actual del controlador para nuestro sistema operativo.  En el archivo encontramos el archivo de encabezado ftd2xx.h con una descripci√≥n de todas las funciones API.  La API en s√≠ se implementa como ftd2xx.dll, pero dejaremos la importaci√≥n din√°mica para m√°s adelante y utilizaremos el enlace est√°tico: necesitamos el archivo de biblioteca ftd2xx.lib.  Para mi caso, ftd2xx.lib est√° en el directorio i386. </p><br><p>  En Eclipse, cree un nuevo proyecto en C.  Se puede confiar en la creaci√≥n de un <em>archivo MAKE</em> con un IDE.  En la configuraci√≥n del vinculador, especifique la ruta y el nombre de la biblioteca ftd2xx (transfir√≠ los archivos necesarios al directorio del proyecto en la carpeta ftdi).  No me enfocar√© en las caracter√≠sticas de configurar un proyecto para Eclipse, ya que sospecho que la mayor√≠a de ellos usan otros entornos y compiladores para la programaci√≥n de Win. </p><br><h3 id="punkt-pervyy-nayti-devays-i-otkryt-ego">  Punto uno  Encuentra un dispositivo y √°brelo </h3><br><p>  La API FTD2XX le permite abrir el chip utilizando una u otra informaci√≥n conocida al respecto.  Este puede ser su n√∫mero de serie en el sistema: el primer chip FTDI conectado tomar√° el n√∫mero 0, el siguiente 1 y as√≠ sucesivamente.  El n√∫mero en el sistema est√° determinado por el orden en que se conectan los microcircuitos, por decirlo suavemente, esto no siempre es conveniente.  Para abrir el chip por n√∫mero, se <code>FT_Open</code> funci√≥n <code>FT_Open</code> .  Puede abrir el chip por su n√∫mero de serie ( <code>FT_OPEN_BY_SERIAL_NUMBER</code> ), descripci√≥n ( <code>FT_OPEN_BY_DESCRIPTION</code> ) o por ubicaci√≥n ( <code>FT_OPEN_BY_LOCATION</code> ), para esto, se <code>FT_OpenEx</code> funci√≥n <code>FT_OpenEx</code> .  El n√∫mero de serie y la descripci√≥n se almacenan en la memoria interna del chip y pueden registrarse all√≠ durante la fabricaci√≥n del dispositivo con FTDI instalado.  La descripci√≥n, como regla, caracteriza el tipo de dispositivo o familia, y el n√∫mero de serie debe ser √∫nico para cada producto.  Por lo tanto, la forma m√°s conveniente de identificar dispositivos compatibles con el programa que se est√° desarrollando es su descripci√≥n.  Abriremos el chip FTDI de acuerdo con la descripci√≥n (descriptor).  De hecho, si inicialmente conoc√≠amos la l√≠nea de descripci√≥n del chip, entonces no necesitamos buscar el dispositivo en el sistema, sin embargo, como experimento, mostraremos todos los dispositivos conectados a la computadora con FTDI.  Usando la funci√≥n <code>FT_CreateDeviceInfoList</code> , crearemos una lista detallada de chips conectados, y usando la funci√≥n <code>FT_GetDeviceInfoList</code> , <code>FT_GetDeviceInfoList</code> consideraremos. </p><br><div class="spoiler">  <b class="spoiler_title">Lista de dispositivos conectados.</b>  <b class="spoiler_title">Listado:</b> <div class="spoiler_text"><pre> <code class="cpp hljs">ftStatus = FT_CreateDeviceInfoList(&amp;numDevs); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ftStatus == FT_OK) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Number of devices is %d\n"</span></span>,numDevs); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numDevs == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// allocate storage for list based on numDevs devInfo = (FT_DEVICE_LIST_INFO_NODE*)malloc(sizeof(FT_DEVICE_LIST_INFO_NODE)*numDevs); ftStatus = FT_GetDeviceInfoList(devInfo,&amp;numDevs); if (ftStatus == FT_OK) for (int i = 0; i &lt; numDevs; i++) { printf("Dev %d:\n",i); printf(" Flags=0x%x\n",devInfo[i].Flags); printf(" Type=0x%x\n",devInfo[i].Type); printf(" ID=0x%x\n",devInfo[i].ID); printf(" LocId=0x%x\n",devInfo[i].LocId); printf(" SerialNumber=%s\n",devInfo[i].SerialNumber); printf(" Description=%s\n",devInfo[i].Description); }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Bienvenido mi zoologico</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">D:\workspace\ftdi-mpsse-ps\<span class="hljs-keyword"><span class="hljs-keyword">Debug</span></span>&gt;ftdi-mpsse-ps.exe Number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> devices <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> Dev <span class="hljs-number"><span class="hljs-number">0</span></span>: Flags = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = <span class="hljs-number"><span class="hljs-number">0x5</span></span> ID = <span class="hljs-number"><span class="hljs-number">0x4036001</span></span> LocId = <span class="hljs-number"><span class="hljs-number">0x214</span></span> SerialNumber = AI043NNV Description = FT232R USB UART Dev <span class="hljs-number"><span class="hljs-number">1</span></span>: Flags = <span class="hljs-number"><span class="hljs-number">0x2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = <span class="hljs-number"><span class="hljs-number">0x6</span></span> ID = <span class="hljs-number"><span class="hljs-number">0x4036010</span></span> LocId = <span class="hljs-number"><span class="hljs-number">0x2121</span></span> SerialNumber = L731T70OA Description = LESO7 A Dev <span class="hljs-number"><span class="hljs-number">2</span></span>: Flags = <span class="hljs-number"><span class="hljs-number">0x2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = <span class="hljs-number"><span class="hljs-number">0x6</span></span> ID = <span class="hljs-number"><span class="hljs-number">0x4036010</span></span> LocId = <span class="hljs-number"><span class="hljs-number">0x2122</span></span> SerialNumber = L731T70OB Description = LESO7 B Dev <span class="hljs-number"><span class="hljs-number">3</span></span>: Flags = <span class="hljs-number"><span class="hljs-number">0x2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = <span class="hljs-number"><span class="hljs-number">0x8</span></span> ID = <span class="hljs-number"><span class="hljs-number">0x4036014</span></span> LocId = <span class="hljs-number"><span class="hljs-number">0x213</span></span> SerialNumber = FTYZ92L6 Description = LESO4<span class="hljs-number"><span class="hljs-number">.1</span></span>_ER</code> </pre> </div></div><br><p>  Tres dispositivos con chips FTDI est√°n conectados a mi PC: FT232RL (tipo 0x5), FT2232H (tipo 0x6) y FT232H (tepe 0x8).  El chip FT2232H en el sistema se mostr√≥ como dos dispositivos independientes (Dev 1 y Dev 2).  La interfaz FPGA PS est√° conectada a Dev 2, su descriptor es "LESO7 B".  √Åbrelo: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Open a device with device description "LESO7 B" ftStatus = FT_OpenEx("LESO7 B", FT_OPEN_BY_DESCRIPTION, &amp;ftHandle); if (ftStatus != FT_OK) { printf ("pen failure\r\n"); return -1; }</span></span></code> </pre> <br><p>  La mayor√≠a de las funciones API devuelven el estado de su llamada de tipo <code>FT_STATUS</code> , todos los valores posibles se describen como enum en el archivo de encabezado.  Hay muchos de ellos, pero es suficiente saber que el valor <code>FT_OK</code> es la ausencia de un error, todos los dem√°s valores son c√≥digos de error.  Un buen estilo de programaci√≥n es verificar el valor del estado despu√©s de cada llamada a la funci√≥n API. </p><br><p>  Si el dispositivo se abri√≥ con √©xito, en la variable <code>ftHandle</code> aparece alg√∫n valor distinto de cero, un descriptor de archivo equivalente, que se utiliza cuando se trabaja con archivos.  El identificador resultante establece una conexi√≥n con la interfaz de hardware y debe usarse al llamar a todas las funciones de la biblioteca que requieren acceso al chip. <br>  Para confirmar en la pr√°ctica la operatividad del sistema para la etapa actual, debemos proceder inmediatamente al paso cinco de nuestro algoritmo. </p><br><p>  Despu√©s de que termine de trabajar con el chip, debe cerrarlo.  Para hacer esto, use la funci√≥n <code>FT_Close</code> : </p><br><pre> <code class="cpp hljs">FT_Close(ftHandle);</code> </pre> <br><h3 id="punkt-2-inicializiruem-chip-i-vklyuchaem-mpsse">  Punto 2. Inicialice el chip y encienda el MPSSE </h3><br><p>  La configuraci√≥n es t√≠pica para la mayor√≠a de los modos y est√° bien descrita en la documentaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">b√°sica AN_135 FTDI MPSSE</a> . </p><br><ol><li>  Realizamos un reinicio (rezet) del chip.  Funci√≥n <code>FT_ResetDevice</code> . </li><li>  En caso de que haya basura en el b√∫fer de recepci√≥n, la limpiamos.  Funci√≥n <code>FT_Purge</code> . </li><li>  Ajuste el tama√±o de las memorias intermedias para leer y escribir.  Funci√≥n <code>FT_SetUSBParameters</code> . </li><li>  Desactiva la paridad.  <code>FT_SetChars</code> . </li><li>  Establecemos tiempos de espera para leer y escribir.  Por defecto, los tiempos de espera est√°n deshabilitados, habilite el tiempo de espera de transmisi√≥n.  <code>FT_SetTimeouts</code> . </li><li>  Configuramos el tiempo de espera para enviar un paquete desde el chip al host.  Por defecto, 16 ms, acelera a 1 ms.  <code>FT_SetLatencyTimer</code> . </li><li>  Active el control de flujo para sincronizar las solicitudes entrantes.  <code>FT_SetFlowControl</code> . </li><li>  Todo est√° listo para activar el modo MPSSE.  Restablezca el controlador MPSSE.  Usamos la funci√≥n <code>FT_SetBitMode</code> , establecemos el modo en 0 (modo = 0, m√°scara = 0). </li><li>  Active el modo MPSSE.  Funci√≥n <code>FT_SetBitMode</code> - modo = 2, m√°scara = 0. </li></ol><br><p>  <code>MPSSE_open</code> y configuramos el chip en la funci√≥n <code>MPSSE_open</code> , como par√°metro pasamos una l√≠nea con el controlador del dispositivo que se abrir√°: </p><br><div class="spoiler">  <b class="spoiler_title">Listado MPSSE_open</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_open</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *description)</span></span></span><span class="hljs-function"> </span></span>{ FT_STATUS ftStatus; ftStatus = FT_OpenEx(description, FT_OPEN_BY_DESCRIPTION, &amp;ftHandle); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ftStatus != FT_OK) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"open failure\r\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FT_DEVICE_NOT_OPENED; } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"open OK, %d\r\n"</span></span>, ftHandle); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\nConfiguring port for MPSSE use...\n"</span></span>); ftStatus |= FT_ResetDevice(ftHandle); <span class="hljs-comment"><span class="hljs-comment">//Purge USB receive buffer first by reading out all old data from FT2232H receive buff: ftStatus |= FT_Purge(ftHandle, FT_PURGE_RX); //Set USB request transfer sizes to 64K: ftStatus |= FT_SetUSBParameters(ftHandle, 65536, 65536); //Disable event and error characters: ftStatus |= FT_SetChars(ftHandle, 0, 0, 0, 0); //Sets the read and write timeouts in milliseconds: ftStatus |= FT_SetTimeouts(ftHandle, 0, 5000); //Set the latency timer to 1mS (default is 16mS): ftStatus |= FT_SetLatencyTimer(ftHandle, 1); //Turn on flow control to synchronize IN requests: ftStatus |= FT_SetFlowControl(ftHandle, FT_FLOW_RTS_CTS, 0x00, 0x00); //Reset controller: ftStatus |= FT_SetBitMode(ftHandle, 0x0, FT_BITMODE_RESET); //Enable MPSSE mode: ftStatus |= FT_SetBitMode(ftHandle, 0x0, FT_BITMODE_MPSSE); if (ftStatus != FT_OK) { printf("Error in initializing the MPSSE %d\n", ftStatus); return FT_OTHER_ERROR; } Sleep(50); // Wait for all the USB stuff to complete and work return FT_OK; }</span></span></code> </pre> </div></div><br><h3 id="punkt-3-nastroim-rezhim-raboty-mpsee">  Elemento 3. Configure el modo de operaci√≥n MPSEE </h3><br><p>  En realidad, en esta etapa, el procesador MPSSE est√° activado y listo para recibir comandos.  Los comandos son secuencias de bytes, el primer byte es "op-code", seguido de los par√°metros del comando.  El comando puede no tener par√°metros y constar de un "c√≥digo operativo".  Los comandos se transmiten usando la funci√≥n FT_Write, se puede obtener una respuesta del procesador MPSSE usando la funci√≥n <code>FT_Read</code> . </p><br><p>  Despu√©s de enviar cada comando, es √∫til leer la respuesta del procesador, ya que en caso de un comando incorrecto, la respuesta puede contener un mensaje de error: el car√°cter 0xFA.  El mecanismo de "comando incorrecto: respuesta 0xFA" se puede utilizar para sincronizar el programa de aplicaci√≥n con el procesador MPSSE.  Si todo est√° bien, entonces el chip devolver√° el car√°cter 0xFA en un comando deliberadamente err√≥neo.  Los c√≥digos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">operativos</a> se describen en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Procesador de comandos para el modo de emulaci√≥n de bus de host MPSSE y MCU</a> . <br>  La configuraci√≥n de MPSSE se reduce a establecer la velocidad de datos, la direcci√≥n y los estados iniciales de las l√≠neas de E / S. <br>  Considere configurar la velocidad de datos del procesador MPSSE.  Las configuraciones para chips con soporte solo para modo de velocidad completa (FT2232 <strong>D</strong> ) y chips con alta velocidad (FT2232 <strong>H</strong> , FT232H, FT4232H) son algo diferentes.  El FT2232D heredado usa un reloj de 12MHz, mientras que los modernos usan 60MHz.  De ah√≠ la f√≥rmula para calcular la velocidad de transferencia de datos: </p><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>V</mi><mi>e</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>i</mi><mi>d</mi><mi>a</mi><mi>d</mi><mi>d</mi><mi>e</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>o</mi><mi>s</mi><mo>=</mo><mtext>&amp;#xA0;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>f</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi></mrow></msub></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>+</mo><mi>D</mi><mi>i</mi><mi>v</mi><mi>i</mi><mi>s</mi><mi>o</mi><mi>r</mi><mo stretchy=&quot;false&quot;>)</mo><mtext>&amp;#xA0;</mtext><mi>c</mi><mi>d</mi><mi>o</mi><mi>t</mi><mn>2</mn></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="50.265ex" height="2.66ex" viewBox="0 -832 21642 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-56" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-65" x="769" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-6C" x="1236" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-6F" x="1534" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-63" x="2020" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-69" x="2453" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-64" x="2799" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-61" x="3322" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-64" x="3852" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-64" x="4375" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-65" x="4899" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-64" x="5365" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-61" x="5889" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-74" x="6418" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-6F" x="6780" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-73" x="7265" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMAIN-3D" x="8012" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-66" x="9319" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-72" x="9869" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-61" x="10321" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-63" x="10850" y="0"></use><g transform="translate(11284,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-66" x="0" y="0"></use><g transform="translate(490,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-63" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-6F" x="433" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-72" x="919" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-65" x="1370" y="0"></use></g></g><g transform="translate(13173,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMAIN-28" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMAIN-31" x="389" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMAIN-2B" x="1112" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-44" x="2112" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-69" x="2941" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-76" x="3286" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-69" x="3772" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-73" x="4117" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-6F" x="4587" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-72" x="5072" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMAIN-29" x="5524" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-63" x="6163" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-64" x="6597" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-6F" x="7120" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMATHI-74" x="7606" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhjKtKndusZvzbKLEhmeLECZ3-BcSw#MJMAIN-32" x="7967" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>V</mi><mi>e</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>i</mi><mi>d</mi><mi>a</mi><mi>d</mi><mi>d</mi><mi>e</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>o</mi><mi>s</mi><mo>=</mo><mtext>&nbsp;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><msub><mi>f</mi><mrow class="MJX-TeXAtom-ORD"><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi></mrow></msub></mrow><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>D</mi><mi>i</mi><mi>v</mi><mi>i</mi><mi>s</mi><mi>o</mi><mi>r</mi><mo stretchy="false">)</mo><mtext>&nbsp;</mtext><mi>c</mi><mi>d</mi><mi>o</mi><mi>t</mi><mn>2</mn></mrow></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> Velocidad de datos = \ frac {f_ {core}} {(1 + Divisor) \ cdot 2} </script></p><br><p>  donde <em>f <sub>core</sub></em> es la frecuencia <em><sub>central</sub></em> FTDI, <em>Divisor</em> es un divisor de dos bytes que, de hecho, establece la frecuencia del reloj de datos. <br>  Como resultado, si el divisor es cero, entonces la velocidad de datos m√°xima ser√° de 30 Mbps, y la velocidad de datos m√≠nima ser√° de 458 bits / s con el divisor 65535. <br>  Confiaremos el c√°lculo del divisor al preprocesador.  La macro devuelve el divisor: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FCORE 60000000ul #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MPSSE_DATA_SPEED_DIV(data_speed) ((FCORE/(2*data_speed)) -1)</span></span></code> </pre> <br><p>  Y estas dos macros devuelven los bytes alto y bajo del divisor respectivamente: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MPSSE_DATA_SPEED_DIV_H(data_speed) ((MPSSE_DATA_SPEED_DIV(data_speed)) &gt;&gt; 8) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MPSSE_DATA_SPEED_DIV_L(data_speed) \ (MPSSE_DATA_SPEED_DIV(data_speed) - (MPSSE_DATA_SPEED_DIV_H(data_speed)&lt;&lt; 8))</span></span></code> </pre> <br><p>  Adem√°s, debe tenerse en cuenta que en los chips modernos para compatibilidad con el antiguo FT2232D hay un divisor adicional de 5, que convierte 60 MHz en 12 MHz.  Este divisor est√° activado por defecto, en nuestro caso deber√≠a estar apagado. <br>  Encontramos el c√≥digo de operaci√≥n correspondiente (0x8A) y el comando del casco para el procesador: </p><br><div class="spoiler">  <b class="spoiler_title">Listado de env√≠o de equipo</b> <div class="spoiler_text"><pre> <code class="cpp hljs">BYTE byOutputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>], byInputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>]; DWORD dwNumBytesToRead, dwNumBytesSent = <span class="hljs-number"><span class="hljs-number">0</span></span>, dwNumBytesRead = <span class="hljs-number"><span class="hljs-number">0</span></span>; byOutputBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0x8A</span></span>; ftStatus = FT_Write(ftHandle, byOutputBuffer, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;dwNumBytesSent); Sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Wait for data to be transmitted and status ftStatus = FT_GetQueueStatus(ftHandle, &amp;dwNumBytesToRead); ftStatus |= FT_Read(ftHandle, byInputBuffer, dwNumBytesToRead, &amp;dwNumBytesRead); if (ftStatus != FT_OK) { printf("Error\r\n"); return FT_OTHER_ERROR; } else if (dwNumBytesToRead &gt; 0) { printf("dwNumBytesToRead = %d:", dwNumBytesToRead); for ( int i = 0; i &lt; dwNumBytesToRead; i++) printf (" %02Xh", byInputBuffer[i]); printf("\r\n"); return FT_INVALID_PARAMETER; } return FT_OK;</span></span></code> </pre> </div></div><br><p>  Como experimento, en lugar del comando real 0x8A, enviaremos el valor 0xFE, que no corresponde a ning√∫n c√≥digo operativo, la salida de la consola: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">dwNumBytesToRead</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span>: FAh FEh</code> </pre> <br><p>  El procesador devolvi√≥ dos bytes, el byte de comando incorrecto es 0xFA y el valor de este comando incorrecto.  Por lo tanto, al enviar varios comandos a la vez, no solo podemos rastrear el hecho del error en s√≠, sino tambi√©n entender en qu√© equipo se produjo este error. <br>  Para no tratar con "n√∫meros m√°gicos" en el futuro, formatearemos todos los c√≥digos de operaci√≥n en forma de constantes y los colocaremos en un archivo de encabezado separado. <br>  Para configurar completamente el modo, debe especificar la direcci√≥n de las l√≠neas de E / S y su valor predeterminado.  Pasemos al diagrama de conexi√≥n.  Para no saturar un art√≠culo ya hinchado, he dibujado un fragmento interesante del esquema: </p><br><img width="500" src="https://habrastorage.org/webt/sc/6g/no/sc6gnoqy5_eyc5lsjpmlqbnl2-m.png"><br><p>  Las <em>l√≠neas DCLK</em> , <em>DATA [0]</em> , <em>nCONFIG</em> deben configurarse como salidas, las <em>l√≠neas</em> <em>nSTATUS</em> , <em>CONF_DONE</em> como entradas.  Usando el diagrama, determinamos qu√© estados iniciales deben tener las l√≠neas.  Para mayor claridad, el pinout del circuito se resume en la tabla: </p><br><table><thead><tr><th>  Pin FPGA </th><th>  Nombre pin </th><th>  Pin </th><th>  MPSSE </th><th>  Direcci√≥n </th><th>  por defecto </th></tr></thead><tbody><tr><td>  DCLK </td><td>  BDBUS0 </td><td>  38 </td><td>  TCK / SK </td><td>  Fuera </td><td>  0 0 </td></tr><tr><td>  DATOS [0] </td><td>  BDBUS1 </td><td>  39 </td><td>  TDI / DO </td><td>  Fuera </td><td>  1 </td></tr><tr><td>  nCONFIG </td><td>  BDBUS2 </td><td>  40 </td><td>  TDO / DI </td><td>  Fuera </td><td>  1 </td></tr><tr><td>  n ESTADO </td><td>  BDBUS3 </td><td>  41 </td><td>  TMS / CS </td><td>  En </td><td>  1 </td></tr><tr><td>  CONF_DONE </td><td>  BDBUS4 </td><td>  43 </td><td>  GPIOL0 </td><td>  En </td><td>  1 </td></tr></tbody></table><br><p>  Todas las l√≠neas utilizadas se encuentran en el byte bajo del puerto MPSSE.  Para establecer el valor, use el c√≥digo de operaci√≥n 0x80.  Este comando asume dos argumentos: el primer byte que sigue al c√≥digo de operaci√≥n es el valor bit por bit, y el segundo es la direcci√≥n (uno es el puerto de salida, cero es el puerto de entrada). <br>  Como parte de la lucha contra el "n√∫mero m√°gico", todos los n√∫meros de l√≠nea en serie y sus valores predeterminados se formatear√°n como constantes: </p><br><div class="spoiler">  <b class="spoiler_title">Definir puertos</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_DIRECTION (0x07) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DCLK (0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DATA0 (1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> N_CONFIG (2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> N_STATUS (3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONF_DONE (4) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// initial states of the MPSSE interface #define DCLK_DEF (1) #define DATA0_DEF (0) #define N_CONFIG_DEF (1) #define N_STATUS_DEF (1) #define CONF_DONE_DEF (1)</span></span></span></span></code> </pre> </div></div><br><p>  Solo queda asegurarse de que el bucle TDI - TDO est√© deshabilitado (se puede activar para probar) y ponerlo en una funci√≥n separada: </p><br><div class="spoiler">  <b class="spoiler_title">Listado de la funci√≥n MPSSE_setup</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_setup</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ DWORD dwNumBytesToSend, dwNumBytesSent, dwNumBytesToRead, dwNumBytesRead; BYTE byOutputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>], byInputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>]; FT_STATUS ftStatus; <span class="hljs-comment"><span class="hljs-comment">// Multple commands can be sent to the MPSSE with one FT_Write dwNumBytesToSend = 0; // Start with a fresh index byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_DISABLE_DIVIDER_5; byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_DISABLE_ADAPTIVE_CLK; byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_DISABLE_3PHASE_CLOCKING; ftStatus = FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); dwNumBytesToSend = 0; // Reset output buffer pointer // Set TCK frequency // Command to set clock divisor: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_SET_TCK_DIVISION; // Set ValueL of clock divisor: byOutputBuffer[dwNumBytesToSend++] = MPSSE_DATA_SPEED_DIV_L(DATA_SPEED); // Set 0xValueH of clock divisor: byOutputBuffer[dwNumBytesToSend++] = MPSSE_DATA_SPEED_DIV_H(DATA_SPEED); ftStatus |= FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); dwNumBytesToSend = 0; // Reset output buffer pointer // Set initial states of the MPSSE interface // - low byte, both pin directions and output values /* | FPGA pin | Pin Name | Pin | MPSSE | Dir | def | | --------- | -------- | --- | ------ | --- | --- | | DCLK | BDBUS0 | 38 | TCK/SK | Out | 0 | | DATA[0] | BDBUS1 | 39 | TDI/DO | Out | 1 | | nCONFIG | BDBUS2 | 40 | TDO/DI | Out | 1 | | nSTATUS | BDBUS3 | 41 | TMS/CS | In | 1 | | CONF_DONE | BDBUS4 | 43 | GPIOL0 | In | 1 | */ // Configure data bits low-byte of MPSSE port: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_SET_DATA_BITS_LOWBYTE; // Initial state config above: byOutputBuffer[dwNumBytesToSend++] = (DCLK_DEF &lt;&lt; DCLK) | (DATA0_DEF &lt;&lt; DATA0) | (N_CONFIG_DEF &lt;&lt; N_CONFIG) | (N_STATUS_DEF &lt;&lt; N_STATUS) | (CONF_DONE_DEF &lt;&lt; CONF_DONE); // Direction config above: byOutputBuffer[dwNumBytesToSend++] = PORT_DIRECTION; ftStatus |= FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); // Send off the low GPIO config commands dwNumBytesToSend = 0; // Reset output buffer pointer // Set initial states of the MPSSE interface // - high byte, all input, Initial State -- 0. // Send off the high GPIO config commands: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_SET_DATA_BITS_HIGHBYTE; byOutputBuffer[dwNumBytesToSend++] = 0x00; byOutputBuffer[dwNumBytesToSend++] = 0x00; ftStatus |= FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); // Disable loopback: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_DISABLE_LOOP_TDI_TDO; ftStatus |= FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); Sleep(2); // Wait for data to be transmitted and status ftStatus = FT_GetQueueStatus(ftHandle, &amp;dwNumBytesToRead); ftStatus |= FT_Read(ftHandle, byInputBuffer, dwNumBytesToRead, &amp;dwNumBytesRead); if (ftStatus != FT_OK) { printf("Unknown error in initializing the MPSSE\r\n"); return FT_OTHER_ERROR; } else if (dwNumBytesToRead &gt; 0) { printf("Error in initializing the MPSSE, bad code:\r\n"); for ( int i = 0; i &lt; dwNumBytesToRead; i++) printf (" %02Xh", byInputBuffer[i]); printf("\r\n"); return FT_INVALID_PARAMETER; } return FT_OK; }</span></span></code> </pre> </div></div><br><h3 id="punkt-4-realizuem-protokol-zagruzki">  Punto 4. Implementamos el protocolo de carga </h3><br><p>  Todo parece listo para experimentos pr√°cticos.  Primero, verifique que la inicializaci√≥n se realice correctamente, en el cuerpo principal del programa, llame a <code>MPSSE_open()</code> y <code>MPSSE_setup()</code> , y antes de cerrar el dispositivo ( <code>FT_Close</code> ), colocamos un <code>getchar()</code> vac√≠o <code>getchar()</code> .  Ejecute el programa y use el osciloscopio para asegurarse de que todas las l√≠neas PS est√©n configuradas en los niveles predeterminados.  Cambiando el valor de estos niveles en la inicializaci√≥n (no ocurrir√° nada malo con el FPGA), nos aseguramos de que el procesador MPSSE d√© el resultado deseado como v√°lido: todo funciona adecuadamente y puede proceder a transferir datos. <br>  El env√≠o y la recepci√≥n secuenciales de datos se realizan en modo comando usando el mismo c√≥digo de operaci√≥n.  El primer byte del comando es el c√≥digo de operaci√≥n, que determina el tipo de operaci√≥n, seguido de la longitud de la secuencia transmitida o recibida y, si es una transmisi√≥n, los datos reales.  El procesador MPSSE puede enviar y recibir datos, tambi√©n lo hace al mismo tiempo.  La transmisi√≥n puede ser el bit bit forward menos significativo (LSB) o el m√°s significativo (MSB).  La transmisi√≥n de datos puede ocurrir tanto en los bordes iniciales como finales de los pulsos de reloj.  Cada combinaci√≥n de opciones tiene su propio c√≥digo de operaci√≥n, cada bit de c√≥digo de operaci√≥n describe el modo de operaci√≥n: </p><br><table><thead><tr><th>  Poco </th><th>  Funci√≥n </th></tr></thead><tbody><tr><td>  0 0 </td><td>  Sincronizaci√≥n de escritura frontal: 0 - positivo, 1 - negativo </td></tr><tr><td>  1 </td><td>  1 - trabajar con bytes, 0 - trabajar con bits </td></tr><tr><td>  2 </td><td>  Borde frontal para lectura: 0 - positivo, 1 - negativo </td></tr><tr><td>  3 </td><td>  Modo de transmisi√≥n: 1 - LSB, 0 - MSB primero </td></tr><tr><td>  4 4 </td><td>  Transmisi√≥n de datos TDI </td></tr><tr><td>  5 5 </td><td>  Lectura de datos de una l√≠nea TDO </td></tr><tr><td>  6 6 </td><td>  Transmisi√≥n de datos TMS </td></tr><tr><td>  7 7 </td><td>  Debe ser 0, de lo contrario, este es otro grupo de comandos </td></tr></tbody></table><br><p>  Al configurar FPGA de acuerdo con el esquema PS, los datos se transmiten en el borde de ataque en modo LSB.     ,   ,    op-code   0001_1000b  0x18   .       ( ,   ),    .    :     .  ,      ,     0,    65536,     65535. ,     .        <code>MPSSE_send</code> . </p><br><div class="spoiler"> <b class="spoiler_title">  MPSSE_send</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> BYTE byBuffer[<span class="hljs-number"><span class="hljs-number">65536</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BYTE * buff, DWORD dwBytesToWrite)</span></span></span><span class="hljs-function"> </span></span>{ DWORD dwNumBytesToSend = <span class="hljs-number"><span class="hljs-number">0</span></span>, dwNumBytesSent, bytes; FT_STATUS ftStatus; <span class="hljs-comment"><span class="hljs-comment">// Output on rising clock, no input // MSB first, clock a number of bytes out byBuffer[dwNumBytesToSend++] = MPSSE_CMD_LSB_DATA_OUT_BYTES_POS_EDGE; // 0x18 bytes = dwBytesToWrite -1; byBuffer[dwNumBytesToSend++] = (bytes) &amp; 0xFF; // Length L byBuffer[dwNumBytesToSend++] = (bytes &gt;&gt; 8) &amp; 0xFF; // Length H memcpy(&amp;byBuffer[dwNumBytesToSend], buff, dwBytesToWrite); dwNumBytesToSend += dwBytesToWrite; ftStatus = FT_Write(ftHandle, byBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); if (ftStatus != FT_OK ) { printf ("ERROR send data\r\n"); return ftStatus; } else if (dwNumBytesSent != dwNumBytesToSend) { printf ("ERROR send data, %d %d\r\n", dwNumBytesSent, dwNumBytesToSend); } return FT_OK; }</span></span></code> </pre> </div></div><br><p>        ‚Äî      65 ,   - ,        op-code   .   <code>byBuffer</code> ,             <code>buff</code> ,  ,      op-code  .    ,     ,         . <br>    ,        ""  ,       25 , ,  ,     1  ( ,     <code>#define DATA_SPEED 1000000ul</code> ).   : </p><br><pre> <code class="hljs objectivec">BYTE byOutputBuffer[] = {<span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-number"><span class="hljs-number">0x1B</span></span>, <span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">MPSSE_send</span></span>(byOutputBuffer, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(byOutputBuffer));</code> </pre> <br><p>    ( ): <br> <a href=""><img src="https://habrastorage.org/webt/bp/gp/es/bpgpesvsoradzqfecft07bdjk-u.png"></a> </p><br><p>   ‚Äî    <em>DATA[0]</em> ,   ‚Äî <em>DCLK</em> .             .  ,  ,   . </p><br><p>      ,     SPI  ( ).  ,     PS,     .   <em>nCONFIG</em> , <em>nSTATUS</em> , <em>CONF_DONE</em> .   ‚Äî  ,      ,   ‚Äî ,     . </p><br><p>  <code>MPSSE_get_lbyte</code>    ,  ,         . </p><br><div class="spoiler"> <b class="spoiler_title">  MPSSE_get_lbyte</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_get_lbyte</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BYTE *lbyte)</span></span></span><span class="hljs-function"> </span></span>{ DWORD dwNumBytesToSend, dwNumBytesSent, dwNumBytesToRead, dwNumBytesRead; BYTE byOutputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>]; FT_STATUS ftStatus; dwNumBytesToSend = <span class="hljs-number"><span class="hljs-number">0</span></span>; byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_GET_DATA_BITS_LOWBYTE; ftStatus = FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); Sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Wait for data to be transmitted and status ftStatus = FT_GetQueueStatus(ftHandle, &amp;dwNumBytesToRead); ftStatus |= FT_Read(ftHandle, lbyte, dwNumBytesToRead, &amp;dwNumBytesRead); if ((ftStatus != FT_OK) &amp; (dwNumBytesToRead != 1)) { printf("Error read Lbyte\r\n"); return FT_OTHER_ERROR; // Exit with error } return FT_OK; }</span></span></code> </pre> </div></div><br><p>  ,  op-code  ,         . ,     -     ,    ,          .    ,   .     <code>MPSSE_set_lbyte</code> : </p><br><div class="spoiler"> <b class="spoiler_title">  MPSSE_set_lbyte</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_set_lbyte</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BYTE lb, BYTE mask)</span></span></span><span class="hljs-function"> </span></span>{ DWORD dwNumBytesToSend, dwNumBytesSent; BYTE byOutputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>], lbyte; FT_STATUS ftStatus; ftStatus = MPSSE_get_lbyte(&amp;lbyte); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( ftStatus != FT_OK) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ftStatus; <span class="hljs-comment"><span class="hljs-comment">// Set to zero the bits selected by the mask: lbyte &amp;= ~mask; // Setting zero is not selected by the mask bits: lb &amp;= mask; lbyte |= lb; dwNumBytesToSend = 0; // Set data bits low-byte of MPSSE port: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_SET_DATA_BITS_LOWBYTE; byOutputBuffer[dwNumBytesToSend++] = lbyte; byOutputBuffer[dwNumBytesToSend++] = PORT_DIRECTION; ftStatus = FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); if ((ftStatus != FT_OK) &amp; (dwNumBytesSent != 1)) { printf("Error set Lbyte\r\n"); return FT_OTHER_ERROR; } return FT_OK; }</span></span></code> </pre> </div></div><br><p>   ,     .   :  FTDI;    MPSSE;  rbf-  ,    <em>nCONFIG</em>  ,      <em>N_STATUS</em> ;    rbf-    ;  ,    ,      <em>CONF_DONE</em> .     ,     MPSSE   FTDI       .   ,  <em>nCONFIG</em>      ""  ,     ,        ,     . </p><br><div class="spoiler"> <b class="spoiler_title">  main</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ FT_STATUS ftStatus; BYTE lowByte; DWORD numDevs; <span class="hljs-comment"><span class="hljs-comment">// create the device information list if ( argv[1] == NULL) { printf ("NO file\r\n"); return -1; } frbf = fopen(argv[1],"rb"); if (frbf == NULL) { printf ("Error open rbf\r\n"); return -1; } ftStatus = FT_CreateDeviceInfoList(&amp;numDevs); if ((numDevs == 0) || (ftStatus != FT_OK)) { printf("Error. FTDI devices not found in the system\r\n"); return -1; } ftStatus = MPSSE_open ("LESO7 B"); if (ftStatus != FT_OK) { printf("Error in MPSSE_open %d\n", ftStatus); EXIT(-1); } MPSSE_setup(); if (ftStatus != FT_OK) { printf("Error in MPSSE_setup %d\n", ftStatus); EXIT(-1); } printf ("nConfig -&gt; 0\r\n"); MPSSE_set_lbyte(0, 1 &lt;&lt; N_CONFIG); printf ("nConfig -&gt; 1\r\n"); MPSSE_set_lbyte(1 &lt;&lt; N_CONFIG, 1 &lt;&lt; N_CONFIG); if (MPSSE_get_lbyte(&amp;lowByte) != FT_OK) { EXIT(-1); } if (((lowByte &gt;&gt; N_STATUS) &amp; 1) == 0) { printf("Error. FPGA is not responding\r\n"); EXIT(-1); } int i = 0; size_t readBytes = 0; // Send the configuration file: do { readBytes = fread(buff, 1, MPSSE_PCK_SEND_SIZE, frbf); if (MPSSE_send(buff, readBytes) != FT_OK) EXIT(-1); putchar('*'); if (!((++i)%16)) printf("\r\n"); } while (readBytes == MPSSE_PCK_SEND_SIZE); printf("\r\n"); memset(buff, 0x00, sizeof(buff)); MPSSE_send(buff, 1); //        ? printf("Load complete\r\n"); // wait CONF_DONE set // A low-to-high transition on the CONF_DONE pin indicates that the configuration is // complete and initialization of the device can begin. i = 0; do { if (MPSSE_get_lbyte(&amp;lowByte) != FT_OK) { printf ("Error read CONF_DONE\r\n"); EXIT(-1); } if (i++ &gt; TIMEOUT_CONF_DONE) { printf ("Error CONF_DONE\r\n"); EXIT(-1); } Sleep(2); } while (((lowByte &gt;&gt; CONF_DONE) &amp; 1) == 0); printf("Configuration complete\r\n"); FT_Close(ftHandle); fclose(frbf); }</span></span></code> </pre> <br><p>   : </p><br><pre> <code class="hljs pgsql">pen "LESO7 B" OK nConfig -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> nConfig -&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ** <span class="hljs-keyword"><span class="hljs-keyword">Load</span></span> complete <span class="hljs-keyword"><span class="hljs-keyword">Configuration</span></span> complete</code> </pre> </div></div><br><p>    rbf-  .    .       30 /     . <br>      ,        -  JTAG. </p><br><h3 id="materialy-po-teme">  Materiales relacionados </h3><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FTDI-MPSSE-Altera PS</a> .   . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   </a> .   .       . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Software Application Development D2XX Programmer's Guide</a> .        FTDI.   API D2XX. </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FTDI MPSSE Basics. Application Note AN_135</a> .    .  FTDI MPSSE.      . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Procesador de comandos para los modos de emulaci√≥n de bus host MPSSE y MCU. </font><font style="vertical-align: inherit;">Nota de aplicaci√≥n AN_108</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Referencia para el c√≥digo de operaci√≥n. </font><font style="vertical-align: inherit;">De ninguna manera sin eso.</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Controladores D2XX</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Conductor FTDI.</font></font></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es426131/">https://habr.com/ru/post/es426131/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es426117/index.html">El Defensor del Pueblo propone bloquear anuncios con productos para beb√©s potencialmente peligrosos</a></li>
<li><a href="../es426119/index.html">Antig√ºedades: Cryptonomicon Iron</a></li>
<li><a href="../es426121/index.html">MC.exe (compilador de mensajes), rc.exe, link.exe para generar .dll para EventMessageFile</a></li>
<li><a href="../es426123/index.html">Aprende OpenGL. Leccion 6.1. PBR o renderizado f√≠sicamente correcto. Teor√≠a</a></li>
<li><a href="../es426125/index.html">Carrera de esteroides. Ascensores</a></li>
<li><a href="../es426133/index.html">Presentaci√≥n de la versi√≥n alfa de instant√°neas de volumen en Kubernetes</a></li>
<li><a href="../es426135/index.html">Nube privada para Internet de las cosas</a></li>
<li><a href="../es426137/index.html">Era de la honestidad</a></li>
<li><a href="../es426141/index.html">Red Hat reemplaza Docker con Podman</a></li>
<li><a href="../es426143/index.html">Animaci√≥n 3D: ¬øvideo o interactivo?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>