<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤚🏿 🌰 👨🏽‍🤝‍👨🏼 Estándares de diseño de bases de datos 🗽 🧜 🐦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pasando de un proyecto a otro, desafortunadamente, nos enfrentamos con la falta de estándares uniformes para el diseño de bases de datos, a pesar del ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estándares de diseño de bases de datos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/484188/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pa/zj/ej/pazjejv8zvpor7tzaggxr54csd4.jpeg"></div><br>  Pasando de un proyecto a otro, desafortunadamente, nos enfrentamos con la falta de estándares uniformes para el diseño de bases de datos, a pesar del hecho de que SQL ha existido durante varias décadas.  Sospecho que la razón se debe en parte a que la mayoría de los desarrolladores no entienden la arquitectura de la base de datos.  A lo largo de los años de mi trabajo en la contratación de desarrolladores, solo me encontré varias veces con quienes podían normalizar correctamente la base de datos.  Honestamente, esta puede ser una tarea difícil, pero muchos de los desarrolladores que entrevisté, incluso con fluidez en SQL, no tenían habilidades de diseño de bases de datos. <br><br>  Este artículo no trata sobre la normalización de la base de datos.  Si quieres aprender esto, <a href="https://youtu.be/y1tcbhWLiUM">aquí</a> te conté brevemente lo básico. <br><br>  Si tiene una base de datos en funcionamiento, debe responder a su pregunta: "¿qué estándares se pueden aplicar para facilitar el <i>uso de</i> esta base <i>de</i> datos?".  Si estos estándares se usan ampliamente, entonces será fácil para usted usar la base de datos, ya que no tiene que estudiar y recordar nuevos conjuntos de estándares cada vez que comience a trabajar con una nueva base de datos. <br><a name="habracut"></a><br><h1>  ¿Nombre o subrayado de CamelCase? </h1><br>  Constantemente encuentro bases de datos en las que las tablas se nombran al estilo de <code>CustomerOrders</code> o <code>customer_orders</code> .  ¿Cuál es mejor usar?  Quizás desee aplicar un estándar ya establecido, pero si está creando una nueva base de datos, le recomiendo usar guiones bajos para aumentar la accesibilidad.  La frase "bajo valor" tiene un significado diferente en comparación con "bajo valor", pero con un guión bajo, el primero siempre estará bajo <code>under_value</code> y el segundo estará bajo <code>undervalue</code> .  Y cuando usamos CamelCase obtenemos <code>Undervalue</code> y <code>UnderValue</code> , que son idénticos en términos de SQL que no distingue entre mayúsculas y minúsculas.  Además, si tiene problemas de visión y está experimentando constantemente con auriculares y clavijas para enfatizar las palabras, entonces el subrayado es <i>mucho</i> más fácil de leer. <br><br>  Finalmente, CamelCase es difícil de leer para aquellos para quienes el inglés no es nativo. <br>  Para resumir, esta no es una recomendación estricta, sino una preferencia personal. <br><br><h1>  ¿Plural o singular en los nombres de las tablas? </h1><br>  Los expertos en teoría de bases de datos han estado discutiendo durante mucho tiempo si las tablas deben ser singulares (cliente) o plurales (clientes).  Permítanme cortar este nudo gordiano sin profundizar en la teoría, simplemente con la ayuda del pragmatismo: los nombres de tablas en plural tienen menos probabilidades de entrar en conflicto con palabras clave reservadas. <br><br>  ¿Tienes usuarios - <code>users</code> ?  SQL tiene la palabra clave del <code>user</code> .  ¿Necesitas una tabla de restricciones?  <code>constraint</code> es una palabra reservada.  La palabra <code>audit</code> <br>  reservado, pero ¿necesita una tabla de <code>audit</code> ?  Simplemente use la forma <i>plural</i> de sustantivos, y luego la mayoría de las palabras reservadas no le molestarán en SQL.  Incluso PostgreSQL, que tiene un excelente analizador de SQL, ha tropezado con la tabla de <code>user</code> . <br><br>  Simplemente use el plural y la probabilidad de conflicto será mucho menor. <br><br><h1>  No nombre la columna con ID como "id" </h1><br>  Yo mismo he pecado con los años.  Una vez que trabajé con un cliente en París, y el DBA se quejó de mí cuando le <code>id</code> el nombre a la columna de <code>id</code> .  Pensé que era solo un pedante.  De hecho, el nombre de la columna <code>customers.id</code> es único, y <code>customers.customer_id</code> es una repetición de información. <br><br>  Y luego tuve que depurar esto: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> thread.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> email <span class="hljs-keyword"><span class="hljs-keyword">thread</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> email selected <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> selected.id = thread.id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> <span class="hljs-built_in"><span class="hljs-built_in">character</span></span> recipient <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> recipient.id = thread.recipient_id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> station_area sa <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> sa.id = recipient.id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> station st <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> st.id = sa.id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> star origin <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> origin.id = thread.id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> star destination <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> destination.id = st.id <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> route <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> ( route.from_id = origin.id <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> route.to_id = destination.id ) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> selected.id = ? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ( thread.sender_id = ? <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> ( thread.recipient_id = ? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ( origin.id = destination.id <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> ( route.distance <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>() &gt;= thread.datesent + ( route.distance * <span class="hljs-built_in"><span class="hljs-built_in">interval</span></span> <span class="hljs-string"><span class="hljs-string">'30 seconds'</span></span> ) )))) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> datesent <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>, thread.parent_id <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span></code> </pre> <br>  ¿Notaste el problema?  Si SQL usara nombres de identificación completos, como <code>email_id</code> , <code>star_id</code> o <code>station_id</code> , entonces los errores <i>desaparecerían</i> inmediatamente <i>cuando escribí este código</i> , y no más tarde, cuando traté de entender lo que hice mal. <br><br>  Hágase un favor y use los nombres completos para la identificación.  Gracias despues. <br><br><h1>  Nombres de columna </h1><br>  Dé a las columnas los nombres más descriptivos posibles.  Digamos que la columna de <code>temperature</code> no tiene nada que ver con esto: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, <span class="hljs-string"><span class="hljs-string">'too cold'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> areas <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> temperature &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>;</code> </pre> <br>  Vivo en Francia, y para nosotros una temperatura de 32 grados será "demasiado fría".  Por lo tanto, es mejor nombrar la columna <code>fahrenheit</code> . <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, <span class="hljs-string"><span class="hljs-string">'too cold'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> areas <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> fahrenheit &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>;</code> </pre> <br>  Ahora todo está completamente claro. <br><br>  Si tiene restricciones de clave externa, siempre que sea posible, asigne el mismo nombre a las columnas a ambos lados de la restricción.  Aquí hay un SQL razonable perfectamente pensado: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> some_table s <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> some_other_table o <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> o.owner = s.person_id;</code> </pre> <br>  Este código está realmente bien.  Pero cuando observa la definición de la tabla, verá que <code>some_other_table.owner</code> tiene una restricción de clave externa con <code>companies.company_id</code> .  Entonces, esencialmente este SQL está mal.  Era necesario usar nombres idénticos: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> some_table s <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> some_other_table o <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> o.company_id = s.person_id;</code> </pre> <br>  Ahora está claro de inmediato que tenemos un error, solo necesita verificar una línea de código y no referirse a la definición de la tabla. <br><br>  Sin embargo, quiero señalar que esto no siempre se puede hacer.  Si tiene una tabla con un almacén de origen y un destino, es posible que desee comparar <code>source_id</code> con <code>destination_id</code> con <code>warehouse_id</code> .  En este caso, es mejor dar los nombres <code>source_warehouse_id</code> y <code>destination_warehouse_id</code> . <br><br>  También tenga en cuenta que en el ejemplo anterior, el <code>owner</code> describirá el propósito mejor que <code>company_id</code> .  Si esto le parece confuso, puede nombrar la columna <code>owning_company_id</code> .  Entonces el nombre te dirá el propósito de la columna. <br><br><h1>  Evitar valores nulos </h1><br>  Este consejo es conocido por muchos desarrolladores experimentados de bases de datos, pero, desafortunadamente, no hablan de ello con la suficiente frecuencia: sin ninguna razón, no permita valores NULL en la base de datos. <br>  Este es un tema importante pero bastante complicado.  Primero, discutimos la teoría, luego su efecto en la arquitectura de la base de datos, y en conclusión analizaremos un ejemplo práctico de problemas serios causados ​​por la presencia de valores NULL. <br><br><h2>  Tipos de bases de datos </h2><br>  La base de datos puede contener datos de diferentes <i>tipos</i> : INTEGER, JSON, DATETIME, etc. El tipo está asociado con la columna y cualquier valor agregado debe corresponder a este tipo. <br><br>  ¿Pero qué es un tipo?  Este es un nombre, un conjunto de valores válidos y un conjunto de operaciones válidas.  Nos ayudan a evitar comportamientos no deseados.  Por ejemplo, ¿qué sucede en Java si intenta comparar una cadena y un número? <br><br><pre> <code class="sql hljs">CustomerAccount.java:5: error: bad operand types for binary operator '&gt;' if ( current &gt; threshold ) { ^ first type: String second type: int</code> </pre> <br>  Incluso si no notas que el <code>current &gt; threshold</code> compara tipos incomparables, el compilador lo detectará por ti. <br><br>  Irónicamente, las bases de datos que almacenan sus datos, y son su última línea de defensa contra la corrupción de datos, ¡funcionan terriblemente con los tipos!  Solo asqueroso.  Por ejemplo, si su tabla de <code>customers</code> tiene una clave sustituta, puede hacer esto: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, birthdate <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> customers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> customer_id &gt; weight;</code> </pre> <br>  Por supuesto, esto no tiene sentido y en realidad obtendrá un error de compilación.  Muchos lenguajes de programación hacen que sea más fácil detectar tales errores de tipo, pero con las bases de datos, lo contrario es cierto. <br><br>  Esta es una situación normal en el mundo de la base de datos, probablemente porque el <a href="https://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">primer estándar SQL fue lanzado en 1992</a> .  Las computadoras eran lentas en esos años, y todo lo que complicaba la implementación indudablemente ralentizaba las bases de datos. <br><br>  Y luego los valores NULL aparecen en la escena.  El estándar SQL los implementó correctamente en un solo lugar, en los <code>IS NOT NULL</code> <code>IS NULL</code> y <code>IS NOT NULL</code> .  Como el valor NULL es desconocido por definición, no puede tener operadores diseñados para él.  Y entonces hay <code>IS NULL</code> y <code>IS NOT NULL</code> lugar de <code>= NULL</code> y <code>!= NULL</code> .  Y cualquier comparación de valores NULL conduce a la aparición de un nuevo valor NULL. <br><br>  Si esto le parece extraño, será mucho más fácil si escribe "desconocido" en lugar de NULL: <br><br><blockquote>  La comparación de valores desconocidos <s>NULL</s> da como resultado valores desconocidos <s>NULL</s> . </blockquote><br>  Sí, ya veo! <br><br><h2>  ¿Qué significa un valor nulo? </h2><br>  Armados con las migajas de la teoría, consideramos sus consecuencias prácticas. <br><br>  Debe pagar una bonificación de $ 500 a todos los empleados cuyo salario del año ascendió a más de $ 50 mil. Escriba este código: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> employee_number, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> employees <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> salary &gt; <span class="hljs-number"><span class="hljs-number">50000</span></span>;</code> </pre> <br>  Y acaba de ser despedido, porque su jefe ganó más de $ 50 mil, pero su salario no está en la base de datos (en la columna de <code>employees.salary</code> es NULL), y el operador de comparación no puede comparar NULL con 50 000. <br><br>  ¿Por qué hay NULL en esta columna?  Tal vez el salario es confidencial.  Tal vez la información aún no ha llegado.  Tal vez este es un consultor y no se le paga.  Tal vez tiene un salario por hora, no un salario.  Hay <i>muchas</i> razones por las que pueden faltar datos. <br><br>  La presencia o ausencia de información en la columna sugiere que depende de otra <i>cosa</i> , y no de la desnormalización de la clave primaria y la base de datos.  Por lo tanto, las columnas en las que puede haber valores NULL son buenos candidatos para crear nuevas tablas.  En este caso, es posible que tenga tablas de <code></code> , <code></code> <code>_</code> , <code>__</code> , etc. Todavía lo despiden por combinar a ciegas los salarios y su jefe no tiene uno.  Pero entonces su base comienza a proporcionarle suficiente información para sugerir que el problema es más que un problema salarial. <br><br>  Y sí, fue un ejemplo estúpido, pero fue el colmo. <br><br><h2>  Los valores NULL conducen a situaciones lógicamente imposibles. </h2><br>  Puede parecerle que soy pedante con respecto a los valores NULL.  Sin embargo, veamos otro ejemplo que está mucho más cerca de la realidad. <br><br>  Hace unos años, trabajé en Londres para un registrador de dominios e intenté entender por qué una consulta SQL de 80 líneas devuelve datos incorrectos.  En esa situación, la información definitivamente debería haber sido devuelta, pero esto no sucedió.  Me da vergüenza admitirlo, pero me llevó un día comprender que la razón era una combinación de condiciones: <br><br><ul><li>  Usé OUTER JOIN. <br></li><li>  Podrían generar fácilmente valores NULL. <br></li><li>  Los valores NULL pueden hacer que SQL dé una respuesta incorrecta. <br></li></ul><br>  Muchos desarrolladores no conocen el último aspecto, así que veamos un ejemplo del libro <a href="https://www.amazon.com/Database-Depth-Relational-Theory-Practitioners/dp/0596100124/">Base de datos en profundidad</a> .  Un diagrama simple de dos tablas: <br><br> <code>suppliers</code> <br> <div class="scrollable-table"><table><tbody><tr><td>  proveedor_id <br></td><td>  ciudad <br></td></tr><tr><td>  s1 <br></td><td>  Londres <br></td></tr></tbody></table></div><br> <code>parts</code> <br> <br><div class="scrollable-table"><table><tbody><tr><td>  parte_id <br></td><td>  ciudad <br></td></tr><tr><td>  p1 <br></td><td>  Nulo <br></td></tr></tbody></table></div><br>  Es difícil encontrar un ejemplo más simple. <br><br>  Este código devuelve <code>p1</code> . <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> part_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> parts;</code> </pre> <br>  ¿Qué hará este código? <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> part_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> parts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> city = city;</code> </pre> <br>  No devolverá nada, porque no puede comparar un valor NULL, incluso con otro NULL o el mismo NULL.  Parece extraño porque la ciudad en cada línea debería ser la misma, incluso si no lo sabemos, ¿verdad?  Entonces, ¿qué devolverá el siguiente código?  Intenta entender esto antes de seguir leyendo. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> s.supplier_id, p.part_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> suppliers s, parts p <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> p.city &lt;&gt; s.city <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> p.city &lt;&gt; <span class="hljs-string"><span class="hljs-string">'Paris'</span></span>;</code> </pre> <br>  No obtuvimos una cadena en respuesta, porque no podemos comparar la ciudad <code>NULL</code> ( <code>p.city</code> ) y, por lo tanto, ninguna de las ramas de la <code>WHERE</code> dará lugar a <code>true</code> . <br><br>  Sin embargo, sabemos que la ciudad desconocida es París o no París.  Si es París, entonces la primera condición será verdadera ( <code>&lt;&gt; 'London'</code> ).  Si no es París, la segunda condición será verdadera ( <code>&lt;&gt; 'Paris'</code> ).  Por lo tanto, la <code>WHERE</code> debe ser <code>true</code> , pero no lo es, y como resultado, SQL genera un resultado lógicamente imposible. <br><br>  Fue un error que encontré en Londres.  Cada vez que escribe SQL que puede generar o contener valores NULL, corre el riesgo de obtener un resultado falso.  Esto sucede con poca frecuencia, pero es muy difícil de identificar. <br><br><h1>  Resumen </h1><br><ul><li>  Use <code>__</code> lugar de <code>CamelCase</code> . <br></li><li>  Los nombres de las tablas deben estar en plural. <br></li><li>  Dé nombres extendidos para los campos con identificadores ( <code>item_id</code> lugar de <code>id</code> ). <br></li><li>  Evite nombres de columna ambiguos. <br></li><li>  Si es posible, nombre las columnas con claves foráneas de la misma manera que las columnas a las que se refieren. <br></li><li>  Siempre que sea posible, agregue NOT NULL a todas las definiciones de columna. <br></li><li>  Siempre que sea posible, evite escribir SQL que pueda generar valores NULL. <br></li></ul><br>  Aunque no es perfecta, esta guía de diseño de bases de datos te facilitará la vida. </div></div><p>Source: <a href="https://habr.com/ru/post/484188/">https://habr.com/ru/post/484188/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../484176/index.html">Implementación de la plantilla de estado en Unity</a></li>
<li><a href="../484178/index.html">Conmutador Ethernet inteligente para el planeta Tierra</a></li>
<li><a href="../484180/index.html">PBX virtual Rostelecom: qué y cómo se puede hacer a través de la API</a></li>
<li><a href="../484182/index.html">Xenobots: nanorobots vivos de células de rana</a></li>
<li><a href="../484186/index.html">LDAP - "autenticación" es un antipatrón</a></li>
<li><a href="../484192/index.html">Aplicaciones fáciles y fáciles de implementar en el cartucho de Tarantool (parte 2)</a></li>
<li><a href="../484194/index.html">Kubernetes traducido a niños</a></li>
<li><a href="../484196/index.html">Grabar sonido JS desde un micrófono o comentarios de voz</a></li>
<li><a href="../484198/index.html">Reverso de la moneda: quién ganó y perdió con el crecimiento de las acciones de Tesla</a></li>
<li><a href="../484200/index.html">Cómo establecer objetivos para alcanzarlos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>