<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåô ‚úåüèæ üôÖ Automatisches Entsperren des Root-LUKS-Containers nach einem Hot-Boot üèúÔ∏è üîÑ üêæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Warum verschl√ºsseln Menschen im Allgemeinen Laufwerke ihrer PCs und manchmal auch Server? Es ist klar, dass niemand Fotos seiner Lieblingskatzen von d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Automatisches Entsperren des Root-LUKS-Containers nach einem Hot-Boot</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457396/"><p>  Warum verschl√ºsseln Menschen im Allgemeinen Laufwerke ihrer PCs und manchmal auch Server?  Es ist klar, dass niemand Fotos seiner Lieblingskatzen von der Festplatte gestohlen hat!  Das ist nur Pech: Bei einem verschl√ºsselten Laufwerk m√ºssen Sie bei jedem Start eine Schl√ºsselphrase √ºber die Tastatur eingeben. Das ist lang und langweilig.  Um es so zu entfernen, dass es zumindest manchmal nicht notwendig w√§re, es zu rekrutieren.  Ja, damit die Bedeutung der Verschl√ºsselung nicht verloren geht. </p><br><div class="spoiler">  <b class="spoiler_title">Katze f√ºr Aufmerksamkeit</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sr/rt/ny/srrtnywyggbrscsufm8ux8tvxmu.jpeg" alt="Cat"></p></div></div><br><p>  Nun, vollst√§ndig entfernen wird es nicht funktionieren.  Sie k√∂nnen stattdessen eine Schl√ºsseldatei auf einem USB-Flash-Laufwerk erstellen, und es funktioniert auch.  Und ohne Flash-Laufwerk (und ohne zweiten Computer im Netzwerk) ist das m√∂glich?  Wenn Sie Gl√ºck mit dem BIOS haben, k√∂nnen Sie fast!  Unter dem Schnitt finden Sie eine Anleitung zum Konfigurieren der Festplattenverschl√ºsselung √ºber LUKS mit den folgenden Eigenschaften: </p><br><ol><li> Die Passphrase oder Schl√ºsseldatei wird beim Ausschalten des Computers nirgendwo in offener Form (oder in der Form, die dem √ñffnen entspricht) gespeichert. </li><li>  Wenn Sie Ihren Computer zum ersten Mal einschalten, m√ºssen Sie eine Passphrase eingeben. </li><li>  Bei nachfolgenden Neustarts (vor dem Herunterfahren) ist keine Passphrase erforderlich. </li></ol><br><p>  Die Anweisungen wurden unter CentOS 7.6, Ubuntu 19.04 und openSUSE Leap 15.1 in virtuellen Maschinen und auf realer Hardware (Desktop, Laptop und zwei Server) getestet.  Sie sollten auf anderen Distributionen funktionieren, die eine funktionierende Version von Dracut haben. </p><br><p>  Und ja, in guter Weise h√§tte dies im Hub "Anormale Systemadministration" enden sollen, aber es gibt keinen solchen Hub. </p><a name="habracut"></a><br><p>  Ich schlage vor, einen separaten Steckplatz im LUKS-Container zu verwenden und den Schl√ºssel dazu zu speichern ... im RAM! </p><br><div class="spoiler">  <b class="spoiler_title">Was f√ºr ein Slot?</b> <div class="spoiler_text"><p> Der LUKS-Container implementiert eine mehrstufige Verschl√ºsselung.  N√ºtzliche Daten auf der Festplatte werden mit einer symmetrischen Verschl√ºsselung verschl√ºsselt, normalerweise <code>aes-xts-plain64</code> .  Der Schl√ºssel zu dieser symmetrischen Verschl√ºsselung (Hauptschl√ºssel) wird in der Phase der Containererstellung als zuf√§llige Folge von Bytes generiert.  Der Hauptschl√ºssel wird im Allgemeinen in verschl√ºsselter Form gespeichert - in mehreren Kopien (Slots).  Standardm√§√üig ist nur einer der acht Steckpl√§tze aktiv.  Jeder aktive Steckplatz verf√ºgt √ºber eine separate Schl√ºsselphrase (oder eine separate Schl√ºsseldatei), mit der Sie den Hauptschl√ºssel entschl√ºsseln k√∂nnen.  Aus Sicht des Benutzers stellt sich heraus, dass Sie das Laufwerk mit mehreren verschiedenen Schl√ºsselphrasen (oder Schl√ºsseldateien) entsperren k√∂nnen.  In unserem Fall verwenden Sie eine Schl√ºsselphrase (Steckplatz 0) oder einen Speicher, der als Schl√ºsseldatei verwendet wird (Steckplatz 6). </p></div></div><br><p>  Das BIOS auf den meisten Motherboards bereinigt den Speicher beim Neustart nicht oder Sie k√∂nnen ihn so konfigurieren, dass er nicht bereinigt wird (bekannte Ausnahme: "Intel Corporation S1200SP / S1200SP, BIOS S1200SP.86B.03.01.0042.013020190050 30.01.2019").  Daher k√∂nnen Sie den Schl√ºssel dort speichern.  Wenn das Ger√§t ausgeschaltet wird, wird der Inhalt des RAM selbst nach einer Weile zusammen mit einer ungesch√ºtzten Kopie des Schl√ºssels gel√∂scht. </p><br><p>  Also lass uns gehen. </p><br><h3 id="shag-pervyy-ustanovit-sistemu-na-zashifrovannyy-s-pomoschyu-luks-disk">  Schritt eins: Installieren Sie das System auf einer mit LUKS verschl√ºsselten Festplatte </h3><br><p>  In diesem Fall sollte die in <code>/boot</code> gemountete Festplattenpartition (z. B. <code>/dev/sda1</code> ) unverschl√ºsselt bleiben und die andere Partition, auf der alles andere (z. B. <code>/dev/sda2</code> ) verschl√ºsselt werden soll.  Das Dateisystem auf der verschl√ºsselten Partition kann ein beliebiges sein. Sie k√∂nnen auch LVM verwenden, sodass sich das Root-Dateisystem, das Swap-Volume und alles andere au√üer <code>/boot</code> im selben Container befinden.  Dies entspricht der Standardfestplattenpartitionierung in CentOS 7 und Debian bei Auswahl der Verschl√ºsselungsoption.  SUSE macht alles anders (verschl√ºsselt <code>/boot</code> ) und erfordert daher eine manuelle Partitionierung der Festplatte. </p><br><p>  Das Ergebnis sollte ungef√§hr so ‚Äã‚Äãaussehen: </p><br><pre> <code class="plaintext hljs">$ lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 10G 0 disk ‚îú‚îÄsda1 8:1 0 1G 0 part /boot ‚îî‚îÄsda2 8:2 0 9G 0 part ‚îî‚îÄluks-d07a97d7-3258-408c-a17c-e2fb56701c69 253:0 0 9G 0 crypt ‚îú‚îÄcentos_centos--encrypt2-root 253:1 0 8G 0 lvm / ‚îî‚îÄcentos_centos--encrypt2-swap 253:2 0 1G 0 lvm [SWAP]</code> </pre> <br><p>  Bei Verwendung von UEFI wird es auch eine EFI-Systempartition geben. </p><br><blockquote>  F√ºr Debian- und Ubuntu-Benutzer: Ersetzen Sie das Paket <code>initramfs-tools</code> durch <code>dracut</code> . <br><pre> <code class="plaintext hljs"># apt install --no-install-recommends dracut</code> </pre> <br><br>  <code>initramfs-tools</code> implementiert in unserem Fall eine falsche Logik, die auf verschl√ºsselte Abschnitte mit einer Schl√ºsseldatei angewendet wird.  Solche Abschnitte werden entweder vollst√§ndig ignoriert oder der Inhalt der Schl√ºsseldatei wird im Klartext in initramfs (d. H. Als Ergebnis auf die Festplatte) kopiert, was wir nicht ben√∂tigen. </blockquote><br><h3 id="shag-vtoroy-sozdat-klyuchevoy-fayl-kotoryy-budet-ispolzovatsya-dlya-avtomaticheskogo-razblokirovaniya-diska-posle-goryachey-perezagruzki">  Schritt 2: Erstellen Sie eine Schl√ºsseldatei, mit der das Laufwerk nach einem Hot-Neustart automatisch entsperrt wird </h3><br><p>  128 zuf√§llige Bits reichen f√ºr uns aus, d.h.  16 Bytes.  Die Datei wird auf einer verschl√ºsselten Festplatte gespeichert, sodass niemand, der den Verschl√ºsselungsschl√ºssel nicht kennt und keinen Root-Zugriff auf das geladene System hat, ihn nicht liest. </p><br><pre> <code class="plaintext hljs"># touch -m 0600 /root/key # head -c16 /dev/urandom &gt; /root/key</code> </pre> <br><p>  Die Schl√ºsseldatei enth√§lt gen√ºgend wirklich zuf√§llige Bits, sodass der langsame PBKDF-Algorithmus, der einen schwer zu w√§hlenden Verschl√ºsselungsschl√ºssel aus einer m√∂glicherweise schwachen Schl√ºsselphrase erstellt, nicht wirklich ben√∂tigt wird.  Daher k√∂nnen Sie beim Hinzuf√ºgen eines Schl√ºssels die Anzahl der Iterationen reduzieren: </p><br><pre> <code class="plaintext hljs"># cryptsetup luksAddKey --key-slot=6 --iter-time=1 /dev/sda2 /root/key Enter any existing passphrase:</code> </pre> <br><p>  Wie Sie sehen, wird die Schl√ºsseldatei auf einer verschl√ºsselten Festplatte gespeichert und stellt daher kein Sicherheitsrisiko dar, wenn der Computer ausgeschaltet wird. </p><br><h3 id="shag-tretiy-vydelit-mesto-v-fizicheskoy-pamyati-dlya-hraneniya-klyucha">  Schritt 3: Weisen Sie Speicherplatz im physischen Speicher zu, um den Schl√ºssel zu speichern </h3><br><p>  Linux verf√ºgt √ºber mindestens drei verschiedene Treiber, mit denen Sie unter einer bekannten Adresse auf den physischen Speicher zugreifen k√∂nnen.  Dies ist <code>linux/drivers/char/mem.c</code> , das auch f√ºr das Ger√§t <code>/dev/mem</code> , sowie <code>phram</code> Module (emuliert einen MTD-Chip, gibt das Ger√§t <code>/dev/mtd0</code> ) und <code>nd_e820</code> (wird bei der Arbeit mit NVDIMM verwendet, gibt <code>/dev/pmem0</code> ).  Sie alle haben ihre unangenehmen Eigenschaften: </p><br><ul><li>  <code>/dev/mem</code> bei Verwendung von Secure Boot nicht beschreibbar, wenn die Distribution <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das LOCKDOWN-Patch-Set</a> von Matthew Garrett verwendet (und dieses Patch-Set ist erforderlich, wenn die Distribution Secure Boot mit einem von Microsoft signierten Bootloader unterst√ºtzen soll). </li><li>  <code>phram</code> unter CentOS und Fedora nicht verf√ºgbar - der Betreuer hat die entsprechende Option beim <code>phram</code> des Kernels einfach nicht aktiviert. </li><li>  <code>nd_e820</code> muss mindestens 128 Megabyte Speicher reservieren - so funktioniert NVDIMM.  Dies ist jedoch die einzige Option, die unter CentOS mit Secure Boot ausgef√ºhrt wird. </li></ul><br><p>  Da es keine ideale Option gibt, werden alle drei unten betrachtet. </p><br><blockquote>  Bei Verwendung einer der Methoden ist √§u√üerste Vorsicht geboten, um andere Ger√§te oder Speicherbereiche als die erforderlichen nicht versehentlich zu beeintr√§chtigen.  Dies gilt insbesondere f√ºr Computer, die bereits √ºber MTD-Chips oder NVDIMM-Module verf√ºgen.  <code>/dev/mtd0</code> oder <code>/dev/pmem0</code> m√∂glicherweise nicht das Ger√§t, das dem Speicherbereich entspricht, der zum Speichern des Schl√ºssels reserviert ist.  Die Nummerierung vorhandener Ger√§te, auf die sich Konfigurationsdateien und Skripte st√ºtzen, kann ebenfalls verwechselt werden.  Dementsprechend wird empfohlen, alle Dienste, die auf vorhandenen Ger√§ten <code>/dev/mtd*</code> und <code>/dev/pmem*</code> , vor√ºbergehend zu deaktivieren. </blockquote><p>  Der physische Linux-Speicher wird <code>memmap</code> indem die <code>memmap</code> Option an den <code>memmap</code> .  Wir sind an zwei Arten dieser Option interessiert: </p><br><ul><li>  <code>memmap=4K$0x10000000</code> reserviert (d. <code>memmap=4K$0x10000000</code> . Markierungen sind reserviert, damit der Kernel selbst keine verwendet) 4 Kilobyte Speicher, beginnend mit der physischen Adresse 0x10000000; </li><li>  <code>memmap=128M!0x10000000</code> markiert 128 Megabyte physischen Speicher, beginnend bei der Adresse 0x10000000, als NVDIMM (offensichtlich falsch, aber f√ºr uns ausreichend). </li></ul><br><p>  Die Option c <code>$</code> ist f√ºr die Verwendung mit <code>/dev/mem</code> und <code>phram</code> , die Option c <code>!</code>  - f√ºr <code>nd_e820</code> .  Bei Verwendung von <code>$</code> Startadresse des reservierten Speichers ein Vielfaches von <code>0x1000</code> (d. H. 4 Kilobyte) sein, wenn <code>!</code>  - ein Vielfaches von <code>0x8000000</code> (d. <code>0x8000000</code> . 128 Megabyte). </p><br><p>  Wichtig: Das Dollarzeichen ( <code>$</code> ) in den GRUB-Konfigurationsdateien ist ein Sonderzeichen und muss maskiert werden.  Und zweimal: einmal - beim Generieren von <code>grub.cfg</code> aus <code>/etc/default/grub</code> , ein zweites Mal - beim Interpretieren der resultierenden Konfigurationsdatei beim Booten.  Das hei√üt,  In <code>/etc/default/grub</code> sollte eventuell die folgende Zeile erscheinen: </p><br><pre> <code class="plaintext hljs">GRUB_CMDLINE_LINUX="memmap=4K\\\$0x10000000 ...  ..."</code> </pre> <br><p>  Ohne das <code>$</code> -Zeichen doppelt zu umgehen, startet das System einfach nicht, da es denkt, dass es nur 4 Kilobyte Speicher hat.  Es gibt keine derartigen Schwierigkeiten mit einem Ausrufezeichen: </p><br><pre> <code class="plaintext hljs">GRUB_CMDLINE_LINUX="memmap=128M!0x10000000 ...  ..."</code> </pre> <br><p>  Die physische Speicherkarte (und es wird ben√∂tigt, um herauszufinden, welche Adressen reserviert werden sollen) ist f√ºr den <code>root</code> in der <code>/proc/iomem</code> : </p><br><pre> <code class="plaintext hljs"># cat /proc/iomem ... 000f0000-000fffff : reserved 000f0000-000fffff : System ROM 00100000-7ffddfff : System RAM 2b000000-350fffff : Crash kernel 73a00000-7417c25e : Kernel code 7417c25f-747661ff : Kernel data 74945000-74c50fff : Kernel bss 7ffde000-7fffffff : reserved 80000000-febfffff : PCI Bus 0000:00 fd000000-fdffffff : 0000:00:02.0 ...</code> </pre> <br><p>  Der RAM ist als "System RAM" gekennzeichnet. Es reicht aus, eine seiner Seiten f√ºr die Speicherung des Schl√ºssels zu reservieren.  Das Erraten, welcher Teil des BIOS-Speichers beim Neustart nicht ber√ºhrt wird, funktioniert im Voraus nicht zuverl√§ssig.  Es sei denn, es gibt einen anderen Computer mit genau derselben BIOS-Version und derselben Speicherkonfiguration, auf dem dieses Handbuch bereits abgeschlossen wurde.  Daher m√ºssen Sie im allgemeinen Fall durch Ausprobieren handeln.  Beim Neustart des BIOS werden die Daten in der Regel nur am Anfang und am Ende jedes Speicherbereichs ge√§ndert.  Normalerweise reicht es aus, 128 Megabyte ( <code>0x8000000</code> ) von den R√§ndern zur√ºckzuziehen.  F√ºr virtuelle KVM-Maschinen mit 1 GB Speicher oder mehr <code>memmap=4K$0x10000000</code> die vorgeschlagenen Optionen ( <code>memmap=4K$0x10000000</code> und <code>memmap=128M!0x10000000</code> ). </p><br><p>  Bei Verwendung des <code>phram</code> Moduls ben√∂tigen <code>phram</code> einen weiteren Kernel-Befehlszeilenparameter, der dem Modul tats√§chlich mitteilt, welcher physische Speicher verwendet werden soll - unser reservierter.  Der Parameter hei√üt <code>phram.phram</code> und besteht aus drei Teilen: dem Namen (beliebig bis zu 63 Zeichen, wird in <code>sysfs</code> ), der Startadresse und der L√§nge.  Die Startadresse und L√§nge m√ºssen mit der in <code>memmap</code> , die Suffixe <code>K</code> und <code>M</code> nicht unterst√ºtzt. </p><br><pre> <code class="plaintext hljs">GRUB_CMDLINE_LINUX="memmap=4K\\\$0x10000000 phram.phram=savedkey,0x10000000,4096 ..."</code> </pre> <br><p>  Nach dem Bearbeiten von <code>/etc/default/grub</code> Sie die reale Konfigurationsdatei neu generieren, die GRUB beim Booten liest.  Der richtige Befehl hierf√ºr h√§ngt von der Verteilung ab. </p><br><pre> <code class="plaintext hljs"># grub2-mkconfig -o /boot/grub2/grub.cfg # CentOS (Legacy BIOS) # grub2-mkconfig -o /boot/efi/EFI/centos/grub.cfg # CentOS (UEFI) # update-grub # Debian, Ubuntu # update-bootloader --reinit # SUSE</code> </pre> <br><p>  Nach dem Aktualisieren der GRUB-Konfiguration sollte der Computer neu gestartet werden. Wir werden dies jedoch sp√§ter tun, wenn wir initramfs aktualisieren. </p><br><h3 id="shag-chetvertyy-nastroit-luks-na-chtenie-klyucha-iz-pamyati">  Vierter Schritt: Konfigurieren Sie LUKS so, dass der Schl√ºssel aus dem Speicher gelesen wird </h3><br><p>  <code>/etc/crypttab</code> Einstellungen f√ºr die <code>/etc/crypttab</code> werden in der <code>/etc/crypttab</code> .  Jede Zeile besteht aus vier Feldern: </p><br><ul><li>  das Ger√§t, das beim Entsperren erhalten werden soll, </li><li>  verschl√ºsseltes Ger√§t </li><li>  Woher bekommt man die Schl√ºsseldatei ( <code>none</code> bedeutet, dass man eine Schl√ºsselphrase √ºber die Tastatur eingibt), </li><li>  optionales Feld f√ºr Optionen. </li></ul><br><p>  Wenn die Schl√ºsseldatei vorhanden ist, aber nicht passt, fragt Dracut nach der Schl√ºsselphrase.  Was in der Tat beim ersten Start erforderlich sein wird. </p><br><p>  Ein Beispiel f√ºr die <code>/etc/crypttab</code> aus einer frisch installierten Distribution: </p><br><pre> <code class="plaintext hljs"># cat /etc/crypttab #   luks-d07....69 UUID=d07....69 none</code> </pre> <br><p>  Die Schl√ºsseldatei in unserem Fall ist ein St√ºck physischen Speichers.  Das hei√üt,  <code>/dev/mem</code> , <code>/dev/mtd0</code> oder <code>/dev/pmem0</code> , abh√§ngig von der ausgew√§hlten Speicherzugriffstechnologie.  Optionen sind erforderlich, um anzugeben, welcher Teil der Datei der Schl√ºssel ist. </p><br><pre> <code class="plaintext hljs"># cat /etc/crypttab #   #   /dev/mem: luks-d07....69 UUID=d07....69 /dev/mem keyfile-offset=0x10000000,keyfile-size=16 #   phram: luks-d07....69 UUID=d07....69 /dev/mtd0 keyfile-size=16 #   nd_e820: luks-d07....69 UUID=d07....69 /dev/pmem0 keyfile-size=16</code> </pre> <br><p>  Das ist nur so, dass es so nicht funktioniert. </p><br><p>  Der Punkt ist, wie systemd bestimmt, wann ein Ger√§t entsperrt werden kann.  Er nimmt n√§mlich das Ger√§t aus der dritten Spalte und wartet darauf, dass die entsprechende Ger√§teeinheit aktiv wird.  Es scheint logisch: Es macht keinen Sinn, den LUKS-Container zu entsperren, bis ein Ger√§t mit einer Schl√ºsseldatei angezeigt wird.  Die Ger√§teeinheit ist jedoch nicht mit dem Ger√§t selbst identisch.  Systemd erstellt standardm√§√üig Ger√§teeinheiten nur f√ºr Kernelger√§te, die sich auf Subsysteme von Blockger√§ten und Netzwerkschnittstellen beziehen.  Die Ger√§te <code>/dev/mem</code> und <code>/dev/mtd0</code> sind <code>/dev/mtd0</code> , werden daher nicht standardm√§√üig √ºberwacht und werden niemals als bereit erkannt. </p><br><p>  Sie m√ºssen systemd mitteilen, dass er sie verfolgen soll, indem Sie udev-Regeln in der Datei <code>/etc/udev/rules.d/99-mem.rules</code> erstellen: </p><br><pre> <code class="plaintext hljs"># /dev/mem KERNEL=="mem", TAG+="systemd" # /dev/mtd* KERNEL=="mtd*", TAG+="systemd" #  /dev/pmem*      </code> </pre> <br><h3 id="shag-pyatyy-peregenerirovat-initramfs">  F√ºnfter Schritt: Initramfs neu generieren </h3><br><blockquote>  Ich erinnere Sie daran: Dieser Artikel behandelt nur Distributionen mit Dracut.  Einschlie√ülich solcher, bei denen es nicht standardm√§√üig verwendet wird, aber zug√§nglich und effizient ist. </blockquote><p>  Sie m√ºssen initramfs neu <code>/etc/crypttab</code> Datei <code>/etc/crypttab</code> dort zu aktualisieren.  Und auch - um dort zus√§tzliche Kernelmodule und udev-Regeln aufzunehmen.  Andernfalls wird das Ger√§t <code>/dev/mtd0</code> oder <code>/dev/pmem0</code> nicht erstellt.  Der Konfigurationsparameter Dracut <code>force_drivers</code> ist f√ºr das Aktivieren und Laden zus√§tzlicher Kernelmodule verantwortlich, und <code>install_items</code> ist f√ºr zus√§tzliche Dateien verantwortlich.  Wir erstellen die Datei <code>/etc/dracut.conf.d/mem.conf</code> mit folgendem Inhalt (ein Leerzeichen nach dem √∂ffnenden Anf√ºhrungszeichen ist erforderlich, dies ist ein Trennzeichen): </p><br><pre> <code class="plaintext hljs">#   /dev/mem: install_items+=" /etc/udev/rules.d/99-mem.rules" #   phram: install_items+=" /etc/udev/rules.d/99-mem.rules" force_drivers+=" phram" #   nd_e820: force_drivers+=" nd_e820 nd_pmem"</code> </pre> <br><p>  Eigentlich Regeneration initramfs: </p><br><pre> <code class="plaintext hljs"># dracut -f</code> </pre> <br><blockquote>  F√ºr Debian- und Ubuntu-Benutzer hat der Betreuer einen Rake gesetzt: Die resultierende Datei wird falsch aufgerufen.  Sie m√ºssen es umbenennen, damit es wie in der GRUB-Konfiguration beschrieben benannt wird: <br><pre> <code class="plaintext hljs"># mv /boot/initramfs-5.0.0-19-generic.img /boot/initrd.img-5.0.0-19-generic</code> </pre> <br><br>  Bei der Installation neuer Kernel wird die automatische Erstellung von initramfs √ºber Dracut korrekt ausgef√ºhrt. Der Fehler betrifft nur den manuellen Start von <code>dracut -f</code> . </blockquote><br><h3 id="shag-shestoy-perezagruzit-kompyuter">  Schritt 6: Starten Sie Ihren Computer neu </h3><br><p>  Ein Neustart ist erforderlich, damit die √Ñnderungen an der GRUB- und Dracut-Konfiguration wirksam werden. </p><br><pre> <code class="plaintext hljs"># reboot</code> </pre> <br><p>  Zu diesem Zeitpunkt befindet sich kein Schl√ºssel im Speicher, daher m√ºssen Sie eine Passphrase eingeben. </p><br><p>  Nach dem Neustart m√ºssen Sie √ºberpr√ºfen, ob die Speichersicherung ordnungsgem√§√ü funktioniert hat.  In der <code>/proc/iomem</code> gew√ºnschte Speicherort <code>/proc/iomem</code> als "reserviert" (bei Verwendung von <code>/dev/mem</code> oder <code>phram</code> ) oder als "persistenter Speicher (Legacy)" markiert sein. </p><br><p>  Wenn Sie <code>phram</code> oder <code>nd_e820</code> Sie sicherstellen, dass sich das Ger√§t <code>/dev/mtd0</code> oder <code>/dev/pmem0</code> wirklich auf den zuvor reservierten Teil des Speichers bezieht und nicht auf etwas anderes. </p><br><pre> <code class="plaintext hljs"># cat /sys/class/mtd/mtd0/name #  : "savedkey" # cat /sys/block/pmem0/device/resource #    </code> </pre> <br><p>  Wenn dies nicht der <code>/dev/mtd*</code> ist, m√ºssen Sie herausfinden, welches der Ger√§te <code>/dev/mtd*</code> oder <code>/dev/pmem*</code> "unser" ist, und dann / etc / crypttab reparieren, initramfs neu generieren und das Ergebnis nach einem weiteren Neustart erneut √ºberpr√ºfen. </p><br><h3 id="shag-sedmoy-nastroit-kopirovanie-klyuchevogo-fayla-v-pamyat">  Siebter Schritt: Konfigurieren Sie das Kopieren der Schl√ºsseldatei in den Speicher </h3><br><p>  Die Schl√ºsseldatei wird vor dem Neustart in den Speicher kopiert.  Eine M√∂glichkeit, einen Befehl in der Phase des Herunterfahrens des Systems auszuf√ºhren, besteht darin, ihn in der <code>ExecStop</code> Direktive im systemd-Dienst zu registrieren.  Damit systemd versteht, dass dies kein Daemon ist und nicht auf das Fehlen der <code>ExecStart</code> Direktive <code>ExecStart</code> , m√ºssen Sie den <code>ExecStart</code> als <code>ExecStart</code> angeben und vorschlagen, dass der Dienst ausgef√ºhrt wird, auch wenn ihm kein Arbeitsprozess zugeordnet ist.  Hier ist also die Datei <code>/etc/systemd/system/savekey.service</code> .  Es muss nur eine der angegebenen Varianten der <code>ExecStop</code> Direktive <code>ExecStop</code> . </p><br><pre> <code class="plaintext hljs">[Unit] Description=Saving LUKS key into RAM Documentation=https://habr.com/ru/post/457396/ [Service] Type=oneshot RemainAfterExit=true #   /dev/mem: ExecStop=/bin/sh -c 'dd if=/root/key of=/dev/mem bs=1 seek=$((0x10000000))' #   /dev/mtd0: ExecStop=/bin/dd if=/root/key of=/dev/mtd0 #   /dev/pmem0: ExecStop=/bin/dd if=/root/key of=/dev/pmem0 [Install] WantedBy=default.target</code> </pre> <br><p>  Die Konstruktion mit <code>/bin/sh</code> ben√∂tigt, da <code>dd</code> die hexadezimale Notation nicht versteht. </p><br><p>  Wir aktivieren den Service, √ºberpr√ºfen Sie: </p><br><pre> <code class="plaintext hljs"># systemctl enable savekey # systemctl start savekey # reboot</code> </pre> <br><p>  W√§hrend des anschlie√üenden Neustarts m√ºssen Sie die Passphrase nicht von der Festplatte eingeben.  Und falls erforderlich, bedeutet dies normalerweise, dass die Startadresse des reservierten Speicherbereichs falsch ausgew√§hlt ist.  Es ist in Ordnung, mehrere Dateien zu reparieren und neu zu generieren und den Computer zweimal neu zu starten. </p><br><p>  Bei Verwendung von <code>phram</code> oder <code>nd_e820</code> nur die GRUB-Konfiguration bearbeitet werden.  Bei Verwendung von <code>/dev/mem</code> Startadresse auch in <code>/etc/crypttab</code> (daher m√ºssen initramfs neu <code>/etc/crypttab</code> werden) und im systemd-Dienst erw√§hnt. </p><br><p>  Das ist aber noch nicht alles. </p><br><h3 id="voprosy-bezopasnosti">  Sicherheitsprobleme </h3><br><p>  Jede Diskussion √ºber Sicherheitsprobleme basiert auf einem Bedrohungsmodell.  Das hei√üt,  auf die Ziele und Mittel des Angreifers.  Mir ist bekannt, dass einige der folgenden Beispiele weit hergeholt sind. </p><br><p>  Situationen mit physischem Zugriff auf einen ausgeschalteten Computer unterscheiden sich nicht von Situationen ohne konfigurierten Schl√ºsselspeicher im Speicher.  Es gibt dieselben Arten von Angriffen, die darauf abzielen, Schl√ºsselbegriffe zu erhalten, einschlie√ülich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Evil Maid</a> , und dieselben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sicherheitsfunktionen</a> .  Wir h√∂ren nicht bei ihnen auf, da es nichts Neues gibt. </p><br><p>  Interessantere Situationen sind, wenn der Computer eingeschaltet ist. </p><br><p>  <strong>Situation 1</strong> .  Der Angreifer hat keinen physischen Zugriff auf den Computer, kennt die Passphrase nicht, hat jedoch Root-Zugriff √ºber ssh.  Das Ziel ist der Schl√ºssel zum Entschl√ºsseln der Festplatte.  Zum Beispiel, um auf alte sektorweise Sicherungen eines Festplattenabbilds einer virtuellen Maschine zuzugreifen. </p><br><p>  Tats√§chlich befindet sich der Schl√ºssel auf der Untertasse in der Datei <code>/root/key</code> .  Die Frage ist, in welcher Beziehung dies zu dem steht, was vor der Implementierung dieser Anweisung passiert ist.  Antwort: F√ºr luks1 ist die Bedrohung nicht neu.  Es gibt einen <code>dmsetup table --target crypt --showkeys</code> , der den Hauptschl√ºssel anzeigt, d. H.  auch Daten, die den Zugriff auf alte Backups erm√∂glichen.  F√ºr luks2 findet die Sicherheitsreduzierung in diesem Szenario tats√§chlich statt: dm-crypt-Schl√ºssel werden auf Kernelebene im Schl√ºsselbund gespeichert, und es ist unm√∂glich, sie aus dem Benutzerbereich heraus zu betrachten. </p><br><p>  <strong>Situation 2</strong> .  Der Angreifer kann die Tastatur verwenden und auf den Bildschirm schauen, ist jedoch nicht bereit, das Geh√§use zu √∂ffnen.  Zum Beispiel habe ich das durchgesickerte Passwort von IPMI verwendet oder eine noVNC-Sitzung in der Cloud abgefangen.  Er kennt den Schl√ºsselbegriff nicht, er kennt auch keine anderen Passw√∂rter.  Das Ziel ist der Root-Zugriff. </p><br><p>  Bitte: Starten Sie √ºber <code>Ctrl-Alt-Del</code> , und f√ºgen Sie die Kernel-Option <code>init=/bin/sh</code> √ºber GRUB hinzu.  Die Passphrase wurde nicht ben√∂tigt, da der Schl√ºssel erfolgreich aus dem Speicher gelesen wurde.  Um sich davor zu sch√ºtzen, m√ºssten Sie GRUB daran hindern, das zu laden, was nicht im Men√º enthalten ist.  Leider ist diese Funktionalit√§t in verschiedenen Distributionen unterschiedlich implementiert. </p><br><p>  Ab Version 7.2 verf√ºgt CentOS √ºber den <code>grub2-setpassword</code> , der GRUB tats√§chlich mit einem Kennwort sch√ºtzt.  Andere Distributionen verf√ºgen m√∂glicherweise √ºber eigene Dienstprogramme f√ºr dieselbe Aufgabe.  Wenn keine vorhanden sind, k√∂nnen Sie die Dateien im Verzeichnis <code>grub.cfg</code> direkt bearbeiten und <code>grub.cfg</code> . </p><br><p>  <code>/etc/grub.d/10_linux</code> Datei <code>/etc/grub.d/10_linux</code> die Variable CLASS und f√ºgen <code>--unrestricted</code> am Ende die Option <code>--unrestricted</code> , falls sie nicht vorhanden war: </p><br><pre> <code class="plaintext hljs">CLASS="--class gnu-linux --class gnu --class os --unrestricted"</code> </pre> <br><p>  <code>/etc/grub.d/40_custom</code> Datei <code>/etc/grub.d/40_custom</code> die Zeilen hinzu, in denen der Benutzername und das Kennwort angegeben sind, die zum Bearbeiten der Kernel-Befehlszeile erforderlich sind: </p><br><pre> <code class="plaintext hljs">set superusers="root" password_pbkdf2 root grub.pbkdf2....... #    grub2-mkpasswd-pbkdf2</code> </pre> <br><p>  Oder wenn eine solche Funktionalit√§t √ºberhaupt deaktiviert werden muss, ist hier eine Zeile wie diese: </p><br><pre> <code class="plaintext hljs">set superusers=""</code> </pre> <br><p>  <strong>Situation 3</strong> .  Der Angreifer hat Zugriff auf den mitgelieferten Computer, sodass Sie von nicht vertrauensw√ºrdigen Medien booten k√∂nnen.  Dies kann ein physischer Zugriff ohne √ñffnen des Geh√§uses oder ein Zugriff √ºber IPMI sein.  Das Ziel ist der Root-Zugriff. </p><br><p>  Es kann seinen GRUB von einem USB-Flash-Laufwerk oder einer CD-ROM laden und <code>init=/bin/sh</code> zu Ihren Kernel-Parametern hinzuf√ºgen, wie im vorherigen Beispiel.  Dementsprechend sollte das Booten von schrecklichen Medien im BIOS verboten werden.  Und sch√ºtzen Sie auch die √Ñnderung der BIOS-Einstellungen mit einem Passwort. </p><br><p>  <strong>Situation 4</strong> .  Der Angreifer hat physischen Zugriff auf den mitgelieferten Computer, einschlie√ülich der M√∂glichkeit, den Fall zu √∂ffnen.  Ziel ist es, den Schl√ºssel herauszufinden oder Root-Zugriff zu erhalten. </p><br><p>  Im Allgemeinen ist dies ohnehin eine Verlustsituation.  Der Angriff auf Speichermodule durch Abk√ºhlen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kaltstartangriff</a> ) wurde nicht abgebrochen.  Auch theoretisch (nicht √ºberpr√ºft) k√∂nnen Sie die Tatsache nutzen, dass moderne SATA-Festplatten Hot-Reconnection unterst√ºtzen.  Wenn Sie den Computer neu starten, trennen Sie die Festplatte, √§ndern Sie <code>grub.cfg</code> in <code>init=/bin/sh</code> , stellen Sie die Verbindung wieder her und lassen Sie das System neu starten.  Es stellt sich heraus (wenn ich es richtig verstehe), Root-Zugriff. </p><br><p>  Ungef√§hr das Gleiche kann ein skrupelloser Mitarbeiter eines Cloud-Hostings tun, indem er einen Schnappschuss einer virtuellen Maschine mit ihrer nachfolgenden √Ñnderung erstellt. </p><br><h3 id="prochie-voprosy">  Andere Angelegenheiten </h3><br><p>  <strong>Es ist ein Spott, den Schl√ºssel w√§hrend eines Neustarts im Speicher zu behalten.</strong>  <strong>Use-after-free in seiner reinsten Form.</strong>  <strong>Eine sauberere L√∂sung besteht darin, kexec zu verwenden und den Schl√ºssel zu dynamisch generierten initramfs hinzuzuf√ºgen.</strong>  <strong>Es sch√ºtzt auch vor dem Ersetzen von Kernel-Parametern</strong> .  Ja, wenn kexec funktioniert.  Moderne Distributionen haben die Kexec-Konfiguration <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zu kompliziert gemacht</a> . </p><br><p>  <strong>In Rechenzentren und vor allem in der Cloud verschwindet die Stromversorgung nie.</strong>  <strong>Es stellt sich heraus, dass der Schl√ºsselbegriff nicht mehr ben√∂tigt wird?</strong>  <em>Wenn</em> Sie sich dessen so sicher sind, k√∂nnen Sie es l√∂schen.  Es wird sich herausstellen, dass es sich um einen funktionierenden Server handelt, dessen Schl√ºssel f√ºr die Festplatte niemand kennt¬π und der daher nicht ausgegeben wird, sondern dessen System mit regul√§ren Mitteln aktualisiert werden kann.    ‚Äî        <code>sudo poweroff</code> . </p><br><p> ¬π    <code>/root/key</code> ‚Äî         ,        cron. </p><br><p> <strong>   ?  IPMI,       </strong> .    IPMI      Java.        . </p><br><p> <strong>   ?     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> SSH</a></strong> . !    .  ,      <code>sudo reboot</code> ,      ? </p><br><p>             ,         .     SSH       ,      .       ,      ,   . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457396/">https://habr.com/ru/post/de457396/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457380/index.html">Ultramodernes OpenGL. Teil 2</a></li>
<li><a href="../de457382/index.html">7 Gewohnheiten von Hochleistungsprogrammierern</a></li>
<li><a href="../de457386/index.html">Einf√ºhrung in virtuelle Linux-Schnittstellen: Tunnel</a></li>
<li><a href="../de457390/index.html">Madagaskar - Insel der Kontraste</a></li>
<li><a href="../de457392/index.html">Einsparungen bei der plattform√ºbergreifenden mobilen Entwicklung: Skyeng-Fallstudie</a></li>
<li><a href="../de457398/index.html">Aber mache ich Bullshit? Warum gehen Entwickler zu gemba?</a></li>
<li><a href="../de457400/index.html">Die Zahl der Opfer von Atomkatastrophen wie Tschernobyl ist f√ºr das Drama stark √ºbertrieben</a></li>
<li><a href="../de457402/index.html">So organisieren Sie die Entwicklung und Unterst√ºtzung eines Blogs in WordPress in 2Q19 und beheben es nicht</a></li>
<li><a href="../de457404/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 465 (06/11/2019 - 06/17/2019)</a></li>
<li><a href="../de457406/index.html">Wie viel verdienen Absolventen verschiedener russischer Universit√§ten?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>