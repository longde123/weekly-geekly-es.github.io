<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌙 ✌🏾 🙅 Automatisches Entsperren des Root-LUKS-Containers nach einem Hot-Boot 🏜️ 🔄 🐾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Warum verschlüsseln Menschen im Allgemeinen Laufwerke ihrer PCs und manchmal auch Server? Es ist klar, dass niemand Fotos seiner Lieblingskatzen von d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Automatisches Entsperren des Root-LUKS-Containers nach einem Hot-Boot</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457396/"><p>  Warum verschlüsseln Menschen im Allgemeinen Laufwerke ihrer PCs und manchmal auch Server?  Es ist klar, dass niemand Fotos seiner Lieblingskatzen von der Festplatte gestohlen hat!  Das ist nur Pech: Bei einem verschlüsselten Laufwerk müssen Sie bei jedem Start eine Schlüsselphrase über die Tastatur eingeben. Das ist lang und langweilig.  Um es so zu entfernen, dass es zumindest manchmal nicht notwendig wäre, es zu rekrutieren.  Ja, damit die Bedeutung der Verschlüsselung nicht verloren geht. </p><br><div class="spoiler">  <b class="spoiler_title">Katze für Aufmerksamkeit</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sr/rt/ny/srrtnywyggbrscsufm8ux8tvxmu.jpeg" alt="Cat"></p></div></div><br><p>  Nun, vollständig entfernen wird es nicht funktionieren.  Sie können stattdessen eine Schlüsseldatei auf einem USB-Flash-Laufwerk erstellen, und es funktioniert auch.  Und ohne Flash-Laufwerk (und ohne zweiten Computer im Netzwerk) ist das möglich?  Wenn Sie Glück mit dem BIOS haben, können Sie fast!  Unter dem Schnitt finden Sie eine Anleitung zum Konfigurieren der Festplattenverschlüsselung über LUKS mit den folgenden Eigenschaften: </p><br><ol><li> Die Passphrase oder Schlüsseldatei wird beim Ausschalten des Computers nirgendwo in offener Form (oder in der Form, die dem Öffnen entspricht) gespeichert. </li><li>  Wenn Sie Ihren Computer zum ersten Mal einschalten, müssen Sie eine Passphrase eingeben. </li><li>  Bei nachfolgenden Neustarts (vor dem Herunterfahren) ist keine Passphrase erforderlich. </li></ol><br><p>  Die Anweisungen wurden unter CentOS 7.6, Ubuntu 19.04 und openSUSE Leap 15.1 in virtuellen Maschinen und auf realer Hardware (Desktop, Laptop und zwei Server) getestet.  Sie sollten auf anderen Distributionen funktionieren, die eine funktionierende Version von Dracut haben. </p><br><p>  Und ja, in guter Weise hätte dies im Hub "Anormale Systemadministration" enden sollen, aber es gibt keinen solchen Hub. </p><a name="habracut"></a><br><p>  Ich schlage vor, einen separaten Steckplatz im LUKS-Container zu verwenden und den Schlüssel dazu zu speichern ... im RAM! </p><br><div class="spoiler">  <b class="spoiler_title">Was für ein Slot?</b> <div class="spoiler_text"><p> Der LUKS-Container implementiert eine mehrstufige Verschlüsselung.  Nützliche Daten auf der Festplatte werden mit einer symmetrischen Verschlüsselung verschlüsselt, normalerweise <code>aes-xts-plain64</code> .  Der Schlüssel zu dieser symmetrischen Verschlüsselung (Hauptschlüssel) wird in der Phase der Containererstellung als zufällige Folge von Bytes generiert.  Der Hauptschlüssel wird im Allgemeinen in verschlüsselter Form gespeichert - in mehreren Kopien (Slots).  Standardmäßig ist nur einer der acht Steckplätze aktiv.  Jeder aktive Steckplatz verfügt über eine separate Schlüsselphrase (oder eine separate Schlüsseldatei), mit der Sie den Hauptschlüssel entschlüsseln können.  Aus Sicht des Benutzers stellt sich heraus, dass Sie das Laufwerk mit mehreren verschiedenen Schlüsselphrasen (oder Schlüsseldateien) entsperren können.  In unserem Fall verwenden Sie eine Schlüsselphrase (Steckplatz 0) oder einen Speicher, der als Schlüsseldatei verwendet wird (Steckplatz 6). </p></div></div><br><p>  Das BIOS auf den meisten Motherboards bereinigt den Speicher beim Neustart nicht oder Sie können ihn so konfigurieren, dass er nicht bereinigt wird (bekannte Ausnahme: "Intel Corporation S1200SP / S1200SP, BIOS S1200SP.86B.03.01.0042.013020190050 30.01.2019").  Daher können Sie den Schlüssel dort speichern.  Wenn das Gerät ausgeschaltet wird, wird der Inhalt des RAM selbst nach einer Weile zusammen mit einer ungeschützten Kopie des Schlüssels gelöscht. </p><br><p>  Also lass uns gehen. </p><br><h3 id="shag-pervyy-ustanovit-sistemu-na-zashifrovannyy-s-pomoschyu-luks-disk">  Schritt eins: Installieren Sie das System auf einer mit LUKS verschlüsselten Festplatte </h3><br><p>  In diesem Fall sollte die in <code>/boot</code> gemountete Festplattenpartition (z. B. <code>/dev/sda1</code> ) unverschlüsselt bleiben und die andere Partition, auf der alles andere (z. B. <code>/dev/sda2</code> ) verschlüsselt werden soll.  Das Dateisystem auf der verschlüsselten Partition kann ein beliebiges sein. Sie können auch LVM verwenden, sodass sich das Root-Dateisystem, das Swap-Volume und alles andere außer <code>/boot</code> im selben Container befinden.  Dies entspricht der Standardfestplattenpartitionierung in CentOS 7 und Debian bei Auswahl der Verschlüsselungsoption.  SUSE macht alles anders (verschlüsselt <code>/boot</code> ) und erfordert daher eine manuelle Partitionierung der Festplatte. </p><br><p>  Das Ergebnis sollte ungefähr so ​​aussehen: </p><br><pre> <code class="plaintext hljs">$ lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 10G 0 disk ├─sda1 8:1 0 1G 0 part /boot └─sda2 8:2 0 9G 0 part └─luks-d07a97d7-3258-408c-a17c-e2fb56701c69 253:0 0 9G 0 crypt ├─centos_centos--encrypt2-root 253:1 0 8G 0 lvm / └─centos_centos--encrypt2-swap 253:2 0 1G 0 lvm [SWAP]</code> </pre> <br><p>  Bei Verwendung von UEFI wird es auch eine EFI-Systempartition geben. </p><br><blockquote>  Für Debian- und Ubuntu-Benutzer: Ersetzen Sie das Paket <code>initramfs-tools</code> durch <code>dracut</code> . <br><pre> <code class="plaintext hljs"># apt install --no-install-recommends dracut</code> </pre> <br><br>  <code>initramfs-tools</code> implementiert in unserem Fall eine falsche Logik, die auf verschlüsselte Abschnitte mit einer Schlüsseldatei angewendet wird.  Solche Abschnitte werden entweder vollständig ignoriert oder der Inhalt der Schlüsseldatei wird im Klartext in initramfs (d. H. Als Ergebnis auf die Festplatte) kopiert, was wir nicht benötigen. </blockquote><br><h3 id="shag-vtoroy-sozdat-klyuchevoy-fayl-kotoryy-budet-ispolzovatsya-dlya-avtomaticheskogo-razblokirovaniya-diska-posle-goryachey-perezagruzki">  Schritt 2: Erstellen Sie eine Schlüsseldatei, mit der das Laufwerk nach einem Hot-Neustart automatisch entsperrt wird </h3><br><p>  128 zufällige Bits reichen für uns aus, d.h.  16 Bytes.  Die Datei wird auf einer verschlüsselten Festplatte gespeichert, sodass niemand, der den Verschlüsselungsschlüssel nicht kennt und keinen Root-Zugriff auf das geladene System hat, ihn nicht liest. </p><br><pre> <code class="plaintext hljs"># touch -m 0600 /root/key # head -c16 /dev/urandom &gt; /root/key</code> </pre> <br><p>  Die Schlüsseldatei enthält genügend wirklich zufällige Bits, sodass der langsame PBKDF-Algorithmus, der einen schwer zu wählenden Verschlüsselungsschlüssel aus einer möglicherweise schwachen Schlüsselphrase erstellt, nicht wirklich benötigt wird.  Daher können Sie beim Hinzufügen eines Schlüssels die Anzahl der Iterationen reduzieren: </p><br><pre> <code class="plaintext hljs"># cryptsetup luksAddKey --key-slot=6 --iter-time=1 /dev/sda2 /root/key Enter any existing passphrase:</code> </pre> <br><p>  Wie Sie sehen, wird die Schlüsseldatei auf einer verschlüsselten Festplatte gespeichert und stellt daher kein Sicherheitsrisiko dar, wenn der Computer ausgeschaltet wird. </p><br><h3 id="shag-tretiy-vydelit-mesto-v-fizicheskoy-pamyati-dlya-hraneniya-klyucha">  Schritt 3: Weisen Sie Speicherplatz im physischen Speicher zu, um den Schlüssel zu speichern </h3><br><p>  Linux verfügt über mindestens drei verschiedene Treiber, mit denen Sie unter einer bekannten Adresse auf den physischen Speicher zugreifen können.  Dies ist <code>linux/drivers/char/mem.c</code> , das auch für das Gerät <code>/dev/mem</code> , sowie <code>phram</code> Module (emuliert einen MTD-Chip, gibt das Gerät <code>/dev/mtd0</code> ) und <code>nd_e820</code> (wird bei der Arbeit mit NVDIMM verwendet, gibt <code>/dev/pmem0</code> ).  Sie alle haben ihre unangenehmen Eigenschaften: </p><br><ul><li>  <code>/dev/mem</code> bei Verwendung von Secure Boot nicht beschreibbar, wenn die Distribution <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das LOCKDOWN-Patch-Set</a> von Matthew Garrett verwendet (und dieses Patch-Set ist erforderlich, wenn die Distribution Secure Boot mit einem von Microsoft signierten Bootloader unterstützen soll). </li><li>  <code>phram</code> unter CentOS und Fedora nicht verfügbar - der Betreuer hat die entsprechende Option beim <code>phram</code> des Kernels einfach nicht aktiviert. </li><li>  <code>nd_e820</code> muss mindestens 128 Megabyte Speicher reservieren - so funktioniert NVDIMM.  Dies ist jedoch die einzige Option, die unter CentOS mit Secure Boot ausgeführt wird. </li></ul><br><p>  Da es keine ideale Option gibt, werden alle drei unten betrachtet. </p><br><blockquote>  Bei Verwendung einer der Methoden ist äußerste Vorsicht geboten, um andere Geräte oder Speicherbereiche als die erforderlichen nicht versehentlich zu beeinträchtigen.  Dies gilt insbesondere für Computer, die bereits über MTD-Chips oder NVDIMM-Module verfügen.  <code>/dev/mtd0</code> oder <code>/dev/pmem0</code> möglicherweise nicht das Gerät, das dem Speicherbereich entspricht, der zum Speichern des Schlüssels reserviert ist.  Die Nummerierung vorhandener Geräte, auf die sich Konfigurationsdateien und Skripte stützen, kann ebenfalls verwechselt werden.  Dementsprechend wird empfohlen, alle Dienste, die auf vorhandenen Geräten <code>/dev/mtd*</code> und <code>/dev/pmem*</code> , vorübergehend zu deaktivieren. </blockquote><p>  Der physische Linux-Speicher wird <code>memmap</code> indem die <code>memmap</code> Option an den <code>memmap</code> .  Wir sind an zwei Arten dieser Option interessiert: </p><br><ul><li>  <code>memmap=4K$0x10000000</code> reserviert (d. <code>memmap=4K$0x10000000</code> . Markierungen sind reserviert, damit der Kernel selbst keine verwendet) 4 Kilobyte Speicher, beginnend mit der physischen Adresse 0x10000000; </li><li>  <code>memmap=128M!0x10000000</code> markiert 128 Megabyte physischen Speicher, beginnend bei der Adresse 0x10000000, als NVDIMM (offensichtlich falsch, aber für uns ausreichend). </li></ul><br><p>  Die Option c <code>$</code> ist für die Verwendung mit <code>/dev/mem</code> und <code>phram</code> , die Option c <code>!</code>  - für <code>nd_e820</code> .  Bei Verwendung von <code>$</code> Startadresse des reservierten Speichers ein Vielfaches von <code>0x1000</code> (d. H. 4 Kilobyte) sein, wenn <code>!</code>  - ein Vielfaches von <code>0x8000000</code> (d. <code>0x8000000</code> . 128 Megabyte). </p><br><p>  Wichtig: Das Dollarzeichen ( <code>$</code> ) in den GRUB-Konfigurationsdateien ist ein Sonderzeichen und muss maskiert werden.  Und zweimal: einmal - beim Generieren von <code>grub.cfg</code> aus <code>/etc/default/grub</code> , ein zweites Mal - beim Interpretieren der resultierenden Konfigurationsdatei beim Booten.  Das heißt,  In <code>/etc/default/grub</code> sollte eventuell die folgende Zeile erscheinen: </p><br><pre> <code class="plaintext hljs">GRUB_CMDLINE_LINUX="memmap=4K\\\$0x10000000 ...  ..."</code> </pre> <br><p>  Ohne das <code>$</code> -Zeichen doppelt zu umgehen, startet das System einfach nicht, da es denkt, dass es nur 4 Kilobyte Speicher hat.  Es gibt keine derartigen Schwierigkeiten mit einem Ausrufezeichen: </p><br><pre> <code class="plaintext hljs">GRUB_CMDLINE_LINUX="memmap=128M!0x10000000 ...  ..."</code> </pre> <br><p>  Die physische Speicherkarte (und es wird benötigt, um herauszufinden, welche Adressen reserviert werden sollen) ist für den <code>root</code> in der <code>/proc/iomem</code> : </p><br><pre> <code class="plaintext hljs"># cat /proc/iomem ... 000f0000-000fffff : reserved 000f0000-000fffff : System ROM 00100000-7ffddfff : System RAM 2b000000-350fffff : Crash kernel 73a00000-7417c25e : Kernel code 7417c25f-747661ff : Kernel data 74945000-74c50fff : Kernel bss 7ffde000-7fffffff : reserved 80000000-febfffff : PCI Bus 0000:00 fd000000-fdffffff : 0000:00:02.0 ...</code> </pre> <br><p>  Der RAM ist als "System RAM" gekennzeichnet. Es reicht aus, eine seiner Seiten für die Speicherung des Schlüssels zu reservieren.  Das Erraten, welcher Teil des BIOS-Speichers beim Neustart nicht berührt wird, funktioniert im Voraus nicht zuverlässig.  Es sei denn, es gibt einen anderen Computer mit genau derselben BIOS-Version und derselben Speicherkonfiguration, auf dem dieses Handbuch bereits abgeschlossen wurde.  Daher müssen Sie im allgemeinen Fall durch Ausprobieren handeln.  Beim Neustart des BIOS werden die Daten in der Regel nur am Anfang und am Ende jedes Speicherbereichs geändert.  Normalerweise reicht es aus, 128 Megabyte ( <code>0x8000000</code> ) von den Rändern zurückzuziehen.  Für virtuelle KVM-Maschinen mit 1 GB Speicher oder mehr <code>memmap=4K$0x10000000</code> die vorgeschlagenen Optionen ( <code>memmap=4K$0x10000000</code> und <code>memmap=128M!0x10000000</code> ). </p><br><p>  Bei Verwendung des <code>phram</code> Moduls benötigen <code>phram</code> einen weiteren Kernel-Befehlszeilenparameter, der dem Modul tatsächlich mitteilt, welcher physische Speicher verwendet werden soll - unser reservierter.  Der Parameter heißt <code>phram.phram</code> und besteht aus drei Teilen: dem Namen (beliebig bis zu 63 Zeichen, wird in <code>sysfs</code> ), der Startadresse und der Länge.  Die Startadresse und Länge müssen mit der in <code>memmap</code> , die Suffixe <code>K</code> und <code>M</code> nicht unterstützt. </p><br><pre> <code class="plaintext hljs">GRUB_CMDLINE_LINUX="memmap=4K\\\$0x10000000 phram.phram=savedkey,0x10000000,4096 ..."</code> </pre> <br><p>  Nach dem Bearbeiten von <code>/etc/default/grub</code> Sie die reale Konfigurationsdatei neu generieren, die GRUB beim Booten liest.  Der richtige Befehl hierfür hängt von der Verteilung ab. </p><br><pre> <code class="plaintext hljs"># grub2-mkconfig -o /boot/grub2/grub.cfg # CentOS (Legacy BIOS) # grub2-mkconfig -o /boot/efi/EFI/centos/grub.cfg # CentOS (UEFI) # update-grub # Debian, Ubuntu # update-bootloader --reinit # SUSE</code> </pre> <br><p>  Nach dem Aktualisieren der GRUB-Konfiguration sollte der Computer neu gestartet werden. Wir werden dies jedoch später tun, wenn wir initramfs aktualisieren. </p><br><h3 id="shag-chetvertyy-nastroit-luks-na-chtenie-klyucha-iz-pamyati">  Vierter Schritt: Konfigurieren Sie LUKS so, dass der Schlüssel aus dem Speicher gelesen wird </h3><br><p>  <code>/etc/crypttab</code> Einstellungen für die <code>/etc/crypttab</code> werden in der <code>/etc/crypttab</code> .  Jede Zeile besteht aus vier Feldern: </p><br><ul><li>  das Gerät, das beim Entsperren erhalten werden soll, </li><li>  verschlüsseltes Gerät </li><li>  Woher bekommt man die Schlüsseldatei ( <code>none</code> bedeutet, dass man eine Schlüsselphrase über die Tastatur eingibt), </li><li>  optionales Feld für Optionen. </li></ul><br><p>  Wenn die Schlüsseldatei vorhanden ist, aber nicht passt, fragt Dracut nach der Schlüsselphrase.  Was in der Tat beim ersten Start erforderlich sein wird. </p><br><p>  Ein Beispiel für die <code>/etc/crypttab</code> aus einer frisch installierten Distribution: </p><br><pre> <code class="plaintext hljs"># cat /etc/crypttab #   luks-d07....69 UUID=d07....69 none</code> </pre> <br><p>  Die Schlüsseldatei in unserem Fall ist ein Stück physischen Speichers.  Das heißt,  <code>/dev/mem</code> , <code>/dev/mtd0</code> oder <code>/dev/pmem0</code> , abhängig von der ausgewählten Speicherzugriffstechnologie.  Optionen sind erforderlich, um anzugeben, welcher Teil der Datei der Schlüssel ist. </p><br><pre> <code class="plaintext hljs"># cat /etc/crypttab #   #   /dev/mem: luks-d07....69 UUID=d07....69 /dev/mem keyfile-offset=0x10000000,keyfile-size=16 #   phram: luks-d07....69 UUID=d07....69 /dev/mtd0 keyfile-size=16 #   nd_e820: luks-d07....69 UUID=d07....69 /dev/pmem0 keyfile-size=16</code> </pre> <br><p>  Das ist nur so, dass es so nicht funktioniert. </p><br><p>  Der Punkt ist, wie systemd bestimmt, wann ein Gerät entsperrt werden kann.  Er nimmt nämlich das Gerät aus der dritten Spalte und wartet darauf, dass die entsprechende Geräteeinheit aktiv wird.  Es scheint logisch: Es macht keinen Sinn, den LUKS-Container zu entsperren, bis ein Gerät mit einer Schlüsseldatei angezeigt wird.  Die Geräteeinheit ist jedoch nicht mit dem Gerät selbst identisch.  Systemd erstellt standardmäßig Geräteeinheiten nur für Kernelgeräte, die sich auf Subsysteme von Blockgeräten und Netzwerkschnittstellen beziehen.  Die Geräte <code>/dev/mem</code> und <code>/dev/mtd0</code> sind <code>/dev/mtd0</code> , werden daher nicht standardmäßig überwacht und werden niemals als bereit erkannt. </p><br><p>  Sie müssen systemd mitteilen, dass er sie verfolgen soll, indem Sie udev-Regeln in der Datei <code>/etc/udev/rules.d/99-mem.rules</code> erstellen: </p><br><pre> <code class="plaintext hljs"># /dev/mem KERNEL=="mem", TAG+="systemd" # /dev/mtd* KERNEL=="mtd*", TAG+="systemd" #  /dev/pmem*      </code> </pre> <br><h3 id="shag-pyatyy-peregenerirovat-initramfs">  Fünfter Schritt: Initramfs neu generieren </h3><br><blockquote>  Ich erinnere Sie daran: Dieser Artikel behandelt nur Distributionen mit Dracut.  Einschließlich solcher, bei denen es nicht standardmäßig verwendet wird, aber zugänglich und effizient ist. </blockquote><p>  Sie müssen initramfs neu <code>/etc/crypttab</code> Datei <code>/etc/crypttab</code> dort zu aktualisieren.  Und auch - um dort zusätzliche Kernelmodule und udev-Regeln aufzunehmen.  Andernfalls wird das Gerät <code>/dev/mtd0</code> oder <code>/dev/pmem0</code> nicht erstellt.  Der Konfigurationsparameter Dracut <code>force_drivers</code> ist für das Aktivieren und Laden zusätzlicher Kernelmodule verantwortlich, und <code>install_items</code> ist für zusätzliche Dateien verantwortlich.  Wir erstellen die Datei <code>/etc/dracut.conf.d/mem.conf</code> mit folgendem Inhalt (ein Leerzeichen nach dem öffnenden Anführungszeichen ist erforderlich, dies ist ein Trennzeichen): </p><br><pre> <code class="plaintext hljs">#   /dev/mem: install_items+=" /etc/udev/rules.d/99-mem.rules" #   phram: install_items+=" /etc/udev/rules.d/99-mem.rules" force_drivers+=" phram" #   nd_e820: force_drivers+=" nd_e820 nd_pmem"</code> </pre> <br><p>  Eigentlich Regeneration initramfs: </p><br><pre> <code class="plaintext hljs"># dracut -f</code> </pre> <br><blockquote>  Für Debian- und Ubuntu-Benutzer hat der Betreuer einen Rake gesetzt: Die resultierende Datei wird falsch aufgerufen.  Sie müssen es umbenennen, damit es wie in der GRUB-Konfiguration beschrieben benannt wird: <br><pre> <code class="plaintext hljs"># mv /boot/initramfs-5.0.0-19-generic.img /boot/initrd.img-5.0.0-19-generic</code> </pre> <br><br>  Bei der Installation neuer Kernel wird die automatische Erstellung von initramfs über Dracut korrekt ausgeführt. Der Fehler betrifft nur den manuellen Start von <code>dracut -f</code> . </blockquote><br><h3 id="shag-shestoy-perezagruzit-kompyuter">  Schritt 6: Starten Sie Ihren Computer neu </h3><br><p>  Ein Neustart ist erforderlich, damit die Änderungen an der GRUB- und Dracut-Konfiguration wirksam werden. </p><br><pre> <code class="plaintext hljs"># reboot</code> </pre> <br><p>  Zu diesem Zeitpunkt befindet sich kein Schlüssel im Speicher, daher müssen Sie eine Passphrase eingeben. </p><br><p>  Nach dem Neustart müssen Sie überprüfen, ob die Speichersicherung ordnungsgemäß funktioniert hat.  In der <code>/proc/iomem</code> gewünschte Speicherort <code>/proc/iomem</code> als "reserviert" (bei Verwendung von <code>/dev/mem</code> oder <code>phram</code> ) oder als "persistenter Speicher (Legacy)" markiert sein. </p><br><p>  Wenn Sie <code>phram</code> oder <code>nd_e820</code> Sie sicherstellen, dass sich das Gerät <code>/dev/mtd0</code> oder <code>/dev/pmem0</code> wirklich auf den zuvor reservierten Teil des Speichers bezieht und nicht auf etwas anderes. </p><br><pre> <code class="plaintext hljs"># cat /sys/class/mtd/mtd0/name #  : "savedkey" # cat /sys/block/pmem0/device/resource #    </code> </pre> <br><p>  Wenn dies nicht der <code>/dev/mtd*</code> ist, müssen Sie herausfinden, welches der Geräte <code>/dev/mtd*</code> oder <code>/dev/pmem*</code> "unser" ist, und dann / etc / crypttab reparieren, initramfs neu generieren und das Ergebnis nach einem weiteren Neustart erneut überprüfen. </p><br><h3 id="shag-sedmoy-nastroit-kopirovanie-klyuchevogo-fayla-v-pamyat">  Siebter Schritt: Konfigurieren Sie das Kopieren der Schlüsseldatei in den Speicher </h3><br><p>  Die Schlüsseldatei wird vor dem Neustart in den Speicher kopiert.  Eine Möglichkeit, einen Befehl in der Phase des Herunterfahrens des Systems auszuführen, besteht darin, ihn in der <code>ExecStop</code> Direktive im systemd-Dienst zu registrieren.  Damit systemd versteht, dass dies kein Daemon ist und nicht auf das Fehlen der <code>ExecStart</code> Direktive <code>ExecStart</code> , müssen Sie den <code>ExecStart</code> als <code>ExecStart</code> angeben und vorschlagen, dass der Dienst ausgeführt wird, auch wenn ihm kein Arbeitsprozess zugeordnet ist.  Hier ist also die Datei <code>/etc/systemd/system/savekey.service</code> .  Es muss nur eine der angegebenen Varianten der <code>ExecStop</code> Direktive <code>ExecStop</code> . </p><br><pre> <code class="plaintext hljs">[Unit] Description=Saving LUKS key into RAM Documentation=https://habr.com/ru/post/457396/ [Service] Type=oneshot RemainAfterExit=true #   /dev/mem: ExecStop=/bin/sh -c 'dd if=/root/key of=/dev/mem bs=1 seek=$((0x10000000))' #   /dev/mtd0: ExecStop=/bin/dd if=/root/key of=/dev/mtd0 #   /dev/pmem0: ExecStop=/bin/dd if=/root/key of=/dev/pmem0 [Install] WantedBy=default.target</code> </pre> <br><p>  Die Konstruktion mit <code>/bin/sh</code> benötigt, da <code>dd</code> die hexadezimale Notation nicht versteht. </p><br><p>  Wir aktivieren den Service, überprüfen Sie: </p><br><pre> <code class="plaintext hljs"># systemctl enable savekey # systemctl start savekey # reboot</code> </pre> <br><p>  Während des anschließenden Neustarts müssen Sie die Passphrase nicht von der Festplatte eingeben.  Und falls erforderlich, bedeutet dies normalerweise, dass die Startadresse des reservierten Speicherbereichs falsch ausgewählt ist.  Es ist in Ordnung, mehrere Dateien zu reparieren und neu zu generieren und den Computer zweimal neu zu starten. </p><br><p>  Bei Verwendung von <code>phram</code> oder <code>nd_e820</code> nur die GRUB-Konfiguration bearbeitet werden.  Bei Verwendung von <code>/dev/mem</code> Startadresse auch in <code>/etc/crypttab</code> (daher müssen initramfs neu <code>/etc/crypttab</code> werden) und im systemd-Dienst erwähnt. </p><br><p>  Das ist aber noch nicht alles. </p><br><h3 id="voprosy-bezopasnosti">  Sicherheitsprobleme </h3><br><p>  Jede Diskussion über Sicherheitsprobleme basiert auf einem Bedrohungsmodell.  Das heißt,  auf die Ziele und Mittel des Angreifers.  Mir ist bekannt, dass einige der folgenden Beispiele weit hergeholt sind. </p><br><p>  Situationen mit physischem Zugriff auf einen ausgeschalteten Computer unterscheiden sich nicht von Situationen ohne konfigurierten Schlüsselspeicher im Speicher.  Es gibt dieselben Arten von Angriffen, die darauf abzielen, Schlüsselbegriffe zu erhalten, einschließlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Evil Maid</a> , und dieselben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sicherheitsfunktionen</a> .  Wir hören nicht bei ihnen auf, da es nichts Neues gibt. </p><br><p>  Interessantere Situationen sind, wenn der Computer eingeschaltet ist. </p><br><p>  <strong>Situation 1</strong> .  Der Angreifer hat keinen physischen Zugriff auf den Computer, kennt die Passphrase nicht, hat jedoch Root-Zugriff über ssh.  Das Ziel ist der Schlüssel zum Entschlüsseln der Festplatte.  Zum Beispiel, um auf alte sektorweise Sicherungen eines Festplattenabbilds einer virtuellen Maschine zuzugreifen. </p><br><p>  Tatsächlich befindet sich der Schlüssel auf der Untertasse in der Datei <code>/root/key</code> .  Die Frage ist, in welcher Beziehung dies zu dem steht, was vor der Implementierung dieser Anweisung passiert ist.  Antwort: Für luks1 ist die Bedrohung nicht neu.  Es gibt einen <code>dmsetup table --target crypt --showkeys</code> , der den Hauptschlüssel anzeigt, d. H.  auch Daten, die den Zugriff auf alte Backups ermöglichen.  Für luks2 findet die Sicherheitsreduzierung in diesem Szenario tatsächlich statt: dm-crypt-Schlüssel werden auf Kernelebene im Schlüsselbund gespeichert, und es ist unmöglich, sie aus dem Benutzerbereich heraus zu betrachten. </p><br><p>  <strong>Situation 2</strong> .  Der Angreifer kann die Tastatur verwenden und auf den Bildschirm schauen, ist jedoch nicht bereit, das Gehäuse zu öffnen.  Zum Beispiel habe ich das durchgesickerte Passwort von IPMI verwendet oder eine noVNC-Sitzung in der Cloud abgefangen.  Er kennt den Schlüsselbegriff nicht, er kennt auch keine anderen Passwörter.  Das Ziel ist der Root-Zugriff. </p><br><p>  Bitte: Starten Sie über <code>Ctrl-Alt-Del</code> , und fügen Sie die Kernel-Option <code>init=/bin/sh</code> über GRUB hinzu.  Die Passphrase wurde nicht benötigt, da der Schlüssel erfolgreich aus dem Speicher gelesen wurde.  Um sich davor zu schützen, müssten Sie GRUB daran hindern, das zu laden, was nicht im Menü enthalten ist.  Leider ist diese Funktionalität in verschiedenen Distributionen unterschiedlich implementiert. </p><br><p>  Ab Version 7.2 verfügt CentOS über den <code>grub2-setpassword</code> , der GRUB tatsächlich mit einem Kennwort schützt.  Andere Distributionen verfügen möglicherweise über eigene Dienstprogramme für dieselbe Aufgabe.  Wenn keine vorhanden sind, können Sie die Dateien im Verzeichnis <code>grub.cfg</code> direkt bearbeiten und <code>grub.cfg</code> . </p><br><p>  <code>/etc/grub.d/10_linux</code> Datei <code>/etc/grub.d/10_linux</code> die Variable CLASS und fügen <code>--unrestricted</code> am Ende die Option <code>--unrestricted</code> , falls sie nicht vorhanden war: </p><br><pre> <code class="plaintext hljs">CLASS="--class gnu-linux --class gnu --class os --unrestricted"</code> </pre> <br><p>  <code>/etc/grub.d/40_custom</code> Datei <code>/etc/grub.d/40_custom</code> die Zeilen hinzu, in denen der Benutzername und das Kennwort angegeben sind, die zum Bearbeiten der Kernel-Befehlszeile erforderlich sind: </p><br><pre> <code class="plaintext hljs">set superusers="root" password_pbkdf2 root grub.pbkdf2....... #    grub2-mkpasswd-pbkdf2</code> </pre> <br><p>  Oder wenn eine solche Funktionalität überhaupt deaktiviert werden muss, ist hier eine Zeile wie diese: </p><br><pre> <code class="plaintext hljs">set superusers=""</code> </pre> <br><p>  <strong>Situation 3</strong> .  Der Angreifer hat Zugriff auf den mitgelieferten Computer, sodass Sie von nicht vertrauenswürdigen Medien booten können.  Dies kann ein physischer Zugriff ohne Öffnen des Gehäuses oder ein Zugriff über IPMI sein.  Das Ziel ist der Root-Zugriff. </p><br><p>  Es kann seinen GRUB von einem USB-Flash-Laufwerk oder einer CD-ROM laden und <code>init=/bin/sh</code> zu Ihren Kernel-Parametern hinzufügen, wie im vorherigen Beispiel.  Dementsprechend sollte das Booten von schrecklichen Medien im BIOS verboten werden.  Und schützen Sie auch die Änderung der BIOS-Einstellungen mit einem Passwort. </p><br><p>  <strong>Situation 4</strong> .  Der Angreifer hat physischen Zugriff auf den mitgelieferten Computer, einschließlich der Möglichkeit, den Fall zu öffnen.  Ziel ist es, den Schlüssel herauszufinden oder Root-Zugriff zu erhalten. </p><br><p>  Im Allgemeinen ist dies ohnehin eine Verlustsituation.  Der Angriff auf Speichermodule durch Abkühlen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kaltstartangriff</a> ) wurde nicht abgebrochen.  Auch theoretisch (nicht überprüft) können Sie die Tatsache nutzen, dass moderne SATA-Festplatten Hot-Reconnection unterstützen.  Wenn Sie den Computer neu starten, trennen Sie die Festplatte, ändern Sie <code>grub.cfg</code> in <code>init=/bin/sh</code> , stellen Sie die Verbindung wieder her und lassen Sie das System neu starten.  Es stellt sich heraus (wenn ich es richtig verstehe), Root-Zugriff. </p><br><p>  Ungefähr das Gleiche kann ein skrupelloser Mitarbeiter eines Cloud-Hostings tun, indem er einen Schnappschuss einer virtuellen Maschine mit ihrer nachfolgenden Änderung erstellt. </p><br><h3 id="prochie-voprosy">  Andere Angelegenheiten </h3><br><p>  <strong>Es ist ein Spott, den Schlüssel während eines Neustarts im Speicher zu behalten.</strong>  <strong>Use-after-free in seiner reinsten Form.</strong>  <strong>Eine sauberere Lösung besteht darin, kexec zu verwenden und den Schlüssel zu dynamisch generierten initramfs hinzuzufügen.</strong>  <strong>Es schützt auch vor dem Ersetzen von Kernel-Parametern</strong> .  Ja, wenn kexec funktioniert.  Moderne Distributionen haben die Kexec-Konfiguration <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zu kompliziert gemacht</a> . </p><br><p>  <strong>In Rechenzentren und vor allem in der Cloud verschwindet die Stromversorgung nie.</strong>  <strong>Es stellt sich heraus, dass der Schlüsselbegriff nicht mehr benötigt wird?</strong>  <em>Wenn</em> Sie sich dessen so sicher sind, können Sie es löschen.  Es wird sich herausstellen, dass es sich um einen funktionierenden Server handelt, dessen Schlüssel für die Festplatte niemand kennt¹ und der daher nicht ausgegeben wird, sondern dessen System mit regulären Mitteln aktualisiert werden kann.    —        <code>sudo poweroff</code> . </p><br><p> ¹    <code>/root/key</code> —         ,        cron. </p><br><p> <strong>   ?  IPMI,       </strong> .    IPMI      Java.        . </p><br><p> <strong>   ?     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> SSH</a></strong> . !    .  ,      <code>sudo reboot</code> ,      ? </p><br><p>             ,         .     SSH       ,      .       ,      ,   . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457396/">https://habr.com/ru/post/de457396/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457380/index.html">Ultramodernes OpenGL. Teil 2</a></li>
<li><a href="../de457382/index.html">7 Gewohnheiten von Hochleistungsprogrammierern</a></li>
<li><a href="../de457386/index.html">Einführung in virtuelle Linux-Schnittstellen: Tunnel</a></li>
<li><a href="../de457390/index.html">Madagaskar - Insel der Kontraste</a></li>
<li><a href="../de457392/index.html">Einsparungen bei der plattformübergreifenden mobilen Entwicklung: Skyeng-Fallstudie</a></li>
<li><a href="../de457398/index.html">Aber mache ich Bullshit? Warum gehen Entwickler zu gemba?</a></li>
<li><a href="../de457400/index.html">Die Zahl der Opfer von Atomkatastrophen wie Tschernobyl ist für das Drama stark übertrieben</a></li>
<li><a href="../de457402/index.html">So organisieren Sie die Entwicklung und Unterstützung eines Blogs in WordPress in 2Q19 und beheben es nicht</a></li>
<li><a href="../de457404/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 465 (06/11/2019 - 06/17/2019)</a></li>
<li><a href="../de457406/index.html">Wie viel verdienen Absolventen verschiedener russischer Universitäten?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>