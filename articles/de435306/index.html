<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßñüèª üò† üå∞ Mono-Repositories: bitte nicht üöö üë©üèæ‚Äçü§ù‚Äçüë®üèª üö∂üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vom √úbersetzer: Hallo Habr! Ja, dies ist ein weiterer Artikel √ºber die Vor- und Nachteile von Monorepositories. Ich wollte meinen Artikel dar√ºber schr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mono-Repositories: bitte nicht</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435306/"><blockquote>  Vom √úbersetzer: Hallo Habr!  Ja, dies ist ein weiterer Artikel √ºber die Vor- und Nachteile von Monorepositories.  Ich wollte meinen Artikel dar√ºber schreiben, wie wir das Mono-Repository verwenden, wie wir von Maven zu Bazel gewechselt sind und was daraus wurde.  Aber w√§hrend ich dar√ºber nachdachte, kam ein ausgezeichneter Artikel des Entwicklers von Lyft heraus, den ich f√ºr Sie √ºbersetzen wollte.  Ich verspreche, meine Erg√§nzungen zum Artikel sowie die Erfahrung mit Bazel als Fortsetzung zu ver√∂ffentlichen. </blockquote>  Wir befinden uns im neuen Jahr 2019 und ich bin bereit f√ºr eine weitere Diskussion √ºber die Vorteile (oder das Fehlen davon) beim Speichern des gesamten Quellcodes der Organisation im ‚ÄûMonorepository‚Äú.  F√ºr diejenigen unter Ihnen, die mit diesem Ansatz nicht vertraut sind, besteht die Idee darin, den gesamten Quellcode in einem einzigen Repository des Versionskontrollsystems zu speichern.  Eine Alternative besteht nat√ºrlich darin, den Quellcode in mehreren unabh√§ngigen Repositorys zu speichern und diese normalerweise entlang der Grenze zwischen Diensten / Anwendungen / Bibliotheken aufzuteilen. <br><br>  In diesem Beitrag werde ich diesen Ansatz "Polyrepository" nennen. <br><a name="habracut"></a><br>  Einige der IT-Giganten verwenden Mono-Repositories, darunter Google, Facebook, Twitter und andere.  Wenn solche seri√∂sen Unternehmen Mono-Repositories verwenden, sollten die Vorteile dieses Ansatzes nat√ºrlich enorm sein, und wir sollten alle das Gleiche tun, oder?  Nein!  Wie der Titel des Artikels sagt: "Bitte benutzen Sie nicht das Mono-Repository!"  Warum?  Denn <i>im gro√üen Ma√üstab l√∂st das Monorepository dieselben Probleme, die auch das Polyrepository l√∂st, provoziert Sie jedoch gleichzeitig zur starken Koh√§renz Ihres Codes und erfordert unglaubliche Anstrengungen, um die Skalierbarkeit Ihres Versionskontrollsystems zu verbessern</i> . <br><br>  Mittel- und langfristig bietet das Mono-Repository keine organisatorischen Vorteile, w√§hrend die besten Ingenieure des Unternehmens ein posttraumatisches Syndrom haben (das sich in Form von Sabbern und inkoh√§rentem Murmeln √ºber die Git-Leistung manifestiert). <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1080170131869712384"></twitter-widget><blockquote class="twitter-tweet" data-lang="en_US" data-twitter-extracted-i158374479977875666="true"><p lang="en" dir="ltr">  Es ist Neujahr und ich streite dar√ºber, wie l√§cherlich Monorepos sind.  Das Jahr 2019 hat einen ung√ºnstigen Start.  In diesem Sinne bringe ich Ihnen eine Umfrage. <br><br>  Wer sind die gr√∂√üeren Eiferer?  Unterst√ºtzer von: </p>  - Matt Klein (@ mattklein123), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1. Januar 2019</a> </blockquote><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  Kurzer Exkurs: Was meine ich mit "im gro√üen Stil"?  Es gibt keine einzige Antwort auf diese Frage, sondern weil  Ich bin sicher, Sie fragen mich danach. Nehmen wir an, es gibt ungef√§hr 100 Entwickler, die Vollzeitcode schreiben. <br><br><h2>  Theoretische Vorteile eines Monorepositorys und warum sie nicht ohne Werkzeuge erreicht werden k√∂nnen, die f√ºr Polyrezitories verwendet werden (oder falsch) </h2><br><h4>  Theoretischer Vorteil 1: Einfachere Zusammenarbeit und Code-Sharing </h4><br>  Bef√ºrworter von Mono-Repositorys behaupten, dass, wenn sich der gesamte Code im selben Repository befindet, die Wahrscheinlichkeit einer Duplizierung des Codes geringer ist und es wahrscheinlicher ist, dass verschiedene Teams an einer gemeinsamen Infrastruktur zusammenarbeiten. <br><br>  Hier ist die bittere Wahrheit √ºber selbst mittelgro√üe Mono-Repositorys (und dies wird in diesem Abschnitt st√§ndig zu h√∂ren sein): Es wird f√ºr einen Entwickler schnell unpraktisch, den gesamten Repository-Code auf seiner Workstation zu behalten oder die gesamte Codebasis mit Dienstprogrammen wie grep zu durchsuchen.  Daher sollte jedes Mono-Repository, das skalieren m√∂chte, zwei Dinge bereitstellen: <br><br>  1) so etwas wie ein virtuelles Dateisystem, mit dem Sie nur einen Teil des Codes lokal speichern k√∂nnen.  Dies kann mit einem propriet√§ren Dateisystem wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Perforce erreicht werden</a> , das diesen Modus nativ unterst√ºtzt, indem das interne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">G3-</a> Tool von Google oder das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GVFS von</a> Microsoft verwendet werden. <br><br>  2) ausgefeilte Tools als Service (als Service) zum Indizieren / Suchen / Anzeigen von Quellcode.  Weil  Keiner der Entwickler wird den gesamten Quellcode in einem durchsuchbaren Zustand auf seiner Workstation speichern. Es wird wichtig, eine solche Suche in der gesamten Codebasis durchf√ºhren zu k√∂nnen. <br><br>  Gibt es aufgrund der Tatsache, dass der Entwickler zu einem bestimmten Zeitpunkt nur auf einen kleinen Teil des Quellcodes zugreifen kann, zumindest einen Unterschied zwischen dem Herunterladen eines Teils des Mono-Repositorys oder dem Herunterladen mehrerer unabh√§ngiger Repositorys?  <i>Es gibt keinen Unterschied</i> . <br><br>  Im Zusammenhang mit der Indizierung / Suche / Suche und √§hnlichem Code kann ein solches hypothetisches Tool leicht mehrere Repositorys durchsuchen und das Ergebnis kombinieren.  Genau so funktioniert die Suche auf GitHub sowie mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">komplexeren</a> Such- und Indizierungswerkzeugen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sourcegraph</a> . <br><br>  Unter dem Gesichtspunkt der kollaborativen Arbeit an Code in gro√üem Ma√üstab sind Entwickler daher auf jeden Fall gezwungen, nur mit einem Teil der Codebasis zu arbeiten und √ºbergeordnete Tools zu verwenden.  Es spielt keine Rolle, ob der Code in einem Mono-Repository oder in mehreren unabh√§ngigen Repositorys gespeichert ist, das Problem auf dieselbe Weise gel√∂st wird und die <i>Effektivit√§t der Zusammenarbeit am Code nur von der Engineering-Kultur und nicht von der Art und Weise abh√§ngt, wie die Quellcodes gespeichert werden</i> . <br><br><h4>  Theoretischer Vorteil 2: eine Assembly / kein Abh√§ngigkeitsmanagement </h4><br>  Das n√§chste Argument, das normalerweise von Bef√ºrwortern von Mono-Repositorys angef√ºhrt wird, ist, dass das Speichern des gesamten Codes in einem einzigen Mono-Repository Ihnen die Notwendigkeit nimmt, Abh√§ngigkeiten zu verwalten  Der gesamte Code wird gleichzeitig erfasst.  Das ist eine L√ºge!  Im gro√üen Ma√üstab gibt es einfach keine M√∂glichkeit, den gesamten Quellcode neu zu erstellen und alle automatisierten Tests jedes Mal auszuf√ºhren, wenn jemand √Ñnderungen am Versionskontrollsystem festlegt (oder, was noch wichtiger ist, h√§ufiger auf dem CI-Server, wenn eine neue Verzweigungs- oder Pull-Anforderung erstellt wird).  Um dieses Problem zu l√∂sen, verwenden alle gro√üen Mono-Repositorys ihr ausgekl√ºgeltes Build-System (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bazel</a> / Blaze von Google oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Buck</a> von Facebook), mit dem √Ñnderungen und ihre abh√§ngigen Bl√∂cke √ºberwacht und ein Abh√§ngigkeitsdiagramm des Quellcodes erstellt werden k√∂nnen.  Mit diesem Diagramm k√∂nnen Sie das effiziente Caching von Baugruppenergebnissen und -tests organisieren, sodass nur √Ñnderungen und deren Abh√§ngigkeiten erneut zusammengesetzt und getestet werden m√ºssen. <br><br>  Dar√ºber hinaus seit  Der gesammelte Code sollte schlie√ülich bereitgestellt werden. Wie Sie wissen, kann nicht die gesamte Software gleichzeitig bereitgestellt werden. Es ist wichtig, dass alle Assembly-Artefakte kontrolliert werden, damit die Artefakte bei Bedarf erneut erstellt werden.  Im Wesentlichen bedeutet dies, dass selbst in der Welt der Mono-Repositorys mehrere Versionen des Codes gleichzeitig existieren k√∂nnen und sorgf√§ltig √ºberwacht und koordiniert werden m√ºssen. <br><br>  Bef√ºrworter von Mono-Repositories werden auch argumentieren, dass dies selbst unter Ber√ºcksichtigung der Notwendigkeit, Assemblys / Abh√§ngigkeiten zu verfolgen, immer noch einen unbestreitbaren Vorteil bietet  Ein einziges Commit beschreibt den gesamten Zustand der ganzen Welt.  Ich w√ºrde sagen, dass dieser Vorteil ziemlich kontrovers ist, da das Abh√§ngigkeitsdiagramm bereits vorhanden ist, und es scheint eine ziemlich triviale Aufgabe zu sein, die Festschreibungskennung f√ºr jedes unabh√§ngige Repository als Teil dieses Diagramms einzuschlie√üen, und tats√§chlich kann Bazel problemlos mit mehreren unabh√§ngigen Repositorys sowie mit einem arbeiten Mono-Repository, das die zugrunde liegende Ebene vom Entwickler abstrahiert.  Dar√ºber hinaus ist es einfach, solche automatisierten Refactoring-Tools zu implementieren, mit denen die Versionen abh√§ngiger Bibliotheken in mehreren unabh√§ngigen Repositorys gleichzeitig automatisch aktualisiert werden, wodurch der Unterschied zwischen dem Mono-Repository und dem Polyrepository in diesem Teil ausgeglichen wird (dazu sp√§ter mehr). <br><br>  Das Endergebnis ist, dass die Realit√§ten der Montage / Bereitstellung in gro√üem Ma√üstab f√ºr Mono- und Poly-Repositorys gr√∂√ütenteils gleich sind.  <i>Es gibt keinen Unterschied f√ºr Tools, es sollte nicht f√ºr Entwickler sein, die Code schreiben</i> . <br><br><h4>  Theoretischer Vorteil 3: Code-Refactoring ist ein einfaches atomares Commit </h4><br>  Die letzte Tugend, die Bef√ºrworter von Monorepositories erw√§hnen, ist die Tatsache, dass ein Repository das Refactoring von Code aufgrund der einfachen Suche vereinfacht und die Idee, dass ein Commit das gesamte Repository umfassen kann.  Dies gilt aus mehreren Gr√ºnden nicht: <br><br>  1) Wie oben beschrieben, kann der Entwickler in gro√üem Umfang nicht die gesamte Codebasis auf seinem lokalen Computer bearbeiten oder durchsuchen.  Daher ist die Idee, dass jeder problemlos sein gesamtes Repository f√ºr sich selbst klonen und nur grep / replace ausf√ºhren kann, nicht so einfach in die Praxis umzusetzen. <br><br>  2) Selbst wenn wir davon ausgehen, dass ein Entwickler mithilfe eines komplexen virtuellen Dateisystems die gesamte Codebasis klonen und bearbeiten kann, wie oft wird dies dann passieren?  Ich spreche nicht von der Behebung eines Fehlers bei der Implementierung einer gemeinsam genutzten Bibliothek, da diese Situation bei einem einzelnen Repository und bei einem Multi-Repository (unter der Annahme eines √§hnlichen Build- / Bereitstellungssystems, wie oben beschrieben) gleicherma√üen behandelt wird.  Ich spreche √ºber das √Ñndern der Bibliotheks-API, worauf viele Kompilierungsfehler an den Stellen folgen, an denen diese Bibliothek aufgerufen wird.  In einer sehr gro√üen Codebasis ist es <i>fast unm√∂glich, eine √Ñnderung an der Basis-API vorzunehmen, die von allen beteiligten Teams in der Vorschau angezeigt wird, bevor die Zusammenf√ºhrungskonflikte Sie zwingen, den Prozess erneut zu starten</i> .  Der Entwickler hat zwei echte M√∂glichkeiten: Er kann aufgeben und eine Problemumgehung f√ºr das Problem mit der API finden (in der Praxis geschieht dies h√§ufiger als wir alle m√∂chten), oder er kann die vorhandene API ablenken, eine neue API schreiben und sich dann auf die lange und Aktualisieren aller Aufrufe der alten API in der gesamten Codebasis.  In jedem Fall ist <i>dies absolut der gleiche Vorgang wie beim Polyrepository</i> . <br><br>  3) In einer serviceorientierten Welt bestehen Anwendungen aus vielen lose gekoppelten Komponenten, die unter Verwendung einer gut beschriebenen API miteinander interagieren.  Gro√üe Unternehmen werden fr√ºher oder sp√§ter auf IDL (Interface Description Language) wie Thrift oder Protobuf umsteigen, mit denen Sie typsichere APIs erstellen und abw√§rtskompatible √Ñnderungen vornehmen k√∂nnen.  Wie im vorherigen Abschnitt zur Assembly / Bereitstellung beschrieben, kann der <i>Code nicht gleichzeitig bereitgestellt werden</i> .  Es kann √ºber einen bestimmten Zeitraum bereitgestellt werden: Stunden, Tage oder sogar Monate.  Daher m√ºssen Entwickler √ºber die Abw√§rtskompatibilit√§t ihrer √Ñnderungen nachdenken.  Dies ist die Realit√§t der modernen Softwareentwicklung, die viele gerne ignorieren w√ºrden, aber nicht k√∂nnen.  Wenn es um Dienste geht (im Gegensatz zu API-Bibliotheken), sollten Entwickler daher einen der beiden oben beschriebenen Ans√§tze verwenden (API nicht √§ndern oder <i>den Verfallszyklus</i> durchlaufen). <i>Dies ist sowohl f√ºr das Monorepository als auch f√ºr das Polyrepository absolut gleich</i> . <br><br>  In Bezug auf das Refactoring gro√üer Codebasen entwickeln viele gro√üe Unternehmen ihre eigenen automatisierten Refactoring-Tools wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fastmod</a> , die k√ºrzlich von Facebook ver√∂ffentlicht wurden.  Wie immer kann dieses Tool problemlos mit einem oder mehreren unabh√§ngigen Repositorys arbeiten.  Lyft hat ein Tool namens "Refactorator", das genau das tut.  Es funktioniert wie Fastmod, automatisiert jedoch √Ñnderungen in mehreren unserer Repositorys, einschlie√ülich der Erstellung von Pull-Anforderungen, der Verfolgung des Status von √úberpr√ºfungen usw. <br><br><h2>  Einzigartige Nachteile von Monorepositories </h2><br>  Im vorherigen Abschnitt habe ich alle theoretischen Vorteile des Mono-Repositorys aufgelistet und festgestellt, dass unglaublich komplexe Tools erstellt werden m√ºssen, die sich nicht von denen f√ºr Poly-Repositorys unterscheiden, um sie nutzen zu k√∂nnen.  In diesem Abschnitt werde ich zwei einzigartige Nachteile von Mono-Repositories erw√§hnen. <br><br><h4>  Nachteil 1: Starke Konnektivit√§t und Open Source-Software </h4><br>  Organisatorisch provoziert ein Monorepository die Erstellung eng gekoppelter und fragiler Software.  Es gibt Entwicklern das Gef√ºhl, dass sie Fehler in Abstraktionen leicht korrigieren k√∂nnen, obwohl dies in der Realit√§t aufgrund des instabilen Montage- / Bereitstellungsprozesses und menschlicher / organisatorischer / kultureller Faktoren, die auftreten, wenn versucht wird, √Ñnderungen sofort in der gesamten Codebasis vorzunehmen, nicht m√∂glich ist. <br><br>  Die Codestruktur in Polyrepositorys stellt klare und transparente Grenzen zwischen Teams / Projekten / Abstraktionen / Codebesitzern dar und zwingt den Entwickler, die Interaktionsschnittstelle sorgf√§ltig zu pr√ºfen.  Dies ist ein subtiler, aber sehr wichtiger Vorteil: Entwickler denken breiter und l√§ngerfristig.  Dar√ºber hinaus bedeutet die Verwendung von Multi-Repositorys nicht, dass Entwickler die Grenzen des Repositorys nicht √ºberschreiten k√∂nnen.  Ob dies geschieht oder nicht, h√§ngt nur von der Entwicklungskultur ab und nicht davon, ob ein Monorepository oder ein Polyrepository verwendet wird. <br><br>  Eine starke Bindung hat auch schwerwiegende Konsequenzen f√ºr das √ñffnen des Quellcodes.  Wenn ein Unternehmen Open Source-Software erstellen oder verwenden m√∂chte, ist die Verwendung von Multi-Repositorys ein Muss.  Die Verzerrungen, die auftreten, wenn ein Unternehmen versucht, sein Projekt in Open Source aus seinem Mono-Repository darzustellen (Import / Export von Quellcodes, √∂ffentlicher / privater Bug-Tracker, zus√§tzliche Ebenen, um den Unterschied in Standardbibliotheken zu abstrahieren usw.), f√ºhren nicht zu einer produktiven Zusammenarbeit und Aufbau einer Community sowie erhebliche Gemeinkosten. <br><br><h4>  Fehler 2: Skalierbarkeit des Versionskontrollsystems </h4><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-1" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="542081644954259457"></twitter-widget><blockquote class="twitter-tweet" data-lang="en_US" data-twitter-extracted-i158374479977875666="true"><p lang="en" dir="ltr">  hier habe ich den XKCD-Comic f√ºr dich aktualisiert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pic.twitter.com/pwPBIghTV3</a> </p>  - Monorepi (@monorepi), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8. Dezember 2014</a> </blockquote><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  Die Skalierung eines Versionskontrollsystems f√ºr Hunderte von Entwicklern, Hunderte Millionen Codezeilen und einen riesigen Strom von Commits ist eine monumentale Aufgabe.  Das vor 5 Jahren erstellte Twitter-Mono-Repository (basierend auf git) war eines der wertlosesten Projekte, die ich in meiner Karriere gesehen habe.  Das Ausf√ºhren eines einfachen Befehls wie <code>git status</code> dauerte <i>Minuten</i> .  Wenn die lokale Kopie des Repositorys zu alt war, konnte das Update <i>Stunden dauern</i> (zu diesem Zeitpunkt war es sogar √ºblich, Festplatten mit einer Kopie des Repositorys mit der neuesten Version des Codes an Remote-Mitarbeiter zu senden).  Ich erinnere mich daran, nicht um Twitter-Entwickler zu verspotten, sondern um zu veranschaulichen, wie komplex dieses Problem ist.  Ich kann sagen, dass die Leistung des Twitter-Mono-Repositorys 5 Jahre sp√§ter immer noch weit von der Leistung entfernt ist, die die Entwickler des Tilling-Teams gerne sehen w√ºrden, und das nicht, weil sie sich sehr bem√ºht haben. <br><br>  Nat√ºrlich hat in den letzten 5 Jahren in diesem Bereich eine gewisse Entwicklung stattgefunden.  Microsofts <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Git VFS</a> , das zur Entwicklung von Windows verwendet wird, hat zur Entstehung eines realen virtuellen Dateisystems f√ºr Git gef√ºhrt, das ich oben als Voraussetzung f√ºr die Skalierung eines Versionskontrollsystems beschrieben habe (und mit dem Kauf von Microsoft Github scheint diese Skalierungsstufe ihren H√∂hepunkt zu finden Anwendung in den Funktionen, die GiHub seinen Firmenkunden bietet).  Und nat√ºrlich investieren Google und Facebook weiterhin enorme Ressourcen in ihre internen Systeme, damit sie weiterhin funktionieren, obwohl fast nichts davon √∂ffentlich verf√ºgbar ist. <br><br>  <i>Warum m√ºssen Sie diese Probleme im Allgemeinen mit der Skalierung des Versionskontrollsystems l√∂sen, wenn das Toolkit, wie im vorherigen Abschnitt beschrieben, genau das gleiche sein muss wie f√ºr das Multirepository?</i>  Daf√ºr gibt es keinen vern√ºnftigen Grund. <br><br><h2>  Fazit </h2><br>  Wie so oft in der Softwareentwicklung betrachten wir die erfolgreichsten Softwareunternehmen als Beispiel und versuchen, ihre Best Practices auszuleihen, ohne zu verstehen, was genau diese Unternehmen zum Erfolg gef√ºhrt hat.  Monorepositories sind meiner Meinung nach ein typisches Beispiel f√ºr einen solchen Fall.  Google, Facebook und Twitter haben eine gro√üe Menge an Ressourcen in ihre Codespeichersysteme investiert, um eine L√∂sung zu finden, die im Wesentlichen der <i>f√ºr ein Multi-Repository erforderlichen entspricht, jedoch eine starke Verkn√ºpfung hervorruft und eine enorme Investition in die Skalierung der Versionskontrolle erfordert</i> . <br><br>  In der Tat, in gro√üem Ma√üstab, wie ein Unternehmen mit der Zusammenarbeit mit Code, Zusammenarbeit, starker Bindung usw. zusammenarbeitet.  <i>h√§ngt direkt von der Ingenieurkultur und der F√ºhrung ab und hat nichts damit zu tun, ob ein Monorepository oder ein Polypository verwendet wird</i> .  Beide L√∂sungen sehen f√ºr den Entwickler gleich aus.  Warum also ein Monorepository verwenden?  <b>Bitte nicht!</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435306/">https://habr.com/ru/post/de435306/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435294/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 346 (1. - 6. Januar 2019)</a></li>
<li><a href="../de435296/index.html">Unterhaltungselektronik Hall of Fame: Die Geschichten der besten Ger√§te der letzten 50 Jahre, Teil 3</a></li>
<li><a href="../de435298/index.html">Google Soli "Radar" entwickelt sich weiter</a></li>
<li><a href="../de435300/index.html">Subjektive Vision einer idealen Programmiersprache</a></li>
<li><a href="../de435302/index.html">Wir prototypisieren per Code. FrontTalks Vortrag</a></li>
<li><a href="../de435308/index.html">E-Books und ihre Formate: Erz√§hlen von PDF - Geschichte, Vor- und Nachteile</a></li>
<li><a href="../de435312/index.html">Electric Polestar 2 - das erste Elektroauto mit nativem Android Auto OS</a></li>
<li><a href="../de435314/index.html">‚ÄûSie kennen das Beste - tun Sie das Beste‚Äú: Ein neuer Podcast √ºber die Mischung aus Arbeit und Hobby eines Redakteurs / Vermarkters</a></li>
<li><a href="../de435316/index.html">Koreanische Wissenschaftler haben ein System zur Verfolgung des Datenverkehrs von zwei Laptops entwickelt</a></li>
<li><a href="../de435320/index.html">Schneller und genauer: ein Hybridsystem heterogener Qubits</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>