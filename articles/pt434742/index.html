<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßÄ üîö üòß Parte 2: Usando os controladores UDB PSoC da Cypress para reduzir o n√∫mero de interrup√ß√µes em uma impressora 3D ‚õ©Ô∏è ü•ú üôáüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na √∫ltima vez, consideramos a op√ß√£o de gerar pulsos para motores de passo, parcialmente removidos do software at√© o n√≠vel do firmware. Em caso de suce...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Parte 2: Usando os controladores UDB PSoC da Cypress para reduzir o n√∫mero de interrup√ß√µes em uma impressora 3D</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434742/"><img src="https://habrastorage.org/webt/vx/mr/gy/vxmrgyrhaaffninezudmxyiex9c.jpeg"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Na √∫ltima vez,</a> consideramos a op√ß√£o de gerar pulsos para motores de passo, parcialmente removidos do software at√© o n√≠vel do firmware.  Em caso de sucesso total, isso promete a aus√™ncia da necessidade de processar interrup√ß√µes chegando com uma frequ√™ncia de at√© 40 kHz.  Mas essa op√ß√£o tem v√°rias falhas √≥bvias.  Primeiro, as acelera√ß√µes n√£o s√£o suportadas l√°.  Em segundo lugar, a granularidade das frequ√™ncias de passo permitidas nessa solu√ß√£o √© centenas de hertz (por exemplo, √© poss√≠vel gerar frequ√™ncias de 40.000 Hz e 39966 Hz, mas √© imposs√≠vel gerar frequ√™ncias com uma magnitude entre esses dois valores). <br><a name="habracut"></a><br><h2>  Implementa√ß√£o de acelera√ß√£o </h2><br>  √â poss√≠vel eliminar as desvantagens indicadas usando as mesmas ferramentas UDB sem complicar o sistema?  Vamos acertar.  Vamos come√ßar com o mais dif√≠cil - com acelera√ß√µes.  As acelera√ß√µes s√£o adicionadas no in√≠cio e no final do caminho.  Primeiramente, se os pulsos de alta frequ√™ncia forem aplicados imediatamente ao motor de passo, ser√° necess√°ria uma corrente maior para iniciar a opera√ß√£o.  A corrente alta permitida √© aquecimento e ru√≠do, por isso √© melhor limit√°-la.  Mas ent√£o o mecanismo pode pular etapas no in√≠cio.  Portanto, √© melhor acelerar o motor sem problemas.  Em segundo lugar, se uma cabe√ßa pesada para abruptamente, ela experimenta transientes associados √† in√©rcia.  As ondas s√£o vis√≠veis no pl√°stico.  Portanto, √© suavemente necess√°rio n√£o apenas dispersar, mas tamb√©m parar a cabe√ßa.  Classicamente, √© apresentado um gr√°fico da velocidade do motor na forma de um trap√©zio.  Aqui est√° um fragmento do c√≥digo-fonte do firmware do Marlin: <br><br><img src="https://habrastorage.org/webt/wm/gg/ce/wmggcetcc0vy5tfgs3xsr2ewwoc.png"><br><br>  Nem tentarei descobrir se √© poss√≠vel implementar isso usando o UDB.  Isso se deve ao fato de que outro tipo de acelera√ß√£o est√° na moda: n√£o trapezoidal, mas a curva S.  A agenda deles √© assim: <br><br><img src="https://habrastorage.org/webt/rs/hy/q9/rshyq94_sz6et-lgsbrpprdmyks.png"><br><br>  Definitivamente, isso n√£o √© para UDB.  Desistir?  Nem um pouco!  Eu j√° observei que o UDB n√£o implementa uma interface de hardware, mas simplesmente permite transferir parte do c√≥digo do software para o n√≠vel do firmware.  Deixe o perfil calcular o processador central e a forma√ß√£o de pulsos de etapa ainda executa UDB.  O processador central tem muito tempo para c√°lculos.  A tarefa de eliminar interrup√ß√µes frequentes continuar√° a ser resolvida com bastante eleg√¢ncia e ningu√©m planejou levar o processo completamente ao n√≠vel do firmware. <br><br>  Obviamente, o perfil precisar√° ser preparado na mem√≥ria e o UDB coletar√° dados usando o DMA.  Mas quanta mem√≥ria √© necess√°ria?  Um mil√≠metro precisa de 200 etapas.  Agora, com codifica√ß√£o de 24 bits, s√£o 600 bytes por 1 mm de movimento da cabe√ßa!  Mais uma vez, lembre-se de interrup√ß√µes n√£o t√£o frequentes, mas ainda constantes, para transmitir tudo em fragmentos?  Na verdade n√£o!  O fato √© que o mecanismo de DMA do PSoC √© baseado em descritores.  Depois de executar a tarefa de um descritor, o controlador DMA continua para o pr√≥ximo.  E assim, ao longo da cadeia, voc√™ pode usar muitos descritores.  Ilustramos isso com alguns desenhos da documenta√ß√£o oficial: <br><br><img src="https://habrastorage.org/webt/ju/hv/6b/juhv6bqptp3uagog5bfgxlmxw0q.png"><br><br>  Na verdade, esse mecanismo tamb√©m pode ser usado atrav√©s da constru√ß√£o de uma cadeia de tr√™s descritores: <br><br><table><tbody><tr><th>  N√£o. </th><th>  Explica√ß√£o </th></tr><tr><td>  1 </td><td>  Da mem√≥ria ao FIFO com incremento de endere√ßo.  Indica uma se√ß√£o com um perfil de acelera√ß√£o. </td></tr><tr><td>  2 </td><td>  Da mem√≥ria ao FIFO sem incremento de endere√ßo.  Envia o tempo todo para a mesma palavra na mem√≥ria para velocidade constante. </td></tr><tr><td>  3 </td><td>  Da mem√≥ria ao FIFO com incremento de endere√ßo.  Indica uma se√ß√£o com um perfil de frenagem. <br></td></tr></tbody></table><br>  Acontece que o caminho principal √© descrito na etapa 2 e a mesma palavra √© usada fisicamente, o que define a velocidade constante.  O consumo de mem√≥ria n√£o √© grande.  Na realidade, o segundo descritor pode ser representado fisicamente por dois ou tr√™s descritores.  Isso se deve ao fato de que o comprimento m√°ximo de bombeamento, de acordo com a TRM, pode ser de 64 kilobytes (a altera√ß√£o ser√° menor).  Ou seja, 32.767 palavras.  Isso a 200 passos por mil√≠metro corresponder√° a um caminho de 163 mil√≠metros.  Pode ser necess√°rio fazer um segmento de duas ou tr√™s partes, dependendo da dist√¢ncia m√°xima que o motor pode percorrer por vez. <br><br>  No entanto, para economizar mem√≥ria (e √†s custas dos blocos UDB), proponho abandonar os blocos DatapPath de 24 bits, passando para os mais econ√¥micos de 16 bits. <br><br>  <b>Ent√£o</b>  <b>A primeira proposta de revis√£o.</b> <b><br><br></b>  <b>As matrizes s√£o preparadas na mem√≥ria que codificam a dura√ß√£o das etapas.</b>  <b>Al√©m disso, essas informa√ß√µes v√£o para o UDB usando DMA.</b>  <b>A se√ß√£o retil√≠nea √© codificada por uma matriz de um elemento, o bloco DMA n√£o aumenta o endere√ßo, escolhendo o mesmo elemento o tempo todo.</b>  <b>As se√ß√µes de acelera√ß√£o, retil√≠nea e de frenagem s√£o conectadas pelos meios dispon√≠veis no controlador DMA.</b> <br><br><h2>  Ajuste fino m√©dio </h2><br>  Agora vamos considerar como superar o problema da granularidade de frequ√™ncia.  Obviamente, n√£o ser√° poss√≠vel defini-lo exatamente.  Mas, de fato, o "firmware" original tamb√©m n√£o pode fazer isso.  Em vez disso, eles usam o algoritmo de Bresenham.  Um atraso de uma medida √© adicionado a algumas etapas.  Como resultado, a frequ√™ncia m√©dia se torna intermedi√°ria, entre um valor menor e um maior.  Ajustando a propor√ß√£o de per√≠odos regulares e prolongados, voc√™ pode alterar suavemente a frequ√™ncia m√©dia.  Se nossa velocidade agora n√£o √© definida pelo registro de dados, mas transmitida via FIFO, e o n√∫mero de pulsos geralmente √© definido pelo n√∫mero de palavras transmitidas via DMA, os dois registros de dados no UDB s√£o liberados.  Al√©m disso, uma das baterias, que conta o n√∫mero de pulsos, tamb√©m √© liberada.  Aqui vamos construir um certo PWM neles. <br><br>  Normalmente, as ALUs comparam e atribuem registros com o mesmo √≠ndice.  Quando um registro possui um √≠ndice 0 e o outro 1, nem todas as vers√µes da opera√ß√£o podem ser implementadas.  Mas consegui reunir o solit√°rio dos registros sob os quais o PWM pode ser feito.  Acabou como mostrado na figura. <br><br><img src="https://habrastorage.org/webt/nc/yv/vq/ncyvvqcqptj3lm4an82idlrrl-c.png"><br><br>  Quando a condi√ß√£o A0 &lt;D1 for atendida, adicionaremos uma batida extra ao comprimento de pulso fornecido.  Quando a condi√ß√£o n√£o for cumprida, n√£o o faremos. <br><br><h2>  Cavalo esf√©rico em condi√ß√µes normais </h2><br>  Ent√£o, come√ßamos a modificar o bloco desenvolvido para o UDB, levando em considera√ß√£o a nova arquitetura.  Substitua a profundidade de bits do Datapath: <br><br><img src="https://habrastorage.org/webt/cj/-m/ae/cj-mae3coaxgzro0er5mkraun4q.png"><br><br>  Vamos precisar de muito mais sa√≠das do Datapath do que da √∫ltima vez. <br><br><img src="https://habrastorage.org/webt/ua/td/hn/uatdhnswe_uzmqinll0wyhsyifg.png"><br><br>  Clicando duas vezes neles, vemos os detalhes: <br><br><img src="https://habrastorage.org/webt/vq/3p/24/vq3p24frqv0uiumytbvn-ewhi1w.png"><br><br>  Existem mais d√≠gitos para a vari√°vel <b>State</b> , n√£o se esque√ßa de conectar a mais antiga !!!  Na vers√£o antiga, havia um 0 constante. <br><br><img src="https://habrastorage.org/webt/0l/dm/fy/0ldmfyci2byicjdsksvkdkg8k04.png"><br><br>  O gr√°fico de transi√ß√£o do aut√¥mato ficou assim: <br><br><img src="https://habrastorage.org/webt/hb/5u/nq/hb5unqu_fmfc6sd9k7m3_x0wr7s.png"><br><br>  Estamos no estado <b>ocioso</b> enquanto o FIFO1 est√° vazio.  A prop√≥sito, trabalhar com FIFO1 e n√£o FIFO0 √© o resultado da pr√≥pria forma√ß√£o de paci√™ncia.  O registro A0 √© usado para implementar o PWM, portanto a largura do pulso √© determinada pelo registro A1.  E eu posso fazer o download apenas do FIFO1 (talvez existam outros m√©todos secretos, mas eles n√£o s√£o conhecidos por mim).  Portanto, o DMA carrega os dados exatamente no FIFO1 e √© precisamente o estado <b>"N√£o vazio"</b> do FIFO1 que sai do estado de espera. <br><br>  A ALU no estado <b>IDLE</b> anula o registro A0: <br><br><img src="https://habrastorage.org/webt/1r/i5/-i/1ri5-iydlu00cfobufepmiaqucg.png"><br><br>  Isso √© necess√°rio para que, no in√≠cio da opera√ß√£o do PWM, ele sempre comece a trabalhar desde o in√≠cio. <br>  Mas os dados entraram no FIFO.  A m√°quina entra no estado <b>LoadData</b> : <br><br><img src="https://habrastorage.org/webt/3v/rf/dx/3vrfdxwme_jw6m69bwrpybhiots.png"><br><br>  Nesse estado, a ALU carrega a pr√≥xima palavra do FIFO no registro A1.  Ao longo do caminho, para n√£o criar estados desnecess√°rios, o valor do contador A0, usado para trabalhar com o PWM, √© aumentado: <br><br><img src="https://habrastorage.org/webt/t4/ki/je/t4kijee95z-kbmn1n3ikcgtc9qk.png"><br><br>  Se o contador A0 ainda n√£o atingiu o valor D0 (ou seja, a condi√ß√£o A0 &lt;D0 √© acionada, armando o sinalizador NoNeedReloadA0), vamos para o estado <b>Um</b> .  Caso contr√°rio, o estado √© <b>ClearA0</b> . <br><br>  No estado <b>ClearA0, a</b> ALU zera simplesmente o valor de A0, iniciando um novo ciclo PWM: <br><br><img src="https://habrastorage.org/webt/0_/pj/ah/0_pjahunjhl34izkpv5k9lplxem.png"><br><br>  ap√≥s o qual a m√°quina tamb√©m entra em <b>um</b> estado, apenas uma batida depois. <br><br>  <b>Um deles</b> √© familiar para a vers√£o antiga da m√°quina.  A ALU n√£o executa nenhuma fun√ß√£o. <br><br>  E assim - nesse estado, uma unidade √© gerada na sa√≠da de <b>Out_Step</b> (aqui o otimizador funcionou melhor quando a unidade √© produzida pela condi√ß√£o, isso foi detectado empiricamente). <br><br><img src="https://habrastorage.org/webt/aq/mj/ml/aqmjmluzxutxzq_caddtls15hfc.png"><br><br>  Estamos nesse estado at√© que o contador de sete bits que j√° conhecemos seja redefinido para zero.  Mas, se anteriormente sa√≠mos desse estado por um caminho, agora pode haver dois caminhos: direto e atrasado ao ritmo. <br><br><img src="https://habrastorage.org/webt/53/fk/qc/53fkqcxnlvsf52sxzb8e1ijnpkk.png"><br><br>  Entraremos no estado ExtraTick se o sinalizador <b>AddCycle</b> estiver <b>definido</b> , designado para atender √† condi√ß√£o A0 &lt;D1.  Nesse estado, a ALU n√£o executa nenhuma a√ß√£o ben√©fica.  S√≥ que o ciclo leva 1 batida a mais.  Al√©m disso, todos os caminhos convergem no estado de <b>atraso</b> . <br><br>  Esta condi√ß√£o mede a dura√ß√£o do pulso.  O registro A1 (carregado enquanto ainda est√° no estado <b>Load</b> ) √© reduzido at√© chegar a zero. <br><br><img src="https://habrastorage.org/webt/bi/ct/jt/bictjtwgqikkvuz4pqmp7owacii.png"><br><br>  Al√©m disso, dependendo de haver dados adicionais no FIFO ou n√£o, a m√°quina passar√° para o pr√≥ximo lote para <b>carregar</b> ou para o modo <b>inativo</b> .  Vejamos isso n√£o na figura (existem setas longas, tudo ser√° pequeno), mas na forma de uma tabela, clique duas vezes no estado <b>Delay</b> : <br><br><img src="https://habrastorage.org/webt/bb/cr/dq/bbcrdq1jfhxret5vbaoexfsr-iq.png"><br><br>  Agora sai do UDB.  Eu converti a flag de estar no estado <b>Idle</b> para compara√ß√£o ass√≠ncrona (na vers√£o anterior havia um gatilho que reinava e reiniciava em v√°rios estados), pois, para ele, o otimizador mostrava o melhor resultado.  Al√©m disso, a bandeira <b>Hungry</b> foi adicionada, sinalizando para a unidade DMA que estava pronta para receber dados.  Est√° na bandeira <b>"FIFO1 n√£o est√° lotado"</b> .  Como n√£o est√° lotado, o DMA pode carregar outra palavra de dados l√°. <br><br><img src="https://habrastorage.org/webt/w8/ea/b-/w8eab-2dwdxvtvyr3hfukjrev9w.png"><br><br>  Na parte autom√°tica - √© isso. <br><br>  Adicione blocos DMA ao diagrama principal do projeto.  Por enquanto, comecei a interromper os sinalizadores de termina√ß√£o do DMA, mas n√£o o fato de que isso est√° correto.  Quando o processo de acesso direto √† mem√≥ria estiver conclu√≠do, voc√™ poder√° iniciar um novo processo relacionado ao mesmo segmento, mas n√£o poder√° come√ßar a preencher informa√ß√µes sobre o novo segmento.  O FIFO ainda possui de tr√™s a quatro elementos.  No momento, ainda √© imposs√≠vel reprogramar os registros D0 e D1 do bloco com base no UDB, eles ainda s√£o necess√°rios para a opera√ß√£o.  Portanto, √© poss√≠vel que interrup√ß√µes com base nas sa√≠das <b>Out_Idle</b> sejam adicionadas <b>posteriormente</b> .  Mas essa cozinha n√£o se relaciona mais √† programa√ß√£o de blocos UDB, portanto, apenas a mencionaremos de passagem. <br><br><img src="https://habrastorage.org/webt/4o/g7/y2/4og7y21diqgqr6qn7_iehukiqho.png"><br><br><h2>  Experi√™ncias de software </h2><br>  Como agora tudo n√£o √© conhecido, n√£o escreveremos nenhuma fun√ß√£o especial.  Todas as verifica√ß√µes ser√£o realizadas "Na testa".  Ent√£o, com base em experi√™ncias bem-sucedidas, as fun√ß√µes da API podem ser gravadas.  Ent√£o  Tornamos a fun√ß√£o <b>main ()</b> m√≠nima.  Simplesmente configura o sistema e chama o teste selecionado. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ CyGlobalIntEnable; <span class="hljs-comment"><span class="hljs-comment">/* Enable global interrupts. */</span></span> <span class="hljs-comment"><span class="hljs-comment">// isr_1_StartEx(StepperFinished); StepperController_X_Start(); StepperController_Y_Start(); StepperController_Z_Start(); StepperController_E0_Start(); StepperController_E1_Start(); // TestShortSteps(); TestWithPacking (); for(;;) { }</span></span></code> </pre> <br>  Vamos tentar enviar um pacote de pulsos chamando uma fun√ß√£o, verificando o fato de inserir um pulso adicional.  A chamada de fun√ß√£o √© simples: <br><br><pre> <code class="plaintext hljs">TestShortSteps();</code> </pre><br>  Mas o corpo requer explica√ß√£o. <div class="spoiler">  <b class="spoiler_title">Vou dar toda a fun√ß√£o primeiro</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void TestShortSteps() { //   ,   //      //   ,  DMA    !!! //    ,   !!! StepperController_X_SingleVibrator_WritePeriod (6); //     //    ‚Äî   CY_SET_REG16(StepperController_X_Datapath_1_D0_PTR, 4); CY_SET_REG16(StepperController_X_Datapath_1_D1_PTR, 2); //         . //         static const uint16 steps[] = { 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001, 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001 }; //  DMA  ,      uint8 channel = DMA_X_DmaInitialize (sizeof(steps[0]),1,HI16(steps),HI16(StepperController_X_Datapath_1_F1_PTR)); CyDmaChRoundRobin (channel,true); //       ,       uint8 td = CyDmaTdAllocate(); //       .  ,    . CyDmaTdSetConfiguration(td, sizeof(steps), CY_DMA_DISABLE_TD, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); //       CyDmaTdSetAddress(td, LO16((uint32)steps), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //      CyDmaChSetInitialTd(channel, td); //         CyDmaChEnable(channel, 1); }</code> </pre><br></div></div><br>  Agora considere suas partes importantes. <br><br>  Se a dura√ß√£o da parte positiva do pulso for igual a 92 ciclos de rel√≥gio, o oscilosc√≥pio n√£o poder√° discernir se existe ou n√£o uma inser√ß√£o de ciclo √∫nico na parte negativa.  A escala n√£o ser√° a mesma.  √â necess√°rio tornar a parte positiva o mais curta poss√≠vel, para que o pulso total seja compar√°vel em escala com a batida inserida.  Portanto, mudo √† for√ßa o per√≠odo do contador que define a dura√ß√£o da parte positiva do pulso: <br><br><pre> <code class="plaintext hljs"> //   ,   //      //   ,  DMA    !!! //    ,   !!! StepperController_X_SingleVibrator_WritePeriod (6);</code> </pre><br>  Mas por que seis medidas inteiras?  Por que n√£o tr√™s?  Por que n√£o dois?  Por que, afinal, n√£o um?  Esta √© uma hist√≥ria triste.  Se o pulso positivo for menor que 6 ciclos, o sistema n√£o funcionar√°.  A depura√ß√£o longa em um oscilosc√≥pio com a sa√≠da de linhas de teste para o exterior mostrou que o DMA n√£o √© uma coisa r√°pida.  Se a m√°quina estiver funcionando por menos de uma determinada dura√ß√£o, quando <b>sair do</b> estado de <b>atraso</b> , o FIFO estar√° frequentemente vazio.  Ainda n√£o pode ser colocada uma √∫nica nova palavra de dados!  E somente quando a parte positiva do pulso tem uma dura√ß√£o de 6 ciclos, √© garantido que o FIFO tenha tempo para carregar ... <br><br><h2>  Digress√£o de lat√™ncia </h2><br>  Outra id√©ia de corre√ß√£o que est√° na minha cabe√ßa √© a acelera√ß√£o por hardware de certas fun√ß√µes do kernel do nosso RTOS MAX.  Mas, infelizmente, todas as minhas melhores id√©ias s√£o quebradas sobre as mesmas lat√™ncias. <br><br>  Houve um caso, estudei o desenvolvimento de aplicativos Bare Metal para o Cyclone V SoC.  Por√©m, trabalhar com registradores FPGA √∫nicos (ao escrever alternadamente para eles e depois l√™-los) reduz a opera√ß√£o principal centenas (!!!) de vezes.  Voc√™ ouviu direito.  Est√° em centenas.  Al√©m disso, tudo isso est√° mal documentado, mas a princ√≠pio senti interiormente e depois provei, a partir de fragmentos de frases da documenta√ß√£o, que as lat√™ncias eram culpadas ao passar solicita√ß√µes atrav√©s de v√°rias pontes.  Se voc√™ precisar expulsar uma grande matriz, tamb√©m haver√° lat√™ncia, mas em termos de uma palavra bombeada, isso n√£o ser√° significativo.  Quando as solicita√ß√µes s√£o √∫nicas (e a acelera√ß√£o de hardware do kernel do SO implica apenas elas), a desacelera√ß√£o ocorre exatamente centenas de vezes.  Ser√° muito mais r√°pido fazer tudo de maneira puramente program√°tica, quando o programa trabalhar com a mem√≥ria principal atrav√©s do cache a uma velocidade fren√©tica. <br><br>  No PSoC, eu tamb√©m tinha alguns planos.  Na apar√™ncia, voc√™ pode procurar maravilhosamente dados em uma matriz usando DMA e UDB.  O que realmente existe!  Devido √† estrutura do descritor de DMA, esses controladores poderiam realizar uma pesquisa completamente de hardware em listas vinculadas!  Mas, tendo recebido o plug descrito acima, percebi que ele tamb√©m est√° associado √† lat√™ncia.  Aqui, essa lat√™ncia √© lindamente descrita na documenta√ß√£o.  Tanto na fam√≠lia TRM quanto em um documento separado <b>AN84810 - PSoC 3 e PSoC 5LP T√≥picos avan√ßados de DMA</b> .  A se√ß√£o 3.2 √© dedicada a isso.  Portanto, a pr√≥xima acelera√ß√£o de hardware √© cancelada.  Uma pena.  Mas, como Semyon Semyonovich Gorbunkov disse: "Vamos procurar". <br><br><h2>  Continuando experimentos de software </h2><br>  Em seguida, defino os par√¢metros do algoritmo de Bresenham: <br><br><pre> <code class="plaintext hljs"> //     //    ‚Äî   CY_SET_REG16(StepperController_X_Datapath_1_D0_PTR, 4); CY_SET_REG16(StepperController_X_Datapath_1_D1_PTR, 2);</code> </pre><br>  Bem, ent√£o vem o c√≥digo regular que transfere uma matriz de palavras atrav√©s do DMA para o FIFO1 da unidade de controle do motor X. <br><br>  O resultado requer alguma explica√ß√£o.  Aqui est√°: <br><br><img src="https://habrastorage.org/webt/bi/hg/ie/bihgiepg_iskg-wor_g4iqnv1ti.png"><br><br>  O valor do contador A0 √© mostrado em vermelho quando a m√°quina est√° no estado <b>Um</b> .  O asterisco verde mostra casos em que o atraso √© inserido devido √† m√°quina estar no estado <b>ExtraTick</b> .  Tamb√©m existem barras nas quais o atraso se deve ao estado <b>ClearA0</b> ; elas s√£o marcadas com uma grade azul. <br><br>  Como voc√™ pode ver, quando voc√™ entra pela primeira vez, o primeiro atraso √© perdido.  Isso ocorre porque A0 √© redefinido quando est√° <b>ocioso</b> , mas aumenta quando entra no <b>LoadData</b> .  Portanto, at√© o ponto da an√°lise (sa√≠da do estado de <b>Um</b> ), j√° √© igual √† unidade.  A conta come√ßa com ela.  Mas, em geral, isso n√£o afetar√° a frequ√™ncia m√©dia.  S√≥ precisa ser mantido em mente.  Como deve ser lembrado que, ao redefinir A0, o rel√≥gio tamb√©m ser√° inserido.  Isso deve ser levado em considera√ß√£o no c√°lculo da frequ√™ncia m√©dia. <br><br>  Mas, em geral, o n√∫mero de pulsos est√° correto.  A dura√ß√£o deles tamb√©m √© cr√≠vel. <br>  Vamos tentar programar uma cadeia de descritores mais real, <br><br><div class="spoiler">  <b class="spoiler_title">constitu√≠do por uma fase de acelera√ß√£o, movimento linear e travagem.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void TestWithPacking(int countOnLinearStage) { //   ,   //     . //   ,  DMA    !!! //    ,   !!! StepperController_X_SingleVibrator_WritePeriod (6); //     //    ‚Äî   CY_SET_REG16(StepperController_X_Datapath_1_D0_PTR, 4); CY_SET_REG16(StepperController_X_Datapath_1_D1_PTR, 2); //    static const uint16 accelerate[] = {0x0010,0x0008,0x0004}; //    static const uint16 deccelerate[] = {0x004,0x0008,0x0010}; //  .    . static const uint16 steps[] = {0x0001}; //  DMA  ,      uint8 channel = DMA_X_DmaInitialize (sizeof(steps[0]),1,HI16(steps),HI16(StepperController_X_Datapath_1_F1_PTR)); CyDmaChRoundRobin (channel,true); //   uint8 tdDeccelerate = CyDmaTdAllocate(); CyDmaTdSetConfiguration(tdDeccelerate, sizeof(deccelerate), CY_DMA_DISABLE_TD, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); CyDmaTdSetAddress(tdDeccelerate, LO16((uint32)deccelerate), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //       uint8 tdSteps = CyDmaTdAllocate(); //   !!! //     !!! CyDmaTdSetConfiguration(tdSteps, countOnLinearStage, tdDeccelerate, /*TD_INC_SRC_ADR |*/ TD_AUTO_EXEC_NEXT); CyDmaTdSetAddress(tdSteps, LO16((uint32)steps), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //   //     !!! uint8 tdAccelerate = CyDmaTdAllocate(); CyDmaTdSetConfiguration(tdAccelerate, sizeof(accelerate), tdSteps, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); CyDmaTdSetAddress(tdAccelerate, LO16((uint32)accelerate), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //      CyDmaChSetInitialTd(channel, tdAccelerate); //         CyDmaChEnable(channel, 1); }</code> </pre><br></div></div><br>  Primeiro, chame as mesmas dez etapas (no DMA, na verdade, 20 bytes v√£o): <br><br><pre> <code class="plaintext hljs">TestWithPacking (20);</code> </pre><br>  O resultado √© o esperado.  No in√≠cio, a acelera√ß√£o √© vis√≠vel.  E a sa√≠da para <b>IDLE</b> (raio azul) ocorre com um grande atraso do √∫ltimo pulso; foi ent√£o que o √∫ltimo passo foi completamente conclu√≠do, seu valor √© aproximadamente igual ao valor do primeiro. <br><br><img src="https://habrastorage.org/webt/5y/tb/na/5ytbna9ixcuxv5-i35tinzixy0e.png"><br><br><h2>  Cavalo de verdade em condi√ß√µes normais </h2><br>  Ao remodelar o equipamento, de alguma forma eu pulei de uma largura de pulso de 24 bits para um trabalho de 16 bits.  Mas descobrimos que isso n√£o pode ser feito: a frequ√™ncia m√≠nima de pulso ser√° muito alta.  Eu fiz isso intencionalmente.  O fato √© que a t√©cnica para expandir a capacidade de bits de um contador de 16 bits se tornou t√£o complicada que, se eu tivesse come√ßado a descrev√™-lo junto com a m√°quina principal, teria desviado toda a aten√ß√£o.  Portanto, consideramos isso separadamente. <br><br>  Temos uma bateria de 16 bits.  Decidi adicionar a entidade padr√£o de contador de sete bits aos bits altos.  O que √© esse contador de sete bits?  Esse √© o design que est√° dispon√≠vel em cada bloco UDB (o bloco UDB base tem uma largura de bits de todos os registros de 8 bits, o aumento na profundidade de bits √© determinado pela combina√ß√£o de blocos em grupos).  Dos mesmos recursos, os registros de <b>Controle / Status</b> podem ser implementados.  Agora, temos um contador e n√£o um √∫nico par <b>Controle / Status</b> para 16 bits de dados.  Portanto, adicionando outro contador ao sistema, n√£o atrasaremos os recursos extras.  N√≥s apenas pegamos o que j√° est√° alocado para n√≥s.  Isso √© legal!  N√≥s criamos o byte alto do contador de largura de pulso atrav√©s desse mecanismo e obtemos a largura total do contador de largura de pulso igual a 23 bits. <br><br><img src="https://habrastorage.org/webt/_k/nc/-h/_knc-hzlxwos6a8jdzopy3pj2ww.png"><br><br>  Primeiro direi o que estava pensando.  Eu pensei que depois de sair do estado de <b>atraso</b> , eu verificaria a conclus√£o da contagem desse contador adicional.  Se ele n√£o tiver terminado a contagem, reduzirei seu valor e novamente mudarei para o estado <b>Atraso</b> .  Se voc√™ contou, a l√≥gica permanecer√° a mesma, sem adicionar ciclos extras. <br><br>  Al√©m disso, a documenta√ß√£o deste contador diz que estou certo.  Literalmente diz: <br><blockquote>  Per√≠odo <br>  Define o valor do registro do per√≠odo inicial.  Para um per√≠odo de N rel√≥gios, o valor do per√≠odo deve ser definido como N-1.  O contador contar√° de N-1 at√© 0, o que resulta em um per√≠odo de ciclo de N rel√≥gio.  <b><i>Um valor de registro de per√≠odo igual a 0 n√£o √© suportado e resultar√° na sa√≠da da contagem de terminais mantida em um estado alto constante.</i></b> </blockquote>  A vida mostrou que tudo √© diferente.  Deduzi o estado da linha de <b>contagem</b> do <b>terminal</b> no oscilosc√≥pio e observei seu valor em um zero pr√©-carregado no <b>per√≠odo</b> e durante o carregamento do programa.  Ai e ah.  N√£o havia <b>estado alto constante</b> ! <br><br>  Por tentativa e erro, consegui que o sistema funcionasse corretamente, mas, para que isso aconte√ßa, pelo menos uma subtra√ß√£o do contador deve acontecer!  O novo estado de <b>"subtra√ß√£o"</b> n√£o <b>est√°</b> do lado.  Tinha que ser encaixado no caminho necess√°rio.  Ele est√° localizado na frente do estado <b>Delay</b> e √© chamado <b>Next65536</b> . <br><br><img src="https://habrastorage.org/webt/cp/6f/oz/cp6fozy_kflvs6eu6w-ho9ebmcu.png"><br><br>  A ALU nesse estado n√£o executa nenhuma a√ß√£o √∫til.  Na verdade, apenas um novo contador reage ao fato de estar nesse estado.  Aqui est√° no diagrama: <br><br><img src="https://habrastorage.org/webt/mh/tb/br/mhtbbr8strxue23n6jmg_giocjc.png"><br><br>  Aqui est√£o suas propriedades em mais detalhes: <br><br><img src="https://habrastorage.org/webt/oo/t5/rs/oot5rs3_cdplwr94gno3poavzkq.png"><br><br>  Em geral, levando em conta os artigos anteriores, a ess√™ncia desse contador √© clara.  Somente a linha <b>Ativar</b> est√° sofrendo.  Novamente, eu n√£o entendo completamente por que ele deve ser ligado quando a m√°quina est√° no estado <b>LoadData</b> (o contador recarrega o valor do per√≠odo).  Peguei esse truque emprestado nas propriedades do contador que controla os LEDs, retirado do autor ingl√™s da unidade de controle desses LEDs.  Sem ele, o valor zero do per√≠odo n√£o funciona.  Ela trabalha com ela. <br><br>  No c√≥digo da API, adicionamos a inicializa√ß√£o de um novo contador.  Agora, a fun√ß√£o de in√≠cio fica assim: <br><br><pre> <code class="plaintext hljs">void `$INSTANCE_NAME`_Start() { `$INSTANCE_NAME`_SingleVibrator_Start(); //"One" Generator start `$INSTANCE_NAME`_Plus65536_Start(); }</code> </pre><br>  Vamos verificar o novo sistema.  Aqui est√° o c√≥digo de fun√ß√£o para testar <br><br><div class="spoiler">  <b class="spoiler_title">(nele, apenas a primeira linha difere da j√° conhecida):</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void JustTest(int extra65536s) { //      65536  StepperController_X_Plus65536_WritePeriod((uint8) extra65536s); //     //    ‚Äî   CY_SET_REG16(StepperController_X_Datapath_1_D0_PTR, 4); CY_SET_REG16(StepperController_X_Datapath_1_D1_PTR, 2); //         . //         static const uint16 steps[] = { 0x1000,0x1000,0x1000,0x1000 }; //  DMA  ,      uint8 channel = DMA_X_DmaInitialize (sizeof(steps[0]),1,HI16(steps),HI16(StepperController_X_Datapath_1_F1_PTR)); CyDmaChRoundRobin (channel,true); //       ,       uint8 td = CyDmaTdAllocate(); //       .  ,    . CyDmaTdSetConfiguration(td, sizeof(steps), CY_DMA_DISABLE_TD, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); //       CyDmaTdSetAddress(td, LO16((uint32)steps), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //      CyDmaChSetInitialTd(channel, td); //         CyDmaChEnable(channel, 1); }</code> </pre><br></div></div><br>  Chamamos assim: <br><br><pre> <code class="plaintext hljs"> JustTest(0);</code> </pre><br>  No oscilosc√≥pio, vemos o seguinte (feixe amarelo - sa√≠da STEP, azul - valor da sa√≠da do contador TC para controle de processo).  A dura√ß√£o do pulso √© definida por <b>etapas</b> .  Em cada etapa, a dura√ß√£o √© de 0x1000 medidas. <br><br><img src="https://habrastorage.org/webt/ap/q7/df/apq7dfk6t5kns3qtzjmkuzzw-44.png"><br><br>  Alterne para outra verifica√ß√£o para que haja compatibilidade entre resultados diferentes: <br><br><img src="https://habrastorage.org/webt/zl/6s/2o/zl6s2oop2bft0ndatbawfdrtacw.png"><br><br>  Altere a chamada de fun√ß√£o para isso: <br><br><pre> <code class="plaintext hljs"> JustTest(1);</code> </pre><br>  O resultado √© o esperado.  Primeiro, a sa√≠da do TC √© zero para ciclos de 0x1000, ent√£o - uma unidade para ciclos de 0x10000 (65536d).  A frequ√™ncia √© aproximadamente igual a 700 hertz, descobrimos na √∫ltima parte do artigo, ent√£o est√° tudo certo. <br><br><img src="https://habrastorage.org/webt/nm/5q/6s/nm5q6s73zb7yqxtvuxzrxis4f5i.png"><br><br>  Bem, vamos tentar um empate: <br><br><pre> <code class="plaintext hljs"> JustTest(2);</code> </pre><br>  Temos: <br><br><img src="https://habrastorage.org/webt/ah/sp/7y/ahsp7ymdefdyl04acuefc3ufct8.png"><br><br>  Isso mesmo.  A sa√≠da do TC √© alterada para uma nos √∫ltimos 65536 ciclos de rel√≥gio.  Antes disso, ele estava em zero por 0x1000 + 0x10000 ciclos. <br><br>  Obviamente, com essa abordagem, todos os pulsos devem seguir o mesmo valor do novo contador.  √â imposs√≠vel fazer um pulso com o byte mais alto durante a acelera√ß√£o, digamos 3, depois 1 e depois 0. Mas, de fato, em freq√º√™ncias t√£o baixas (menos de setecentos hertz) as acelera√ß√µes n√£o t√™m significado f√≠sico, portanto esse problema pode ser negligenciado.  Nesta frequ√™ncia, voc√™ pode trabalhar com o mecanismo linearmente. <br><br><h2>  Voar na pomada </h2><br>  O documento TRM para a fam√≠lia PSoC5LP declara: <br><blockquote>  Cada transa√ß√£o pode ter de 1 a 64 KB </blockquote>  Mas no j√° mencionado AN84810 existe uma frase: <br><blockquote>  1. Como voc√™ pode armazenar em buffer mais de 4095 bytes usando o DMA? <br>  A contagem m√°xima de transfer√™ncias de um TD √© limitada a 4095 bytes.  Se voc√™ precisar transferir mais de 4095 bytes usando um √∫nico canal DMA, use v√°rios TDs e encadeie-os conforme mostrado no Exemplo 5. </blockquote>  Quem est√° certo?  Se voc√™ realizar experimentos, os resultados ser√£o inclinados a favor das piores declara√ß√µes, mas o comportamento ser√° completamente incompreens√≠vel.  A falha toda √© essa verifica√ß√£o na API: <br><br><img src="https://habrastorage.org/webt/ib/5s/i2/ib5si2yxxn4e_idcohactjo2j-u.png"><br><br><div class="spoiler">  <b class="spoiler_title">O mesmo texto.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">cystatus CyDmaTdSetConfiguration(uint8 tdHandle, uint16 transferCount, uint8 nextTd, uint8 configuration) \ { cystatus status = CYRET_BAD_PARAM; if((tdHandle &lt; CY_DMA_NUMBEROF_TDS) &amp;&amp; (0u == (0xF000u &amp; transferCount))) { /* Set 12 bits transfer count. */ reg16 *convert = (reg16 *) &amp;CY_DMA_TDMEM_STRUCT_PTR[tdHandle].TD0[0u]; CY_SET_REG16(convert, transferCount); /* Set Next TD pointer. */ CY_DMA_TDMEM_STRUCT_PTR[tdHandle].TD0[2u] = nextTd; /* Configure the TD */ CY_DMA_TDMEM_STRUCT_PTR[tdHandle].TD0[3u] = configuration; status = CYRET_SUCCESS; } return(status); }</code> </pre><br></div></div><br>  Se for especificada uma transa√ß√£o com mais de 4095 bytes, a configura√ß√£o anterior ser√° usada.  Sim, n√£o pensei em verificar c√≥digos de erro ... <br><br>  As experi√™ncias mostraram que, se voc√™ remover essa verifica√ß√£o, o comprimento real ser√° cortado usando a m√°scara 0xfff (4096 = 0x1000).  Ai e ah.  Todas as esperan√ßas de um trabalho agrad√°vel fracassaram.  Voc√™ pode, √© claro, criar cadeias de descritores relacionados em 4K.  Mas, digamos, 64K s√£o 16 cadeias.  Tr√™s motores ativos (extrusoras ter√£o menos etapas) - 48 correntes.  Exatamente isso deve ser preenchido no pior dos casos, antes de cada segmento.  Talvez seja aceit√°vel a tempo.  No m√≠nimo, 127 descritores est√£o dispon√≠veis, portanto, definitivamente haver√° mem√≥ria suficiente. <br><br>  Voc√™ pode enviar os dados ausentes, conforme necess√°rio.  Houve uma interrup√ß√£o porque o canal DMA havia conclu√≠do o trabalho, estamos transferindo outro segmento para ele.  Nesse caso, n√£o s√£o necess√°rios c√°lculos, o segmento j√° est√° formado, tudo ser√° r√°pido.  E n√£o h√° requisitos de desempenho: quando uma solicita√ß√£o de interrup√ß√£o √© emitida, haver√° mais 4 elementos no FIFO que ser√£o atendidos cada um por v√°rias centenas ou mesmo milhares de ciclos de clock.  Ou seja, tudo √© real.  Uma estrat√©gia espec√≠fica ser√° mais f√°cil de escolher durante o trabalho real.  Mas um erro na documenta√ß√£o (TRM) estragou todo o clima.  Se isso fosse conhecido com anteced√™ncia, talvez eu n√£o tivesse verificado a metodologia. <br><br><h2>  Conclus√£o </h2><br>  Na apar√™ncia, a ferramenta de firmware auxiliar desenvolvida tornou-se aceit√°vel para que, com base em si, fosse poss√≠vel criar uma vers√£o do "Firmware", por exemplo, Marlin, que n√£o est√° constantemente no manipulador de interrup√ß√µes para motores de passo.  At√© onde eu sei, isso √© especialmente verdade para as impressoras Delta, onde a demanda por recursos de computa√ß√£o √© bastante alta.  Talvez isso elimine o influxo que ocorre no meu Delta em lugares onde a cabe√ßa para.  No MZ3D nesses mesmos locais, n√£o √© observado influxo.  Se √© verdade ou n√£o, o tempo dir√°, e o relat√≥rio sobre isso precisar√° ser publicado em uma ramifica√ß√£o completamente diferente. <br><br>  Enquanto isso, vimos que, no bloco UDB, por toda a sua simplicidade, √© bem poss√≠vel implementar um coprocessador trabalhando em conjunto com o processador principal e permitindo que ele seja descarregado.  E quando existem muitas dessas unidades, os coprocessadores podem trabalhar em paralelo. <br><br>  Um erro na documenta√ß√£o do controlador DMA emba√ßou o resultado.  No entanto, s√£o necess√°rias interrup√ß√µes, mas n√£o na mesma frequ√™ncia e n√£o com a criticidade no tempo que estava na vers√£o original.  Portanto, o clima √© estragado, mas o uso de um "coprocessador" baseado em UDB ainda oferece um ganho consider√°vel em compara√ß√£o com o trabalho puramente de software. <br><br>  Ao longo do caminho, foi revelado que o DMA funciona a uma velocidade bastante baixa.  Como resultado disso, algumas medi√ß√µes foram realizadas no PSoC5LP e no STM32.  Os resultados puxam outro artigo.  Talvez um dia eu o fa√ßa se o assunto for interessante. <br><br>  Como resultado dos experimentos, dois projetos de teste foram obtidos ao mesmo tempo.  O primeiro √© mais f√°cil de entender.  Voc√™ pode pegar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  O segundo √© herdado do primeiro, mas confuso ao adicionar um contador de sete bits e a l√≥gica associada.  Voc√™ pode pegar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Obviamente, esses exemplos s√£o apenas exemplos de teste.  Ainda n√£o h√° tempo livre para incorporar o verdadeiro "firmware".  Por√©m, dentro da estrutura desses artigos, √© mais importante praticar o trabalho com o UDB. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt434742/">https://habr.com/ru/post/pt434742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt434732/index.html">Vida em 6200 DPI. Revis√£o do HyperX Pulsefire Core</a></li>
<li><a href="../pt434734/index.html">Transformada de Fourier. Os velozes e furiosos</a></li>
<li><a href="../pt434736/index.html">Usando o banco de dados de log Mikrotik para suprimir a for√ßa bruta</a></li>
<li><a href="../pt434738/index.html">Aprendizado por Refor√ßo em Python</a></li>
<li><a href="../pt434740/index.html">Rede neural ensinada a detectar pain√©is solares em imagens de sat√©lite e prever o n√≠vel de sua distribui√ß√£o</a></li>
<li><a href="../pt434744/index.html">Samsung SSD 860 QVO 1 TB e 4 TB: o primeiro consumidor SATA QLC (2 partes)</a></li>
<li><a href="../pt434746/index.html">BLE sob microsc√≥pio 4</a></li>
<li><a href="../pt434750/index.html">Como assumir o controle de sua infraestrutura de rede. Cap√≠tulo Dois Limpeza e documenta√ß√£o</a></li>
<li><a href="../pt434752/index.html">Robomoroz: o futuro do personagem principal do Ano Novo</a></li>
<li><a href="../pt434756/index.html">O futuro do Kubernetes √© com m√°quinas virtuais</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>