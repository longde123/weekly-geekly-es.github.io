<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçüç≥ üà≤ üê® √â poss√≠vel renderizar imagens realistas sem n√∫meros de ponto flutuante? üè¨ ü¶ä ‚úäüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 

 "O que acontece se substituirmos os n√∫meros de ponto flutuante por n√∫meros racionais e tentarmos renderizar a imagem?" 

 Eu me fiz e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√â poss√≠vel renderizar imagens realistas sem n√∫meros de ponto flutuante?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448558/"><h2>  1. Introdu√ß√£o </h2><br><hr><br>  "O que acontece se substituirmos os n√∫meros de ponto flutuante por n√∫meros racionais e tentarmos renderizar a imagem?" <br><br>  Eu me fiz essa pergunta depois de pensar no tweet de um pesquisador e professor de computa√ß√£o gr√°fica Morgan McGwire.  Ele falou sobre o quanto os estudantes de ci√™ncia da computa√ß√£o ficam surpresos quando descobrem que, para armazenar os n√∫meros familiares de ponto flutuante nos computadores modernos, √© necess√°rio fazer compromissos.  E esses compromissos dificultam tarefas simples, por exemplo, verificar se um ponto pertence a um tri√¢ngulo.  O problema, √© claro, √© que verificar se quatro pontos est√£o no mesmo plano (coplanaridade) usando o determinante ou algum tipo de multiplica√ß√£o de vetor (mas, de fato, √© a mesma coisa) nunca dar√° um valor exatamente igual a zero, o que √© necess√°rio estes s√£o m√©todos matem√°ticos.  Mesmo que os c√°lculos reais de estar no mesmo plano fossem precisos, os mesmos compromissos com uma precis√£o de quase 1,0 dariam a resposta de que os quatro pontos em si n√£o s√£o coplanares. <br><br>  Isso deu origem √† ideia em mim - se assumirmos que todos os dados do renderizador recebido (coordenadas de v√©rtices, transforma√ß√µes em 3D etc.) foram definidos como n√∫meros racionais, eles criariam todas as opera√ß√µes, desde a cria√ß√£o de um raio, passando pela estrutura aceleradora at√© a interse√ß√£o raios com tri√¢ngulos s√£o apenas n√∫meros racionais?  Se fosse esse o caso, poder√≠amos realizar um teste de coplanaridade exatamente!  Voc√™ pode estar se perguntando por que uma cena 3D expressa em n√∫meros racionais deve dar apenas resultados em n√∫meros racionais ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a99/c79/14b/a99c7914bc94ae608f4215c34cbe4f66.jpg"></div><br>  <i>Uma cena simples, cujo tra√ßado √© realizado pela aritm√©tica racional.</i>  <i>Ele usa um sistema num√©rico de <b>ponto</b> flutuante, n√£o um <b>n√∫mero de ponto</b> flutuante.</i> <br><a name="habracut"></a><br>  Primeiro, um n√∫mero racional √© um n√∫mero que pode ser expresso como a raz√£o de dois n√∫meros inteiros, por exemplo 1/2 ou 355/113.  Em segundo lugar, "opera√ß√µes normais de renderiza√ß√£o", como testes em caixas delimitadoras, verifica√ß√£o da interse√ß√£o de um raio com um tri√¢ngulo, reflex√£o de um raio etc., baseiam-se em produtos vetoriais e escalares, bem como na divis√£o escalar (isso inclui transforma√ß√£o coordenada e invers√£o matricial, quaterni√µes, etc.), que por sua vez se baseiam em quatro opera√ß√µes b√°sicas: adi√ß√£o, subtra√ß√£o, multiplica√ß√£o e divis√£o.  Ao adicionar, subtrair, multiplicar e dividir n√∫meros racionais, tamb√©m s√£o obtidos n√∫meros racionais.  O matem√°tico diria que muitos n√∫meros racionais formam um campo fechado em quatro opera√ß√µes aritm√©ticas b√°sicas.  Para n√≥s, isso significa que, se aderirmos a n√∫meros exclusivamente racionais, poderemos realmente ir dos dados de entrada da cena 3D para uma imagem totalmente renderizada sem sair do mundo dos n√∫meros racionais. <br><br>  Exce√ß√µes √† regra "a√ß√µes em n√∫meros racionais d√£o n√∫meros racionais" s√£o ra√≠zes quadradas e fun√ß√µes trigonom√©tricas / transcendentais.  Quanto ao √∫ltimo, eu sempre digo que se voc√™ tivesse que realizar c√°lculos trigonom√©tricos nos interiores geom√©tricos do seu renderizador, provavelmente estava fazendo algo errado (e eu mostrei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">como corrigir os casos mais comuns</a> ) [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tradu√ß√£o</a> em Habr√©].  Quanto √†s ra√≠zes quadradas, com exce√ß√£o das se√ß√µes c√¥nicas (esferas, cilindros, etc.) e a realiza√ß√£o de sombreamento / DFOS / colora√ß√£o, n√£o √© necess√°rio normalizar os raios e normal para as superf√≠cies com a frequ√™ncia habitual.  Certamente n√£o precisa ser feito para criar um raio, sua passagem, interse√ß√£o, reflex√µes etc.  Infelizmente, muitas vezes vejo que os programadores normalizam valores por nenhuma outra raz√£o al√©m de "bem, eu n√£o sei, fa√ßo isso para poder jogar com seguran√ßa".  Na pr√°tica, na parte da renderiza√ß√£o onde a geometria √© rastreada, raramente √© necess√°rio normalizar os valores, ent√£o eu tinha a esperan√ßa de que voc√™ pudesse rastrear toda a cena sem sair do mundo dos n√∫meros racionais - isso √© o que eu chamaria de "renderiza√ß√£o racional". <br><br>  Para colocar isso em pr√°tica, preciso criar um sistema num√©rico baseado em n√∫meros racionais que um computador possa usar.  Al√©m disso, eu poderia implementar os algoritmos comuns de rastreamento de caminho, calcular imagens sem perda de precis√£o, executar verifica√ß√µes de coplanaridade com respostas precisas e deixar todos os alunos que estudam computa√ß√£o gr√°fica felizes. <br><br>  Este artigo √© uma hist√≥ria sobre duas noites de pesquisa sobre o realismo dessa ideia.  Vou falar sobre os muitos aspectos que aprendi, sobre o que descobri e sobre algumas surpresas que descobri no processo.  O artigo est√° escrito em uma ordem mais ou menos cronol√≥gica do meu trabalho.  Al√©m disso, foi escrito em meu estilo incomumente informal e pouco cient√≠fico (do qual me orgulho).  A imagem mostrada acima √© uma esp√©cie de spoiler, mas leia o artigo at√© o fim, porque vou falar sobre o bem e o mal. <br><br><h2>  Prepara√ß√£o </h2><br><hr><br>  A primeira coisa que fiz foi implementar em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Shadertoy um rastreador minimamente</a> limitado para uma cena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">extremamente simples que</a> consistia em um avi√£o, uma esfera, um paralelep√≠pedo retangular e um tri√¢ngulo - os blocos de constru√ß√£o de renderizadores reais.  Depois copiei o c√≥digo em um arquivo C ++ e, depois de fazer algumas pequenas altera√ß√µes, compilei-o usando minha estrutura <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">piLibs</a> .  Portanto, para compara√ß√£o, obtive uma imagem rastreada renderizada na CPU usando n√∫meros regulares de acordo com o padr√£o IEEE754 com um ponto flutuante.  Tamb√©m removi toda a normaliza√ß√£o de raios do c√≥digo de rastreamento, porque, como mencionado acima, nenhum deles √© realmente necess√°rio.  Deixe-me lembr√°-lo de que uma raiz quadrada √© necess√°ria para a normaliza√ß√£o, e os n√∫meros racionais n√£o s√£o preservados quando usados ‚Äã‚Äã(a raiz quadrada de um n√∫mero racional n√£o √© um n√∫mero racional).  Um pouco mais tarde, veremos que a aplica√ß√£o de ra√≠zes quadradas, √© claro, ainda √© poss√≠vel, eu s√≥ queria tornar o c√≥digo o mais matematicamente limpo poss√≠vel para ver at√© onde posso ir com a aritm√©tica exata dos n√∫meros racionais sem arredondamentos. <br><br>  A etapa preparat√≥ria final - tomei todas as aulas de vec3, mat4x4 e outras aulas b√°sicas de √°lgebra / matem√°tica e as alterei para que usassem racional em vez de float.  Como minha estrutura racional sobrecarrega todos os operadores padr√£o (adi√ß√£o, sub, mul, div, invers√£o de sinal, compara√ß√µes etc.), a substitui√ß√£o ocorreu sem problemas.  Eu rapidamente implementei as opera√ß√µes usuais restantes (abs, sinal, mod, fratura, piso, sqrt etc.), o que teoricamente era suficiente para obter renderiza√ß√µes racionais bonitas. <br><br><h2>  Teste 1 - A Solu√ß√£o Ing√™nua </h2><br><hr><br>  Mas vamos ver como foi essa primeira implementa√ß√£o.  No come√ßo, sempre tento o mais simples e depois olho para os resultados.  E a maneira mais simples de implementar valores racionais era usar dois n√∫meros inteiros.  Como o nome da se√ß√£o sugere, essa n√£o ser√° minha decis√£o final, mas, na primeira tentativa, foi uma decis√£o razo√°vel.  Portanto, cada n√∫mero <b>x</b> deve ser representado como o numerador <b>N</b> e o denominador <b>D</b> , formando o valor <b>N</b> / <b>D.</b>  O valor <b>x</b> √© aproximado pelo melhor par <b>N</b> / <b>D</b> poss√≠vel (dentro da profundidade de bits especificada), mais pr√≥ximo do valor <b>x</b> verdadeiro.  Decidi que ambos os n√∫meros devem ser positivos, e o sinal do n√∫mero deve ser armazenado em um bit separado, a fim de simplificar o trabalho e livrar-se de ambiguidades, embora isso n√£o seja muito importante.  Nesse est√°gio, numeradores e denominadores eram do tipo n√£o assinado.  Mas, mesmo ao separar o sinal, <b>N</b> / <b>D</b> tinha muita redund√¢ncia: por exemplo, 1/4 e 7/28 denotam o mesmo n√∫mero, mas t√™m representa√ß√µes de bits completamente diferentes.  Falaremos sobre isso mais tarde, mas, por enquanto, n√£o vamos concentrar nossa aten√ß√£o e ver como as quatro opera√ß√µes aritm√©ticas b√°sicas se parecem nessa forma racional. <br><br>  Primeiro, observe que subtrair <b>a</b> - <b>b</b> √© simplesmente a adi√ß√£o de <b>a</b> e o valor oposto a <b>b</b> , ou seja, <b>a</b> + ( <b>-b</b> ), onde <b>-b</b> pode ser calculado simplesmente substituindo o sinal de <b>b</b> .  Da mesma forma, dividir <b>a</b> / <b>b</b> √© o mesmo que multiplicar ae o inverso de <b>b</b> .  Ou, em outras palavras, <b>a</b> / <b>b</b> = <b>a</b> ¬∑ (1 / <b>b</b> ), em que (1 / <b>b</b> ) pode ser calculado simplesmente mudando os locais do numerador <b>b <sub>n</sub></b> e do denominador <b>b <sub>d do</sub></b> n√∫mero <b>b</b> .  Portanto, aqui est√° a primeira propriedade interessante da aritm√©tica racional - divis√£o e multiplica√ß√£o t√™m os mesmos custos, portanto, diferentemente da renderiza√ß√£o de ponto flutuante usual, na qual as divis√µes geralmente s√£o evitadas, atrasadas ou ocultas sob os atrasos das solicita√ß√µes de textura lenta, n√£o h√° necessidade de ter medo dessas opera√ß√µes na aritm√©tica racional . <br><br>  Passamos √† adi√ß√£o com multiplica√ß√£o: sabemos que os valores opostos e inversos s√£o trivialmente simples de calcular, ent√£o obtemos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20f/b96/9c6/20fb969c6d2d6ad899898575244a8d20.png"></div><br>  A preserva√ß√£o do sinal durante a multiplica√ß√£o √© trivial, √© apenas xor, porque dois valores positivos d√£o um resultado positivo e dois negativos.  Salvar um sinal para adi√ß√£o √© um processo mais complicado, e para uma solu√ß√£o r√°pida eu o implementei atrav√©s de tr√™s ramos (a adi√ß√£o √© trivial se os sinais <b>a</b> e <b>b</b> coincidem, mas quando eles n√£o coincidem, √© necess√°rio selecionar um n√∫mero menor e subtra√≠-lo do maior - no artigo eu n√£o Descreverei esses pequenos detalhes com mais detalhes, mas apenas coloque o c√≥digo-fonte em algum lugar). <br><br>  Tamb√©m vou pular a implementa√ß√£o de fract () e floor ();  se voc√™ decidir implement√°-las, ver√° sua simplicidade e beleza.  Tamb√©m deve ser dada aten√ß√£o aos operadores de compara√ß√£o.  Tendo cuidado dos sinais e assumindo que <b>aeb s√£o</b> positivos, obtemos <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e4/b9c/831/6e4b9c831e9b49215c939fedc88ee0cd.png"></div><br>  √â importante notar aqui que, mesmo para compara√ß√£o, precisamos de algumas opera√ß√µes de multiplica√ß√£o, o que pode levar √† transi√ß√£o para o tamanho da pr√≥xima palavra e ser√° importante um pouco menor. <br><br>  Por fim, examinamos as ra√≠zes quadradas em uma se√ß√£o separada, sabendo que na maioria das vezes n√£o precisamos delas (exceto a esfera deste primeiro teste). <br><br>  Isso foi suficiente para executar a primeira renderiza√ß√£o e rastrear a cena de teste (plano + esfera + tri√¢ngulo + caixa retangular) para ver o que aconteceu.  Usei generosamente n√∫meros racionais de 65 bits para este primeiro teste, que na verdade representa uma grande quantidade de dados (compar√°vel ao tipo de dados "duplo"): 32 bits s√£o obtidos pelo numerador, 32 bits s√£o o denominador e outro bit √© o sinal.  A primeira √© a imagem obtida com essa abordagem ing√™nua, a segunda √© a imagem criada usando n√∫meros de ponto flutuante (refer√™ncia): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f79/628/aca/f79628aca052bc725fa16953c8939a5c.png"></div><br>  <i>N√∫meros racionais de 65 bits "ing√™nuos"</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e83/749/dcde8374930d99d48b070981d62043be.png"></div><br>  <i>Refer√™ncia de ponto flutuante</i> <br><br>  O resultado foi muito ruim, a caixa e o tri√¢ngulo nem apareceram na renderiza√ß√£o, e a esfera e o plano do piso eram muito barulhentos.  O problema, √© claro, era que toda vez que meus n√∫meros racionais realizavam qualquer opera√ß√£o aritm√©tica b√°sica em qualquer um dos est√°gios algor√≠tmicos da renderiza√ß√£o, o numerador e o denominador ficavam cada vez mais incontrol√°veis, porque a multiplica√ß√£o inteira era usada.  Pense no seguinte: se as unidades do nosso mundo inicial fossem metros e anex√°ssemos a geometria da fonte (v√©rtices e c√¢mera) √† precis√£o milim√©trica, apenas os dados da fonte ocupariam um volume de 16 bits para uma cena bastante pequena.  Ao mesmo tempo, com resolu√ß√£o de tela HD padr√£o e suaviza√ß√£o de 4x, n√∫meros de dire√ß√£o racional do feixe exigiriam facilmente 12 bits.  Ou seja, durante a primeira intera√ß√£o do feixe e da geometria, a opera√ß√£o aritm√©tica mais simples usando os dois conjuntos de dados de entrada transformaria o resultado em comprimentos de 28 bits - perto o suficiente do limite de 32 bits que eu estabeleci para mim nesta primeira implementa√ß√£o.  E isso foi antes mesmo de executarmos o primeiro produto vetorial ou escalar.  Quando o produto escalar estiver completo, o renderizador precisar√° de n√∫meros racionais com centenas de bits para representar n√∫meros.  Obviamente, esse √© o pior caso, mas o caso m√©dio estaria pr√≥ximo disso.  Considerando que aloquei apenas uma capacidade de 32 bits para o numerador e o denominador, √© f√°cil entender a rapidez com que os valores ultrapassam os limites deste teste - n√£o √© de surpreender que, com exce√ß√£o da planta baixa e parte da esfera, quase nada seja vis√≠vel. <br><br><h2>  Teste 2 - Redu√ß√£o pelo maior fator comum </h2><br><hr><br>  Depois, aprimorei o sistema usando a propriedade que mencionei brevemente acima - diferentes n√∫meros racionais podem significar a mesma quantidade.  De fato, 6/12 √© o mesmo valor que 1/2, mas usa muito mais bits que o anterior.  Portanto, a id√©ia era a seguinte: se ap√≥s cada opera√ß√£o aritm√©tica b√°sica (ou depois dela) eu extra√≠sse todos os divisores comuns do numerador e dos denominadores e traga a fra√ß√£o para sua forma mais simples, talvez seja poss√≠vel manter tudo sob controle e continuar as opera√ß√µes por mais tempo com aritm√©tica exata sem perda de precis√£o.  Talvez voc√™ possa fazer isso o suficiente para obter imagens limpas e renderizadas?  Vou fazer uma pequena digress√£o para mostrar outro exemplo: 588/910 pode ser simplificado para 42/65, porque 14 √© um divisor de 588 e 910. Mas para armazenar 42/65, obviamente, s√£o necess√°rios menos bits que 588/910.  Encontrar o maior n√∫mero poss√≠vel que divide simultaneamente os outros dois n√∫meros pode ser feito usando o algoritmo Great Common Divisor (GCD), cujas implementa√ß√µes eficazes voc√™ pode encontrar em qualquer lugar (copiei-o pessoalmente diretamente da Wikipedia e o acelerei um pouco, executando a etapa de verifica√ß√£o) bits usando opera√ß√µes internas x64).  Assim, armada com o algoritmo GCD, minha classe racional deve simplificar constantemente as fra√ß√µes geradas durante o processo de renderiza√ß√£o.  Isso pode ser feito de duas maneiras: <br><br>  O primeiro √© converter o resultado intermedi√°rio dos operadores de adi√ß√£o e multiplica√ß√£o para o pr√≥ximo tipo de dados de bit (na minha solu√ß√£o ing√™nua atual √© uin64_t), procurar o GCD nesse tipo de dados mais volumoso e reduzir o resultado ao tamanho do bit original (32).  A segunda maneira √© analisar como <b>a <sub>n</sub></b> , <b>a <sub>d</sub></b> , <b>b <sub>n</sub></b> e <b>b <sub>d</sub></b> s√£o combinados entre si nos dois operadores aritm√©ticos e extrair deles divisores comuns antes de realizar a multiplica√ß√£o.  A segunda abordagem basicamente eliminou a necessidade de comprimentos de bits grandes.  Sabendo que seria necess√°rio us√°-los de qualquer maneira, decidi escolher o primeiro m√©todo, porque era mais f√°cil de implementar e me permitiu acelerar meu trabalho (a noite voa muito rapidamente).  Tendo feito tudo isso, vamos ver qual renderiza√ß√£o posso criar agora: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb9/bc5/66f/eb9bc566f927cab52570332aff765d02.png"></div><br>  <i>N√∫meros racionais de 65 bits reduzidos por GCD</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e83/749/dcde8374930d99d48b070981d62043be.png"></div><br>  <i>Refer√™ncia de ponto flutuante</i> <br><br>  Muito melhor!  At√© agora, longe do ideal, √© claro, mas parece promissor.  Fiz a caixa e o tri√¢ngulo aparecerem, e a esfera agora parece muito mais volumosa.  No entanto, um artefato engra√ßado apareceu no canto superior direito, e n√∫meros racionais para muitos pixels ainda v√£o al√©m dos limites, o que leva a muitos pontos na imagem.  No entanto, vale ressaltar que, para alguns (muitos) pixels, comecei a obter resultados <b>precisos</b> e perfeitos!  Ou seja, o rastreador encontrou interse√ß√µes matematicamente precisas de pontos e dist√¢ncias, que foram a causa principal da tentativa de usar n√∫meros racionais. <br><br>  Antes de prosseguir para a pr√≥xima etapa do processo de comprova√ß√£o da aplicabilidade dos n√∫meros racionais, quero parar brevemente e compartilhar minhas descobertas sobre o GCD e a redu√ß√£o dos n√∫meros racionais. <br><br>  A primeira descoberta est√° relacionada ao volume de bits de n√∫meros racionais.  Embora ainda n√£o consiga render belas imagens, isso √© mais importante do que me preocupar com a otimiza√ß√£o de volumes de dados e, embora essa implementa√ß√£o inicial ainda usasse um grande n√∫mero de bits (1 + 32 + 32), eu j√° estava pensando no desperd√≠cio mencionado anteriormente bits na forma de fra√ß√µes em excesso.  Em particular, ap√≥s adicionar um est√°gio com um GCD, combina√ß√µes de bits como 2/4 n√£o s√£o mais aplic√°veis, porque s√£o automaticamente reduzidas a 1/2 antes de serem gravadas em qualquer registro ou vari√°vel.  Isto √©, de certo modo, de todas as 2 <sup>64</sup> combina√ß√µes de bits que poderiam ser um numerador e um denominador, muitas permaneceram sem uso.  E voc√™ n√£o pode desperdi√ßar peda√ßos assim.  Ou √© poss√≠vel?  Quanto espa√ßo eu realmente perco?  Fiz uma pequena digress√£o para explorar esta quest√£o. <br><br><h2>  Digress√£o - em n√∫meros mutuamente primos </h2><br><hr><br>  As ilustra√ß√µes abaixo mostram o uso de bits para n√∫meros racionais em 5/5 bits e 7/7 bits.  Os eixos horizontal e vertical dos gr√°ficos representam os valores do numerador e denominador de todos os n√∫meros racionais poss√≠veis, com numeradores e denominadores de at√© 5 bits (31) e 7 bits (127).  Pixels pretos s√£o combina√ß√µes n√£o utilizadas e pixels brancos s√£o fra√ß√µes usadas.  Por exemplo, a diagonal inteira √© preta, exceto o 1/1 pixel, porque todas as fra√ß√µes do formato n / n s√£o reduzidas para 1/1. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c6c/f08/b9d/c6cf08b9df8d1adecee7836e92a228be.png"><br><br>  <i>Usando bits para 5/5 racional</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/16e/79b/24b/16e79b24b234907f082af70a013ae971.png"><br><br>  <i>Usando bits para 7/7 racional</i> <br><br>  Se voc√™ contar os pixels, como eu fiz, poder√° entender rapidamente que a propor√ß√£o de pixels √∫teis com um aumento no n√∫mero de bits tende a 60,8%.  Uma pequena pesquisa on-line mostrou-me que essa raz√£o √© exatamente 6 / œÄ <sup>2</sup> , porque tamb√©m √© a probabilidade de ser relativamente primo (sem divisores comuns) para dois n√∫meros aleat√≥rios.  Voc√™ pode perguntar, de onde veio o pi?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acontece que ‚Äúseis por pi ao quadrado‚Äù √© um valor igual √† unidade dividido pela </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fun√ß√£o zie de Riemann</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> calculada no ponto 2, 1 / Œ∂ (2). Isso n√£o deveria nos surpreender muito, porque a fun√ß√£o Riemann zeta geralmente aparece em problemas envolvendo n√∫meros primos e mutuamente primos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seja como for, na minha vis√£o racional, desperdicei cerca de 40% das combina√ß√µes de bits. E, embora este pare√ßa um n√∫mero grande, eu decidi olhar para ele como se fosse realmente um pouco menos ... gra√ßas ao qual eu n√£o poderia estar muito chateado. Com isso em mente, decidi seguir em frente, usando outras abordagens completamente diferentes, em vez de tentar otimizar esse √∫nico problema localmente. No entanto, aprendi brevemente sobre as √°rvores Stern-Brokaw e Calkin-Wilf, o que poderia me permitir usar totalmente todos os bits dispon√≠veis, mas o intervalo de valores obtidos com a ajuda deles √© muito pequeno, ent√£o abandonei rapidamente essa ideia e segui em frente. Acho que neste momento devo expressar minha gratid√£o √† </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como uma fonte constante de meu conhecimento.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voltemos √† an√°lise do que obtivemos: posso renderizar imagens com distor√ß√µes, mas muito dependemos da distribui√ß√£o dos n√∫meros primos nos c√°lculos. Depende desses n√∫meros primos se o algoritmo GCD pode simplificar a express√£o - assim que qualquer n√∫mero primo ou um m√∫ltiplo dele cair em qualquer um dos n√∫meros de renderizador (vetores, escalares, matrizes), ele polui todos os n√∫meros que o seguem em outras manipula√ß√µes aritm√©ticas, e permanece neles para sempre. Portanto, gradualmente tudo √© garantido para come√ßar a crescer, √© apenas uma quest√£o de tempo. Al√©m do fato de que isso √© inevit√°vel, tamb√©m √© necess√°rio, porque s√£o divisores mutuamente simples que carregam informa√ß√µes sobre o valor de um n√∫mero. Mas, ao mesmo tempo, n√∫meros primos grandes quebram tudo muito rapidamente. Portanto, h√° um conflito.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A √∫ltima coisa que vale a pena notar √© que eu ainda usei o dobro de bits do n√∫mero de ponto flutuante padr√£o, ent√£o n√£o h√° vantagens reais at√© agora. </font><font style="vertical-align: inherit;">Obviamente, tentei usar n√∫meros racionais de 16/16 bits, o que seria uma compara√ß√£o mais honesta com os verdadeiros requisitos da aritm√©tica de ponto flutuante, mas com uma precis√£o de 16/16, o sistema que escrevi com o numerador + denominador + GCD criou imagens completamente ileg√≠veis.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teste 3 - Normaliza√ß√£o de N√∫meros Racionais </font></font></h2><br><hr><br> ,         . ,              .        <b></b> ,      ,           ,    ,  ,      ( ,     ‚Äî      ,            . ,     ,       ,           ). <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seja como for, decidi verificar o que aconteceria com os processamentos se de alguma forma protegesse o numerador e o denominador de transbordar. A maneira mais f√°cil seria deslocar o numerador e o denominador, se necess√°rio, por um n√∫mero suficiente de bits para a direita, at√© que apare√ßam novamente no espa√ßo de bits alocado. De fato, isso significa uma divis√£o inteira do numerador e do denominador por um valor, o que significa que o valor do n√∫mero permanece </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aproximadamente</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inalterado. E aqui eu me desviei do objetivo original do experimento.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na minha primeira implementa√ß√£o, observei o n√∫mero de bits necess√°rios para o numerador e o denominador, peguei o m√°ximo para ambos e mudei ambos por esse n√∫mero de bits (arredondando para o n√∫mero inteiro mais pr√≥ximo). </font><font style="vertical-align: inherit;">Quando isso foi implementado nos operadores de adi√ß√£o e multiplica√ß√£o, tudo come√ßou a parecer bastante aceit√°vel:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/912/c9d/8db/912c9d8dbc165e2aa14843cb3b3ccd12.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√∫meros racionais de 65 bits reduzidos por GCD e normaliza√ß√£o</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e83/749/dcde8374930d99d48b070981d62043be.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Padr√£o de ponto flutuante</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como tudo parecia muito bom, nessa fase, resolvi o problema de uma grande quantidade de bits usados ‚Äã‚Äãna implementa√ß√£o atual. </font><font style="vertical-align: inherit;">Tentei usar 16/16 (33 bits) em vez de 32/32 (65 bits), e as imagens foram surpreendentemente boas! </font><font style="vertical-align: inherit;">Eu ainda vi que em algumas bordas da esfera existem pequenos buracos, e na figura da textura do tri√¢ngulo existem pequenas lacunas. </font><font style="vertical-align: inherit;">Mas isso n√£o √© ruim para quantidades pr√≥ximas o suficiente de n√∫meros de ponto flutuante. </font><font style="vertical-align: inherit;">Isso me deu energia para aprender novas id√©ias.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teste 4 - Barra flutuante </font></font></h2><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesse est√°gio, decidi me distrair e parar de procurar desculpas - se eu quiser encontrar algo interessante para renderizar em n√∫meros racionais, eles devem ocupar 32 bits e n√£o mais. √â melhor encontrar uma boa id√©ia ou parar e terminar a√≠ (isso foi no in√≠cio da segunda noite de experimentos).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No come√ßo, pensei que valia a pena aderir √†s id√©ias de GCD e normaliza√ß√£o, mas era mais sensato abordar o armazenamento e o uso de bits. A primeira coisa que me ocorreu foi que, embora o numerador e o denominador possam aumentar, isso geralmente n√£o acontece. Ou, pelo menos, isso n√£o acontece simultaneamente. Portanto, quando o numerador √© pequeno, voc√™ pode deixar o denominador ser grande e vice-versa. Os bits n√£o utilizados de um dos dois valores inteiros podem ser usados ‚Äã‚Äãpara representar valores maiores. Ent√£o percebi que, da mesma forma, um n√∫mero de ponto flutuante √© essencialmente um formato de ponto fixo, onde o ponto "fixo" √© feito vari√°vel. Eu posso pegar meus n√∫meros racionais e tamb√©m tornar o layout de bits da fra√ß√£o de fra√ß√£o vari√°vel. Ou seja, n√£o √© dif√≠cil definir a fra√ß√£o como 16/16, mas permitir que a mesma vari√°vel de 32 bits √†s vezes seja 16/16,e √†s vezes 5/27 ou 13/19, conforme necess√°rio.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valeu a pena conferir. </font><font style="vertical-align: inherit;">De qualquer forma, algumas linhas de c√≥digo de embalagem / descompacta√ß√£o em setters e getters internos podem ser escritas rapidamente. </font><font style="vertical-align: inherit;">O esquema mais l√≥gico para mim parecia 1 | 5 | 26, ou seja:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 bit: sinal de </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5 bits: posi√ß√£o da linha de fra√ß√£o (B) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">26 bits: dados combinados de numerador e denominador; </font><font style="vertical-align: inherit;">o numerador √© o bit 26-B superior, o denominador √© o bit B inferior,</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onde a barra de fra√ß√µes (B) determina o tamanho do denominador. </font><font style="vertical-align: inherit;">Por exemplo, o n√∫mero 7/3 ser√° escrito como</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7/3 = 0 00010 0000000000000000000001111 11, </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onde o sinal 0 significa um valor positivo, a linha da fra√ß√£o 2 indica o denominador (n√∫mero 3), que requer 2 bits para representar, e o restante dos bits vai para o numerador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os leitores que trabalharam com o padr√£o IEEE754 podem achar familiar essa observa√ß√£o: a representa√ß√£o bin√°ria do denominador sempre come√ßa com "1", porque o n√∫mero da linha de fra√ß√£o sempre o trunca para a representa√ß√£o mais curta. </font><font style="vertical-align: inherit;">Ou seja, o primeiro bit do denominador √© opcional. </font><font style="vertical-align: inherit;">Nesse caso, o n√∫mero "3" pode ser representado apenas pelo valor bin√°rio "1" e pelo valor da linha de fra√ß√£o "1":</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7/3 = 0 00001 00000000000000000000000000111 1 </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esse truque n√£o s√≥ me salvou um pouco precioso, mas tamb√©m tem um excelente efeito colateral: quando o valor da barra de uma fra√ß√£o √© zero, isso naturalmente significa ao mesmo tempo que o denominador √© 1 e que n√£o √© necess√°rio espa√ßo para armazen√°-lo. Isso significa que, de repente, minha representa√ß√£o racional de n√∫meros se tornou completamente compat√≠vel com a representa√ß√£o inteira e aritm√©tica usuais, at√© que os valores dos n√∫meros subissem acima de 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">26</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ou seja, para um limite suficientemente grande. </font><font style="vertical-align: inherit;">Que surpresa maravilhosa! </font><font style="vertical-align: inherit;">Ou seja, teoricamente, eu posso usar exatamente o mesmo tipo de dados, "racional", para executar opera√ß√µes de renderiza√ß√£o e sombreamento padr√£o, mas tamb√©m executar toda a l√≥gica e tarefas do fluxo de comando no rastreador de caminho - n√£o preciso mais usar dois tipos de dados, como acontece na maioria dos renderizadores ("int" e "float") e fa√ßa convers√µes em uma dire√ß√£o e outra! </font><font style="vertical-align: inherit;">No entanto, o tempo estava se esgotando para mim, ent√£o n√£o alterei todos os √≠ndices de loop de "int" para "racional". </font><font style="vertical-align: inherit;">A noite estava chegando ao fim e eu ainda tinha que verificar muitas coisas para melhorar a qualidade das renderiza√ß√µes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de criar a implementa√ß√£o, pude verificar:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fcb/a9b/34d/fcba9b34d81aae413f1288e6dcfcdf9b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√∫meros racionais </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fracion√°rios de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 32 bits </font><font style="vertical-align: inherit;">(1 | 5 | 26)</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e83/749/dcde8374930d99d48b070981d62043be.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Refer√™ncia de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ponto</font></font></b></i> <font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;"> flutuante de 32 bits Ohhhh</font></i></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nada mal! Ainda tenho artefatos na esfera, que por enquanto vou culpar por minha m√° implementa√ß√£o da raiz quadrada, mas a caixa e o tri√¢ngulo ficaram realmente limpos. O n√∫mero de pixels de imagem resolvidos com precis√£o tamb√©m aumentou. Penso que, devido ao fato de que antes do estouro no denominador ou numerador, mais n√∫meros t√™m tempo para aparecer, aumentei a probabilidade de o GCD encontrar divisores comuns e realizar uma redu√ß√£o. Ou seja, a linha flutuante da fra√ß√£o n√£o apenas aumentou o intervalo dos n√∫meros representados e adiou o momento de normaliza√ß√£o (com perda de precis√£o) causada pelo estouro, mas tamb√©m deu o pr√≥ximo passo na melhoria da qualidade, aumentando a probabilidade de redu√ß√µes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta fase, eu estava pronto para realizar um teste mais s√©rio (mas ainda experimental - o sistema ainda est√° longe de estar pronto para opera√ß√£o). </font><font style="vertical-align: inherit;">Eu implementei um rastreador de caminho com um conjunto m√≠nimo de fun√ß√µes (n√£o necessariamente fisicamente precisas ou mesmo levando em conta a f√≠sica) e criei uma cena com v√°rios paralelep√≠pedos retangulares e duas fontes de luz, cuja implementa√ß√£o de refer√™ncia na GPU est√° aqui: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.shadertoy.com/view/Xd2fzR</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Novamente converti a cena para a estrutura C ++, novamente removi algumas normaliza√ß√µes de raios desnecess√°rias e executei a renderiza√ß√£o. </font><font style="vertical-align: inherit;">Aqui est√° o que eu tenho:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b9/e7d/951/5b9e7d951bbef194094a389017433a50.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√∫meros racionais </font><b><font style="vertical-align: inherit;">fracion√°rios de</font></b><font style="vertical-align: inherit;"> 32 bits</font></font><b><font style="vertical-align: inherit;"></font></b></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20d/58f/543/20d58f54338c93f88379f550faf52c51.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Padr√£o de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ponto</font></font></b></i> <font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;"> flutuante de 32 bits</font></i></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Uau, isso √© realmente bom! </font><font style="vertical-align: inherit;">Embora vazamentos de luz sejam claramente vis√≠veis nos cantos onde as bordas do piso e do teto est√£o conectadas. </font><font style="vertical-align: inherit;">Veja-os na aproxima√ß√£o: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/36d/404/72d/36d40472de509e4fe6a7520c7e6df5a4.png"><img src="https://habrastorage.org/getpro/habr/post_images/ffd/9da/0d6/ffd9da0d613a076c0c624e5a9b2c15e9.png"><img src="https://habrastorage.org/getpro/habr/post_images/273/84b/a41/27384ba41a08f4771f8cf6c6cddd129d.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Talvez eles sejam causados ‚Äã‚Äãpor um problema na minha implementa√ß√£o da interse√ß√£o de um raio e uma caixa retangular, que s√≥ √© expressa em n√∫meros racionais; </font><font style="vertical-align: inherit;">Eu n√£o ficaria surpreso. </font><font style="vertical-align: inherit;">Ou talvez eu tenha me deparado com os limites dos quais n√∫meros racionais s√£o capazes. </font><font style="vertical-align: inherit;">Seja como for, estou bastante satisfeito. </font><font style="vertical-align: inherit;">Al√©m disso, tenho outras altera√ß√µes e experimentos que queria testar pelo curto per√≠odo de tempo restante:</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algumas outras experi√™ncias </font></font></h2><br><hr><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aritm√©tica precisa em 64 bits </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A id√©ia de aritm√©tica exata n√£o pode ser realizada em n√∫meros racionais ing√™nuos de 64 bits ou em n√∫meros racionais de 32 bits (1 | 5 | 26) com uma fra√ß√£o de linha flutuante. E os n√∫meros de ponto flutuante de 64 bits de uma fra√ß√£o funcionam? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementei rapidamente os n√∫meros racionais 1 | 6 | 57 (embora eu tivesse que aprender novos mecanismos internos x64 para troca de bits). Esses 57 bits de numerador / denominador permitiram tra√ßar um intervalo de dist√¢ncia muito maior. Na verdade, eu consegui tra√ßar uma cena com v√°rios tri√¢ngulos com toda a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">precis√£o</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aritm√©tica (n√£o a cena acima mencionada com paralelep√≠pedos retangulares e ilumina√ß√£o global, mas apenas alguns tri√¢ngulos na frente da c√¢mera). E o sucesso me esperava! No entanto, o teste de coplanaridade, que eu implementei para verificar a exatid√£o, exigiu v√°rias opera√ß√µes de produtos escalares e vetoriais, o que fez com que os n√∫meros come√ßassem a se normalizar. Portanto, embora eu soubesse que a renderiza√ß√£o era precisa, n√£o poderia "prov√°-la" experimentalmente. Que ironia. Em geral, isso significa que 64 bits foram suficientes para v√°rios tri√¢ngulos, mas cenas mais complexas ainda ser√£o desfeitas. No entanto, isso me fez pensar em outra pergunta: existe algum algoritmo que pode ser usado para testar a coplanaridade, baseado n√£o em valores absolutos, mas na aritm√©tica modular? Eu achona aritm√©tica modular, os n√∫meros racionais n√£o devem "explodir" em tamanho? N√£o tive tempo de investigar tudo isso e n√£o sou especialista em teoria dos n√∫meros.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ra√≠zes quadradas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na √∫ltima (segunda) noite de pesquisa, decidi abordar brevemente esse t√≥pico e estudar novas informa√ß√µes. </font><font style="vertical-align: inherit;">Eu queria implementar a melhor fun√ß√£o de raiz quadrada poss√≠vel para n√∫meros racionais. </font><font style="vertical-align: inherit;">Minha decis√£o ing√™nua atual ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incorreta</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) pegou a raiz quadrada inteira do numerador (com arredondamento correspondente) e depois fez o mesmo com o denominador. </font><font style="vertical-align: inherit;">Como a raiz quadrada de uma fra√ß√£o √© uma fra√ß√£o das ra√≠zes quadradas do numerador e denominador, em geral, essa abordagem retorna resultados decentes, n√£o muito diferentes da melhor resposta. </font><font style="vertical-align: inherit;">Mas ele certamente n√£o retorna a melhor aproxima√ß√£o racional da raiz quadrada de um n√∫mero racional. </font><font style="vertical-align: inherit;">Ele realiza duas em vez de uma aproxima√ß√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu tentei o seguinte: no final, aqui estamos procurando por dois inteiros </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></b>  <b>y</b> , ,  <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/769/1eb/d9b/7691ebd9ba782aacba6bc480f13199a8.png"></div><br>          ()    (¬´¬ª ,      ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aaf/9db/7db/aaf9db7db7d1ee8300d090ea1e97535b.png"></div><br>  Depois de pesquisar na Wikipedia, descobri que essa equa√ß√£o espec√≠fica √© a chamada "equa√ß√£o de Pell modificada".  Existem algoritmos que encontram os menores valores de <b>x</b> e <b>y</b> para resolver esta equa√ß√£o.  Infelizmente, minha aten√ß√£o mudou rapidamente para outras curiosas matem√°ticas diofantinas, e eu n√£o continuei com a implementa√ß√£o de nenhum desses algoritmos. <br><br><h3>  Redu√ß√£o mais efetiva </h3><br>  Nos √∫ltimos minutos da noite, pensei em explorar a id√©ia de usar v√°rios membros que se combinam em operadores geom√©tricos complexos, por exemplo, em um produto vetorial.  Digamos que o primeiro componente de um produto vetorial foi <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c84/4b5/c33/c844b5c33c70116474bbaa0c63273ad7.png"></div><br>  sob a suposi√ß√£o de que sy = a / b, tz = c / d, ty = e / f, sz = g / h <br><br>  Isso significava que agora eu posso tentar encontrar divisores comuns, por exemplo, entre a e d ou e e h, e us√°-los para redu√ß√£o preliminar. <br><br>  Tive outra ideia: se, em algum momento, a velocidade de renderiza√ß√£o se tornar um problema, voc√™ poder√° desativar completamente as etapas de pesquisa do GCD e aplicar apenas a normaliza√ß√£o.  Uma verifica√ß√£o r√°pida mostrou que, nesse caso, a imagem renderizada ainda permanece aceit√°vel e funciona bem a uma velocidade muito maior.  No entanto, nesse caso, √© claro, obtemos menos resultados aritmeticamente precisos. <br><br>  Como compromisso, voc√™ pode se recusar a implementar o procedimento ou o esquema GCD e usar algo matematicamente simples, codificado no c√≥digo e eficaz, determinando a divisibilidade em apenas 2, 3 e 5. Embora n√£o encontremos um n√∫mero exaustivo de divisores, na pr√°tica, isso levaria a encontrar um grande n√∫mero de abrevia√ß√µes.  Pense nisso - divisibilidade por 2 ocorre tr√™s vezes mais que divisibilidade por 7 e 20 vezes mais que divisibilidade por 41! <br><br><h2>  Conclus√£o </h2><br><hr><br>  Ap√≥s esse experimento, comecei a acreditar que √© bem poss√≠vel que uma representa√ß√£o de n√∫meros seja baseada em n√∫meros racionais, semelhante ao que eu chamo de "fra√ß√£o de linha flutuante".  Uma representa√ß√£o compat√≠vel com n√∫meros inteiros e capaz de executar muitas opera√ß√µes na aritm√©tica exata para muitas tarefas (desde que os dados de entrada sejam apresentados de forma racional).  A vers√£o de 64 bits (1 | 6 | 57) tem um grande potencial, embora a vers√£o de 32 bits (1 | 5 | 26) j√° crie renderiza√ß√µes interessantes. <br><br>  Se n√£o fosse um experimento por duas noites, mas algo profissional criado em um est√∫dio ou empresa, no futuro, as seguintes etapas poder√£o ser tomadas: <br><br>  * Obtenha um histograma do n√∫mero de pixels precisos e n√£o exatamente rastreados (em outras palavras, a frequ√™ncia de execu√ß√£o da normaliza√ß√£o) <br>  * Tente implementar uma redu√ß√£o codificada nos divisores 2, 3 e 5 e me√ßa a porcentagem de pixels exatos perdidos <br>  * Mostre a diferen√ßa de pixel entre a renderiza√ß√£o do ponto flutuante e a renderiza√ß√£o do ponto flutuante da fra√ß√£o <br>  * Encontre maneiras engenhosas de usar os valores n√£o utilizados do formato de bit "fra√ß√µes de linha flutuante", por exemplo, para indicar Inf e NaN <br>  * Implementar a detec√ß√£o de NaN, Inf, underflow, overflow. <br><br>  Em suma, foi um estudo fascinante.  No processo, descobri algumas surpresas, criei uma pequena inven√ß√£o e aprendi muito sobre a equa√ß√£o de Pell, ra√≠zes quadradas, GCD, mecanismos internos x86_64, a fun√ß√£o zie de Riemann e outros aspectos.  Estou muito satisfeito com isso! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt448558/">https://habr.com/ru/post/pt448558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt448540/index.html">VMware NSX para o menor. Parte 5. Configurando o Balanceador de Carga</a></li>
<li><a href="../pt448546/index.html">Tamanhos autom√°ticos de cabe√ßalho e rodap√© do UITableView com AutoLayout</a></li>
<li><a href="../pt448548/index.html">Constru√ß√£o na arte: de Brueghel a Vasya Lozhkin</a></li>
<li><a href="../pt448550/index.html">Inaugura√ß√£o do Concurso de Reportagens no #PAYMENTSECURITY 2019</a></li>
<li><a href="../pt448552/index.html">ProLiant Series 100 - O irm√£o mais novo perdido</a></li>
<li><a href="../pt448560/index.html">Plano de transforma√ß√£o da IA: como gerenciar uma empresa na era da IA?</a></li>
<li><a href="../pt448562/index.html">Google ajuda a pol√≠cia a localizar dispositivos perto de cenas de crime usando dados de localiza√ß√£o</a></li>
<li><a href="../pt448564/index.html">O primeiro do grupo - o primeiro a cair: avalia√ß√£o dos riscos de lideran√ßa em grupos de animais auto-organizados</a></li>
<li><a href="../pt448568/index.html">Como implementar a ISO 27001: instru√ß√µes de uso</a></li>
<li><a href="../pt448570/index.html">Estimamos o rendimento do canal MIMO (o algoritmo de vazamento de √°gua est√° inclu√≠do)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>