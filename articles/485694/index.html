<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶É üëºüèº üòü Embox en el procesador Elbrus. O nunca olvides lo que tienes en inteligencia üèáüèΩ üè¨ üî∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art√≠culo es la conclusi√≥n l√≥gica de una serie de art√≠culos de "escalada Elbrus" sobre la introducci√≥n de Embox a la arquitectura del procesador E...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Embox en el procesador Elbrus. O nunca olvides lo que tienes en inteligencia</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/embox/blog/485694/"><img src="https://habrastorage.org/webt/ic/4z/5o/ic4z5olelesc04boln85goculk4.png" align="right" width="320">  Este art√≠culo es la conclusi√≥n l√≥gica de una <a href="https://habr.com/ru/company/embox/blog/447704/">serie de</a> <a href="https://habr.com/ru/company/embox/blog/447744/">art√≠culos</a> <a href="https://habr.com/ru/company/embox/blog/447704/">de</a> <a href="https://habr.com/ru/company/embox/blog/421441/">"escalada Elbrus"</a> sobre la introducci√≥n de <a href="http://embox.github.io/">Embox</a> a la <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BB%25D1%258C%25D0%25B1%25D1%2580%25D1%2583%25D1%2581_2000">arquitectura del procesador Elbrus (E2K)</a> .  Por qu√© una conclusi√≥n l√≥gica, porque como resultado, fue posible ejecutar a trav√©s de telnet una aplicaci√≥n que muestra la imagen en la pantalla, es decir, para lograr el funcionamiento completo de Embox en esta arquitectura.  La investigaci√≥n adicional dif√≠cilmente puede considerarse una introducci√≥n, aunque, por supuesto, queda mucho por aclarar.  Y la arquitectura en s√≠ tiene muchas caracter√≠sticas interesantes, que tampoco se entienden actualmente.  En este art√≠culo, nos centraremos en la organizaci√≥n de la memoria virtual, tocaremos PCI, hablaremos un poco sobre una tarjeta de red y tocaremos una tarjeta de video en un hardware espec√≠fico que tenemos. <a name="habracut"></a><br><br>  Para aquellos que son demasiado flojos para leer el art√≠culo, les dar√© de inmediato un breve video con los resultados. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/FqOSFJ36B48" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Y ahora, para aquellos que est√©n interesados, revelaremos los detalles t√©cnicos que pudimos entender en el proceso. <br><br><h3>  Memoria virtual </h3><br><h4>  Nuestro error de pila </h4><br>  Comencemos con la memoria virtual.  En realidad, esto es lo que resolvimos en el <a href="https://habr.com/ru/company/embox/blog/447744/">art√≠culo</a> anterior <a href="https://habr.com/ru/company/embox/blog/447744/">de la</a> serie.  Vale la pena recordar de inmediato por qu√© necesit√°bamos memoria virtual, porque Embox puede funcionar sin ella.  Es simple: la cosa es el almacenamiento en cach√©.  Vidyaha funcion√≥, pero tuvo que escribir lo mismo dos veces en la memoria de video para una recuperaci√≥n de imagen confiable.  Por supuesto, era posible lidiar con la memoria cach√©, pero nuestros ejemplos implican el uso de memoria de video directamente desde una aplicaci√≥n de usuario, sin ning√∫n elemento nuclear como la administraci√≥n de la memoria cach√©, por lo que fue correcto aprender a asignar la memoria como no almacenable en cach√©.  Lo mismo se puede hacer en Linux mapeando fb ( <a href="http://dmilvdv.narod.ru/Translate/ELSDD/elsdd_sample_frame_buffer_example.html">ejemplo</a> ). <br><br>  Vale la pena se√±alar que aunque no escribimos sobre Elbrus durante mucho tiempo y podr√≠a parecer que MMU en esta arquitectura es una especie de s√∫per complicado, pero la cosa es diferente.  De hecho, agregamos apoyo en el verano, simplemente no llegamos a nuestras manos para escribir sobre ello.  Pasamos mucho tiempo (varios meses) debido a nuestro est√∫pido error.  Este error incluso se cometi√≥ en el t√≠tulo del art√≠culo ("O nunca olvides lo que obtuviste durante la inteligencia").  Estamos hablando de pilas con las que tratamos bastante bien y lo describimos en el art√≠culo Climbing <a href="https://habr.com/ru/company/embox/blog/447704/">Elbrus - Reconnaissance.</a>  <a href="https://habr.com/ru/company/embox/blog/447704/">Parte t√©cnica 1. Registros, pilas y otros detalles t√©cnicos "</a> .  Sufrimos durante mucho tiempo, perdiendo est√∫pidamente el hecho de que tomamos la pila inicial (en la que se inicializa el sistema) desde alg√∫n lugar fuera, y mapeamos todo.  lo que necesitamos para que Embox funcione, no mapeamos estos datos. <br><br>  Debajo del gato, le dar√© una nueva funci√≥n e2k_entry, descrita en el segundo <a href="https://habr.com/ru/company/embox/blog/447744/">art√≠culo de la serie</a> . <br><br>  Si lo desea, puede comparar. <br><br><pre><code class="cpp hljs">__attribute__ ((__section__(<span class="hljs-string"><span class="hljs-string">".e2k_entry"</span></span>))) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e2k_entry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct pt_regs *regs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Since we enable exceptions only when all CPUs except the main one * reached the idle state (cpu_idle), we can rely that order and can * guarantee exceptions happen strictly after all CPUS entries. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entries_count &gt;= CPU_COUNT) { <span class="hljs-comment"><span class="hljs-comment">/* Entering here because of exception or interrupt */</span></span> e2k_trap_handler(regs); RESTORE_COMMON_REGS(regs); E2K_DONE; } <span class="hljs-comment"><span class="hljs-comment">/* It wasn't exception, so we decide this usual program execution, * that is, Embox started on CPU0 or CPU1 */</span></span> e2k_wait_all(); entries_count = __e2k_atomic32_add(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;entries_count); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entries_count &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* XXX currently we support only single core */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Run cpu_idle on 2nd CPU */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* it's just needed if log_debug enabled in e2k_context module * else output will be wrong because 2 cpu printing at the same time */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!sync_count); context_init(&amp;cpu_ctx[<span class="hljs-number"><span class="hljs-number">0</span></span>], CONTEXT_PRIVELEGED | CONTEXT_IRQDISABLE, cpu_idle, idle_stack, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(idle_stack)); context_switch(&amp;cpu_ctx_prev[<span class="hljs-number"><span class="hljs-number">0</span></span>], &amp;cpu_ctx[<span class="hljs-number"><span class="hljs-number">0</span></span>]); } <span class="hljs-comment"><span class="hljs-comment">/* Run e2k_kernel_start on 1st CPU */</span></span> context_init(&amp;cpu_ctx[<span class="hljs-number"><span class="hljs-number">1</span></span>], CONTEXT_PRIVELEGED | CONTEXT_IRQDISABLE, e2k_kernel_start, &amp;_stack_top, KERNEL_STACK_SZ); sync_count = __e2k_atomic32_add(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;sync_count); context_switch(&amp;cpu_ctx_prev[<span class="hljs-number"><span class="hljs-number">1</span></span>], &amp;cpu_ctx[<span class="hljs-number"><span class="hljs-number">1</span></span>]); }</code> </pre> <br>  Solo explicar√© que ahora usamos las funciones context_init () y context_switch () solo para cambiar la pila a la memoria en el espacio Embox.  Y hacemos esto para todos los n√∫cleos, incluidos los que no se utilizan. <br><br><h3>  Organizaci√≥n MMU </h3><br>  Ahora hablar√© un poco sobre la organizaci√≥n de MMU en la arquitectura E2k. <br><br>  En general, la arquitectura MMU es bastante com√∫n y tiene tablas de cuatro niveles (o tres cuando se usa una p√°gina de 4 MB). <br><br>  Hay varios registros de servicio en la arquitectura E2k, se accede a ellos mediante comandos de acceso a espacios alternativos, as√≠ como al espacio de E / S que se describe brevemente en el art√≠culo <a href="https://habr.com/ru/company/embox/blog/421441/">"Embox comienza a escalar Elbrus"</a> . <br><br>  Necesitaremos tales registros: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MMU_REG_CR 0x00 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Control register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MMU_REG_CONT 0x10 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Context register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MMU_REG_CR3_RG 0x20 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* CR3 register for INTEL only */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MMU_REG_ELB_PTB 0x30 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ELBRUS page table virtual base */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MMU_REG_ROOT_PTB 0x40 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Root Page Table Base register */</span></span></span><span class="hljs-meta">/</span></span></code> </pre> <br>  En realidad, este es un registro de control, un registro de n√∫mero de contexto, un registro ra√≠z de tablas y un poco oscuro MMU_REG_ELB_PTB.  Comencemos con esto, este registro debe establecerse en alg√∫n valor, el procesador utilizar√° los siguientes 512 GB para las necesidades del equipo, y estas direcciones no estar√°n disponibles para el programador.  Proporcionar√© explicaciones de la carta del especialista de ICST, dif√≠cilmente puedo explicar mejor: <br><br><blockquote>  En Linux, configuramos MMU_ELB_PTB en 0xff1 &lt;&lt; 39, y luego <br>  √°rea superior de la memoria virtual (0xff8000000000 - 0xffffffffffff) <br>  reservado para las necesidades de equipos, a saber, TLB.  Cada p√°gina <br>  la tabla de p√°ginas (TS) obtiene su direcci√≥n √∫nica en esta √°rea, <br>  Adem√°s, estas direcciones se obtienen f√°cilmente de la direcci√≥n en la que el programa <br>  apel√≥ a la memoria.  Y desde  TLB almacena asignaciones de direcciones virtuales <br>  f√≠sico, esto le permite almacenar en cach√© en el mismo b√∫fer TLB <br>  difunde no solo para las direcciones de los usuarios, sino tambi√©n para el propio veh√≠culo. <br><br>  En aquellos procesadores / arquitecturas donde se realizan TLB separados para diferentes <br>  niveles de la tabla de p√°ginas, tal truco se vuelve innecesario. <br><br>  Por lo tanto, cuando pierde el TLB, es posible no comenzar la b√∫squeda <br>  desde el nivel cero (pgd *), e inmediatamente verifique el √∫ltimo nivel del veh√≠culo (pte *). <br>  No hay requisitos de hardware para mapear esta √°rea en s√≠, Wirth.  direcciones de <br>  solo es necesario como √≠ndices para la b√∫squeda de TLB.  Sin embargo, en el n√∫cleo de <br>  el √∫ltimo pgd en el nivel cero de la tabla de p√°ginas se escribe nat.  la direcci√≥n de este <br>  nivel m√°s cero  Como resultado, solo <br>  los √∫ltimos 4 KB del √°rea ff80'0000'0000 - ffff'ffff'ffff - es decir  justo <br>  Nivel cero del veh√≠culo.  Esto permite que pgd * sea accesible por ordinario <br>  leer / escribir instrucciones trabajando en direcciones virtuales. </blockquote><br>  Como resultado, se decidi√≥ simplemente poner en este registro un gran valor, que no nos molestar√°.  Despu√©s de todo, la soluci√≥n propuesta nos permite optimizar la b√∫squeda de p√°ginas, pero a√∫n no nos hemos dedicado a la optimizaci√≥n.  Se entrega igual que en Linux. <br><br>  Ahora el registro de control.  Necesita habilitar MMU a trav√©s de √©l.  Los bits conocidos se ven as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _MMU_CR_TLB_EN 0x0000000000000001 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* translation enable */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _MMU_CR_CD_MASK 0x0000000000000006 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* cache disable bits */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _MMU_CR_SET1 0x0000000000000008 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* set #1 enable for 4 MB pages */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _MMU_CR_SET2 0x0000000000000010 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* set #2 enable for 4 MB pages */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _MMU_CR_SET3 0x0000000000000020 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* set #3 enable for 4 MB pages */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* paging enable for second space INTEL */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _MMU_CR_CR0_PG 0x0000000000000040 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* page size 4Mb enable for second space INTEL */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _MMU_CR_CR4_PSE 0x0000000000000080 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* cache disable for secondary space INTEL */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _MMU_CR_CR0_CD 0x0000000000000100 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* TLU enable for secondary space INTEL */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _MMU_CR_TLU2_EN 0x0000000000000200 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* memory protection table enable for LD from secondary space INTEL */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _MMU_CR_LD_MPT 0x0000000000000400 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _MMU_CR_IPD_MASK 0x0000000000000800 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Instruction Prefetch Depth */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _MMU_CR_UPT_EN 0x0000000000001000 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* enable UPT */</span></span></span></span></code> </pre> <br>  Estamos interesados ‚Äã‚Äãen el primer bit, que incluye la traducci√≥n de direcciones. <br><br>  Tambi√©n configuramos _MMU_CR_SET3, pero no hemos descubierto en qu√© casos particulares se debe hacer esto. <br><br>  Registro de concurso  Bueno, si es simple, entonces este es el PID del proceso o espacio de direcciones.  M√°s t√©cnicamente, esta es una extensi√≥n de direcci√≥n de 11 bits.  En nuestro caso, convertimos todas las p√°ginas en nucleares, al establecer un poco de globalidad en todas nuestras p√°ginas, usamos el mismo espacio de direcciones y, por lo tanto, podemos usar cero en este registro. <br><br>  En el registro de la tabla ra√≠z hay un puntero a la direcci√≥n f√≠sica del comienzo de la tabla de traducci√≥n.  Puede hacer un fraude asignando la tabla tambi√©n a la direcci√≥n especificada en el registro MMU_REG_ELB_PTB, pero como dije, no est√°bamos enfocados en la optimizaci√≥n. <br><br>  ¬øQu√© m√°s puedo decir? La estructura de las tablas es bastante com√∫n, las banderas son las siguientes: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_P 0x0000000000000001ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Page Present bit */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_W 0x0000000000000002ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Writable (0 - only read) */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_UU2 0x0000000000000004ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* unused bit # 2 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_PWT 0x0000000000000008ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Write Through */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_CD1 0x0000000000000010ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Cache disable (right bit) */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_A 0x0000000000000020ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Accessed Page */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_D 0x0000000000000040ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Page Dirty */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_HUGE 0x0000000000000080ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Page Size */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_G 0x0000000000000100ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Global Page */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_CD2 0x0000000000000200ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Cache disable (left bit) */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_NWA 0x0000000000000400ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Prohibit address writing */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_AVAIL 0x0000000000000800ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Available page */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_PFN 0x000000fffffff000ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Physical Page Number */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_VALID 0x0000010000000000ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Valid Page */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_PV 0x0000020000000000ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* PriVileged Page */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_INT_PR 0x0000040000000000ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Integer address access Protection */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_NON_EX 0x0000080000000000ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Non Executable Page */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_RES 0x0000f00000000000ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Reserved bits */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_MMU_PAGE_C_UNIT 0xffff000000000000ULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Compilation Unit */</span></span></span></span></code> </pre> <br>  Para la tabla de 4 niveles, los cambios de direcci√≥n son los siguientes: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __MMU_PGD_SHIFT (PAGE_SHIFT + 3 * (PAGE_SHIFT-3)) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* 39 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __MMU_PUD_SHIFT (PAGE_SHIFT + 2 * (PAGE_SHIFT-3)) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* 30 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __MMU_PMD_SHIFT (PAGE_SHIFT + 1 * (PAGE_SHIFT-3)) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* 21 */</span></span></span></span></code> </pre><br><h3>  Un poco sobre PCI </h3><br><h4>  Comunicaci√≥n a trav√©s de espacios de direcciones alternativos </h4><br>  Antes de pasar a vidyaha y tarjeta de red, regresemos brevemente a PCI.  Ya hablamos un poco sobre esto en la primera parte de <a href="https://habr.com/ru/company/embox/blog/421441/">"Embox comienza a escalar el Monte Elbrus"</a> .  Mostr√≥ macros para comunicarse con espacios de direcciones alternativos: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _E2K_READ_MAS(addr, mas, type, size_letter, chan_letter) \ ({ \ register type res; \ asm volatile (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ld"</span></span></span><span class="hljs-meta"> #size_letter </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">","</span></span></span><span class="hljs-meta"> #chan_letter </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" \t0x0, [%1] %2, %0"</span></span></span><span class="hljs-meta"> \ : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=r"</span></span></span><span class="hljs-meta"> (res) \ : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r"</span></span></span><span class="hljs-meta"> ((__e2k_ptr_t) (addr)), \ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"i"</span></span></span><span class="hljs-meta"> (mas)); \ res; \ }) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _E2K_WRITE_MAS(addr, val, mas, type, size_letter, chan_letter) \ ({ \ asm volatile (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"st"</span></span></span><span class="hljs-meta"> #size_letter </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">","</span></span></span><span class="hljs-meta"> #chan_letter </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" \t0x0, [%0] %2, %1"</span></span></span><span class="hljs-meta"> \ : \ : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r"</span></span></span><span class="hljs-meta"> ((__e2k_ptr_t) (addr)), \ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r"</span></span></span><span class="hljs-meta"> ((type) (val)), \ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"i"</span></span></span><span class="hljs-meta"> (mas) \ : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"memory"</span></span></span><span class="hljs-meta">); \ })</span></span></code> </pre> <br>  Y hab√≠a una referencia al principio de los espacios de direcciones.  Se definen diferentes espacios de direcciones utilizando el MAS (especificador de direcci√≥n de memoria).  Y, por ejemplo, para acceder al IO, a trav√©s del cual se accede al PCI, debe usar 6 y MMU 7. <br><br>  Pero con un estudio m√°s exhaustivo de la macro, puede notar alg√∫n tipo de chan_letter.  Y si nos fijamos en la descripci√≥n de los comandos e2k, encontramos <br><blockquote>  LDD ddd lectura de doble palabra <br>  ldd [direcci√≥n] mas, dst </blockquote><br>  Es decir, a primera vista, no hay canales.  Pero si sigue los enlaces, resulta que el c√≥digo para la operaci√≥n dada ldd es 67. Pero 67 es el c√≥digo para ldd solo para los canales AL0 / AL3 y AL2 / AL5, y para los canales AL1 / AL4 este c√≥digo corresponde a la operaci√≥n POPCNTd. <br><br>  Por lo tanto, no fue posible comprender completamente qu√© canales hay en la terminolog√≠a de Elbrus.  Me atrever√≠a a sugerir que esto ya est√° conectado con el principio vliw, cuando puede especificar qu√© alu se usa, porque en este tipo de arquitectura una de las caracter√≠sticas es la presencia de varios dispositivos inform√°ticos independientes.  Puedo, por supuesto, estar equivocado, pero el hecho es que necesita usar el segundo o quinto canal para acceder a PCI o MMU.  Por lo tanto, el comando se ver√° as√≠: <br><blockquote>  ldd, 2 0x0, [addr_in_mas] mas_id,% reg </blockquote><br><h4>  lspci </h4><br>  Ahora dar√© el resultado de la salida del comando lspci en el dispositivo que tenemos: <br><blockquote>  root @ embox: (nulo) #lspci <br>  00: 0.0 (PCI dev E3E3: ABCD) [6 4] <br>  Puente PCI a PCI: (nulo) Puente Elbrus PCIe (rev 01) <br>  00: 1.0 (PCI dev 8086: E3E3) [6 4] <br>  Puente PCI a PCI: puente Intel Corporation Elbrus Virt PCI (rev 01) <br>  01: 0.0 (PCI dev 1FFF: 8000) [6 4] <br>  Puente PCI a PCI: (nulo) Puente Elbrus PCI (rev 05) <br>  01: 1.0 (PCI dev 8086: 4D45) [2 0] <br>  Controlador Ethernet: Intel Corporation MCST ETH1000 Gigabit Ethernet (rev 01) <br>  01: 2.0 (PCI dev 8086: 4D49) [1 1] <br>  Controlador IDE: Intel Corporation MCST IDE (rev 128) <br>  01: 2.1 (PCI dev 8086: 0002) [7 2] <br>  Comunicaci√≥n simple  controlador: Intel Corporation (nulo) (rev 05) <br>  01: 2.2 (PCI dev 8086: 8000) [7 128] <br>  Comunicaci√≥n simple  Controlador: Intel Corporation Elbrus PCI bridge (rev 00) <br>  01: 2.3 (PCI dev 1013: 6005) [4 1] <br>  Dispositivo multimedia: Cirrus Logic Crystal CS4281 PCI Audio (rev 01) <br>  01: 3.0 (PCI dev 8086: 4748) [1 6] <br>  Controlador de almacenamiento masivo: Intel Corporation MCST SATA (rev 00) <br>  01: 4.0 (PCI dev 8086: 554F) [12 3] <br>  Dispositivo USB: Intel Corporation OHCI para Elbrus (rev 00) <br>  01: 4.1 (PCI dev 8086: 5545) [12 3] <br>  Dispositivo USB: Intel Corporation EHCI para Elbrus (rev 00) <br>  02: 1.0 (PCI dev 126F: 0718) [3 0] <br>  Controlador compatible con VGA: Silicon Motion, Inc.  SM718 LynxSE + (rev 160) <br>  root @ embox: (nulo) # </blockquote><br>  Nota <br><blockquote>  01: 2.2 (PCI dev 8086: 8000) [7 128] <br>  Comunicaci√≥n simple  Controlador: Intel Corporation Elbrus PCI bridge (rev 00) </blockquote><br>  De hecho, es un puerto serie del MCST similar al am85c30, al menos a trav√©s de este dispositivo nos comunicamos a trav√©s de minicom. <br><br><h3>  Tarjeta de red </h3><br><h4>  Estructura general </h4><br>  Ahora vamos a la tarjeta de red. <br><br>  Si entiendo correctamente, esta es la tarjeta de red original, un poco similar en funcionamiento a e1000, pero solo en funcionamiento (como la presencia de descriptores en las colas de recepci√≥n y transmisi√≥n). <br><br>  Ahora m√°s sobre los puntos importantes que encontramos. <br><br>  Tarjeta de red PCI VID: PID 0x8086: 0x4D45.  No se sorprenda de que el VID sea el mismo que Intel, el MCST a menudo usa este VID en particular, observe al menos el dispositivo de puerto serie mencionado anteriormente. <br><br>  BAR0 contiene una base de registro.  Los registros son los siguientes: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> L_E1000_E_CSR 0x00 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Ethernet Control/Status Register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> L_E1000_MGIO_CSR 0x04 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* MGIO Control/Status Register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> L_E1000_MGIO_DATA 0x08 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* MGIO Data Register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> L_E1000_E_BASE_ADDR 0x0c </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* EthernetBase Address Register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> L_E1000_DMA_BASE_ADDR 0x10 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* DMA Base Address Register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> L_E1000_PSF_CSR 0x14 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pause Frame Control/Status Register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> L_E1000_PSF_DATA 0x18 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pause Frame Data Register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> L_E1000_INT_DELAY 0x1c </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Interrupt Delay Register */</span></span></span></span></code> </pre> <br>  Los √∫ltimos tres (L_E1000_PSF_CSR, L_E1000_PSF_DATA, L_E1000_INT_DELAY) no los utilizamos, por lo que no hablaremos de ellos.  Comencemos con MGIO, todo es simple: lectura-escritura usando el protocolo MII, es decir, comunicaci√≥n con el chip PHY.  Espec√≠ficamente, tenemos un chip DP83865. <br><br>  Los procedimientos no son particularmente notables, simplemente los enumerar√©. <br><br>  Lectura: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e1000_mii_readreg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct net_device *dev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> phy_id, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reg_num)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l_e1000_priv</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ep</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">netdev_priv</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> rd; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> val_out = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; rd = <span class="hljs-number"><span class="hljs-number">0</span></span>; rd |= <span class="hljs-number"><span class="hljs-number">0x2</span></span> &lt;&lt; MGIO_CS_OFF; rd |= <span class="hljs-number"><span class="hljs-number">0x1</span></span> &lt;&lt; MGIO_ST_OF_F_OFF; rd |= <span class="hljs-number"><span class="hljs-number">0x2</span></span> &lt;&lt; MGIO_OP_CODE_OFF; <span class="hljs-comment"><span class="hljs-comment">/* Read */</span></span> rd |= (phy_id &amp; <span class="hljs-number"><span class="hljs-number">0x1f</span></span>) &lt;&lt; MGIO_PHY_AD_OFF; rd |= (reg_num &amp; <span class="hljs-number"><span class="hljs-number">0x1f</span></span>) &lt;&lt; MGIO_REG_AD_OFF; e1000_write_mgio_data(ep, rd); rd = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i != <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e1000_read_mgio_csr(ep) &amp; MGIO_CSR_RRDY) { rd = (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>)e1000_read_mgio_data(ep); val_out = rd &amp; <span class="hljs-number"><span class="hljs-number">0xffff</span></span>; log_debug(<span class="hljs-string"><span class="hljs-string">"reg 0x%x &gt;&gt;&gt; 0x%x"</span></span>, reg_num, val_out); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val_out; } usleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); } log_error(<span class="hljs-string"><span class="hljs-string">"mdio_read: Unable to read from MGIO_DATA reg\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val_out; }</code> </pre> <br>  Registro: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e1000_mii_writereg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct net_device *dev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> phy_id, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reg_num, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l_e1000_priv</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ep</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">netdev_priv</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> wr; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; wr = <span class="hljs-number"><span class="hljs-number">0</span></span>; wr |= <span class="hljs-number"><span class="hljs-number">0x2</span></span> &lt;&lt; MGIO_CS_OFF; wr |= <span class="hljs-number"><span class="hljs-number">0x1</span></span> &lt;&lt; MGIO_ST_OF_F_OFF; wr |= <span class="hljs-number"><span class="hljs-number">0x1</span></span> &lt;&lt; MGIO_OP_CODE_OFF; <span class="hljs-comment"><span class="hljs-comment">/* Write */</span></span> wr |= (phy_id &amp; <span class="hljs-number"><span class="hljs-number">0x1f</span></span>) &lt;&lt; MGIO_PHY_AD_OFF; wr |= (reg_num &amp; <span class="hljs-number"><span class="hljs-number">0x1f</span></span>) &lt;&lt; MGIO_REG_AD_OFF; wr |= val &amp; <span class="hljs-number"><span class="hljs-number">0xffff</span></span>; log_debug(<span class="hljs-string"><span class="hljs-string">"reg 0x%x &lt;&lt;&lt; 0x%x"</span></span>, reg_num, val); e1000_write_mgio_data(ep, wr); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i != <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e1000_read_mgio_csr(ep) &amp; MGIO_CSR_RRDY) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } usleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); } log_error(<span class="hljs-string"><span class="hljs-string">"Unable to write MGIO_DATA reg: val = 0x%x"</span></span>, wr); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br>  Ahora L_E1000_DMA_BASE_ADDR y L_E1000_E_BASE_ADDR, de hecho, describen un par√°metro, la direcci√≥n del bloque de descripci√≥n de la tarjeta de red.  Es decir, la direcci√≥n en Elbrus es de 64 bits y los registros son de 32 bits. <br><br>  En realidad codificar: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* low 32 bits */</span></span> init_block_addr_part = (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)((<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>)ep-&gt;init_block &amp; <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>); e1000_write_e_base_addr(ep, init_block_addr_part); log_debug(<span class="hljs-string"><span class="hljs-string">"Init Block Low DMA addr: 0x%x"</span></span>, init_block_addr_part); <span class="hljs-comment"><span class="hljs-comment">/* high 32 bits */</span></span> init_block_addr_part = (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)(((<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>)(ep-&gt;init_block) &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>); e1000_write_dma_base_addr(ep, init_block_addr_part); log_debug(<span class="hljs-string"><span class="hljs-string">"Init Block High DMA addr: 0x%x"</span></span>, init_block_addr_part); <span class="hljs-comment"><span class="hljs-comment">/************************************************************************/</span></span></code> </pre><br>  De lo que se puede ver que L_E1000_DMA_BASE_ADDR es la parte superior, y L_E1000_DMA_BASE_ADDR es la parte inferior de la direcci√≥n de un determinado bloque de inicializaci√≥n (en realidad un bloque de descripci√≥n de tarjeta). <br><br>  La estructura de descripci√≥n es la siguiente: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l_e1000_init_block</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> mode; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> paddr[<span class="hljs-number"><span class="hljs-number">6</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> laddrf; <span class="hljs-comment"><span class="hljs-comment">/* 31:4 = addr of rx desc ring (16 bytes align) + * 3:0 = number of descriptors (the power of two) * 0x09 is max value (desc number = 512 if [3:0] &gt;= 0x09) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> rdra; <span class="hljs-comment"><span class="hljs-comment">/* 31:4 = addr of tx desc ring (16 bytes align) + * 3:0 = number of descriptors (the power of two) * 0x09 is max value (desc number = 512 if [3:0] &gt;= 0x09) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> tdra; } __attribute__((packed));</code> </pre> <br>  C laddrf - no entend√≠, por alguna raz√≥n se pone a cero, hicimos lo mismo. <br><br>  paddr: como puede suponer, mac es la direcci√≥n de la tarjeta de red. <br><br>  rdra y tdra contienen las direcciones de los anillos de los descriptores de memoria, los 4 bits inferiores se asignan al tama√±o del anillo, y este es el logaritmo del tama√±o.  Es decir, si hay 8, entonces el n√∫mero de descriptores en el anillo ser√° 2 ^ 8 (1 &lt;&lt; 8 == 256). <br><br>  modo es el modo de la tarjeta, los bits son los siguientes: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRX (1 &lt;&lt; 0) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Receiver disable */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DTX (1 &lt;&lt; 1) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Transmitter disable */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LOOP (1 &lt;&lt; 2) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* loopback */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DTCR (1 &lt;&lt; 3) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* disable transmit crc */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> COLL (1 &lt;&lt; 4) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* force collision */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRTY (1 &lt;&lt; 5) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* disable retry */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> INTL (1 &lt;&lt; 6) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Internal loopback */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EMBA (1 &lt;&lt; 7) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* enable modified back-off algorithm */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EJMF (1 &lt;&lt; 8) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* enable jambo frame */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EPSF (1 &lt;&lt; 9) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* enable pause frame */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FULL (1 &lt;&lt; 10) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* full packet mode */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PROM (1 &lt;&lt; 15) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* promiscuous mode */</span></span></span></span></code> </pre> <br>  Es decir, cuando todo est√° configurado, debe establecer el bit 10. Si desea un modo promiscuo, entonces tambi√©n 15. <br><br><h4>  Descriptores de paquetes </h4><br>  Ahora sobre el formato de los descriptores de paquetes. <br><br>  En la recepci√≥n: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l_e1000_rx_desc</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> base; <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> buf_length; <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> status; <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> msg_length; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> reserved1; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> etmr; } __attribute__((packed));</code> </pre> <br>  base: probablemente comprenda que esta es la direcci√≥n del b√∫fer para el paquete <br>  buf_length - tama√±o del b√∫fer <br>  msg_length: despu√©s de recibir, contiene la longitud del paquete recibido <br>  estado: estado del descriptor.  Cuando el paquete se prepara y se entrega a la DMA (tarjeta), debe establecer el bit 15 (RD_OWN).  Si todo est√° bien, luego de recibir el paquete en este descriptor, este bit se restablecer√° y se establecer√°n 9 (RD_STP) y 8 (RD_ENP). <br><br>  Todos los bits de estado son los siguientes: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* RX Descriptor status bits */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RD_OWN (1 &lt;&lt; 15) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RD_ERR (1 &lt;&lt; 14) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RD_FRAM (1 &lt;&lt; 13) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RD_OFLO (1 &lt;&lt; 12) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RD_CRC (1 &lt;&lt; 11) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RD_BUFF (1 &lt;&lt; 10) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RD_STP (1 &lt;&lt; 9) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RD_ENP (1 &lt;&lt; 8) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RD_PAM (1 &lt;&lt; 6) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RD_LAFM (1 &lt;&lt; 4) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RD_BAM (1 &lt;&lt; 3)</span></span></code> </pre> <br>  En transferencia: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l_e1000_tx_desc</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> base; <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> buf_length; <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> status; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> misc; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> etmr; } __attribute__((packed));</code> </pre><br>  Casi lo mismo que recibir, los bits de estado son los siguientes: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* TX Descriptor status bits */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TD_OWN (1 &lt;&lt; 15) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TD_ERR (1 &lt;&lt; 14) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TD_AFCS (1 &lt;&lt; 13) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TD_NOINTR (1 &lt;&lt; 13) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TD_MORE (1 &lt;&lt; 12) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TD_ONE (1 &lt;&lt; 11) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TD_DEF (1 &lt;&lt; 10) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TD_STP (1 &lt;&lt; 9) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TD_ENP (1 &lt;&lt; 8)</span></span></code> </pre> <br>  Cuando se env√≠a un paquete, es necesario establecer 15 (TD_OWN), 9 (TD_STP) y 8 (TD_ENP) en consecuencia.  El bit 8 significa que este es el √∫ltimo paquete que se procesar√°, por lo tanto, si se env√≠a un paquete, solo necesita instalarlo en el √∫ltimo. <br><br>  Tambi√©n olvid√© una caracter√≠stica importante, la longitud del b√∫fer en los descriptores se escribe con un signo menos, probablemente en un c√≥digo adicional.  Incluso en little-endian, pero dado que Elbrus tiene el mismo orden de bytes, esto probablemente no sea importante. <br><br><h4>  Registro de gesti√≥n </h4><br>  Ahora describimos el √∫ltimo registro sin ensamblar L_E1000_E_CSR: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* E_CSR register bits */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 31:21 unused, readed as 0 */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_ATME (1 &lt;&lt; 24) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW, Add Timer Enable */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_TMCE (1 &lt;&lt; 23) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW, Timer Clear Enable */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_DRIN (1 &lt;&lt; 22) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW, Disable RX Interrupt */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_DTIN (1 &lt;&lt; 21) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW, Disable TX Interrupt */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_ESLE (1 &lt;&lt; 20) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW, Enable Slave Error */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_SLVE (1 &lt;&lt; 19) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW1c, Slave Error */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_PSFI (1 &lt;&lt; 18) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW1c, Pause Frame Interrupt */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* 17 unused, read as 0 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_SINT (1 &lt;&lt; 16) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* R, Status Interrupt */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_ERR (1 &lt;&lt; 15) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* R, Error */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_BABL (1 &lt;&lt; 14) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW1c, Babble */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_CERR (1 &lt;&lt; 13) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW1c, Collision Error */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_MISS (1 &lt;&lt; 12) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW1c, Missed Packet */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_MERR (1 &lt;&lt; 11) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW1c, Memory Error */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_RINT (1 &lt;&lt; 10) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW1c, Receiver Interrupt */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_TINT (1 &lt;&lt; 9) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW1c, Transmiter Interrupt */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_IDON (1 &lt;&lt; 8) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW1c, Initialization Done */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_INTR (1 &lt;&lt; 7) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* R, Interrupt Flag */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_INEA (1 &lt;&lt; 6) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW, Interrupt Enable */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_RXON (1 &lt;&lt; 5) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* R, Receiver On */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_TXON (1 &lt;&lt; 4) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* R, Transmiter On */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_TDMD (1 &lt;&lt; 3) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW1, Transmit Demand */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_STOP (1 &lt;&lt; 2) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW1, Stop */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_STRT (1 &lt;&lt; 1) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW1, Start */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E_CSR_INIT (1 &lt;&lt; 0) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RW1, Initialize */</span></span></span></span></code> </pre><br><h4>  Inicializaci√≥n </h4><br>  Hay una secuencia de inicializaci√≥n algo inusual: <br><blockquote>  STOP-&gt; INIT-&gt; IDON-&gt; STRT </blockquote><br>  En este caso, los bits RXON y TXON aumentan independientemente. <br>  M√°s detalles se pueden encontrar en nuestro controlador. <br><br><h2>  Tarjeta de video </h2><br>  Como ya se se√±al√≥, nuestro dispositivo utiliza una vidyah Silicon Motion llamada SM718 LynxSE +.  Por lo tanto, todo es simple, hay <a href="https://github.com/torvalds/linux/tree/master/drivers/staging/sm750fb">fuentes de controladores en Linux</a> y no hay nada que describir en realidad. <br><br>  Bueno, excepto que el video muestra que result√≥ ser muy bajo en fps, se siente como un acceso lento a la memoria.  Pero esto es sin la optimizaci√≥n del compilador, y en general, tal vez este es nuestro problema asociado con el uso incorrecto de la arquitectura e2k. <br><br><h3>  Bueno, ¬øqu√© m√°s decir sobre <s>Sakhalin</s> Elbrus? </h3><br>  En principio, el clima es normal :) <br><br>  Aparentemente, Elbrus existe, trabaja.  Personalmente, veo el principal problema del desarrollo de esta interesante arquitectura como su cercan√≠a.  Es dif√≠cil creer que una empresa relativamente peque√±a pueda crear un procesador, un compilador, brindar soporte y todo lo dem√°s.  S√≠, comenzaron a aparecer desarrolladores de software de terceros, el mismo Basalt-SPO es compatible con <a href="https://www.altlinux.org/%25D0%25AD%25D0%25BB%25D1%258C%25D0%25B1%25D1%2580%25D1%2583%25D1%2581">Alt-Linux, que se puede instalar en Elbrus</a> . <br><br>  S√≠, hubo informes de que desarrolladores <a href="https://m.vk.com/wall-71796881_858">externos</a> est√°n fabricando hardware basado en el procesador Elbrus, por ejemplo <a href="https://m.vk.com/wall-71796881_858">Fastwel</a> .  Pero todos estos son solo peque√±os avances hacia la apertura.  Un ejemplo muy simple, para reproducir lo que hemos dicho y mostrado aqu√≠, necesitamos un compilador, y solo el <a href="http://www.mcst.ru/">MCST lo tiene</a> , la informaci√≥n proporcionada en el art√≠culo es una adici√≥n a la informaci√≥n recibida de, nuevamente, el <a href="http://www.mcst.ru/">MCST</a> , y todav√≠a no digo que es poco probable encontrar una pieza de hierro incluso en el MCST.  Es bastante antiguo e <a href="http://www.mcst.ru/">ICST</a> ofrece modelos m√°s nuevos. <br><br>  PD: Naturalmente, puedes ver todo en <a href="https://github.com/embox/embox">el repositorio de Embox</a> . <br><br>  PPS Ven al canal de telegramas ruso a trav√©s de Embox ( <a href="https://t.me/embox_chat">https://t.me/embox_chat</a> ). <br><br>  PPS Embox ha actualizado el segundo componente de la versi√≥n, ahora el actual <a href="">0.4.0</a> </div></div><p>Source: <a href="https://habr.com/ru/post/485694/">https://habr.com/ru/post/485694/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../485660/index.html">La propia compa√±√≠a de protecci√≥n DDoS lanz√≥ ataques DDoS, admiti√≥ su fundador.</a></li>
<li><a href="../485664/index.html">Crear par√°metros din√°micos en un trabajo de Jenkins, o c√≥mo hacer que su tarea sea f√°cil de usar</a></li>
<li><a href="../485672/index.html">Mejores pr√°cticas de Redis, parte 1</a></li>
<li><a href="../485688/index.html">Myapp extiende vacaciones</a></li>
<li><a href="../485692/index.html">Asesoramiento del especialista de TI al cliente, o c√≥mo automatizar el desorden</a></li>
<li><a href="../485702/index.html">Meetup FunCorp iOS # 2</a></li>
<li><a href="../485704/index.html">Pixel art para principiantes: arreglando errores comunes</a></li>
<li><a href="../485706/index.html">Te invitamos a la reuni√≥n "Transformaci√≥n digital y nuevos roles en la ciencia de datos"</a></li>
<li><a href="../485712/index.html">La gerencia no es una oraci√≥n</a></li>
<li><a href="../485716/index.html">Calico para redes en Kubernetes: conocer y un poco de experiencia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>