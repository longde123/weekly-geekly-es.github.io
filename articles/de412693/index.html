<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¶üèª üéöÔ∏è ü•á Schreiben Sie Code, der leicht zu entfernen und zu debuggen ist ü§¥ üõÄüèº ü•¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einfach zu debuggender Code ist Code, der Sie nicht t√§uscht. Es ist schwieriger, Code mit verstecktem Verhalten, schlechter Fehlerbehandlung, Unsicher...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schreiben Sie Code, der leicht zu entfernen und zu debuggen ist</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/412693/"><img src="https://habrastorage.org/webt/zf/0a/g4/zf0ag4yxvf4vsw9xoftd_acnr38.png"><br><br>  Einfach zu debuggender Code ist Code, der Sie nicht t√§uscht.  Es ist schwieriger, Code mit verstecktem Verhalten, schlechter Fehlerbehandlung, Unsicherheiten, unzureichender oder √ºberm√§√üig strukturierter Struktur oder √Ñnderungen zu debuggen.  In ausreichend gro√üen Projekten erhalten Sie Code, den Sie nicht verstehen k√∂nnen. <br><br>  Wenn das Projekt relativ alt ist, sto√üen Sie m√∂glicherweise auf Code, den Sie √ºberhaupt vergessen haben, und wenn das Commit-Protokoll nicht vorhanden w√§re, w√ºrden Sie schw√∂ren, dass diese Zeilen nicht von Ihnen geschrieben wurden.  Wenn das Projekt w√§chst, wird es schwieriger, sich daran zu erinnern, was verschiedene Codeteile tun.  Und die Situation versch√§rft sich, wenn der Code nicht das tut, was er zu tun scheint.  Und wenn Sie Code √§ndern m√ºssen, den Sie nicht verstehen, m√ºssen Sie es schwer herausfinden: Debuggen. <br><br>  Die F√§higkeit, Code zu schreiben, der einfach zu debuggen ist, beginnt mit dem Verst√§ndnis, dass Sie sich an nichts erinnern, was zuvor geschrieben wurde. <br><a name="habracut"></a><br><h2>  Regel 0: Guter Code enth√§lt offensichtliche Fehler. </h2><br>  Anbieter weit verbreiteter Technologien behaupten, dass "klaren Code schreiben" "sauberen Code schreiben" bedeutet.  Das Problem ist, dass der Grad der ‚ÄûReinheit‚Äú sehr kontextsensitiv ist.  Reiner Code kann im System fest codiert werden, und manchmal wird ein schmutziger Hack geschrieben, damit er leicht deaktiviert werden kann.  Manchmal wird der Code als sauber angesehen, weil der gesamte Schmutz irgendwohin geschoben wird.  Guter Code ist nicht unbedingt sauber. <br><br>  Sauberkeit kennzeichnet den Grad des Stolzes (oder der Schande), den der Entwickler in Bezug auf diesen Code erlebt, und nicht die einfache Wartung oder √Ñnderung.  Es ist besser, uns einen langweiligen Code zu geben, als einen sauberen, dessen √Ñnderungen offensichtlich sind: Ich habe festgestellt, dass die Leute eher bereit sind, die Codebasis zu √§ndern, wenn die Frucht niedrig genug h√§ngt und leicht zu pfl√ºcken ist.  Der beste Code ist m√∂glicherweise der, den Sie gerade angesehen und sofort verstanden haben, wie er funktioniert. <br><br><ul><li>  Code, der nicht versucht, ein h√§ssliches Problem zu erstellen, um gut auszusehen, oder ein langweiliges Problem, um interessant auszusehen. </li><li>  Code, bei dem die Fehler offensichtlich und das Verhalten klar sind, im Gegensatz zu Code ohne offensichtliche Fehler und mit unklarem Verhalten. </li><li>  Der Code, in dem es dokumentiert ist, in dem es nicht ideal ist, im Gegensatz zu dem Code, der nach Perfektion strebt. </li><li>  Code mit einem so offensichtlichen Verhalten, dass jeder Entwickler unz√§hlige verschiedene M√∂glichkeiten finden kann, diesen Code zu √§ndern. </li></ul><br>  Manchmal ist der Code so b√∂se, dass jeder Versuch, ihn sauberer zu machen, die Situation nur versch√§rft.  Das Schreiben von Code ohne Verst√§ndnis der Konsequenzen ihrer Handlungen kann auch als Ritual zum Aufrufen von bequem gepflegtem Code angesehen werden. <br><br>  Ich m√∂chte nicht sagen, dass sauberer Code schlecht ist, aber manchmal sieht der Wunsch nach Sauberkeit eher so aus, als w√ºrde man M√ºll unter einen Teppich kehren.  Das Debuggen von Code ist nicht unbedingt sauber.  und mit √úberpr√ºfungen oder Fehlerbehandlung √ºberf√ºllter Code ist selten lesbar. <br><br><h2>  Regel 1: Es gibt immer Probleme im Computer </h2><br>  Der Computer hat Probleme und das Programm ist beim letzten Lauf abgest√ºrzt. <br><br>  Die Anwendung muss zuerst sicherstellen, dass sie von einem bekannten, guten und sicheren Zustand ausgeht, bevor sie versucht, etwas zu tun.  Manchmal gibt es einfach keine Kopie des Status, weil der Benutzer ihn gel√∂scht oder den Computer aktualisiert hat.  Das Programm st√ºrzte beim letzten Lauf und paradoxerweise auch beim ersten Lauf ab. <br><br>  Wenn Sie beispielsweise den Status einer Datei lesen oder schreiben, k√∂nnen die folgenden Probleme auftreten: <br><br><ul><li>  Die Datei fehlt. </li><li>  Die Datei ist besch√§digt. </li><li>  Datei einer √§lteren oder neueren Version. </li><li>  Die letzte √Ñnderung an der Datei ist nicht abgeschlossen. </li><li>  Das Dateisystem l√ºgt dich an. </li></ul><br>  Diese Probleme sind nicht neu, Datenbanken sind seit der Antike (1970-01-01) auf sie gesto√üen.  Die Verwendung von SQLite hilft bei der Bew√§ltigung vieler √§hnlicher Probleme. Wenn das Programm jedoch bei der letzten Ausf√ºhrung abst√ºrzt, funktioniert der Code m√∂glicherweise mit fehlerhaften Daten und / oder fehlerhaften Methoden. <br><br>  Bei geplanten Programmen passiert beispielsweise etwas aus dieser Liste: <br><br><ul><li>  Aufgrund der Sommerzeit startet das Programm zweimal in einer Stunde. </li><li>  Das Programm wird zweimal gestartet, da der Bediener vergessen hat, dass es bereits ausgef√ºhrt wird. </li><li>  Das Programm wird sp√§t gestartet, da nicht gen√ºgend Speicherplatz oder mysteri√∂se Cloud- oder Netzwerkprobleme vorhanden sind. </li><li>  Das Programm l√§uft l√§nger als eine Stunde, was zu einer Verz√∂gerung bei nachfolgenden Programmaufrufen f√ºhren kann. </li><li>  Das Programm startet zur falschen Tageszeit. </li><li>  Das Programm wird unweigerlich kurz vor einer Grenzzeit ausgef√ºhrt, z. B. Mitternacht, dem Ende des Monats oder Jahres, und schl√§gt aufgrund von Rechenfehlern fehl. </li></ul><br>  Das Erstellen nachhaltiger Software beginnt mit dem Schreiben von Software, die denkt, dass sie beim letzten Mal gefallen ist, und st√ºrzt ab, wenn Sie nicht wissen, was Sie tun sollen.  Das Beste daran, eine Ausnahme auszul√∂sen und einen Kommentar im Stil ‚ÄûDies sollte nicht passieren‚Äú zu hinterlassen, ist, dass Sie, wenn dies unvermeidlich passiert, einen Vorsprung beim Debuggen Ihres Codes haben. <br><br>  Das Programm ist nicht einmal verpflichtet, sich von einem Fehler zu erholen, es reicht aus, um es aufzugeben und die Situation nicht zu verschlechtern.  Kleine √úberpr√ºfungen, die Ausnahmen generieren, k√∂nnen Wochen beim Snooping sparen, und eine einfache Sperrdatei kann Stunden bei der Wiederherstellung nach Sicherungen sparen. <br><br>  Code, der leicht zu debuggen ist, ist: <br><br><ul><li>  ein Code, der pr√ºft, ob alles in Ordnung ist, bevor er das tut, was er verlangt; </li><li>  Code, der es einfach macht, in einen bekannten Zustand zur√ºckzukehren und es erneut zu versuchen; </li><li>  sowie Code mit Sicherheitsstufen, die dazu f√ºhren, dass Fehler so fr√ºh wie m√∂glich auftreten. </li></ul><br><h2>  Regel 2: Ihr Programm k√§mpft mit sich selbst </h2><br><blockquote>  <i>Der gr√∂√üte DoS-Angriff in der Geschichte von Google kam von uns selbst (weil unsere Systeme sehr gro√ü sind).</i>  <i>Zwar versucht von Zeit zu Zeit jemand, uns auf St√§rke zu testen, aber wir k√∂nnen uns dennoch mehr schaden als andere.</i> <i><br><br></i>  <i>Dies gilt f√ºr alle unsere Systeme.</i> <br><br>  Astrid Atkinson, Ingenieurin f√ºr langes Spiel <br></blockquote><br>  Programme st√ºrzen w√§hrend des letzten Laufs immer ab, es ist immer nicht gen√ºgend Prozessor, Speicher oder Speicherplatz vorhanden.  Alle Mitarbeiter h√§mmern in eine leere Warteschlange, alle versuchen, eine fehlgeschlagene und seit langem veraltete Anforderung zu wiederholen, und alle Server pausieren gleichzeitig w√§hrend der Speicherbereinigung.  Das System ist nicht nur kaputt, es versucht st√§ndig, sich selbst zu kaputt zu machen. <br><br>  Gro√üe Schwierigkeiten k√∂nnen sogar zu einer √úberpr√ºfung des Systems f√ºhren. <br><br>  Das Implementieren einer Serverbetriebspr√ºfung kann einfach sein, jedoch nur, wenn keine Anforderungen verarbeitet werden.  Wenn Sie die Dauer der kontinuierlichen Betriebszeit nicht √ºberpr√ºfen, liegt das Programm m√∂glicherweise zwischen den √úberpr√ºfungen.  Fehler k√∂nnen auch durch Integrit√§tspr√ºfungen ausgel√∂st werden: Ich musste Pr√ºfungen schreiben, die zum Absturz des Systems f√ºhrten, das sie sch√ºtzen mussten.  Zweimal mit einer Differenz von drei Monaten. <br><br>  Der Fehlerbehandlungscode f√ºhrt zwangsl√§ufig dazu, dass noch mehr Fehler entdeckt werden, die verarbeitet werden m√ºssen. Viele davon ergeben sich aus der Fehlerbehandlung selbst.  In √§hnlicher Weise sind Leistungsoptimierungen h√§ufig die Ursache f√ºr Engp√§sse im System.  Eine Anwendung, die auf einer Registerkarte verwendet werden kann, wird zu einem Problem, da sie in 20 Kopien gestartet wird. <br><br>  Ein weiteres Beispiel: Ein Worker in einer Pipeline l√§uft zu schnell und verbraucht verf√ºgbaren Speicher, bevor der n√§chste Teil der Pipeline darauf zugreift.  Dies kann mit Staus verglichen werden: Sie entstehen aufgrund einer Geschwindigkeitssteigerung, und infolgedessen w√§chst die Verkehrs√ºberlastung in die entgegengesetzte Richtung.  Optimierungen k√∂nnen also Systeme erzeugen, die unter hohen oder schweren Lasten stehen, oft auf mysteri√∂se Weise. <br>  Mit anderen Worten: Je schneller das System ist, desto st√§rker ist der Druck auf das System. Wenn Sie dem System nicht erlauben, ein wenig entgegenzuwirken, wundern Sie sich nicht, wenn es bricht. <br><br>  Gegenma√ünahmen sind eine der R√ºckkopplungsformen des Systems.  Das Programm, das einfach zu debuggen ist und den Benutzer in die R√ºckkopplungsschleife einbezieht, erm√∂glicht es Ihnen, alle Verhaltensweisen innerhalb des Systems zu sehen, zuf√§llig, absichtlich, erw√ºnscht und nicht erw√ºnscht.  Sie k√∂nnen diesen Code leicht √ºberpr√ºfen, die damit verbundenen √Ñnderungen sehen und verstehen. <br><br><h2>  Regel 3: Wenn Sie jetzt etwas mehrdeutig lassen, m√ºssen Sie es sp√§ter debuggen </h2><br>  Mit anderen Worten, es sollte f√ºr Sie einfach sein, die Variablen im Programm zu verfolgen und zu verstehen, was passiert.  Nehmen Sie alle Routinen mit Alptraum linearer Algebra, sollten Sie sich bem√ºhen, den Status des Programms so offensichtlich wie m√∂glich darzustellen.  Dies bedeutet, dass Sie mitten in einem Programm den Zweck einer Variablen nicht √§ndern k√∂nnen, da die Verwendung einer Variablen f√ºr zwei verschiedene Zwecke eine Tods√ºnde ist. <br><br>  Dies bedeutet auch, dass Sie das Semi-Pr√§dikat-Problem sorgf√§ltig vermeiden m√ºssen. Verwenden Sie niemals einen einzelnen Wert ( <code>count</code> ), um ein Wertepaar ( <code>boolean</code> , <code>count</code> ) darzustellen.  Es ist zu vermeiden, eine positive Zahl f√ºr das Ergebnis zur√ºckzugeben und gleichzeitig <code>-1</code> wenn nichts √ºbereinstimmt.  Tatsache ist, dass Sie sich leicht in einer Situation befinden k√∂nnen, in der Sie etwas wie " <code>0, but true</code> " ben√∂tigen (und genau das ist eine Funktion in Perl 5).  oder wenn Sie Code erstellen, der sich nur schwer mit anderen Teilen des Systems kombinieren l√§sst ( <code>-1</code> f√ºr den n√§chsten Teil des Programms ist m√∂glicherweise kein Fehler, sondern ein g√ºltiger Eingabewert). <br><br>  Zus√§tzlich zur Verwendung einer Variablen f√ºr zwei Zwecke wird nicht empfohlen, zwei Variablen f√ºr denselben Zweck zu verwenden, insbesondere wenn es sich um eine Boolesche Variable handelt.  Ich will damit nicht sagen, dass es schlecht ist, zwei Zahlen zum Speichern eines Bereichs zu verwenden, aber die Verwendung von Booleschen Zahlen, um den Status eines Programms anzuzeigen, ist oft eine maskierte Zustandsmaschine. <br><br>  Wenn ein Zustand nicht von oben nach unten verl√§uft, dh im Fall eines episodischen Zyklus, ist es am besten, den Zustand mit einer eigenen Variablen zu versehen und die Logik zu l√∂schen.  Wenn das Objekt eine Reihe von Booleschen Werten enth√§lt, ersetzen Sie diese durch eine Variable namens <code>state</code> und verwenden Sie enum (oder eine Zeichenfolge, falls erforderlich, irgendwo).  <code>if</code> Ausdr√ºcke so aussehen, als <code>if state == name</code> , nicht <code>if bad_name &amp;&amp; !alternate_option</code> . <br><br>  Selbst wenn Sie eine explizite Zustandsmaschine erstellen, besteht die M√∂glichkeit einer Verwirrung: Manchmal enth√§lt der Code zwei versteckte Zustandsmaschinen.  Einmal wurde ich gefoltert, um HTTP-Proxys zu schreiben, bis ich jeden Computer explizit machte, den Verbindungsstatus verfolgte und ihn separat analysierte.  Wenn Sie zwei Zustandsautomaten zu einer kombinieren, kann es schwierig sein, einen neuen Zustand hinzuzuf√ºgen oder genau zu verstehen, welchen Zustand etwas haben sollte. <br><br>  Es geht mehr darum, Code zu erstellen, der nicht debuggt werden muss, als um einfaches Debuggen.  Wenn Sie eine Liste korrekter Zust√§nde erstellen, ist es viel einfacher, falsche Zust√§nde zu verwerfen, ohne versehentlich einen oder zwei zu verpassen. <br><br><h2>  Regel 4: Zuf√§lliges Verhalten ist das erwartete Verhalten. </h2><br>  Wenn Sie nicht verstehen, was die Datenstruktur bewirkt, werden diese Wissensl√ºcken von den Benutzern geschlossen: Jedes absichtliche oder zuf√§llige Verhalten des Codes h√§ngt letztendlich von etwas ab.  Viele g√§ngige Programmiersprachen unterst√ºtzen Hash-Tabellen, die iteriert werden k√∂nnen und in den meisten F√§llen die Reihenfolge nach dem Einf√ºgen beibehalten. <br><br>  In einigen Sprachen entspricht das Verhalten der Hash-Tabelle den Erwartungen der meisten Benutzer und durchl√§uft die Schl√ºssel in der Reihenfolge, in der sie hinzugef√ºgt wurden.  In anderen Sprachen gibt die Hash-Tabelle bei jeder Iteration die Schl√ºssel in einer anderen Reihenfolge zur√ºck.  In diesem Fall beschweren sich einige Benutzer, dass das Verhalten <b>nicht</b> zuf√§llig <b>genug ist</b> . <br><br>  Leider wird jede Zufallsquelle in Ihrem Programm irgendwann f√ºr statistische Simulationen oder noch schlimmer f√ºr die Kryptographie verwendet.  und jede Sortierquelle wird zum Sortieren verwendet. <br><br>  In Datenbanken enthalten einige Bezeichner etwas mehr Informationen als andere.  Durch Erstellen einer Tabelle kann der Entwickler zwischen verschiedenen Arten von Prim√§rschl√ºsseln w√§hlen.  Die richtige Wahl ist die UUID oder etwas, das nicht von ihr zu unterscheiden ist.  Der Nachteil anderer Optionen besteht darin, dass sie Bestell- und Identifikationsinformationen offenlegen k√∂nnen.  Das hei√üt, nicht nur <code>a == b</code> , sondern <code>a &lt;= b</code> und andere Optionen bedeuten automatische Inkrementierungsschl√ºssel. <br><br>  Bei Verwendung eines Auto-Inkrement-Schl√ºssels weist die Datenbank jeder Zeile in der Tabelle eine Nummer zu und f√ºgt beim Einf√ºgen einer neuen Zeile 1 hinzu.  Und das Sortieren ist vage: Die Leute wissen nicht, welcher Teil der Daten kanonisch ist.  Mit anderen Worten, sortieren Sie nach Schl√ºssel oder Zeitstempel?  Wie bei einer Hash-Tabelle w√§hlen die Leute selbst die richtige Antwort.  Ein weiteres Problem besteht darin, dass Benutzer benachbarte Datens√§tze mit anderen Schl√ºsseln leicht vorhersagen k√∂nnen. <br><br>  Jeder Versuch, die UUID zu √ºberlisten, schl√§gt jedoch fehl: Wir haben bereits versucht, Postleitzahlen, Telefonnummern und IP-Adressen zu verwenden, und jedes Mal ist dies kl√§glich gescheitert.  Eine UUID erleichtert m√∂glicherweise nicht das Debuggen Ihres Codes, aber weniger zuf√§lliges Verhalten bedeutet weniger Probleme. <br><br>  Aus den Schl√ºsseln k√∂nnen Sie nicht nur Informationen zur Bestellung extrahieren.  Wenn Sie in der Datenbank Schl√ºssel basierend auf anderen Feldern erstellen, verwerfen die Benutzer die Daten und stellen sie aus dem Schl√ºssel wieder her.  Und es treten zwei Probleme auf: Wenn der Status des Programms an mehreren Stellen gespeichert wird, k√∂nnen Kopien sehr leicht nicht miteinander √ºbereinstimmen.  und die Synchronisierung wird schwieriger, wenn Sie nicht sicher sind, welche ge√§ndert werden muss oder welche ge√§ndert wurde. <br><br>  Was auch immer Sie Ihren Benutzern erlauben, sie werden es tun.  Das Schreiben von Code, der leicht zu debuggen ist, bedeutet, √ºber M√∂glichkeiten nachzudenken, ihn zu missbrauchen und wie Menschen im Allgemeinen damit interagieren k√∂nnen. <br><br><h2>  Regel 5: Debuggen ist eine soziale Aufgabe, vor allem eine technische. </h2><br>  Wenn ein Projekt in Komponenten und Systeme unterteilt ist, kann es viel schwieriger sein, Fehler zu finden.  Wenn Sie wissen, wie das Problem auftritt, k√∂nnen Sie die √Ñnderungen in verschiedenen Teilen koordinieren, um das Verhalten zu korrigieren.  Um Fehler in gro√üen Projekten zu beheben, m√ºssen sie weniger gefunden als vielmehr von der Existenz dieser Fehler oder von der M√∂glichkeit der Existenz √ºberzeugt werden. <br>  Es gibt Fehler in der Software, weil niemand ganz sicher ist, wer f√ºr was verantwortlich ist.  Das hei√üt, es ist schwieriger, den Code zu debuggen, wenn nichts geschrieben ist. Sie m√ºssen nach allem in Slack fragen, und niemand antwortet, bis ein Experte kommt. <br><br>  Dies kann mit Planung, Tools, Prozessen und Dokumentation behoben werden. <br><br>  Planung ist ein Weg, um den Stress des Kontakts, die Incident-Management-Struktur, loszuwerden.  Mit den Pl√§nen k√∂nnen Sie K√§ufer informieren, Personen freigeben, die zu lange in Kontakt waren, Probleme verfolgen und √Ñnderungen vornehmen, um zuk√ºnftige Risiken zu verringern.  Tools - eine M√∂glichkeit, die Anforderungen f√ºr die Ausf√ºhrung einiger Arbeiten zu reduzieren, damit andere Entwickler besser darauf zugreifen k√∂nnen.  Ein Prozess ist eine M√∂glichkeit, Verwaltungsfunktionen von einzelnen Teilnehmern zu entfernen und an ein Team weiterzugeben. <br><br>  Menschen und Interaktionsweisen werden sich √§ndern, aber Prozesse und Werkzeuge bleiben erhalten, wenn sich das Team ver√§ndert.  Es ist nicht so, dass eines wichtiger ist als das andere, sondern dass eines darauf ausgelegt ist, √Ñnderungen im anderen zu unterst√ºtzen.  Der Prozess kann auch verwendet werden, um Kontrollfunktionen aus dem Team zu entfernen.  Dies ist nicht immer gut oder schlecht, aber es gibt immer <b>einen</b> Prozess, auch wenn er nicht formuliert ist.  Und die Dokumentation ist der erste Schritt, um andere Menschen diesen Prozess √§ndern zu lassen. <br><br>  Dokumentation ist mehr als Textdateien.  Auf diese Weise k√∂nnen Sie Verantwortung √ºbertragen, wie Sie Mitarbeiter zur Arbeit bringen und wie Sie √Ñnderungen an die von diesen √Ñnderungen Betroffenen melden.  Das Schreiben von Dokumentation erfordert mehr Einf√ºhlungsverm√∂gen als beim Schreiben von Code und mehr F√§higkeiten: Es gibt keine einfachen Compiler-Flags oder Typpr√ºfungen, und Sie k√∂nnen problemlos viele W√∂rter schreiben, ohne etwas zu dokumentieren. <br><br>  Ohne Dokumentation kann man nicht erwarten, dass andere fundierte Entscheidungen treffen oder sogar den Konsequenzen der Verwendung der Software zustimmen.  Ohne Dokumentation, Tools oder Prozesse ist es unm√∂glich, die Wartungslast zu teilen oder zumindest die Personen zu ersetzen, die das Problem jetzt l√∂sen. <br><br>  Der Wunsch, das Debuggen zu vereinfachen, gilt nicht nur f√ºr den Code selbst, sondern auch f√ºr codebezogene Prozesse. Dies hilft zu verstehen, in welche Skin Sie sich begeben m√ºssen, um den Code zu reparieren. <br><br><h2>  Einfach zu debuggender Code ist leicht zu erkl√§ren. </h2><br>  Es gibt eine Meinung, dass Sie es selbst verstehen, wenn Sie jemandem w√§hrend des Debuggens ein Problem erkl√§ren.  Daf√ºr brauchen Sie nicht einmal eine andere Person. Die Hauptsache ist, sich zu zwingen, die Situation von Grund auf neu zu erkl√§ren und die Wiedergabereihenfolge zu erkl√§ren.  Und oft reicht dies aus, um die richtige Entscheidung zu treffen. <br><br>  Wenn.  Wenn wir um Hilfe bitten, fragen wir manchmal nicht, was ben√∂tigt wird.  Dies ist so h√§ufig, dass es als The XY-Problem bezeichnet wird: ‚Äû <i>Wie erhalte ich die letzten drei Buchstaben eines Dateinamens?</i>  <i>Huh?</i>  <i>Nein, ich meinte Expansion</i> . ‚Äú <br><br>  Wir sprechen √ºber ein Problem in Bezug auf eine L√∂sung, die wir verstehen, und wir sprechen √ºber eine L√∂sung in Bezug auf die Konsequenzen, die wir f√ºrchten.  Das Debuggen ist ein schwieriges Verst√§ndnis unerwarteter Konsequenzen und alternativer L√∂sungen. F√ºr einen Programmierer ist es am schwierigsten, zuzugeben, dass er etwas falsch verstanden hat. <br><br>  Es stellte sich heraus, dass dies kein Compilerfehler war. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de412693/">https://habr.com/ru/post/de412693/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de412683/index.html">Wo und wie lernt man maschinelles Lernen?</a></li>
<li><a href="../de412685/index.html">Unity GPU Path Tracing - Teil 2</a></li>
<li><a href="../de412687/index.html">Implementieren Sie IdM. Verfahren und technische Mittel - von Basic bis IdM</a></li>
<li><a href="../de412689/index.html">Predictive IT Analytics optimieren die verteilte Anwendungs√ºberwachung</a></li>
<li><a href="../de412691/index.html">5 Jahre Witz auf Facebook oder forensische Geschichte</a></li>
<li><a href="../de412695/index.html">Das Gesamtbild der Unit-Tests</a></li>
<li><a href="../de412697/index.html">IoT als universelles Fachgebiet f√ºr eine multidisziplin√§re technische Universit√§t</a></li>
<li><a href="../de412699/index.html">Einfache Erkl√§rung der SOLID-Prinzipien</a></li>
<li><a href="../de412701/index.html">Die intelligenteste Heizung</a></li>
<li><a href="../de412703/index.html">Bei einer Konferenz mit Veeam: ein R√ºckblick auf VeeamON 2018 und eine Einladung zum VeeamON-Forum in Moskau</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>