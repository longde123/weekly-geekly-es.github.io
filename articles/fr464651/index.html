<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßîüèæ üíç üìß Biblioth√®que de g√©n√©rateur de code assembleur pour microcontr√¥leurs AVR. Partie 5 üë®‚Äç‚öñÔ∏è üç∫ üì™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚Üê Partie 4. Programmation des p√©riph√©riques et gestion des interruptions 
 Biblioth√®que de g√©n√©rateur de code d'assembleur pour microcontr√¥leurs AVR 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Biblioth√®que de g√©n√©rateur de code assembleur pour microcontr√¥leurs AVR. Partie 5</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464651/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">‚Üê Partie 4. Programmation des p√©riph√©riques et gestion des interruptions</a> </p><br><h2 id="biblioteka-generatora-assemblernogo-koda-dlya-mikrokontrollerov-avr">  Biblioth√®que de g√©n√©rateur de code d'assembleur pour microcontr√¥leurs AVR </h2><br><h3 id="chast-5-proektirovanie-mnogopotochnyh-prilozheniy">  Partie 5. Conception d'applications multithread </h3><br><p>  Dans les parties pr√©c√©dentes de l'article, nous avons d√©velopp√© les bases de la programmation √† l'aide de la biblioth√®que.  Dans la partie pr√©c√©dente, nous nous sommes familiaris√©s avec la mise en ≈ìuvre des interruptions et les restrictions qui peuvent survenir lors de leur utilisation.  Dans cette partie de l'article, nous nous attarderons sur l'une des options possibles pour programmer des processus parall√®les en utilisant la classe <em>Parallel</em> .  L'utilisation de cette classe permet de simplifier la cr√©ation d'applications dans lesquelles les donn√©es doivent √™tre trait√©es dans plusieurs flux de programmes ind√©pendants. </p><a name="habracut"></a><br><p>  Tous les syst√®mes multit√¢ches pour les syst√®mes monoc≈ìur sont similaires les uns aux autres.  Le multithreading est impl√©ment√© gr√¢ce au travail du r√©partiteur, qui alloue un intervalle de temps pour chaque thread, et lorsqu'il se termine, il prend le contr√¥le et donne le contr√¥le au thread suivant.  La diff√©rence entre les diff√©rentes impl√©mentations n'est que dans les d√©tails, nous allons donc nous attarder plus en d√©tail principalement sur les caract√©ristiques sp√©cifiques de cette impl√©mentation. </p><br><p>  L'unit√© d'ex√©cution du processus dans le thread est la t√¢che.  Un nombre illimit√© de t√¢ches peut exister dans le syst√®me, mais √† un moment donn√©, seul un certain nombre d'entre elles peuvent √™tre activ√©es, limit√© par le nombre de flux de travail dans le r√©partiteur.  Dans cette impl√©mentation, le nombre de workflows est sp√©cifi√© dans le constructeur du gestionnaire et ne peut pas √™tre modifi√© ult√©rieurement.  Dans le processus, les threads peuvent effectuer des t√¢ches ou rester libres.  Contrairement √† d'autres solutions, <em>Parallel</em> Manager ne change pas de t√¢ches.  Pour que la t√¢che retourne le contr√¥le au r√©partiteur, les commandes appropri√©es doivent √™tre ins√©r√©es dans son code.  Ainsi, la responsabilit√© de la dur√©e de l'intervalle de temps dans la t√¢che incombe au programmeur, qui doit ins√©rer des commandes d'interruption √† certains endroits du code si la t√¢che prend trop de temps, ainsi que d√©terminer le comportement du thread √† la fin de la t√¢che.  L'avantage de cette approche est que le programmeur contr√¥le les points de commutation entre les t√¢ches, ce qui vous permet d'optimiser consid√©rablement le code de sauvegarde / restauration lors du changement de t√¢ches, ainsi que de vous d√©barrasser de la plupart des probl√®mes li√©s √† l'acc√®s aux donn√©es thread-safe. </p><br><p>  Pour contr√¥ler l'ex√©cution des t√¢ches en cours d'ex√©cution, une classe <em>Signal</em> sp√©ciale est utilis√©e.  Le signal est une variable binaire, dont le r√©glage est utilis√© comme signal d'activation pour d√©marrer une t√¢che dans un flux.  Les valeurs du signal peuvent √™tre d√©finies manuellement ou par un √©v√©nement associ√© √† ce signal. </p><br><p>  Le signal est r√©initialis√© lorsque la t√¢che est activ√©e par le r√©partiteur ou peut √™tre ex√©cut√©e par programme. </p><br><p>  Les t√¢ches dans le syst√®me peuvent √™tre dans les √©tats suivants: </p><br><p>  <strong>D√©sactiv√©</strong> - √©tat initial pour toutes les t√¢ches.  La t√¢che ne prend pas le flux et le contr√¥le d'ex√©cution n'est pas transf√©r√©.  Le retour √† cet √©tat pour les t√¢ches activ√©es se produit √† la fin de la commande. </p><br><p>  <strong>Activ√©</strong> - l'√©tat dans lequel se trouve la t√¢che apr√®s l'activation.  Le processus d'activation associe une t√¢che √† un fil d'ex√©cution et √† un signal d'activation.  Le gestionnaire interroge les threads et d√©marre la t√¢che si le signal de t√¢che est activ√©. </p><br><p>  <strong>Bloqu√©</strong> - lorsqu'une t√¢che est activ√©e, un signal peut d√©j√† lui √™tre affect√© en tant que signal, qui est d√©j√† utilis√© pour contr√¥ler un autre thread.  Dans ce cas, afin d'√©viter l'ambigu√Øt√© du comportement du programme, la t√¢che activ√©e passe √† l'√©tat verrouill√©.  Dans cet √©tat, la t√¢che occupe le thread, mais ne peut pas recevoir de contr√¥le, m√™me si son signal est activ√©.  √Ä la fin des t√¢ches ou lors de la modification du signal d'activation, le r√©partiteur v√©rifie et modifie l'√©tat des t√¢ches dans les threads.  Si les threads ont bloqu√© des t√¢ches pour lesquelles le signal correspond √† celui lib√©r√©, le premier trouv√© est activ√©.  Si n√©cessaire, le programmeur peut verrouiller et d√©verrouiller les t√¢ches ind√©pendamment, en fonction de la logique requise du programme. </p><br><p>  <strong>En attente</strong> - l'√©tat de la t√¢che apr√®s l'ex√©cution de la commande <em>D√©lai</em> .  Dans cet √©tat, la t√¢che ne re√ßoit le contr√¥le que lorsque l'intervalle requis s'est √©coul√©.  Dans la classe <em>Parallel</em> , des interruptions WDT de 16 ms sont utilis√©es pour contr√¥ler le retard, ce qui permet de ne pas occuper les temporisateurs pour les besoins du syst√®me.  Dans le cas o√π vous avez besoin de plus de stabilit√© ou de r√©solution dans de petits intervalles, au lieu de <em>retard,</em> vous pouvez utiliser l'activation par des signaux de minuterie.  Il convient de garder √† l'esprit que la pr√©cision du retard sera toujours faible et fluctuera dans la plage de <em>¬´temps de r√©ponse du r√©partiteur¬ª - ¬´dur√©e maximale de la tranche de temps dans le syst√®me + temps de r√©ponse du r√©partiteur¬ª</em> .  Pour les t√¢ches avec des plages de temps exactes, un mode hybride doit √™tre utilis√©, dans lequel le temporisateur non utilis√© dans la classe <em>Parall√®le</em> fonctionne ind√©pendamment du flux de t√¢ches et traite les intervalles en mode d'interruption pure. </p><br><p>  Chaque t√¢che ex√©cut√©e dans un thread est un processus isol√©.  Cela n√©cessite la d√©finition de deux types de donn√©es: les donn√©es locales d'un flux, qui ne doivent √™tre visibles et modifi√©es que dans le cadre de ce flux, et les donn√©es globales pour l'√©change entre les flux et l'acc√®s aux ressources partag√©es.  Dans le cadre de cette impl√©mentation, les donn√©es globales sont cr√©√©es par des commandes pr√©c√©demment consid√©r√©es au niveau de l'appareil.  Pour cr√©er des variables de t√¢che locales, elles doivent √™tre cr√©√©es √† l'aide de m√©thodes de la classe de t√¢ches.  Le comportement d'une variable de t√¢che locale est le suivant: lorsqu'une t√¢che est interrompue avant de transf√©rer le contr√¥le au r√©partiteur, toutes les variables de registre locales sont stock√©es dans la m√©moire du flux.  Lorsque le contr√¥le est renvoy√©, les variables de registre locales sont restaur√©es avant l'ex√©cution de la commande suivante. <br>  La classe avec l'interface <em>IHeap</em> associ√©e √† la propri√©t√© <em>Heap</em> de la classe <em>Parallel</em> est responsable du stockage des donn√©es de flux local.  L'impl√©mentation la plus simple de cette classe est <em>StaticHeap</em> , qui impl√©mente l'allocation statique des m√™mes blocs de m√©moire pour chaque thread.  Dans le cas o√π les t√¢ches ont une large r√©partition en fonction de l'exigence de la quantit√© de donn√©es locales, vous pouvez utiliser <em>DynamicHeap</em> , qui vous permet de d√©terminer la taille de la m√©moire locale individuellement pour chaque t√¢che.  De toute √©vidence, la surcharge de travail avec la m√©moire de flux dans ce cas sera consid√©rablement plus √©lev√©e. </p><br><p>  Examinons maintenant de plus pr√®s la syntaxe de la classe en utilisant deux flux comme exemple, dont chacun commute ind√©pendamment une sortie de port distincte. </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328 { FCLK = <span class="hljs-number"><span class="hljs-number">16000000</span></span>, CKDIV8 = <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; m.PortB.Direction(<span class="hljs-number"><span class="hljs-number">0x07</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bit1 = m.PortB[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bit2 = m.PortB[<span class="hljs-number"><span class="hljs-number">2</span></span>]; m.PortB.Activate(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tasks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Parallel(m, <span class="hljs-number"><span class="hljs-number">2</span></span>); tasks.Heap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticHeap(tasks, <span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = tasks.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); bit1.Toggle(); tsk.Delay(<span class="hljs-number"><span class="hljs-number">32</span></span>); tsk.TaskContinue(loop); },<span class="hljs-string"><span class="hljs-string">"Task1"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = tasks.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); bit2.Toggle(); tsk.Delay(<span class="hljs-number"><span class="hljs-number">48</span></span>); tsk.TaskContinue(loop); }, <span class="hljs-string"><span class="hljs-string">"Task2"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ca = tasks.ContinuousActivate(tasks.AlwaysOn, t1); tasks.ActivateNext(ca, tasks.AlwaysOn, t2); ca.Dispose(); m.EnableInterrupt(); tasks.Loop();</code> </pre> <br><p>  Les premi√®res lignes du programme vous sont d√©j√† famili√®res.  Dans ceux-ci, nous d√©terminons le type de contr√¥leur et attribuons les premier et deuxi√®me bits du port B comme sortie.  Vient ensuite l'initialisation d'une variable de la classe <em>Parallel</em> , o√π dans le deuxi√®me param√®tre nous d√©terminons le nombre maximum de threads d'ex√©cution.  Dans la ligne suivante, nous allouons de la m√©moire pour accueillir les flux de variables locales.  Nous avons des t√¢ches √©gales, nous utilisons donc <em>StaticHeap</em> .  Le prochain bloc de code est la d√©finition des t√¢ches.  Nous y d√©finissons deux t√¢ches presque identiques.  La seule diff√©rence est le port de contr√¥le et la quantit√© de retard.  Pour travailler avec des objets de t√¢che locaux, un pointeur vers la t√¢che locale <em>tsk</em> est transmis au <em>bloc de code de</em> t√¢che.  Le texte de la t√¢che lui-m√™me est tr√®s simple: </p><br><ul><li>  une √©tiquette locale est cr√©√©e pour organiser un cycle de commutation infini </li><li>  l'√©tat du port est invers√© </li><li>  le contr√¥le est renvoy√© au r√©partiteur et la t√¢che passe en √©tat d'attente pendant le nombre de millisecondes sp√©cifi√© </li><li>  Le pointeur de retour est d√©fini sur le bloc de d√©part du bloc et le contr√¥le est renvoy√© au r√©partiteur. <br>  Evidemment, dans un exemple concret, la derni√®re commande pourrait √™tre remplac√©e par une commande normale pour aller au d√©but du bloc et donn√©e dans l'exemple uniquement √† des fins de d√©monstration.  Si vous le souhaitez, l'exemple peut √™tre facilement d√©velopp√© pour contr√¥ler un grand nombre de conclusions, en copiant les t√¢ches et en augmentant le nombre de threads. </li></ul><br><p>  Une liste compl√®te des commandes d'abandon de t√¢che pour transf√©rer le contr√¥le au r√©partiteur est la suivante <br>  <strong>AWAIT (signal)</strong> - le flux enregistre toutes les variables dans la m√©moire du flux et transf√®re le contr√¥le au r√©partiteur.  La prochaine fois que le flux est activ√©, les variables sont restaur√©es et l'ex√©cution se poursuit, en commen√ßant par l'instruction suivante apr√®s <em>AWAIT</em> .  La commande est con√ßue pour diviser la t√¢che en intervalles de temps et pour impl√©menter la machine d'√©tat selon le sch√©ma <em>Signal ‚Üí Traitement 1 ‚Üí Signal ‚Üí Traitement 2</em> , etc. </p><br><p>  La commande AWAIT peut avoir un signal comme param√®tre facultatif.  Si le param√®tre est vide, le signal d'activation est enregistr√©.  S'il est sp√©cifi√© dans le param√®tre, tous les appels de t√¢che suivants seront effectu√©s lorsque le signal sp√©cifi√© est activ√© et la communication avec le signal pr√©c√©dent est perdue. </p><br><p>  <strong>TaskContinue (√©tiquette, signal)</strong> - la commande termine le flux et donne le contr√¥le au r√©partiteur sans enregistrer les variables.  La prochaine fois que le flux est activ√©, le contr√¥le est transf√©r√© sur l'√©tiquette de l' <em>√©tiquette</em> .  Le param√®tre <em>Signal</em> facultatif vous permet de remplacer le signal d'activation de flux pour le prochain appel.  S'il n'est pas sp√©cifi√©, le signal reste le m√™me.  Une commande sans sp√©cifier de signal peut √™tre utilis√©e pour organiser des cycles au sein d'une seule t√¢che, o√π chaque cycle est ex√©cut√© dans une tranche de temps distincte.  Il peut √©galement √™tre utilis√© pour affecter une nouvelle t√¢che au thread en cours apr√®s avoir termin√© la pr√©c√©dente.  L'avantage de cette approche par rapport au cycle <em>Lib√©rer un fil ‚Üí Mettre en surbrillance un flux</em> est un programme plus efficace.  L'utilisation de <em>TaskContinue</em> √©limine la n√©cessit√© pour le gestionnaire de rechercher un thread libre dans le pool et garantit les erreurs lors de la tentative d'allocation de threads en l'absence de threads libres. </p><br><p>  <strong>TaskEnd ()</strong> - <strong>efface</strong> le flux une fois la t√¢che termin√©e.  La t√¢che se termine, le thread est lib√©r√© et peut √™tre utilis√© pour affecter une nouvelle t√¢che avec la commande <em>Activer</em> . </p><br><p>  <strong>D√©lai (ms)</strong> - le flux, comme dans le cas de l'utilisation d' <em>AWAIT</em> , enregistre toutes les variables dans la m√©moire du flux et transf√®re le contr√¥le au r√©partiteur.  Dans ce cas, la valeur du retard en millisecondes est enregistr√©e dans l'en-t√™te du flux.  Dans la boucle du r√©partiteur, dans le cas d'une valeur non nulle dans le champ de retard, le flux n'est pas activ√©.  La modification des valeurs dans le champ de retard pour tous les flux est effectu√©e en interrompant le temporisateur WDT toutes les 16 ms.  Lorsque la valeur z√©ro est atteinte, l'interdiction d'ex√©cution est supprim√©e et le signal d'activation de flux est d√©fini.  Seule une valeur √† un octet pour le retard est stock√©e dans l'en-t√™te, ce qui donne une plage relativement √©troite de retards possibles.Par cons√©quent, pour impl√©menter des retards plus longs, <em>Delay ()</em> cr√©e une boucle interne √† l'aide de variables de flux locales. <br>  L'activation des commandes dans l'exemple est effectu√©e √† l'aide des commandes <em>ContinuousActivate</em> et <em>ActivateNext</em> .  Il s'agit d'un type sp√©cial d'activation de t√¢che initiale au d√©marrage.  Lors de la phase d'activation initiale, nous avons la garantie de ne pas avoir un seul thread occup√©, de sorte que le processus d'activation ne n√©cessite pas de recherche pr√©alable d'un thread libre pour une t√¢che et vous permet d'activer les t√¢ches en s√©quence.  <em>ContinuousActivate</em> active la t√¢che dans le thread z√©ro et renvoie un pointeur vers l'en-t√™te du thread suivant, et la fonction <em>ActivateNext</em> utilise ce pointeur pour activer les t√¢ches suivantes dans les threads s√©quentiels. </p><br><p>  Comme signal d'activation, l'exemple utilise le signal <em>AlwaysOn</em> .  C'est l'un des signaux du syst√®me.  Son objectif signifie que la t√¢che sera toujours ex√©cut√©e, car il s'agit du seul signal toujours activ√© et non r√©initialis√© par l'utilisation. </p><br><p>  L'exemple se termine par un appel en <em>boucle</em> .  Cette fonction d√©marre le cycle du r√©partiteur, cette commande doit donc √™tre la derni√®re du code. </p><br><p>  Prenons un autre exemple o√π l'utilisation de la biblioth√®que peut simplifier consid√©rablement la structure du code.  Que ce soit un dispositif de contr√¥le conditionnel qui enregistre un signal analogique et l'envoie sous la forme d'un code HEX au terminal. </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); m.FCLK = <span class="hljs-number"><span class="hljs-number">16000000</span></span>; m.CKDIV8 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cData = m.DREG(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> outDigit = m.ARRAY(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> chex = Const.String(<span class="hljs-string"><span class="hljs-string">"0123456789ABCDEF"</span></span>); m.ADC.Clock = eADCPrescaler.S64; m.ADC.ADCReserved = <span class="hljs-number"><span class="hljs-number">0x01</span></span>; m.ADC.Source = eASource.ADC0; m.Usart.Baudrate = <span class="hljs-number"><span class="hljs-number">9600</span></span>; m.Usart.FrameFormat = eUartFrame.U8N1; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> os = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Parallel(m, <span class="hljs-number"><span class="hljs-number">4</span></span>); os.Heap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticHeap(os, <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ADS = os.AddSignal(m.ADC.Handler, () =&gt; m.ADC.Data(cData)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> trm = os.AddSignal(m.Usart.TXC_Handler); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> starts = os.AddLocker(); os.PrepareSignals(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t0 = os.CreateTask((tsk) =&gt; { m.LOOP(m.TempL, (r, l) =&gt; m.GO(l), (r, l) =&gt; { m.ADC.ConvertAsync(); tsk.Delay(<span class="hljs-number"><span class="hljs-number">500</span></span>); }); }, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = os.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mref = m.ROMPTR(); mref.Load(chex); m.TempL.Load(cData.High); m.TempL &gt;&gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>; mref += m.TempL; mref.MLoad(m.TempL); m.TempL.MStore(outDigit[<span class="hljs-number"><span class="hljs-number">0</span></span>]); mref.Load(chex); m.TempL.Load(cData.High); m.TempL &amp;= <span class="hljs-number"><span class="hljs-number">0x0F</span></span>; mref += m.TempL; mref.MLoad(m.TempL); m.TempL.MStore(outDigit[<span class="hljs-number"><span class="hljs-number">1</span></span>]); mref.Load(chex); m.TempL.Load(cData.Low); m.TempL &gt;&gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>; mref += m.TempL; mref.MLoad(m.TempL); m.TempL.MStore(outDigit[<span class="hljs-number"><span class="hljs-number">2</span></span>]); mref.Load(chex); m.TempL.Load(cData.Low); m.TempL &amp;= <span class="hljs-number"><span class="hljs-number">0x0F</span></span>; mref += m.TempL; mref.MLoad(m.TempL); m.TempL.MStore(outDigit[<span class="hljs-number"><span class="hljs-number">3</span></span>]); starts.Set(); tsk.TaskContinue(loop); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = os.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); trm.Clear(); m.TempL.Load(<span class="hljs-string"><span class="hljs-string">'0'</span></span>); m.Usart.Transmit(m.TempL); tsk.AWAIT(trm); m.TempL.Load(<span class="hljs-string"><span class="hljs-string">'x'</span></span>); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.MLoad(outDigit[<span class="hljs-number"><span class="hljs-number">0</span></span>]); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.MLoad(outDigit[<span class="hljs-number"><span class="hljs-number">1</span></span>]); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.MLoad(outDigit[<span class="hljs-number"><span class="hljs-number">2</span></span>]); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.MLoad(outDigit[<span class="hljs-number"><span class="hljs-number">3</span></span>]); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.Load(<span class="hljs-number"><span class="hljs-number">13</span></span>); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.Load(<span class="hljs-number"><span class="hljs-number">10</span></span>); m.Usart.Transmit(m.TempL); tsk.TaskContinue(loop, starts); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = os.ContinuousActivate(os.AlwaysOn, t0); os.ActivateNext(p, ADS, t1); os.ActivateNext(p, starts, t2); m.ADC.Activate(); m.Usart.Activate(); m.EnableInterrupt(); os.Loop();</code> </pre> <br><p>  Cela ne veut pas dire que nous avons vu beaucoup de nouvelles choses ici, mais vous pouvez voir quelque chose d'int√©ressant dans ce code. </p><br><p>  Dans cet exemple, ADC (convertisseur analogique-num√©rique) est tout d'abord mentionn√©.  Ce p√©riph√©rique est con√ßu pour convertir la tension du signal d'entr√©e en un code num√©rique.  Le cycle de conversion est d√©marr√© par la fonction <em>ConvertAsync</em> , qui d√©marre uniquement le processus sans attendre le r√©sultat.  Une fois la conversion termin√©e, le CAN g√©n√®re une interruption qui active le signal <em>adcSig</em> .  Faites attention √† la d√©finition du signal <em>adcSig</em> .  En plus du pointeur d'interruption, il contient √©galement un bloc de code pour stocker les valeurs du registre de donn√©es ADC.  Tout le code qui est de pr√©f√©rence ex√©cut√© imm√©diatement apr√®s une interruption (par exemple, la lecture de donn√©es √† partir des registres de l'appareil) doit √™tre situ√© √† cet endroit. <br>  La t√¢che de <em>conversion</em> consiste √† convertir un code de tension binaire en une repr√©sentation HEX √† quatre caract√®res pour notre terminal conditionnel.  Ici, nous pouvons noter l'utilisation de fonctions pour d√©crire les fragments r√©p√©titifs afin de r√©duire la taille du code source et l'utilisation d'une cha√Æne constante pour la conversion des donn√©es. </p><br><p>  Le probl√®me de <em>transmission</em> est int√©ressant du point de vue de l'impl√©mentation d'une sortie format√©e d'une cha√Æne dans laquelle la sortie de donn√©es statiques et dynamiques est combin√©e.  Le m√©canisme lui-m√™me ne peut pas √™tre consid√©r√© comme id√©al; il s'agit plut√¥t d'une d√©monstration des possibilit√©s de gestion des gestionnaires.  Ici, vous pouvez √©galement faire attention √† la red√©finition du signal d'activation pendant l'ex√©cution, qui change le signal d'activation de <em>ConvS</em> en <em>TxS</em> et vice versa. </p><br><p>  Pour une meilleure compr√©hension, nous d√©crivons en mots l'algorithme du programme. </p><br><p>  Dans l'√©tat initial, nous avons lanc√© trois t√¢ches.  Deux d'entre eux ont des signaux inactifs, car le signal pour la t√¢che de <em>conversion (adcSig) est</em> activ√© √† la fin du cycle de lecture du signal analogique, et <em>ConvS</em> pour la t√¢che de <em>transmission</em> est activ√© par un code qui n'a pas encore √©t√© ex√©cut√©.  Par cons√©quent, la premi√®re t√¢che √† lancer apr√®s le lancement sera toujours la mesure.  Le code de cette t√¢che d√©marre le cycle de conversion ADC, apr√®s quoi la t√¢che de 500 ms entre dans le cycle d'attente.  √Ä la fin du cycle de conversion, l'indicateur <em>adcSig</em> est <em>activ√©</em> , ce qui d√©clenche la t√¢che de <em>conversion</em> .  Dans cette t√¢che, un cycle de conversion des donn√©es re√ßues en cha√Æne est impl√©ment√©.  Avant de quitter la t√¢che, nous <em>activons le</em> drapeau <em>ConvS</em> , indiquant clairement que nous avons de nouvelles donn√©es √† envoyer au terminal.  La commande exit r√©initialise le point de retour au d√©but de la t√¢che et donne le contr√¥le au r√©partiteur.  L' <em>ensemble d'</em> indicateurs <em>ConvS</em> permet de transf√©rer le contr√¥le √† la t√¢che de <em>transmission</em> .  Apr√®s avoir transmis le premier octet de la s√©quence, le signal d'activation de la t√¢che passe √† <em>TxS</em> .  Par cons√©quent, une fois le transfert de l'octet termin√©, la t√¢che de transmission sera √† nouveau appel√©e, ce qui conduira au transfert de l'octet suivant.  Une fois le dernier octet de la s√©quence transmis, la t√¢che renvoie le <em>signal d'</em> activation <em>ConvS</em> et r√©initialise le point de retour au d√©but de la t√¢che.  Le cycle est termin√©.  Le cycle suivant commencera lorsque la t√¢che de mesure terminera l'attente et activera le cycle de mesure suivant. </p><br><p>  Dans presque tous les syst√®mes multit√¢ches, il existe le concept de files d'attente pour l'interaction entre les threads.  Nous avons d√©j√† compris que, comme la commutation entre les t√¢ches dans ce syst√®me est un processus compl√®tement contr√¥l√©, l'utilisation de variables globales pour √©changer des donn√©es entre les t√¢ches est tout √† fait possible.  Cependant, il existe un certain nombre de t√¢ches o√π l'utilisation de files d'attente est justifi√©e.  Par cons√©quent, nous ne laisserons pas de c√¥t√© ce sujet et verrons comment il est impl√©ment√© dans la biblioth√®que. </p><br><p>  Pour impl√©menter une file d'attente dans un programme, il est pr√©f√©rable d'utiliser la classe <em>RingBuff</em> .  La classe, comme son nom l'indique, impl√©mente un tampon en anneau avec des commandes d'√©criture et de r√©cup√©ration.  La lecture et l'√©criture des donn√©es sont effectu√©es par les commandes de <em>lecture</em> et d' <em>√©criture</em> .  Les commandes de lecture et d'√©criture n'ont pas de param√®tres.  Le tampon utilise la variable de registre sp√©cifi√©e dans le constructeur comme source / r√©cepteur de donn√©es.  L'acc√®s √† cette variable se fait via le param√®tre classe <em>IOReg</em> .  L'√©tat du tampon est d√©termin√© par les deux drapeaux <em>Ovf</em> et <em>Empty</em> , qui aident √† d√©terminer l'√©tat de d√©bordement pendant l'√©criture et de d√©bordement pendant la lecture.  De plus, la classe a la capacit√© de d√©terminer le code qui s'ex√©cute sur les √©v√©nements de d√©bordement / d√©bordement.  <em>RingBuff</em> n'a pas de d√©pendances sur la classe <em>Parallel</em> et peut √™tre utilis√© s√©par√©ment.  La limitation lors de l'utilisation de la classe est la capacit√© autoris√©e, qui doit √™tre un multiple de la puissance de deux (8.16.32, etc.) pour des raisons d'optimisation du code. </p><br><p>  Un exemple de travail avec la classe est donn√© ci-dessous. </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> io = m.REG(); <span class="hljs-comment"><span class="hljs-comment">//     16     io. var bf = new RingBuff(m, 16, io) { //    OnOverflow = () =&gt; { AVRASM.Comment("   "); }, OnEmpty = () =&gt; { AVRASM.Comment("   "); } }; var cntr = m.REG(); cntr.Load(16); //       m.LOOP(cntr, (r, l) =&gt; { cntr--; m.IFNOTEMPTY(l); },(r)=&gt; { //         //m.IF(bf.Ovf,()=&gt;{AVRASM.Comment("‚Äù)}; bf.IOReg.Load(cntr); //      bf.Write(); //    }); //     m.LOOP(cntr, (r, l) =&gt; { m.GO(l); }, (r) =&gt; { //         //m.IF(bf.Ovf,()=&gt;{AVRASM.Comment(" ‚Äù)}; bf.Read(); //       IOReg //    });</span></span></code> </pre> <br><p>  Cette partie conclut l'aper√ßu des fonctionnalit√©s de la biblioth√®que.  Malheureusement, il restait un certain nombre d'aspects concernant les capacit√©s de la biblioth√®que, qui n'√©taient m√™me pas mentionn√©s.  √Ä l'avenir, en cas d'int√©r√™t pour le projet, des articles sont pr√©vus pour r√©soudre des probl√®mes sp√©cifiques √† l'aide de la biblioth√®que et une description plus d√©taill√©e des probl√®mes complexes n√©cessitant une publication s√©par√©e. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr464651/">https://habr.com/ru/post/fr464651/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr464641/index.html">Comment configurer PVS-Studio dans Travis CI en utilisant l'exemple de l'√©mulateur de console de jeu PSP</a></li>
<li><a href="../fr464643/index.html">Pas une seule analyse, ni comment cr√©er un processus de gestion des vuln√©rabilit√©s en 9 √©tapes</a></li>
<li><a href="../fr464645/index.html">Comment configurer PVS-Studio dans Travis CI en utilisant l'√©mulateur de console de jeu PSP comme exemple</a></li>
<li><a href="../fr464647/index.html">Journal Harry Potter</a></li>
<li><a href="../fr464649/index.html">Syst√®me de collaboration de documents pour Zimbra Open-Source Edition</a></li>
<li><a href="../fr464655/index.html">Comment les salaires et la popularit√© des langages de programmation ont chang√© au cours des 2 derni√®res ann√©es</a></li>
<li><a href="../fr464657/index.html">Corniche √©lectrique d'ing√©nierie inverse AM82TV</a></li>
<li><a href="../fr464659/index.html">S√©curit√© des applications ou Comment int√©grer la s√©curit√© dans le d√©veloppement personnalis√©. Exp√©rience personnelle chez AGIMA</a></li>
<li><a href="../fr464661/index.html">A qui confier la conception des √©quipements techniques de r√©√©quipement et de reconstruction</a></li>
<li><a href="../fr464665/index.html">Partitionnement dans SQL Server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>