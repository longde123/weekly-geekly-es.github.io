<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¹ ğŸ™ğŸ¿ ğŸš¢ Merkle Tree: berkarat dan cepat ğŸ”Œ ğŸ§šğŸ¼ ğŸ¤šğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Baru-baru ini menemukan bahasa Rust. Dia berbagi kesan pertamanya di artikel sebelumnya . Sekarang saya memutuskan untuk menggali lebih...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Merkle Tree: berkarat dan cepat</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455260/"><p><img src="https://habrastorage.org/webt/02/we/l8/02wel89vk_uuxibqbvaiimofkkk.png" alt="gambar"></p><br><p>  Halo semuanya!  Baru-baru ini menemukan bahasa Rust.  Dia berbagi kesan pertamanya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya</a> .  Sekarang saya memutuskan untuk menggali lebih dalam, untuk ini Anda perlu sesuatu yang lebih serius daripada daftar.  Pilihan saya jatuh pada pohon Merkle.  Dalam artikel ini saya ingin: </p><br><ul><li>  bicarakan struktur data ini </li><li>  lihat apa yang sudah dimiliki Rust </li><li>  menawarkan implementasi Anda </li><li>  bandingkan kinerja </li></ul><a name="habracut"></a><br><h1 id="derevo-merkla">  Merkle Tree </h1><br><p>  Ini adalah struktur data yang relatif sederhana, dan sudah ada banyak informasi tentang hal itu di Internet, tetapi saya pikir artikel saya tidak akan lengkap tanpa uraian pohon. </p><br><h2 id="v-chyom-problema">  Apa masalahnya? </h2><br><p>  Pohon Merkle ditemukan kembali pada tahun 1979, tetapi mendapatkan popularitasnya berkat blockchain.  Rantai blok dalam jaringan sangat besar (untuk bitcoin lebih dari 200 GB), dan tidak semua node dapat memompanya.  Misalnya, telepon atau mesin kasir.  Namun demikian, mereka perlu tahu tentang fakta termasuk ini atau itu transaksi di blok.  Untuk ini, protokol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SPV - Verifikasi Pembayaran Sederhana</a> telah ditemukan. </p><br><h2 id="kak-ustroeno-derevo">  Cara kerja pohon </h2><br><p>  Ini adalah pohon biner yang daunnya hash dari benda apa pun.  Untuk membangun tingkat berikutnya, hash daun tetangga diambil berpasangan, digabungkan dan hash dari hasil penggabungan dihitung, yang diilustrasikan dalam gambar di header.  Dengan demikian, akar pohon adalah hash dari semua daun.  Jika Anda menghapus atau menambahkan elemen, root akan berubah. </p><br><h2 id="kak-rabotaet-derevo">  Bagaimana cara kerja pohon? </h2><br><p>  Memiliki pohon Merkle, Anda dapat membangun bukti dari penyertaan transaksi dalam blok sebagai jalur dari hash transaksi ke root.  Sebagai contoh, kami tertarik pada transaksi Tx2, untuk itu buktinya adalah (Hash3, Hash01).  Mekanisme ini juga digunakan dalam SPV.  Klien hanya mengunduh header blok dengan hash-nya.  Memiliki transaksi yang menarik, ia meminta bukti dari simpul yang berisi seluruh rantai.  Kemudian ia melakukan pemeriksaan, untuk Tx2 akan menjadi: </p><br><pre><code class="plaintext hljs">hash(Hash01, hash(Hash2, Hash3)) = Root Hash</code> </pre> <br><p>  Hasilnya dibandingkan dengan root header blok.  Pendekatan ini membuat tidak mungkin untuk memalsukan bukti, karena dalam hal ini hasil tes tidak menyatu dengan isi tajuk. </p><br><h1 id="kakie-uzhe-est-realizacii">  Implementasi mana yang sudah ada </h1><br><p>  Karat adalah bahasa yang muda, tetapi banyak realisasi pohon Merkle sudah ditulis di atasnya.  Dilihat oleh Github, saat ini 56, ini lebih dari gabungan C dan C ++.  Meskipun Go membuatnya berdiri dengan 80 implementasi. </p><br><h2 id="spinresearchmerklershttpsgithubcomspinresearchmerklers">  <a href="">SpinResearch / merkle.rs</a> </h2><br><p>  Sebagai perbandingan, saya memilih implementasi ini dengan jumlah bintang di repositori. </p><br><p>  Pohon ini dibangun dengan cara yang paling jelas, yaitu grafik benda.  Seperti yang sudah saya catat, pendekatan ini tidak sepenuhnya ramah terhadap karat.  Misalnya, komunikasi dua arah dari anak ke orang tua tidak mungkin dilakukan. </p><br><p>  Konstruksi bukti terjadi melalui pencarian mendalam.  Jika lembar dengan hash yang tepat ditemukan, maka jalan menuju itu akan menjadi hasilnya. </p><br><h2 id="chto-mozhno-uluchshit">  Apa yang bisa diperbaiki </h2><br><p>  Itu tidak menarik bagi saya untuk membuat implementasi sederhana (n +1), jadi saya berpikir tentang optimasi.  Kode untuk <em>vektor-merkle-tree saya</em> ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Github</a> . </p><br><h3 id="hranenie-dannyh">  Penyimpanan data </h3><br><p>  Hal pertama yang terlintas dalam pikiran adalah untuk memindahkan pohon ke array.  Solusi ini akan jauh lebih baik dalam hal lokalitas data: lebih banyak hit cache dan preload yang lebih baik.  Berjalan di sekitar objek yang tersebar dari memori membutuhkan waktu lebih lama.  Fakta yang mudah adalah bahwa semua hash memiliki panjang yang sama, karena  dihitung dengan satu algoritma.  Pohon Merkle dalam array akan terlihat seperti ini: <br><img src="https://habrastorage.org/webt/7_/in/4_/7_in4_ijawhhqj4f9pldunhl2mu.png" alt="gambar"></p><br><h3 id="dokazatelstvo">  Bukti </h3><br><p>  Saat Anda menginisialisasi pohon, Anda dapat membuat HashMap dengan semua indeks daun.  Jadi, ketika tidak ada daun, tidak perlu mengelilingi seluruh pohon, dan jika ada, maka Anda dapat langsung pergi ke sana dan naik ke akar, membangun bukti.  Dalam implementasi saya, saya membuat HashMap opsional. </p><br><h3 id="konkatenaciya-i-heshirovanie">  Rangkaian dan Hashing </h3><br><p>  Tampaknya di sini dapat ditingkatkan?  Bagaimanapun, semuanya jelas - ambil dua hash, rekatkan dan hitung hash baru.  Tetapi kenyataannya adalah bahwa fungsi ini non-komutatif, yaitu  hash (H0, H1) â‰  hash (H1, H0).  Karena itu, ketika membuat bukti, Anda perlu mengingat sisi mana simpul tetangga berada.  Ini membuat algoritma lebih sulit untuk diimplementasikan, dan menambahkan kebutuhan untuk menyimpan data yang berlebihan.  Semuanya sangat mudah diperbaiki, cukup urutkan dua node sebelum hashing.  Sebagai contoh, saya mengutip Tx2, dengan mempertimbangkan commutativity, cek akan terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">hash(hash(Hash2, Hash3), Hash01) = Root Hash</code> </pre> <br><p>  Saat Anda tidak perlu khawatir tentang pesanan, algoritme verifikasi terlihat seperti konvolusi array yang sederhana: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, proof: &amp;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;&amp;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]&gt;) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { proof[<span class="hljs-number"><span class="hljs-number">2</span></span>..].iter() .fold( get_pair_hash(proof[<span class="hljs-number"><span class="hljs-number">0</span></span>], proof[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.algo), |a, b| get_pair_hash(a.as_ref(), b, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.algo) ).as_ref() == <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.get_root() }</code> </pre> <br><p>  Elemen nol adalah hash dari objek yang diinginkan, yang pertama adalah tetangganya. </p><br><h1 id="pognali">  Ayo pergi! </h1><br><p>  Cerita itu tidak akan lengkap tanpa perbandingan kinerja, yang membuat saya beberapa kali lebih lama daripada implementasi pohon itu sendiri.  Untuk tujuan ini, saya menggunakan kerangka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kriteria</a> .  Sumber tes itu sendiri ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Semua pengujian dilakukan melalui antarmuka <em>TreeWrapper</em> , yang diterapkan untuk kedua subjek: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TreeWrapper</span></span></span></span>&lt;V&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, c: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Criterion, counts: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;, data: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;V&gt;&gt;, title: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, c: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Criterion, counts: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;, data: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;V&gt;&gt;, title: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, c: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Criterion, counts: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;, data: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;V&gt;&gt;, title: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>); }</code> </pre> <br><p>  Kedua pohon bekerja dengan kriptografi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>cincin yang</em></a> sama.  Di sini saya tidak akan membandingkan perpustakaan yang berbeda.  Saya mengambil yang paling umum. </p><br><p>  Sebagai objek hash, string yang dihasilkan secara acak digunakan.  Pohon dibandingkan pada susunan berbagai panjang: (500, 1000, 1500, 2000, 2500 3000).  2500 - 3000 adalah perkiraan jumlah transaksi di blok bitcoin saat ini. </p><br><p>  Pada semua grafik, sumbu X menunjukkan jumlah elemen array (atau jumlah transaksi dalam blok), dan sumbu Y mewakili waktu rata-rata untuk menyelesaikan operasi dalam mikrodetik.  Artinya, semakin buruk. </p><br><h2 id="sozdanie-dereva">  Pembuatan pohon </h2><br><p>  Penyimpanan semua data pohon dalam satu array sangat melebihi grafik kinerja objek.  Untuk array dengan 500 elemen, 1,5 kali, dan untuk 3000 elemen sudah 3,6 kali.  Sifat nonlinear dari ketergantungan kompleksitas pada volume input data dalam implementasi standar terlihat jelas. </p><br><p>  Juga, sebagai perbandingan, saya menambahkan dua opsi untuk pohon vektor: dengan dan tanpa <em>HashMap</em> .  Mengisi struktur data tambahan menambahkan sekitar 20%, tetapi memungkinkan Anda untuk mencari objek lebih cepat ketika membangun bukti. <br><img src="https://habrastorage.org/webt/xk/nf/kj/xknfkjl5aqy8oqagfzaj05p1qo4.png" alt="gambar"></p><br><h2 id="postroenie-dokazatelstva">  Membangun bukti </h2><br><p>  Di sini Anda dapat melihat inefisiensi nyata dari pencarian secara mendalam.  Dengan peningkatan input, itu hanya bertambah buruk.  Penting untuk dipahami bahwa objek yang Anda cari adalah lembaran, sehingga tidak ada kerumitan <em>log (n)</em> .  Jika data pra-hash, maka waktu operasi praktis tidak tergantung pada jumlah elemen.  Tanpa hashing, kompleksitas tumbuh secara linear dan terdiri dari pencarian brute force. <br><img src="https://habrastorage.org/webt/py/lc/20/pylc206tjr1oraib8eynbeeatym.png" alt="gambar"></p><br><h2 id="validaciya-dokazatelstva">  Validasi bukti </h2><br><p>  Ini adalah operasi terakhir.  Itu tidak tergantung pada struktur pohon, karena  bekerja dengan hasil membangun bukti.  Saya percaya bahwa kesulitan utama di sini adalah perhitungan hash. <br><img src="https://habrastorage.org/webt/2h/n6/hk/2hn6hkfzrbhxnejuihg2xx2hpoc.png" alt="gambar"></p><br><h1 id="itog">  Ringkasan </h1><br><ul><li>  Cara data disimpan sangat memengaruhi kinerja.  Ketika semuanya dalam satu array jauh lebih cepat.  Dan serialisasi struktur seperti itu akan sangat sederhana.  Jumlah total kode juga dikurangi. </li><li>  Menyatukan node dengan penyortiran sangat menyederhanakan kode, tetapi tidak membuatnya lebih cepat. </li></ul><br><h1 id="nemnogo-o-rust">  Sedikit tentang Rust </h1><br><ul><li>  Menyukai kerangka <em>kriteria</em> .  Ini menghasilkan hasil yang jelas dengan nilai rata-rata dan penyimpangan yang dilengkapi dengan grafik.  Mampu membandingkan implementasi berbeda dari kode yang sama. </li><li>  Kurangnya warisan tidak terlalu mengganggu kehidupan. </li><li>  Macro adalah mekanisme yang kuat.  Saya menggunakannya dalam <a href="">tes pohon saya</a> untuk parameterisasi.  Saya pikir jika mereka digunakan dengan buruk, Anda dapat melakukan hal seperti itu sehingga Anda sendiri tidak akan bahagia nanti. </li><li>  Di beberapa tempat, kompiler bosan dengan pemeriksaan memorinya.  Asumsi awal saya bahwa mulai menulis di Rust jadi tidak berhasil ternyata benar. <br><img src="https://habrastorage.org/webt/1n/uw/mf/1nuwmfwfozbeosqyvhtmbybur7w.png" alt="gambar"></li></ul><br><h1 id="ssylki">  Referensi </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Deskripsi yang lebih lengkap tentang algoritma pohon Merkle</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kriteria - kerangka pengujian beban</a> </li><li>  <a href="">merkle.rs - pohon paling populer di bawah Rust</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">vector-merkle-tree - implementasi pohon saya</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">merkle-tree-test-rs - proyek untuk membandingkan kinerja dua perpustakaan</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455260/">https://habr.com/ru/post/id455260/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455244/index.html">Komik "Soldering is Easy" dalam versi yang diperbarui (2019)</a></li>
<li><a href="../id455248/index.html">Kesalahan pengembangan teratas saat bekerja dengan PostgreSQL</a></li>
<li><a href="../id455250/index.html">Orang yang membangkitkan Duke Nukem: wawancara dengan Randy Pitchford, pesulap dari Gearbox</a></li>
<li><a href="../id455256/index.html">Habr Weekly # 4 / Computex, bagaimana kita beta Apple, Durov kelaparan, kucing BadComedian, mengapa jaringan saraf mencari aktor porno</a></li>
<li><a href="../id455258/index.html">Voting untuk laporan bagian Backend pada peringatan DevConfX dimulai, yang akan diselenggarakan pada 21-22 Juni di Moskow</a></li>
<li><a href="../id455264/index.html">Jadilah seperti Munch, atau beberapa kata tentang tugas teknis</a></li>
<li><a href="../id455268/index.html">Bagaimana semuanya dimulai: tampilan fleksibel dan lipat - kisah penampilan dan jalan keluar "orang"</a></li>
<li><a href="../id455272/index.html">TheOutloud - Suara dan bagikan artikel dan cerita favorit Anda.</a></li>
<li><a href="../id455274/index.html">Microsoft meluncurkan inisiatif pendidikan skala besar di universitas-universitas Rusia</a></li>
<li><a href="../id455276/index.html">Game cloud: Layanan Google Stadia mengumumkan harga untuk pengguna</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>