<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ•  â™‘ï¸ ğŸ½ Berurusan dengan Pencegat dalam Bereaksi ğŸ‘©â€ğŸ‘¦ ğŸ¥œ ğŸ‘©ğŸ¼â€ğŸ¤â€ğŸ‘©ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 

 Dengan rasa bangga dan lega yang luar biasa, kami menyerahkan sebuah buku baru tentang Bereaksi ke percetakan malam ini. 



 Pada kese...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Berurusan dengan Pencegat dalam Bereaksi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/428632/">  Halo, Habr! <br><br>  Dengan rasa bangga dan lega yang luar biasa, kami menyerahkan sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buku baru tentang Bereaksi</a> ke percetakan malam ini. <br><br><img src="https://habrastorage.org/webt/yy/eu/am/yyeuamoit3imb91e5gligyk4oys.jpeg"><br><br>  Pada kesempatan ini, kami menawarkan kepada Anda terjemahan artikel yang sedikit diringkas oleh Dan Abramov, yang menjelaskan penggunaan pencegat dalam React versi 16.  Buku, yang kita sendiri nantikan, dijelaskan dalam Bab 5. <br><a name="habracut"></a><br>  Pekan lalu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sophie Alpert dan saya</a> memperkenalkan konsep "pencegat" di konferensi React Conf, diikuti dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diskusi</a> rinci <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tentang topik</a> dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ryan Florence</a> . <br><br>  Saya sangat menyarankan Anda menonton kuliah pleno ini untuk membiasakan diri dengan berbagai masalah yang kami coba selesaikan dengan bantuan pencegat.  Namun, bahkan waktu Anda sangat saya hargai, jadi saya memutuskan untuk menguraikan secara singkat dalam artikel ini pertimbangan utama untuk pencegat. <br><blockquote>  Catatan: React interceptors masih bersifat percobaan.  Tidak perlu menyelidiki mereka sekarang.  Perhatikan juga bahwa publikasi ini menetapkan pandangan pribadi saya, yang mungkin tidak sesuai dengan posisi pengembang Bereaksi. </blockquote>  <b>Mengapa pencegat diperlukan?</b> <br><br>  Diketahui bahwa komponen organisasi dan aliran data ke bawah membantu mengatur UI besar dalam bentuk fragmen kecil, independen dan dapat digunakan kembali.  <b>Namun, seringkali tidak mungkin untuk memecah komponen kompleks di luar batas tertentu, karena logika mempertahankan keadaan dan tidak dapat diekstraksi ke dalam fungsi atau komponen lain</b> .  Kadang-kadang mereka yang mengatakan bahwa Bereaksi gagal mencapai "pemisahan tugas" mengeluh tentang ini. <br>  Kasus-kasus seperti itu sangat umum, dan terkait, misalnya, dengan animasi, pemrosesan formulir, menghubungkan ke sumber data eksternal, dan banyak operasi lain yang mungkin perlu kami lakukan dengan komponen kami.  Mencoba memecahkan masalah seperti itu dengan komponen saja, kita biasanya mendapatkan: <br><br><ul><li>  <b>Komponen raksasa</b> yang sulit untuk direstorasi dan diuji. </li><li> <b>Duplikasi logika</b> antara berbagai komponen dan metode siklus hidup. </li><li>  <b>Pola kompleks</b> , khususnya, render alat peraga dan komponen tingkat tinggi. </li></ul><br>  Kami percaya bahwa pencegat adalah yang paling menjanjikan untuk menyelesaikan semua masalah ini.  <b>Interceptor membantu mengatur logika di dalam komponen dalam bentuk unit terisolasi yang dapat digunakan kembali</b> : <br><br><img src="https://habrastorage.org/webt/4g/xr/jw/4gxrjwrsbsq2o6nqjrcjvq8lifo.jpeg"><br><br><img src="https://habrastorage.org/webt/cs/sx/ac/cssxacn4rnmwuob4lhtqflnnyxw.jpeg"><br><br>  <b>Pencegat sejalan dengan filosofi Bereaksi (aliran dan komposisi data eksplisit) dan dalam suatu komponen, bukan hanya antar komponen</b> .  Itulah mengapa menurut saya pencegat secara alami cocok dengan model komponen Bereaksi. <br><br>  Tidak seperti pola seperti rendering properti atau komponen tingkat tinggi, sniffer tidak membebani pohon komponen Anda dengan lampiran yang tidak perlu dalam.  Juga, mereka tidak memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelemahan</a> yang melekat pada kotoran. <br><br>  Bahkan jika pada pandangan pertama pencegat membelokkan Anda (sama seperti saya pada awalnya!) Saya sarankan memberikan opsi ini kesempatan dan bereksperimen dengannya.  Saya pikir Anda akan menyukainya. <br><br>  <b>Apakah Bereaksi bengkak karena pencegat?</b> <br><br>  Sampai kami membahas pencegat secara detail, Anda mungkin khawatir bahwa menambahkan pencegat di Bereaksi hanyalah penggandaan entitas.  Ini adalah kritik yang adil.  Saya pikir ini: walaupun, dalam jangka pendek, Anda benar-benar merasakan beban kognitif ekstra (untuk mempelajarinya), pada akhirnya Anda hanya akan merasa lebih baik. <br><br>  <b>Jika pencegat berakar di komunitas Bereaksi, maka sebenarnya jumlah entitas yang harus dikelola saat menulis aplikasi Bereaksi <i>akan berkurang</i></b> .  Menggunakan interseptor, Anda dapat terus menggunakan fungsi, daripada beralih di antara fungsi, kelas, komponen tingkat tinggi, dan rendering komponen. <br><br>  Adapun peningkatan ukuran implementasi, aplikasi Bereaksi dengan dukungan pencegat meningkat hanya sekitar ~ 1.5kB (min + gzip).  Meskipun ini sendiri tidak terlalu banyak, sangat mungkin bahwa <b>ketika menggunakan pencegat, ukuran rakitan Anda bahkan akan berkurang</b> , karena kode pencegat biasanya diperkecil lebih baik daripada kode setara menggunakan kelas.  Contoh berikut ini sedikit ekstrem, tetapi jelas menunjukkan mengapa semuanya demikian ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://twitter.com/jamiebuilds/status/1056015484364087297/photo/1%3Fref_src%3Dtwsrc%255Etfw%257Ctwcamp%255Etweetembed%257Ctwterm%255E1056015484364087297%26ref_url%3D">klik</a> untuk membuka seluruh utas): <br><br><img src="https://habrastorage.org/webt/_z/zp/7k/_zzp7ky6u-3dcsitdyla1mt-ive.jpeg"><br><br>  <b>Tidak ada perubahan revolusioner untuk proposal pencegat</b> .  Kode Anda akan berfungsi dengan baik bahkan jika Anda mulai menggunakan interceptor di komponen baru.  Sebenarnya, inilah yang kami sarankan: jangan menulis ulang apa pun secara global!  Akan lebih bijaksana untuk menunggu sampai penggunaan pencegat ditetapkan dalam semua kode penting.  Namun demikian, kami akan berterima kasih jika Anda dapat bereksperimen dengan alpha versi 16.7 dan meninggalkan kami umpan balik pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proposal untuk pencegat</a> , serta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://github.com/login%3Freturn_to%3D">melaporkan bug</a> . <br><br>  <b>Apa itu - pencegat?</b> <br><br>  Untuk memahami apa itu pencegat, Anda harus mundur satu langkah dan berpikir tentang apa yang digunakan kembali kode. <br><br>  Ada banyak cara untuk menggunakan kembali logika dalam Bereaksi aplikasi saat ini.  Jadi, untuk menghitung sesuatu, Anda dapat menulis fungsi sederhana, lalu memanggilnya.  Anda juga dapat menulis komponen (yang dapat berupa fungsi atau kelas).  Komponen lebih kuat, tetapi ketika bekerja dengan mereka, Anda perlu menampilkan beberapa UI.  Oleh karena itu, menggunakan komponen tidak nyaman untuk mengirimkan logika non-visual.  Jadi kita sampai pada pola kompleks seperti properti rendering dan komponen tingkat tinggi.  <b>Tidak Bereaksi akan membuatnya lebih mudah jika hanya ada satu cara umum untuk menggunakan kembali kode di dalamnya, dan tidak begitu banyak?</b> <br><br>  Fungsi tampaknya sempurna untuk kode yang dapat digunakan kembali.  Melewati logika antar fungsi adalah yang paling murah.  Namun, kondisi lokal Bereaksi tidak dapat disimpan di dalam fungsi.  Anda tidak dapat mengekstrak perilaku seperti "melacak ukuran jendela dan memperbarui keadaan" atau "menghidupkan nilai untuk beberapa waktu" dari komponen kelas tanpa merestrukturisasi kode atau tanpa memperkenalkan abstraksi seperti Observable.  Kedua pendekatan hanya mempersulit kode, dan Bereaksi baik untuk kita dengan kesederhanaannya. <br><br>  Pencegat memecahkan masalah ini.  Berkat pencegat, Anda dapat menggunakan fitur Bereaksi (misalnya, menyatakan) dari suatu fungsi - dengan memanggilnya hanya sekali.  Bereaksi menyediakan beberapa pencegat built-in yang sesuai dengan batu bata Bereaksi: keadaan, siklus hidup, dan konteks. <br><br>  <b>Karena pencegat adalah fungsi JavaScript biasa, Anda dapat menggabungkan pencegat internal yang disediakan di Bereaksi untuk membuat "pencegat asli"</b> .  Dengan demikian, masalah kompleks dapat diselesaikan dengan satu baris kode, dan kemudian melipatgandakannya dalam aplikasi Anda, atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://twitter.com/seldo/status/1057030727512911874%3Fref_src%3Dtwsrc%255Etfw%257Ctwcamp%255Etweetembed%257Ctwterm%255E1057030727512911874%26ref_url%3D">membaginya dalam komunitas Bereaksi</a> <br><br>  Perhatian: secara tegas, pencegat Anda sendiri tidak termasuk dalam fitur React.  Kemampuan untuk menulis interceptor Anda sendiri secara alami berasal dari organisasi internal mereka. <br><br>  <b>Tunjukkan kodenya!</b> <br><br>  Misalkan kita ingin berlangganan komponen dengan lebar jendela saat ini (misalnya, untuk menampilkan konten lain atau area tampilan yang lebih sempit). <br>  Kode serupa dapat ditulis hari ini dalam beberapa cara.  Misalnya, untuk membuat kelas, buat beberapa metode siklus hidup, atau mungkin bahkan menggunakan rendering properti atau menerapkan komponen tingkat tinggi jika Anda mencari penggunaan kembali.  Namun, saya kira tidak ada yang sebanding dengan ini: <br><br><img src="https://habrastorage.org/webt/it/yg/sm/itygsmtcllercyaret5qvglik7u.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gist.github.com/gaearon/cb5add26336003ed8c0004c4ba820eae</a> <br><br>  <b>Jika Anda membaca kode ini, itu berarti ia melakukan apa yang dikatakannya</b> .  Kami menggunakan lebar jendela di dalam komponen kami, dan Bereaksi redraw komponen Anda jika itu berubah.  Inilah yang diperlukan untuk pencegat - untuk membuat komponen benar-benar deklaratif, bahkan jika mereka mengandung efek samping dan negara. <br><br>  Pertimbangkan bagaimana pencegat ini sendiri dapat diimplementasikan.  Kita bisa menggunakan status Bereaksi lokal untuk menjaga lebar jendela saat ini di dalamnya, dan mengatur status ketika jendela diubah ukurannya menggunakan efek samping: <br><br><img src="https://habrastorage.org/webt/9t/wf/rx/9twfrxgngukwpy1geu5m8hvcqjk.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gist.github.com/gaearon/cb5add26336003ed8c0004c4ba820eae</a> <br><br>  Seperti yang ditunjukkan di atas, pencegat <code>useState</code> seperti <code>useState</code> dan <code>useEffect</code> berfungsi sebagai batu bata.  Kita dapat menggunakannya langsung dari komponen kita, atau mengumpulkan pencegat kita sendiri dari mereka, misalnya, menggunakan <code>useWindowWidth</code> .  Menggunakan pencegat Anda sendiri tampaknya tidak kurang idiomatis daripada bekerja dengan React API bawaan. <br><br>  Baca lebih lanjut tentang pencegat bawaan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ulasan ini</a> . <br><br>  <b>Interceptors dienkapsulasi - setiap kali interceptor dipanggil, ia menerima keadaan lokal yang terisolasi di dalam komponen yang sedang dijalankan</b> .  Dalam contoh khusus ini, ini tidak penting (lebar jendela sama untuk semua komponen!), Tapi inilah tepatnya kekuatan pencegat!  Mereka dimaksudkan untuk memisahkan bukan negara, tetapi logika pelestarian negara.  <b>Kami tidak ingin memutus aliran data hilir!</b> <br><br>  Setiap interceptor mungkin mengandung beberapa keadaan lokal dan efek samping.  Anda dapat mentransfer data antara banyak pencegat, seperti yang biasanya dilakukan antar fungsi.  Mereka dapat mengambil argumen dan mengembalikan nilai karena itu adalah fungsi JavaScript. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berikut adalah contoh</a> perpustakaan animasi Bereaksi tempat kami bereksperimen dengan interseptor: <br>  Perhatikan bagaimana animasi yang menakjubkan diimplementasikan dalam kode sumber yang ditunjukkan: kami memberikan nilai antara beberapa pencegat asli dalam fungsi rendering yang sama. <br><br><img src="https://habrastorage.org/webt/uc/h_/fs/uch_fszu4xmd8xnegfqvwz-flzc.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">codesandbox.io/s/ppxnl191zx</a> <br><br>  (Contoh ini dibahas lebih rinci dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">panduan ini</a> .) <br><br>  Karena kemampuan untuk mentransfer data antara pencegat, mereka sangat nyaman untuk menerapkan animasi, berlangganan data, mengelola formulir, dan bekerja dengan abstraksi stateful lainnya.  <b>Tidak seperti merender properti atau komponen tingkat tinggi, pencegat tidak membuat "hierarki palsu" di pohon render Anda</b> .  Mereka lebih seperti daftar dua dimensi "sel memori" yang melekat pada suatu komponen.  Tidak ada level tambahan. <br><br>  <b>Bagaimana dengan kelas?</b> <br><br>  Menurut pendapat kami, pencegat kami sendiri adalah detail paling menarik dalam seluruh penawaran.  Tetapi agar pencegatnya sendiri berfungsi, React harus memberikan kemampuan fungsi untuk menyatakan keadaan dan efek samping pada tingkat fungsi.  Inilah yang memungkinkan kami melakukan pencegat <code>useState</code> seperti <code>useState</code> dan <code>useEffect</code> .  Baca lebih lanjut tentang ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> . <br><br>  Ternyata pencegat bawaan seperti itu nyaman tidak hanya saat membuat pencegat Anda sendiri.  Mereka juga cukup untuk menentukan komponen secara keseluruhan, karena mereka memberi kita kemampuan yang diperlukan - misalnya, keadaan.  Itu sebabnya kami ingin pencegat menjadi sarana utama untuk mendefinisikan komponen Bereaksi di masa depan. <br>  Tidak, kami tidak berencana menghapus kelas secara bertahap.  Kami menggunakan puluhan ribu komponen kelas di Facebook dan kami (sama seperti Anda) sama sekali tidak ingin menulis ulang.  Tetapi, jika komunitas Bereaksi mulai menggunakan pencegat, itu akan menjadi tidak pantas untuk melestarikan dua cara yang direkomendasikan untuk menulis komponen.  Pencegat mencakup semua kasus praktis di mana kelas digunakan, tetapi memberikan fleksibilitas yang lebih besar ketika mengekstraksi, menguji, dan menggunakan kembali kode.  Itu sebabnya kami menghubungkan pencegat dengan ide kami tentang masa depan Bereaksi. <br><br>  <b>Bagaimana jika pencegat itu sihir?</b> <br><br>  Mungkin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aturan pencegat</a> akan membingungkan Anda. <br><br>  <b>Meskipun tidak lazim untuk memanggil pencegat di tingkat atas, Anda mungkin tidak ingin menentukan kondisi dalam kondisi itu sendiri, bahkan jika Anda bisa</b> .  Sebagai contoh, kondisi terikat kondisi tidak dapat ditentukan di kelas, dan selama empat tahun berkomunikasi dengan pengguna Bereaksi, saya belum mendengar keluhan tentang hal ini. <br><br>  Desain seperti ini sangat penting untuk memperkenalkan pencegat Anda sendiri tanpa memperkenalkan kebisingan sintaksis yang berlebihan atau membuat jebakan.  Kami memahami bahwa karena kebiasaan itu sulit, tetapi kami percaya bahwa kompromi ini dapat diterima, mengingat peluang yang ditawarkannya.  Jika Anda tidak setuju, saya sarankan Anda mencoba sendiri dan coba bagaimana Anda menyukai pendekatan ini. <br><br>  Kami telah menggunakan kait produksi selama sebulan sekarang untuk melihat apakah aturan baru akan membingungkan programmer.  Praktek menunjukkan bahwa seseorang menguasai pencegat dalam hitungan jam.  Saya mengakui bahwa bagi saya aturan-aturan ini pada pandangan pertama tampak seperti bid'ah, tetapi perasaan ini cepat berlalu.  Itulah kesan yang saya miliki ketika pertama kali bertemu React.  (Anda tidak suka Bereaksi? Dan saya hanya menyukainya untuk kedua kalinya.) <br><br>  Harap dicatat: pada tingkat implementasi pencegat juga tidak ada keajaiban.  Menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jamie</a> , dia mendapatkan sesuatu seperti ini: <br><br><img src="https://habrastorage.org/webt/cf/xl/zt/cfxlztqheooupmcgmecqjp1kk2g.jpeg"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gist.github.com/gaearon/62866046e396f4de9b4827eae861ff19</a> <br><br>  Kami mempertahankan daftar pencegat yang meledak, dan beralih ke komponen berikutnya dalam daftar setiap kali Anda menggunakan pencegat.  Berkat aturan pencegat, urutannya sama di mesin render apa pun, sehingga dengan setiap panggilan kami dapat menyediakan komponen dengan keadaan yang benar. <br><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dalam artikel dari Rudy Yardley ini,</a> semuanya dijelaskan dengan indah dalam gambar!) <br><br>  Mungkin Anda bertanya-tanya di mana React menyimpan status pencegat.  Di tempat yang sama dengan keadaan kelas.  Bereaksi memiliki antrian pembaruan internal yang berisi kebenaran tertinggi untuk setiap negara, terlepas dari bagaimana Anda mendefinisikan komponen Anda. <br><br>  Interceptor tidak tergantung pada proxy dan getter, yang sangat umum di perpustakaan JavaScript modern.  Oleh karena itu, dapat dikatakan bahwa ada sedikit sihir dalam pencegat daripada dalam pendekatan populer lainnya untuk memecahkan masalah tersebut.  Tidak lebih dari dalam <code>array.push</code> dan <code>array.pop</code> (dalam hal urutan urutan panggilan juga penting!) <br><br>  Desain pencegat tidak terikat dengan Bereaksi.  Bahkan, beberapa hari setelah publikasi proposal, berbagai orang menunjukkan kepada kami implementasi eksperimental dari API pencegat yang sama untuk Vue, komponen web, dan bahkan fungsi JavaScript biasa. <br>  Akhirnya, jika Anda secara fanatik mengabdikan diri untuk pemrograman fungsional, dan Anda merasa tidak nyaman ketika Bereaksi mulai mengandalkan keadaan yang bisa berubah sebagai bagian dari implementasi.  Tapi, itu mungkin menghibur Anda bahwa pemrosesan interseptor dapat diimplementasikan dalam bentuknya yang murni, membatasi dirinya pada efek aljabar (jika didukung dalam JavaScript).  Tentu saja, pada level intra-sistem, Bereaksi selalu mengandalkan keadaan yang bisa berubah - dan itulah yang ingin Anda hindari. <br><br>  Terlepas dari sudut pandang mana yang lebih dekat dengan Anda - pragmatis atau dogmatis - saya berharap bahwa setidaknya salah satu dari opsi ini tampaknya masuk akal bagi Anda.  Yang paling penting, menurut saya, pencegat menyederhanakan pekerjaan kami, dan menjadi lebih nyaman bagi pengguna untuk bekerja.  Itulah yang mencegat saya seperti itu. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428632/">https://habr.com/ru/post/id428632/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428616/index.html">Konversikan file XLS ke Google Spreadsheet menggunakan Google Apps Script</a></li>
<li><a href="../id428624/index.html">Jeffrey Richter, Pavel Yosifovich, Greg Young dan semuanya. Hardcore dan arsitektur di DotNext 2018 Moscow</a></li>
<li><a href="../id428626/index.html">Cara membuat ekstensi di PHP7 lebih sulit daripada "halo, dunia", dan tidak menjadi mata merah. Bagian 1</a></li>
<li><a href="../id428628/index.html">Bekerja dengan pohon sintaksis JavaScript abstrak</a></li>
<li><a href="../id428630/index.html">Tidak, Bitcoin tidak akan menghancurkan iklim kita pada tahun 2033.</a></li>
<li><a href="../id428634/index.html">Porting Quake3</a></li>
<li><a href="../id428636/index.html">Roskomnadzor akan memulihkan denda dari Google</a></li>
<li><a href="../id428638/index.html">Hearts Flame Motor: QardioCore Heart Monitor Review</a></li>
<li><a href="../id428640/index.html">Dengan handset di saku Anda: Peralatan Snom DECT untuk jaringan telepon nirkabel</a></li>
<li><a href="../id428644/index.html">Brainfuck tingkat rendah</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>