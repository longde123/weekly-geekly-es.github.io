<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛅 👨‍👨‍👧‍👧 🤳🏽 在Swift上编写Snapchat UI 👃🏻 🤱🏼 👨🏿‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="序言 


在我的一个项目中，我需要创建一个类似于Snepchat的界面。 当带有信息的卡留在相机图像的顶部时，请以纯色平稳地替换它，并且方向也要相反。 我个人特别着迷于从摄像头窗口到侧卡的过渡，我非常高兴地叙述了解决此问题的方法。 


 左侧是Snepchat的示例，右侧是我们将创建的应用程序的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在Swift上编写Snapchat UI</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415795/"><h2 id="prolog"> 序言 </h2><br><p>在我的一个项目中，我需要创建一个类似于Snepchat的界面。 当带有信息的卡留在相机图像的顶部时，请以纯色平稳地替换它，并且方向也要相反。 我个人特别着迷于从摄像头窗口到侧卡的过渡，我非常高兴地叙述了解决此问题的方法。 </p><br><p> 左侧是Snepchat的示例，右侧是我们将创建的应用程序的示例。 </p><br><p><img src="https://habrastorage.org/webt/es/cx/sd/escxsdlqbwqu7rfh9l9lcjjcl0a.gif"><img src="https://habrastorage.org/webt/vg/xf/8v/vgxf8vdl1gwnu0vplvu9gikqaho.gif"></p><a name="habracut"></a><br><p>可能想到的第一个解决方案是调整<code>UIScrollView</code> ，以某种方式在其上排列视图，使用分页，但是坦率地说，滚动被认为可以解决完全不同的问题，在其上拾取其他动画非常耗时，并且没有必要的灵活性设置。 因此，用它来解决这个问题是绝对不合理的。 </p><br><p> 摄像机窗口和侧边选项卡之间的滚动具有欺骗性-根本不是滚动，它是属于不同控制器的视图之间的交互式过渡。 下部的按钮是普通的选项卡，单击它们会将我们扔到控制器之间。 </p><br><p><img src="https://habrastorage.org/webt/s1/xq/o7/s1xqo7xcojshfu3lqvdjiyonluk.jpeg"></p><br><p> 通过这种方式，Snatch将其自己的导航控制器版本（例如<code>UITabBarController</code>与自定义交互式转换一起使用。 </p><br><p>  <code>UIKit</code>包括两个用于导航控制器的选项，它们允许您自定义过渡<code>UINavigationController</code>和<code>UITabBarController</code> 。 他们两个都在各自的委托中分别具有<code>navigationController(_:interactionControllerFor:)</code>和<code>tabBarController(_:interactionControllerFor:)</code>方法，这使我们能够使用自己的交互式动画进行过渡。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">tabBarController（_：interactionControllerFor ：）</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">navigationController（_：interactionControllerFor :)</a> </p><br><p> 但是我不想受到<code>UITabBarController</code>或<code>UINavigationController</code>的实现的限制，特别是因为我们无法控制它们的内部逻辑。 因此，我决定编写类似的控制器，现在我想告诉和展示它的来龙去脉。 </p><br><h2 id="postanovka-zadachi"> 问题陈述 </h2><br><p> 创建自己的容器控制器，您可以使用<code>UITabBarController</code>和<code>UINavigationController</code>的标准机制，使用交互式动画在子控制器之间进行切换，以进行过渡。 我们需要这种标准机制来使用已经编写的<code>UIViewControllerAnimatedTransitioning</code>类型的现成过渡动画。 </p><br><h2 id="podgotovka-proekta"> 项目准备 </h2><br><p> 通常，我尝试将模块移到单独的框架中，为此，我创建了一个新的应用程序项目，并在其中添加了一个额外的<code>Cocoa Touch Framework</code>目标，然后将项目中的源分散到相应的目标。 这样，我获得了带有测试应用程序的单独框架以进行调试。 </p><br><p> 创建一个<code>Single View App</code> 。 </p><br><p><img src="https://habrastorage.org/webt/6p/eb/pa/6pebpaksin3ixvmlpse9tj7rnzs.png"></p><br><p>  <code>Product Name</code>将是我们的目标。 </p><br><p><img src="https://habrastorage.org/webt/aq/qv/fg/aqqvfgoimy4kv85lqjrb34tbkco.png"></p><br><p> 单击<code>+</code>添加目标。 </p><br><p><img src="https://habrastorage.org/webt/_b/2v/vj/_b2vvjuxpzkbvcmxuo8wxsctza0.png"></p><br><p> 选择<code>Cocoa Touch Framework</code> 。 </p><br><p><img src="https://habrastorage.org/webt/kr/mg/yy/krmgyylj_xfil50cdtejstjdpuc.png"></p><br><p> 我们将框架称为适当的名称，Xcode会自动为目标选择项目，并提供将二进制文件直接绑定到应用程序中的功能。 我们同意。 </p><br><p><img src="https://habrastorage.org/webt/no/xi/cn/noxicnp_oslkyxhn3qkmcaukpom.png"></p><br><p> 我们不需要默认的<code>Main.storyboard</code>和<code>ViewController.swift</code> ，我们将其删除。 </p><br><p><img src="https://habrastorage.org/webt/_m/zq/aw/_mzqawkdo2pi9zgulfqlwnhs2vo.png"></p><br><p> 另外，不要忘记从“ <code>General</code>选项卡上应用程序目标中的<code>Main Interface</code>中删除该值。 </p><br><p><img src="https://habrastorage.org/webt/kt/sv/3v/ktsv3vjy_1vqgwdnkh288h4ecpc.png"></p><br><p> 现在，我们转到<code>AppDelegate.swift</code>并仅保留以下内容的<code>application</code>方法： </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">application</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">]?)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Launch our master view controller let master = MasterViewController() window = UIWindow() window?.rootViewController = master window?.makeKeyAndVisible() return true }</span></span></code> </pre> <br><p> 在这里，我们将控制器设置在主要位置，以便它出现在启动器之后。 </p><br><p> 现在创建这个<code>MasterViewController</code> 。 它与应用程序有关，因此在创建文件时选择正确的目标很重要。 </p><br><p><img src="https://habrastorage.org/webt/7m/0y/r8/7m0yr8cefaenhznoqbjisg7sy1q.png"></p><br><p> 我们将从<code>SnapchatNavigationController</code>继承<code>MasterViewController</code> ，稍后将在框架中实现。 不要忘记指定我们框架的<code>import</code> 。 我没有在此处提供完整的控制器代码，省略号由省略号表示<code>...</code> ，我将应用程序放置在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub上</a> ，您可以在其中看到所有详细信息。 在此控制器中，我们只对<code>viewDidLoad()</code>方法感兴趣，该方法使用相机+一个透明控制器（主窗口）+包含离场卡的控制器来初始化背景控制器。 </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">MakingSnapchatNavigation</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MasterViewController</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">SnapchatNavigationController</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> func viewDidLoad() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() <span class="hljs-comment"><span class="hljs-comment">//   let camera = CameraViewController() setBackground(vc: camera) //     var vcs: [UIViewController] = [] //    var stub = UIViewController() stub.view.backgroundColor = .clear vcs.append(stub) //  ,     stub = UIViewController() stub.view.backgroundColor = .clear //   let scroll = UIScrollView() stub.view.addSubview(scroll) //  ... //  ,      let content = GradientView() //  ... //    scroll.addSubview(content) vcs.append(stub) //     - setViewControllers(vcs: vcs) } }</span></span></code> </pre> <br><p> 这是怎么回事 我们使用相机创建一个控制器，并使用<code>SnapchatNavigationController</code>的<code>setBackground</code>方法将其设置为背景。 该控制器包含一个从摄像机整个视图延伸的图像。 然后，我们创建一个空的透明控制器并将其添加到数组中，它只是将相机中的图像传递给它，我们可以在其上放置控件，创建另一个透明控制器，向其中添加滚动，在滚动中添加包含内容的视图，向其中添加第二个控制器数组并使用父<code>SnapchatNavigationController</code>的特殊<code>setViewControllers</code>方法设置此数组。 </p><br><p> 不要忘记在<code>Info.plist</code>添加使用相机的请求 </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>NSCameraUsageDescription<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span>Need camera for background<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 在此基础上，我们认为测试应用程序已准备就绪，然后转到最有趣的部分-框架的实现。 </p><br><h2 id="struktura-roditelskogo-kontrollera"> 父控制器结构 </h2><br><p> 首先，创建一个空的<code>SnapchatNavigationController</code> ，为它选择正确的目标很重要。 如果一切都正确完成，则应构建应用程序。 该项目的状态可以通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">引用</a>卸载。 </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> SnapchatNavigationController: UIViewController { override <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> func viewDidLoad() { super.viewDidLoad() // <span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> additional setup <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> loading the <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>. } // MARK: - <span class="hljs-built_in"><span class="hljs-built_in">Public</span></span> interface /// Sets <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> controllers. <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> func setViewControllers(vcs: [UIViewController]) { } /// Sets background <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> func setBackground(vc: UIViewController) { } }</code> </pre> <br><p> 现在添加控制器将组成的内部组件。 我没有将所有代码都放在这里，我只关注重点。 </p><br><p> 我们设置变量以存储子控制器数组。 现在，我们严格设置其所需数量-2件。 将来，将有可能扩展控制器逻辑以用于任何数量的控制器。 我们还设置了一个变量来存储当前显示的控制器。 </p><br><pre> <code class="hljs pgsql">private let requiredChildrenAmount = <span class="hljs-number"><span class="hljs-number">2</span></span> // MARK: - <span class="hljs-keyword"><span class="hljs-keyword">View</span></span> controllers /// top child <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> controller private var topViewController: UIViewController? /// <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> children <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> controllers private var children: [UIViewController] = []</code> </pre> <br><p> 创建视图。 我们需要一个背景视图，一个需要在更改控制器时应用于背景的视图。 我们还有一个用于当前子控制器的视图容器和一个视图指示器，该指示器将告诉用户如何使用导航。 </p><br><pre> <code class="hljs bash">// MARK: - Views private <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> backgroundViewContainer = UIView() private <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> backgroundBlurEffectView: UIVisualEffectView = { <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> backgroundBlurEffect = UIBlurEffect(style: UIBlurEffectStyle.light) <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> backgroundBlurEffectView = UIVisualEffectView(effect: backgroundBlurEffect) backgroundBlurEffectView.alpha = 0 <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> backgroundBlurEffectView }() /// content view <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> children private <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> contentViewContainer = UIView() private <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> swipeIndicatorView = UIView()</code> </pre> <br><p> 在下一个块中，我们设置两个变量， <code>swipeAnimator</code>负责动画， <code>swipeInteractor</code>负责交互（控制动画进度的能力），我们必须在控制器启动过程中对其进行初始化，因此我们要强制展开。 </p><br><pre> <code class="hljs erlang">// MARK: - Animation <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> transition private <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> swipeAnimator = AnimatedTransitioning() private var swipeInteractor: CustomSwipeInteractor!</code> </pre> <br><p> 我们还为指标设置了转换。 我们将指示器移动容器的宽度+从边缘移动两倍+指示器本身的宽度，以使指示器位于容器的另一端。 容器的宽度在应用过程中将是已知的，因此该变量可随时进行计算。 </p><br><pre> <code class="hljs pgsql">// MARK: - Animation transforms private var swipeIndicatorViewTransform: CGAffineTransform { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CGAffineTransform(translationX: -contentViewContainer.bounds.size.width + (swipeIndicatorViewXShift * <span class="hljs-number"><span class="hljs-number">2</span></span>) + swipeIndicatorViewWidth, y: <span class="hljs-number"><span class="hljs-number">0</span></span>) } }</code> </pre> <br><p> 加载控制器时，我们将<code>self</code>分配给动画（我们将在下面实现相应的协议），并根据动画初始化交互器，并控制动画的进度。 我们还任命他为代表。 代表将响应用户手势的开始，并根据控制器的状态开始动画或取消动画。 然后，我们将所有视图添加到主视图中，并调用<code>setupViews()</code>来设置约束。 </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() swipeAnimator.animation = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> swipeInteractor = <span class="hljs-type"><span class="hljs-type">CustomSwipeInteractor</span></span>(with: swipeAnimator) swipeInteractor.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> view.addSubview(backgroundViewContainer) view.addSubview(backgroundBlurEffectView) view.addSubview(contentViewContainer) view.addSubview(swipeIndicatorView) setupViews() }</code> </pre> <br><p> 接下来，我们继续介绍在容器中安装和删除子控制器的逻辑。 这里的一切都很简单，就像Apple文档中的一样。 我们使用针对此类操作规定的方法。 </p><br><p>  <code>addChildViewController(vc)</code> -在当前控制器上添加一个子控制器。 </p><br><p>  <code>contentViewContainer.addSubview(vc.view)</code> -将控制器视图添加到视图层次结构。 </p><br><p>  <code>vc.view.frame = contentViewContainer.bounds</code>将视图拉伸到整个容器。 由于我们在这里使用框架而不是自动布局，因此每次控制器大小更改时我们都需要更改其大小，因此我们将省略此逻辑，并假设容器在应用程序运行时不会更改应用程序的大小。 </p><br><p>  <code>vc.didMove(toParentViewController: self)</code> -终止添加子控制器的操作。 </p><br><p>  <code>swipeInteractor.wireTo</code>我们将当前控制器绑定到用户手势。 稍后我们将分析这种方法。 </p><br><pre> <code class="hljs pgsql">// MARK: - Private methods private func addChild(vc: UIViewController) { addChildViewController(vc) contentViewContainer.addSubview(vc.<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>) vc.<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.frame = contentViewContainer.bounds vc.didMove(toParentViewController: self) topViewController = vc let goingRight = children.<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">of</span></span>: topViewController!) == <span class="hljs-number"><span class="hljs-number">0</span></span> swipeInteractor.wireTo(viewController: topViewController!, edge: goingRight ? .right : .left) } private func removeChild(vc: UIViewController) { vc.willMove(toParentViewController: nil) vc.<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.removeFromSuperview() vc.removeFromParentViewController() topViewController = nil }</code> </pre> <br><p> 还有另外两种方法，我在这里不再赘述： <code>setViewControllers</code>和<code>setBackground</code> 。 在<code>setViewControllers</code>方法中<code>setViewControllers</code>我们只需在控制器的相应变量中设置子控制器的数组，然后调用<code>addChild</code>即可在视图中显示其中的一个。 在<code>setBackground</code>方法中<code>setBackground</code>我们仅对后台控制器执行与<code>addChild</code>相同的操作。 </p><br><h2 id="logika-animacii-kontrollera-konteynera"> 容器控制器动画逻辑 </h2><br><p> 总计，我们的父控制器的基础是： </p><br><ul><li>  UIView分为两种类型 <br><ul><li> 货柜 </li><li> 普通的 </li></ul></li><li> 子UIViewController的列表 </li><li>  <code>swipeAnimator</code>类型的<code>AnimatedTransitioning</code>动画控制对象 </li><li> 一个对象，用于控制类型<code>CustomSwipeInteractor</code>的<code>swipeInteractor</code>动画的交互过程 </li><li> 委托互动动画 </li><li> 动画协议实现 </li></ul><br><p> 现在，我们将分析最后两点，然后继续执行<code>AnimatedTransitioning</code>和<code>CustomSwipeInteractor</code> 。 </p><br><h3 id="delegat-interaktivnogo-hoda-animacii"> 委托互动动画 </h3><br><p> 委托仅由一个<code>panGestureDidStart(rightToLeftSwipe: Bool) -&gt; Bool</code>方法组成，该方法通知控制器手势的开始及其方向。 作为响应，他等待有关动画是否可以视为开始的信息。 </p><br><p> 作为代表，我们检查控制器的当前顺序，以了解是否可以按给定的方向启动动画，如果一切正常，则使用以下参数启动<code>transition</code>方法：参数：我们要从中移动的控制器，我们要移动的控制器，移动的方向，交互性标志（如果为<code>false</code> ，则会触发一个固定时间的过渡动​​画）。 </p><br><pre> <code class="hljs julia">func panGestureDidStart(rightToLeftSwipe: <span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span> { guard <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> topViewController = topViewController, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fromIndex = children.index(of: topViewController) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newIndex = rightToLeftSwipe ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span> //   -    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> newIndex &gt; -<span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; newIndex &lt; children.count &amp;&amp; newIndex != fromIndex { transition(from: children[fromIndex], to: children[newIndex], goingRight: rightToLeftSwipe, interactive: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br><p> 让我们立即检查<code>transition</code>方法的主体。 首先，我们为<code>CustomControllerContext</code>动画创建动画上下文。 稍后我们还将分析此类；该类实现了<code>UIViewControllerContextTransitioning</code>协议。 对于<code>UINavigationController</code>和<code>UITabBarController</code>此协议的实现实例由系统自动创建，并且其逻辑对我们隐藏，我们需要创建自己的逻辑。 </p><br><pre> <code class="hljs pgsql">let ctx = CustomControllerContext(fromViewController: <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, toViewController: <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, containerView: contentViewContainer, goingRight: goingRight) ctx.isAnimated = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ctx.isInteractive = interactive ctx.completionBlock = { (didComplete: <span class="hljs-type"><span class="hljs-type">Bool</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> didComplete { self.removeChild(vc: <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) self.addChild(vc: <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) } };</code> </pre> <br><p> 然后我们简单地称为固定或交互式动画。 将来，可以在控制器之间的导航按钮选项卡上挂一个固定的按钮，在此示例中，我们将不这样做。 </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> interactive { // Animate <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> interaction swipeInteractor.startInteractiveTransition(ctx) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // Animate <span class="hljs-keyword"><span class="hljs-keyword">without</span></span> interaction swipeAnimator.animateTransition(<span class="hljs-keyword"><span class="hljs-keyword">using</span></span>: ctx) }</code> </pre> <br><h3 id="protokol-animacii"> 动画协议 </h3><br><p>  <code>TransitionAnimation</code>动画协议包含4种方法： </p><br><p>  <code>addTo</code>是一种用于在容器中创建正确的子视图结构的方法，根据动画的想法，前一个视图与新视图重叠。 </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/// Setup the views hirearchy for animation. func addTo(containerView: UIView, fromView: UIView, toView: UIView, fromLeft: Bool)</span></span></code> </pre> <br><p>  <code>prepare</code>是在动画之前准备视图的方法。 </p><br><pre> <code class="hljs sql">/// Setup the views position prior to the animation start. func <span class="hljs-keyword"><span class="hljs-keyword">prepare</span></span>(fromView <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>: UIView?, toView <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>: UIView?, fromLeft: <span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span>)</code> </pre> <br><p>  <code>animation</code>动画本身。 </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/// The animation. func animation(fromView from: UIView?, toView to: UIView?, fromLeft: Bool)</span></span></code> </pre> <br><p>  <code>finalize</code> -动画完成后的必要操作。 </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/// Cleanup the views position after the animation ended. func finalize(completed: Bool, fromView from: UIView?, toView to: UIView?, fromLeft: Bool)</span></span></code> </pre> <br><p> 我们将不考虑所使用的实现，那里的一切都非常透明，我们将直接进入三个主要类，这要归功于动画的发生。 </p><br><h2 id="class-customcontrollercontext-nsobject-uiviewcontrollercontexttransitioning"> <code>class CustomControllerContext: NSObject, UIViewControllerContextTransitioning</code> </h2> <br><p> 动画的上下文。 为了描述其功能，我们参考<code>UIViewControllerContextTransitioning</code>协议的帮助： </p><br><blockquote> 上下文对象封装有关转换中涉及的视图和视图控制器的信息。 它还包含有关如何执行过渡的详细信息。 </blockquote><p> 最有趣的是禁止修改此协议： </p><br><blockquote> 不要在自己的类中采用此协议，也不要直接创建采用此协议的对象。 </blockquote><p> 但是我们确实需要它来运行标准动画引擎，因此无论如何我们都会对其进行调整。 它几乎没有逻辑；它仅存储状态。 因此，我什至不会把它带到这里。 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub上</a>观看它。 </p><br><p> 它适用于固定时间的动画。 但是，当将其用于交互式动画时，会出现一个问题<code>UIPercentDrivenInteractiveTransition</code>会在上下文中调用未记录的方法。 在这种情况下，唯一正确的解决方案是改编另一种协议<code>UIViewControllerInteractiveTransitioning</code>以使用您自己的上下文。 </p><br><h2 id="class-percentdriveninteractivetransition-nsobject-uiviewcontrollerinteractivetransitioning"> <code>class PercentDrivenInteractiveTransition: NSObject, UIViewControllerInteractiveTransitioning</code> </h2> <br><p> 这是项目的核心-允许交互式动画存在于自定义容器控制器中。 让我们按顺序进行。 </p><br><p> 该类使用<code>UIViewControllerAnimatedTransitioning</code>类型的一个参数初始化，这是用于动画化控制器之间过渡的标准协议。 这样，我们可以使用已经与类一起编写的任何动画。 </p><br><pre> <code class="hljs objectivec">init(with animator: <span class="hljs-built_in"><span class="hljs-built_in">UIViewControllerAnimatedTransitioning</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.animator = animator }</code> </pre> <br><p> 公共接口非常简单，有四种方法，其功能应该很明显。 </p><br><p> 只需注意动画开始的那一刻，我们就可以获取容器的父视图并将图层速度设置为0，这样我们就可以手动控制动画的进度。 </p><br><pre> <code class="hljs pgsql">// MARK: - <span class="hljs-built_in"><span class="hljs-built_in">Public</span></span> func startInteractiveTransition(_ transitionContext: UIViewControllerContextTransitioning) { self.transitionContext = transitionContext transitionContext.containerView.superview?.layer.speed = <span class="hljs-number"><span class="hljs-number">0</span></span> animator.animateTransition(<span class="hljs-keyword"><span class="hljs-keyword">using</span></span>: transitionContext) } func updateInteractiveTransition(percentComplete: CGFloat) { setPercentComplete(percentComplete: (CGFloat(fmaxf(fminf(<span class="hljs-type"><span class="hljs-type">Float</span></span>(percentComplete), <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>)))) } func cancelInteractiveTransition() { transitionContext?.cancelInteractiveTransition() completeTransition() } func finishInteractiveTransition() { transitionContext?.finishInteractiveTransition() completeTransition() }</code> </pre> <br><p> 现在我们来看我们班级的私有逻辑模块。 </p><br><p>  <code>setPercentComplete</code>设置<code>setPercentComplete</code>视图层的动画进度的时间偏移量，并根据动画的完成百分比和持续时间来计算该值。 </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPercentComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(percentComplete: CGFloat)</span></span></span></span> { setTimeOffset(timeOffset: <span class="hljs-type"><span class="hljs-type">TimeInterval</span></span>(percentComplete) * duration) transitionContext?.updateInteractiveTransition(percentComplete) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setTimeOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeOffset: TimeInterval)</span></span></span></span> { transitionContext?.containerView.superview?.layer.timeOffset = timeOffset }</code> </pre> <br><p> 当用户停止手势时会调用<code>completeTransition</code> 。 在这里，我们创建了<code>CADisplayLink</code>类的实例，该实例将使我们能够从用户不再控制其进度的那一刻起自动漂亮地自动完成动画。 我们将<code>displayLink</code>添加到<code>run loop</code>以便系统在需要在设备屏幕上显示新帧时调用选择器。 </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">completeTransition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { displayLink = <span class="hljs-type"><span class="hljs-type">CADisplayLink</span></span>(target: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, selector: #selector(tickAnimation)) displayLink!.add(to: .main, forMode: .commonModes) }</code> </pre> <br><p> 在选择器中，我们计算并设置动画进度的临时位移，就像我们在用户手势操作之前所做的那样，或者在动画到达其起点或终点时完成动画。 </p><br><pre> <code class="hljs coffeescript">@objc private func tickAnimation() { var timeOffset = self.timeOffset() let tick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(displayLink?.duration ?? </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> * TimeInterval</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(completionSpeed)</span></span></span><span class="hljs-function"> timeOffset += </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(transitionContext?.transitionWasCancelled ?? </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> ? -tick : tick; if </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeOffset &lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> || timeOffset &gt; duration)</span></span></span><span class="hljs-function"> { transitionFinished</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> } else { setTimeOffset</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeOffset: timeOffset)</span></span></span><span class="hljs-function"> } } private func timeOffset</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> TimeInterval { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> transitionContext?.containerView.superview?.layer.timeOffset ?? <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><p> 完成动画后，我们关闭<code>displayLink</code> ，返回图层的速度，如果尚未取消动画（即动画已到达其最后一帧），我们将计算图层动画应开始的时间。 您可以在《核心动画编程指南》中或在stackoverflow的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此答案中</a>了解有关此内容的更多信息。 </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transitionFinished</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { displayLink?.invalidate() <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> layer = transitionContext?.containerView.superview?.layer <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } layer.speed = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wasNotCanceled = !(transitionContext?.transitionWasCancelled ?? <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wasNotCanceled) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pausedTime = layer.timeOffset layer.timeOffset = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timeSincePause = layer.convertTime(<span class="hljs-type"><span class="hljs-type">CACurrentMediaTime</span></span>(), from: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) - pausedTime layer.beginTime = timeSincePause } animator.animationEnded?(wasNotCanceled) }</code> </pre> <br><h2 id="class-animatedtransitioning-nsobject-uiviewcontrolleranimatedtransitioning"> <code>class AnimatedTransitioning: NSObject, UIViewControllerAnimatedTransitioning</code> </h2> <br><p> 我们尚未检查的最后一个类是<code>UIViewControllerAnimatedTransitioning</code>协议的实现，其中我们控制动画<code>addTo</code> ， <code>prepare</code> ， <code>animation</code>和<code>finalize</code>的协议方法的执行顺序。 这里的一切都是平淡无奇的，值得注意的是，仅使用<code>UIViewPropertyAnimator</code>来执行动画，而不是使用更典型的<code>UIView.animate(withDuration:animations:)</code> 。 这样做是为了可以进一步控制动画的进度，如果取消了动画，则可以通过调用<code>finishAnimation(at: .start)</code>将其返回到其<code>finishAnimation(at: .start)</code>位置，从而避免了动画的最后一帧在屏幕上不必要的闪烁。 </p><br><h2 id="epilog"> 结语 </h2><br><p> 我们创建了一个类似于Snapchat的界面的工作演示。 在我的版本中，我配置了常量，以便在卡的左右两边都有字段。此外，我将相机放在背景视图上以在卡的后面创建效果。 这样做只是为了演示这种方法的功能，它如何影响设备的性能，而我没有检查其电池电量。 </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本文是我第一次尝试撰写技术文献类型的文章，我可能会漏掉一些要点，因此很高兴在评论中回答问题。</font><font style="vertical-align: inherit;">感谢所有阅读我的文章的人，希望您在这里找到了对自己有用的东西。</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以从GitHub的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链接</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载完成的项目</font><font style="vertical-align: inherit;">。</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 再次感谢，大家度过了愉快的一天，有趣的任务，高效的编码！ </font></font></p><br><p><img src="https://habrastorage.org/webt/mh/se/2z/mhse2z7hfck6aicbobu-vwyi9bw.gif"></p><br><h2 id="istochniki-informacii"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 信息来源 </font></font></h2><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 为了编写该程序，我使用了以下信息： </font></font></p><br><ol><li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Joachim Bondo撰写的“定制容器视图控制器转换”一文。 </font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 本文的作者提出了目标C中自定义上下文的一种变体。我用它的变体在Swift中编写类。 </font></font></p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">友情链接</font></font></a> </p><br></li><li><p>  Interactive Custom Container View Controller Transitions,  Alek Åström </p><br><p>               ,   Objective C,           Swift. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> </p><br></li><li><p> <code>SwipeableTabBarController</code> </p> <br><p> ,            <code>UITabBarController</code> .      . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> </p><br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN415795/">https://habr.com/ru/post/zh-CN415795/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN415783/index.html">星盘向我们揭示了行星外观的秘密</a></li>
<li><a href="../zh-CN415785/index.html">SpaceX将人工智能机器人发送给ISS</a></li>
<li><a href="../zh-CN415789/index.html">计算机程序的专利算法</a></li>
<li><a href="../zh-CN415791/index.html">优化智能合约。 实体类型如何影响交易成本</a></li>
<li><a href="../zh-CN415793/index.html">完整的域名补货指南</a></li>
<li><a href="../zh-CN415797/index.html">正则表达式+逻辑编程。 结果如何？</a></li>
<li><a href="../zh-CN415801/index.html">谷歌：我们的“电话”人工智能还不够危险</a></li>
<li><a href="../zh-CN415805/index.html">修改用于互联网控制的Doorhan GSM屏障模块</a></li>
<li><a href="../zh-CN415809/index.html">如何在Atlassian Jira的插件中使用Soy，Requiresjs，Bones js</a></li>
<li><a href="../zh-CN415811/index.html">AI，实践课程。 用于图像分类的神经网络概述</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>