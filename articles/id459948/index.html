<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📅 🆙 👍🏻 Menerapkan awan volumetrik yang benar secara fisik seperti di Horizon Zero Dawn 🧛 👏 🧑🏿‍🤝‍🧑🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sebelumnya, cloud dalam gim digambar dengan sprite 2D biasa, yang selalu diputar ke arah kamera, tetapi dalam beberapa tahun terakhir, model kartu vid...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menerapkan awan volumetrik yang benar secara fisik seperti di Horizon Zero Dawn</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459948/">  Sebelumnya, cloud dalam gim digambar dengan sprite 2D biasa, yang selalu diputar ke arah kamera, tetapi dalam beberapa tahun terakhir, model kartu video baru memungkinkan Anda untuk menggambar awan yang benar secara fisik tanpa kehilangan kinerja yang nyata.  Diyakini bahwa awan tebal dalam game membawa studio Game Gerilya bersama dengan game Horizon Zero Dawn.  Tentu saja, awan-awan seperti itu dapat dirender sebelumnya, tetapi studio membentuk sesuatu seperti standar industri untuk sumber daya sumber dan algoritma yang digunakan, dan sekarang setiap implementasi awan volumetrik entah bagaimana sesuai dengan standar ini. <br><br><img src="https://habrastorage.org/webt/v9/uq/em/v9uqemwtz5ty7x5uvpppsoonmdu.png"><br><a name="habracut"></a><br>  Seluruh proses rendering cloud dibagi dengan sangat baik menjadi beberapa tahap dan penting untuk dicatat bahwa implementasi yang tidak akurat bahkan pada salah satu dari mereka dapat menyebabkan konsekuensi sedemikian rupa sehingga tidak akan jelas di mana kesalahan itu dan bagaimana cara memperbaikinya, oleh karena itu disarankan untuk membuat kesimpulan kontrol dari hasil setiap kali. <br><br><h2>  Pemetaan nada, sRGB </h2><br>  Sebelum mulai bekerja dengan pencahayaan, penting untuk melakukan dua hal: <br><br><ol><li>  Sebelum menampilkan gambar akhir di layar, terapkan setidaknya pemetaan nada paling sederhana: <br><br><pre><code class="cpp hljs">tunedColor=color/(<span class="hljs-number"><span class="hljs-number">1</span></span>+color)</code> </pre> <br>  Ini diperlukan karena nilai warna yang dihitung akan jauh lebih besar daripada satu. <br></li><li>  Pastikan bahwa framebuffer terakhir yang Anda gambar dan tampilkan di layar dalam format sRGB.  Jika aktivasi mode sRGB adalah masalah, konversi dapat dilakukan secara manual di shader: <br><br><pre> <code class="cpp hljs">finalColor=<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(color, vec3(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">2.2</span></span>))</code> </pre> <br>  Formula ini cocok untuk kebanyakan kasus, tetapi tidak 100% tergantung pada monitor.  Penting bahwa konversi sRGB selalu dilakukan terakhir. </li></ol><br><h2>  Model pencahayaan </h2><br>  Pertimbangkan ruang yang diisi dengan materi transparan sebagian dengan kepadatan berbeda.  Ketika sinar cahaya melewati zat semacam itu, ia terkena empat efek: penyerapan, hamburan, hamburan memperkuat dan radiasi diri.  Yang terakhir terjadi dalam kasus proses kimia dalam suatu zat, dan tidak terpengaruh di sini. <br><br>  Misalkan kita memiliki sinar cahaya yang melewati materi dari titik A ke titik B: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_1/1t/9w/_11t9wizftnmwilerlsi5fvcrm4.png"></div><br>  <b>Penyerapan</b> <br><br>  Cahaya yang melewati suatu zat mengalami penyerapan oleh zat ini.  Fraksi cahaya yang tidak diserap dapat ditemukan dengan rumus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/567/34c/ec6/56734cec6154e1fab8bb2d1538a8dffa.svg"></div><br>  dimana <img src="https://habrastorage.org/getpro/habr/post_images/a3e/204/11f/a3e20411f145906908c5cd2b53a36dbe.svg">  - cahaya yang tersisa di titik setelah penyerapan <img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg">  . <img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg">  - arahkan pada segmen AB di kejauhan <img src="https://habrastorage.org/getpro/habr/post_images/2a3/102/4ea/2a31024ea1803c34a47496e24a53a1ef.svg">  dari A. <br><br>  <b>Hamburan</b> <br><br>  Bagian dari cahaya di bawah pengaruh partikel-partikel materi mengubah arahnya.  Fraksi cahaya yang tidak berubah arahnya dapat ditemukan dengan rumus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04b/c17/2f5/04bc172f53fa572aebf0399275b5009f.svg"></div><br>  dimana <img src="https://habrastorage.org/getpro/habr/post_images/5e3/0b7/bad/5e30b7badd64b9da62be750e48573c7d.svg">  - pecahan cahaya yang tidak berubah arah setelah hamburan pada suatu titik <img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg">  . <br><br>  Penyerapan dan dispersi harus digabungkan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d7/d5a/f1a/8d7d5af1a0506ee776c4c2f850e862a9.svg"></div><br>  Fungsi <img src="https://habrastorage.org/getpro/habr/post_images/33f/297/4e9/33f2974e9c84331f8b92d8b7ed5aca97.svg">  disebut pelemahan atau kepunahan.  Suatu fungsi <img src="https://habrastorage.org/getpro/habr/post_images/eea/d4d/0d4/eead4d0d4f08873f9aa49b69a7c46fd8.svg">  - fungsi transfer.  Ini menunjukkan berapa banyak cahaya yang tersisa ketika melewati dari titik A ke titik B. <br><br>  Salam <img src="https://habrastorage.org/getpro/habr/post_images/610/ddb/ee8/610ddbee8d80f847b44fa75c9a136489.svg">  dan <img src="https://habrastorage.org/getpro/habr/post_images/cd1/8c2/405/cd18c240521dcfb71084a340a504e41f.svg">  : <img src="https://habrastorage.org/getpro/habr/post_images/b76/ea9/fd5/b76ea9fd577eb1c2cee545caa4153bd3.svg">  , di mana C adalah konstanta tertentu, yang mungkin memiliki nilai berbeda untuk setiap saluran dalam RGB, <img src="https://habrastorage.org/getpro/habr/post_images/9ee/494/9d2/9ee4949d2897f56ac90e563db1eb96cd.svg">  Adalah kepadatan medium pada titik tersebut <img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg">  . <br><br>  Sekarang mari kita rumit tugasnya.  Cahaya bergerak dari titik A ke titik B, padam saat gerakan.  Pada titik X, bagian dari cahaya tersebar di arah yang berbeda, salah satu arah sesuai dengan pengamat di titik O. Selanjutnya, sebagian dari cahaya yang tersebar bergerak dari titik X ke titik O dan meredam lagi.  Jalur cahaya AXO menarik bagi kami. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zo/b_/tr/zob_troftvd8-ggp1ga7wesnrlk.png"></div><br>  Hilangnya cahaya saat pindah dari A ke X kita tahu: <img src="https://habrastorage.org/getpro/habr/post_images/25d/8c9/f76/25d8c9f76986f59eb045b801f19d4e0a.svg">  , seperti yang kita ketahui hilangnya cahaya dari X ke O - ini <img src="https://habrastorage.org/getpro/habr/post_images/25b/3a9/8e3/25b3a98e370f0a95b734794b74bee57a.svg">  .  Tetapi bagaimana dengan sebagian kecil cahaya yang akan tersebar ke arah pengamat? <br><br>  <b>Dispersi amplifikasi</b> <br><br>  Jika dalam kasus hamburan biasa, intensitas cahaya berkurang, maka dalam kasus hamburan penguatan, itu meningkat karena hamburan cahaya yang telah terjadi di daerah tetangga.  Jumlah total cahaya yang berasal dari daerah tetangga dapat ditemukan dengan rumus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e4/be1/bd9/7e4be1bd9a1d8f05b9d1d47e1bb27ecc.svg"></div><br>  dimana <img src="https://habrastorage.org/getpro/habr/post_images/e63/878/1e4/e638781e456c920d7864e85c8b14a746.svg">  berarti mengambil integral dari bola, <img src="https://habrastorage.org/getpro/habr/post_images/1ad/0bb/23e/1ad0bb23eb22871d78d2b5cc67d58292.svg">  - fungsi fase <img src="https://habrastorage.org/getpro/habr/post_images/da9/7bc/3c5/da97bc3c51ddad728182deecd39ba0d0.svg">  - Cahaya datang dari arah <img src="https://habrastorage.org/getpro/habr/post_images/9c6/a44/e8e/9c6a44e8ed4cb10046e00346c6b58b15.svg">  . <br><br>  Sangat sulit untuk menghitung cahaya dari semua arah, namun, kita tahu bahwa bagian asli cahaya dibawa oleh balok AB asli kita.  Formula dapat sangat disederhanakan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef8/4aa/222/ef84aa22259c648ea9925502712250f6.svg"></div><br>  dimana <img src="https://habrastorage.org/getpro/habr/post_images/2cb/bcb/347/2cbbcb347a44c276c1095ac5bb3f8242.svg">  - sudut antara berkas cahaya dan berkas pengamat (mis., sudut AXO), <img src="https://habrastorage.org/getpro/habr/post_images/309/1ee/38b/3091ee38b2de66a8aa89af86fe87eb65.svg">  - nilai awal dari intensitas cahaya.  Meringkas semua hal di atas, kami memperoleh rumus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/642/fb7/273/642fb727356c245fc6f053dbc9affde8.svg"></div><br>  dimana <img src="https://habrastorage.org/getpro/habr/post_images/309/1ee/38b/3091ee38b2de66a8aa89af86fe87eb65.svg">  - cahaya yang masuk <img src="https://habrastorage.org/getpro/habr/post_images/f7a/fbd/138/f7afbd138efabfc5bf5dad3e26e6c0fb.svg">  - cahaya mencapai pengamat. <br><br>  Kami sedikit merumitkan tugas.  Katakanlah cahaya dipancarkan oleh cahaya directional, mis.  matahari: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wz/r2/gg/wzr2ggl_1oshhmhn3kkqalhtkoo.png"></div><br>  Semuanya terjadi sama seperti pada kasus sebelumnya, tetapi berkali-kali.  Cahaya dari titik A1 tersebar di titik X1 menuju pengamat di titik O, cahaya dari titik A2 tersebar di titik X2 ke arah pengamat di titik O, dll.  Kita melihat bahwa cahaya yang mencapai pengamat sama dengan jumlah: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/838/191/24f/83819124f0beb6bdd5adc3644a79653b.svg"></div><br>  Atau ungkapan integral yang lebih akurat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e01/7b0/5d2/e017b05d2026f311f43bc53da48c130e.svg"></div><br>  Penting untuk memahami hal itu di sini <img src="https://habrastorage.org/getpro/habr/post_images/e7b/3af/88e/e7b3af88eb6397d1f88774b011fe4cbb.svg">  , yaitu  segmen dibagi menjadi jumlah tak terbatas dari bagian dengan panjang nol. <br><br><h2>  Langit </h2><br>  Dengan sedikit penyederhanaan, sinar matahari yang melewati atmosfer hanya mengalami hamburan, yaitu <img src="https://habrastorage.org/getpro/habr/post_images/c79/ce0/055/c79ce005518e112e707da427d7231066.svg">  . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k0/mm/tz/k0mmtzjcir3wnqxbcjzsouln4yo.png"></div><br>  Dan bahkan tidak satu jenis hamburan, tetapi dua: hamburan Rayleigh dan hamburan Mi.  Yang pertama disebabkan oleh molekul udara, dan yang kedua disebabkan oleh aerosol air. <br><br>  Total kepadatan udara (atau aerosol) yang dilalui oleh sinar cahaya, bergerak dari titik A ke titik B: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0bc/d80/e5d/0bcd80e5d5b35e43fef8336e6c66cde0.svg"></div>  dimana <img src="https://habrastorage.org/getpro/habr/post_images/14b/01a/bf0/14b01abf043545d56ac10d61e69792e8.svg">  - tinggi scaling, h - tinggi saat ini. <br><br>  Solusi integral sederhana adalah: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d3f/b07/e75/d3fb07e750a91c2a253fdcf1de74de72.svg"></div><br>  di mana dh adalah ukuran langkah dengan mana sampel tinggi diambil. <br><br>  Sekarang lihat gambar dan gunakan rumus yang diperoleh di bagian sebelumnya dari "model pencahayaan": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gr/n0/fr/grn0fr0f-dly-jjpcjpg_pxof9a.png"></div><br>  Pengamat melihat dari O ke O '.  Kami ingin mengumpulkan semua cahaya yang mencapai titik X1, X2, ..., Xn, tersebar di dalamnya, dan kemudian mencapai pengamat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/540/c25/470/540c25470466173df2e5cf7880390ff9.svg"></div><br>  dimana <img src="https://habrastorage.org/getpro/habr/post_images/c87/cb3/ca4/c87cb3ca4e0a0f0fc9d1a9d5c485c116.svg">  intensitas cahaya yang dipancarkan oleh matahari, <img src="https://habrastorage.org/getpro/habr/post_images/6c3/b25/b5f/6c3b25b5f22b9a03c093ef2f25a06339.svg">  - tinggi pada titik <img src="https://habrastorage.org/getpro/habr/post_images/ee6/2f8/bed/ee62f8bed8d0d0e9b3d3cd2c81841ded.svg">  ;  dalam kasus langit, konstanta C, yang berfungsi <img src="https://habrastorage.org/getpro/habr/post_images/cd1/8c2/405/cd18c240521dcfb71084a340a504e41f.svg">  dilambangkan sebagai <img src="https://habrastorage.org/getpro/habr/post_images/cea/f36/742/ceaf36742def9a68dbd173a0ac9c9aeb.svg">  . <br><br>  Solusi integral dapat sebagai berikut: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5be/44a/9fc/5be44a9fcdb92469fee29b924a957556.svg"></div><br>  Formula ini berlaku untuk hamburan Rayleigh dan hamburan Mie.  Sebagai hasilnya, nilai-nilai cahaya untuk masing-masing sebaran cukup dijumlahkan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34f/cb4/a91/34fcb4a9100e4b9c60a7c7eca2c489ec.svg"></div><br>  <b>Rayleigh Dispersion</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/71e/a55/e80/71ea55e8043a70776eb70f29eb84d877.svg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/679/03f/8e9/67903f8e987346a525fb22e02e718aad.svg">  (berisi nilai untuk setiap saluran RGB) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c9/02f/384/4c902f3848ae3cb24347ee0b367132d6.svg"><br><br>  Hasil: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nk/xs/8z/nkxs8zt8hyh909tjilktrkrrvri.png"></div><br>  <b>Pencar saya</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/72b/94b/cc1/72b94bcc19f99b0e164c6a48e4408b44.svg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c9a/52e/00c/c9a52e00c5e6169a8ad778f902e49595.svg">  (nilai untuk semua saluran RGB adalah sama) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/208/fcf/3bf/208fcf3bf216540af2bfa93a186a3a19.svg"><br><br>  Hasil: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fu/jv/sb/fujvsbtduq-il-1reylizx1kosa.png"></div><br>  Jumlah sampel per segmen <img src="https://habrastorage.org/getpro/habr/post_images/2a1/abf/7c3/2a1abf7c35ec6c9a9d35514977d15981.svg">  dan di segmennya <img src="https://habrastorage.org/getpro/habr/post_images/392/559/f75/392559f75e1c271b8bbfbc6255e70d4d.svg">  Anda dapat mengambil 32 ke atas.  Radius bumi adalah 6371000 m, atmosfer adalah 100000 m. <br><br>  Apa yang harus dilakukan dengan semua ini: <br><br><ol><li>  Di setiap piksel layar, kami menghitung arah pengamat V </li><li>  Kami mengambil posisi pengamat O sama dengan {0, 6371000, 0} </li><li>  Kami menemukan <img src="https://habrastorage.org/getpro/habr/post_images/28d/cc9/fe7/28dcc9fe786e9216afc4ab3ae2196ebe.svg">  sebagai hasil dari persimpangan sinar yang berasal dari titik O, dan arah V dan bola berpusat di titik {0,0,0} dan jari-jari 6471000 </li><li>  Segmen garis <img src="https://habrastorage.org/getpro/habr/post_images/392/559/f75/392559f75e1c271b8bbfbc6255e70d4d.svg">  bagi menjadi 32 bagian dengan panjang yang sama </li><li>  Untuk setiap bagian, kami menghitung hamburan Rayleigh dan hamburan Mie, dan menambahkan semuanya.  Apalagi untuk menghitung <img src="https://habrastorage.org/getpro/habr/post_images/2a1/abf/7c3/2a1abf7c35ec6c9a9d35514977d15981.svg">  kita juga perlu membagi segmen <img src="https://habrastorage.org/getpro/habr/post_images/0e6/fb0/4e8/0e6fb04e8525f5a3448df984993ab3c4.svg">  32 plot sama dalam setiap kasus. <img src="https://habrastorage.org/getpro/habr/post_images/60e/970/a20/60e970a20b30f36e7c21fe71c3d4dadb.svg">  dapat dibaca melalui variabel, nilai yang meningkat pada setiap langkah dalam siklus. </li></ol><br>  Hasil akhir: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/no/gb/tl/nogbtlqbuzffixmq7xmt1w4j_ja.png"></div><br><h2>  Model cloud </h2><br>  Kami membutuhkan beberapa jenis noise dalam 3D.  Yang pertama adalah suara gerakan Brownian fraktal Perlin yang bersembunyi: <br><br>  Hasil untuk irisan 2D: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ld/h6/v6/ldh6v6zglre4jhon_n8qu193o8k.png"></div><br>  Yang kedua adalah bunyi fBm cloaking Voronoi. <br><br>  Hasil untuk irisan 2D: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/aa/rc/s2/aarcs2hvles3h89jqfc1lfrufjk.png"></div><br>  Untuk mendapatkan noise fBm cloaking Vorley, Anda perlu membalikkan fBm cloaking Voronoj.  Namun, saya sedikit mengubah rentang nilai menurut kebijaksanaan saya: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fbmTiledWorley3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> clamp((<span class="hljs-number"><span class="hljs-number">1.0</span></span>-fbmTiledVoronoi3(...))*<span class="hljs-number"><span class="hljs-number">1.5</span></span><span class="hljs-number"><span class="hljs-number">-0.25</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br>  Hasilnya segera menyerupai struktur cloud: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ha/pf/em/hapfemxrqrxuqfpckajp53j4zxc.png"></div><br>  Untuk cloud, Anda perlu mendapatkan dua tekstur khusus.  Yang pertama memiliki ukuran 128x128x128 dan bertanggung jawab untuk kebisingan frekuensi rendah, yang kedua memiliki ukuran 32x32x32 dan bertanggung jawab untuk kebisingan frekuensi tinggi.  Setiap tekstur hanya menggunakan satu saluran dalam format R8.  Dalam beberapa contoh, 4 saluran R8G8B8A8 digunakan untuk tekstur pertama dan tiga saluran R8G8B8 untuk yang kedua, dan kemudian saluran dicampur dalam shader.  Saya tidak mengerti intinya, karena pencampuran dapat dilakukan sebelumnya sehingga mendapatkan hit yang lebih besar dalam koherensi cache. <br><br>  Untuk pencampuran, dan juga di beberapa tempat, fungsi remap () akan digunakan, yang menskalakan nilai dari satu rentang ke yang lain: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> minValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newMinValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newMaxValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newMinValue+(value-minValue)/(maxValue-minValue)*(newMaxValue-newMinValue); }</code> </pre> <br>  Mari kita mulai menyiapkan tekstur dengan noise frekuensi rendah: <br>  R-channel - fBm noise perlin <br>  G-channel - ubin fBm Vorley noise <br>  B-channel - fBm noise Worley yang lebih kecil dengan skala yang lebih kecil <br>  A-channel - kebisingan fBm taylable Varley dengan skala yang lebih kecil <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ms/_9/z-/ms_9z-hofvyvya5-zuh6vpi6da0.png"></div><br>  Pencampuran dilakukan dengan cara ini: <br><br><pre> <code class="cpp hljs">finalValue=remap(noise.x, (noise.y * <span class="hljs-number"><span class="hljs-number">0.625</span></span> + noise.z*<span class="hljs-number"><span class="hljs-number">0.25</span></span> + noise.w * <span class="hljs-number"><span class="hljs-number">0.125</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Hasil untuk irisan 2D: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/64/qh/rl/64qhrl3wl2vrsbedao4fk9zr3xg.png"></div><br>  Sekarang siapkan tekstur dengan noise frekuensi tinggi: <br>  R-channel - ubin fBm Vorley noise <br>  G-channel - fBm Vorley noise berskala lebih kecil <br>  B-channel - Varley taylivaya fBm noise dengan skala yang lebih kecil <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ox/m6/in/oxm6inosejxwrkx2kdz7zv17eea.png"></div><br><pre> <code class="cpp hljs">finalValue=noise.x * <span class="hljs-number"><span class="hljs-number">0.625</span></span> + noise.y*<span class="hljs-number"><span class="hljs-number">0.25</span></span> + noise.z * <span class="hljs-number"><span class="hljs-number">0.125</span></span>;</code> </pre> <br>  Hasil untuk irisan 2D: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lg/mr/mc/lgmrmc2ohi3ayicwbji49fdhqb4.png"></div><br>  Kita juga membutuhkan peta cuaca-tekstur 2D yang akan menentukan keberadaan, kepadatan, dan bentuk awan, tergantung pada koordinat ruang.  Itu dilukis oleh seniman untuk menyempurnakan tutupan awan.  Interpretasi saluran warna dari peta cuaca mungkin berbeda, dalam versi yang saya pinjamkan, adalah sebagai berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fu/oi/m8/fuoim8wbtdzgqoc2lma8g6gb0ow.png"></div><br>  R-channel - tutupan awan ketinggian rendah <br>  G-channel - tutupan awan ketinggian tinggi <br>  B-channel - ketinggian awan maksimum <br>  A-channel - kerapatan awan <br><br>  Sekarang kita siap membuat fungsi yang akan mengembalikan kerapatan awan tergantung pada koordinat ruang 3D. <br><br>  Di pintu masuk, titik di ruang angkasa dengan koordinat dalam km <br><br><pre> <code class="cpp hljs">vec3 position</code> </pre> <br>  Segera tambahkan offset ke angin <br><br><pre> <code class="cpp hljs">position.xz+=vec2(<span class="hljs-number"><span class="hljs-number">0.2f</span></span>)*ufmParams.time;</code> </pre> <br>  Dapatkan nilai peta cuaca <br><br><pre> <code class="cpp hljs">vec4 weather=textureLod(ufmWeatherMap, position.xz/<span class="hljs-number"><span class="hljs-number">4096.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre>  Kami mendapatkan persentase tinggi (dari 0 hingga 1) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> height=cloudGetHeight(position);</code> </pre> <br>  Tambahkan pembulatan kecil awan di bawah ini: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SRb=clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.07</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre>  Kami membuat penurunan kerapatan linear menjadi 0 dengan meningkatnya ketinggian menurut B-channel dari peta cuaca: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SRt=clamp(remap(height, weather.b*<span class="hljs-number"><span class="hljs-number">0.2</span></span>, weather.b, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre>  Gabungkan hasilnya: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SA=SRb*SRt;</code> </pre> <br>  Sekali lagi tambahkan pembulatan awan di bawah ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DRb=height*clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.15</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Tambahkan juga pembulatan awan di atas: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DRt=height*clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0.9</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre>  Kami menggabungkan hasilnya, di sini kami menambahkan pengaruh kepadatan dari peta cuaca dan pengaruh kepadatan, yang ditetapkan melalui gui: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DA=DRb*DRt*weather.a*<span class="hljs-number"><span class="hljs-number">2</span></span>*ufmProperties.density;</code> </pre> <br>  Gabungkan noise frekuensi rendah dan frekuensi tinggi dari tekstur kami: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SNsample=textureLod(ufmLowFreqNoiseTexture, position/<span class="hljs-number"><span class="hljs-number">48.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).x*<span class="hljs-number"><span class="hljs-number">0.85f</span></span>+textureLod(ufmHighFreqNoiseTexture, position/<span class="hljs-number"><span class="hljs-number">4.8f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).x*<span class="hljs-number"><span class="hljs-number">0.15f</span></span>;</code> </pre> <br>  Di semua dokumen yang saya baca, penggabungan terjadi dengan cara yang berbeda, tetapi saya menyukai opsi ini. <br><br>  Kami menentukan jumlah cakupan (% dari langit yang ditempati awan), yang ditetapkan melalui gui, saluran R dan G pada peta cuaca juga digunakan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> WMc=max(weather.r, clamp(ufmProperties.coverage<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)*weather.g*<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Hitung kerapatan akhir: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d=clamp(remap(SNsample*SA, <span class="hljs-number"><span class="hljs-number">1</span></span>-ufmProperties.coverage*WMc, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)*DA;</code> </pre> <br>  Seluruh fungsi: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cloudSampleDensity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 position)</span></span></span><span class="hljs-function"> </span></span>{ position.xz+=vec2(<span class="hljs-number"><span class="hljs-number">0.2f</span></span>)*ufmParams.time; vec4 weather=textureLod(ufmWeatherMap, position.xz/<span class="hljs-number"><span class="hljs-number">4096.0f</span></span>+vec2(<span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> height=cloudGetHeight(position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SRb=clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.07</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SRt=clamp(remap(height, weather.b*<span class="hljs-number"><span class="hljs-number">0.2</span></span>, weather.b, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SA=SRb*SRt; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DRb=height*clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.15</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DRt=height*clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0.9</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DA=DRb*DRt*weather.a*<span class="hljs-number"><span class="hljs-number">2</span></span>*ufmProperties.density; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SNsample=textureLod(ufmLowFreqNoiseTexture, position/<span class="hljs-number"><span class="hljs-number">48.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).x*<span class="hljs-number"><span class="hljs-number">0.85f</span></span>+textureLod(ufmHighFreqNoiseTexture, position/<span class="hljs-number"><span class="hljs-number">4.8f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).x*<span class="hljs-number"><span class="hljs-number">0.15f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> WMc=max(weather.r, clamp(ufmProperties.coverage<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)*weather.g*<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d=clamp(remap(SNsample*SA, <span class="hljs-number"><span class="hljs-number">1</span></span>-ufmProperties.coverage*WMc, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)*DA; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d; }</code> </pre> <br>  Apa sebenarnya fungsi ini seharusnya adalah pertanyaan terbuka, karena mengabaikan hukum yang dipatuhi awan saat mengatur parameter, Anda bisa mendapatkan hasil yang sangat tidak biasa dan indah.  Itu semua tergantung aplikasi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tf/nz/bz/tfnzbzvd2oucw2h_oed9pbm_8ku.png"></div><br><h2>  Integrasi </h2><br>  Atmosfer Bumi dibagi menjadi dua lapisan: internal dan eksternal, di antaranya awan dapat ditemukan.  Lapisan-lapisan ini dapat diwakili oleh bola, tetapi juga oleh pesawat.  Saya memilih bola.  Untuk lapisan pertama, saya mengambil jari-jari bola 6415 km, untuk lapisan kedua, jari-jari 6435 km.  Jari-jari bumi membulat hingga 6.400 km.  Beberapa parameter akan tergantung pada ketebalan bersyarat dari bagian "mendung" atmosfer (20 km). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0z/ir/8r/0zir8r9qtvwlh9xk85i-hznhqa0.png"></div><br><br>  Tidak seperti langit, awan bersifat buram, dan integrasi tidak hanya membutuhkan warna, tetapi juga mendapatkan nilai untuk saluran alpha.  Pertama, Anda membutuhkan fungsi yang mengembalikan kerapatan total awan tempat sinar cahaya dari matahari akan lewat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5k/ne/lj/5kneljw4unaofsxxgbq12ealebw.png"></div><br>  Tidak ada yang menarik perhatian pada hal ini, tetapi latihan telah menunjukkan bahwa sama sekali tidak perlu memperhitungkan seluruh jalur balok, hanya dibutuhkan celah yang paling ekstrem.  Kami berasumsi bahwa awan di atas segmen terpotong tidak ada sama sekali. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/sr/ly/edsrlyis3-2or1nztj6q-osmats.png"></div><br>  Selain itu, kami sangat terbatas dalam jumlah sampel kepadatan yang dapat dilakukan tanpa membunuh kinerja.  Gerilya Game melakukan 6. Selain itu, dalam salah satu presentasi, pengembang mengatakan bahwa mereka menyebarkan sampel ini di dalam kerucut, dan sampel terakhir dibuat sangat jauh dari yang lain untuk menutupi ruang sebanyak mungkin.  Ketidakakuratan dan kebisingan yang dihasilkan masih akan diperhalus dengan latar belakang sampel tetangga, dan ini, sebaliknya, akan berubah menjadi peningkatan akurasi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5p/rr/df/5prrdfocofvzsjobvawnairijp0.png"></div><br>  Pada akhirnya, saya memilih 4 sampel yang terletak pada garis yang sama, tetapi yang terakhir diambil dengan langkah meningkat 6 kali.  Ukuran langkah adalah 20 km * 0,01, yaitu 200 m. <br><br>  Fungsinya cukup sederhana: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cloudSampleDirectDensity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 position, vec3 sunDir)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   float avrStep=(6435.0-6415.0)*0.01; float sumDensity=0.0; for(int i=0;i&lt;4;i++) { float step=avrStep; //      6 if(i==3) step=step*6.0; //  position+=sunDir*step; //  ,  ,   //  float density=cloudSampleDensity(position)*step; sumDensity+=density; } return sumDensity; }</span></span></code> </pre> <br>  Sekarang Anda dapat beralih ke bagian yang lebih sulit.  Kami menentukan pengamat di permukaan bumi pada titik {0, 6400,0} dan menemukan persimpangan berkas pengamatan dengan bola jari-jari 6415 km dan pusat {0,0,0} - kami mendapatkan titik awal S. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/25/je/zj/25jezjeea4j3bl51jneypfjetsi.png"></div><br>  Di bawah ini adalah versi dasar dari fungsi: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainMarching</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 viewDir, vec3 sunDir)</span></span></span><span class="hljs-function"> </span></span>{ vec3 position; crossRaySphereOutFar(vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">6400.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>), viewDir, vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>), <span class="hljs-number"><span class="hljs-number">6415.0</span></span>, position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> avrStep=(<span class="hljs-number"><span class="hljs-number">6435.0</span></span><span class="hljs-number"><span class="hljs-number">-6415.0</span></span>)/<span class="hljs-number"><span class="hljs-number">64.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;<span class="hljs-number"><span class="hljs-number">128</span></span>;i++) { position+=viewDir*step; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(length(position)&gt;<span class="hljs-number"><span class="hljs-number">6435.0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>); }</code> </pre> <br>  Ukuran langkah didefinisikan sebagai 20 km / 64. yaitu  dalam kasus arah vertikal ketat dari berkas pengamat, kami akan membuat 64 sampel.  Namun, ketika arah ini lebih horizontal, sampel akan sedikit lebih besar, sehingga tidak ada 64 langkah dalam siklus, tetapi 128 dengan margin. <br><br>  Pada awalnya, kami menganggap bahwa warna akhir adalah hitam, dan transparansi adalah kesatuan.  Dengan setiap langkah, kami akan meningkatkan nilai warna dan mengurangi nilai transparansi.  Jika transparansi mendekati 0, maka Anda dapat keluar dari loop sebelumnya: <br><br><pre> <code class="cpp hljs">vec3 color=vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> transmittance=<span class="hljs-number"><span class="hljs-number">1.0</span></span>; … <span class="hljs-comment"><span class="hljs-comment">//    //      float density=cloudSampleDensity(position)*avrStep; //   ,   //   float sunDensity=cloudSampleDirectDensity(position, sunDir); //      float m2=exp(-ufmProperties.attenuation*sunDensity); float m3=ufmProperties.attenuation2*density; float light=ufmProperties.sunIntensity*m2*m3; //       color+=sunColor*light*transmittance; transmittance*=exp(-ufmProperties.attenuation*density); … return vec4(color, 1.0-transmittance);</span></span></code> </pre> <br>  ufmProperties.attenuation - Tidak ada yang lain selain C in <img src="https://habrastorage.org/getpro/habr/post_images/610/ddb/ee8/610ddbee8d80f847b44fa75c9a136489.svg">  dan ufmProperties.attenuation2 adalah C dalam <img src="https://habrastorage.org/getpro/habr/post_images/cd1/8c2/405/cd18c240521dcfb71084a340a504e41f.svg">  .  ufmProperties.sunIntensity - intensitas radiasi matahari.  sunColor - warna matahari. <br><br>  Hasil: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vc/ft/z9/vcftz9vsswkxpqoggirezpfpygm.png"></div><br>  Sebuah cacat segera terlihat - naungan yang parah.  Tapi sekarang kita akan memperbaiki kurangnya pencahayaan yang diperkuat di dekat matahari.  Itu terjadi karena kami tidak menambahkan fungsi fase.  Untuk menghitung hamburan cahaya yang melewati awan, fase-fungsi Hengy-Greenstein digunakan, yang membukanya pada tahun 1941 untuk perhitungan serupa dalam kluster gas di ruang angkasa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b0/b2e/33f/4b0b2e33fbd07036b14317d40cb1eac0.svg"></div><br>  Penyimpangan harus dilakukan di sini.  Menurut model pencahayaan kanonik, fungsi fase harus satu.  Namun, pada kenyataannya, hasil yang diperoleh tidak sesuai dengan siapa pun dan semua orang menggunakan fungsi dua fase, dan bahkan menggabungkan nilai-nilai mereka dengan cara khusus.  Saya juga fokus pada fungsi dua fase, tapi saya hanya menambahkan nilainya.  Fungsi fase pertama memiliki g mendekati 1 dan memungkinkan Anda membuat pencahayaan terang di dekat matahari.  Fungsi fase kedua memiliki g mendekati 0,5 dan memungkinkan Anda untuk membuat penurunan bertahap dalam pencahayaan di seluruh bidang langit. <br><br>  Kode yang diperbarui: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// cos(theta) float mu=max(0, dot(viewDir, sunDir)); float m11=ufmProperties.phaseInfluence*cloudPhaseFunction(mu, ufmProperties.eccentrisy); float m12=ufmProperties.phaseInfluence2*cloudPhaseFunction(mu, ufmProperties.eccentrisy2); float m2=exp(-ufmProperties.attenuation*sunDensity); float m3=ufmProperties.attenuation2*density; float light=ufmProperties.sunIntensity*(m11+m12)*m2*m3;</span></span></code> </pre> <br>  ufmProperties.eccentrisy, ufmProperties.eccentrisy2 adalah nilai g <br><br>  Hasil: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ip/qr/fi/ipqrfivyafyxnmdswnn_nbpvfdk.png"></div><br>  Sekarang Anda bisa memulai pertarungan dengan terlalu banyak naungan.  Itu hadir karena kita tidak memperhitungkan cahaya dari awan di sekitarnya dan langit, yang ada di kehidupan nyata. <br><br>  Saya memecahkan masalah ini seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec4(color+ambientColor*ufmProperties.ambient, <span class="hljs-number"><span class="hljs-number">1.0</span></span>-transmittance);</code> </pre> <br>  Di mana ambientColor adalah warna langit ke arah sinar pengamatan, ufmProperties.ambient adalah parameter tuning. <br><br>  Hasil: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ct/8h/ji/ct8hjiyk7brz5pv8vuwjeji33bc.png"></div><br>  Masih untuk menyelesaikan masalah terakhir.  Dalam kehidupan nyata, semakin horizontal pandangan dipegang, semakin kita melihat kabut atau kabut tertentu yang tidak memungkinkan kita untuk melihat objek yang sangat jauh.  Ini juga perlu tercermin dalam kode.  Saya mengambil cosine biasa dari sudut pandang dan fungsi eksponensial.  Berdasarkan ini, koefisien campuran tertentu dihitung, yang memungkinkan interpolasi linier antara warna yang dihasilkan dan warna latar belakang. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> blending=<span class="hljs-number"><span class="hljs-number">1.0</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-max(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, dot(viewDir, vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>)))*ufmProperties.fog); blending=blending*blending*blending; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec4(mix(ambientColor, color+ambientColor*ufmProperties.ambient, blending), <span class="hljs-number"><span class="hljs-number">1.0</span></span>-transmittance);</code> </pre> <br>  ufmProperties.fog - untuk konfigurasi manual. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/02/td/9h/02td9ho6kelgum68wldvcf-zymu.png"></div><br>  Fungsi ringkasan: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainMarching</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 viewDir, vec3 sunDir, vec3 sunColor, vec3 ambientColor)</span></span></span><span class="hljs-function"> </span></span>{ vec3 position; crossRaySphereOutFar(vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">6400.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>), viewDir, vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>), <span class="hljs-number"><span class="hljs-number">6415.0</span></span>, position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> avrStep=(<span class="hljs-number"><span class="hljs-number">6435.0</span></span><span class="hljs-number"><span class="hljs-number">-6415.0</span></span>)/<span class="hljs-number"><span class="hljs-number">64.0</span></span>; vec3 color=vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> transmittance=<span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;<span class="hljs-number"><span class="hljs-number">128</span></span>;i++) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> density=cloudSampleDensity(position)*avrStep; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(density&gt;<span class="hljs-number"><span class="hljs-number">0.0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sunDensity=cloudSampleDirectDensity(position, sunDir); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> mu=max(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, dot(viewDir, sunDir)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m11=ufmProperties.phaseInfluence*cloudPhaseFunction(mu, ufmProperties.eccentrisy); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m12=ufmProperties.phaseInfluence2*cloudPhaseFunction(mu, ufmProperties.eccentrisy2); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m2=<span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-ufmProperties.attenuation*sunDensity); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m3=ufmProperties.attenuation2*density; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> light=ufmProperties.sunIntensity*(m11+m12)*m2*m3; color+=sunColor*light*transmittance; transmittance*=<span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-ufmProperties.attenuation*density); } position+=viewDir*avrStep; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(transmittance&lt;<span class="hljs-number"><span class="hljs-number">0.05</span></span> || length(position)&gt;<span class="hljs-number"><span class="hljs-number">6435.0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> blending=<span class="hljs-number"><span class="hljs-number">1.0</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-max(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, dot(viewDir, vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>)))*ufmProperties.fog); blending=blending*blending*blending; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec4(mix(ambientColor, color+ambientColor*ufmProperties.ambient, blending), <span class="hljs-number"><span class="hljs-number">1.0</span></span>-transmittance); }</code> </pre> <br>  Video demo: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/uPxVgbwThmI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Optimalisasi dan kemungkinan peningkatan </h2><br>  Setelah menerapkan algoritma rendering dasar, masalah berikutnya adalah ia bekerja terlalu lambat.  Versi saya menghasilkan 25 fps dalam full hd pada radeon rx 480. Dua pendekatan berikut untuk memecahkan masalah disarankan oleh Guerrilla Games sendiri. <br><br>  <b>Kami menggambar apa yang benar-benar terlihat</b> <br><br>  Layar dibagi menjadi ubin berukuran 16x16 piksel.  Pertama, lingkungan 3D biasa digambar.  Ternyata sebagian besar langit ditutupi oleh gunung atau benda besar.  Oleh karena itu, Anda perlu melakukan perhitungan hanya pada ubin-ubin di mana awan tidak terhalang oleh apa pun. <br><br>  <b>Proyeksi ulang</b> <br><br>  Ketika kamera diam, ternyata awan pada umumnya tidak bisa diperbarui.  Namun, jika kamera telah bergerak, ini tidak berarti bahwa kami perlu memperbarui seluruh layar.  Semuanya sudah digambar, Anda hanya perlu membangun kembali gambar sesuai dengan koordinat baru.  Menemukan koordinat lama pada yang baru, melalui proyeksi dan melihat matriks dari frame saat ini dan sebelumnya, disebut proyeksi.  Jadi, dalam kasus pergeseran kamera, kami cukup mentransfer warna sesuai dengan koordinat baru.  Dalam kasus di mana koordinat ini menunjukkan di luar layar, awan harus digambar ulang dengan jujur. <br><br>  <b>Pembaruan sebagian</b> <br><br>  Saya tidak menyukai ide proyeksi ulang karena dengan putaran tajam pada kamera, mungkin awan akan berubah menjadi sepertiga layar, yang dapat menyebabkan jeda.  Saya tidak tahu bagaimana Game Gerilya menangani ini, tetapi setidaknya di Horizon Zero Dawn, ketika mengendalikan joystick, kamera bergerak dengan lancar dan tidak ada masalah dengan lompatan yang tajam.  Karena itu, sebagai percobaan, saya datang dengan pendekatan saya sendiri.  Awan digambar dalam peta kubik, dalam 5 wajah, karena  bagian bawah tidak menarik bagi kita.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sisi peta kubik memiliki resolusi berkurang sama dengan ⅔ dari ketinggian layar. Setiap muka peta kubik dibagi menjadi 8x8 ubin. Setiap bingkai di setiap wajah diperbarui dengan hanya satu dari 64 piksel di setiap ubin. Ini memberikan artefak yang terlihat selama perubahan tiba-tiba, tetapi karena Awannya cukup statis, maka trik seperti itu tidak terlihat. Hasilnya, radeon rx 480 menghasilkan 500 fps dalam resolusi penuh untuk gunung berapi dan 330 fps untuk pembukaan. Radeon hd 5700 series menghasilkan 109 fps dalam full hd di bawah OpenGL (vulkan tidak mendukung). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan level mip</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saat mengakses tekstur dengan noise, Anda dapat mengambil data dari level nol mip hanya pada sampel pertama, dan kemudian semakin jauh sampel yang kami buat, semakin besar level mip yang dapat diambil. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Awan tinggi</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk mensimulasikan keberadaan awan cirrus-altitude dan cirrocumulus di Game Gerilya selama integrasi, sampel terbaru dibuat bukan dari tekstur 3D yang saya bicarakan, tetapi dari tekstur 2D khusus. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/f2/vj/udf2vjpfht0hhpbf9zptwfmadhg.jpeg"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curl noise</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beberapa tekstur tambahan dalam curl noise digunakan untuk menciptakan efek awan angin bertiup. </font><font style="vertical-align: inherit;">Tekstur ini diperlukan untuk menggeser koordinat asli.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-n/qq/pg/-nqqpgmixyogyjxqrdyhm4oxlpc.png"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sinar ilahi</font></font></b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qd/wq/xv/qdwqxvzveiwuxgu2v84aw5fhjwo.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sinar seperti itu, menangkap pada drama, diwujudkan dalam postprocessing. </font><font style="vertical-align: inherit;">Pertama, iluminasi terang digambar di sekitar matahari, di mana ia tidak terhalang oleh awan. </font><font style="vertical-align: inherit;">Maka lampu latar ini harus diimbangi secara radial dari matahari.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ap/vj/-a/apvj-assr02-vaov3o1k5frfawk.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang Anda perlu menerapkan perataan radial. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jd/lg/1h/jdlg1hp7jajzhlbom4ocmn3vl70.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faktanya, ada lebih banyak peningkatan dan kehalusan, tapi saya tidak memeriksa semuanya, jadi saya tidak bisa mengatakan dengan percaya diri tentang mereka. Namun, Anda bisa membiasakan diri dengan mereka sendiri. Saya pikir yang terkuat adalah dokumentasi cloud dari mesin Frostbite.</font></font><br><br><h2>  Tautan yang bermanfaat </h2><br> <b> Guerrilla Games</b> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">d1z4o56rleaq4j.cloudfront.net/downloads/assets/Nubis-Authoring-Realtime-Volumetric-Cloudscapes-with-the-Decima-Engine-Final.pdf?mtime=20170807141817</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">killzone.dl.playstation.net/killzone/horizonzerodawn/presentations/Siggraph15_Schneider_Real-Time_Volumetric_Cloudscapes_of_Horizon_Zero_Dawn.pdf</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.youtube.com/watch?v=-d8qT5-1LOI</a> <br><br> <b>  GPU Pro 7</b> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">vk.com/doc179245989_437393482?hash=a9af5f665eda4edf58&amp;dl=806d4dbdac0f7a761c</a> <br><br> <b></b> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/simulating-colors-of-the-sky</a> <br><br> <b> Frostbite</b> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">media.contentapi.ea.com/content/dam/eacom/frostbite/files/s2016-pbs-frostbite-sky-clouds-new.pdf</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.shadertoy.com/view/XlBSRz</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459948/">https://habr.com/ru/post/id459948/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459924/index.html">Siklus Pengujian Reaksi Penuh. Laporan Auto.ru</a></li>
<li><a href="../id459928/index.html">Jalur siswa ke pengembangan aplikasi seluler</a></li>
<li><a href="../id459930/index.html">Otomasi impor Python</a></li>
<li><a href="../id459934/index.html">Intisari materi menarik untuk pengembang ponsel # 306 (pada 8-14 Juli)</a></li>
<li><a href="../id459936/index.html">9 trik lagi untuk bekerja dengan Visual Studio</a></li>
<li><a href="../id459952/index.html">Sedikit pengalaman tentang cadangan & penyimpanan</a></li>
<li><a href="../id459954/index.html">Mengapa salah satu perusahaan IT terbesar bergabung dengan CNCF - dana pengembangan infrastruktur cloud</a></li>
<li><a href="../id459956/index.html">Implantasi tanpa adanya gigi sama sekali, sebagai akibat dari kunjungan yang tidak tepat waktu ke dokter gigi</a></li>
<li><a href="../id459958/index.html">Mem-parsing tugas-tugas dari konferensi Hydra - menyeimbangkan beban dan penyimpanan dalam memori</a></li>
<li><a href="../id459960/index.html">Dari ide hingga rilis. Detil Frontend Market</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>