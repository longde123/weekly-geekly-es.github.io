<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙆🏾 🤘🏼 🌯 Desarrollo de BPM juvenil elegante y de moda en Camunda 🚵🏼 🏼 🚣🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El desarrollo de BPM no es fácil. Esto se debe al hecho de que el proceso debe ser legible y comprensible para el cliente, y no solo correcto desde un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desarrollo de BPM juvenil elegante y de moda en Camunda</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/455860/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/1j/oi/yt/1joiyt3a6d_durbq0kzzzat4e04.png" alt="imagen"></div><br>  El desarrollo de BPM no es fácil.  Esto se debe al hecho de que el proceso debe ser legible y comprensible para el cliente, y no solo correcto desde un punto de vista técnico. <br><br>  No todas las herramientas para desarrollar procesos comerciales le permiten encontrar un compromiso entre una descripción clara y la funcionalidad técnica.  Muchas herramientas avanzadas de desarrollo y descripciones de procesos a menudo tienen un inconveniente más: son tan geniales, poderosas y complejas que, mientras se realizaban, las tecnologías dieron un gran paso adelante y el desarrollo con dicha herramienta se volvió irrelevante. <br><br>  2018 cambió fundamentalmente nuestro enfoque para el desarrollo de procesos comerciales.  A continuación se muestra cómo ha evolucionado este enfoque y cómo hemos cambiado. <br><a name="habracut"></a><br><h3>  En lugar de un prólogo </h3><br>  Nuestro departamento se dedica al desarrollo de procesos comerciales, desde el más pequeño y más pequeño hasta el más grande y extremadamente rentable.  Hasta hace poco, utilizamos un producto de IBM para el desarrollo, lo que nos permite lanzar rápidamente un proceso comercial en producción. <br><br>  IBM BPM es una plataforma poderosa que incluye un amplio conjunto de características, como una descripción de los procesos en sí, formularios de IU y módulos de integración.  Además, esta plataforma tiene un umbral de entrada bastante bajo, que permite a los desarrolladores novatos sumergirse de inmediato en el proyecto.  Pero este producto también tiene inconvenientes que, si no inhiben el desarrollo, ciertamente no contribuyen a la velocidad y la calidad: <br><br><ul><li>  No hay control de versiones sensatas.  IBM BPM simplemente no proporciona la capacidad de almacenar adecuadamente los procesos (código) en el repositorio y utiliza su propio repositorio, que no conoce un concepto como la fusión, por ejemplo. </li><li> Desarrollando en Java 6. Quizás en el momento de escribir esto, ya es posible desarrollar en Java 7, pero en 2019 esto es un poco de comodidad. </li><li>  IBM BPM está girando sobre WebSphere, como resultado, los desarrolladores deben ser pacientes con cada actualización de su módulo.  Además, este es un dolor de cabeza adicional para los administradores que periódicamente tienen que revivir a este monstruo si se cuelga. </li><li>  El desarrollo de módulos de integración en el entorno de Integration Designer, que de hecho no está oculto para el mejor Eclipse. </li><li>  No hay capacidad de prueba de unidad normal. </li><li>  El alto costo de la plataforma. </li></ul><br>  Estas deficiencias, además de los inconvenientes puramente técnicos del desarrollo, han creado otro problema, que es quizás mucho más grave que todo lo anterior.  En los días de Java 12, Kotlin, microservicios y otras tendencias y piezas de moda, todos estos matices desmotivan mucho al equipo.  Es difícil experimentar la alegría de desarrollar en el Diseñador de integración para Java 6 en 2019. <br><br><img src="https://habrastorage.org/webt/w-/vb/nv/w-vbnvq2nttuahmxuliqqatugng.png" alt="imagen"><br><br>  Con todas estas limitaciones, es difícil mantenerse a flote.  Hace poco menos de un año, hubo una oferta para probar el motor Camunda para describir los procesos comerciales.  Para empezar, se seleccionó un proceso no muy grande pero bastante importante para registrar terminales para personas jurídicas. <br><br>  Como lo reescribimos por completo, casi no había código antiguo, prácticamente no podíamos limitarnos a nada y, por lo tanto, elegimos Kotlin como el lenguaje de desarrollo.  Fue interesante probar este nuevo lenguaje, que se escuchó principalmente por críticas positivas.  En algunos otros proyectos en nuestro departamento hubo una exitosa experiencia de implementación.  La pila final resultó así: Camunda, Spring Boot 2, Kotlin, Postgre. <br><br><h3>  ¿Qué es la camunda? </h3><br><img src="https://habrastorage.org/webt/n7/jx/jk/n7jxjkzverskjq-ljwnhpabcqpu.png" alt="imagen"><br><br>  Camunda es una plataforma de modelado de procesos empresariales de código abierto que está escrita en Java y utiliza Java como lenguaje de desarrollo.  Es un conjunto de bibliotecas que le permiten realizar los procesos descritos.  Para integrar Camunda en un proyecto, solo agregue algunas dependencias.  Para almacenar procesos, puede elegir DBMS en memoria o persistentes, dependiendo de las tareas.  Elegimos Postgre, porque la historia es importante para nosotros para "debriefing".  Por defecto, la plataforma se implementa en H2. <br><br>  El desarrollo consta de dos partes: crear un proceso de flujo en una utilidad especial de Camunda Modeler y escribir código Java que procesa los pasos del proceso descritos en el diagrama.  Para llamar al código java desde el proceso, es suficiente implementar la interfaz JavaDelegate, generar este Bean (puede especificar el retraso por el nombre completo, pero a través del Bean es más conveniente y flexible) en el contexto y especificar su identificación en el paso del proceso deseado.  En Kotlin, el delegado se ve aún más sucinto.  La lógica de los delegados es bastante simple: restaron algo del contexto, realizaron algunas acciones y lo volvieron a poner en contexto. <br><br><img src="https://habrastorage.org/webt/vr/13/sy/vr13syiaahlc4bxpf32jay7kzg8.png" alt="imagen"><br>  <i>Ventana emergente de Camunda Modeler</i> <br><br><h4>  Ejemplo de delegado de Java: </h4><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.camunda.bpm.engine.delegate.DelegateExecution; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.camunda.bpm.engine.delegate.JavaDelegate; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JavaExampleDelegate</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JavaDelegate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DelegateExecution execution)</span></span></span><span class="hljs-function"> </span></span>{ String someVar = (String) execution.getVariable(<span class="hljs-string"><span class="hljs-string">"someVariable"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// some actions execution.setVariable("otherVariable", "otherValue"); } }</span></span></code> </pre> <br><h4>  Ejemplo de delegado de Kotlin: </h4><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.camunda.bpm.engine.delegate.DelegateExecution <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.camunda.bpm.engine.delegate.JavaDelegate <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KotlinExampleDelegate</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">JavaDelegate { override fun execute</span></span></span></span>(execution: DelegateExecution) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someVar = execution.getVariable(<span class="hljs-string"><span class="hljs-string">"someVariable"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//some code execution.setVariable("otherVariable", "someValue") } }</span></span></code> </pre><br>  En el delegado, puede describir la lógica empresarial, la integración y todo lo que su corazón desea. <br><br>  Intentamos crear una capa en forma de un componente comercial con lógica, y utilizamos el delegado solo como un enlace al flujo del proceso para que el código y el proceso se mezclen lo menos posible. <br><br>  En la mayoría de los casos, este enfoque es conveniente y funciona con éxito.  La interacción con el proceso se produce a través de DelegateExecution, que permite, por ejemplo, trabajar con contexto, incidentes, etc. <br><br><h3>  ¿Es eso lo que queríamos? </h3><br>  Al principio, al elegir una herramienta, buscábamos una solución con las siguientes características: <br><br><ul><li>  Recuperación del proceso exactamente desde el lugar donde ocurrió la falla, y es deseable que esté listo para usar. </li><li>  Alguna GUI donde puedes ver qué pasa con el proceso en general. </li><li>  La capacidad de escribir pruebas unitarias no solo para la lógica y la integración, sino también para el proceso en sí. </li><li>  Java 8 y superior. </li><li>  Comunidad desarrollada </li></ul><br>  Camunda está bien con recuperación y análisis de errores. <br><br>  Una traza bien legible, la capacidad de establecer el número de intentos de dar un paso antes de caer, un controlador personalizado al caer, por ejemplo, si durante una caída queremos cambiar el estado de alguna entidad a Error.  Esto último es fácil de hacer simplemente implementando DefaultIncidentHandler.  Es cierto, hay un momento divertido cuando este controlador funciona: el código de recuperación de error se activa cada vez que ingresa el paso del proceso.  No puedo decir que esto sea una superbacteria o un problema.  Por el contrario, solo necesita recordar y considerar esto al desarrollar. <br><br>  Lo resolvimos así: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolveIncident</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">IncidentContext</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> incidentList = Context.getCommandContext().incidentManager.findIncidentByConfiguration(context.configuration) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (incidentList.isNotEmpty()) { <span class="hljs-comment"><span class="hljs-comment">//      } }</span></span></code> </pre><br>  Camunda tiene una GUI y no está mal. <br><br>  Pero si desea un poco más, por ejemplo, la migración de instancias entre versiones de proceso, entonces tendrá que trabajar duro.  La interfaz de usuario predeterminada solo tiene una funcionalidad mínima, pero hay una API de Rest muy poderosa que le permite crear su propio panel de administración, genial y sofisticado. <br><br>  Fuimos a lo largo del camino de nuestro panel de administración.  Nuestro arquitecto de procesos de negocios en poco tiempo lo vio inactivo, incluidas las funciones de ver el historial de procesos ya completados, la migración entre versiones, etc. <br><br>  Camunda's Rest es realmente poderoso y le permite hacer casi cualquier cosa con los procesos.  Por ejemplo, puede iniciar un proceso usando <i>/ process-definition / key / aProcessDefinitionKey / start con</i> una solicitud tan simple: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"variables"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"aVariable"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"value"</span></span> : <span class="hljs-string"><span class="hljs-string">"aStringValue"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"String"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"anotherVariable"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"value"</span></span> : <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"Boolean"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"businessKey"</span></span> : <span class="hljs-string"><span class="hljs-string">"myBusinessKey"</span></span> }</code> </pre><br>  El ejemplo está tomado de la documentación oficial, que contiene una descripción extensa de los diversos casos de uso de esta API. <br><br>  Para las pruebas unitarias, usamos el Junit habitual.  Además, hay una biblioteca bastante interesante para probar el proceso en sí mismo: 'org.camunda.bpm.extension', nombre: 'camunda-bpm-afirmar'.  Con él, puede describir pruebas para verificar el proceso de flujo. <br><br>  Esto es bastante conveniente, ya que a menudo es más difícil buscar problemas con errores en el flujo que en el código.  Dichas pruebas protegen, por ejemplo, de la refactorización inexacta y realmente nos ayudaron varias veces. <br><br>  La necesidad de Java 8 ha desaparecido parcialmente, ya que el uso de Kotlin en muchos procesos eliminó la necesidad del G8.  Kotlin encaja muy bien con el proyecto y le permite centrarse solo en escribir la lógica empresarial.  Es difícil de creer, pero básicamente todo lo que Kotlin dice sobre la frescura es cierto.  Las entidades con una gran cantidad de campos, que son conocidas por casi todas las aplicaciones con integraciones, ahora no parecen tan aterradoras, y las asignaciones entre entidades se han vuelto mucho más legibles.  A menudo criticado, la seguridad nula realmente funciona y ayuda en la mayoría de los casos. <br><br>  La comunidad en Camunda está bastante desarrollada.  Esto se evidencia por el hecho de que constantemente aparecen nuevas bibliotecas en GitHub para pruebas y métricas. <br><br>  Es bueno que Camunda se integre perfectamente con Spring.  Agregue las dependencias necesarias, un par de anotaciones y un par de beans de configuración; de hecho, ¡eso es toda la integración!  Como resultado, escribimos una aplicación de primavera regular a la que todos están acostumbrados, agregando el flujo de un proceso comercial.  La interacción se lleva a cabo a través de la API de Java, que le permite manipular procesos desde el código de Java. <br><br>  Por ejemplo, puede iniciar el proceso con solo un comando: <br><br><pre> <code class="kotlin hljs">runtimeService.startProcessInstanceByKey( <span class="hljs-string"><span class="hljs-string">"MyTestProcess"</span></span>, <span class="hljs-string"><span class="hljs-string">"MyBusinessKey"</span></span>, mapOf( <span class="hljs-string"><span class="hljs-string">"key1"</span></span> to <span class="hljs-string"><span class="hljs-string">"value1"</span></span>, <span class="hljs-string"><span class="hljs-string">"key2"</span></span> to <span class="hljs-string"><span class="hljs-string">"value2"</span></span>, ) )</code> </pre><br>  Aquí MyTestProcess es el Id-shnik del proceso, no la instancia.  MyBusinessKey es una clave única para una instancia de proceso en ejecución.  Usualmente usamos algún valor comercial para este campo, para una navegación más rápida entre instancias y búsqueda. <br><br>  De la misma manera, puede despertar un proceso "somnoliento". <br><br>  Los inconvenientes notables o cualquier problema que encontramos, especialmente no se pueden recordar.  Como resultado, durante un período de tiempo bastante corto, resultó ser un proceso completamente funcional y ponerlo en producción de manera segura.  Se están implementando otros procesos en la plataforma y con bastante éxito.  Ahora en Camunda hemos lanzado unas 15 aplicaciones en las que giran alrededor de 100 mil procesos a la vez. <br><br><img src="https://habrastorage.org/webt/w_/zz/rt/w_zzrtmrhavm1i-wld62ymbclng.png" alt="imagen"><br><br><h3>  En lugar de un epílogo </h3><br>  Aquí hay algunos recursos que han sido útiles para implementar la pila descrita anteriormente.  Le recomiendo que los lea si está interesado en obtener información adicional sobre el tema. <br><br><ul><li>  Camunda está bien documentada: encontramos la mayoría de los casos necesarios <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en la documentación oficial</a> . </li><li>  Se pueden ver más detalles sobre la plataforma, casos interesantes y, en general, sobre bpm <a href="">en este canal</a> .  Está dirigido por nuestro colega, quien sugirió usar Camunda. </li><li>  Un buen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe de Pavel Finkelstein sobre la implementación de Kotlin</a> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/455860/">https://habr.com/ru/post/455860/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455850/index.html">Caja de herramientas para investigadores - Tercera edición: Encontrar y trabajar con fuentes</a></li>
<li><a href="../455852/index.html">Levantamiento de senos e implantación simultánea</a></li>
<li><a href="../455854/index.html">Cómo implementar menús contextuales en iOS 13</a></li>
<li><a href="../455856/index.html">Sensor inalámbrico de temperatura, humedad y presión atmosférica en nRF52832</a></li>
<li><a href="../455858/index.html">Redes de TV por cable para los más pequeños. Parte 9: cabecera</a></li>
<li><a href="../455862/index.html">Novedades de AWS: DATA API, Kinesis Data Analytics, S3 Path</a></li>
<li><a href="../455868/index.html">Superando la Ley de Moore: Tecnologías de transistores del futuro</a></li>
<li><a href="../455872/index.html">¿Qué apuestas hizo Bezos en 1997 para que Amazon ahora tenga el 50% del mercado de comercio electrónico en los Estados Unidos y el 14% en el mundo?</a></li>
<li><a href="../455874/index.html">Procedimiento de notificación para aplicaciones Electron para macOS 10.14.5</a></li>
<li><a href="../455878/index.html">Escenarios para el uso de la analítica de video en el comercio minorista. Siguiendo los pasos de Video Analytics en Retail</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>