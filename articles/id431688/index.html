<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐓 🤐 🚜 Bagaimana dentang mengkompilasi suatu fungsi 📯 ↪️ 🕵🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya berencana untuk menulis artikel tentang bagaimana LLVM mengoptimalkan suatu fungsi, tetapi pertama-tama Anda perlu menulis bagaimana Dentang mene...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana dentang mengkompilasi suatu fungsi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431688/">  Saya berencana untuk menulis artikel tentang bagaimana LLVM mengoptimalkan suatu fungsi, tetapi pertama-tama Anda perlu menulis bagaimana Dentang menerjemahkan C atau C ++ ke LLVM. <br><br><img src="https://habrastorage.org/webt/df/9y/a9/df9ya9didizcjaetap9tjvfymzo.jpeg" alt="gambar"><br><a name="habracut"></a><br><br>  Pertimbangkan aspek tingkat tinggi tanpa menyelam ke kedalaman Dentang.  Saya ingin memperhatikan bagaimana dentang output terkait dengan input, sementara kami tidak akan mempertimbangkan fitur non-sepele dari C ++.  Kami menggunakan fungsi kecil ini, yang saya pinjam dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kuliah</a> luar biasa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tentang optimisasi siklik</a> : <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_sorted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[i] &gt; a[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Karena Dentang tidak membuat optimasi apa pun, dan karena LLVM IR pada awalnya dirancang untuk bekerja dengan C dan C ++, konversi relatif mudah.  Saya akan menggunakan Dentang 6.0.1 (atau versi dekat, karena yang ini belum dirilis) di x86-64. <br><br>  Baris perintah adalah sebagai berikut: <br><br><pre> <code class="bash hljs">clang++ is_sorted.cpp -O0 -S -emit-llvm</code> </pre> <br>  Dengan kata lain: kita mengkompilasi file is_sorted.cpp sebagai C ++ dan kemudian memberi tahu rantai alat LLVM berikut ini: jangan mengoptimalkan, mengeluarkan assembler sebagai representasi tekstual dari LLVM IR.  LLVM IR adalah produktif, dan tidak dapat dengan cepat ditampilkan atau diurai; format kode bit biner selalu lebih disukai jika seseorang tidak perlu melihat kode ini.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berikut</a> adalah LLVM IR lengkap, kami akan memeriksanya di beberapa bagian. <br><br>  Mari kita mulai dari bagian atas file: <br><br><pre> <code class="cpp hljs">; ModuleID = <span class="hljs-string"><span class="hljs-string">'is_sorted.cpp'</span></span> source_filename = <span class="hljs-string"><span class="hljs-string">"is_sorted.cpp"</span></span> target datalayout = <span class="hljs-string"><span class="hljs-string">"em:e-i64:64-f80:128-n8:16:32:64-S128"</span></span> target triple = <span class="hljs-string"><span class="hljs-string">"x86_64-unknown-linux-gnu"</span></span></code> </pre> <br>  Seluruh teks antara titik koma dan akhir baris adalah komentar, yang berarti bahwa baris pertama tidak melakukan apa-apa, tetapi, jika Anda tertarik, dalam LLVM "modul" adalah unit kompilasi, wadah untuk kode dan data.  Baris kedua seharusnya tidak mengganggu kita juga.  Baris ketiga menjelaskan beberapa asumsi yang dibuat oleh kompiler, mereka tidak berperan dalam artikel ini, tetapi Anda dapat membaca lebih lanjut di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Target tiga</a> adalah warisan gcc dan tidak lagi membutuhkan kita. <br><br>  Fungsi LLVM memiliki atribut opsional: <br><br><pre> <code class="cpp hljs">; Function Attrs: noinline nounwind optnone uwtable</code> </pre> <br>  Beberapa dari mereka (seperti ini) didukung oleh front-end, yang lain ditambahkan kemudian oleh melewati optimasi.  Atribut ini tidak ada hubungannya dengan arti kode, saya tidak akan membahasnya di sini, tetapi Anda dapat membaca tentang mereka di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> jika Anda tertarik. <br><br>  Dan akhirnya, fungsi kami: <br><br><pre> <code class="bash hljs">define zeroext i1 @_Z9is_sortedPii(i32* %a, i32 %n) <span class="hljs-comment"><span class="hljs-comment">#0 {</span></span></code> </pre> <br>  "Zeroext" berarti bahwa nilai balik fungsi (i1, bilangan bulat tunggal) harus diperluas dengan nol di backend ke lebar yang dibutuhkan ABI.  Kemudian muncul nama fungsi "mangled", kemudian daftar parameter pada dasarnya sama dengan kode C ++, kecuali bahwa i32 mendefinisikan variabel 32-bit.  # 0 menghubungkan fungsi ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">grup atribut</a> di akhir file. <br><br>  Ini adalah unit dasar pertama: <br><br><pre> <code class="cpp hljs">entry: %retval = alloca i1, align <span class="hljs-number"><span class="hljs-number">1</span></span> %a.addr = alloca i32*, align <span class="hljs-number"><span class="hljs-number">8</span></span> %n.addr = alloca i32, align <span class="hljs-number"><span class="hljs-number">4</span></span> %i = alloca i32, align <span class="hljs-number"><span class="hljs-number">4</span></span> store i32* %a, i32** %a.addr, align <span class="hljs-number"><span class="hljs-number">8</span></span> store i32 %n, i32* %n.addr, align <span class="hljs-number"><span class="hljs-number">4</span></span> store i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32* %i, align <span class="hljs-number"><span class="hljs-number">4</span></span> br label %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.cond</code> </pre> <br>  Setiap instruksi LLVM harus ditempatkan di dalam unit dasar: satu set instruksi yang memiliki satu input di awal dan satu output di akhir.  Instruksi terakhir dari unit dasar harus berupa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">instruksi terminasi</a> : "gagal" ke unit dasar berikutnya tidak dapat diterima.  Setiap fungsi harus memiliki blok input yang tidak memiliki pendahulu yang melakukan transisi ke blok ini.  Properti ini dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lainnya</a> diperiksa ketika parsing IR; pemeriksaan ini juga dapat dipanggil beberapa kali selama proses kompilasi oleh "module verifier".  Verifier berguna untuk debugging ketika pass menghasilkan IR yang tidak valid. <br><br>  Empat instruksi pertama dalam blok dasar ini adalah "mengalokasikan": mengalokasikan memori tumpukan.  Tiga variabel pertama dibuat secara implisit dibuat selama kompilasi, yang keempat - variabel loop.  Variabel yang dialokasikan dengan cara ini hanya dapat diakses melalui instruksi memuat dan menyimpan.  Tiga instruksi berikut menginisialisasi tiga slot stack, a.addr dan n.addr diinisialisasi menggunakan nilai yang diteruskan ke fungsi sebagai parameter, dan saya diinisialisasi ke nol.  Nilai kembali tidak perlu diinisialisasi, kode apa pun yang tidak terdefinisi dalam C dan C ++ harus mengurus hal ini.  Instruksi terakhir adalah transisi tanpa syarat ke unit dasar berikutnya (kami belum khawatir tentang hal ini, transisi yang paling tidak perlu akan dihapus oleh backend LLVM). <br><br>  Anda mungkin bertanya: mengapa Dentang mengalokasikan slot stack untuk a dan n?  Mengapa dia tidak menggunakan nilai-nilai ini secara langsung?  Dalam fungsi ini, karena a dan n tidak berubah, strategi seperti itu akan berhasil, tetapi kasus ini akan diperhitungkan oleh pengoptimal, dan berada di luar kompetensi Calng.  Jika a dan n dapat dimodifikasi, mereka harus di memori, dan tidak boleh nilai SSA, yang, menurut definisi, dapat mengambil nilai hanya pada satu titik dalam program.  Sel memori berada di luar dunia SSA dan dapat dimodifikasi kapan saja.  Ini mungkin tampak aneh, tetapi solusi semacam itu memungkinkan Anda untuk mengatur pekerjaan semua bagian kompiler dengan cara yang alami dan efisien. <br><br>  Saya menganggap Dentang sebagai generator kode SSA yang merosot yang memenuhi semua persyaratan SSA, tetapi hanya karena pertukaran informasi antara unit dasar terjadi melalui memori.  Membuat kode non-degenerasi memerlukan perhatian dan analisis, dan pengembang Clang menolak untuk melakukan ini untuk memisahkan tanggung jawab menghasilkan dan mengoptimalkan kode.  Saya tidak melihat hasil pengukuran, tetapi dalam pemahaman saya, banyak operasi memori dihasilkan, dan kemudian, hampir segera, sebagian besar dari mereka dihapus oleh pengoptimal, tanpa mengarah ke overhead besar waktu kompilasi, <br><br>  Pertimbangkan bagaimana loop for diterjemahkan.  Secara umum, tampilannya seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (initializer; condition; modifier) { body }</code> </pre> <br>  Ini diterjemahkan menjadi sesuatu seperti ini: <br><br><pre> <code class="cpp hljs"> initializer <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> COND COND: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> BODY <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> EXIT BODY: body modifier <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> COND EXIT:</code> </pre> <br>  Tentu saja, terjemahan seperti itu tidak spesifik untuk Dentang, setiap kompiler C dan C ++ melakukan hal yang sama. <br><br>  Dalam contoh kami, penginisialisasi loop runtuh ke dalam blok basis input.  Unit dasar berikut adalah pemeriksaan kondisi loop: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.cond: ; preds = %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.inc, %entry %<span class="hljs-number"><span class="hljs-number">0</span></span> = load i32, i32* %i, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">1</span></span> = load i32, i32* %n.addr, align <span class="hljs-number"><span class="hljs-number">4</span></span> %sub = sub nsw i32 %<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> %cmp = icmp slt i32 %<span class="hljs-number"><span class="hljs-number">0</span></span>, %sub br i1 %cmp, label %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.body, label %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.end</code> </pre> <br>  Dentang juga membuat komentar yang berguna bahwa blok dasar ini dapat dicapai baik dari for.inc atau dari blok basis input.  Blok ini memuat i dan n dari memori, mengurangi n (bendera nsw mencerminkan properti bahasa C yang sign overflow tidak didefinisikan; tanpa flag ini LLVM menggunakan semantik kode tambahan), membandingkan nilai yang dikurangi dengan saya menggunakan slt (ditandatangani kurang dari, tandatangani kurang dari) dan akhirnya cabang ke pangkalan untuk blok .body atau blok. <br><br>  Pintu masuk ke badan loop hanya dimungkinkan dari blok for.cond: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.body: %<span class="hljs-number"><span class="hljs-number">2</span></span> = load i32*, i32** %a.addr, align <span class="hljs-number"><span class="hljs-number">8</span></span> %<span class="hljs-number"><span class="hljs-number">3</span></span> = load i32, i32* %i, align <span class="hljs-number"><span class="hljs-number">4</span></span> %idxprom = sext i32 %<span class="hljs-number"><span class="hljs-number">3</span></span> to i64 %arrayidx = getelementptr inbounds i32, i32* %<span class="hljs-number"><span class="hljs-number">2</span></span>, i64 %idxprom %<span class="hljs-number"><span class="hljs-number">4</span></span> = load i32, i32* %arrayidx, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">5</span></span> = load i32*, i32** %a.addr, align <span class="hljs-number"><span class="hljs-number">8</span></span> %<span class="hljs-number"><span class="hljs-number">6</span></span> = load i32, i32* %i, align <span class="hljs-number"><span class="hljs-number">4</span></span> %add = add nsw i32 %<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> %idxprom1 = sext i32 %add to i64 %arrayidx2 = getelementptr inbounds i32, i32* %<span class="hljs-number"><span class="hljs-number">5</span></span>, i64 %idxprom1 %<span class="hljs-number"><span class="hljs-number">7</span></span> = load i32, i32* %arrayidx2, align <span class="hljs-number"><span class="hljs-number">4</span></span> %cmp3 = icmp sgt i32 %<span class="hljs-number"><span class="hljs-number">4</span></span>, %<span class="hljs-number"><span class="hljs-number">7</span></span> br i1 %cmp3, label %<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>.then, label %<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>.end</code> </pre> <br>  Dua baris pertama memuat a dan i di register SSA;  saya kemudian mengembang menjadi 64 bit dan dapat mengambil bagian dalam menghitung alamat.  Perintah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">getelementptr</a> (atau gep disingkat) adalah perintah LLVM yang dikenal karena pretensinya, bahkan memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian bantuannya</a> sendiri.  Tidak seperti bahasa mesin, LLVM tidak memperlakukan pointer sebagai bilangan bulat.  Ini memfasilitasi analisis alias dan optimisasi memori lainnya.  Kode ini memuat [i] dan [i +1], membandingkannya dan melakukan percabangan tergantung pada hasilnya. <br><br>  Blok if.then menyimpan 0 ke slot stack untuk nilai kembali fungsi dan tanpa syarat melompat ke blok output fungsi: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>.then: store i1 <span class="hljs-literal"><span class="hljs-literal">false</span></span>, i1* %retval, align <span class="hljs-number"><span class="hljs-number">1</span></span> br label %<span class="hljs-keyword"><span class="hljs-keyword">return</span></span></code> </pre> <br>  Blok lain sepele: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>.end: br label %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.inc</code> </pre> <br>  Dan blok untuk menambahkan satu ke variabel loop juga sangat sederhana: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.inc: %<span class="hljs-number"><span class="hljs-number">8</span></span> = load i32, i32* %i, align <span class="hljs-number"><span class="hljs-number">4</span></span> %inc = add nsw i32 %<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> store i32 %inc, i32* %i, align <span class="hljs-number"><span class="hljs-number">4</span></span> br label %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.cond</code> </pre> <br>  Kode ini melompat kembali untuk memeriksa kondisi loop. <br><br>  Jika loop selesai secara normal, kami mengembalikan true: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.end: store i1 <span class="hljs-literal"><span class="hljs-literal">true</span></span>, i1* %retval, align <span class="hljs-number"><span class="hljs-number">1</span></span> br label %<span class="hljs-keyword"><span class="hljs-keyword">return</span></span></code> </pre> <br>  Dan akhirnya, apa yang kita muat ke dalam slot stack dari nilai yang dikembalikan dimuat dan dikembalikan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span>: %<span class="hljs-number"><span class="hljs-number">9</span></span> = load i1, i1* %retval, align <span class="hljs-number"><span class="hljs-number">1</span></span> ret i1 %<span class="hljs-number"><span class="hljs-number">9</span></span></code> </pre> <br>  Tidak ada yang istimewa di akhir fungsi.  Posnya ternyata lebih panjang dari yang saya kira, di pos berikutnya kita akan mempertimbangkan untuk mengoptimalkan level IR untuk fungsi ini. <br><br>  (Terima kasih kepada Xi Wang dan Alex Rosenberg untuk koreksi yang dikirim) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id431688/">https://habr.com/ru/post/id431688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id431674/index.html">Kanvas Nanoleaf: Soon On All Walls</a></li>
<li><a href="../id431676/index.html">Robot Tactful: dapat mendengarkan dan tidak mengganggu</a></li>
<li><a href="../id431678/index.html">Ada pengembang seluler di hutan, melihat - Kotlin terbakar. Dia duduk di Kotlin dan terbakar</a></li>
<li><a href="../id431682/index.html">Marriott membocorkan data pribadi 500 juta pelanggan</a></li>
<li><a href="../id431686/index.html">Kecuali IoT: Mirai botnet meluncurkan serangan pada mesin Linux</a></li>
<li><a href="../id431690/index.html">Memecahkan crackme dari Kaspersky Lab</a></li>
<li><a href="../id431692/index.html">Kemajuan dalam imunoterapi dalam pengobatan multiple sclerosis</a></li>
<li><a href="../id431694/index.html">Sortir "Menara Hanoi"</a></li>
<li><a href="../id431696/index.html">Kodein. Dasar-dasarnya</a></li>
<li><a href="../id431698/index.html">Analisis pertanyaan di stand hh.ru di # HolyJS18</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>