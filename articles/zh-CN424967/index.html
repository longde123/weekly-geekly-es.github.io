<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🎤 ⚡️ 🔮 面向初学者的JavaScript快捷方式 ↗️ 👦🏿 🎅🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="闭包是JavaScript的基本概念之一，给许多初学者带来了麻烦，这是每个JS程序员都应该了解和理解的。 对闭包有一个很好的了解，您可以编写更好，更有效和更干净的代码。 反过来，这将有助于您的专业发展。 

 该材料（我们今天出版的翻译）专门介绍闭包的内部机制及其在JavaScript程序中的工作原...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>面向初学者的JavaScript快捷方式</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424967/"> 闭包是JavaScript的基本概念之一，给许多初学者带来了麻烦，这是每个JS程序员都应该了解和理解的。 对闭包有一个很好的了解，您可以编写更好，更有效和更干净的代码。 反过来，这将有助于您的专业发展。 <br><br> 该材料（我们今天出版的翻译）专门介绍闭包的内部机制及其在JavaScript程序中的工作原理。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/652/808/540/652808540f60e3a5f1b4b255fe90337a.png"></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">什么是封包？</font> </h2><br> 闭包是一种功能，即使该外部功能已完成其工作，也可以访问由外部功能相对于它形成的作用域。 这意味着闭包可以存储在外部函数中声明的变量以及传递给它的参数。 实际上，在进行闭包之前，我们将处理“词汇环境”的概念。 <br><br><h2>  <font color="#3AC1EF">什么是词汇环境？</font> </h2><br>  JavaScript中的术语“词汇环境”或“静态环境”是指根据变量，函数和对象在源代码中的物理位置来访问它们的能力。 考虑一个例子： <br><br><pre><code class="hljs pgsql">let a = <span class="hljs-string"><span class="hljs-string">'global'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>() {    let b = <span class="hljs-string"><span class="hljs-string">'outer'</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span>() {      let c = <span class="hljs-string"><span class="hljs-string">'inner'</span></span>      console.log(c);   // <span class="hljs-string"><span class="hljs-string">'inner'</span></span>      console.log(b);   // <span class="hljs-string"><span class="hljs-string">'outer'</span></span>      console.log(a);   // <span class="hljs-string"><span class="hljs-string">'global'</span></span>    }    console.log(a);     // <span class="hljs-string"><span class="hljs-string">'global'</span></span>    console.log(b);     // <span class="hljs-string"><span class="hljs-string">'outer'</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span>();  } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>(); console.log(a);         // <span class="hljs-string"><span class="hljs-string">'global'</span></span></code> </pre> <br> 在此， <code>inner()</code>函数可以访问在其自己的作用域， <code>outer()</code>函数的作用域和全局作用域中声明的变量。  <code>outer()</code>函数可以访问在其自己的作用域和全局作用域中声明的变量。 <br><br> 上面代码的作用域链如下所示： <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Global</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> } }</code> </pre> <br> 请注意， <code>inner()</code>函数被<code>inner()</code>函数的词法环境包围，而后者又被全局作用域包围。 这就是为什么<code>inner()</code>函数可以访问在<code>outer()</code>函数和全局范围中声明的变量的原因。 <br><br><h2>  <font color="#3AC1EF">闭包的实际例子</font> </h2><br> 在拆解内部电路的复杂性之前，请考虑一些实际示例。 <br><br><h3>  <font color="#3AC1EF">▍示例1</font> </h3><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">'Peter'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">displayName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name); }; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> peter = person(); peter(); <span class="hljs-comment"><span class="hljs-comment">// 'Peter'</span></span></code> </pre> <br> 在这里，我们调用<code>person()</code>函数，该函数返回内部函数<code>displayName()</code> ，并将此函数存储在变量<code>peter</code> 。 此后，当我们调用<code>peter()</code>函数（相应的变量实际上存储对<code>displayName()</code>函数的引用）时，名称<code>Peter</code>将显示在控制台中。 <br><br> 同时， <code>displayName()</code>函数没有名为<code>name</code>的变量，因此我们可以得出结论，该函数可以以某种方式访问​​在其外部函数<code>person()</code>声明的变量，即使之后该功能如何工作。 也许是因为<code>displayName()</code>函数实际上是一个闭包。 <br><br><h3>  <font color="#3AC1EF">▍示例2</font> </h3><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter++; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count = getCounter(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(count());  <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(count());  // 1 console.log(count());  // 2</span></span></code> </pre> <br> 在这里，与前面的示例一样，我们将指向<code>getCounter()</code>函数返回的匿名内部函数的链接存储在变量<code>count</code> 。 由于<code>count()</code>函数是一个闭包，因此即使在<code>getCounter()</code>函数完成其工作之后，它也可以访问<code>getCount()</code>函数的<code>counter</code>变量。 <br><br> 请注意，每次调用<code>count()</code>函数时， <code>counter</code>变量的值都不会重置为0。 似乎应该将其重置为0，就像调用常规函数时那样，但这不会发生。 <br><br> 就像这样工作，因为每次调用<code>count()</code>函数时，都会为其创建一个新的作用域，但是<code>getCounter()</code>函数只有一个作用域。 由于<code>counter</code>变量是在<code>getCounter()</code>函数的范围内声明的，因此在调用<code>count()</code>函数之间的值将被保存，而不会重置为0。 <br><br><h2>  <font color="#3AC1EF">短路如何工作？</font> </h2><br> 到目前为止，我们已经讨论了什么是闭包，并研究了实际示例。 现在，让我们讨论使它们起作用的内部JavaScript机制。 <br><br> 为了理解闭包，我们需要处理两个关键的JavaScript概念。 这是执行上下文和词汇环境。 <br><br><h3>  <font color="#3AC1EF">context执行上下文</font> </h3><br> 执行上下文是一个抽象环境，在其中计算和执行JavaScript代码。 当执行全局代码时，这会在全局执行上下文中发生。 功能代码在功能的上下文中执行。 <br><br> 在某个时间点，代码只能在一种执行上下文中执行（JavaScript是一种单线程编程语言）。 这些过程使用所谓的调用堆栈进行管理。 <br><br> 调用堆栈是根据LIFO原理（后进先出-后进先出）排列的数据结构。 新元素只能放置在堆栈的顶部，并且只能从其中删除元素。 <br><br> 当前执行上下文将始终位于堆栈的顶部，并且当当前函数退出时，其执行上下文将从堆栈中拉出，控制权将转移到执行上下文，该执行上下文位于调用堆栈中该函数的上下文下方。 <br><br> 考虑以下示例，以更好地了解执行上下文和调用堆栈是什么： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e23/04d/ef3/e2304def39694bb52330011b2f0fa4af.png"></div><br>  <i><font color="#999999">执行上下文示例</font></i> <br><br> 执行此代码时，JavaScript引擎将创建用于执行全局代码的全局执行上下文，并且在遇到对<code>first()</code>函数的调用时，会为此函数创建一个新的执行上下文并将其放置在堆栈的顶部。 <br><br> 此代码的调用堆栈如下所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/612/86c/7d2/61286c7d24769fa8df93b030e4d98c6b.png"></div><br>  <i><font color="#999999">调用堆栈</font></i> <br><br> 当<code>first()</code>函数的执行完成时，将从调用堆栈中检索其执行上下文，并将控制权转移到它下面的执行上下文，即全局上下文。 之后，将执行保留在全局范围内的代码。 <br><br><h3>  <font color="#3AC1EF">▍词汇环境</font> </h3><br> 每次JS引擎创建用于执行函数或全局代码的执行上下文时，它还会创建一个新的词法环境，用于存储在函数执行期间在该函数中声明的变量。 <br><br> 词汇环境是一种数据结构，用于存储有关标识符和变量的对应关系的信息。 在此，“标识符”是变量或函数的名称，“变量”是对对象（包括函数）的引用或原始类型的值。 <br><br> 词汇环境包含两个组件： <br><br><ul><li> 环境记录是存储变量和函数声明的位置。 </li><li> 对外部环境的引用-允许您访问外部（父）词法环境的链接。 这是为了了解闭包需要处理的最重要的组件。 </li></ul><br> 从概念上讲，词汇环境如下所示： <br><br><pre> <code class="hljs xml">lexicalEnvironment = { environmentRecord: {   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">identifier</span></span></span><span class="hljs-tag">&gt;</span></span> : <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>,   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">identifier</span></span></span><span class="hljs-tag">&gt;</span></span> : <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> } outer: <span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Reference</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">to</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">the</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">parent</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">lexical</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">environment</span></span></span><span class="hljs-tag">&gt;</span></span> }</code> </pre> <br> 看一下以下代码片段： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">first</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-number"><span class="hljs-number">25</span></span>;  <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Inside first function'</span></span>); } first(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Inside global execution context'</span></span>);</code> </pre> <br> 当JS引擎创建用于执行全局代码的全局执行上下文时，它还会创建一个新的词法环境，用于存储在全局范围内声明的变量和函数。 结果，全局范围的词法环境将如下所示： <br><br><pre> <code class="hljs pgsql">globalLexicalEnvironment = { environmentRecord: {     a : <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>,     first : &lt; reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> &gt; } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> }</code> </pre> <br> 请注意，由于全局作用域没有外部词汇环境，因此对外部词汇环境（external）的引用设置为<code>null</code> 。 <br><br> 当引擎为<code>first()</code>函数创建执行上下文时，它还会创建一个词法环境来存储在该函数执行期间在该函数中声明的变量。 结果，该函数的词法环境将如下所示： <br><br><pre> <code class="hljs pgsql">functionLexicalEnvironment = { environmentRecord: {     b : <span class="hljs-number"><span class="hljs-number">25</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;globalLexicalEnvironment&gt; }</code> </pre> <br> 到函数的外部词法环境的链接设置为<code>&lt;globalLexicalEnvironment&gt;</code> ，因为在源代码中，函数代码在全局范围内。 <br><br> 请注意，函数完成工作后，将从调用堆栈中检索其执行上下文，但是其词法环境可能会从内存中删除，或者可能保留在内存中。 这取决于在其他词汇环境中是否以链接到外部词汇环境的形式引用此词汇环境。 <br><br><h2>  <font color="#3AC1EF">有关使用闭包的示例的详细分析</font> </h2><br> 现在，我们已经掌握了执行上下文和词汇环境的知识，我们将返回到闭包并更深入地分析已经检查过的相同代码片段。 <br><br><h3>  <font color="#3AC1EF">▍示例1</font> </h3><br> 看一下以下代码片段： <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">'Peter'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">displayName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name); }; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> peter = person(); peter(); <span class="hljs-comment"><span class="hljs-comment">// 'Peter'</span></span></code> </pre> <br> 当执行<code>person()</code>函数时，JS引擎为此函数创建一个新的执行上下文和一个新的词法环境。 完成工作后，该函数返回<code>displayName()</code>函数，对该函数的引用被写入变量<code>peter</code> 。 <br><br> 她的词汇环境将如下所示： <br><br><pre> <code class="hljs powershell">personLexicalEnvironment = { environmentRecord: {   name : <span class="hljs-string"><span class="hljs-string">'Peter'</span></span>,   displayName: &lt; displayName <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reference</span></span></span><span class="hljs-function">&gt; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">outer</span></span></span><span class="hljs-function">: &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">globalLexicalEnvironment</span></span></span><span class="hljs-function">&gt; }</span></span></code> </pre> <br> 当<code>person()</code>函数退出时，其执行上下文将从堆栈中弹出。 但是它的词法环境仍保留在内存中，因为在其内部函数<code>displayName()</code>的词法环境中有指向它的链接。 结果，在此词法环境中声明的变量仍然可用。 <br><br> 当调用<code>peter()</code>函数（相应的变量存储对<code>displayName()</code>函数的引用）时，JS引擎为此函数创建新的执行上下文和新的词法环境。 这个词汇环境如下所示： <br><br><pre> <code class="hljs pgsql">displayNameLexicalEnvironment = { environmentRecord: {   } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;personLexicalEnvironment&gt; }</code> </pre> <br>  <code>displayName()</code>函数中没有变量，因此其环境记录将为空。 在执行此函数期间，JS引擎将尝试在该函数的词法环境中查找<code>name</code>变量。 <br><br> 由于无法在<code>displayName()</code>函数的词法环境中找到搜索，因此搜索将在外部词法环境（即仍在内存中的<code>person()</code>函数的词法环境<code>person()</code>中继续进行。 引擎在那里找到所需的变量，并在控制台中显示其值。 <br><br><h3>  <font color="#3AC1EF">▍示例2</font> </h3><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter++; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count = getCounter(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(count());  <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(count());  // 1 console.log(count());  // 2</span></span></code> </pre> <br>  <code>getCounter()</code>函数的词法环境如下所示： <br><br><pre> <code class="hljs pgsql">getCounterLexicalEnvironment = { environmentRecord: {   counter: <span class="hljs-number"><span class="hljs-number">0</span></span>,   &lt;anonymous <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>&gt; : &lt; reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>&gt; } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;globalLexicalEnvironment&gt; }</code> </pre> <br> 该函数返回分配给<code>count</code>变量的匿名函数。 <br><br> 当执行<code>count()</code>函数时，其词法环境如下所示： <br><br><pre> <code class="hljs pgsql">countLexicalEnvironment = { environmentRecord: { } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;getCountLexicalEnvironment&gt; }</code> </pre> <br> 执行此功能时，系统将在其词法环境中查找<code>counter</code>变量。 同样，在这种情况下，函数环境记录为空，因此将在函数的外部词法环境中继续搜索变量。 <br><br> 引擎找到该变量，将其显示在控制台中，然后增加<code>counter</code>变量，该<code>counter</code>变量存储在<code>getCounter()</code>函数的词法环境中。 <br><br> 结果，在第一次调用<code>count()</code>函数之后， <code>getCounter()</code>函数的词法环境将如下所示： <br><br><pre> <code class="hljs pgsql">getCounterLexicalEnvironment = { environmentRecord: {   counter: <span class="hljs-number"><span class="hljs-number">1</span></span>,   &lt;anonymous <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>&gt; : &lt; reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>&gt; } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;globalLexicalEnvironment&gt; }</code> </pre> <br> 每次调用<code>count()</code>函数时，JavaScript引擎都会为此函数创建一个新的词汇环境，并递增<code>counter</code>变量，这将导致<code>getCounter()</code>函数的词汇环境发生变化。 <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 在本文中，我们讨论了闭包是什么，并整理了闭包所基于的底层JavaScript机制。 闭包是最重要的JavaScript基本概念之一，每个JS开发人员都应该理解它们。 了解闭包是编写有效和高质量应用程序的步骤之一。 <br><br>  <b>亲爱的读者们！</b> 如果您有JS开发经验，请与初学者分享使用闭包的实际示例。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN424967/">https://habr.com/ru/post/zh-CN424967/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN424955/index.html">上周第332期来自前端世界的新鲜材料摘要（2018年9月24日至30日）</a></li>
<li><a href="../zh-CN424957/index.html">使用AttnGAN从文本生成图像</a></li>
<li><a href="../zh-CN424961/index.html">MTA-STS for Postfix</a></li>
<li><a href="../zh-CN424963/index.html">扎克伯格资助：共同构建科学工具</a></li>
<li><a href="../zh-CN424965/index.html">使用ReasonReact进行应用程序开发</a></li>
<li><a href="../zh-CN424969/index.html">Node.js指南，第9部分：使用文件系统</a></li>
<li><a href="../zh-CN424971/index.html">Habrokast“手动日落”＃1。 尝试建立用于开发Windows玩具的环境</a></li>
<li><a href="../zh-CN424973/index.html">视频的人脸检测：Raspberry Pi和神经计算棒</a></li>
<li><a href="../zh-CN424975/index.html">SIEM深度：现成的相关性。 第2部分。数据模式反映“世界”模型</a></li>
<li><a href="../zh-CN424977/index.html">从错误中学习：优化App Store和Google Play上的应用程序</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>