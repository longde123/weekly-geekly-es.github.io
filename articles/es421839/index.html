<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👲 🐵 👧🏻 Programación funcional de Java con Vavr 🚢 🙋🏿 👲🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Muchos han oído hablar de lenguajes funcionales como Haskell y Clojure. Pero hay idiomas como Scala, por ejemplo. Combina OOP y un enfoque funcional. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programación funcional de Java con Vavr</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421839/">  Muchos han oído hablar de lenguajes funcionales como Haskell y Clojure.  Pero hay idiomas como Scala, por ejemplo.  Combina OOP y un enfoque funcional.  ¿Qué pasa con el buen viejo Java?  ¿Es posible escribir programas en un estilo funcional y cuánto puede doler?  Sí, hay Java 8 y lambdas con secuencias.  Este es un gran paso para el idioma, pero aún no es suficiente.  ¿Es posible llegar a algo en esta situación?  Resulta que si. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u2/tp/cr/u2tpcrdrjmcmw9yvj9ptnbsuiwo.jpeg"></div><br><a name="habracut"></a><br>  Para comenzar, tratemos de determinar qué significa la escritura de código en un estilo funcional.  Primero, debemos operar no con variables y manipulaciones con ellas, sino con cadenas de algunos cálculos.  En esencia, una secuencia de funciones.  Además, debemos tener estructuras de datos especiales.  Por ejemplo, las colecciones estándar de Java no son adecuadas.  Pronto quedará claro por qué. <br><br>  Consideremos las estructuras funcionales con más detalle.  Cualquier estructura de este tipo debe satisfacer al menos dos condiciones: <br><br><ul><li>  <b><i>inmutable</i></b> : la estructura debe ser inmutable.  Esto significa que arreglamos el estado del objeto en la etapa de creación y lo dejamos como tal hasta el final de su existencia.  Un claro ejemplo de violación de una condición: ArrayList estándar. </li><li>  <b>persistente</b> : la estructura debe almacenarse en la memoria el mayor tiempo posible.  Si creamos algún objeto, en lugar de crear uno nuevo con el mismo estado, deberíamos usar el listo.  Más formalmente, tales estructuras retienen todos sus estados anteriores tras la modificación.  Las referencias a estas condiciones deben permanecer completamente operativas. </li></ul><br>  Obviamente, necesitamos algún tipo de solución de terceros.  Y existe tal solución: la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Vavr</a> .  Hoy es la biblioteca <i>Java</i> más popular para trabajar en un estilo funcional.  A continuación, describiré las características principales de la biblioteca.  Muchos, pero no todos, ejemplos y descripciones fueron tomados de la documentación oficial. <br><br><h2>  Las principales estructuras de datos de la biblioteca <b>vavr</b> </h2><br><h3>  Tupla </h3><br>  Una de las estructuras de datos funcionales más básicas y simples son las tuplas.  Una tupla es un conjunto ordenado de longitud fija.  A diferencia de las listas, una tupla puede contener datos de cualquier tipo. <br><br><pre><code class="java hljs">Tuple tuple = Tuple.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"blablabla"</span></span>, .<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">42L</span></span>); <span class="hljs-comment"><span class="hljs-comment">// (1, blablabla, 0.0, 42)</span></span></code> </pre> <br>  Obtener el artículo deseado proviene de llamar al campo con el número de artículo en la tupla. <br><br><pre> <code class="java hljs">((Tuple4) tuple)._1 <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre> <br>  Tenga en cuenta: ¡la indexación de tuplas comienza en 1!  Además, para obtener el elemento deseado, debemos convertir nuestro objeto al tipo deseado con el conjunto apropiado de métodos.  En el ejemplo anterior, usamos una tupla de 4 elementos, lo que significa que la conversión debe ser del tipo <i>Tuple4</i> .  De hecho, nadie nos impide hacer inicialmente el tipo correcto. <br><br><pre> <code class="java hljs">Tuple4 tuple = Tuple.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"blablabla"</span></span>, .<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">42L</span></span>); <span class="hljs-comment"><span class="hljs-comment">// (1, blablabla, 0.0, 42) System.out.println(tuple._1); // 1</span></span></code> </pre> <br><h3>  Las 3 mejores colecciones de vavr </h3><br><h4>  Lista </h4><br>  Crear una lista con vavr es muy simple.  Incluso más fácil que sin <i>vavr</i> . <br><br><pre> <code class="java hljs">List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br>  ¿Qué podemos hacer con tal lista?  Bueno, en primer lugar, podemos convertirlo en una lista estándar de <i>Java</i> . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> containThree = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) .asJava() .stream() .anyMatch(x -&gt; x == <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre><br>  Pero, de hecho, esto no es muy necesario, porque  podemos hacer, por ejemplo, así: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> containThree = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) .find(x -&gt; x == <span class="hljs-number"><span class="hljs-number">1</span></span>) .isDefined();</code> </pre> <br>  En general, la <i>lista de</i> bibliotecas <i>vavr</i> estándar tiene muchos métodos útiles.  Por ejemplo, hay una función de convolución bastante poderosa que le permite combinar una lista de valores por alguna regla y un elemento neutral. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   final int zero = 0; //   final BiFunction&lt;Integer, Integer, Integer&gt; combine = (x, y) -&gt; x + y; //   final int sum = List.of(1, 2, 3) .fold(zero, combine); //  </span></span></code> </pre> <br>  Un punto importante debe señalarse aquí.  Tenemos estructuras de datos funcionales, lo que significa que no podemos cambiar su estado.  ¿Cómo se implementa nuestra lista?  Las matrices simplemente no nos convienen. <br><br>  <b>Lista vinculada como la lista predeterminada</b> <br><br>  Hagamos una lista simplemente vinculada con objetos inmutables.  Se verá más o menos así: <br><br><img src="https://habrastorage.org/webt/lr/4p/xn/lr4pxnezcvipnsgaownffgw6ewq.png" alt="imagen"><br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de código</b> <div class="spoiler_text"><pre> <code class="java hljs">List list = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br></div></div><br>  Cada elemento de la lista tiene dos métodos principales: obtener el elemento head (head) y todos los demás (tail). <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de código</b> <div class="spoiler_text"><pre> <code class="java hljs">list.head(); <span class="hljs-comment"><span class="hljs-comment">// 1 list.tail(); // List(2, 3)</span></span></code> </pre> <br></div></div><br>  Ahora, si queremos cambiar el primer elemento de la lista (de 1 a 0), entonces necesitamos crear una nueva lista con la reutilización de las partes terminadas. <br><br><img src="https://habrastorage.org/webt/hu/xc/lp/huxclpxqlaunelfqyqu259ayj9o.png" alt="imagen"><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de código</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List tailList = list.tail(); <span class="hljs-comment"><span class="hljs-comment">//    tailList.prepend(0); //     </span></span></code> </pre> <br></div></div><br>  ¡Y eso es todo!  Dado que nuestros objetos en la hoja de trabajo son inmutables, obtenemos una colección reutilizable y segura para subprocesos.  ¡Los elementos de nuestra lista se pueden aplicar en cualquier lugar de la aplicación y es completamente seguro! <br><br><h4>  Cola </h4><br>  Otra estructura de datos extremadamente útil es la cola.  ¿Cómo hacer una cola para construir programas efectivos y confiables en un estilo funcional?  Por ejemplo, podemos tomar estructuras de datos que ya conocemos: dos listas y una tupla. <br><br><img src="https://habrastorage.org/webt/bi/bp/sb/bibpsbx_odpxx2kdupxg0l4ufku.png" alt="imagen"><br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de código</b> <div class="spoiler_text"><pre> <code class="java hljs">Queue&lt;Integer&gt; queue = Queue.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) .enqueue(<span class="hljs-number"><span class="hljs-number">4</span></span>) .enqueue(<span class="hljs-number"><span class="hljs-number">5</span></span>);</code> </pre> <br></div></div><br>  Cuando termina el primero, expandimos el segundo y lo usamos para leer. <br><br><img src="https://habrastorage.org/webt/b5/ho/zz/b5hozzqnmnm8fyhoebj3g3d7c_0.png" alt="imagen"><br><br><img src="https://habrastorage.org/webt/ld/_e/ly/ld_ely_1i5buzwbadpirjf0f1gc.png" alt="imagen"><br><br>  Es importante recordar que la cola no debe cambiar, como todas las demás estructuras.  Pero, ¿de qué sirve una cola que no cambia?  De hecho, hay un truco.  Como valor aceptado de la cola, obtenemos una tupla de dos elementos.  Primero: el elemento de cola deseado, segundo: lo que sucedió a la cola sin este elemento. <br><br><pre> <code class="java hljs">System.out.println(queue); <span class="hljs-comment"><span class="hljs-comment">// Queue(1, 2, 3, 4, 5) Tuple2&lt;Integer, Queue&lt;Integer&gt;&gt; tuple2 = queue.dequeue(); System.out.println(tuple2._1); // 1 System.out.println(tuple2._2); // Queue(2, 3, 4, 5)</span></span></code> </pre> <br><h4>  Corrientes </h4><br>  La siguiente estructura de datos importante es la secuencia.  Una secuencia es una secuencia de ejecución de algunas acciones en un determinado conjunto de valores, a menudo abstracto. <br><br>  Alguien puede decir que <i>Java 8</i> ya tiene transmisiones completas y que no necesitamos nuevas.  Es asi? <br><br>  Para comenzar, asegurémonos de que <i>Java Stream</i> no sea una estructura de datos funcional.  Verifique la estructura de mutabilidad.  Para hacer esto, cree una secuencia tan pequeña: <br><pre> <code class="java hljs">IntStream standardStream = IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre> <br>  Ordenaremos todos los elementos en la secuencia: <br><br><pre> <code class="java hljs">standardStream.forEach(System.out::print);</code> </pre> <br>  En respuesta, obtenemos la salida a la consola: <i>123456789</i> .  Repitamos la operación de fuerza bruta: <br><br><pre> <code class="java hljs">standardStream.forEach(System.out::print);</code> </pre> <br>  Vaya, se produjo el siguiente error: <br><br><pre> <code class="java hljs">java.lang.IllegalStateException: stream has already been operated upon or closed</code> </pre><br>  El hecho es que las transmisiones estándar son solo una especie de abstracción sobre un iterador.  Aunque las transmisiones externas parecen extremadamente independientes y poderosas, las desventajas de los iteradores no han desaparecido. <br><br>  Por ejemplo, la definición de una secuencia no dice nada acerca de limitar el número de elementos.  Desafortunadamente, existe en el iterador, lo que significa que está en secuencias estándar. <br><br>  Afortunadamente, la biblioteca vavr resuelve estos problemas.  Asegúrate de esto: <br><br><pre> <code class="java hljs">Stream stream = Stream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); stream.forEach(System.out::print); stream.forEach(System.out::print);</code> </pre> <br>  En respuesta, obtenemos <i>123456789123456789</i> .  Lo que significa que la primera operación no "estropeó" nuestra transmisión. <br><br>  Intentemos crear una secuencia interminable: <br><br>  Stream infiniteStream = Stream.from (1); <br>  System.out.println (infiniteStream);  // Stream (1 ,?) <br><br>  Tenga en cuenta: al imprimir un objeto, no obtenemos una estructura infinita, sino el primer elemento y el signo de interrogación.  El hecho es que cada elemento posterior en la secuencia se genera sobre la marcha.  Este enfoque se llama inicialización perezosa.  Es él quien le permite trabajar con seguridad con tales estructuras. <br><br>  Si nunca ha trabajado con estructuras de datos infinitas, lo más probable es que esté pensando: ¿por qué es esto necesario?  Pero pueden ser extremadamente convenientes.  Escribimos una secuencia que devuelve un número arbitrario de números impares, los convierte en una cadena y agrega un espacio: <br><br><pre> <code class="java hljs">Stream oddNumbers = Stream .from(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  1   2 .map(x -&gt; x + " "); //  //   oddNumbers.take(5) .forEach(System.out::print); // 1 3 5 7 9 oddNumbers.take(10) .forEach(System.out::print); // 1 3 5 7 9 11 13 15 17 19</span></span></code> </pre> <br>  Tan simple <br><br><h3>  Estructura general de colecciones. </h3><br>  Después de discutir las estructuras básicas, es hora de mirar la arquitectura general de las <i>colecciones</i> funcionales <i>vavr</i> : <br><br><img src="https://habrastorage.org/webt/m2/ae/wl/m2aewlwyky8-r-dktx1asgvxqgy.png"><br><br>  Cada elemento de la estructura se puede usar como iterable: <br><br><pre> <code class="java hljs">StringBuilder builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String word : List.of(<span class="hljs-string"><span class="hljs-string">"one"</span></span>, <span class="hljs-string"><span class="hljs-string">"two"</span></span>, <span class="hljs-string"><span class="hljs-string">"tree"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (builder.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { builder.append(<span class="hljs-string"><span class="hljs-string">", "</span></span>); } builder.append(word); } System.out.println(builder.toString()); <span class="hljs-comment"><span class="hljs-comment">// one, two, tree</span></span></code> </pre> <br>  Pero debes pensarlo dos veces y ver el muelle antes de usarlo.  La biblioteca le permite facilitar las cosas familiares. <br><br><pre> <code class="java hljs">System.out.println(List.of(<span class="hljs-string"><span class="hljs-string">"one"</span></span>, <span class="hljs-string"><span class="hljs-string">"two"</span></span>, <span class="hljs-string"><span class="hljs-string">"tree"</span></span>).mkString(<span class="hljs-string"><span class="hljs-string">", "</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// one, two, tree</span></span></code> </pre> <br><h2>  Trabajar con funciones </h2><br>  La biblioteca tiene varias funciones (8 piezas) y métodos útiles para trabajar con ellas.  Son interfaces funcionales ordinarias con muchos métodos interesantes.  El nombre de las funciones depende del número de argumentos aceptados (de 0 a 8).  Por ejemplo, <i>Function0</i> no toma argumentos, <i>Function1</i> toma un argumento, <i>Function2</i> toma dos, etc. <br><br><pre> <code class="java hljs">Function2&lt;String, String, String&gt; combineName = (lastName, firstName) -&gt; firstName + <span class="hljs-string"><span class="hljs-string">" "</span></span> + lastName; System.out.println(combineName.apply(<span class="hljs-string"><span class="hljs-string">"Griffin"</span></span>, <span class="hljs-string"><span class="hljs-string">"Peter"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// Peter Griffin</span></span></code> </pre> <br>  En las funciones de la biblioteca vavr, podemos hacer muchas cosas interesantes.  En términos de funcionalidad, van muy por delante de la función estándar, BiFunction, etc.  Por ejemplo, curry.  Curry es la construcción de funciones en partes.  Veamos un ejemplo: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    Function2&lt;String, String, String&gt; combineName = (lastName, firstName) -&gt; firstName + " " + lastName; //           Function1&lt;String, String&gt; makeGriffinName = combineName .curried() .apply("Griffin"); //      System.out.println(makeGriffinName.apply("Peter")); // Peter Griffin System.out.println(makeGriffinName.apply("Lois")); // Lois Griffin</span></span></code> </pre> <br>  Como puede ver, muy sucintamente.  El método <i>curry</i> es extremadamente simple, pero puede ser muy útil. <br><br><div class="spoiler">  <b class="spoiler_title">Implementación del método curry</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> Function1&lt;T1, Function1&lt;T2, R&gt;&gt; curried() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t1 -&gt; t2 -&gt; apply(t1, t2); }</code> </pre><br></div></div><br>  Hay muchos más métodos útiles en el conjunto de <i>funciones</i> .  Por ejemplo, puede almacenar en caché el resultado devuelto de una función: <br><br><pre> <code class="java hljs">Function0&lt;Double&gt; hashCache = Function0.of(Math::random).memoized(); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> randomValue1 = hashCache.apply(); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> randomValue2 = hashCache.apply(); System.out.println(randomValue1 == randomValue2); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br><br><h2>  Lucha contra las excepciones. </h2><br>  Como dijimos anteriormente, el proceso de programación debe ser seguro.  Para hacer esto, es necesario evitar varios efectos extraños.  Las excepciones son sus generadores explícitos. <br><br>  Puede usar la clase <i>Try</i> para manejar de manera segura las excepciones en un estilo funcional.  De hecho, esta es una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mónada</a> típica.  Para profundizar en la teoría del uso no es necesario.  Solo mira un ejemplo simple: <br><br><pre> <code class="java hljs">Try.of(() -&gt; <span class="hljs-number"><span class="hljs-number">4</span></span> / <span class="hljs-number"><span class="hljs-number">0</span></span>) .onFailure(System.out::println) .onSuccess(System.out::println);</code> </pre> <br>  Como puede ver en el ejemplo, todo es bastante simple.  Simplemente colgamos el evento en un error potencial y no lo llevamos más allá de los límites de la computación. <br><br><h2>  Coincidencia de patrones </h2><br>  A menudo surge una situación en la que necesitamos verificar el valor de una variable y modelar el comportamiento del programa dependiendo del resultado.  Solo en tales situaciones, un maravilloso motor de búsqueda de plantillas viene al rescate.  Ya no tiene que escribir un montón de, <i>si no</i> , simplemente configure toda la lógica en un solo lugar. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> io.vavr.API.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> io.vavr.Predicates.*; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PatternMatchingDemo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ String s = Match(<span class="hljs-number"><span class="hljs-number">1993</span></span>).of( Case($(<span class="hljs-number"><span class="hljs-number">42</span></span>), () -&gt; <span class="hljs-string"><span class="hljs-string">"one"</span></span>), Case($(anyOf(isIn(<span class="hljs-number"><span class="hljs-number">1990</span></span>, <span class="hljs-number"><span class="hljs-number">1991</span></span>, <span class="hljs-number"><span class="hljs-number">1992</span></span>), is(<span class="hljs-number"><span class="hljs-number">1993</span></span>))), <span class="hljs-string"><span class="hljs-string">"two"</span></span>), Case($(), <span class="hljs-string"><span class="hljs-string">"?"</span></span>) ); System.out.println(s); <span class="hljs-comment"><span class="hljs-comment">// two } }</span></span></code> </pre> <br>  Tenga en cuenta que mayúscula y minúscula  case es una palabra clave y ya está en uso. <br><br><h2>  Conclusión </h2><br>  En mi opinión, la biblioteca es muy buena, pero vale la pena usarla con mucho cuidado.  Ella puede hacerlo muy bien en el desarrollo <i>impulsado por eventos</i> .  Sin embargo, su uso excesivo e irreflexivo en la programación imperativa estándar basada en un grupo de subprocesos puede causar mucho dolor de cabeza.  Además, a menudo en nuestros proyectos usamos Spring e Hibernate, que no siempre están listos para tal aplicación.  Antes de importar una biblioteca a su proyecto, necesita una comprensión clara de cómo y por qué se utilizará.  De lo que hablaré en uno de mis próximos artículos. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es421839/">https://habr.com/ru/post/es421839/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es421827/index.html">¿Qué leer sobre Java en este momento?</a></li>
<li><a href="../es421829/index.html">La anomalía de Frango: un romance fantástico con personas reales de TI</a></li>
<li><a href="../es421833/index.html">Escribimos nuestro programa más simple para ARM Cortex-M3</a></li>
<li><a href="../es421835/index.html">La Comisión Interagencial desarrolla nueva tecnología para bloquear Telegram</a></li>
<li><a href="../es421837/index.html">Creación de 1k intro Chaos para ZX-Spectrum</a></li>
<li><a href="../es421841/index.html">Robotaxi Waymo no está listo para acceder a la vía pública</a></li>
<li><a href="../es421845/index.html">¿Qué hacen realmente los analistas de datos? Hallazgos de 35 entrevistas</a></li>
<li><a href="../es421847/index.html">Salta a la nube. Creación de una solución de IoT económica en NodeMCU + Azure IoT Hub</a></li>
<li><a href="../es421849/index.html">Eventos para RRHH en TI en septiembre de 2018: My Circle Digest</a></li>
<li><a href="../es421851/index.html">Problemas de búho y globo: conectando dos ensamblajes con espacios de nombres y nombres de clase idénticos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>