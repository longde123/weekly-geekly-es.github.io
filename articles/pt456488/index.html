<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçüç≥ üë∑üèº ü¶Ñ Registro r√°pido üà∫ üôÜüèª üé≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Neste artigo, coloquei benchmarks das chamadas mais privadas de loggers. Conduzi todos os experimentos no log4net e NLog, no Intel Windows 10 x64 com ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Registro r√°pido</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456488/"><p>  Neste artigo, coloquei benchmarks das chamadas mais privadas de loggers.  Conduzi todos os experimentos no log4net e NLog, no Intel Windows 10 x64 com SSD M.2. </p><br><p>  Os resultados brutos podem ser visualizados no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> .  O c√≥digo est√° no mesmo reposit√≥rio (√© necess√°rio o .Net 4.7.2 + Microsoft Visual Studio 2017+ para executar). </p><br><p>  O que, como e por qu√™ - sob o corte. </p><a name="habracut"></a><br><p>  Para n√£o ler por muito tempo, a tabela de resultados: </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Mean </th><th>  Erro </th><th>  Stddev </th></tr></thead><tbody><tr><td>  KeepFileOpen = true, ConcurrentWrites = false, Async = true </td><td>  1.144.677 ns </td><td>  26.3805 ns </td><td>  77.7835 ns </td></tr><tr><td>  KeepFileOpen = true, ConcurrentWrites = true, Ass√≠ncrono = true </td><td>  1.106.691 ns </td><td>  31.4041 ns </td><td>  87.5421 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = false, Ass√≠ncrono = true </td><td>  4.804.426 ns </td><td>  110.3406 ns </td><td>  103.2126 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = true, Ass√≠ncrono = true </td><td>  5.303,602 ns </td><td>  104,3022 ns </td><td>  102.4387 ns </td></tr><tr><td>  KeepFileOpen = true, ConcurrentWrites = false, Ass√≠ncrono = false </td><td>  5.642,301 ns </td><td>  73.2291 ns </td><td>  68.4986 ns </td></tr><tr><td>  KeepFileOpen = true, ConcurrentWrites = true, Ass√≠ncrono = false </td><td>  11.834.892 ns </td><td>  82,7578 ns </td><td>  77.4117 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = false, Ass√≠ncrono = false </td><td>  731.250.539 ns </td><td>  14.612.0117 ns </td><td>  27.444.8998 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = true, Ass√≠ncrono = false </td><td>  730.271.927 ns </td><td>  11.330.0172 ns </td><td>  10.598.1051 ns </td></tr><tr><td>  CreateLog4NetFromString </td><td>  1.470.662 ns </td><td>  19.9492 ns </td><td>  18.6605 ns </td></tr><tr><td>  CreateNLogFromString </td><td>  228.774 ns </td><td>  2.1315 ns </td><td>  1,8895 ns </td></tr><tr><td>  CreateLog4NetLogger </td><td>  21.046.294 ns </td><td>  284.1171 ns </td><td>  265.7633 ns </td></tr><tr><td>  CreateNLogTypeOfLogger </td><td>  164.487.931 ns </td><td>  3.240.4372 ns </td><td> 3.031.1070 ns </td></tr><tr><td>  CreateNLogDynamicLogger </td><td>  134.459.092 ns </td><td>  1.882,8663 ns </td><td>  1.761,2344 ns </td></tr><tr><td>  FileLoggingLog4NetNoParams </td><td>  8.251.032 ns </td><td>  109.3075 ns </td><td>  102.2463 ns </td></tr><tr><td>  FileLoggingLog4NetSingleReferenceParam </td><td>  8.260,445 ns </td><td>  145.9028 ns </td><td>  136.4776 ns </td></tr><tr><td>  FileLoggingLog4NetSingleValueParam </td><td>  8.378.693 ns </td><td>  121.3003 ns </td><td>  113.4643 ns </td></tr><tr><td>  FileLoggingLog4NetMultipleReferencesParam </td><td>  9.133.136 ns </td><td>  89.7420 ns </td><td>  79.5539 ns </td></tr><tr><td>  FileLoggingLog4NetMultipleValuesParam </td><td>  9.393.989 ns </td><td>  166.0347 ns </td><td>  155.3089 ns </td></tr><tr><td>  FileLoggingNLogNetNoParams </td><td>  6.061.837 ns </td><td>  69.5666 ns </td><td>  65.0726 ns </td></tr><tr><td>  FileLoggingNLogNetSingleReferenceParam </td><td>  6.458.201 ns </td><td>  94.5617 ns </td><td>  88,4530 ns </td></tr><tr><td>  FileLoggingNLogNetSingleValueParam </td><td>  6.460.859 ns </td><td>  95.5435 ns </td><td>  84.6969 ns </td></tr><tr><td>  FileLoggingNLogNetMultipleReferencesParam </td><td>  7.236.886 ns </td><td>  89.7334 ns </td><td>  83.9367 ns </td></tr><tr><td>  FileLoggingNLogNetMultipleValuesParam </td><td>  7.524.876 ns </td><td>  82.8979 ns </td><td>  77.5427 ns </td></tr><tr><td>  NoOpLog4NetNoParams </td><td>  12.684 ns </td><td>  0,0795 ns </td><td>  0,0743 ns </td></tr><tr><td>  NoOpLog4NetSingleReferenceParam </td><td>  10.506 ns </td><td>  0,0571 ns </td><td>  0,0506 ns </td></tr><tr><td>  NoOpLog4NetSingleValueParam </td><td>  12.608 ns </td><td>  0,1012 ns </td><td>  0,0946 ns </td></tr><tr><td>  NoOpLog4NetMultipleReferencesParam </td><td>  48.858 ns </td><td>  0,3988 ns </td><td>  0,3730 ns </td></tr><tr><td>  NoOpLog4NetMultipleValuesParam </td><td>  69.463 ns </td><td>  0,9444 ns </td><td>  0,8834 ns </td></tr><tr><td>  NoOpNLogNetNoParams </td><td>  2.073 ns </td><td>  0,0253 ns </td><td>  0,0225 ns </td></tr><tr><td>  NoOpNLogNetSingleReferenceParam </td><td>  2.625 ns </td><td>  0,0364 ns </td><td>  0,0340 ns </td></tr><tr><td>  NoOpNLogNetSingleValueParam </td><td>  2,281 ns </td><td>  0,0222 ns </td><td>  0,0208 ns </td></tr><tr><td>  NoOpNLogNetMultipleReferencesParam </td><td>  41.525 ns </td><td>  0,4481 ns </td><td>  0,4191 ns </td></tr><tr><td>  NoOpNLogNetMultipleValuesParam </td><td>  57,622 ns </td><td>  0,5341 ns </td><td>  0,4996 ns </td></tr></tbody></table></div><br><h1 id="nooplogging">  NoOpLogging </h1><br><p>  Primeiro, vamos estimar quanto gastamos tempo chamando um m√©todo para registro, o que no final n√£o levar√° a nada.  Na maioria dos casos (na minha experi√™ncia), o Debug detalhado est√° desativado nos servidores de batalha, no entanto, ningu√©m remove as chamadas. </p><br><p>  Primeiro, o resultado: </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Mean </th><th>  Erro </th><th>  Stddev </th></tr></thead><tbody><tr><td>  NoOpLog4NetNoParams </td><td>  12.684 ns </td><td>  0,0795 ns </td><td>  0,0743 ns </td></tr><tr><td>  NoOpLog4NetSingleReferenceParam </td><td>  10.506 ns </td><td>  0,0571 ns </td><td>  0,0506 ns </td></tr><tr><td>  NoOpLog4NetSingleValueParam </td><td>  12.608 ns </td><td>  0,1012 ns </td><td>  0,0946 ns </td></tr><tr><td>  NoOpLog4NetMultipleReferencesParam </td><td>  48.858 ns </td><td>  0,3988 ns </td><td>  0,3730 ns </td></tr><tr><td>  NoOpLog4NetMultipleValuesParam </td><td>  69.463 ns </td><td>  0,9444 ns </td><td>  0,8834 ns </td></tr><tr><td>  NoOpNLogNetNoParams </td><td>  2.073 ns </td><td>  0,0253 ns </td><td>  0,0225 ns </td></tr><tr><td>  NoOpNLogNetSingleReferenceParam </td><td>  2.625 ns </td><td>  0,0364 ns </td><td>  0,0340 ns </td></tr><tr><td>  NoOpNLogNetSingleValueParam </td><td>  2,281 ns </td><td>  0,0222 ns </td><td>  0,0208 ns </td></tr><tr><td>  NoOpNLogNetMultipleReferencesParam </td><td>  41.525 ns </td><td>  0,4481 ns </td><td>  0,4191 ns </td></tr><tr><td>  NoOpNLogNetMultipleValuesParam </td><td>  57,622 ns </td><td>  0,5341 ns </td><td>  0,4996 ns </td></tr></tbody></table></div><br><p>  E o c√≥digo: </p><br><pre><code class="plaintext hljs">void Log4NetNoParams() =&gt; _log4Net.Debug("test"); void Log4NetSingleReferenceParam() =&gt; _log4Net.DebugFormat("test {0}", _stringArgument); void Log4NetSingleValueParam() =&gt; _log4Net.DebugFormat("test {0}", _intArgument); void Log4NetMultipleReferencesParam() =&gt; _log4Net.DebugFormat( "test {0} {1} {2} {3} {4} {5} {6} {7} {8}", _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument); void Log4NetMultipleValuesParam() =&gt; _log4Net.DebugFormat( "test {0} {1} {2} {3} {4} {5} {6} {7} {8}", _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument); void NLogNetNoParams() =&gt; _nlog.Debug("test"); void NLogNetSingleReferenceParam() =&gt; _nlog.Debug("test {0}", _stringArgument); void NLogNetSingleValueParam() =&gt; _nlog.Debug("test {0}", _intArgument); void NLogNetMultipleReferencesParam() =&gt; _nlog.Debug( "test {0} {1} {2} {3} {4} {5} {6} {7} {8}", _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument); void NLogNetMultipleValuesParam() =&gt; _nlog.Debug( "test {0} {1} {2} {3} {4} {5} {6} {7} {8}", _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument);</code> </pre> <br><p>  Primeiro, vamos determinar por que esses testes foram escolhidos: </p><br><ul><li>  Os experimentos foram realizados nas bibliotecas mais populares. </li><li><p>  NLog e log4net t√™m assinaturas de fun√ß√µes diferentes para um pequeno n√∫mero de argumentos: </p><br><ul><li>  log4net: </li></ul><br><pre> <code class="plaintext hljs">void DebugFormat(string format, object arg0)</code> </pre> <br><ul><li>  Nlog: </li></ul><br><pre> <code class="plaintext hljs">void Debug(string message, string argument) void Debug&lt;TArgument&gt;(string message, TArgument argument)</code> </pre> <br><ul><li>  Teoria: ao transferir um tipo significativo para o log4net, o boxe deve ocorrer, o que simplesmente gasta o tempo do processador e n√£o leva a nada.  No caso do NLog, n√£o existe esse comportamento, portanto, o √∫ltimo deve funcionar mais rapidamente. </li></ul><br></li><li>  As assinaturas para um grande n√∫mero de argumentos nas bibliotecas s√£o aproximadamente as mesmas, ent√£o eu gostaria de saber: <br><ul><li>  Qu√£o mais eficiente √© invocar m√©todos com um pequeno n√∫mero de par√¢metros. </li><li>  Existe uma diferen√ßa na velocidade de chamar o m√©todo "Is ... Enabled" entre as duas bibliotecas </li></ul></li></ul><br><p>  E agora a an√°lise dos resultados: </p><br><ul><li>  Devido ao uso de argumentos gen√©ricos no NLog, ele funciona mais r√°pido no caso em que o log direto n√£o √© necess√°rio.  Ou seja, no caso em que no seu programa Debug o n√≠vel √© ativado apenas no sistema de teste, apenas alterar a biblioteca pode acelerar o software (e melhorar a vida dos usu√°rios). </li><li>  Se voc√™ tiver desativado o log e quiser chamar um m√©todo com um grande n√∫mero de argumentos, ser√° mais eficiente dividi-lo em dois.  Por esse motivo, as chamadas de m√©todo acima funcionar√£o dez vezes mais r√°pido. </li><li>  Quando voc√™ escreve uma fun√ß√£o que pode receber qualquer objeto, geralmente √© mais eficaz ficar confuso e criar uma fun√ß√£o gen√©rica.  Devido a uma otimiza√ß√£o t√£o simples, o c√≥digo funcionar√° mais rapidamente (isso √© claramente visto na diferen√ßa de hor√°rio entre as chamadas para <code>Log4NetSingleReferenceParam</code> e <code>Log4NetSingleValueParam</code> ) </li></ul><br><h1 id="filelogging">  Registro de arquivos </h1><br><p>  A maioria dos programas (de acordo com minhas observa√ß√µes) ainda registra os resultados em um arquivo, portanto, para compara√ß√£o, escolhemos esta opera√ß√£o.  Por uma quest√£o de simplicidade, apenas assumimos a configura√ß√£o dos registradores quando um arquivo √© gravado no arquivo sem buffer, sem bloqueios adicionais, etc. </p><br><p>  Resultados: </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Mean </th><th>  Erro </th><th>  Stddev </th></tr></thead><tbody><tr><td>  FileLoggingLog4NetNoParams </td><td>  8.251.032 ns </td><td>  109.3075 ns </td><td>  102.2463 ns </td></tr><tr><td>  FileLoggingLog4NetSingleReferenceParam </td><td>  8.260,445 ns </td><td>  145.9028 ns </td><td>  136.4776 ns </td></tr><tr><td>  FileLoggingLog4NetSingleValueParam </td><td>  8.378.693 ns </td><td>  121.3003 ns </td><td>  113.4643 ns </td></tr><tr><td>  FileLoggingLog4NetMultipleReferencesParam </td><td>  9.133.136 ns </td><td>  89.7420 ns </td><td>  79.5539 ns </td></tr><tr><td>  FileLoggingLog4NetMultipleValuesParam </td><td>  9.393.989 ns </td><td>  166.0347 ns </td><td>  155.3089 ns </td></tr><tr><td>  FileLoggingNLogNetNoParams </td><td>  6.061.837 ns </td><td>  69.5666 ns </td><td>  65.0726 ns </td></tr><tr><td>  FileLoggingNLogNetSingleReferenceParam </td><td>  6.458.201 ns </td><td>  94.5617 ns </td><td>  88,4530 ns </td></tr><tr><td>  FileLoggingNLogNetSingleValueParam </td><td>  6.460.859 ns </td><td>  95.5435 ns </td><td>  84.6969 ns </td></tr><tr><td>  FileLoggingNLogNetMultipleReferencesParam </td><td>  7.236.886 ns </td><td>  89.7334 ns </td><td>  83.9367 ns </td></tr><tr><td>  FileLoggingNLogNetMultipleValuesParam </td><td>  7.524.876 ns </td><td>  82.8979 ns </td><td>  77.5427 ns </td></tr></tbody></table></div><br><p>  C√≥digo usado: </p><br><ul><li>  log4net: </li></ul><br><pre> <code class="plaintext hljs">var roller = new RollingFileAppender(); roller.ImmediateFlush = true; roller.RollingStyle = RollingFileAppender.RollingMode.Once; roller.MaxFileSize = 128 * 1000 * 1000;</code> </pre> <br><ul><li>  Nlog: </li></ul><br><pre> <code class="plaintext hljs">new FileTarget($"target_{_logIndex++}") { ArchiveAboveSize = 128 * 1000 * 1000, MaxArchiveFiles = 16, AutoFlush = true, ConcurrentWrites = false, KeepFileOpen = false };</code> </pre><br><p>  Como voc√™ pode ver, a configura√ß√£o dos registradores √© mais ou menos semelhante e de acordo com os resultados: </p><br><ul><li>  O NLog √© um pouco mais r√°pido que o log4net, algo em torno de 15%. </li><li>  Segundo os testes, descobriu-se que √© mais eficiente registrar menos par√¢metros.  No entanto, n√£o se deve esquecer que, com um n√∫mero maior de par√¢metros, a sequ√™ncia resultante tamb√©m se expandiu.  Portanto, a tabela apenas compara corretamente o NLog ao log4net. </li></ul><br><h1 id="nlog---raznye-sposoby-blokirovok">  NLog - diferentes tipos de bloqueios </h1><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Mean </th><th>  Erro </th><th>  Stddev </th></tr></thead><tbody><tr><td>  KeepFileOpen = true, ConcurrentWrites = false, Ass√≠ncrono = false </td><td>  5.642,301 ns </td><td>  73.2291 ns </td><td>  68.4986 ns </td></tr><tr><td>  KeepFileOpen = true, ConcurrentWrites = true, Ass√≠ncrono = false </td><td>  11.834.892 ns </td><td>  82,7578 ns </td><td>  77.4117 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = false, Ass√≠ncrono = false </td><td>  731.250.539 ns </td><td>  14.612.0117 ns </td><td>  27.444.8998 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = true, Ass√≠ncrono = false </td><td>  730.271.927 ns </td><td>  11.330.0172 ns </td><td>  10.598.1051 ns </td></tr></tbody></table></div><br><p>  C√≥digo fonte: </p><br><pre> <code class="plaintext hljs">new FileTarget($"target_{_logIndex++}") { ArchiveAboveSize = 128 * 1000 * 1000, MaxArchiveFiles = 16, AutoFlush = true, ConcurrentWrites = XXXXX, KeepFileOpen = YYYYY };</code> </pre><br><p>  Se colocarmos todas as combina√ß√µes poss√≠veis no lugar de XXXXX e AAAA, obtemos o teste da tabela. </p><br><p>  Os resultados s√£o bastante previs√≠veis: </p><br><ul><li>  Se voc√™ ativar ConcurrentWrites, o sistema pegar√° e fornecer√° o Mutex constantemente, o que n√£o √© gratuito.  Mas, como vemos, gravar uma linha em um arquivo √© aproximadamente equivalente a um bloqueio do sistema. </li><li>  Fechar e abrir um arquivo, como vemos, afeta ainda mais o desempenho do sistema.  Nos exemplos com <code>KeepFileOpen=true</code> para cada opera√ß√£o de cria√ß√£o de log, criamos um arquivo (junto com o Handle), <code>KeepFileOpen=true</code> no disco, chamado Flush, retornamos o Handle e tamb√©m fizemos v√°rias opera√ß√µes de cap√¥ do motor.  Como resultado, a velocidade cai centenas de vezes. </li></ul><br><h1 id="asinhronnoe-loggirovanie-i-raznye-sposoby-blokirovok">  Registro ass√≠ncrono e diferentes m√©todos de bloqueio </h1><br><p>  A biblioteca NLog tamb√©m pode executar todas as opera√ß√µes de E / S em outro encadeamento, liberando imediatamente o atual.  E ele faz isso com compet√™ncia, preservando a ordem dos eventos, descartando todos os dados em blocos, e em cada bloco um n√∫mero inteiro √© um n√∫mero de evento (para que as linhas cortadas n√£o sejam obtidas) e assim por diante. </p><br><p>  Os resultados de diferentes m√©todos sem bloqueio: </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Mean </th><th>  Erro </th><th>  Stddev </th></tr></thead><tbody><tr><td>  KeepFileOpen = true, ConcurrentWrites = false, Async = true </td><td>  1.144.677 ns </td><td>  26.3805 ns </td><td>  77.7835 ns </td></tr><tr><td>  KeepFileOpen = true, ConcurrentWrites = true, Ass√≠ncrono = true </td><td>  1.106.691 ns </td><td>  31.4041 ns </td><td>  87.5421 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = false, Ass√≠ncrono = true </td><td>  4.804.426 ns </td><td>  110.3406 ns </td><td>  103.2126 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = true, Ass√≠ncrono = true </td><td>  5.303,602 ns </td><td>  104,3022 ns </td><td>  102.4387 ns </td></tr></tbody></table></div><br><p>  A compara√ß√£o das abordagens de bloqueio e ass√≠ncronas ser√° mais adiante, mas aqui - apenas a √∫ltima. </p><br><p>  C√≥digo <code>AsyncTargetWrapper</code> : </p><br><pre> <code class="plaintext hljs">new AsyncTargetWrapper(fileTargetWithConcurrentWritesAndCloseFileAsync) { OverflowAction = AsyncTargetWrapperOverflowAction.Block, QueueLimit = 10000 }</code> </pre> <br><p>  Como voc√™ pode ver, as configura√ß√µes do wrapper s√£o tais que um despejo direto no arquivo n√£o leva muito tempo.  Assim, um buffer grande √© acumulado, o que significa que todas as opera√ß√µes que exigem muitos recursos, como "arquivo aberto", s√£o executadas uma vez para todo o bloco.  No entanto, esse algoritmo requer mem√≥ria adicional (e muito). </p><br><p>  Conclus√µes: </p><br><ul><li>  Se a sa√≠da ass√≠ncrona for usada, n√£o importa que tipo de configura√ß√£o de sa√≠da com o arquivo seja usada.  Voc√™ pode abrir e fechar o arquivo toda vez, com um buffer grande ser√° quase impercept√≠vel. </li><li>  Todas as medi√ß√µes s√£o verdadeiras apenas para o caso em que os dados s√£o liberados para o disco na mesma velocidade do preenchimento de buffers (eu fiz isso devido ao r√°pido sistema de arquivos + pausas naturais entre as medi√ß√µes). </li></ul><br><h1 id="sinhronnoe-i-asinhronnoe-loggirovanie">  Log s√≠ncrono e ass√≠ncrono </h1><br><div class="scrollable-table"><table><thead><tr><th>  Resultados: </th><th>  M√©todo </th><th>  Mean </th><th>  Erro </th><th>  Stddev </th><th>  Mediana </th></tr></thead><tbody><tr><td>  KeepFileOpen = true, ConcurrentWrites = false, Async = true </td><td>  1.835.730 ns </td><td>  55.3980 ns </td><td>  163.3422 ns </td><td>  1.791.901 ns </td></tr><tr><td>  FileLoggingLog4NetNoParams </td><td>  7.076.251 ns </td><td>  41.5518 ns </td><td>  38.8676 ns </td><td>  7.075.394 ns </td></tr><tr><td>  FileLoggingNLogNetNoParams </td><td>  5.438,306 ns </td><td>  42.0170 ns </td><td>  37.2470 ns </td><td>  5.427,805 ns </td></tr><tr><td>  NoOpLog4NetNoParams </td><td>  11.063 ns </td><td>  0,0141 ns </td><td>  0,0125 ns </td><td>  11.065 ns </td></tr><tr><td>  NoOpNLogNetNoParams </td><td>  1.045 ns </td><td>  0,0037 ns </td><td>  0,0033 ns </td><td>  1.045 ns </td></tr></tbody></table></div><br><p>  Conclus√µes: </p><br><ul><li>  Apesar do disco r√°pido (no meu caso - M.2 SSD), a grava√ß√£o em um arquivo em outro fluxo acelera o trabalho v√°rias vezes.  Se seu aplicativo gravar em discos HDD e at√© rodar em uma m√°quina virtual, o ganho ser√° ainda maior. </li><li>  No entanto, apesar da opera√ß√£o ainda mais r√°pida do c√≥digo ass√≠ncrono, a falta de registro fornece um ganho ainda maior (embora um pouco diferente, dependendo da biblioteca). </li></ul><br><h1 id="sozdanie-loggerov">  Criando Registradores </h1><br><p>  Resultados: </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Mean </th><th>  Erro </th><th>  Stddev </th></tr></thead><tbody><tr><td>  CreateLog4NetFromString </td><td>  1.470.662 ns </td><td>  19.9492 ns </td><td>  18.6605 ns </td></tr><tr><td>  CreateNLogFromString </td><td>  228.774 ns </td><td>  2.1315 ns </td><td>  1,8895 ns </td></tr><tr><td>  CreateLog4NetLogger </td><td>  21.046.294 ns </td><td>  284.1171 ns </td><td>  265.7633 ns </td></tr><tr><td>  CreateNLogTypeOfLogger </td><td>  164.487.931 ns </td><td>  3.240.4372 ns </td><td>  3.031.1070 ns </td></tr><tr><td>  CreateNLogDynamicLogger </td><td>  134.459.092 ns </td><td>  1.882,8663 ns </td><td>  1.761,2344 ns </td></tr></tbody></table></div><br><p>  O que foi testado: </p><br><pre> <code class="plaintext hljs">[Benchmark] public object CreateLog4NetFromString() { return LogManager.GetLogger("my-logger_" + (Interlocked.Increment(ref _log4NetStringLogIndex) % 1000)); } [Benchmark] public object CreateNLogFromString() { return NLog.LogManager.GetLogger("my-logger_" + (Interlocked.Increment(ref _nLogStringLogIndex) % 1000)); } [Benchmark] public object CreateLog4NetLogger() { return new [] { LogManager.GetLogger(typeof(BaseTest)), // x16 times }; } [Benchmark] public object CreateNLogTypeOfLogger() { return new[] { NLog.LogManager.GetCurrentClassLogger(typeof(BaseTest)), // x16 times }; } [Benchmark] public object CreateNLogDynamicLogger() { return new[] { NLog.LogManager.GetCurrentClassLogger(), // x16 times }; }</code> </pre> <br><p>  Observa√ß√£o importante: infelizmente, para mim foi dif√≠cil fazer um benchmark reproduz√≠vel que n√£o levasse √† falta de mem√≥ria, mas que criaria diferentes registradores (ou seja, para tipos diferentes, para linhas diferentes e assim por diante). </p><br><p>  No entanto, tendo estudado o trabalho das bibliotecas, descobri que quase as opera√ß√µes mais dif√≠ceis s√£o executadas para criar uma chave do criador de logs (isto √©, determinar um nome, limpar argumentos gen√©ricos etc.). <br>  Al√©m disso, para estabilizar o benchmark para a cria√ß√£o de um logger para o log4net, foi necess√°rio executar n√£o uma opera√ß√£o, mas 16 (isto √©, uma matriz de 16 objetos id√™nticos √© retornada).  Se voc√™ n√£o retornar nada, o .Net otimizou a execu√ß√£o para mim (aparentemente, apenas n√£o retornando o resultado), o que levou a resultados incorretos. </p><br><p>  E conclus√µes: </p><br><ul><li>  Os criadores de logs s√£o criados mais rapidamente a partir de strings (o NLog √© mais r√°pido novamente, no entanto, a diferen√ßa entre as bibliotecas √© pequena, considerando que os criadores de logs s√£o criados n√£o apenas assim, mas para o trabalho subsequente com eles). </li><li>  O log4net √© mais r√°pido que o NLog ao inicializar um projeto.  Talvez isso se deva ao cache adicional no lado do NLog, o que ajuda a acelerar as chamadas diretas para <code>Debug</code> , <code>Info</code> etc.  De fato, todo <code>ILogger</code> sabe a resposta: chamar os m√©todos a seguir ou n√£o (e isso requer pelo menos algum tipo de liga√ß√£o √† configura√ß√£o geral).  Devido a esse esquema de trabalho, a Mem√≥ria insuficiente foi usada por mim na maioria dos testes (se eu usar linhas diferentes etc.). </li><li>  <code>LogManager.GetCurrentClassLogger()</code> √© ainda mais lento que <code>LogManager.GetLogget(typeof(XXX))</code> .  Isso √© l√≥gico, mesmo os desenvolvedores do NLog n√£o recomendam chamar o primeiro m√©todo em um loop. </li><li>  E o mais importante: a velocidade de todos esses m√©todos geralmente afeta apenas o in√≠cio a frio do aplicativo quando os campos do formul√°rio <code>private static readonly ILogger Log = LogManager.GetCurrentClassLogger()</code> .  Ou seja, n√£o afeta diretamente o desempenho do sistema. </li></ul><br><h1 id="vyvod">  Conclus√£o </h1><br><p>  Qual √© a melhor maneira de lidar com logs: </p><br><ul><li>  Se for poss√≠vel n√£o fazer logon, este ser√° o mais r√°pido (o que √© √≥bvio at√© agora). </li><li>  Se o projeto tiver muitas chamadas de criador de logs que n√£o despejam dados em um arquivo (no console etc.), o NLog ser√° mais r√°pido.  Al√©m disso, ele aloca menos objetos no heap. </li><li>  Se voc√™ ainda precisar gravar em um arquivo, o NLog funcionar√° de forma ass√≠ncrona mais rapidamente.  Sim, consome mais mem√≥ria (em compara√ß√£o com o NLog no modo s√≠ncrono, pois de acordo com minhas medi√ß√µes anteriores, o log4net nem tenta reutilizar matrizes e <code>Stream</code> ).  No entanto, o programa poder√° executar mais rapidamente. </li><li>  Criar um criador de logs n√£o √© uma opera√ß√£o livre; portanto, √© melhor cri√°-lo com um campo est√°tico.  Isso n√£o se aplica √† cria√ß√£o de uma sequ√™ncia, ou seja, algo como <code>LogManager.GetLogger("123")</code> .  Essas chamadas funcionam mais rapidamente, o que significa que um criador de logs pode ser criado para grandes inst√¢ncias de objetos (por exemplo, "um criador de logs para o contexto da consulta"). </li><li>  Se voc√™ deseja gerar muitos par√¢metros para o log, mas na maioria dos casos n√£o haver√° despejo direto de dados no arquivo, √© melhor fazer v√°rias chamadas.  Portanto, o NLog n√£o criar√° objetos adicionais no heap se eles n√£o forem necess√°rios l√°. </li></ul><br><p>  Conclus√µes para o seu c√≥digo: </p><br><ul><li>  Se o seu m√©todo aceitar um objeto arbitr√°rio (ou seja, <code>object</code> ) e, na maioria dos casos, n√£o fizer nada (o que √© verdadeiro para contratos / validadores), √© mais correto agrupar chamadas em um formato gen√©rico (ou seja, criar m√©todos com o formato <code>Something&lt;TArg&gt;(TArg arg)</code> ).  Isso funcionar√° muito mais r√°pido. </li><li>  Se no seu c√≥digo uma redefini√ß√£o de dados do arquivo for permitida e, ao mesmo tempo, trabalhar com outra coisa, √© melhor ficar confuso e dar suporte a isso.  Sim, parece √≥bvio que a execu√ß√£o paralela pode acelerar o trabalho; no entanto, no caso de opera√ß√µes de E / S, essa abordagem tamb√©m oferece um aumento de desempenho adicional em m√°quinas com discos lentos. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt456488/">https://habr.com/ru/post/pt456488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt456470/index.html">Armadilhas do Publicador de Pacotes do WSUS</a></li>
<li><a href="../pt456472/index.html">Apresentando o Go e o Mggo Framework</a></li>
<li><a href="../pt456476/index.html">Modifica√ß√µes da pilha Bluetooth para melhorar a qualidade do √°udio em fones de ouvido sem codecs AAC, aptX ou LDAC</a></li>
<li><a href="../pt456482/index.html">Me pegue se puder. King Version</a></li>
<li><a href="../pt456486/index.html">Interface e Escolha (2014)</a></li>
<li><a href="../pt456490/index.html">Palestras sobre o c√©rebro, parte 1. A evolu√ß√£o do c√©rebro humano. O c√©rebro funciona em todas as fases do seu desenvolvimento</a></li>
<li><a href="../pt456492/index.html">Troll army</a></li>
<li><a href="../pt456494/index.html">Nos Estados Unidos, os GOSTs tamb√©m s√£o mais ou menos. Vulnerabilidade fatal do YubiKey FIPS que poderia ter sido evitada</a></li>
<li><a href="../pt456498/index.html">Gerenciador de dispositivos Estender o MIS para dispositivos</a></li>
<li><a href="../pt456500/index.html">Como ensinar a superar dificuldades e, ao mesmo tempo, escrever ciclos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>