<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôäÔ∏è üßóüèø üë®üèæ‚Äçüç≥ Erstellen eines Plugins f√ºr Clang Static Analyzer zur Suche nach Ganzzahl√ºberl√§ufen üöü üçë üò∂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel Autor: 0x64rem 
 Eintrag 


 Vor anderthalb Jahren hatte ich die Idee, meinen Phaser im Rahmen der Diplomarbeit an der Universit√§t zu realisie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen eines Plugins f√ºr Clang Static Analyzer zur Suche nach Ganzzahl√ºberl√§ufen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/473412/"><p><img src="https://habrastorage.org/getpro/habr/post_images/e69/d01/efb/e69d01efbeff395f19dbb543055a5493.jpg" title="Abb. 1"></p><br><p>  <em>Artikel Autor: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">0x64rem</a></em> </p><br><h2 id="vstuplenie">  Eintrag </h2><br><p>  Vor anderthalb Jahren hatte ich die Idee, meinen Phaser im Rahmen der Diplomarbeit an der Universit√§t zu realisieren.  Ich begann Materialien √ºber Kontrollflussdiagramme, Datenflussdiagramme, symbolische Ausf√ºhrung usw. zu studieren.  Als n√§chstes folgte die Suche nach Werkzeugen, einer Auswahl verschiedener Bibliotheken (Angr, Triton, Pin, Z3).  Am Ende passierte nichts Konkretes, bis ich diesen Sommer zum Summer of Hack 2019-Programm von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Digital Security</a> ging, wo mir die Erweiterung des Clang Static Analyzer als Thema f√ºr das Projekt angeboten wurde.  Es schien mir, dass dieses Thema mir helfen w√ºrde, mein theoretisches Wissen in die Regale zu stellen, etwas Wesentliches umzusetzen und Empfehlungen von erfahrenen Mentoren zu erhalten.  Als n√§chstes werde ich Ihnen erz√§hlen, wie der Prozess des Schreibens des Plug-Ins verlaufen ist, und den Verlauf meiner Gedanken w√§hrend des Praktikumsmonats beschreiben. </p><a name="habracut"></a><br><h2 id="clang-static-analyzer">  Clang statischer Analysator </h2><br><p>  F√ºr die Entwicklung bietet Clang drei Schnittstellenoptionen f√ºr die Interaktion: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LibClang</a> ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºbergeordnete</a> C-Schnittstelle, mit der Sie mit AST interagieren k√∂nnen, jedoch nicht vollst√§ndig.  Eine gute Option, wenn Sie eine Interaktion mit einer anderen Sprache (z. B. die Implementierung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bindungen</a> ) oder eine stabile Schnittstelle ben√∂tigen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Clang Plugins</a> - dynamische Bibliotheken, die zur Kompilierungszeit aufgerufen werden.  Erm√∂glicht die vollst√§ndige Bearbeitung des AST. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LibTooling</a> - eine Bibliothek zum Erstellen separater Tools basierend auf Clang.  Erm√∂glicht au√üerdem den vollst√§ndigen Zugriff auf die Interaktion mit AST.  Der resultierende Code kann au√üerhalb der Build-Umgebung des √ºberpr√ºften Projekts ausgef√ºhrt werden. </li></ul><br><p>  Da wir die Funktionen von Clang Static Analyzer erweitern werden, w√§hlen wir die Implementierung des Plugins.  Sie k√∂nnen Code f√ºr das Plugin in C ++ oder Python schreiben. </p><br><p>  F√ºr letztere gibt es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ordner</a> , mit denen Sie den Quellcode analysieren, √ºber die Knoten des resultierenden abstrakten Syntaxbaums iterieren, auf die Eigenschaften der Knoten zugreifen und den Knoten der Zeile des Quellcodes zuordnen k√∂nnen.  Ein solches Set eignet sich f√ºr einen einfachen Pr√ºfer.  Weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen finden</a> Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im llvm-Repository</a> . </p><br><p>  Meine Aufgabe erfordert eine detaillierte Analyse des Codes, daher wurde C ++ f√ºr die Entwicklung ausgew√§hlt.  Als n√§chstes folgt eine Einf√ºhrung in das Tool. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Clang Staic Analyzer</a> (im Folgenden CSA) ist ein Tool zur statischen Analyse von C / C ++ / Objective-C-Code basierend auf symbolischer Ausf√ºhrung.  Der Analysator kann √ºber das Clang-Frontend aufgerufen werden, indem dem Befehl build die Flags -cc1 und -analyze hinzugef√ºgt werden, oder √ºber eine separate Scan-Build-Bin√§rdatei.  Zus√§tzlich zur Analyse selbst erm√∂glicht CSA die Erstellung visueller HTML-Berichte. </p><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ,      clang' clang -cc1 --help #  CSA  ‚Ññ1 clang++ -cc1 -x c++ -load path/to/Checker.so -analyze -analyzer-checker=test.Me -analyzer-config $BUILD_OPTIONS Checker.cpp</span></span></code> </pre> <br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#  CSA  ‚Ññ2 scan-build -load-plugin path/to/Checker.so -enable-checker test.Me $BUILD_COMMAND</span></span></code> </pre> <br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#       DivideZero clang++ -cc1 -analyze -analyzer-checker=core.DivideZero -o reports div-by-zero-test.cpp</span></span></code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/6dd/b8e/302/6ddb8e302c62b6cc58c4533a894d49e9.jpg" alt=" " title="Abb. 2"></p><br><p>  CSA verf√ºgt √ºber eine hervorragende Bibliothek zum Parsen von Quellcode mithilfe von AST (Abstract Syntax Tree) und CFG (Control Flow Graph).  Aus den Strukturen k√∂nnen Sie weiter die Deklarationen von Variablen, ihre Typen, die Verwendung von bin√§ren und un√§ren Operatoren sehen, Sie k√∂nnen symbolische Ausdr√ºcke erhalten usw.  Mein Plugin wird die Funktionalit√§t von AST-Klassen verwenden, diese Auswahl wird weiter gerechtfertigt sein.  Das Folgende ist eine Liste von Klassen, die bei der Implementierung des Plugins verwendet wurden. Die Liste hilft dabei, ein prim√§res Verst√§ndnis der Funktionen von CSA zu erlangen: </p><br><ul><li><p>  Stmt - Dies schlie√üt bin√§re Operationen ein. </p><br></li><li><p>  Deklaration - Deklaration von Variablen. </p><br></li><li><p>  Ausdruck - speichert die linken und rechten Teile von Ausdr√ºcken, ihren Typ. </p><br></li><li><p>  ASTContext - Informationen zum Baum, dem aktuellen Knoten. </p><br></li><li><p>  Quellmanager - Informationen zum tats√§chlichen Code, der dem Teil des Baums entspricht. </p><br></li><li><p>  RecursiveASTVisitor, ASTMatcher - Klassen zum Durchlaufen eines Baums. </p><br><p>  Ich wiederhole, dass CSA dem Entwickler die M√∂glichkeit bietet, die Struktur des Codes im Detail zu untersuchen, und die oben aufgef√ºhrten Klassen sind nur ein kleiner Teil der verf√ºgbaren.  Ich empfehle auf jeden Fall, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> Ihrer Clang-Version zu lesen, wenn Sie nicht wissen, wie Sie Daten extrahieren k√∂nnen.  h√∂chstwahrscheinlich wurde bereits etwas Passendes geschrieben. </p><br></li></ul><br><h2 id="poisk-celochislennyh-perepolneniy">  Integer Overflow Search </h2><br><p>  Um mit der Implementierung des Plugins zu beginnen, m√ºssen Sie die Aufgabe ausw√§hlen, die es l√∂sen soll.  In diesem Fall enth√§lt die llvm-Website <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Listen potenzieller Pr√ºfer</a> . Sie k√∂nnen auch vorhandene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stabile</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alpha-</a> Pr√ºfer √§ndern.  Bei der √úberpr√ºfung des Codes der verf√ºgbaren Pr√ºfer wurde klar, dass es f√ºr eine erfolgreichere Entwicklung von libclang besser ist, den Pr√ºfer von Grund auf neu zu schreiben. Daher wurde die Auswahl aus einer Liste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht realisierter Ideen getroffen</a> .  Infolgedessen wurde die Option ausgew√§hlt, einen Pr√ºfer f√ºr die Erkennung von Ganzzahl√ºberl√§ufen zu erstellen.  Clang verf√ºgt bereits √ºber Funktionen, um diese Sicherheitsanf√§lligkeit zu verhindern (die Flags -ftrapv, -fwrapv und dergleichen sind f√ºr seine Verwendung angegeben), es ist in den Compiler integriert, und dieser Auspuff wird in Warnungen eingef√ºllt, und es wird dort nicht oft gesucht.  Es gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">immer noch UBSan</a> , aber dies sind Desinfektionsmittel, die nicht von allen verwendet werden. Bei dieser Methode werden Probleme zur Laufzeit identifiziert, und das CSA-Plug-In funktioniert zur Kompilierungszeit und analysiert die Quellen. </p><br><p>  Als n√§chstes folgt die Sammlung von Material zur ausgew√§hlten Sicherheitsanf√§lligkeit.  Ein ganzzahliger √úberlauf war fr√ºher etwas Einfaches und nicht Ernstes.  In der Tat ist die Sicherheitsanf√§lligkeit unterhaltsam und kann beeindruckende Konsequenzen haben. <br>  Ganzzahl√ºberl√§ufe sind eine Art von Sicherheitsanf√§lligkeit, die dazu f√ºhren kann, dass Daten vom Typ Ganzzahl im Code unerwartete Werte annehmen.  √úberlauf - Wenn die Variable gr√∂√üer geworden ist als beabsichtigt, Unterlauf - weniger als der urspr√ºngliche Typ.  Solche Fehler k√∂nnen sowohl aufgrund des Programmierers als auch aufgrund des Compilers auftreten. </p><br><p>  In C ++ werden w√§hrend einer arithmetischen Vergleichsoperation ganzzahlige Werte in denselben Typ umgewandelt, h√§ufiger in einen gr√∂√üeren Typ in Bezug auf die Bittiefe.  Und solche Geister kommen √ºberall und st√§ndig vor, sie k√∂nnen explizit oder implizit sein.  Es gibt verschiedene Regeln, nach denen Geister auftreten [1]: </p><br><ul><li>  Konvertieren von einem signierten in einen Typ mit einem signierten, aber gr√∂√üeren Bit: F√ºgen Sie einfach die hohe Ordnung hinzu. </li><li>  Konvertieren einer vorzeichenbehafteten Ganzzahl in eine vorzeichenlose Ganzzahl mit derselben Kapazit√§t: Das Negative wird in ein Positiv umgewandelt und erh√§lt eine neue Bedeutung.  Ein Beispiel f√ºr einen √§hnlichen Fehler in DirectFB ist <a href="">CVE-2014-2977</a> . </li><li>  Konvertieren einer vorzeichenbehafteten Ganzzahl in eine vorzeichenlose Ganzzahl mit gr√∂√üerer Bitkapazit√§t: Zuerst wird die Bitkapazit√§t erweitert, und wenn die Zahl negativ ist, wird der Wert falsch ge√§ndert.  Zum Beispiel: 0xff (-1) wird zu 0xffffffff. </li><li>  Eine vorzeichenlose Ganzzahl mit einem Vorzeichen derselben Bitkapazit√§t: Eine Zahl kann den Wert abh√§ngig vom Wert des hohen Bits √§ndern. </li><li>  Eine vorzeichenlose Ganzzahl mit einer Ganzzahl mit einem Zeichen gr√∂√üerer Kapazit√§t: Zuerst erh√∂ht sich die Kapazit√§t einer vorzeichenlosen Zahl, dann die Konvertierung in eine vorzeichenbehaftete. </li><li>  Abw√§rtskonvertierung: Bits werden nur abgeschnitten.  Dies kann vorzeichenlose Werte negativ machen und so weiter.  Ein Beispiel f√ºr eine solche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sicherheitsl√ºcke in PHP</a> . </li></ul><br><p>  Das hei√üt,  Der Ausl√∂ser f√ºr die Sicherheitsanf√§lligkeit k√∂nnen unsichere Benutzereingaben, falsche Arithmetik und falsche Typkonvertierung sein, die von einem Programmierer oder Compiler w√§hrend der Optimierung verursacht werden.  Die Zeitbombenoption ist auch m√∂glich, wenn ein Teil des Codes mit einer Version des Compilers harmlos ist, aber mit der Ver√∂ffentlichung eines neuen Optimierungsalgorithmus ‚Äûexplodiert‚Äú und unerwartetes Verhalten verursacht.  In der Geschichte gab es bereits einen solchen Fall mit der SafeInt-Klasse (sehr ironisch) [5, 6.5.2]. </p><br><p>  Ganzzahl√ºberl√§ufe √∂ffnen einen breiten Vektor: Es ist m√∂glich, die Ausf√ºhrung zu zwingen, einen anderen Pfad einzuschlagen (wenn der √úberlauf bedingte Anweisungen beeinflusst), was zu einem Puffer√ºberlauf f√ºhrt.  Aus Gr√ºnden der √úbersichtlichkeit k√∂nnen Sie sich mit bestimmten CVEs vertraut machen und deren Ursachen und Folgen ermitteln.  Nat√ºrlich ist es besser, in Open Source-Produkten nach einem Ganzzahl√ºberlauf zu suchen, damit Sie nicht nur die Beschreibung lesen, sondern auch den Code sehen. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CVE-2019-3560</a> - Ein Integer-√úberlauf in Fizz (ein Projekt, das TLS f√ºr Facebook implementiert) k√∂nnte die Sicherheitsanf√§lligkeit f√ºr DoS-Angriffe mithilfe eines engen Netzwerkpakets ausnutzen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CVE-2018-14618</a> - Puffer√ºberlauf in Curl durch ganzzahligen √úberlauf aufgrund der Kennwortl√§nge. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CVE-2018-6092</a> - Auf 32-Bit-Systemen erm√∂glichte eine Sicherheitsanf√§lligkeit in WebAssembly f√ºr Chrome die Implementierung von RCE √ºber eine spezielle HTML-Seite. </li></ul><br><p>  Um das Rad nicht neu zu erfinden, wurde der Code zum Erkennen eines Ganzzahl√ºberlaufs im statischen Analysator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CppCheck</a> ber√ºcksichtigt.  Sein Ansatz ist wie folgt: </p><br><ol><li>  Bestimmen Sie, ob ein Ausdruck ein bin√§rer Operator ist. </li><li>  Wenn ja, √ºberpr√ºfen Sie, ob beide Argumente vom Typ Integer sind. </li><li>  Bestimmen Sie die Gr√∂√üe der Typen. </li><li>  Pr√ºfen Sie anhand von Berechnungen, ob der Wert seine H√∂chst- oder Mindestgrenze √ºberschreiten kann. <br>  Aber zu diesem Zeitpunkt gab es keine Klarheit.  Es gibt viele verschiedene Geschichten, und durch diese Systematisierung von Informationen wird es schwieriger.  Alles an seiner Stelle stellte die Liste der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE</a> .  Insgesamt sind auf der Site 9 Arten von Ganzzahl√ºberl√§ufen zugeordnet: <br><ul><li>  190 - ganzzahliger √úberlauf </li><li>  191 - ganzzahliger Unterlauf </li><li>  192 - ganzzahliger Koertionsfehler </li><li>  193 - eins nach dem anderen </li><li>  194 - Unerwartete Zeichenerweiterung </li><li>  195 - Signed to Unsigned Conversion Error </li><li>  196 - Fehler beim Konvertieren ohne Vorzeichen </li><li>  197 - Numerischer K√ºrzungsfehler </li><li>  198 - Verwendung einer falschen Bytereihenfolge </li></ul></li></ol><br><p>  Wir betrachten den Grund f√ºr jede Option und verstehen, dass √úberl√§ufe mit falschen expliziten / impliziten Casts auftreten.  Und weil  Alle Casts werden in der Struktur des abstrakten Syntaxbaums angezeigt. Wir werden AST f√ºr die Analyse verwenden.  In der folgenden Abbildung (Abb. 3) ist zu sehen, dass jede Operation, die eine Umwandlung in den Baum verursacht, ein separater Knoten ist. Wenn Sie sich im Baum bewegen, k√∂nnen Sie alle Typkonvertierungen anhand einer Tabelle mit Transformationen √ºberpr√ºfen, die einen Fehler verursachen k√∂nnen. </p><br><div class="scrollable-table"><table><thead><tr><th></th><th>  Zeichen g </th><th>  Zeichen l </th><th>  Zeichen e </th><th>  Unsignieren g </th><th>  Unsign l </th><th>  Unsign e </th></tr></thead><tbody><tr><td>  Zeichen </td><td>  + </td><td>  - </td><td>  + </td><td>  - </td><td>  - </td><td>  - </td></tr><tr><td>  Unsignieren </td><td>  + </td><td>  - </td><td>  - </td><td>  - </td><td>  - </td><td>  + </td></tr></tbody></table></div><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e72/315/acb/e72315acbeaf57dcf7ea2f85670fe4e0.jpg" title="Abb. 3"></p><br><p>  Genauer gesagt klingt der Algorithmus so: Wir gehen um Casts herum und betrachten IntegralCast (Integer-Konvertierungen).  Wenn Sie einen geeigneten Knoten finden, suchen Sie die Nachkommen auf der Suche nach einer bin√§ren Operation oder Decl (Variablendeklaration).  Im ersten Fall m√ºssen Sie das Vorzeichen und die Bittiefe √ºberpr√ºfen, die von der Bin√§roperation verwendet werden.  Vergleichen Sie im zweiten Fall nur die Art der Deklaration. </p><br><h2 id="realizaciya-chekera">  Checker-Implementierung </h2><br><p>  Kommen wir zur Implementierung.  Wir ben√∂tigen ein Skelett f√ºr einen Checker, das eine eigenst√§ndige Bibliothek sein oder als Teil von Clang zusammengestellt werden kann.  Im Code ist der Unterschied gering.  Wenn Sie bereits vorhaben, ein eigenes Plugin zu schreiben, empfehle ich Ihnen, sofort ein kleines PDF zu lesen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Clang Static Analyzer: Ein Checker-Entwicklerhandbuch"</a> . Die grundlegenden Dinge sind dort gut beschrieben, obwohl etwas m√∂glicherweise nicht mehr relevant ist. Die Bibliothek wird regelm√§√üig aktualisiert, aber Sie sofort greifen. </p><br><p>  Wenn Sie Ihren Checker zu Ihrer Clang-Baugruppe hinzuf√ºgen m√∂chten, m√ºssen Sie: </p><br><ol><li><p>  Schreiben Sie den Checker selbst mit ungef√§hr folgendem Inhalt: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuperChecker</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Checker&lt;check::PreStmt&lt;BinaryOperator&gt;&gt; { <span class="hljs-comment"><span class="hljs-comment">//       ,    .       struct CheckerOpts { //       string FlagOne; int FlagTwo; }; CheckerOpts Opts; //cool code }; } void ento::registerSuperChecker(CheckerManager &amp;mgr) { auto checker = mgr.registerChecker&lt;SuperChecker&gt;(); //       ,   4    //       ,  stand-alone    . AnalyzerOptions &amp;AnOpts = mgr.getAnalyzerOptions(); SuperChecker::CheckerOpts &amp;ChOpts = checker-&gt;Opts; ChOpts.FlagOne = AnOpts.getCheckerStringOption("Inp1", "", checker); ChOpts.FlagTwo = AnOpts.getCheckerIntegerOption("Inp2", 0, checker); // getCheckerIntegerOption:  ,  ,   }</span></span></code> </pre> <br></li><li><p>  Anschlie√üend m√ºssen Sie im Quellcode von Clang die Dateien <code>CMakeLists.txt</code> und <code>Checkers.td</code> √§ndern.  Lebe hier herum <code>${llvm-source-path}/clang/lib/StaticAnalyzer/Checkers/CMakeLists.txt</code> <br>  und hier <code>${llvm-source-path}/clang/include/clang/StaticAnalyzer/Checkers/Checkers.td</code> . <br>  In der ersten m√ºssen Sie nur den Dateinamen mit dem Code hinzuf√ºgen, in der zweiten m√ºssen Sie eine strukturelle Beschreibung hinzuf√ºgen: </p><br><pre> <code class="cpp hljs"> #Checkers.td def SuperChecker : Checker&lt;<span class="hljs-string"><span class="hljs-string">"SuperChecker"</span></span>&gt;, HelpText&lt;<span class="hljs-string"><span class="hljs-string">"test checker"</span></span>&gt;, Documentation&lt;HasDocumentation&gt;;</code> </pre> <br></li></ol><br><p>  Wenn es nicht klar ist, finden Sie in der Datei <code>Checkers.td</code> gen√ºgend Beispiele daf√ºr, wie und was zu tun ist. </p><br><p>  H√∂chstwahrscheinlich m√∂chten Sie Clang nicht neu erstellen, und Sie greifen auf die Option mit der Bibliotheksassembly (so / dll) zur√ºck.  Dann sollte im Code des Checkers so etwas lauten: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuperChecker</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Checker&lt;check::PreStmt&lt;BinaryOperator&gt;&gt; { <span class="hljs-comment"><span class="hljs-comment">//       ,    .       struct CheckerOpts { string FlagOne; int FlagTwo; }; CheckerOpts Opts; //cool code }; } void initializationFunction(CheckerManager &amp;mgr){ SuperChecker *checker = mgr.registerChecker&lt;SuperChecker&gt;(); //       ,   4    AnalyzerOptions &amp;AnOpts = mgr.getAnalyzerOptions(); TestChecker::CheckerOpts &amp;ChOpts = checker-&gt;Opts; ChOpts.FlagOne = AnOpts.getCheckerStringOption("Inp1", "", checker); ChOpts.FlagTwo = AnOpts.getCheckerIntegerOption("Inp2", 0, checker); // getCheckerIntegerOption:  ,  ,   } extern "C" void clang_registerCheckers (CheckerRegistry &amp;registry) { registry.addChecker(&amp;initializationFunction, "test.Me", "SuperChecker description", "doc_link"); } extern "C" const char clang_analyzerAPIVersionString [] = "8.0.1";</span></span></code> </pre> <br><p>  Als n√§chstes sammeln Sie Ihren Code, Sie k√∂nnen Ihr eigenes Skript f√ºr die Assemblierung schreiben, aber wenn Sie Probleme damit haben (wie der Autor :)), k√∂nnen Sie das Makefile im Quellcode von clang verwenden und den Befehl clangStaticAnalyzerCheckers auf seltsame Weise ausf√ºhren. </p><br><p>  Rufen Sie als n√§chstes den Checker auf: </p><br><ul><li><p>  f√ºr eingebaute Pr√ºfer </p><br><pre> <code class="bash hljs">clang++ -cc1 -analyze -analyzer-checker=core.DivideZero test.cpp</code> </pre> <br></li><li><p>  f√ºr extern </p><br><pre> <code class="bash hljs">clang++ -cc1 -load <span class="hljs-variable"><span class="hljs-variable">${PATH_TO_CHECKER}</span></span>/SuperChecker.so -analyze -analyzer-checker=test.Me -analyzer-config test.Me:UsrInp1=<span class="hljs-string"><span class="hljs-string">"foo"</span></span> test.Me:Inp1=<span class="hljs-string"><span class="hljs-string">"bar"</span></span> -analyzer-config test.Me:Inp2=123 test.cpp</code> </pre> <br><p>  Zu diesem Zeitpunkt haben wir bereits ein Ergebnis (Abb. 4), aber der geschriebene Code kann nur m√∂gliche √úberl√§ufe erkennen.  Und das bedeutet eine gro√üe Anzahl von Fehlalarmen. </p><br></li></ul><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ac1/79d/29b/ac179d29b330efd513343fdd5f9a2ddd.jpg" title="Abb. 4"></p><br><p>  Um dies zu beheben, k√∂nnen wir: </p><br><ul><li>  Gehen Sie im Diagramm hin und her und √ºberpr√ºfen Sie die spezifischen Werte der Variablen auf F√§lle, in denen ein potenzieller √úberlauf vorliegt. </li><li>  Speichern Sie w√§hrend der AST-Durchquerung sofort bestimmte Werte f√ºr Variablen und √ºberpr√ºfen Sie sie bei Bedarf. </li><li>  Verwenden Sie die Verschmutzungsanalyse. </li></ul><br><p>  Um weitere Argumente zu untermauern, ist zu erw√§hnen, dass bei der Analyse von Clang alle in der Direktive <code>#include</code> angegebenen Dateien auch analysiert werden, wodurch sich die Gr√∂√üe des resultierenden AST erh√∂ht.  Infolgedessen ist von den vorgeschlagenen Optionen nur eine in Bezug auf eine bestimmte Aufgabe rational: </p><br><ul><li>  Erstens dauert die Fertigstellung sehr lange.  Das Gehen in einem Baum, das Suchen und Z√§hlen von allem, was Sie ben√∂tigen, wird lange dauern. Es kann schwierig werden, ein gro√ües Projekt mit einem solchen Code zu analysieren.  Um den Baum im Code zu <code>clang::RecursiveASTVisitor</code> , verwenden wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Klasse</a> <code>clang::RecursiveASTVisitor</code> , die eine rekursive Tiefensuche durchf√ºhrt.  Eine Sch√§tzung der Zeit dieses Ansatzes wird sein <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a7cf317fbe3965ae3164f28c1f6858696adb23f4" title="Schwierigkeitsgrad">  Dabei ist V die Menge der Eckpunkte und E die Menge der Kanten des Graphen. </li><li>  Die zweite - Sie k√∂nnen sicherlich speichern, aber wir wissen nicht, was wir brauchen und was nicht.  Dar√ºber hinaus ben√∂tigen die Baumstrukturen selbst, die wir in der Analyse verwenden, viel Speicher, sodass es eine schlechte Idee ist, solche Ressourcen f√ºr etwas anderes auszugeben. </li><li>  Drittens ist eine gute Idee, f√ºr diese Methode finden Sie gen√ºgend Forschung und Beispiele.  Aber in CSA gibt es keinen fertigen Makel.  In den Quellen befindet sich ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pr√ºfer</a> , der sp√§ter zur Liste der Alpha-Pr√ºfer (alpha.security.taint.TaintPropagation) hinzugef√ºgt wurde. Er wird in der Datei <code>GenericTaintChecker.cpp</code> .  Der Checker ist gut, aber nur f√ºr bekannte unsichere E / A-Funktionen von C geeignet. Er "markiert" nur Variablen, die Argumente oder Ergebnisse gef√§hrlicher Funktionen waren.  Zus√§tzlich zu den beschriebenen Optionen sollten globale Variablen, Klassenfelder usw. ber√ºcksichtigt werden, um das "Verteilungs" -Modell korrekt wiederherzustellen. </li></ul><br><p>  Die verbleibende Zeit f√ºr das Praktikum wurde damit verbracht, <code>GenericTaintChecker.cpp</code> lesen und zu versuchen, es an Ihre Bed√ºrfnisse anzupassen.  Es hat bis zum Ende des Semesters nicht erfolgreich geklappt, aber es blieb eine Aufgabe zur Verfeinerung, die bereits √ºber den Umfang der Ausbildung bei DSec hinausging.  W√§hrend der Entwicklung wurde auch klar, dass das Identifizieren gef√§hrlicher Funktionen eine separate Aufgabe ist. Nicht immer gef√§hrliche Stellen im Projekt stammen von einigen Standardfunktionen. Daher wurde dem Pr√ºfer ein Flag hinzugef√ºgt, um eine Liste von Funktionen anzuzeigen, die als ‚Äûvergiftet‚Äú / ‚Äûmarkiert‚Äú gelten. w√§hrend der Verschmutzungsanalyse. <br>  Zus√§tzlich wurde eine Pr√ºfung hinzugef√ºgt, um festzustellen, ob die Variable ein Bitfeld ist.  Bei Standard-CSA-Tools wird die Gr√∂√üe nach Typ bestimmt. Wenn wir mit einem Bitfeld arbeiten, hat seine Gr√∂√üe den Wert des Bittyps des gesamten Felds und nicht die Anzahl der in der Variablendeklaration angegebenen Bits. </p><br><h2 id="chto-v-itoge">  Was ist das ergebnis </h2><br><p>  Derzeit wurde ein einfacher Pr√ºfer implementiert, der nur vor m√∂glichen Ganzzahl√ºberl√§ufen warnen kann.  Eine modifizierte Klasse f√ºr die Verschmutzungsanalyse, die noch viel zu tun hat.  Danach m√ºssen Sie SMT verwenden, um √úberl√§ufe zu bestimmen.  Hierf√ºr eignet sich der Z3 SMT-Solver, der der Clang-Baugruppe in Version 5.0.0 hinzugef√ºgt wurde (gemessen an den Versionshinweisen).  Um den Solver verwenden zu k√∂nnen, muss Clang mit der Option <code>CLANG_ANALYZER_BUILD_Z3=ON</code> werden. Wenn das CSA-Plug-In direkt aufgerufen wird, werden die <code>-Xanalyzer -analyzer-constraints=z3</code> √ºbertragen. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub Results Repository</a> </p><br><h2 id="ssylki">  Referenzen: </h2><br><ol><li><p>  Howard M., Leblanc D., Viega J. "Die 24 S√ºnden der Computersicherheit" </p><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">So schreiben Sie einen Checker in 24 Stunden</a> </p><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Clang Static Analyzer: Ein Checker-Entwicklerhandbuch</a> </p><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CSA Checker Entwicklungshandbuch</a> </p><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dietz W. et al.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grundlegendes zum Ganzzahl√ºberlauf in C / C ++</a> </p><br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de473412/">https://habr.com/ru/post/de473412/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de473394/index.html">Ihr alle l√ºgt! √úber CRM-Werbung</a></li>
<li><a href="../de473396/index.html">Wir brauchen noch eine Bitrix</a></li>
<li><a href="../de473400/index.html">Hochwertige, leichte und anpassungsf√§hige Text-to-Speech-Technologie mit LPCNet</a></li>
<li><a href="../de473406/index.html">Freier Marathon "Data Science and AI: Bringen Sie der Maschine bei, das Skript f√ºr die Serie zu schreiben"</a></li>
<li><a href="../de473408/index.html">Das Debuggen von versteckten Speicherlecks in Ruby</a></li>
<li><a href="../de473416/index.html">ZeroNights 2019 Konferenzprogramm</a></li>
<li><a href="../de473418/index.html">OSCP - Offensive Sicherheit</a></li>
<li><a href="../de473420/index.html">Wir er√∂ffnen die Saison der PHP-Meetups am 2. November in Nischni Nowgorod</a></li>
<li><a href="../de473424/index.html">ARM k√ºndigte die Grafikl√∂sungen Mali-G57 Valhall und Mali-D37 sowie die Neuroprozessoren Ethos-N57 und N37 an</a></li>
<li><a href="../de473426/index.html">Automatisierung von End-2-End-Tests eines integrierten Informationssystems. Teil 1. Organisatorisch</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>