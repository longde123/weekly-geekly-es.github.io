<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüè´ üë´ üòî N√∫meros de lat√™ncia no iPhone üõê üè® üë∏üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="N√∫meros de lat√™ncia que todo programador deve saber - uma tabela com "atrasos que todo programador deve conhecer". Ele cont√©m os valores m√©dios de tem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>N√∫meros de lat√™ncia no iPhone</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/437590/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">N√∫meros de lat√™ncia que todo programador deve saber</a> - uma tabela com "atrasos que todo programador deve conhecer".  Ele cont√©m os valores m√©dios de tempo para executar opera√ß√µes b√°sicas do computador em 2012.  Existem v√°rias visualiza√ß√µes alternativas para esta tabela, e aqui est√° uma delas. <br><br><img src="https://habrastorage.org/webt/oa/i4/ho/oai4hogxseqehs_ciso1lz9q_io.png"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Link</a> para a fonte do esquema</i> <br><br>  Mas qual √© o benef√≠cio para desenvolvedores m√≥veis dessas informa√ß√µes em 2019?  Parece que n√£o, mas <b>Dmitry Kurkin</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">SClown</a> ), da equipe Yandex.Navigator, pensou: ‚ÄúComo seria a mesa para um iPhone moderno?‚Äù  O que aconteceu, em uma vers√£o de texto revisada do relat√≥rio de Dmitry no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AppsConf</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/cyzo48f0exw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Para que √© isso? </h2><br>  Por que os programadores devem conhecer esses n√∫meros?  E eles s√£o relevantes para desenvolvedores m√≥veis?  Existem duas tarefas principais que podem ser resolvidas com a ajuda desses n√∫meros. <br><a name="habracut"></a><br><h3>  Compreendendo a escala de tempo de um computador </h3> <br>  Tome uma situa√ß√£o simples - uma conversa telef√¥nica.  Podemos dizer com facilidade quando esse processo √© r√°pido e quando √© longo: alguns segundos s√£o muito r√°pidos, alguns minutos s√£o uma conversa comum e uma hora ou mais √© muito longa.  Com o carregamento das p√°ginas, √© semelhante: em menos de um segundo - rapidamente, alguns segundos - suport√°vel e um minuto √© um desastre, o usu√°rio pode n√£o esperar pelo download. <br><br>  Mas e opera√ß√µes como adicionar um n√∫mero a uma matriz - a inser√ß√£o r√°pida que as pessoas √†s vezes gostam de falar em entrevistas?  Quanto custa um smartphone?  Nanossegundos, microssegundos ou milissegundos?  Eu conheci poucas pessoas que poderiam dizer que 1 milissegundo √© muito tempo, mas no nosso caso √© assim. <br><br><h3>  A propor√ß√£o da velocidade de v√°rios componentes do computador </h3><br>  O tempo de execu√ß√£o das opera√ß√µes em v√°rios dispositivos pode variar em dezenas ou centenas de vezes.  Por exemplo, o tempo de acesso √† mem√≥ria principal √© 100 vezes diferente do acesso ao cache L1.  Esta √© uma grande diferen√ßa, mas n√£o infinita.  Se tivermos um significado espec√≠fico para isso, ao otimizar nossos aplicativos, podemos avaliar se haver√° um ganho de tempo ou n√£o. <br><br><img src="https://habrastorage.org/webt/km/q5/ze/kmq5zekztqx_yhwcoyrjomhjcy4.png"><br><br><h2>  "N√∫meros de lat√™ncia" na vida real </h2><br>  Quando vi esses n√∫meros, fiquei interessado na diferen√ßa entre o cache e o acesso √† mem√≥ria.  Se eu colocar meus dados com cuidado em 64 Kbytes, que n√£o s√£o t√£o pequenos, meu c√≥digo funcionar√° 100 vezes mais r√°pido - √© r√°pido, tudo voar√°! <br><br><img src="https://habrastorage.org/webt/-p/oh/fh/-pohfhloth8e4c-8sl2i5jdmbi4.png"><br><br>  Eu imediatamente quis verificar tudo, mostr√°-lo aos meus colegas e aplic√°-lo sempre que poss√≠vel.  Decidi come√ßar com a ferramenta padr√£o que a Apple oferece - XCTest com measureBlock.  O teste foi organizado da seguinte maneira: alocou uma matriz, preencheu-a com n√∫meros, seus XOR'il e repetiu o algoritmo 10 vezes, com certeza.  Depois disso, observei quanto tempo leva para um elemento. <br><br><table><tbody><tr><td>  <b>Tamanho do buffer</b> </td><td>  <b>Tempo total</b> </td><td>  <b>Hora da cirurgia</b> </td></tr><tr><td>  50 kb </td><td>  1,5 ms </td><td>  30 ns </td></tr><tr><td>  500 kb </td><td>  12 ms </td><td>  24 ns </td></tr><tr><td>  5000 kb </td><td>  85 ms </td><td>  17 ns </td></tr></tbody></table><br>  O tamanho do buffer aumentou 100 vezes, e o tempo para a opera√ß√£o n√£o apenas n√£o aumentou 100 vezes, mas diminuiu quase 2 vezes.  <i>Senhores, oficiais, eles nos traiu ?!</i> <br><br>  Ap√≥s esse resultado, surgiram grandes d√∫vidas em mim de que esses n√∫meros podem ser vistos na vida real.  Pode n√£o ser poss√≠vel para um aplicativo regular perceber essa diferen√ßa.  Ou talvez na plataforma m√≥vel tudo esteja diferente. <br><br>  Comecei a procurar uma maneira de ver a diferen√ßa no desempenho entre caches e mem√≥ria principal.  Durante a pesquisa, me deparei com um artigo em que o autor reclamou que ele tinha uma refer√™ncia em execu√ß√£o no seu Mac e iPhone e n√£o mostrou esses atrasos.  Peguei essa ferramenta e obtive o resultado - assim como em uma farm√°cia.  O tempo de acesso √† mem√≥ria aumentou bastante quando o tamanho do buffer excedeu o tamanho do cache correspondente. <br><br><img src="https://habrastorage.org/webt/he/_q/k8/he_qk85tbetz4emjxbp5znbqidc.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O LMbench</a> me ajudou a obter esses resultados.  Este √© um benchmark criado por Larry McVoy, um dos desenvolvedores do kernel Linux, que permite medir o tempo de acesso √† mem√≥ria, o custo da troca de threads e opera√ß√µes do sistema de arquivos e at√© o tempo que as principais opera√ß√µes do processador levam: adi√ß√£o, subtra√ß√£o, etc. De acordo com este benchmark A Texas Instruments apresentou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dados de</a> medi√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">interessantes</a> para seus processadores.  O LMBench est√° escrito em C, por isso n√£o foi dif√≠cil execut√°-lo no iOS. <br><br><h2>  Custos de mem√≥ria </h2><br>  Armado com uma ferramenta t√£o maravilhosa, decidi fazer medi√ß√µes semelhantes, mas para um dispositivo m√≥vel real - para o iPhone.  As principais medidas foram feitas no 5S e, em seguida, obtive os resultados quando outros dispositivos ca√≠ram em minhas m√£os.  Portanto, se o dispositivo n√£o for especificado, ser√° 5S. <br><br><h3>  Acesso √† mem√≥ria </h3><br>  Para este teste, √© usada uma matriz especial, que √© preenchida com elementos que se referem um ao outro.  Cada um dos elementos √© um ponteiro para outro elemento.  A matriz n√£o √© atravessada pelo √≠ndice, mas pelas transi√ß√µes de um n√≥ para outro.  Esses elementos est√£o espalhados por toda a matriz, de modo que, ao acessar um novo elemento, sempre que poss√≠vel, ele n√£o estava no cache, mas era descarregado da RAM.  Esse arranjo interfere nos caches o m√°ximo poss√≠vel. <br><br>  Voc√™ j√° viu o resultado preliminar.  No caso do cache L1, √© inferior a 10 nanossegundos, para L2 s√£o algumas dezenas de nanossegundos e, no caso da mem√≥ria principal, o tempo aumenta para centenas de nanossegundos. <br><br><img src="https://habrastorage.org/webt/6u/dk/f0/6udkf0ihlo3lgfqhntfkzp3vshm.png"><br><br><h3>  Velocidade de leitura e grava√ß√£o </h3><br>  Tr√™s opera√ß√µes principais s√£o medidas: <br><br><ul><li>  leitura ( <em>p [i] +</em> ) - lemos os elementos e os adicionamos ao valor total; </li><li>  registro ( <em>p [i] = 1</em> ) - um n√∫mero constante √© escrito em cada elemento; </li><li>  leitura e escrita ( <em>p [i] = p [i] * 2</em> ) - retiramos o elemento, alteramos e escrevemos o novo valor de volta. </li></ul><br>  Ao trabalhar com o buffer, duas abordagens s√£o usadas: no primeiro caso, apenas cada quarto elemento √© usado e, no segundo, todos os elementos s√£o seq√ºenciais. <br><br><img src="https://habrastorage.org/webt/yr/ke/ia/yrkeiaf0vzc47trw7wc_hypse-s.png"><br><br>  A velocidade mais alta √© obtida com um tamanho de buffer pequeno e, em seguida, h√° etapas claras, de acordo com os tamanhos dos caches L1 e L2.  O mais interessante √© que, quando os dados s√£o lidos sequencialmente, n√£o ocorre redu√ß√£o de velocidade.  Mas no caso de passes, etapas claras s√£o vis√≠veis. <br><br><img src="https://habrastorage.org/webt/2t/-d/_6/2t-d_68-oyjigkraj2mpirwjzfw.png"><br><br>  Durante a leitura seq√ºencial, o sistema operacional consegue carregar os dados necess√°rios no cache, portanto, para qualquer tamanho de buffer, n√£o preciso acessar a mem√≥ria - todos os dados necess√°rios s√£o obtidos no cache.  Isso explica por que n√£o vi a diferen√ßa hor√°ria no meu teste b√°sico. <br><br>  Os resultados das medi√ß√µes das opera√ß√µes de leitura e grava√ß√£o mostraram que em uma aplica√ß√£o normal √© bastante dif√≠cil obter a acelera√ß√£o estimada de 100 vezes.  Por um lado, o pr√≥prio sistema armazena em cache os dados muito bem e, mesmo com grandes matrizes, √© muito prov√°vel que encontremos dados no cache.  Por outro lado, trabalhar com v√°rias vari√°veis ‚Äã‚Äãpode facilmente exigir acesso √† mem√≥ria e a perda de centenas de nanossegundos conquistados. <br><br><table><tbody><tr><td></td><td>  <b>L1</b> </td><td>  <b>L2</b> </td><td>  <b>Mem√≥ria</b> </td></tr><tr><td>  N√∫meros de lat√™ncia </td><td>  1 ns </td><td>  7 ns </td><td>  100 ns </td></tr><tr><td>  iPhone 5s </td><td>  7 ns </td><td>  30 ns </td><td>  240 ns </td></tr><tr><td>  iPhone 6s Plus </td><td>  5 ns </td><td>  12 ns </td><td>  200 ns </td></tr><tr><td>  iPhone X </td><td>  2 ns </td><td>  12 ns </td><td>  146 ns </td></tr></tbody></table><br><h2>  Custos de rosqueamento </h2><br>  Em seguida, queria obter dados semelhantes para trabalhar com threads, a fim de <strong>entender o custo do uso de multithreading</strong> : quanto custa criar uma thread e alternar de uma thread para outra.  Para n√≥s, essas s√£o opera√ß√µes frequentes e quero entender a perda. <br><br><h3>  Instrumentos.  Rastreio do sistema </h3><br>  O System Trace ajuda muito a rastrear o trabalho dos threads no aplicativo.  Esta ferramenta foi descrita em alguns detalhes na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">WWDC 2016</a> .  A ferramenta ajuda a ver transi√ß√µes por condi√ß√µes de fluxo e apresenta dados sobre fluxos em tr√™s categorias principais: chamadas do sistema, trabalhando com condi√ß√µes de mem√≥ria e fluxo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hs/gx/kq/hsgxkqsh5khfclg4gncfbksihya.png" width="500"></div><br><br><ol><li>  <strong>Chamadas do sistema</strong>  Eles s√£o apresentados na forma de "salsichas" vermelhas.  Quando voc√™ os aponta, pode ver o nome do m√©todo do sistema e a dura√ß√£o da execu√ß√£o.  Freq√ºentemente, em aplicativos de aplicativos, essa chamada de sistema n√£o ocorre diretamente: usamos algo que, por sua vez, j√° chama o m√©todo de sistema.  Voc√™ n√£o deve confiar no fato de que aqui os m√©todos do seu c√≥digo estar√£o vis√≠veis. </li><li>  <strong>Opera√ß√µes de mem√≥ria</strong> .  Eles s√£o apresentados na forma de "salsichas" azuis.  Isso inclui opera√ß√µes como aloca√ß√£o de mem√≥ria, libera√ß√£o, zeramento, etc. </li><li>  <strong>Status do fluxo</strong> .  Cor azul - um segmento est√° sendo executado, algum processador est√° executando o c√≥digo desse segmento.  Cinza - o encadeamento est√° bloqueado por algum motivo e n√£o pode continuar a execu√ß√£o.  Vermelho - o thread est√° pronto para funcionar, mas neste momento n√£o h√° kernel livre para executar seu c√≥digo.  Cor laranja - o fluxo √© interrompido para trabalhos com prioridade mais alta. </li><li> <strong>Pontos de interesse</strong> .  Esses s√£o r√≥tulos especiais que podem ser organizados por c√≥digo chamando <code>kdebug_signpost</code> .  Os r√≥tulos podem ser √∫nicos (um local espec√≠fico no c√≥digo) ou como um intervalo (para destacar todo o procedimento).  Usando esses r√≥tulos, √© muito mais f√°cil correlacionar microssegundos e chamadas do sistema com seu aplicativo. </li></ol><br><h3>  Custos de cria√ß√£o de stream </h3><br>  O primeiro teste √© a <strong>execu√ß√£o de uma tarefa em um novo thread</strong> .  Criamos um encadeamento com um determinado procedimento e esperamos que ele conclua seu trabalho.  Comparando o tempo total com o tempo do pr√≥prio procedimento, obtemos a perda total para iniciar o procedimento em um novo encadeamento. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m3/ln/wa/m3lnwaf0zdjx7b7suyujhp9eywu.png" width="600"></div><br><br>  No System Trace, voc√™ pode ver claramente como tudo realmente acontece: <br><br><img src="https://habrastorage.org/webt/wh/ta/qd/whtaqdwmfal7dyi4d-fs_22oir0.png"><br><br><ol><li>  Crie fluxo. </li><li>  O novo encadeamento no qual nosso procedimento √© executado.  A zona vermelha no in√≠cio diz que o encadeamento foi criado, mas por algum tempo n√£o p√¥de ser executado, pois n√£o havia n√∫cleo livre. </li><li>  A conclus√£o do fluxo.  Curiosamente, o pr√≥prio procedimento de conclus√£o de encadeamento √© ainda maior que sua cria√ß√£o.  Embora pare√ßa que a exclus√£o seja sempre mais r√°pida. </li><li>  Aguardando a conclus√£o do procedimento, que estava no esquema original, e termina ap√≥s o t√©rmino do fluxo - por um tempo o m√©todo percebe isso e, depois disso, relat√≥rios.  Esse tempo √© um pouco mais longo que a conclus√£o do fluxo. </li></ol><br>  Como resultado, a cria√ß√£o de um fluxo requer custos bastante significativos: iPhone 5S - 230 microssegundos, 6S - 50 microssegundos.  <b>A conclus√£o do fluxo leva quase duas vezes mais tempo que a cria√ß√£o</b> ; a jun√ß√£o tamb√©m leva um tempo tang√≠vel.  Ao trabalhar com mem√≥ria, obtivemos centenas de nanossegundos, que s√£o 100 vezes menos que dezenas de microssegundos. <br><br><table><tbody><tr><td></td><td>  <b>sobrecarga</b> </td><td>  <b>criar</b> </td><td>  <b>fim</b> </td><td>  <b>juntar</b> </td></tr><tr><td>  iPhone 5s </td><td>  230 Œºs </td><td>  40 Œºs </td><td>  70 Œºs </td><td>  30 Œºs </td></tr><tr><td>  iPhone 6s Plus </td><td>  50 Œºs </td><td>  12 Œºs </td><td>  20 Œºs </td><td>  7 Œºs </td></tr></tbody></table><br><h3>  Tempo de comuta√ß√£o do sem√°foro </h3><br>  O pr√≥ximo teste √© <strong>medi√ß√µes no trabalho do sem√°foro</strong> .  Temos 2 threads pr√©-criados, e para cada um deles existe um sem√°foro.  Os c√≥rregos sinalizam alternadamente o sem√°foro do vizinho e esperam pelo seu.  Passando sinais um para o outro, os fluxos jogam pingue-pongue, revivem um ao outro.  Essa itera√ß√£o dupla fornece tempo de comuta√ß√£o de sem√°foro duplo. <br><br><img src="https://habrastorage.org/webt/nf/de/iq/nfdeiqezf1edyugn_lkccjocndy.png"><br><br>  No System Trace, tudo parece semelhante: <br><br><ol><li>  Um sinal √© dado para o sem√°foro do segundo fluxo.  Pode-se ver que esta opera√ß√£o √© muito curta. </li><li>  O segundo segmento √© desbloqueado, a espera no seu sem√°foro termina. </li><li>  Um sinal √© dado para o sem√°foro do primeiro fluxo. </li><li>  O primeiro encadeamento √© desbloqueado, a espera em seu sem√°foro termina. </li></ol><br><img src="https://habrastorage.org/webt/0e/jn/mb/0ejnmb3dxvozsz-h0zaijdl_3xm.png"><br><br>  O tempo de troca foi de 10 microssegundos.  A diferen√ßa de criar um encadeamento 50 vezes √© exatamente o motivo pelo qual os conjuntos de encadeamentos s√£o criados, e n√£o um novo encadeamento para cada procedimento. <br><br><h3>  Perdas na altern√¢ncia de contexto do encadeamento do sistema </h3><br>  Nos dois testes anteriores, a transfer√™ncia de controle entre os threads foi completamente controlada - entendemos claramente onde e onde a transi√ß√£o deveria ocorrer.  No entanto, muitas vezes acontece que o pr√≥prio sistema alterna de um thread para outro.  Quando executamos mais tarefas em paralelo do que os n√∫cleos do dispositivo, o sistema operacional deve poder mudar automaticamente para fornecer a todos tempo de processador. <br><br>  Neste teste, eu queria medir a perda de iniciar muitos threads.  Para isso, √© criado um pool de 16 threads, cada um aguardando um sem√°foro e, assim que recebe um sinal, executa um determinado procedimento e sinaliza o sem√°foro de volta.  O thread principal inicia o pool inteiro, emitindo 16 sinais e depois espera 16 sinais em resposta. <br><br><img src="https://habrastorage.org/webt/fv/ki/an/fvkiang1lid-dgw6bmddnudyjro.png"><br><br>  No System Trace, voc√™ pode ver que os blocos est√£o espalhados aleatoriamente, alguns deles s√£o muito mais longos que os demais.  Se v√°rias comuta√ß√µes levarem a um aumento no tempo de execu√ß√£o da opera√ß√£o, o tempo m√©dio de execu√ß√£o dever√° aumentar como resultado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ar/0b/r6/ar0br6h-8hm8qwmlyokuots92au.png" width="500"></div><br>  <b>No entanto, com um aumento no n√∫mero de threads, o tempo m√©dio de opera√ß√£o n√£o aumenta.</b> <br><br>  Em teoria, o tempo m√©dio deve ser mantido enquanto a carga corresponder √† pot√™ncia de processamento.  Ou seja, o n√∫mero de tarefas corresponde ao n√∫mero de n√∫cleos. <br><br><img src="https://habrastorage.org/webt/9r/8l/-p/9r8l-p83_ad6ibrit6ee2d67cwa.png"><br><br>  Se voc√™ executar muitas tarefas em paralelo, o sistema operacional, alternando de uma tarefa para outra, apresentar√° atrasos adicionais.  Isso deve se refletir no resultado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fe/0x/ko/fe0xko9wqlkfu5nt4n0fonqcrfs.png"></div><br>  Na pr√°tica, n√£o apenas nosso aplicativo funciona no dispositivo, mas ainda possui muitos processos paralelos e de sistema.  At√© o √∫nico thread em nosso aplicativo ser√° afetado pela altern√¢ncia, o que leva a interrup√ß√µes e atrasos.  Portanto, em todas as situa√ß√µes, h√° atrasos e n√£o h√° diferen√ßa entre criar tarefas em s√©rie ou executar em paralelo. <br><br><img src="https://habrastorage.org/webt/by/io/c4/byioc4ax6qgcuwxpkmjhpfyaaeg.png"><br><br>  Abaixo est√° nossa tabela de n√∫meros de lat√™ncia com dados sobre fluxos e sem√°foros. <br><br><table><tbody><tr><td></td><td>  <b>L1</b> </td><td>  <b>L2</b> </td><td>  <b>Mem√≥ria</b> </td><td>  <b>Sem√°foro</b> </td></tr><tr><td>  N√∫meros de lat√™ncia </td><td>  1 ns </td><td>  7 ns </td><td>  100 ns </td><td>  25 ns </td></tr><tr><td>  iPhone 5s </td><td>  7 ns </td><td>  30 ns </td><td>  240 ns </td><td>  8 Œºs </td></tr><tr><td>  iPhone 6s Plus </td><td>  5 ns </td><td>  12 ns </td><td>  200 ns </td><td>  5 Œºs </td></tr><tr><td>  iPhone X </td><td>  2 ns </td><td>  12 ns </td><td>  146 ns </td><td>  3,2 Œºs </td></tr></tbody></table><br><h2>  Custos de arquivo </h2><br>  J√° temos mem√≥ria e threads - para completar, precisamos apenas de opera√ß√µes do sistema de arquivos. <br><br><h3>  Ler arquivo </h3><br>  O primeiro teste √© a <strong>velocidade de leitura</strong> - quanto custa ler um arquivo.  O teste consiste em duas partes.  Na primeira, <strong>medimos a velocidade de leitura,</strong> levando em considera√ß√£o a abertura, leitura e fechamento do arquivo.  No segundo, <strong>assumimos que o arquivo est√° constantemente aberto</strong> : nos posicionamos em algum lugar e lemos o quanto queremos. <br><br>  Os resultados s√£o exibidos corretamente de dois pontos de vista.  <strong>Quando o arquivo √© pequeno</strong> , h√° um tempo m√≠nimo para ler os dados do arquivo.  At√© um kilobyte √© de 5,3 microssegundos - n√£o importa: 1 byte, 2 ou 1 KB - para todos os 5,3 Œºs.  Portanto, voc√™ pode falar sobre velocidade apenas no caso de arquivos grandes, quando o tempo fixo j√° pode ser negligenciado.  A opera√ß√£o para abrir e fechar o arquivo leva aproximadamente o mesmo tempo para qualquer tamanho de arquivo - no caso do 5S, cerca de 50 microssegundos. <br><br><img src="https://habrastorage.org/webt/zv/na/-2/zvna-2en_axstzffeo9iru-bpuo.png"><br><br>  Para velocidade de leitura, esses gr√°ficos s√£o obtidos. <br><br><img src="https://habrastorage.org/webt/h4/2g/ri/h42griw_vpjjlfgkpxdbty3c8yw.png"><br><br>  Para o iPhone X e um arquivo de 1 MB, a velocidade pode chegar a 20 MB / s.  Curiosamente, a leitura de um arquivo de 1 MB √© mais eficiente.  Com tamanhos grandes de arquivo, os tamanhos de cache parecem ser afetados.  √â por isso que a velocidade diminui ainda mais e se equilibra na regi√£o de 10 Mb. <br><br><h3>  Crie e exclua arquivos </h3><br>  O teste consiste na etapa de <strong>cria√ß√£o de um arquivo, grava√ß√£o de dados</strong> e <strong>exclus√£o dos</strong> arquivos criados.  O resultado √© gradual: em tamanhos pequenos, o tempo √© est√°vel - cerca de 7 Œºs e continua crescendo.  A escala √© logar√≠tmica. <br><br><img src="https://habrastorage.org/webt/da/xn/sp/daxnspzyy0raugagyluwnkwjqhs.png"><br><br>  Fiquei surpreso que o tempo necess√°rio para excluir um arquivo grande seja proporcional ao tempo necess√°rio para criar, pois eu supus que a exclus√£o seja uma opera√ß√£o r√°pida.  Acontece que n√£o, para o iPhone, a exclus√£o a tempo √© compar√°vel √† cria√ß√£o de um arquivo.  A tabela de resumo fica assim. <br><br><table><tbody><tr><td></td><td>  <b>L1</b> </td><td>  <b>L2</b> </td><td>  <b>Mem√≥ria</b> </td><td>  <b>Sem√°foro</b> </td><td>  <b>Disco</b> </td></tr><tr><td>  N√∫meros de lat√™ncia </td><td>  1 ns </td><td>  7 ns </td><td>  100 ns </td><td>  25 ns </td><td>  150 Œºs </td></tr><tr><td>  iPhone 5s </td><td>  7 ns </td><td>  30 ns </td><td>  240 ns </td><td>  8 Œºs </td><td>  5 Œºs </td></tr><tr><td>  iPhone 6s Plus </td><td>  5 ns </td><td>  12 ns </td><td>  200 ns </td><td>  5 Œºs </td><td>  4 Œºs </td></tr><tr><td>  iPhone X </td><td>  2 ns </td><td>  12 ns </td><td>  146 ns </td><td>  3,2 Œºs </td><td>  1,3 Œºs </td></tr></tbody></table><br><h2>  Conclus√£o </h2><br>  Com base nessas medi√ß√µes, agora temos uma id√©ia de quanto tempo as opera√ß√µes b√°sicas do iOS exigem: acessar a mem√≥ria em nanossegundos, trabalhar com arquivos em microssegundos, criar um fluxo em dezenas de microssegundos e alternar em apenas alguns microssegundos. <br><br>  Para obter uma interrup√ß√£o fisicamente vis√≠vel no aplicativo, o tempo de execu√ß√£o do procedimento deve exceder 15 milissegundos (o tempo necess√°rio para atualizar a tela a 60fps).  Isso √© quase mil vezes maior que a maioria das medi√ß√µes feitas no artigo.  Nessa escala, um milissegundo √© bastante, e um segundo j√° √© "para sempre". <br><br>  Os testes mostraram que, apesar da grande diferen√ßa no tempo de acesso √† mem√≥ria e aos caches, o uso direto dessa taxa √© bastante dif√≠cil.  Antes de compilar todos os seus dados no L1, voc√™ precisa garantir que, no seu caso, realmente d√™ um resultado. <br><br>  De acordo com os testes de opera√ß√µes com encadeamentos, fomos capazes de garantir que a cria√ß√£o e destrui√ß√£o de encadeamentos demandem um tempo consider√°vel, mas a execu√ß√£o de um grande n√∫mero de opera√ß√µes paralelas n√£o gera custos adicionais. <br><br>  Bem, para concluir, gostaria de lembr√°-lo da regra mais importante ao trabalhar no desempenho - <b>primeiras medi√ß√µes e somente ent√£o otimiza√ß√£o</b> ! <br><br>  Orador de perfil Dmitry Kurkin no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> . <br><br><blockquote>  A convers√£o e transforma√ß√£o dos relat√≥rios do AppsConf 2018 em artigos √© paralela √† <b>prepara√ß√£o da nova confer√™ncia de</b> 2019.  At√© o momento, existem apenas 7 t√≥picos na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">lista de relat√≥rios aceitos</a> , mas essa lista ser√° expandida o tempo todo para que ocorra uma confer√™ncia interessante para desenvolvedores m√≥veis <b>nos dias 22 e 23 de abril</b> . <br><br>  Siga as publica√ß√µes, assine o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">canal</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">youtube</a> e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">boletim informativo,</a> e dessa vez voar√° rapidamente. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt437590/">https://habr.com/ru/post/pt437590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt437580/index.html">Como lembrar de um livro sobre JavaScript em 5 dias ou do ‚ÄúPal√°cio da Mem√≥ria‚Äù na vida cotidiana de um programador</a></li>
<li><a href="../pt437582/index.html">Vis√£o geral do Vue.js 2.6</a></li>
<li><a href="../pt437584/index.html">Os princ√≠pios matem√°ticos do layout autom√°tico</a></li>
<li><a href="../pt437586/index.html">Criamos um aplicativo de voz usando o exemplo do Google Assistant</a></li>
<li><a href="../pt437588/index.html">√â mais divertido desenvolver para telefones celulares do que para a web?</a></li>
<li><a href="../pt437592/index.html">Arquitetura ass√≠ncrona da camada de execu√ß√£o de tarefas</a></li>
<li><a href="../pt437594/index.html">Como eu erradiquei a causa da gagueira e do salto de quadros em todos os jogos e tamb√©m reduzi acidentalmente a temperatura em 15 graus</a></li>
<li><a href="../pt437596/index.html">OTRS: autentica√ß√£o, autoriza√ß√£o e sincroniza√ß√£o LDAP (FreeIPA, AD)</a></li>
<li><a href="../pt437598/index.html">Como salvar o sistema de jogo do PC dom√©stico por meio da virtualiza√ß√£o</a></li>
<li><a href="../pt437600/index.html">opencv4arts: Desenhe minha cidade, Vincent</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>