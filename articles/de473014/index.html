<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏬 👩‍👩‍👧 👪 Einführung in die Kubernetes-Autorisierung von Hashicorp Consul 🙍 👨🏻‍✈️ 👲🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Richtig , nach der Veröffentlichung von Hashicorp Consul 1.5.0 Anfang Mai 2019 in Consul können Sie Anwendungen und Dienste autorisieren, die in Kuber...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einführung in die Kubernetes-Autorisierung von Hashicorp Consul</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nixys/blog/473014/"><img src="https://habrastorage.org/webt/ge/q3/ey/geq3eyqujybgzgmalsngtz3azuu.png"><br><p>  <a href="">Richtig</a> , nach der Veröffentlichung von <a href="">Hashicorp Consul 1.5.0</a> Anfang Mai 2019 in Consul können Sie Anwendungen und Dienste autorisieren, die in Kubernetes nativ ausgeführt werden. </p><br><p>  In diesem Tutorial erstellen wir Schritt für Schritt einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">POC</a> (Proof of Concept, PoC - Proof of Concept), der diese neue Funktion demonstriert. Grundkenntnisse über Kubernetes und Hashicorps Konsul werden von Ihnen erwartet. Und obwohl Sie Sie können jede Cloud-Plattform oder lokale Umgebung verwenden. In diesem Handbuch verwenden wir die Cloud-Plattform von Google. </p><a name="habracut"></a><br><h2>  Rückblick </h2><br><p>  Wenn wir uns der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Consul-Dokumentation zu ihrer Autorisierungsmethode</a> zuwenden, erhalten wir einen kurzen Überblick über ihren Zweck und Anwendungsfall sowie einige technische Details und einen allgemeinen Überblick über die Logik.  Ich empfehle dringend, es mindestens einmal zu lesen, bevor Sie fortfahren, da ich jetzt alles erklären und kauen werde. </p><br><img src="https://habrastorage.org/webt/ca/xp/mp/caxpmprm5u-8bupb1_fpjgehvcw.png"><br><p>  <i>Abbildung 1: Übersicht über die offizielle Konsulautorisierungsmethode</i> </p><br><p>  Werfen wir einen Blick auf die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation zur spezifischen Kubernetes-Autorisierungsmethode</a> . </p><br><p>  Natürlich gibt es nützliche Informationen, aber es gibt keine Anleitung, wie man all dies tatsächlich nutzt.  Daher durchsuchen Sie wie jede vernünftige Person das Internet nach Anleitungen.  Und dann ... besiegt werden.  Es passiert.  Lass es uns reparieren. </p><br><p>  Bevor wir mit der Erstellung unseres POC fortfahren, kehren wir zur Übersicht über die Consul-Autorisierungsmethoden (Abbildung 1) zurück und verfeinern sie im Kontext von Kubernetes. </p><br><h2 id="arhitektura">  Architektur </h2><br><p>  In diesem Handbuch erstellen wir einen Consul-Server auf einem separaten Computer, der mit dem installierten Consul-Client mit dem Kubernetes-Cluster interagiert.  Anschließend erstellen wir unsere Dummy-Anwendung im Kamin und verwenden unsere angepasste Autorisierungsmethode, um aus unserem Konsul-Schlüssel- / Wert-Repository zu lesen. </p><br><p>  Das folgende Diagramm zeigt detailliert die Architektur, die wir in diesem Handbuch erstellen, sowie die Logik der Autorisierungsmethode, die später erläutert wird. </p><br><img src="https://habrastorage.org/webt/az/zn/kj/azznkjy-wrxrndezbwxezarbs-4.png"><br><p>  <em>Abbildung 2: Übersicht über die Autorisierungsmethode in Kubernetes</em> </p><br><p>  Ein kurzer Hinweis: Der Konsulsserver muss nicht außerhalb des Kubernetes-Clusters leben, damit dies funktioniert.  Aber ja, er kann dies und das tun. </p><br><p> Wenn wir also das Konsul-Übersichtsdiagramm (Schema 1) nehmen und Kubernetes darauf anwenden, erhalten wir das obige Diagramm (Schema 2), und hier lautet die Logik wie folgt: </p><br><ol><li>  Jedem Pod ist ein Dienstkonto beigefügt, das ein von Kubernetes generiertes und bekanntes JWT-Token enthält.  Dieses Token wird standardmäßig auch in das Sub eingefügt. </li><li>  Unsere Anwendung oder unser Service im Kamin löst einen Befehl zur Eingabe unseres Konsul-Clients aus.  In der Anmeldeanforderung werden auch unser Token und der Name einer <strong>speziell erstellten</strong> Autorisierungsmethode (z. B. Kubernetes) angegeben.  Dieser Schritt Nr. 2 entspricht Schritt 1 des Konsulschemas (Schema 1). </li><li>  Unser Consul-Client leitet diese Anfrage dann an unseren Consul-Server weiter. </li><li>  MAGIE!  Hier überprüft der Consul-Server die Authentizität der Anforderung, sammelt Informationen über die Identität der Anforderung und vergleicht sie mit den zugehörigen vordefinierten Regeln.  Unten sehen Sie ein weiteres Diagramm, um dies zu veranschaulichen.  Dieser Schritt entspricht den Schritten 3, 4 und 5 des Konsul-Übersichtsdiagramms (Schema 1). </li><li>  Unser Consul-Server generiert ein Consul-Token mit Berechtigungen gemäß den Regeln der Autorisierungsmethode, die wir in Bezug auf die Identität des Anforderers angegeben haben (die wir festgelegt haben).  Dann wird er diesen Token zurückschicken.  Dies entspricht Schritt 6 des Konsulschemas (Schema 1). </li><li>  Unser Consul-Client leitet das Token an die anfordernde Anwendung oder den anfordernden Dienst weiter. </li></ol><br><p>  Unsere Anwendung oder unser Dienst kann dieses Consul-Token jetzt verwenden, um mit unseren Consul-Daten zu kommunizieren, wie durch die Token-Berechtigungen bestimmt. </p><br><h2 id="volshebstvo-raskryto">  Die Magie wird offenbart! </h2><br><p>  Für diejenigen unter Ihnen, die nicht nur mit dem Kaninchen im Hut zufrieden sind und wissen möchten, wie es funktioniert ... lassen Sie mich "Ihnen zeigen, wie tief das <strong>Kaninchenloch ist</strong> ". </p><br><p>  Wie bereits erwähnt, besteht unser „magischer“ Schritt (Schema 2: Schritt 4) darin, dass der Consul-Server die Authentizität der Anforderung überprüft, Informationen über die Anforderung sammelt und diese mit den zugehörigen vordefinierten Regeln vergleicht.  Dieser Schritt entspricht den Schritten 3, 4 und 5 des Konsul-Übersichtsdiagramms (Schema 1).  Unten sehen Sie ein Diagramm (Schema 3), mit dem klar dargestellt werden soll, was tatsächlich <em>unter der Haube einer</em> bestimmten Kubernetes-Autorisierungsmethode geschieht. </p><br><img src="https://habrastorage.org/webt/5e/5w/eg/5e5wegybhhtjkwkotfs1disgzc8.png"><br><p>  <em>Schema 3: Die Magie wird enthüllt!</em> </p><br><ol><li>  Als Ausgangspunkt leitet unser Consul-Client die Anmeldeanforderung mit dem Kubernetes-Kontotoken und dem spezifischen Namen der Instanz der zuvor erstellten Autorisierungsmethode an unseren Consul-Server weiter.  Dieser Schritt entspricht Schritt 3 in der vorherigen Erläuterung der Schaltung. </li><li>  Jetzt muss der Consul-Server (oder Leader) die Authentizität des empfangenen Tokens überprüfen.  Daher wird er sich mit dem Kubernetes-Cluster (über den Consul-Client) beraten und mit den entsprechenden Berechtigungen herausfinden, ob das Token echt ist und wem es gehört. </li><li>  Anschließend wird die verifizierte Anforderung an den Konsulleiter zurückgegeben, und der Konsul-Server sucht in der Anmeldeanforderung nach einer Instanz der Autorisierungsmethode mit dem angegebenen Namen (und gibt Kubernetes ein). </li><li>  Der Konsulführer bestimmt die angegebene Instanz der Autorisierungsmethode (falls eine gefunden wird) und liest die damit verbundenen Bindungsregeln.  Anschließend liest er diese Regeln und vergleicht sie mit verifizierten Identitätsattributen. </li><li>  Tada!  Fahren Sie mit Schritt 5 in der vorherigen Erläuterung der Schaltung fort. </li></ol><br><h2 id="zapustite-consul-server-na-obychnoy-virtualnoy-mashine">  Führen Sie Consul-Server auf einer normalen virtuellen Maschine aus </h2><br><p>  Von nun an werde ich hauptsächlich Anweisungen zum Erstellen dieses POC geben, oft in Punkten, ohne erklärende ganze Sätze.  Wie bereits erwähnt, werde ich GCP verwenden, um die gesamte Infrastruktur zu erstellen, aber Sie können dieselbe Infrastruktur überall anders erstellen. </p><br><ul><li>  Starten Sie die virtuelle Maschine (Instanz / Server). </li></ul><br><img src="https://habrastorage.org/webt/gg/5m/j-/gg5mj-dyw9frdaglrfwizvbkna8.png"><br><ul><li>  Erstellen Sie eine Regel für die Firewall (Sicherheitsgruppe in AWS): </li><li>  Ich möchte der Regel und dem Netzwerk-Tag den gleichen Computernamen zuweisen, in diesem Fall ist es "skywiz-consul-server-poc". </li><li>  Suchen Sie die IP-Adresse Ihres lokalen Computers und fügen Sie sie der Liste der Quell-IP-Adressen hinzu, damit wir auf die Benutzeroberfläche zugreifen können. </li><li>  Öffnen Sie Port 8500 für die Benutzeroberfläche.  Klicken Sie auf Erstellen.  Wir werden diese Firewall [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> ] bald wieder ändern. </li><li>  Fügen Sie der Instanz die Regel für die Firewall hinzu.  Kehren Sie zum VM-Dashboard auf dem Consul-Server zurück und fügen Sie dem Feld "Netzwerk-Tag" "skywiz-consul-server-poc" hinzu.  Klicken Sie auf Speichern. </li></ul><br><img src="https://habrastorage.org/webt/o3/7i/52/o37i52gc_8k8fxu4ve113oh7ljc.png"><br><ul><li>  Installieren Sie Consul auf einer virtuellen Maschine. Überprüfen Sie dies hier.  Denken Sie daran, dass Sie die Consul-Version ≥ 1.5 benötigen [Link] </li><li>  Erstellen Sie einen Konsul mit einem einzelnen Knoten - die Konfiguration ist wie folgt. </li></ul><br><pre><code class="plaintext hljs">groupadd --system consul useradd -s /sbin/nologin --system -g consul consul mkdir -p /var/lib/consul chown -R consul:consul /var/lib/consul chmod -R 775 /var/lib/consul mkdir /etc/consul.d chown -R consul:consul /etc/consul.d</code> </pre> <br><ul><li>  Eine ausführlichere Anleitung zur Installation von Consul und zum Einrichten eines Clusters mit 3 Knoten finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </li><li>  Erstellen Sie die Datei /etc/consul.d/agent.json wie folgt [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> ]: </li></ul><br><pre> <code class="plaintext hljs">### /etc/consul.d/agent.json { "acl" : { "enabled": true, "default_policy": "deny", "enable_token_persistence": true } }</code> </pre> <br><ul><li>  Starten Sie unseren Consul-Server: </li></ul><br><pre> <code class="plaintext hljs">consul agent \ -server \ -ui \ -client 0.0.0.0 \ -data-dir=/var/lib/consul \ -bootstrap-expect=1 \ -config-dir=/etc/consul.d</code> </pre> <br><ul><li>  Sie sollten eine Reihe von Ausgaben sehen und am Ende "... Update durch ACLs blockiert" erhalten. </li><li>  Suchen Sie die externe IP-Adresse des Consul-Servers und öffnen Sie einen Browser mit dieser IP-Adresse an Port 8500. Stellen Sie sicher, dass die Benutzeroberfläche geöffnet ist. </li><li>  Versuchen Sie, ein Schlüssel / Wert-Paar hinzuzufügen.  Es muss ein Fehler sein.  Dies liegt daran, dass wir den Consul-Server mithilfe der ACL geladen und alle Regeln abgelehnt haben. </li><li>  Kehren Sie zu Ihrer Shell auf dem Consul-Server zurück, starten Sie den Vorgang im Hintergrund oder auf andere Weise, damit er funktioniert, und geben Sie Folgendes ein: </li></ul><br><pre> <code class="plaintext hljs">consul acl bootstrap</code> </pre> <br><ul><li>  Suchen Sie den Wert "SecretID" und kehren Sie zur Benutzeroberfläche zurück.  Geben Sie auf der Registerkarte ACL die geheime Kennung des gerade kopierten Tokens ein.  Kopieren Sie SecretID woanders, wir werden es später brauchen. </li><li>  Fügen Sie nun ein Schlüssel / Wert-Paar hinzu.  Fügen Sie für diesen POC Folgendes hinzu: key: "custom-ns / test_key", Wert: "Ich bin im Ordner custom-ns!" </li></ul><br><h2 id="zapusk-kubernetes-klastera-dlya-nashego-prilozheniya-s-consul-klientom-v-kachestve-daemonset">  Starten Sie Kubernetes Cluster für unsere Anwendung mit Consul Client als Daemonset </h2><br><ul><li>  Erstellen Sie einen K8s-Cluster (Kubernetes).  Wir werden es für den schnelleren Zugriff in derselben Zone wie der Server erstellen und können daher dasselbe Subnetz für die einfache Verbindung mit internen IP-Adressen verwenden.  Wir werden es skywiz-app-with-consul-client-poc nennen. </li></ul><br><img src="https://habrastorage.org/webt/_l/vp/gu/_lvpgupywaktqzykauebirhibm0.png"><br><ul><li>  Hier ist eine gute Anleitung, die mir beim Einrichten eines POC Consul-Clusters mit Consul Connect begegnet ist. </li><li>  Wir werden auch das Hashicorp-Helmdiagramm mit einer erweiterten Wertedatei verwenden. </li><li>  Helm installieren und konfigurieren.  Konfigurationsschritte: </li></ul><br><pre> <code class="plaintext hljs">kubectl create serviceaccount tiller --namespace kube-system kubectl create clusterrolebinding tiller-admin-binding \ --clusterrole=cluster-admin --serviceaccount=kube-system:tiller ./helm init --service-account=tiller ./helm update</code> </pre> <br><ul><li>  Steuerkarte: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.consul.io/docs/platform/k8s/helm.html</a> </li><li>  Verwenden Sie die folgende Wertedatei (beachten Sie, dass die meisten deaktiviert sind): </li></ul><br><pre> <code class="plaintext hljs">### poc-helm-consul-values.yaml global: enabled: false image: "consul:latest" # Expose the Consul UI through this LoadBalancer ui: enabled: false # Allow Consul to inject the Connect proxy into Kubernetes containers connectInject: enabled: false # Configure a Consul client on Kubernetes nodes. GRPC listener is required for Connect. client: enabled: true join: ["&lt;PRIVATE_IP_CONSUL_SERVER&gt;"] extraConfig: | { "acl" : { "enabled": true, "default_policy": "deny", "enable_token_persistence": true } } # Minimal Consul configuration. Not suitable for production. server: enabled: false # Sync Kubernetes and Consul services syncCatalog: enabled: false</code> </pre> <br><ul><li>  Helmkarte anwenden: </li></ul><br><pre> <code class="plaintext hljs">./helm install -f poc-helm-consul-values.yaml ./consul-helm - name skywiz-app-with-consul-client-poc</code> </pre> <br><ul><li>  Wenn Sie versuchen zu starten, benötigen Sie Berechtigungen für den Consul-Server. Fügen Sie diese also hinzu. </li><li>  Beachten Sie den "Pod-Adressbereich" im Cluster-Dashboard und kehren Sie zu unserer Regel für die Skywiz-Consul-Server-Poc-Firewall zurück. </li><li>  Fügen Sie den Adressbereich für die IPA zur Liste der IP-Adressen und offenen Ports 8301 und 8300 hinzu. </li></ul><br><img src="https://habrastorage.org/webt/gh/wu/bi/ghwubingk53amwe3qnbiendjgvm.png"><br><ul><li>  Gehen Sie zur Consul-Benutzeroberfläche, und in wenigen Minuten sehen Sie, dass unser Cluster auf der Registerkarte "Knoten" angezeigt wird. </li></ul><br><img src="https://habrastorage.org/webt/j1/l_/h5/j1l_h5fj5iusg3ea3rxc7qc_sb8.png"><br><h2 id="nastroyka-metoda-avtorizacii-putem-integracii-consul-s-kubernetes">  Konfigurieren Sie die Autorisierungsmethode durch Integration von Consul in Kubernetes </h2><br><ul><li>  Kehren Sie zur Shell des Consul-Servers zurück und exportieren Sie das zuvor gespeicherte Token: </li></ul><br><pre> <code class="plaintext hljs">export CONSUL_HTTP_TOKEN=&lt;SecretID&gt;</code> </pre> <br><ul><li>  Wir benötigen Informationen aus unserem Kubernetes-Cluster, um eine Instanz der Authentifizierungsmethode zu erstellen: </li><li>  kubernetes-host </li></ul><br><pre> <code class="plaintext hljs">kubectl get endpoints | grep kubernetes</code> </pre> <br><ul><li>  kubernetes-service-account-jwt </li></ul><br><pre> <code class="plaintext hljs">kubectl get sa &lt;helm_deployment_name&gt;-consul-client -o yaml | grep "\- name:" kubectl get secret &lt;secret_name_from_prev_command&gt; -o yaml | grep token:</code> </pre> <br><ul><li>  Das Token ist in base64 codiert, entschlüsseln Sie es also mit Ihrem bevorzugten Tool [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> ] </li><li>  kubernetes-ca-cert </li></ul><br><pre> <code class="plaintext hljs">kubectl get secret &lt;secret_name_from_prev_command&gt; -o yaml | grep ca.crt:</code> </pre> <br><ul><li>  Nehmen Sie das Zertifikat "ca.crt" (nach dem Dekodieren mit base64) und schreiben Sie es in die Datei "ca.crt". </li><li>  Erstellen Sie nun eine Instanz der Auth-Methode und ersetzen Sie die Platzhalter durch die soeben erhaltenen Werte. </li></ul><br><pre> <code class="plaintext hljs">consul acl auth-method create \ -type "kubernetes" \ -name "auth-method-skywiz-consul-poc" \ -description "This is an auth method using kubernetes for the cluster skywiz-app-with-consul-client-poc" \ -kubernetes-host "&lt;k8s_endpoint_retrieved earlier&gt;" \ -kubernetes-ca-cert=@ca.crt \ -kubernetes-service-account- jwt="&lt;decoded_token_retrieved_earlier&gt;"</code> </pre> <br><ul><li>  Als Nächstes müssen wir eine Regel erstellen und sie an die neue Rolle anhängen.  Sie können die Consul-Benutzeroberfläche für diesen Teil verwenden, wir verwenden jedoch die Befehlszeile. </li><li>  Schreibe eine Regel </li></ul><br><pre> <code class="plaintext hljs">### kv-custom-ns-policy.hcl key_prefix "custom-ns/" { policy = "write" }</code> </pre> <br><ul><li>  Wenden Sie die Regel an </li></ul><br><pre> <code class="plaintext hljs">consul acl policy create \ -name kv-custom-ns-policy \ -description "This is an example policy for kv at custom-ns/" \ -rules @kv-custom-ns-policy.hcl</code> </pre> <br><ul><li>  Suchen Sie die Kennung der Regel, die Sie gerade aus der Ausgabe erstellt haben. </li><li>  Erstellen Sie eine Rolle mit einer neuen Regel. </li></ul><br><pre> <code class="plaintext hljs">consul acl role create \ -name "custom-ns-role" \ -description "This is an example role for custom-ns namespace" \ -policy-id &lt;policy_id&gt;</code> </pre> <br><ul><li>  Jetzt werden wir unsere neue Rolle der Instanz der Auth-Methode zuordnen.  Bitte beachten Sie, dass das Auswahlflag bestimmt, ob unsere Anmeldeanforderung diese Rolle erhält.  Überprüfen Sie die anderen Auswahloptionen hier: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.consul.io/docs/acl/auth-methods/kubernetes.html#trusted-identity-attributes</a> </li></ul><br><pre> <code class="plaintext hljs">consul acl binding-rule create \ -method=auth-method-skywiz-consul-poc \ -bind-type=role \ -bind-name='custom-ns-role' \ -selector='serviceaccount.namespace=="custom-ns"'</code> </pre> <br><h2 id="konfiguracii-naposledok">  Letzte Konfigurationen </h2><br><h3 id="prava-dostupa">  Zugangsrechte </h3><br><ul><li>  Erstellen Sie Berechtigungen.  Wir müssen dem Konsul die Erlaubnis erteilen, die Token-Identität des K8-Dienstkontos zu überprüfen und zu identifizieren. </li><li>  Schreiben Sie den folgenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[Link]</a> in die Datei: </li></ul><br><pre> <code class="plaintext hljs">###skywiz-poc-consul-server_rbac.yaml --- kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata: name: review-tokens namespace: default subjects: - kind: ServiceAccount name: skywiz-app-with-consul-client-poc-consul-client namespace: default roleRef: kind: ClusterRole name: system:auth-delegator apiGroup: rbac.authorization.k8s.io --- kind: ClusterRole apiVersion: rbac.authorization.k8s.io/v1 metadata: name: service-account-getter namespace: default rules: - apiGroups: [""] resources: ["serviceaccounts"] verbs: ["get"] --- kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata: name: get-service-accounts namespace: default subjects: - kind: ServiceAccount name: skywiz-app-with-consul-client-poc-consul-client namespace: default roleRef: kind: ClusterRole name: service-account-getter apiGroup: rbac.authorization.k8s.io</code> </pre> <br><ul><li>  Zugriffsrechte erstellen </li></ul><br><pre> <code class="plaintext hljs">kubectl create -f skywiz-poc-consul-server_rbac.yaml</code> </pre> <br><h3 id="podklyuchenie-k-consul-client">  Stellen Sie eine Verbindung zum Consul-Client her </h3><br><ul><li>  Wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier erwähnt</a> , gibt es verschiedene Möglichkeiten, eine Verbindung zu Daemonset herzustellen. Wir werden jedoch mit der folgenden einfachen Lösung fortfahren: </li><li>  Wenden Sie die folgende Datei an [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> ]. </li></ul><br><pre> <code class="plaintext hljs">### poc-consul-client-ds-svc.yaml apiVersion: v1 kind: Service metadata: name: consul-ds-client spec: selector: app: consul chart: consul-helm component: client hasDNS: "true" release: skywiz-app-with-consul-client-poc ports: - protocol: TCP port: 80 targetPort: 8500</code> </pre> <br><ul><li>  Verwenden Sie dann den folgenden integrierten Befehl, um die Konfigurationskarte [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> ] zu erstellen.  Bitte beachten Sie, dass wir uns auf den Namen unseres Service beziehen. Ersetzen Sie ihn gegebenenfalls. </li></ul><br><pre> <code class="plaintext hljs">cat &lt;&lt;EOF | kubectl apply -f - apiVersion: v1 kind: ConfigMap metadata: labels: addonmanager.kubernetes.io/mode: EnsureExists name: kube-dns namespace: kube-system data: stubDomains: | {"consul": ["$(kubectl get svc consul-ds-client -o jsonpath='{.spec.clusterIP}')"]} EOF</code> </pre> <br><h2 id="testirovanie-auth-metoda">  Testen der Auth-Methode </h2><br><p>  Schauen wir uns jetzt die Magie in Aktion an! </p><br><ul><li>  Erstellen Sie einige weitere Schlüsselordner mit demselben Schlüssel der obersten Ebene (d. H. &lt;Neuer_Ordner&gt; / Beispielschlüssel) und dem Wert Ihrer Wahl.  Erstellen Sie geeignete Richtlinien und Rollen für neue Schlüsselpfade.  Wir werden die Bindungen später machen. </li></ul><br><img src="https://habrastorage.org/webt/qm/yi/jn/qmyijnz6f7yy4kx-3l6owupoulk.png"><br><h3 id="polzovatelskiy-test-prostranstva-imen">  Benutzerdefinierter Namespace-Test: </h3><br><ul><li>  Erstellen Sie unseren eigenen Namespace: </li></ul><br><pre> <code class="plaintext hljs">kubectl create namespace custom-ns</code> </pre> <br><ul><li>  Erstellen Sie unter in unserem neuen Namespace.  Schreiben Sie die Konfiguration für den Herd. </li></ul><br><pre> <code class="plaintext hljs">###poc-ubuntu-custom-ns.yaml apiVersion: v1 kind: Pod metadata: name: poc-ubuntu-custom-ns namespace: custom-ns spec: containers: - name: poc-ubuntu-custom-ns image: ubuntu command: ["/bin/bash", "-ec", "sleep infinity"] restartPolicy: Never</code> </pre> <br><ul><li>  Erstellen unter: </li></ul><br><pre> <code class="plaintext hljs">kubectl create -f poc-ubuntu-custom-ns.yaml</code> </pre> <br><ul><li>  Sobald der Container startet, gehen Sie dorthin und installieren Sie die Locke. </li></ul><br><pre> <code class="plaintext hljs">kubectl exec poc-ubuntu-custom-ns -n custom-ns -it /bin/bash apt-get update &amp;&amp; apt-get install curl -y</code> </pre> <br><ul><li>  Jetzt senden wir eine Anfrage zur Eingabe von Consul mit der zuvor erstellten Autorisierungsmethode [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> ]. </li><li>  So zeigen Sie das eingegebene Token in Ihrem Dienstkonto an: </li></ul><br><pre> <code class="plaintext hljs">cat /run/secrets/kubernetes.io/serviceaccount/token</code> </pre> <br><ul><li>  Schreiben Sie Folgendes in eine Datei im Container: </li></ul><br><pre> <code class="plaintext hljs">### payload.json { "AuthMethod": "auth-method-test", "BearerToken": "&lt;jwt_token&gt;" }</code> </pre> <br><ul><li>  Login! </li></ul><br><pre> <code class="plaintext hljs">curl \ --request POST \ --data @payload.json \ consul-ds-client.default.svc.cluster.local/v1/acl/login</code> </pre> <br><ul><li>  Um die obigen Schritte in einer einzigen Zeile auszuführen (da wir mehrere Tests ausführen werden), können Sie Folgendes tun: </li></ul><br><pre> <code class="plaintext hljs">echo "{ \ \"AuthMethod\": \"auth-method-skywiz-consul-poc\", \ \"BearerToken\": \"$(cat /run/secrets/kubernetes.io/serviceaccount/token)\" \ }" \ | curl \ --request POST \ --data @- \ consul-ds-client.default.svc.cluster.local/v1/acl/login</code> </pre> <br><ul><li>  Es funktioniert!  Muss zumindest sein.  Nehmen Sie nun die SecretID und versuchen Sie, auf den Schlüssel / Wert zuzugreifen, auf den wir Zugriff haben müssen. </li></ul><br><pre> <code class="plaintext hljs">curl \ consul-ds-client.default.svc.cluster.local/v1/kv/custom-ns/test_key --header “X-Consul-Token: &lt;SecretID_from_prev_response&gt;”</code> </pre> <br><ul><li>  Sie können den Basiswert "Wert" 64 dekodieren und feststellen, dass er mit dem Wert in custom-ns / test_key in der Benutzeroberfläche übereinstimmt.  Wenn Sie den gleichen Wert wie in diesem Handbuch verwenden, lautet Ihr codierter Wert IkknbSBpbiB0aGUgY3VzdG9tLW5zIGZvbGRlciEi. </li></ul><br><h3 id="test-uchetnoy-zapisi-polzovatelskoy-sluzhby">  User Service Account Test: </h3><br><ul><li>  Erstellen Sie ein benutzerdefiniertes ServiceAccount mit dem folgenden Befehl [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> ]. </li></ul><br><pre> <code class="plaintext hljs">kubectl apply -f - &lt;&lt;EOF apiVersion: v1 kind: ServiceAccount metadata: name: custom-sa EOF</code> </pre> <br><ul><li>  Erstellen Sie eine neue Konfigurationsdatei für den Herd.  Bitte beachten Sie, dass ich die Curl-Installation aktiviert habe, um Arbeit zu sparen :) </li></ul><br><pre> <code class="plaintext hljs">###poc-ubuntu-custom-sa.yaml apiVersion: v1 kind: Pod metadata: name: poc-ubuntu-custom-sa namespace: default spec: serviceAccountName: custom-sa containers: - name: poc-ubuntu-custom-sa image: ubuntu command: ["/bin/bash","-ec"] args: ["apt-get update &amp;&amp; apt-get install curl -y; sleep infinity"] restartPolicy: Never</code> </pre> <br><ul><li>  Führen Sie danach die Shell im Container aus. </li></ul><br><pre> <code class="plaintext hljs">kubectl exec -it poc-ubuntu-custom-sa /bin/bash</code> </pre> <br><ul><li>  Login! </li></ul><br><pre> <code class="plaintext hljs">echo "{ \ \"AuthMethod\": \"auth-method-skywiz-consul-poc\", \ \"BearerToken\": \"$(cat /run/secrets/kubernetes.io/serviceaccount/token)\" \ }" \ | curl \ --request POST \ --data @- \ consul-ds-client.default.svc.cluster.local/v1/acl/login</code> </pre> <br><ul><li>  Erlaubnis verweigert.  Oh, wir haben vergessen, eine neue Regelbindung mit den entsprechenden Berechtigungen hinzuzufügen. Lassen Sie es uns jetzt tun. </li></ul><br><p>  Wiederholen Sie die obigen Schritte: <br>  a) Erstellen Sie eine identische Richtlinie für das Präfix "custom-sa /". <br>  b) Erstellen Sie eine Rolle und nennen Sie sie "custom-sa-role". <br>  c) Hängen Sie die Richtlinie an die Rolle an. </p><br><ul><li>  Erstellen Sie eine Regelbindung (nur über cli / api möglich).  Beachten Sie den unterschiedlichen Wert des Auswahlflags. </li></ul><br><pre> <code class="plaintext hljs">consul acl binding-rule create \ -method=auth-method-skywiz-consul-poc \ -bind-type=role \ -bind-name='custom-sa-role' \ -selector='serviceaccount.name=="custom-sa"'</code> </pre> <br><ul><li>  Melden Sie sich erneut über den Container poc-ubuntu-custom-sa an.  Erfolg! </li><li>  Überprüfen Sie unseren Zugriff auf den Pfad custom-sa / key. </li></ul><br><pre> <code class="plaintext hljs">curl \ consul-ds-client.default.svc.cluster.local/v1/kv/custom-sa/test_key --header “X-Consul-Token: &lt;SecretID&gt;”</code> </pre> <br><ul><li>  Sie können auch sicherstellen, dass dieses Token keinen Zugriff auf kv in "custom-ns /" bietet.  Wiederholen Sie einfach den obigen Befehl, nachdem Sie "custom-sa" durch das Präfix "custom-ns" ersetzt haben. <br>  Erlaubnis verweigert. </li></ul><br><h3 id="primer-overleya">  Überlagerungsbeispiel: </h3><br><ul><li>  Es ist zu beachten, dass alle regelbindenden Zuordnungen mit diesen Rechten zum Token hinzugefügt werden. </li><li>  Unser poc-ubuntu-custom-sa-Container befindet sich im Standard-Namespace. Verwenden wir ihn also für eine andere Regelbindung. </li><li>  Wiederholen Sie die vorherigen Schritte: <br>  a) Erstellen Sie eine identische Richtlinie für das Schlüsselpräfix "default /". <br>  b) Erstellen Sie eine Rolle und nennen Sie sie "default-ns-role". <br>  c) Hängen Sie die Richtlinie an die Rolle an. </li><li>  Regelbindung erstellen (nur über cli / api möglich) </li></ul><br><pre> <code class="plaintext hljs">consul acl binding-rule create \ -method=auth-method-skywiz-consul-poc \ -bind-type=role \ -bind-name='default-ns-role' \ -selector='serviceaccount.namespace=="default"'</code> </pre> <br><ul><li>  Gehen Sie zurück zu unserem poc-ubuntu-custom-sa-Container und versuchen Sie, auf den Standardpfad / kv zuzugreifen. </li><li>  Erlaubnis verweigert. <br>  Sie können die angegebenen Anmeldeinformationen für jedes Token in der Benutzeroberfläche unter ACL&gt; Token anzeigen.  Wie Sie sehen können, ist unserem aktuellen Token nur eine "benutzerdefinierte Rolle" zugeordnet.  Das Token, das wir derzeit verwenden, wurde beim Anmelden generiert, und dann gab es nur eine Regelbindung, die dann entsprach.  Wir müssen uns erneut anmelden und das neue Token verwenden. </li><li>  Stellen Sie sicher, dass Sie sowohl aus den Pfaden "custom-sa /" als auch "default /" kv lesen können. <br>  Erfolg! <br>  Dies liegt daran, dass unser poc-ubuntu-custom-sa mit den Bindungen der Regeln custom-sa und default-ns übereinstimmt. </li></ul><br><h2 id="zaklyuchenie">  Fazit </h2><br><h3 id="ttl-token-mgmt">  TTL Token mgmt? </h3><br><p>  Zum Zeitpunkt dieses Schreibens gibt es keine integrierte Möglichkeit, die TTL für Token zu bestimmen, die mit dieser Autorisierungsmethode generiert wurden.  Es wäre eine fantastische Gelegenheit, die Konsulautorisierung sicher zu automatisieren. </p><br><p>  Es ist möglich, ein Token manuell mit TTL zu erstellen: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.consul.io/docs/acl/acl-system.html#acl-tokens</a> <br>  Ablaufzeit - Die Zeit, zu der dieses Token widerrufen wird.  (Optional; hinzugefügt in Consul 1.5.0) </li><li>  Es gibt nur für die manuelle Erstellung / Aktualisierung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.consul.io/api/acl/tokens.html#expirationtime</a> </li></ul><br><p>  Ich hoffe, dass wir in naher Zukunft steuern können, wie Token generiert werden (für jede Regel oder Autorisierungsmethode) und TTL hinzufügen können. </p><br><p>  Bis dahin wird vorgeschlagen, in Ihrer Logik den Endpunkt des Austritts aus dem System zu verwenden. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.consul.io/api/acl/acl.html#logout-from-auth-method</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.consul.io/docs/acl/acl-auth-methods.html#overall-login-process</a> </li></ul><br><h3 id="takzhe-chitayte-drugie-stati-v-nashem-bloge">  Lesen Sie auch andere Artikel in unserem Blog: </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was war das Ergebnis der Migration von ClickHouse ohne Autorisierung zu ClickHouse mit Autorisierung?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">So führen Sie mehrere Pipelines mit GitLab CI / CD aus</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Drei einfache Tricks zum Reduzieren von Docker-Bildern</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Traefik als Ingress Controller für K8S</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sichern einer großen Anzahl heterogener Webprojekte</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telegrammbot für Redmine.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie Sie das Leben für sich und die Menschen vereinfachen können</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de473014/">https://habr.com/ru/post/de473014/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de473000/index.html">Ein kurzer Matheführer für Ausländer</a></li>
<li><a href="../de473002/index.html">Erklärung des Fermi-Paradoxons im Rahmen der Weltraumsoziologie Liu Qixin</a></li>
<li><a href="../de473006/index.html">DevOps - alles</a></li>
<li><a href="../de473008/index.html">Das Gesetz der Beschleunigung der Rückgabe (Teil 2)</a></li>
<li><a href="../de473012/index.html">Ergebnisse der Advantech-Partnerkonferenz in Moskau</a></li>
<li><a href="../de473016/index.html">Top-profitable Geschäftsmodelle, die von wachsenden Uber-ähnlichen Taxi-Apps implementiert werden</a></li>
<li><a href="../de473018/index.html">Tipps für Kandidaten eines Programmierers, der Interviews auf Facebook führt</a></li>
<li><a href="../de473024/index.html">Was Sie über das Internet der Dinge wissen müssen: grundlegendes Bildungsprogramm</a></li>
<li><a href="../de473026/index.html">Om-yum-yum und Datenvalidierung</a></li>
<li><a href="../de473028/index.html">In Russland begann radioaktive Abfälle aus Europa zu importieren? Sortiert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>