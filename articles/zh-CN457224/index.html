<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙆🏻 🙅🏿 🎑 Android中竞争的现代方法：Kotlin的Corotins 🧗 👨🏾‍⚖️ 🍔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 

 我们提醒您，我们已经从著名的《大书呆子牧场指南》系列中预订了人们期待已久的有关Kotlin语言的书 。 今天，我们决定提请您注意一篇文章的翻译，该文章讲述了Kotlin协程以及Android中流的正确工作。 对该主题的讨论非常活跃，因此，为完整起见，我们还建议您阅读Habr的本文和A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Android中竞争的现代方法：Kotlin的Corotins</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/457224/">哈Ha！ <br><br> 我们提醒您，我们已经从著名的《大书呆子牧场指南》系列中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">预订</a>了人们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">期待已久的</a>有关Kotlin语言的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">书</a> 。 今天，我们决定提请您注意一篇文章的翻译，该文章讲述了Kotlin协程以及Android中流的正确工作。 对该主题的讨论非常活跃，因此，为完整起见，我们还建议您阅读Habr的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本文</a>和Axmor Software博客的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">详细文章</a> 。 <br><a name="habracut"></a><br>  Java / Android中的现代竞争框架在回调上​​造成地狱，并导致阻塞状态，因为Android并没有相当简单的方法来保证线程安全。 <br><br>  Kotlin协程是非常有效和完整的工具包，可以使竞争管理变得更加轻松和高效。 <br><br>  <b>暂停和阻止：有什么区别</b> <br><br> 协程不替代线程，而是提供用于管理线程的框架。  corutin的理念是定义一个上下文，使您可以<b>等待</b>后台操作完成而不会阻塞主线程。 <br><br> 在这种情况下，Corutin的目标是放弃回调并简化竞争。 <br><br>  <b>最简单的例子</b> <br><br> 首先，让我们以最简单的示例为例：在<code>Main</code> （主线程）的上下文中运行coroutine。 在其中，我们将从<code>IO</code>流中提取图像，并将该图像发送回<code>Main</code>进行处理。 <br><br><pre> <code class="kotlin hljs">launch(Dispatchers.Main) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> image = withContext(Dispatchers.IO) { getImage() } <span class="hljs-comment"><span class="hljs-comment">//    IO imageView.setImageBitmap(image) //     }</span></span></code> </pre> <br> 该代码作为单线程函数很简单。 而且，尽管在分配的<code>IO</code>线程池中执行<code>getImage</code> ，但主线程是空闲的，可以执行任何其他任务！  withContext函数在其动作运行时暂停当前协程（ <code>getImage()</code> ）。 一旦<code>getImage()</code>返回并且主线程中的循环程序变得可用，协程将在主线程中恢复工作并调用<code>imageView.setImageBitmap(image)</code> 。 <br><br> 第二个示例：现在我们需要完成2个后台任务，以便可以使用它们。 我们将使用async / await二重唱，以便并行执行这两个任务，并在两个任务准备就绪后立即在主线程中使用它们的结果： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = launch(Dispatchers.Main) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferred1 = async(Dispatchers.Default) { getFirstValue() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferred2 = async(Dispatchers.IO) { getSecondValue() } useValues(deferred1.await(), deferred2.await()) } job.join() <span class="hljs-comment"><span class="hljs-comment">//    ,     </span></span></code> </pre> <br>  <code>async</code>与<code>launch</code>类似，但返回的是<code>deferred</code> （相当于<code>Future</code>的Kotlin实体），因此可以使用<code>await()</code>获得其结果。 不带参数调用时，它将在当前作用域的默认上下文中工作。 <br><br> 同样，在等待2个值时，主线程保持空闲状态。 <br> 如您所见， <code>launch</code>函数返回<code>Job</code> ，它可以用来等待操作完成-这是通过<code>join()</code>函数完成的。 它的工作方式与其他任何语言一样，但要注意的是，它只是<b>暂停协程，而不阻塞流程</b> 。 <br><br>  <b>派遣</b> <br><br> 使用协同程序时，调度是一个关键概念。 此操作使您可以从一个线程“跳转”到另一个线程。 <br><br> 考虑一下Java中<code>Main</code>分派的等效情况，即 <br><br><pre> <code class="kotlin hljs">runOnUiThread: <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> void runOnUiThread(Runnable action) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.currentThread() != mUiThread) { mHandler.post(action); <span class="hljs-comment"><span class="hljs-comment">//  } else { action.run(); //   } }</span></span></code> </pre> <br>  Android的<code>Main</code>上下文实现是基于处理程序的调度程序。 因此，这确实是一个非常合适的实现： <br><br><pre> <code class="kotlin hljs">launch(Dispatchers.Main) { ... } vs launch(Dispatchers.Main, CoroutineStart.UNDISPATCHED) { ... } <span class="hljs-comment"><span class="hljs-comment">//   kotlinx 0.26: launch(Dispatchers.Main.immediate) { ... }</span></span></code> </pre> <br>  <code>launch(Dispatchers.Main)</code>将<code>Runnable</code>发送给<code>Handler</code> ，因此其代码不会立即执行。 <br><br>  <code>launch(Dispatchers.Main, CoroutineStart.UNDISPATCHED)</code>将立即在当前线程中执行其lambda表达式。 <br><br>  <code>Dispatchers.Main</code> <b>确保协程恢复工作时将其定向到主线程</b> ； 另外，这里将Handler用作原生Android实现，以发送到应用程序事件循环。 <br><br> 确切的实现如下所示： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> Main: HandlerDispatcher = HandlerContext(mainHandler, <span class="hljs-string"><span class="hljs-string">"Main"</span></span>)</code> </pre> <br> 这是一篇很好的文章，可以帮助您了解Android中调度的复杂性： <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了解Android Core：Looper，Handler和HandlerThread</a> 。 <br><br>  <b>协程上下文</b> <br><br> 协程上下文（也称为协程管理器）确定将在哪个线程中执行其代码，如果引发异常，该怎么办，并引用父上下文来传播取消。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = Job() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> exceptionHandler = CoroutineExceptionHandler { coroutineContext, throwable -&gt; whatever(throwable) } launch(Disaptchers.Default+exceptionHandler+job) { ... }</code> </pre> <br>  <code>job.cancel()</code>将取消所有父对象为<code>job</code>协程。  exceptionHandler将接收在这些协程中引发的所有异常。 <br><br>  <b>适用范围</b> <br><br>  <code>coroutineScope</code>接口简化了错误处理： <br> 如果其子协程中的任何一个失败，则整个范围和所有子协程也将被取消。 <br><br> 在<code>async</code>示例中，如果无法提取该值，而另一项任务继续工作，则我们处于损坏状态，我们需要对此进行一些处理。 <br><br> 使用<code>coroutineScope</code> ，仅当两个值的提取成功时，才会调用<code>useValues</code>函数。 另外，如果<code>deferred2</code>失败，则<code>deferred1</code>将被取消。 <br><br><pre> <code class="kotlin hljs">coroutineScope { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferred1 = async(Dispatchers.Default) { getFirstValue() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferred2 = async(Dispatchers.IO) { getSecondValue() } useValues(deferred1.await(), deferred2.await()) }</code> </pre> <br> 您还可以“放入作用域”整个类来为其设置默认的<code>CoroutineContext</code>并使用它。 <br><br> 实现<code>CoroutineScope</code>接口的示例类： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScopedViewModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ViewModel</span></span></span></span>(), CoroutineScope { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = Job() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> coroutineContext = Dispatchers.Main+job <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCleared</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCleared() job.cancel() } }</code> </pre> <br> 在<code>CoroutineScope</code>运行<code>CoroutineScope</code> ： <br><br> 现在，默认的<code>launch</code>或<code>async</code>管理器将成为当前的作用域管理器。 <br><br><pre> <code class="kotlin hljs">launch { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> foo = withContext(Dispatchers.IO) { … } <span class="hljs-comment"><span class="hljs-comment">// -    CoroutineContext   … } launch(Dispatchers.Default) { // -        … }</span></span></code> </pre> <br> 协程的自动启动（在任何CoroutineScope之外）： <br><br><pre> <code class="kotlin hljs">GlobalScope.launch(Dispatchers.Main) { <span class="hljs-comment"><span class="hljs-comment">// -    . … }</span></span></code> </pre> <br> 您甚至可以通过设置默认的<code>Main</code>调度程序来定义应用程序的范围： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> AppScope : CoroutineScope <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> GlobalScope { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> coroutineContext = Dispatchers.Main.immediate }</code> </pre><br>  <b>备注</b> <br><br><ul><li> 协程限制了与Java的互操作性 </li><li> 限制可变性以避免锁定 </li><li> 协程旨在等待而不是组织线程 </li><li> 避免在<code>Dispatchers.Default</code> （和<code>Main</code> ...）中使用I / O-这就是Dispatchers.IO的用途 </li><li> 流消耗资源，因此使用单线程上下文 </li><li>  <code>Dispatchers.Default</code>基于Android 5+中引入的<code>ForkJoinPool</code> </li><li> 协程可以通过渠道使用 </li></ul><br>  <b>使用通道摆脱锁和回调</b> <br><br>  JetBrains文档中的渠道定义： <br><br><blockquote>  Channel <code>Channel</code>概念上与<code>BlockingQueue</code>非常相似。 关键区别在于，它不会阻止放置操作，而是提供了挂起<code>send</code> （或非阻止<code>offer</code> ），并且提供了暂停<code>receive</code> ，而不是阻止了获取操作。 </blockquote><br><br>  <b>演员们</b> <br><br> 考虑一个使用渠道的简单工具： <code>Actor</code> 。 <br><br> 同样， <code>Actor</code>与<code>Handler</code>非常相似：我们定义协程的上下文（即，我们将在其中执行操作的线程）并按顺序使用它。 <br><br> 当然，区别在于这里使用了Corutins。  <b>您可以指定电源以及执行的代码-pause</b> 。 <br><br> 原则上， <code>actor</code>会将任何命令重定向到协程通道。 它<b>保证命令的执行，并限制其上下文中的操作</b> 。 这种方法非常有助于摆脱<code>synchronize</code>调用并保持所有线程空闲！ <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> updateActor <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { actor&lt;Update&gt;(capacity = Channel.UNLIMITED) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (update <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> channel) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (update) { Refresh -&gt; updateList() <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Filter -&gt; filter.filter(update.query) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MediaUpdate -&gt; updateItems(update.mediaList <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;T&gt;) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MediaAddition -&gt; addMedia(update.media <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MediaListAddition -&gt; addMedia(update.mediaList <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;T&gt;) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MediaRemoval -&gt; removeMedia(update.media <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T) } } } <span class="hljs-comment"><span class="hljs-comment">//  fun filter(query: String?) = updateActor.offer(Filter(query)) //  suspend fun filter(query: String?) = updateActor.send(Filter(query))</span></span></code> </pre> <br> 在此示例中，我们使用密封的Kotlin类，选择要执行的动作。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Update</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Refresh</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Update</span></span></span></span>() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Filter</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> query: String?) : Update() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MediaAddition</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> media: Media) : Update()</code> </pre> <br> 而且，所有这些动作都将排队，它们将永远不会并行执行。 这是达到<b>可变性限制</b>的便捷方法。 <br><br>  <b>Android生命周期+协程</b> <br><br>  Actor对于控制Android用户界面，简化任务取消并防止主线程过载也非常有用。 <br> 让我们实现它，并在活动被破坏时调用<code>job.cancel()</code> 。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span></span>(), CoroutineScope { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = SupervisorJob() <span class="hljs-comment"><span class="hljs-comment">//  Job    override val coroutineContext = Dispatchers.Main.immediate+job override fun onDestroy() { super.onDestroy() job.cancel() //      } }</span></span></code> </pre> <br>  <code>SupervisorJob</code>类与常规<code>Job</code>类似，唯一的区别是取消仅在下游方向上进行。 <br><br> 因此，当其中一个协程失败时，我们不会取消所有协程。 <br><br> 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">扩展功能</a> ，您可以从<code>CoroutineContext</code>的任何<code>View</code>访问此<code>CoroutineContext</code> ，从而使事情变得更好。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> View.coroutineContext: CoroutineContext? <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = (context <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? CoroutineScope)?.coroutineContext</code> </pre> <br> 现在我们可以结合所有这些， <code>setOnClick</code>函数创建一个组合的actor来控制其<code>onClick</code>动作。 在多次轻击的情况下，中间动作将被忽略，从而消除了ANR错误（应用程序不响应），并且这些动作将在<code>Activity</code>的范围内执行。 因此，当活动被销毁时，所有这些都将被取消。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setOnClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">suspend</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//         val scope = (context as? CoroutineScope)?: AppScope val eventActor = scope.actor&lt;Unit&gt;(capacity = Channel.CONFLATED) { for (event in channel) action() } //       setOnClickListener { eventActor.offer(Unit) } }</span></span></code> </pre> <br> 在此示例中，我们将<code>Channel</code>设置为<code>Conflated</code>以便在事件过多时忽略某些事件。 如果您希望将事件排队而不丢失任何事件，但仍希望保护应用程序免受ANR错误的影响，则可以将其替换为<code>Channel.UNLIMITED</code> 。 <br><br> 您还可以结合协程和生命周期框架来自动取消与用户界面相关的任务： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> LifecycleOwner.untilDestroy: Job <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = Job() lifecycle.addObserver(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>: LifecycleObserver { <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { job.cancel() } }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> job } <span class="hljs-comment"><span class="hljs-comment">//  GlobalScope.launch(Dispatchers.Main, parent = untilDestroy) { /*    ! */ }</span></span></code> </pre> <br>  <b>通过回调简化情况（第1部分）</b> <br><br> 这是通过<code>Channel</code>转换基于回调的API的用法的方法。 <br><br>  API的工作方式如下： <br><br><ol><li>  <code>requestBrowsing(url, listener)</code>解析位于<code>url</code>的文件夹。 </li><li>  <code>listener</code>收到此文件夹中找到的任何媒体文件的<code>onMediaAdded(media: Media)</code> 。 </li><li> 解析文件夹时调用<code>listener.onBrowseEnd()</code> </li></ol><br> 这是VLC浏览器的内容提供程序中的旧<code>refresh</code>功能： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshList = mutableListOf&lt;Media&gt;() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = requestBrowsing(url, refreshListener) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshListener = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : EventListener{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMediaAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(media: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Media</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { refreshList.add(media)) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBrowseEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> list = refreshList.toMutableList() refreshList.clear() launch { dataset.value = list parseSubDirectories() } } }</code> </pre> <br>  <b>如何改善呢？</b> <br><br> 创建一个将<code>refresh</code>运行的通道。 现在，浏览器回调仅将媒体定向到该通道，然后将其关闭。 <br><br> 现在， <code>refresh</code>功能变得更加清晰。 她创建了一个频道，调用了VLC浏览器，然后形成了一个媒体文件列表并对其进行处理。 <br><br> 您可以使用<code>for</code>来等待媒体，而不是<code>select</code>或<code>consumeEach</code>并且该循环将在<code>browserChannel</code>关闭后立即中断。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> browserChannel : Channel&lt;Media&gt; <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMediaAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(media: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Media</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { browserChannel.offer(media) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBrowseEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { browserChannel.close() } <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { browserChannel = Channel(Channel.UNLIMITED) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshList = mutableListOf&lt;Media&gt;() requestBrowsing(url) <span class="hljs-comment"><span class="hljs-comment">//        for (media in browserChannel) refreshList.add(media) //   dataset.value = refreshList parseSubDirectories() }</span></span></code> </pre> <br>  <b>通过回调简化情况（第2部分）：改进</b> <br><br> 第二种方法：我们根本不使用kotlinx协程，而是使用协程核心框架。 <br><br> 看看协程实际上是如何工作的！ <br><br>  <code>retrofitSuspendCall</code>函数包装<code>Retrofit Call</code>请求以使其成为<code>suspend</code>函数。 <br><br> 使用<code>suspendCoroutine</code>我们调用<code>Call.enqueue</code>方法并暂停协程。 以这种方式提供的回调将在调用后立即调用<code>continuation.resume(response)</code>以使用服务器的响应来恢复协程。 <br><br> 接下来，我们只需要将Retrofit函数组合到<code>retrofitSuspendCall</code>即可使用它们返回查询结果。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrofitSuspendCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request: ()</span></span></span></span> -&gt; Call &lt;T&gt; ) : Response &lt;T&gt; = suspendCoroutine { continuation -&gt; request.invoke().enqueue(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : Callback&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(call: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Call</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, response: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Response</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { continuation.resume(response) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onFailure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(call: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Call</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, t: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { continuation.resumeWithException(t) } }) } <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">browse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> = retrofitSuspendCall { ApiClient.browse(path) } <span class="hljs-comment"><span class="hljs-comment">//  (   Main) livedata.value = Repo.browse(path)</span></span></code> </pre> <br> 因此，阻止网络的呼叫是在专用的Retrofit线程中进行的，协程在这里，等待服务器的响应，并且在应用程序中无处可使用！ <br><br> 此实现受到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gildor / kotlin-coroutines-retrofit库的</a>启发。 <br><br> 还有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JakeWharton / retrofit2-kotlin-coroutines-adapter</a> ，另外一个实现也给出了类似的结果。 <br><br>  <b>结语</b> <br><br>  <code>Channel</code>可以以许多其他方式使用； 请查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BroadcastChannel，以</a>获得可能有用的更强大的实现。 <br><br> 您还可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">生产</a>功能创建频道。 <br><br> 最后，使用通道可以方便地组织UI组件之间的通信：适配器可以通过<code>Channel</code>或例如<code>Actor</code>点击事件传输到其片段/活动。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN457224/">https://habr.com/ru/post/zh-CN457224/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN457204/index.html">Windows PowerShell和长路径</a></li>
<li><a href="../zh-CN457206/index.html">SQL索引管理器-关于SQL Server，深入挖掘和索引维护的悠久历史</a></li>
<li><a href="../zh-CN457208/index.html">根据环境为ASP.NET Core网站动态生成robots.txt</a></li>
<li><a href="../zh-CN457210/index.html">在主机上存储静态资源</a></li>
<li><a href="../zh-CN457212/index.html">为什么开始学习Java（或其他Java语言）永远不会太晚</a></li>
<li><a href="../zh-CN457232/index.html">机器人“大黄蜂”-国际空间站内的首次试飞</a></li>
<li><a href="../zh-CN457234/index.html">产品认知偏差</a></li>
<li><a href="../zh-CN457236/index.html">IT公司如何努力销售音乐</a></li>
<li><a href="../zh-CN457240/index.html">本周新闻：神经网络和拍照图像，Yandex股份的增长，华为需要10亿美元的专利</a></li>
<li><a href="../zh-CN457246/index.html">如何使用C ++ 17，元组和一些幻想使CortexM上的4个LED闪烁</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>