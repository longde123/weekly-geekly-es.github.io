<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🌾 🈚️ 🗡️ Eine andere Möglichkeit, die Leistung von .NET-Anwendungsmethoden zu messen 🖖🏽 ☠️ 👼🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Häufig ist es erforderlich, Statistiken über die Leistung von Anwendungsmethoden in Echtzeit zu erfassen (wenn die Anwendung bereits ausgeführt wird),...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eine andere Möglichkeit, die Leistung von .NET-Anwendungsmethoden zu messen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485198/"><p><img src="https://habrastorage.org/webt/-q/hs/z8/-qhsz8oawswkr7chwsijjbkrr1y.png"></p><br><p>  Häufig ist es erforderlich, Statistiken über die Leistung von Anwendungsmethoden in Echtzeit zu erfassen (wenn die Anwendung bereits ausgeführt wird), um die Engpässe zu ermitteln und festzustellen, welcher Teil der Anwendung langsamer wird. </p><br><p>  Darüber hinaus wäre es hilfreich, den Aufrufkontext zu speichern, in dem die Leistung verfolgt wird (z. B. Argumente zum Methodenaufruf und vom Entwickler hinzugefügte beliebige Daten), zusätzlich zu den Leistungsdaten selbst (Zeitpunkt der Methodenentwicklung, Start- und Enddatum des Aufrufs). </p><br><p>  Nun, die "Kirsche auf dem Kuchen" kann als die Bequemlichkeit und Einfachheit des verwendeten Werkzeugs angesehen werden, was auch wichtig ist. </p><br><p>  Um diese Probleme zu lösen, wurde eine plattformübergreifende Open-Source-.NET-Bibliothek <a href="https://github.com/unchase/Unchase.FluentPerformanceMeter" rel="nofollow">Unchase.FluentPerformanceMeter entwickelt</a> . </p><a name="habracut"></a><br><h2 id="vvedenie">  Einleitung </h2><br><p> In diesem Artikel wird die Arbeit mit <a href="https://github.com/unchase/Unchase.FluentPerformanceMeter" rel="nofollow"><strong>Unchase Fluent Performance Meter beschrieben</strong></a> , einer plattformübergreifenden Open-Source-Bibliothek mit <a href="https://github.com/unchase/Unchase.FluentPerformanceMeter" rel="nofollow"><strong>.NET</strong></a> <em>Standard 2.0</em> zur Berechnung der Leistung von Methoden. </p><br><p>  Die Bibliothek kann in .NET Core- und .NET Framework-Anwendungen verwendet werden, die .NET <em>Standard 2.0 unterstützen</em> , und ermöglicht <em>Folgendes</em> : </p><br><ul><li>  <a href="https://habr.com/ru/post/485198/"><strong>Führen Sie genaue Messungen der</strong></a> Leistung <strong><em>öffentlicher</em> Methoden</strong> für <strong><em>öffentliche</em> Klassen</strong> sowohl Ihres Codes als auch des <a href="https://habr.com/ru/post/485198/">Codes der verwendeten Bibliotheken durch</a> (wobei Sie den genauen Zeitpunkt des Beginns und des Endes der Messung festlegen). </li><li>  <a href="https://habr.com/ru/post/485198/"><strong>Fügen Sie den</strong></a> Messergebnissen <strong>zusätzliche Daten</strong> (benutzerdefinierte Daten) hinzu.  Zum Beispiel die Werte der Eingabeparameter der Methode und des Ergebnisses;  oder Kontextdaten der Methodenausführung;  oder <em>corellationId</em> , mit der mehrere Messungen der Leistung von Methoden verknüpft werden können; </li><li>  <a href="https://habr.com/ru/post/485198/"><strong>Teilen Sie die Messung der</strong></a> Methodenleistung <strong>in separate Schritte</strong> (Steps) auf, wobei Sie für jeden Schritt eigene Daten festlegen.  Außerdem können Sie <a href="https://habr.com/ru/post/485198/">die minimale</a> Laufzeit <a href="https://habr.com/ru/post/485198/">festlegen</a> , ab der der Schritt bei der Messung berücksichtigt wird (wenn der Schritt schneller ausgeführt wird, wird er nicht gemessen). </li><li>  <strong>Bestimmte Teile des Codes</strong> <a href="https://habr.com/ru/post/485198/"><strong>von der</strong></a> Leistungsmessung ausschließen (z. B. Aufrufe einzelner Methoden, deren Ausführungszeit bei der Messung nicht berücksichtigt werden muss); </li><li>  <a href="https://habr.com/ru/post/485198/"><strong>Fügen Sie Ihre eigenen Befehle</strong></a> (Commands) hinzu, die garantiert <strong>sofort nach dem</strong> Ende der Leistungsmessung der Methode ausgeführt werden (z. B. um die erhaltenen Ergebnisse zusätzlich zu verarbeiten, z. B. um Daten zu protokollieren oder in den Speicher zu schreiben). </li><li>  <a href="https://habr.com/ru/post/485198/"><strong>Fügen Sie einen eigenen Ausnahmehandler</strong></a> für Code hinzu, der im Zusammenhang mit der Messung der Leistung der Methode ausgeführt wird (sowohl für alle Messungen als auch für jede Messung separat). </li><li>  <a href="https://habr.com/ru/post/485198/"><strong>Legen Sie die Zeit zum Speichern der Ergebnisse von</strong></a> Messungen der Produktivität von Methoden fest. Danach werden die Ergebnisse gelöscht. </li><li>  <a href="https://habr.com/ru/post/485198/"><strong>Fügen Sie</strong></a> den Messergebnissen Daten darüber hinzu, <strong>wer die Methode</strong> ( <em>Aufrufer</em> ) über <em>IHttpContextAccesor</em> oder die Aufgabe des <em>Aufrufers</em> im Code <em>aufruft</em> (Sie können beispielsweise den Namen des externen Dienstes angeben, der die Methode aufgerufen hat). </li><li>  <a href="https://habr.com/ru/post/485198/"><strong>Ergänzen Sie die Messergebnisdaten</strong></a> an der Stelle, an der die Leistungsmessung gestartet wurde (Dateiname und Zeilennummer mit dem Anrufort im Code); </li><li>  <a href="https://habr.com/ru/post/485198/"><strong>Unterbrechen der Messung der</strong></a> Leistung der Methode <strong>bis zu ihrem Abschluss</strong> . </li></ul><br><p>  Die aus der Messung der Leistung der Methoden gewonnenen Daten können verwendet werden, um die Leistung der Anwendung (ihre einzelnen Teile, sowohl interner Code als auch externer Code der verwendeten Bibliotheken) zu analysieren und in einer für Sie geeigneten grafischen Form anzuzeigen. </p><br><h2 id="soderzhanie">  Inhalt </h2><br><ul><li>  <a href="https://habr.com/ru/post/485198/">Erste Schritte</a> </li><li>  <a href="https://habr.com/ru/post/485198/">Anwendungsbeispiele</a> <br><ul><li>  <a href="https://habr.com/ru/post/485198/">Methodenleistungsmessung</a> </li><li>  <a href="https://habr.com/ru/post/485198/">Methodenleistungsmessung mit DiagnosticSource</a> </li><li>  <a href="https://habr.com/ru/post/485198/">Messung der Leistung der von der Bibliothek verwendeten Methode</a> </li><li>  <a href="https://habr.com/ru/post/485198/">Hinzufügen zusätzlicher Daten (benutzerdefinierte Daten) und Paginierung (Schritte)</a> </li><li>  <a href="https://habr.com/ru/post/485198/">Ausnahme von der Messung (Ignorieren)</a> </li><li>  <a href="https://habr.com/ru/post/485198/">Befehle und Aktionen hinzufügen</a> </li><li>  <a href="https://habr.com/ru/post/485198/">Ausnahmebehandlungsroutinen hinzufügen</a> </li><li>  <a href="https://habr.com/ru/post/485198/">Einstellen der Datenspeicherzeit (Set Cache Time)</a> </li><li>  <a href="https://habr.com/ru/post/485198/">Hinzufügen von Daten zur aufrufenden Methode und zum Ort des Anrufs (Unterbrechung der Leistungsmessung)</a> </li></ul></li></ul><br><h2 id="a-namestarta-nachalo-raboty">  Erste Schritte </h2><br><p>  Installieren Sie das <a href="https://www.nuget.org/packages/Unchase.FluentPerformanceMeter/" rel="nofollow"><em>NuGet-</em> Paket</a> in Ihrem Projekt, um die Bibliothek zu verwenden: </p><br><h4 id="vruchnuyu-s-pomoschyu-menedzhera-nuget-paketov-package-manager">  Manuelles Verwenden des <em>NuGet</em> Package Managers: </h4><br><pre><code class="powershell hljs"><span class="hljs-built_in"><span class="hljs-built_in">Install-Package</span></span> Unchase.FluentPerformanceMeter</code> </pre> <br><h4 id="s-pomoschyu-net-cli">  Verwenden der .NET CLI: </h4><br><pre> <code class="powershell hljs">dotnet add package Unchase.FluentPerformanceMeter -<span class="hljs-literal"><span class="hljs-literal">-version</span></span> {version}</code> </pre> <br><blockquote>  Wobei {version} die Version des Pakets ist, das Sie installieren möchten. <br>  Beispiel: <code>dotnet add package Unchase.FluentPerformanceMeter --version 1.0.0</code> </blockquote><br><h2 id="a-namesimplesamplesa-primery-ispolzovaniya">  Anwendungsbeispiele </h2><br><h3 id="izmerenie-proizvoditelnosti-metoda">  Methodenleistungsmessung </h3><br><p>  Im Folgenden finden Sie ein einfaches Beispiel für die Verwendung der Bibliothek (ohne Konfiguration und zusätzliche Einstellungen) zum Messen der Leistung der (Action) <code>SimpleWatchingMethodStart</code> <em>Asp.Net Core 2.2-WebAPI-</em> Anwendung " <code>SimpleWatchingMethodStart</code> controller (Controller) <code>PerformanceMeterController</code> <em>"</em> .  Dazu können Sie die Erweiterungsmethode <code>.WatchingMethod().Start()</code> oder eine ähnliche Funktion <code>.StartWatching()</code> . <br>  Ab Version 1.0.5 können Sie auch <code>.WatchingMethod().Start(SimpleWatchingMethodStart)</code> oder <code>.StartWatching(SimpleWatchingMethodStart)</code> mit dem Methodennamen verwenden. </p><br><blockquote>  Alle Beispiele für die Verwendung der Bibliothek finden Sie in den <code>Unchase.FluentPerformanceMeter.Test*</code> -Projekten <a href="https://github.com/unchase/Unchase.FluentPerformanceMeter" rel="nofollow">dieses Repositorys</a> . </blockquote><br><pre> <code class="plaintext hljs">/// &lt;summary&gt; /// Test GET method with simple performance watching. /// &lt;/summary&gt; [HttpGet("SimpleWatchingMethodStart")] public ActionResult SimpleWatchingMethodStart() { // for C# 8 you can use: //using var pm = PerformanceMeter&lt;PerformanceMeterController&gt;.StartWatching(); using (PerformanceMeter&lt;PerformanceMeterController&gt;.WatchingMethod().Start()) { // put your code with some logic here return Ok(); } }</code> </pre> <br><p>  Um die Ergebnisse von Leistungsmessungen öffentlicher Methoden der Controller-Klasse <code>PerformanceMeterController</code> abzurufen, können Sie die folgende Methode aufrufen: </p><br><pre> <code class="plaintext hljs">/// &lt;summary&gt; /// Get methods performance info for this controller. /// &lt;/summary&gt; /// &lt;returns&gt;Returns methods performance info.&lt;/returns&gt; [HttpGet("GetPerformanceInfo")] [IgnoreMethodPerformance] public ActionResult&lt;IPerformanceInfo&gt; GetPerformanceInfo() { return Ok(PerformanceMeter&lt;PerformanceMeterController&gt;.PerformanceInfo); }</code> </pre> <br><p>  Nach dem Aufruf der <code>SimpleWatchingMethodStart</code> Methode beim Aufruf von <code>GetPerformanceInfo</code> wir: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"methodCalls"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"SimpleWatchingMethodStart"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"elapsed"</span></span>: <span class="hljs-string"><span class="hljs-string">"00:00:00.0016350"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"caller"</span></span>: <span class="hljs-string"><span class="hljs-string">"unknown"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"startTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T10:27:27.3385385Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"endTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T10:27:27.3401735Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"steps"</span></span>: [] } ], <span class="hljs-attr"><span class="hljs-attr">"totalActivity"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"SimpleWatchingMethodStart"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callsCount"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"currentActivity"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"SimpleWatchingMethodStart"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callsCount"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"uptimeSince"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T10:27:27.3370183Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"className"</span></span>: <span class="hljs-string"><span class="hljs-string">"Unchase.FluentPerformanceMeter.TestWebAPI.Controllers.PerformanceMeterController"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"methodNames"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"SimpleWatchingMethodStart"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"timerFrequency"</span></span>: <span class="hljs-number"><span class="hljs-number">10000000</span></span> }</code> </pre> <br><h3 id="a-namediagnosticsourcesamplea-izmerenie-proizvoditelnosti-metoda-s-pomoschyu-diagnosticsource">  Methodenleistungsmessung mit <code>DiagnosticSource</code> </h3><br><p>  Ab Version <em>1.1.0</em> konnte die Leistung von Methoden in einer <em>AspNetCore MVC-</em> Anwendung mithilfe von <code>DiagnosticSource</code> und dem speziellen Attribut <code>WatchingWithDiagnosticSourceAttribute</code> <em>gemessen</em> werden. <br>  <a href="" rel="nofollow"><code>Unchase.FluentPerformanceMeter.AspNetCore.Mvc</code></a> Sie dazu das <a href="" rel="nofollow"><code>Unchase.FluentPerformanceMeter.AspNetCore.Mvc</code></a> Paket zum <em>NuGet-</em> Projekt hinzu und fügen Sie <code>Startap.cs</code> den folgenden Code <code>Startap.cs</code> : </p><br><pre> <code class="plaintext hljs">public void ConfigureServices(IServiceCollection services) { // ... // allows to measure methods performance for class "MeasurableClass" and "MeasurableSecondClass" services.AddPerformanceDiagnosticObserver&lt;MeasurableClass&gt;(); services.AddPerformanceDiagnosticObserver&lt;MeasurableSecondClass&gt;(); // ... the same for another classes services.AddMvc(); // ... } public void Configure(IApplicationBuilder app, IHostingEnvironment env) { // ... app.UsePerformanceDiagnosticObserver(); app.UseMvc(); }</code> </pre> <br><p>  Dann markieren Sie mit dem Attribut <code>WatchingWithDiagnosticSourceAttribute</code> oder einzelnen Methoden: </p><br><pre> <code class="plaintext hljs">[HttpGet("SimpleWatchingMethodStart")] [WatchingWithDiagnosticSource] public ActionResult SimpleWatchingMethodStart() { return Ok(); }</code> </pre> <br><p>  oder die ganze Klasse: </p><br><pre> <code class="plaintext hljs">[ApiController] [Route("api/v1/[controller]")] [Produces("application/json")] [SwaggerTag("Unchase.PerformanceMeter Test WebAPI Controller")] [WatchingWithDiagnosticSource] public class PerformanceMeterController : ControllerBase { // measurable methods }</code> </pre> <br><p>  Ab Version <em>1.2.0</em> konnten in einer <em>AspNetCore MVC-</em> Anwendung mithilfe des speziellen <code>AddMethodArgumentsToCustomDataAttribute</code> Attributs in Verbindung mit dem <code>WatchingWithDiagnosticSourceAttribute</code> Attribut <code>AddMethodArgumentsToCustomDataAttribute</code> Leistungsmessdaten von Benutzermethoden <code>AddMethodArgumentsToCustomDataAttribute</code> werden: </p><br><pre> <code class="plaintext hljs">[HttpPost("SimpleWatchingMethodStartWithArgs")] [WatchingWithDiagnosticSource] [AddMethodArgumentsToCustomData("actionArguments")] public ActionResult SimpleWatchingMethodStartWithArgs(DTOArgument arg) { return Ok(); }</code> </pre> <br><p>  Nach dem Aufruf der <code>SimpleWatchingMethodStartWithArgs</code> Methode beim Aufruf von <code>GetPerformanceInfo</code> wir: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"methodCalls"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"SimpleWatchingMethodStartWithArgs"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"elapsed"</span></span>: <span class="hljs-string"><span class="hljs-string">"00:00:00.0016350"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"caller"</span></span>: <span class="hljs-string"><span class="hljs-string">"unknown"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"startTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T10:27:27.3385385Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"endTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T10:27:27.3401735Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"actionArguments"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"arg"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"data"</span></span>: <span class="hljs-string"><span class="hljs-string">"&lt;string_in_DTOArgument&gt;"</span></span> } } }, <span class="hljs-attr"><span class="hljs-attr">"steps"</span></span>: [] } ], <span class="hljs-attr"><span class="hljs-attr">"totalActivity"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"SimpleWatchingMethodStartWithArgs"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callsCount"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"currentActivity"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"SimpleWatchingMethodStartWithArgs"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callsCount"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"uptimeSince"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T10:27:27.3370183Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"className"</span></span>: <span class="hljs-string"><span class="hljs-string">"Unchase.FluentPerformanceMeter.TestWebAPI.Controllers.PerformanceMeterController"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"methodNames"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"SimpleWatchingMethodStartWithArgs"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"timerFrequency"</span></span>: <span class="hljs-number"><span class="hljs-number">10000000</span></span> }</code> </pre> <br><h3 id="a-namesampleexternala-izmerenie-proizvoditelnosti-metoda-ispolzuemoy-biblioteki">  Messung der Leistung der von der Bibliothek verwendeten Methode </h3><br><p>  Um die Leistung der <em>öffentlichen</em> Methode der <em>öffentlichen</em> Klasse der verwendeten Drittanbieter-Bibliothek zu messen, müssen Sie die Klasse selbst und den Namen ihrer Methode explizit festlegen: </p><br><pre> <code class="plaintext hljs">[HttpGet("GetThreadSleepPerformance")] public ActionResult&lt;string&gt; GetThreadSleepPerformance() { using (PerformanceMeter&lt;Thread&gt;.WatchingMethod(nameof(Thread.Sleep)).Start()) { Thread.Sleep(1000); } return Ok(PerformanceMeter&lt;Thread&gt;.PerformanceInfo.MethodCalls.FirstOrDefault(ta =&gt; ta.MethodName == nameof(Thread.Sleep))?.Elapsed); }</code> </pre> <br><p>  Die ausgeführte Methode gibt Folgendes zurück: </p><br><pre> <code class="plaintext hljs">"00:00:01.0033040"</code> </pre> <br><p>  Sie können Daten zum Aufrufen dieser Methode über einen Aufruf abrufen: </p><br><pre> <code class="plaintext hljs">/// &lt;summary&gt; /// Get methods performance info for Thread class. /// &lt;/summary&gt; /// &lt;returns&gt;Returns Thread methods performance info.&lt;/returns&gt; [HttpGet("GetThreadPerformanceInfo")] [IgnoreMethodPerformance] public ActionResult&lt;IPerformanceInfo&gt; GetThreadPerformanceInfo() { return Ok(PerformanceMeter&lt;Thread&gt;.PerformanceInfo); }</code> </pre> <br><blockquote>  Das <code>IgnoreMethodPerformance</code> Attribut <code>IgnoreMethodPerformance</code> so konzipiert, dass die von ihm <code>IgnoreMethodPerformance</code> Methode beim Messen der Leistung nicht berücksichtigt wird. </blockquote><p>  Als Antwort auf den Aufruf dieser Methode wird sein: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"methodCalls"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"Sleep"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"elapsed"</span></span>: <span class="hljs-string"><span class="hljs-string">"00:00:01.0033040"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"caller"</span></span>: <span class="hljs-string"><span class="hljs-string">"unknown"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"startTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T13:08:09.336624Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"endTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T13:08:10.339928Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"steps"</span></span>: [] } ], <span class="hljs-attr"><span class="hljs-attr">"totalActivity"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"Abort"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callsCount"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }, // ... { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"Sleep"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callsCount"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } // ... ], <span class="hljs-attr"><span class="hljs-attr">"currentActivity"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"Abort"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callsCount"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }, // ... { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"Sleep"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callsCount"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } // ... ], <span class="hljs-attr"><span class="hljs-attr">"uptimeSince"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T13:08:09.3357028Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"className"</span></span>: <span class="hljs-string"><span class="hljs-string">"System.Threading.Thread"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"methodNames"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"Abort"</span></span>, // ... <span class="hljs-string"><span class="hljs-string">"Sleep"</span></span>, // ... ], <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"timerFrequency"</span></span>: <span class="hljs-number"><span class="hljs-number">10000000</span></span> }</code> </pre> <br><h3 id="a-namesamplecustomdataa-dobavlenie-dopolnitelnyh-dannyh-custom-data-i-razbienie-na-shagi-steps">  Hinzufügen zusätzlicher Daten (benutzerdefinierte Daten) und Paginierung (Schritte) </h3><br><p>  Sie können zusätzliche Daten (benutzerdefinierte Daten) für alle Leistungsmessungen von Methoden einer bestimmten Klasse hinzufügen.  Zum Beispiel im statischen Konstruktor der Controller-Klasse <code>PerformanceMeterController</code> : </p><br><pre> <code class="plaintext hljs">[ApiController] [Route("api/v1/[controller]")] public class PerformanceMeterController : ControllerBase { /// &lt;summary&gt; /// Static constructor. /// &lt;/summary&gt; static PerformanceMeterController() { // add common custom data (string) to class performance information PerformanceMeter&lt;PerformanceMeterController&gt;.AddCustomData("Tag", "CustomTag"); // add common custom data (anonymous class) to class performance information PerformanceMeter&lt;PerformanceMeterController&gt;.AddCustomData("Custom anonymous class", new { Name = "Custom Name", Value = 1 }); } // ... actions }</code> </pre> <br><p>  Darüber hinaus können Sie mithilfe der Erweiterungsmethode <code>.WithSettingData.CustomData("&lt;key&gt;", &lt;value&gt;)</code> (einschließlich eines speziellen Attributs der <code>MethodCustomDataAttribute</code> Methode) und für jeden Schritt (Step) zusätzliche Daten (Custom Data) für eine bestimmte Messung hinzufügen ) dieser Messung, hinzugefügt unter Verwendung der Erweiterungsmethode <code>.Step("&lt;step_name&gt;")</code> , unter Verwendung der Erweiterungsmethode <code>.AddCustomData("&lt;key&gt;", &lt;value&gt;)</code> : </p><br><pre> <code class="plaintext hljs">/// &lt;summary&gt; /// Test GET method with simple performance watching (with steps). /// &lt;/summary&gt; [HttpGet("SimpleStartWatchingWithSteps")] [MethodCustomData("Custom data from attribute", "Attr")] public ActionResult SimpleStartWatchingWithSteps() { using (var pm = PerformanceMeter&lt;PerformanceMeterController&gt; .WatchingMethod() .WithSettingData .CustomData("coins", 1) .CustomData("Coins sets", new { Gold = "Many", Silver = 5 }) .Start()) { // put your code with some logic here // add "Step 1" using (pm.Step("Step 1")) { Thread.Sleep(1000); } // add "Step 2" with custom data using (var pmStep = pm.Step("Step 2").AddCustomData("step2 custom data", "data!")) { // add "Step 3 in Step 2" using (pm.Step("Step 3 in Step 2")) { Thread.Sleep(1000); } // add custom data to "Step 2" pmStep.AddCustomData("step2 another custom data", "data2!"); // get and remove custom data from "Step 2" var customData = pmStep.GetAndRemoveCustomData&lt;string&gt;("step2 custom data"); // get custom data from "Step 2" (without removing) var anotherCustomData = pmStep.GetCustomData&lt;string&gt;("step2 another custom data"); // ... } } }</code> </pre> <br><p>  Als Ergebnis <code>GetPerformanceInfo</code> wir beim Aufruf von <code>GetPerformanceInfo</code> : </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"methodCalls"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"SimpleStartWatchingWithSteps"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"elapsed"</span></span>: <span class="hljs-string"><span class="hljs-string">"00:00:02.0083031"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"caller"</span></span>: <span class="hljs-string"><span class="hljs-string">"unknown"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"startTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T11:58:18.9006891Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"endTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T11:58:20.9089922Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Coins sets"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"gold"</span></span>: <span class="hljs-string"><span class="hljs-string">"Many"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"silver"</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"coins"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Custom data from attribute"</span></span>: <span class="hljs-string"><span class="hljs-string">"Attr"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"steps"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"stepName"</span></span>: <span class="hljs-string"><span class="hljs-string">"Step 1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"elapsed"</span></span>: <span class="hljs-string"><span class="hljs-string">"00:00:01.0009758"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"startTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T11:58:18.9018272Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"endTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T11:58:19.902803Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: {} }, { <span class="hljs-attr"><span class="hljs-attr">"stepName"</span></span>: <span class="hljs-string"><span class="hljs-string">"Step 3 in Step 2"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"elapsed"</span></span>: <span class="hljs-string"><span class="hljs-string">"00:00:01.0004549"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"startTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T11:58:19.9046523Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"endTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T11:58:20.9051072Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: {} }, { <span class="hljs-attr"><span class="hljs-attr">"stepName"</span></span>: <span class="hljs-string"><span class="hljs-string">"Step 2"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"elapsed"</span></span>: <span class="hljs-string"><span class="hljs-string">"00:00:01.0029596"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"startTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T11:58:19.904534Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"endTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T11:58:20.9074936Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"step2 another custom data"</span></span>: <span class="hljs-string"><span class="hljs-string">"data2!"</span></span> } } ] } ], <span class="hljs-attr"><span class="hljs-attr">"totalActivity"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"SimpleStartWatchingWithSteps"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callsCount"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"currentActivity"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"SimpleStartWatchingWithSteps"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callsCount"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"uptimeSince"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T11:58:18.8801249Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"className"</span></span>: <span class="hljs-string"><span class="hljs-string">"Unchase.FluentPerformanceMeter.TestWebAPI.Controllers.PerformanceMeterController"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"methodNames"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"SimpleStartWatchingWithSteps"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Tag"</span></span>: <span class="hljs-string"><span class="hljs-string">"CustomTag"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Custom anonymous class"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Custom Name"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"timerFrequency"</span></span>: <span class="hljs-number"><span class="hljs-number">10000000</span></span> }</code> </pre> <br><h3 id="a-namesampleignorea-isklyuchenie-iz-zamera-ignore">  Ausnahme von der Messung (Ignorieren) </h3><br><p>  Sie können einzelne Teile der Methode beim Messen der Leistung ignorieren (mithilfe von <code>.Ignore()</code> oder <code>.Executing().WithoutWatching().Start(&lt;Action&gt;)</code> ) und auch einzelne Schritte nicht speichern (Erweiterungsmethode <code>.StepIf("&lt;step_name&gt;", &lt;minSaveMs&gt;)</code> ), wenn sie die Bedingung nicht erfüllen (die Ausführungszeit des Schritts wird in der Ausführungszeit der Methode berücksichtigt): </p><br><pre> <code class="plaintext hljs">using (var pm = PerformanceMeter&lt;PerformanceMeterController&gt;.WatchingMethod().Start()) { // put your code with some logic here // sleep 1 sec Thread.Sleep(1000); // ignore this block in performance watching using (pm.Ignore()) { Thread.Sleep(5000); } // skip this step with minSaveMs (not save, but consider duration in method performance watching) using (pm.StepIf("Skipped step", minSaveMs: 1000)) { Thread.Sleep(500); } // execute action without performance watching pm.Executing().WithoutWatching().Start(() =&gt; { Thread.Sleep(2000); }); return Ok(); }</code> </pre> <br><p>  Als Ergebnis erhalten wir: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"methodCalls"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"SimpleStartWatchingWithIgnored"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"elapsed"</span></span>: <span class="hljs-string"><span class="hljs-string">"00:00:01.5080227"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"caller"</span></span>: <span class="hljs-string"><span class="hljs-string">"unknown"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"startTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T12:34:36.9187359Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"endTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T12:34:38.4267586Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"steps"</span></span>: [] } ], <span class="hljs-attr"><span class="hljs-attr">"totalActivity"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"SimpleStartWatchingWithIgnored"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callsCount"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"currentActivity"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"SimpleStartWatchingWithIgnored"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callsCount"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"uptimeSince"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T12:34:36.9035129Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"className"</span></span>: <span class="hljs-string"><span class="hljs-string">"Unchase.FluentPerformanceMeter.TestWebAPI.Controllers.PerformanceMeterController"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"methodNames"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"SimpleStartWatchingWithIgnored"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: { }, <span class="hljs-attr"><span class="hljs-attr">"timerFrequency"</span></span>: <span class="hljs-number"><span class="hljs-number">10000000</span></span> }</code> </pre> <br><h3 id="a-namesamplecustomcommandsa-dobavlenie-komand-commands-i-deystviy-actions">  Befehle und Aktionen hinzufügen </h3><br><p>  Um einen Befehl hinzuzufügen, dessen Ausführung nach Abschluss der Messung der Leistung einer Methode garantiert ist, muss eine Befehlsklasse erstellt werden, die die <code>IPerformanceCommand</code> Schnittstelle implementiert. <br>  Gleichzeitig können Sie beliebige Daten über den Konstruktor des erstellten Befehls übertragen, der während seiner Ausführung verwendet wird.  Zum Beispiel: </p><br><pre> <code class="plaintext hljs">/// &lt;summary&gt; /// Custom executed command. /// &lt;/summary&gt; public class ExecutedCommand : IPerformanceCommand { /// &lt;summary&gt; /// Executed commad name. /// &lt;/summary&gt; public string CommandName =&gt; this.GetType().Name; private string _customString { get; } internal bool IsCommandExecuted { get; private set; } /// &lt;summary&gt; /// Constructor. /// &lt;/summary&gt; /// &lt;remarks&gt; /// You can pass any data through the command constructor. /// &lt;/remarks&gt; /// &lt;param name="customString"&gt;&lt;/param&gt; public ExecutedCommand(string customString) { this._customString = customString; } /// &lt;summary&gt; /// Execute command. /// &lt;/summary&gt; /// &lt;param name="performanceInfo"&gt;&lt;see cref="IPerformanceInfo"/&gt;.&lt;/param&gt; public void Execute(IPerformanceInfo performanceInfo) { // for example, write to the debug console some information Debug.WriteLine(this.CommandName); Debug.WriteLine(this._customString); Debug.WriteLine($"Method names count: {performanceInfo.MethodNames.Count}"); this.IsCommandExecuted = true; } }</code> </pre> <br><p>  Sie können einen Befehl (IPerformanceCommand) und eine Aktion (Action) hinzufügen, damit sie am Ende der Messung wie folgt ausgeführt werden: </p><br><pre> <code class="plaintext hljs">// custom "ExecutedCommand" will be executed after performance watching is completed using (PerformanceMeter&lt;PerformanceMeterController&gt; .WatchingMethod() .WithExecutingOnComplete .Command(new ExecutedCommand("bla-bla-bla")) .Action((pi) =&gt; { Debug.WriteLine($"Class name: {pi.ClassName}"); }) .Start()) { return Ok(); }</code> </pre> <br><p>  Als Ergebnis wird am Ende der Messung der Leistung der Methode in der <em>Debug-</em> Konsole <em>Folgendes</em> angezeigt: </p><br><pre> <code class="plaintext hljs">ExecutedCommand bla-bla-bla Method names count: 13 Class name: Unchase.FluentPerformanceMeter.TestWebAPI.Controllers.PerformanceMeterController</code> </pre> <br><h3 id="a-namesamplecustomexceptionhandlera-dobavlenie-obrabotchikov-isklyucheniy-exception-handlers">  Ausnahmebehandlungsroutinen hinzufügen </h3><br><p>  Wenn Sie Ausnahmen behandeln müssen, die während der Ausführung eines Teils der Methode auftreten können, für die die Leistung überwacht wird, müssen Sie einen Ausnahmebehandler wie folgt hinzufügen: </p><br><pre> <code class="plaintext hljs">using (var pm = PerformanceMeter&lt;PerformanceMeterController&gt;.StartWatching()) { // execute action throws Exception with exception handler pm.Executing() .WithExceptionHandler((ex) =&gt; Debug.WriteLine(ex.Message)) .Start(() =&gt; throw new Exception("Exception")); // execute action throws custom Exception with exception handler pm.Executing&lt;CustomException&gt;() .WithExceptionHandler((ex) =&gt; { Debug.WriteLine(ex.Message); }) .Start(() =&gt; { throw new CustomException("Custom exception was occured!"); }); return Ok(); }</code> </pre> <br><p>  Wo ist die <code>CustomException</code> Klasse, zum Beispiel: </p><br><pre> <code class="plaintext hljs">/// &lt;summary&gt; /// Custom exception. /// &lt;/summary&gt; public class CustomException : Exception { public CustomException(string message) : base(message) { } public CustomException(string message, Exception innerException) : base(message, innerException) { } public CustomException() { } }</code> </pre> <br><p>  Infolgedessen zeigt die <em>Debug-</em> Konsole Folgendes an: </p><br><pre> <code class="plaintext hljs">Exception Custom exception was occured!</code> </pre> <br><p>  Darüber hinaus können Sie einen Ausnahmebehandler angeben, der standardmäßig zum Messen der Leistung jeder Methode dieser Klasse verwendet wird, z. B. über den statischen Konstruktor der <code>PerformanceMeterController</code> Controllerklasse: </p><br><pre> <code class="plaintext hljs">[ApiController] [Route("api/v1/[controller]")] public class PerformanceMeterController : ControllerBase { /// &lt;summary&gt; /// Static constructor. /// &lt;/summary&gt; static PerformanceMeterController() { // set default exception handler for PerformanceMeterController class PerformanceMeter&lt;PerformanceMeterController&gt;.SetDefaultExceptionHandler((ex) =&gt; Debug.WriteLine(ex.Message)); } // ... actions }</code> </pre> <br><h3 id="a-namesamplesettingcachetimea-ustanovka-vremeni-hraneniya-dannyh-set-cache-time">  Einstellen der Datenspeicherzeit (Set Cache Time) </h3><br><p>  Sie können die Speicherzeit für die Daten der Leistungsmessungen von Methoden einstellen, nach deren Ablauf diese Daten gelöscht werden.  Für jede Klasse, für die eine Messung durchgeführt wird, wird diese Zeit separat eingestellt.  Die Zeit kann beispielsweise über den statischen Konstruktor der <code>PerformanceMeterController</code> Controller-Klasse festgelegt werden: </p><br><pre> <code class="plaintext hljs">[ApiController] [Route("api/v1/[controller]")] public class PerformanceMeterController : ControllerBase { /// &lt;summary&gt; /// Static constructor. /// &lt;/summary&gt; static PerformanceMeterController() { // set cache time for PerformanceMeterController class PerformanceMeter&lt;PerformanceMeterController&gt;.SetMethodCallsCacheTime(5); } // ... actions }</code> </pre> <br><h3 id="a-namesamplesetcallerandsourcewithstopa-dobavlenie-dannyh-o-vyzyvayuschem-metod-i-meste-vyzova-i-preryvanie-zamera-proizvoditelnosti">  Hinzufügen von Daten zur aufrufenden Methode und zum Ort des Anrufs (und Unterbrechen der Leistungsmessung) </h3><br><ul><li><p>  Sie können angeben, wer die Methode aufruft, indem Sie die Erweiterungsmethode <code>.CallerFrom("&lt;caller_name&gt;")</code> (entweder eine Zeichenfolge oder <em>IHttpContextAccessor wird an sie übergeben</em> ) oder ein spezielles Attribut der Methode <code>[MethodCaller("&lt;caller_name&gt;")]</code> .  Wenn sowohl das Attribut als auch die Erweiterungsmethode verwendet werden, wird der Wert von dieser übernommen. </p><br></li><li><p>  Mit der Erweiterungsmethode <code>.WithSettingData.CallerSourceData()</code> ein <code>.WithSettingData.CallerSourceData()</code> zum Messen der Leistung hinzugefügt. </p><br></li><li><p>  Verwenden Sie die Erweiterungsmethode <code>.StopWatching()</code> oder die Methode <code>Dispose()</code> direkt, um die Messung der Leistung innerhalb des <code>using</code> Blocks zu <code>.StopWatching()</code> : </p><br></li></ul><br><pre> <code class="plaintext hljs">[HttpPost("StartWatchingWithCallerName")] [MethodCaller("testCaller")] public ActionResult&lt;string&gt; StartWatchingWithCallerName([FromBody] string value) { // method performance info will reach with caller name (if internal HttpContextAccessor is null) using (var pm = PerformanceMeter&lt;PerformanceMeterController&gt; .WatchingMethod() .WithSettingData .CallerSourceData() .CallerFrom("Test caller") .Start()) { pm.StopWatching(); // stop watching here (or you can use "pm.Dispose();") Thread.Sleep(2000); return Ok(value); } }</code> </pre> <br><p>  Durch den Aufruf der Methode <code>GetPerformanceInfo</code> : </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"methodCalls"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"StartWatchingWithCallerName"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"elapsed"</span></span>: <span class="hljs-string"><span class="hljs-string">"00:00:00.0019172"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"caller"</span></span>: <span class="hljs-string"><span class="hljs-string">"Test caller"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"startTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T13:35:45.3164507Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"endTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T13:35:45.3183679Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"customData123"</span></span>: <span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callerSourceLineNumber"</span></span>: <span class="hljs-number"><span class="hljs-number">525</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callerSource"</span></span>: <span class="hljs-string"><span class="hljs-string">"D:\\GitHub\\Unchase.FluentPerformanceMeter\\Unchase.FluentPerformanceMeter.TestWebAPI\\Controllers\\PerformanceMeterController.cs"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"steps"</span></span>: [] } ], <span class="hljs-attr"><span class="hljs-attr">"totalActivity"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"StartWatchingWithCallerName"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callsCount"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"currentActivity"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"StartWatchingWithCallerName"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callsCount"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"uptimeSince"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T13:35:45.2601668Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"className"</span></span>: <span class="hljs-string"><span class="hljs-string">"Unchase.FluentPerformanceMeter.TestWebAPI.Controllers.PerformanceMeterController"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"methodNames"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"StartWatchingWithCallerName"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: { }, <span class="hljs-attr"><span class="hljs-attr">"timerFrequency"</span></span>: <span class="hljs-number"><span class="hljs-number">10000000</span></span> }</code> </pre> <br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Die vorgestellte Lösung ermöglicht es uns daher, die Erfassung von Informationen über die Leistung von .NET-Anwendungsmethoden auf eine recht bequeme Weise teilweise zu automatisieren.  Die gesammelten Daten können auf eine Weise visualisiert werden, die für den jeweiligen Entwickler besser geeignet ist. </p><br><p>  Natürlich löst die Bibliothek nicht alle Probleme, die mit dem Sammeln von Daten zur Leistung von Methoden verbunden sind, sondern versucht, die gängigsten zu vereinfachen. </p><br><p>  Bei der Bibliothek handelt es sich um eine Open-Source-Lösung. Vorschläge und Vorschläge für deren Entwicklung sind ebenso willkommen wie Fehlerberichte (jeder kann dem <a href="https://github.com/unchase/Unchase.FluentPerformanceMeter/issues" rel="nofollow">Link</a> folgen; der Autor ist für jede Hilfe dankbar!). </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485198/">https://habr.com/ru/post/de485198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485184/index.html">Umfrageergebnisse mit Registerkarten</a></li>
<li><a href="../de485186/index.html">Billionen-Dollar-Startup oder wie die erfolgreichsten Valley-Unternehmen geboren wurden</a></li>
<li><a href="../de485190/index.html">Andrew Eun "Leidenschaft für maschinelles Lernen." Übersetzung der Kapitel 47-58</a></li>
<li><a href="../de485194/index.html">Segmentbaum: schnell und einfach</a></li>
<li><a href="../de485196/index.html">AvitoTech On Tour: Besuchen Sie Frontend-Meetings in Kasan</a></li>
<li><a href="../de485200/index.html">Mess am Start: Post-Mortem zur Startgeschwindigkeit einer iOS-Anwendung</a></li>
<li><a href="../de485202/index.html">Unterdrückungssystem</a></li>
<li><a href="../de485204/index.html">Zurück zum Anfang: Warum Amazon bald wieder mehr als 1 Billion US-Dollar kapitalisiert</a></li>
<li><a href="../de485206/index.html">Wie hat mich Typescript enttäuscht und ist es das wert?</a></li>
<li><a href="../de485208/index.html">Aufbau einer fehlertoleranten IT-Infrastruktur. Teil 2. Installieren und Konfigurieren des oVirt 4.3-Clusters</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>