<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüåæ üàöÔ∏è üó°Ô∏è Eine andere M√∂glichkeit, die Leistung von .NET-Anwendungsmethoden zu messen üññüèΩ ‚ò†Ô∏è üëºüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="H√§ufig ist es erforderlich, Statistiken √ºber die Leistung von Anwendungsmethoden in Echtzeit zu erfassen (wenn die Anwendung bereits ausgef√ºhrt wird),...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eine andere M√∂glichkeit, die Leistung von .NET-Anwendungsmethoden zu messen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485198/"><p><img src="https://habrastorage.org/webt/-q/hs/z8/-qhsz8oawswkr7chwsijjbkrr1y.png"></p><br><p>  H√§ufig ist es erforderlich, Statistiken √ºber die Leistung von Anwendungsmethoden in Echtzeit zu erfassen (wenn die Anwendung bereits ausgef√ºhrt wird), um die Engp√§sse zu ermitteln und festzustellen, welcher Teil der Anwendung langsamer wird. </p><br><p>  Dar√ºber hinaus w√§re es hilfreich, den Aufrufkontext zu speichern, in dem die Leistung verfolgt wird (z. B. Argumente zum Methodenaufruf und vom Entwickler hinzugef√ºgte beliebige Daten), zus√§tzlich zu den Leistungsdaten selbst (Zeitpunkt der Methodenentwicklung, Start- und Enddatum des Aufrufs). </p><br><p>  Nun, die "Kirsche auf dem Kuchen" kann als die Bequemlichkeit und Einfachheit des verwendeten Werkzeugs angesehen werden, was auch wichtig ist. </p><br><p>  Um diese Probleme zu l√∂sen, wurde eine plattform√ºbergreifende Open-Source-.NET-Bibliothek <a href="https://github.com/unchase/Unchase.FluentPerformanceMeter" rel="nofollow">Unchase.FluentPerformanceMeter entwickelt</a> . </p><a name="habracut"></a><br><h2 id="vvedenie">  Einleitung </h2><br><p> In diesem Artikel wird die Arbeit mit <a href="https://github.com/unchase/Unchase.FluentPerformanceMeter" rel="nofollow"><strong>Unchase Fluent Performance Meter beschrieben</strong></a> , einer plattform√ºbergreifenden Open-Source-Bibliothek mit <a href="https://github.com/unchase/Unchase.FluentPerformanceMeter" rel="nofollow"><strong>.NET</strong></a> <em>Standard 2.0</em> zur Berechnung der Leistung von Methoden. </p><br><p>  Die Bibliothek kann in .NET Core- und .NET Framework-Anwendungen verwendet werden, die .NET <em>Standard 2.0 unterst√ºtzen</em> , und erm√∂glicht <em>Folgendes</em> : </p><br><ul><li>  <a href="https://habr.com/ru/post/485198/"><strong>F√ºhren Sie genaue Messungen der</strong></a> Leistung <strong><em>√∂ffentlicher</em> Methoden</strong> f√ºr <strong><em>√∂ffentliche</em> Klassen</strong> sowohl Ihres Codes als auch des <a href="https://habr.com/ru/post/485198/">Codes der verwendeten Bibliotheken durch</a> (wobei Sie den genauen Zeitpunkt des Beginns und des Endes der Messung festlegen). </li><li>  <a href="https://habr.com/ru/post/485198/"><strong>F√ºgen Sie den</strong></a> Messergebnissen <strong>zus√§tzliche Daten</strong> (benutzerdefinierte Daten) hinzu.  Zum Beispiel die Werte der Eingabeparameter der Methode und des Ergebnisses;  oder Kontextdaten der Methodenausf√ºhrung;  oder <em>corellationId</em> , mit der mehrere Messungen der Leistung von Methoden verkn√ºpft werden k√∂nnen; </li><li>  <a href="https://habr.com/ru/post/485198/"><strong>Teilen Sie die Messung der</strong></a> Methodenleistung <strong>in separate Schritte</strong> (Steps) auf, wobei Sie f√ºr jeden Schritt eigene Daten festlegen.  Au√üerdem k√∂nnen Sie <a href="https://habr.com/ru/post/485198/">die minimale</a> Laufzeit <a href="https://habr.com/ru/post/485198/">festlegen</a> , ab der der Schritt bei der Messung ber√ºcksichtigt wird (wenn der Schritt schneller ausgef√ºhrt wird, wird er nicht gemessen). </li><li>  <strong>Bestimmte Teile des Codes</strong> <a href="https://habr.com/ru/post/485198/"><strong>von der</strong></a> Leistungsmessung ausschlie√üen (z. B. Aufrufe einzelner Methoden, deren Ausf√ºhrungszeit bei der Messung nicht ber√ºcksichtigt werden muss); </li><li>  <a href="https://habr.com/ru/post/485198/"><strong>F√ºgen Sie Ihre eigenen Befehle</strong></a> (Commands) hinzu, die garantiert <strong>sofort nach dem</strong> Ende der Leistungsmessung der Methode ausgef√ºhrt werden (z. B. um die erhaltenen Ergebnisse zus√§tzlich zu verarbeiten, z. B. um Daten zu protokollieren oder in den Speicher zu schreiben). </li><li>  <a href="https://habr.com/ru/post/485198/"><strong>F√ºgen Sie einen eigenen Ausnahmehandler</strong></a> f√ºr Code hinzu, der im Zusammenhang mit der Messung der Leistung der Methode ausgef√ºhrt wird (sowohl f√ºr alle Messungen als auch f√ºr jede Messung separat). </li><li>  <a href="https://habr.com/ru/post/485198/"><strong>Legen Sie die Zeit zum Speichern der Ergebnisse von</strong></a> Messungen der Produktivit√§t von Methoden fest. Danach werden die Ergebnisse gel√∂scht. </li><li>  <a href="https://habr.com/ru/post/485198/"><strong>F√ºgen Sie</strong></a> den Messergebnissen Daten dar√ºber hinzu, <strong>wer die Methode</strong> ( <em>Aufrufer</em> ) √ºber <em>IHttpContextAccesor</em> oder die Aufgabe des <em>Aufrufers</em> im Code <em>aufruft</em> (Sie k√∂nnen beispielsweise den Namen des externen Dienstes angeben, der die Methode aufgerufen hat). </li><li>  <a href="https://habr.com/ru/post/485198/"><strong>Erg√§nzen Sie die Messergebnisdaten</strong></a> an der Stelle, an der die Leistungsmessung gestartet wurde (Dateiname und Zeilennummer mit dem Anrufort im Code); </li><li>  <a href="https://habr.com/ru/post/485198/"><strong>Unterbrechen der Messung der</strong></a> Leistung der Methode <strong>bis zu ihrem Abschluss</strong> . </li></ul><br><p>  Die aus der Messung der Leistung der Methoden gewonnenen Daten k√∂nnen verwendet werden, um die Leistung der Anwendung (ihre einzelnen Teile, sowohl interner Code als auch externer Code der verwendeten Bibliotheken) zu analysieren und in einer f√ºr Sie geeigneten grafischen Form anzuzeigen. </p><br><h2 id="soderzhanie">  Inhalt </h2><br><ul><li>  <a href="https://habr.com/ru/post/485198/">Erste Schritte</a> </li><li>  <a href="https://habr.com/ru/post/485198/">Anwendungsbeispiele</a> <br><ul><li>  <a href="https://habr.com/ru/post/485198/">Methodenleistungsmessung</a> </li><li>  <a href="https://habr.com/ru/post/485198/">Methodenleistungsmessung mit DiagnosticSource</a> </li><li>  <a href="https://habr.com/ru/post/485198/">Messung der Leistung der von der Bibliothek verwendeten Methode</a> </li><li>  <a href="https://habr.com/ru/post/485198/">Hinzuf√ºgen zus√§tzlicher Daten (benutzerdefinierte Daten) und Paginierung (Schritte)</a> </li><li>  <a href="https://habr.com/ru/post/485198/">Ausnahme von der Messung (Ignorieren)</a> </li><li>  <a href="https://habr.com/ru/post/485198/">Befehle und Aktionen hinzuf√ºgen</a> </li><li>  <a href="https://habr.com/ru/post/485198/">Ausnahmebehandlungsroutinen hinzuf√ºgen</a> </li><li>  <a href="https://habr.com/ru/post/485198/">Einstellen der Datenspeicherzeit (Set Cache Time)</a> </li><li>  <a href="https://habr.com/ru/post/485198/">Hinzuf√ºgen von Daten zur aufrufenden Methode und zum Ort des Anrufs (Unterbrechung der Leistungsmessung)</a> </li></ul></li></ul><br><h2 id="a-namestarta-nachalo-raboty">  Erste Schritte </h2><br><p>  Installieren Sie das <a href="https://www.nuget.org/packages/Unchase.FluentPerformanceMeter/" rel="nofollow"><em>NuGet-</em> Paket</a> in Ihrem Projekt, um die Bibliothek zu verwenden: </p><br><h4 id="vruchnuyu-s-pomoschyu-menedzhera-nuget-paketov-package-manager">  Manuelles Verwenden des <em>NuGet</em> Package Managers: </h4><br><pre><code class="powershell hljs"><span class="hljs-built_in"><span class="hljs-built_in">Install-Package</span></span> Unchase.FluentPerformanceMeter</code> </pre> <br><h4 id="s-pomoschyu-net-cli">  Verwenden der .NET CLI: </h4><br><pre> <code class="powershell hljs">dotnet add package Unchase.FluentPerformanceMeter -<span class="hljs-literal"><span class="hljs-literal">-version</span></span> {version}</code> </pre> <br><blockquote>  Wobei {version} die Version des Pakets ist, das Sie installieren m√∂chten. <br>  Beispiel: <code>dotnet add package Unchase.FluentPerformanceMeter --version 1.0.0</code> </blockquote><br><h2 id="a-namesimplesamplesa-primery-ispolzovaniya">  Anwendungsbeispiele </h2><br><h3 id="izmerenie-proizvoditelnosti-metoda">  Methodenleistungsmessung </h3><br><p>  Im Folgenden finden Sie ein einfaches Beispiel f√ºr die Verwendung der Bibliothek (ohne Konfiguration und zus√§tzliche Einstellungen) zum Messen der Leistung der (Action) <code>SimpleWatchingMethodStart</code> <em>Asp.Net Core 2.2-WebAPI-</em> Anwendung " <code>SimpleWatchingMethodStart</code> controller (Controller) <code>PerformanceMeterController</code> <em>"</em> .  Dazu k√∂nnen Sie die Erweiterungsmethode <code>.WatchingMethod().Start()</code> oder eine √§hnliche Funktion <code>.StartWatching()</code> . <br>  Ab Version 1.0.5 k√∂nnen Sie auch <code>.WatchingMethod().Start(SimpleWatchingMethodStart)</code> oder <code>.StartWatching(SimpleWatchingMethodStart)</code> mit dem Methodennamen verwenden. </p><br><blockquote>  Alle Beispiele f√ºr die Verwendung der Bibliothek finden Sie in den <code>Unchase.FluentPerformanceMeter.Test*</code> -Projekten <a href="https://github.com/unchase/Unchase.FluentPerformanceMeter" rel="nofollow">dieses Repositorys</a> . </blockquote><br><pre> <code class="plaintext hljs">/// &lt;summary&gt; /// Test GET method with simple performance watching. /// &lt;/summary&gt; [HttpGet("SimpleWatchingMethodStart")] public ActionResult SimpleWatchingMethodStart() { // for C# 8 you can use: //using var pm = PerformanceMeter&lt;PerformanceMeterController&gt;.StartWatching(); using (PerformanceMeter&lt;PerformanceMeterController&gt;.WatchingMethod().Start()) { // put your code with some logic here return Ok(); } }</code> </pre> <br><p>  Um die Ergebnisse von Leistungsmessungen √∂ffentlicher Methoden der Controller-Klasse <code>PerformanceMeterController</code> abzurufen, k√∂nnen Sie die folgende Methode aufrufen: </p><br><pre> <code class="plaintext hljs">/// &lt;summary&gt; /// Get methods performance info for this controller. /// &lt;/summary&gt; /// &lt;returns&gt;Returns methods performance info.&lt;/returns&gt; [HttpGet("GetPerformanceInfo")] [IgnoreMethodPerformance] public ActionResult&lt;IPerformanceInfo&gt; GetPerformanceInfo() { return Ok(PerformanceMeter&lt;PerformanceMeterController&gt;.PerformanceInfo); }</code> </pre> <br><p>  Nach dem Aufruf der <code>SimpleWatchingMethodStart</code> Methode beim Aufruf von <code>GetPerformanceInfo</code> wir: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"methodCalls"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"SimpleWatchingMethodStart"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"elapsed"</span></span>: <span class="hljs-string"><span class="hljs-string">"00:00:00.0016350"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"caller"</span></span>: <span class="hljs-string"><span class="hljs-string">"unknown"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"startTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T10:27:27.3385385Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"endTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T10:27:27.3401735Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"steps"</span></span>: [] } ], <span class="hljs-attr"><span class="hljs-attr">"totalActivity"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"SimpleWatchingMethodStart"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callsCount"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"currentActivity"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"SimpleWatchingMethodStart"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callsCount"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"uptimeSince"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T10:27:27.3370183Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"className"</span></span>: <span class="hljs-string"><span class="hljs-string">"Unchase.FluentPerformanceMeter.TestWebAPI.Controllers.PerformanceMeterController"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"methodNames"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"SimpleWatchingMethodStart"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"timerFrequency"</span></span>: <span class="hljs-number"><span class="hljs-number">10000000</span></span> }</code> </pre> <br><h3 id="a-namediagnosticsourcesamplea-izmerenie-proizvoditelnosti-metoda-s-pomoschyu-diagnosticsource">  Methodenleistungsmessung mit <code>DiagnosticSource</code> </h3><br><p>  Ab Version <em>1.1.0</em> konnte die Leistung von Methoden in einer <em>AspNetCore MVC-</em> Anwendung mithilfe von <code>DiagnosticSource</code> und dem speziellen Attribut <code>WatchingWithDiagnosticSourceAttribute</code> <em>gemessen</em> werden. <br>  <a href="" rel="nofollow"><code>Unchase.FluentPerformanceMeter.AspNetCore.Mvc</code></a> Sie dazu das <a href="" rel="nofollow"><code>Unchase.FluentPerformanceMeter.AspNetCore.Mvc</code></a> Paket zum <em>NuGet-</em> Projekt hinzu und f√ºgen Sie <code>Startap.cs</code> den folgenden Code <code>Startap.cs</code> : </p><br><pre> <code class="plaintext hljs">public void ConfigureServices(IServiceCollection services) { // ... // allows to measure methods performance for class "MeasurableClass" and "MeasurableSecondClass" services.AddPerformanceDiagnosticObserver&lt;MeasurableClass&gt;(); services.AddPerformanceDiagnosticObserver&lt;MeasurableSecondClass&gt;(); // ... the same for another classes services.AddMvc(); // ... } public void Configure(IApplicationBuilder app, IHostingEnvironment env) { // ... app.UsePerformanceDiagnosticObserver(); app.UseMvc(); }</code> </pre> <br><p>  Dann markieren Sie mit dem Attribut <code>WatchingWithDiagnosticSourceAttribute</code> oder einzelnen Methoden: </p><br><pre> <code class="plaintext hljs">[HttpGet("SimpleWatchingMethodStart")] [WatchingWithDiagnosticSource] public ActionResult SimpleWatchingMethodStart() { return Ok(); }</code> </pre> <br><p>  oder die ganze Klasse: </p><br><pre> <code class="plaintext hljs">[ApiController] [Route("api/v1/[controller]")] [Produces("application/json")] [SwaggerTag("Unchase.PerformanceMeter Test WebAPI Controller")] [WatchingWithDiagnosticSource] public class PerformanceMeterController : ControllerBase { // measurable methods }</code> </pre> <br><p>  Ab Version <em>1.2.0</em> konnten in einer <em>AspNetCore MVC-</em> Anwendung mithilfe des speziellen <code>AddMethodArgumentsToCustomDataAttribute</code> Attributs in Verbindung mit dem <code>WatchingWithDiagnosticSourceAttribute</code> Attribut <code>AddMethodArgumentsToCustomDataAttribute</code> Leistungsmessdaten von Benutzermethoden <code>AddMethodArgumentsToCustomDataAttribute</code> werden: </p><br><pre> <code class="plaintext hljs">[HttpPost("SimpleWatchingMethodStartWithArgs")] [WatchingWithDiagnosticSource] [AddMethodArgumentsToCustomData("actionArguments")] public ActionResult SimpleWatchingMethodStartWithArgs(DTOArgument arg) { return Ok(); }</code> </pre> <br><p>  Nach dem Aufruf der <code>SimpleWatchingMethodStartWithArgs</code> Methode beim Aufruf von <code>GetPerformanceInfo</code> wir: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"methodCalls"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"SimpleWatchingMethodStartWithArgs"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"elapsed"</span></span>: <span class="hljs-string"><span class="hljs-string">"00:00:00.0016350"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"caller"</span></span>: <span class="hljs-string"><span class="hljs-string">"unknown"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"startTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T10:27:27.3385385Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"endTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T10:27:27.3401735Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"actionArguments"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"arg"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"data"</span></span>: <span class="hljs-string"><span class="hljs-string">"&lt;string_in_DTOArgument&gt;"</span></span> } } }, <span class="hljs-attr"><span class="hljs-attr">"steps"</span></span>: [] } ], <span class="hljs-attr"><span class="hljs-attr">"totalActivity"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"SimpleWatchingMethodStartWithArgs"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callsCount"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"currentActivity"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"SimpleWatchingMethodStartWithArgs"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callsCount"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"uptimeSince"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T10:27:27.3370183Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"className"</span></span>: <span class="hljs-string"><span class="hljs-string">"Unchase.FluentPerformanceMeter.TestWebAPI.Controllers.PerformanceMeterController"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"methodNames"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"SimpleWatchingMethodStartWithArgs"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"timerFrequency"</span></span>: <span class="hljs-number"><span class="hljs-number">10000000</span></span> }</code> </pre> <br><h3 id="a-namesampleexternala-izmerenie-proizvoditelnosti-metoda-ispolzuemoy-biblioteki">  Messung der Leistung der von der Bibliothek verwendeten Methode </h3><br><p>  Um die Leistung der <em>√∂ffentlichen</em> Methode der <em>√∂ffentlichen</em> Klasse der verwendeten Drittanbieter-Bibliothek zu messen, m√ºssen Sie die Klasse selbst und den Namen ihrer Methode explizit festlegen: </p><br><pre> <code class="plaintext hljs">[HttpGet("GetThreadSleepPerformance")] public ActionResult&lt;string&gt; GetThreadSleepPerformance() { using (PerformanceMeter&lt;Thread&gt;.WatchingMethod(nameof(Thread.Sleep)).Start()) { Thread.Sleep(1000); } return Ok(PerformanceMeter&lt;Thread&gt;.PerformanceInfo.MethodCalls.FirstOrDefault(ta =&gt; ta.MethodName == nameof(Thread.Sleep))?.Elapsed); }</code> </pre> <br><p>  Die ausgef√ºhrte Methode gibt Folgendes zur√ºck: </p><br><pre> <code class="plaintext hljs">"00:00:01.0033040"</code> </pre> <br><p>  Sie k√∂nnen Daten zum Aufrufen dieser Methode √ºber einen Aufruf abrufen: </p><br><pre> <code class="plaintext hljs">/// &lt;summary&gt; /// Get methods performance info for Thread class. /// &lt;/summary&gt; /// &lt;returns&gt;Returns Thread methods performance info.&lt;/returns&gt; [HttpGet("GetThreadPerformanceInfo")] [IgnoreMethodPerformance] public ActionResult&lt;IPerformanceInfo&gt; GetThreadPerformanceInfo() { return Ok(PerformanceMeter&lt;Thread&gt;.PerformanceInfo); }</code> </pre> <br><blockquote>  Das <code>IgnoreMethodPerformance</code> Attribut <code>IgnoreMethodPerformance</code> so konzipiert, dass die von ihm <code>IgnoreMethodPerformance</code> Methode beim Messen der Leistung nicht ber√ºcksichtigt wird. </blockquote><p>  Als Antwort auf den Aufruf dieser Methode wird sein: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"methodCalls"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"Sleep"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"elapsed"</span></span>: <span class="hljs-string"><span class="hljs-string">"00:00:01.0033040"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"caller"</span></span>: <span class="hljs-string"><span class="hljs-string">"unknown"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"startTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T13:08:09.336624Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"endTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T13:08:10.339928Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"steps"</span></span>: [] } ], <span class="hljs-attr"><span class="hljs-attr">"totalActivity"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"Abort"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callsCount"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }, // ... { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"Sleep"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callsCount"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } // ... ], <span class="hljs-attr"><span class="hljs-attr">"currentActivity"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"Abort"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callsCount"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }, // ... { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"Sleep"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callsCount"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } // ... ], <span class="hljs-attr"><span class="hljs-attr">"uptimeSince"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T13:08:09.3357028Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"className"</span></span>: <span class="hljs-string"><span class="hljs-string">"System.Threading.Thread"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"methodNames"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"Abort"</span></span>, // ... <span class="hljs-string"><span class="hljs-string">"Sleep"</span></span>, // ... ], <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"timerFrequency"</span></span>: <span class="hljs-number"><span class="hljs-number">10000000</span></span> }</code> </pre> <br><h3 id="a-namesamplecustomdataa-dobavlenie-dopolnitelnyh-dannyh-custom-data-i-razbienie-na-shagi-steps">  Hinzuf√ºgen zus√§tzlicher Daten (benutzerdefinierte Daten) und Paginierung (Schritte) </h3><br><p>  Sie k√∂nnen zus√§tzliche Daten (benutzerdefinierte Daten) f√ºr alle Leistungsmessungen von Methoden einer bestimmten Klasse hinzuf√ºgen.  Zum Beispiel im statischen Konstruktor der Controller-Klasse <code>PerformanceMeterController</code> : </p><br><pre> <code class="plaintext hljs">[ApiController] [Route("api/v1/[controller]")] public class PerformanceMeterController : ControllerBase { /// &lt;summary&gt; /// Static constructor. /// &lt;/summary&gt; static PerformanceMeterController() { // add common custom data (string) to class performance information PerformanceMeter&lt;PerformanceMeterController&gt;.AddCustomData("Tag", "CustomTag"); // add common custom data (anonymous class) to class performance information PerformanceMeter&lt;PerformanceMeterController&gt;.AddCustomData("Custom anonymous class", new { Name = "Custom Name", Value = 1 }); } // ... actions }</code> </pre> <br><p>  Dar√ºber hinaus k√∂nnen Sie mithilfe der Erweiterungsmethode <code>.WithSettingData.CustomData("&lt;key&gt;", &lt;value&gt;)</code> (einschlie√ülich eines speziellen Attributs der <code>MethodCustomDataAttribute</code> Methode) und f√ºr jeden Schritt (Step) zus√§tzliche Daten (Custom Data) f√ºr eine bestimmte Messung hinzuf√ºgen ) dieser Messung, hinzugef√ºgt unter Verwendung der Erweiterungsmethode <code>.Step("&lt;step_name&gt;")</code> , unter Verwendung der Erweiterungsmethode <code>.AddCustomData("&lt;key&gt;", &lt;value&gt;)</code> : </p><br><pre> <code class="plaintext hljs">/// &lt;summary&gt; /// Test GET method with simple performance watching (with steps). /// &lt;/summary&gt; [HttpGet("SimpleStartWatchingWithSteps")] [MethodCustomData("Custom data from attribute", "Attr")] public ActionResult SimpleStartWatchingWithSteps() { using (var pm = PerformanceMeter&lt;PerformanceMeterController&gt; .WatchingMethod() .WithSettingData .CustomData("coins", 1) .CustomData("Coins sets", new { Gold = "Many", Silver = 5 }) .Start()) { // put your code with some logic here // add "Step 1" using (pm.Step("Step 1")) { Thread.Sleep(1000); } // add "Step 2" with custom data using (var pmStep = pm.Step("Step 2").AddCustomData("step2 custom data", "data!")) { // add "Step 3 in Step 2" using (pm.Step("Step 3 in Step 2")) { Thread.Sleep(1000); } // add custom data to "Step 2" pmStep.AddCustomData("step2 another custom data", "data2!"); // get and remove custom data from "Step 2" var customData = pmStep.GetAndRemoveCustomData&lt;string&gt;("step2 custom data"); // get custom data from "Step 2" (without removing) var anotherCustomData = pmStep.GetCustomData&lt;string&gt;("step2 another custom data"); // ... } } }</code> </pre> <br><p>  Als Ergebnis <code>GetPerformanceInfo</code> wir beim Aufruf von <code>GetPerformanceInfo</code> : </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"methodCalls"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"SimpleStartWatchingWithSteps"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"elapsed"</span></span>: <span class="hljs-string"><span class="hljs-string">"00:00:02.0083031"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"caller"</span></span>: <span class="hljs-string"><span class="hljs-string">"unknown"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"startTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T11:58:18.9006891Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"endTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T11:58:20.9089922Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Coins sets"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"gold"</span></span>: <span class="hljs-string"><span class="hljs-string">"Many"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"silver"</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"coins"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Custom data from attribute"</span></span>: <span class="hljs-string"><span class="hljs-string">"Attr"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"steps"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"stepName"</span></span>: <span class="hljs-string"><span class="hljs-string">"Step 1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"elapsed"</span></span>: <span class="hljs-string"><span class="hljs-string">"00:00:01.0009758"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"startTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T11:58:18.9018272Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"endTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T11:58:19.902803Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: {} }, { <span class="hljs-attr"><span class="hljs-attr">"stepName"</span></span>: <span class="hljs-string"><span class="hljs-string">"Step 3 in Step 2"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"elapsed"</span></span>: <span class="hljs-string"><span class="hljs-string">"00:00:01.0004549"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"startTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T11:58:19.9046523Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"endTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T11:58:20.9051072Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: {} }, { <span class="hljs-attr"><span class="hljs-attr">"stepName"</span></span>: <span class="hljs-string"><span class="hljs-string">"Step 2"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"elapsed"</span></span>: <span class="hljs-string"><span class="hljs-string">"00:00:01.0029596"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"startTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T11:58:19.904534Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"endTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T11:58:20.9074936Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"step2 another custom data"</span></span>: <span class="hljs-string"><span class="hljs-string">"data2!"</span></span> } } ] } ], <span class="hljs-attr"><span class="hljs-attr">"totalActivity"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"SimpleStartWatchingWithSteps"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callsCount"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"currentActivity"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"SimpleStartWatchingWithSteps"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callsCount"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"uptimeSince"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T11:58:18.8801249Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"className"</span></span>: <span class="hljs-string"><span class="hljs-string">"Unchase.FluentPerformanceMeter.TestWebAPI.Controllers.PerformanceMeterController"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"methodNames"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"SimpleStartWatchingWithSteps"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Tag"</span></span>: <span class="hljs-string"><span class="hljs-string">"CustomTag"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Custom anonymous class"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Custom Name"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"timerFrequency"</span></span>: <span class="hljs-number"><span class="hljs-number">10000000</span></span> }</code> </pre> <br><h3 id="a-namesampleignorea-isklyuchenie-iz-zamera-ignore">  Ausnahme von der Messung (Ignorieren) </h3><br><p>  Sie k√∂nnen einzelne Teile der Methode beim Messen der Leistung ignorieren (mithilfe von <code>.Ignore()</code> oder <code>.Executing().WithoutWatching().Start(&lt;Action&gt;)</code> ) und auch einzelne Schritte nicht speichern (Erweiterungsmethode <code>.StepIf("&lt;step_name&gt;", &lt;minSaveMs&gt;)</code> ), wenn sie die Bedingung nicht erf√ºllen (die Ausf√ºhrungszeit des Schritts wird in der Ausf√ºhrungszeit der Methode ber√ºcksichtigt): </p><br><pre> <code class="plaintext hljs">using (var pm = PerformanceMeter&lt;PerformanceMeterController&gt;.WatchingMethod().Start()) { // put your code with some logic here // sleep 1 sec Thread.Sleep(1000); // ignore this block in performance watching using (pm.Ignore()) { Thread.Sleep(5000); } // skip this step with minSaveMs (not save, but consider duration in method performance watching) using (pm.StepIf("Skipped step", minSaveMs: 1000)) { Thread.Sleep(500); } // execute action without performance watching pm.Executing().WithoutWatching().Start(() =&gt; { Thread.Sleep(2000); }); return Ok(); }</code> </pre> <br><p>  Als Ergebnis erhalten wir: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"methodCalls"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"SimpleStartWatchingWithIgnored"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"elapsed"</span></span>: <span class="hljs-string"><span class="hljs-string">"00:00:01.5080227"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"caller"</span></span>: <span class="hljs-string"><span class="hljs-string">"unknown"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"startTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T12:34:36.9187359Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"endTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T12:34:38.4267586Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"steps"</span></span>: [] } ], <span class="hljs-attr"><span class="hljs-attr">"totalActivity"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"SimpleStartWatchingWithIgnored"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callsCount"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"currentActivity"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"SimpleStartWatchingWithIgnored"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callsCount"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"uptimeSince"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T12:34:36.9035129Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"className"</span></span>: <span class="hljs-string"><span class="hljs-string">"Unchase.FluentPerformanceMeter.TestWebAPI.Controllers.PerformanceMeterController"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"methodNames"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"SimpleStartWatchingWithIgnored"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: { }, <span class="hljs-attr"><span class="hljs-attr">"timerFrequency"</span></span>: <span class="hljs-number"><span class="hljs-number">10000000</span></span> }</code> </pre> <br><h3 id="a-namesamplecustomcommandsa-dobavlenie-komand-commands-i-deystviy-actions">  Befehle und Aktionen hinzuf√ºgen </h3><br><p>  Um einen Befehl hinzuzuf√ºgen, dessen Ausf√ºhrung nach Abschluss der Messung der Leistung einer Methode garantiert ist, muss eine Befehlsklasse erstellt werden, die die <code>IPerformanceCommand</code> Schnittstelle implementiert. <br>  Gleichzeitig k√∂nnen Sie beliebige Daten √ºber den Konstruktor des erstellten Befehls √ºbertragen, der w√§hrend seiner Ausf√ºhrung verwendet wird.  Zum Beispiel: </p><br><pre> <code class="plaintext hljs">/// &lt;summary&gt; /// Custom executed command. /// &lt;/summary&gt; public class ExecutedCommand : IPerformanceCommand { /// &lt;summary&gt; /// Executed commad name. /// &lt;/summary&gt; public string CommandName =&gt; this.GetType().Name; private string _customString { get; } internal bool IsCommandExecuted { get; private set; } /// &lt;summary&gt; /// Constructor. /// &lt;/summary&gt; /// &lt;remarks&gt; /// You can pass any data through the command constructor. /// &lt;/remarks&gt; /// &lt;param name="customString"&gt;&lt;/param&gt; public ExecutedCommand(string customString) { this._customString = customString; } /// &lt;summary&gt; /// Execute command. /// &lt;/summary&gt; /// &lt;param name="performanceInfo"&gt;&lt;see cref="IPerformanceInfo"/&gt;.&lt;/param&gt; public void Execute(IPerformanceInfo performanceInfo) { // for example, write to the debug console some information Debug.WriteLine(this.CommandName); Debug.WriteLine(this._customString); Debug.WriteLine($"Method names count: {performanceInfo.MethodNames.Count}"); this.IsCommandExecuted = true; } }</code> </pre> <br><p>  Sie k√∂nnen einen Befehl (IPerformanceCommand) und eine Aktion (Action) hinzuf√ºgen, damit sie am Ende der Messung wie folgt ausgef√ºhrt werden: </p><br><pre> <code class="plaintext hljs">// custom "ExecutedCommand" will be executed after performance watching is completed using (PerformanceMeter&lt;PerformanceMeterController&gt; .WatchingMethod() .WithExecutingOnComplete .Command(new ExecutedCommand("bla-bla-bla")) .Action((pi) =&gt; { Debug.WriteLine($"Class name: {pi.ClassName}"); }) .Start()) { return Ok(); }</code> </pre> <br><p>  Als Ergebnis wird am Ende der Messung der Leistung der Methode in der <em>Debug-</em> Konsole <em>Folgendes</em> angezeigt: </p><br><pre> <code class="plaintext hljs">ExecutedCommand bla-bla-bla Method names count: 13 Class name: Unchase.FluentPerformanceMeter.TestWebAPI.Controllers.PerformanceMeterController</code> </pre> <br><h3 id="a-namesamplecustomexceptionhandlera-dobavlenie-obrabotchikov-isklyucheniy-exception-handlers">  Ausnahmebehandlungsroutinen hinzuf√ºgen </h3><br><p>  Wenn Sie Ausnahmen behandeln m√ºssen, die w√§hrend der Ausf√ºhrung eines Teils der Methode auftreten k√∂nnen, f√ºr die die Leistung √ºberwacht wird, m√ºssen Sie einen Ausnahmebehandler wie folgt hinzuf√ºgen: </p><br><pre> <code class="plaintext hljs">using (var pm = PerformanceMeter&lt;PerformanceMeterController&gt;.StartWatching()) { // execute action throws Exception with exception handler pm.Executing() .WithExceptionHandler((ex) =&gt; Debug.WriteLine(ex.Message)) .Start(() =&gt; throw new Exception("Exception")); // execute action throws custom Exception with exception handler pm.Executing&lt;CustomException&gt;() .WithExceptionHandler((ex) =&gt; { Debug.WriteLine(ex.Message); }) .Start(() =&gt; { throw new CustomException("Custom exception was occured!"); }); return Ok(); }</code> </pre> <br><p>  Wo ist die <code>CustomException</code> Klasse, zum Beispiel: </p><br><pre> <code class="plaintext hljs">/// &lt;summary&gt; /// Custom exception. /// &lt;/summary&gt; public class CustomException : Exception { public CustomException(string message) : base(message) { } public CustomException(string message, Exception innerException) : base(message, innerException) { } public CustomException() { } }</code> </pre> <br><p>  Infolgedessen zeigt die <em>Debug-</em> Konsole Folgendes an: </p><br><pre> <code class="plaintext hljs">Exception Custom exception was occured!</code> </pre> <br><p>  Dar√ºber hinaus k√∂nnen Sie einen Ausnahmebehandler angeben, der standardm√§√üig zum Messen der Leistung jeder Methode dieser Klasse verwendet wird, z. B. √ºber den statischen Konstruktor der <code>PerformanceMeterController</code> Controllerklasse: </p><br><pre> <code class="plaintext hljs">[ApiController] [Route("api/v1/[controller]")] public class PerformanceMeterController : ControllerBase { /// &lt;summary&gt; /// Static constructor. /// &lt;/summary&gt; static PerformanceMeterController() { // set default exception handler for PerformanceMeterController class PerformanceMeter&lt;PerformanceMeterController&gt;.SetDefaultExceptionHandler((ex) =&gt; Debug.WriteLine(ex.Message)); } // ... actions }</code> </pre> <br><h3 id="a-namesamplesettingcachetimea-ustanovka-vremeni-hraneniya-dannyh-set-cache-time">  Einstellen der Datenspeicherzeit (Set Cache Time) </h3><br><p>  Sie k√∂nnen die Speicherzeit f√ºr die Daten der Leistungsmessungen von Methoden einstellen, nach deren Ablauf diese Daten gel√∂scht werden.  F√ºr jede Klasse, f√ºr die eine Messung durchgef√ºhrt wird, wird diese Zeit separat eingestellt.  Die Zeit kann beispielsweise √ºber den statischen Konstruktor der <code>PerformanceMeterController</code> Controller-Klasse festgelegt werden: </p><br><pre> <code class="plaintext hljs">[ApiController] [Route("api/v1/[controller]")] public class PerformanceMeterController : ControllerBase { /// &lt;summary&gt; /// Static constructor. /// &lt;/summary&gt; static PerformanceMeterController() { // set cache time for PerformanceMeterController class PerformanceMeter&lt;PerformanceMeterController&gt;.SetMethodCallsCacheTime(5); } // ... actions }</code> </pre> <br><h3 id="a-namesamplesetcallerandsourcewithstopa-dobavlenie-dannyh-o-vyzyvayuschem-metod-i-meste-vyzova-i-preryvanie-zamera-proizvoditelnosti">  Hinzuf√ºgen von Daten zur aufrufenden Methode und zum Ort des Anrufs (und Unterbrechen der Leistungsmessung) </h3><br><ul><li><p>  Sie k√∂nnen angeben, wer die Methode aufruft, indem Sie die Erweiterungsmethode <code>.CallerFrom("&lt;caller_name&gt;")</code> (entweder eine Zeichenfolge oder <em>IHttpContextAccessor wird an sie √ºbergeben</em> ) oder ein spezielles Attribut der Methode <code>[MethodCaller("&lt;caller_name&gt;")]</code> .  Wenn sowohl das Attribut als auch die Erweiterungsmethode verwendet werden, wird der Wert von dieser √ºbernommen. </p><br></li><li><p>  Mit der Erweiterungsmethode <code>.WithSettingData.CallerSourceData()</code> ein <code>.WithSettingData.CallerSourceData()</code> zum Messen der Leistung hinzugef√ºgt. </p><br></li><li><p>  Verwenden Sie die Erweiterungsmethode <code>.StopWatching()</code> oder die Methode <code>Dispose()</code> direkt, um die Messung der Leistung innerhalb des <code>using</code> Blocks zu <code>.StopWatching()</code> : </p><br></li></ul><br><pre> <code class="plaintext hljs">[HttpPost("StartWatchingWithCallerName")] [MethodCaller("testCaller")] public ActionResult&lt;string&gt; StartWatchingWithCallerName([FromBody] string value) { // method performance info will reach with caller name (if internal HttpContextAccessor is null) using (var pm = PerformanceMeter&lt;PerformanceMeterController&gt; .WatchingMethod() .WithSettingData .CallerSourceData() .CallerFrom("Test caller") .Start()) { pm.StopWatching(); // stop watching here (or you can use "pm.Dispose();") Thread.Sleep(2000); return Ok(value); } }</code> </pre> <br><p>  Durch den Aufruf der Methode <code>GetPerformanceInfo</code> : </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"methodCalls"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"StartWatchingWithCallerName"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"elapsed"</span></span>: <span class="hljs-string"><span class="hljs-string">"00:00:00.0019172"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"caller"</span></span>: <span class="hljs-string"><span class="hljs-string">"Test caller"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"startTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T13:35:45.3164507Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"endTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T13:35:45.3183679Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"customData123"</span></span>: <span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callerSourceLineNumber"</span></span>: <span class="hljs-number"><span class="hljs-number">525</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callerSource"</span></span>: <span class="hljs-string"><span class="hljs-string">"D:\\GitHub\\Unchase.FluentPerformanceMeter\\Unchase.FluentPerformanceMeter.TestWebAPI\\Controllers\\PerformanceMeterController.cs"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"steps"</span></span>: [] } ], <span class="hljs-attr"><span class="hljs-attr">"totalActivity"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"StartWatchingWithCallerName"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callsCount"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"currentActivity"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"methodName"</span></span>: <span class="hljs-string"><span class="hljs-string">"StartWatchingWithCallerName"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"callsCount"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"uptimeSince"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-06T13:35:45.2601668Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"className"</span></span>: <span class="hljs-string"><span class="hljs-string">"Unchase.FluentPerformanceMeter.TestWebAPI.Controllers.PerformanceMeterController"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"methodNames"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"StartWatchingWithCallerName"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"customData"</span></span>: { }, <span class="hljs-attr"><span class="hljs-attr">"timerFrequency"</span></span>: <span class="hljs-number"><span class="hljs-number">10000000</span></span> }</code> </pre> <br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Die vorgestellte L√∂sung erm√∂glicht es uns daher, die Erfassung von Informationen √ºber die Leistung von .NET-Anwendungsmethoden auf eine recht bequeme Weise teilweise zu automatisieren.  Die gesammelten Daten k√∂nnen auf eine Weise visualisiert werden, die f√ºr den jeweiligen Entwickler besser geeignet ist. </p><br><p>  Nat√ºrlich l√∂st die Bibliothek nicht alle Probleme, die mit dem Sammeln von Daten zur Leistung von Methoden verbunden sind, sondern versucht, die g√§ngigsten zu vereinfachen. </p><br><p>  Bei der Bibliothek handelt es sich um eine Open-Source-L√∂sung. Vorschl√§ge und Vorschl√§ge f√ºr deren Entwicklung sind ebenso willkommen wie Fehlerberichte (jeder kann dem <a href="https://github.com/unchase/Unchase.FluentPerformanceMeter/issues" rel="nofollow">Link</a> folgen; der Autor ist f√ºr jede Hilfe dankbar!). </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485198/">https://habr.com/ru/post/de485198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485184/index.html">Umfrageergebnisse mit Registerkarten</a></li>
<li><a href="../de485186/index.html">Billionen-Dollar-Startup oder wie die erfolgreichsten Valley-Unternehmen geboren wurden</a></li>
<li><a href="../de485190/index.html">Andrew Eun "Leidenschaft f√ºr maschinelles Lernen." √úbersetzung der Kapitel 47-58</a></li>
<li><a href="../de485194/index.html">Segmentbaum: schnell und einfach</a></li>
<li><a href="../de485196/index.html">AvitoTech On Tour: Besuchen Sie Frontend-Meetings in Kasan</a></li>
<li><a href="../de485200/index.html">Mess am Start: Post-Mortem zur Startgeschwindigkeit einer iOS-Anwendung</a></li>
<li><a href="../de485202/index.html">Unterdr√ºckungssystem</a></li>
<li><a href="../de485204/index.html">Zur√ºck zum Anfang: Warum Amazon bald wieder mehr als 1 Billion US-Dollar kapitalisiert</a></li>
<li><a href="../de485206/index.html">Wie hat mich Typescript entt√§uscht und ist es das wert?</a></li>
<li><a href="../de485208/index.html">Aufbau einer fehlertoleranten IT-Infrastruktur. Teil 2. Installieren und Konfigurieren des oVirt 4.3-Clusters</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>