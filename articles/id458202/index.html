<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¾â€ğŸš€ ğŸ‘©ğŸ¾â€ğŸ¤â€ğŸ‘¨ğŸ¼ ğŸ¤ğŸ½ Lihatlah SObjectizer jika Anda ingin menggunakan Aktor atau CSP dalam proyek C ++ Anda ğŸ‘©â€ğŸš’ ğŸ§“ğŸ½ ğŸ‘ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa kata tentang SObjectizer dan sejarahnya 


 SObjectizer adalah kerangka C ++ agak kecil yang menyederhanakan pengembangan aplikasi multithrea...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lihatlah SObjectizer jika Anda ingin menggunakan Aktor atau CSP dalam proyek C ++ Anda</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458202/"><p><img src="https://habrastorage.org/webt/qq/0_/at/qq0_atvjcf2gb0uklnpqjbl31hw.jpeg"></p><br><h1 id="a-few-words-about-sobjectizer-and-its-history">  Beberapa kata tentang SObjectizer dan sejarahnya </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">SObjectizer</a> adalah kerangka C ++ agak kecil yang menyederhanakan pengembangan aplikasi multithreaded.  SObjectizer memungkinkan pengembang untuk menggunakan pendekatan dari model Aktor, Terbitkan-Berlangganan, dan Berkomunikasi Proses Berurutan (CSP).  Ini adalah proyek OpenSource yang didistribusikan di bawah lisensi BSD-3-CLAUSE. </p><br><p>  SObjectizer memiliki sejarah panjang.  SObjectizer sendiri lahir pada tahun 2002 sebagai proyek SObjectizer-4.  Tetapi didasarkan pada ide-ide dari ObjectADA SCADA sebelumnya yang dikembangkan antara 1995 dan 2000. SObjectizer-4 bersumber terbuka pada tahun 2006, tetapi evolusinya dihentikan segera setelah itu.  Versi baru SObjectizer dengan nama SObjectizer-5 dimulai pada 2010 dan bersumber terbuka pada 2013. Evolusi SObjectizer-5 masih dalam proses dan SObjectizer-5 telah memasukkan banyak fitur baru sejak 2013. </p><br><p>  SObjectizer kurang lebih dikenal di segmen Internet Rusia, tetapi hampir tidak dikenal di luar exUSSR.  Itu karena SObjectizer terutama digunakan untuk proyek-proyek lokal di negara-negara exUSSR dan banyak artikel, presentasi, dan pembicaraan tentang SObjectizer dalam bahasa Rusia. </p><br><h1 id="a-niche-for-sobjectizer-and-similar-tools">  Ceruk untuk SObjectizer dan alat serupa </h1><br><p>  Multithreading digunakan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">komputasi Paralel</a> maupun dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">komputasi Bersamaan</a> .  Tetapi ada perbedaan besar antara komputasi Paralel dan Bersamaan.  Dan, sebagai konsekuensinya, ada alat yang ditargetkan komputasi Paralel, dan ada alat untuk komputasi Bersamaan, dan mereka berbeda. </p><a name="habracut"></a><br><p>  Secara kasar, komputasi paralel adalah tentang menggunakan beberapa inti untuk mengurangi waktu perhitungan.  Misalnya, transcoding file video dari satu format ke format lain dapat memakan waktu satu jam pada satu inti CPU, tetapi hanya 15 menit pada empat inti CPU.  Alat-alat seperti OpenMP, Intel TBB, HPX atau cpp-taskflow dirancang untuk digunakan dalam komputasi Paralel.  Dan alat-alat itu mendukung pendekatan area yang sesuai, seperti pemrograman berbasis tugas atau aliran data. </p><br><p>  Komputasi bersamaan adalah tentang menangani banyak (mungkin berbeda) tugas pada saat yang bersamaan.  Server database atau MQ-broker dapat menjadi contoh yang baik: server harus menerima koneksi, membaca dan mem-parsing data dari koneksi yang diterima, menangani permintaan yang diterima (melakukan beberapa tindakan untuk setiap permintaan), mengirim respons, dan sebagainya.  Sebenarnya, tidak perlu menggunakan multithreading dalam komputasi bersamaan: semua tugas itu dapat dilakukan hanya pada satu utas pekerja.  Tetapi penggunaan multithreading dan beberapa core CPU dapat membuat aplikasi Anda lebih berkinerja, terukur dan responsif. </p><br><p>  Pendekatan seperti Actor Model atau CSP dimaksudkan untuk menangani komputasi secara bersamaan.  Contoh-contoh baik dari Aktor penggunaan dalam area komputasi secara bersamaan adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">proyek InfineSQL</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Yandex Message-Queue</a> .  Kedua proyek tersebut menggunakan aktor di dalam. </p><br><p>  Jadi alat seperti SObjectizer, QP / C ++ atau CAF, yang mendukung Actor Model, berguna dalam menyelesaikan tugas-tugas dari area komputasi Concurrent.  Ini berarti bahwa penggunaan SObjectizer mungkin tidak akan memberi Anda apa pun dalam tugas-tugas seperti konversi aliran video.  Tetapi Anda bisa mendapatkan hasil yang sangat berbeda dengan menerapkan broker pesan di atas SObjectizer. </p><br><h2 id="disclaimer">  Penafian </h2><br><p>  Penggunaan model Aktor- atau CSP dapat memberi Anda manfaat besar dalam beberapa tugas, tetapi tidak ada jaminan bahwa model tersebut sesuai untuk masalah khusus Anda.  Pembicaraan tentang penerapan model Aktor- atau CSP berada di luar cakupan artikel itu.  Mari kita asumsikan bahwa model Aktor atau / dan CSP berlaku untuk tugas Anda dan Anda tahu cara menggunakannya secara efisien. </p><br><h1 id="what-sobjectizer-can-give-to-a-user">  SObjectizer apa yang dapat diberikan kepada pengguna? </h1><br><h2 id="shared-nothing-and-fire-and-forget-principles-just-out-of-box">  Prinsip shared-nothing dan fire-and-forget baru saja keluar dari kotak </h2><br><p>  Penggunaan Aktor mengasumsikan tidak adanya data bersama.  Setiap aktor memiliki datanya dan data ini tidak dapat dilihat oleh orang lain.  Ini adalah <em>prinsip shared-nothing</em> yang terkenal dalam pengembangan aplikasi terdistribusi, misalnya.  Dalam aplikasi multithread, prinsip shared-nothing memiliki manfaat penting: memungkinkan untuk menghindari masalah berbahaya seperti bekerja dengan data bersama seperti deadlock dan data-race. </p><br><p>  Interaksi antara aktor (agen) di SObjectizer hanya dilakukan melalui pesan asinkron.  Satu agen mengirim pesan ke agen lain dan operasi ini tidak memblokir pengirim (dalam kasus umum). </p><br><p>  Interaksi asinkron memungkinkan penggunaan prinsip lain yang bermanfaat: <em>api-dan-lupakan</em> .  Ketika beberapa agen perlu beberapa operasi untuk dilakukan, ia mengirim (menembak) pesan dan melanjutkan pekerjaannya.  Dalam sebagian besar kasus, pesan akan diterima dan diproses. </p><br><p>  Misalnya, mungkin ada agen yang membaca koneksi yang diterima dan mem-parsing data yang masuk.  Jika seluruh PDU dibaca dan diuraikan agen hanya mengirimkan PDU itu ke agen-prosesor lain dan kembali membaca / mem-parsing data baru yang masuk. </p><br><h2 id="dispatchers">  Dispatcher </h2><br><p>  Dispatcher adalah salah satu pilar SObjectizer.  Dispatcher memberikan konteks kerja (alias utas pekerja) bahwa agen akan menangani pesan yang masuk.  Alih-alih membuat utas pekerja (atau kumpulan utas) secara manual, pengguna membuat dispatcher dan mengikat agen kepada mereka.  Seorang pengguna dapat membuat sebanyak mungkin dispatcher dalam suatu aplikasi sesuai keinginannya. </p><br><p>  Hal terbaik dengan dispatcher dan agen di SObjectizer adalah pemisahan konsep: dispatcher bertanggung jawab untuk mengelola konteks kerja dan memiliki antrian pesan, agen melakukan logika aplikasi dan tidak peduli dengan konteks pekerja.  Ini memungkinkan pemindahan agen dari satu operator ke operator lain secara harfiah dengan satu klik.  Kemarin agen bekerja pada dispatcher one_thread, hari ini kita bisa mengubahnya menjadi dispatcher active_obj, dan besok kita bisa rebind ke dispatcher thread_pool.  Tanpa mengubah garis dalam implementasi agen. </p><br><p>  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">delapan jenis dispatcher di SObjectizer-5.6.0</a> (dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">satu lagi</a> dapat ditemukan di proyek pendamping so5extra): mulai dari yang sangat sederhana (one_thread atau thread_pool) hingga yang canggih (seperti adv_thread_pool atau prio_dedicated_threads :: one_per_prio).  Dan pengguna dapat menulis operator sendiri untuk kondisi tertentu. </p><br><h2 id="hierarchical-state-machines-are-built-in-functionality">  Mesin status hierarkis adalah fungsi bawaan </h2><br><p>  Agen (aktor) dalam SObjectizer adalah mesin negara: reaksi pada pesan masuk tergantung pada keadaan agen saat ini.  SObjectizer mendukung sebagian besar fitur mesin negara hierarkis (HSM): status bersarang, riwayat dalam dan dangkal untuk keadaan, penangan on_enter / on_exit, batas waktu untuk tetap berada dalam keadaan.  Hanya status orthogonal yang tidak didukung di SObjectizer sekarang (kami tidak melihat perlunya fitur itu di proyek kami, dan tidak ada yang meminta kami untuk menambahkan dukungan untuk fitur itu). </p><br><h2 id="csp-like-channels-just-out-of-box">  Saluran seperti CSP baru saja keluar dari kotak </h2><br><p> Tidak perlu menggunakan agen SObjectizer (alias aktor).  Seluruh aplikasi dapat dikembangkan hanya menggunakan objek <code>std::thread</code> dan mchains <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">SObjectizer (alias saluran CSP)</a> .  Dalam hal itu pengembangan aplikasi dengan SObjectizer akan sedikit mirip dengan pengembangan dalam bahasa Go (termasuk analog dari konstruk <code>select</code> Go yang memungkinkan untuk menunggu pesan dari beberapa saluran). </p><br><p>  Kereta SObjectizer dapat memiliki fitur yang sangat penting: mekanisme tekanan balik terpadu.  Jika pengguna membuat mchain terbatas ukuran dan kemudian mencoba mendorong pesan ke mchain penuh operasi pengiriman dapat memblokir pengirim untuk beberapa waktu.  Hal ini memungkinkan untuk menyelesaikan masalah yang terkenal dengan produsen cepat dan konsumen lambat. </p><br><p>  Kereta SObjectizer memiliki fitur menarik lainnya: mchain dapat digunakan sebagai alat distribusi beban yang sangat sederhana.  Beberapa utas dapat menunggu <em>diterima</em> dari mchain yang sama pada saat yang sama.  Jika pesan baru dikirim ke mchain itu, hanya satu utas yang akan membaca dan menangani pesan itu. </p><br><h2 id="only-a-part-of-an-application-can-use-sobjectizer">  Hanya sebagian aplikasi yang dapat menggunakan SObjectizer </h2><br><p>  Tidak perlu menggunakan SObjectizer di setiap bagian aplikasi.  Hanya sebagian dari aplikasi yang dapat dikembangkan dengan menggunakan SObjectizer.  Jadi, jika Anda sudah menggunakan Qt atau wxWidgets, atau Boost.Asio sebagai kerangka kerja utama untuk aplikasi Anda, dimungkinkan untuk menggunakan SObjectize hanya dalam satu submodule dari aplikasi Anda. </p><br><p>  Kami memiliki pengalaman tentang penggunaan SObjectizer untuk pengembangan perpustakaan yang menyembunyikan penggunaan SObjectizer sebagai detail implementasi.  API publik dari perpustakaan-perpustakaan itu sama sekali tidak memaparkan keberadaan SObjectizer.  SObjectizer sepenuhnya di bawah kendali perpustakaan: perpustakaan mulai dan menghentikan SObjectizer sesuai kebutuhan.  Pustaka tersebut digunakan dalam aplikasi yang sama sekali tidak mengetahui keberadaan SObjectizer. </p><br><p>  Jika SObjectizer hanya digunakan di bagian aplikasi, ada tugas komunikasi antara SObjectizer dan non-SObjectizer-bagian aplikasi.  Tugas ini mudah diselesaikan: pesan dari komponen non-SObjectizer ke SObjectizer dapat dikirim melalui mekanisme SObjectizer pengiriman pesan biasa.  Pesan di arah yang berlawanan dapat dikirim melalui kereta. </p><br><h2 id="you-can-run-several-instances-of-sobjectizer-at-the-same-time">  Anda dapat menjalankan beberapa instance SObjectizer secara bersamaan </h2><br><p>  SObjectizer memungkinkan dijalankannya beberapa instance SObjectizer (disebut SObjectizer Environment) dalam satu aplikasi secara bersamaan.  Setiap Lingkungan SObjectizer tidak tergantung pada lingkungan lain seperti itu. </p><br><p>  Fitur ini sangat berharga dalam situasi di mana Anda harus membangun aplikasi dari beberapa modul independen.  Beberapa modul dapat menggunakan SObjectizer, beberapa tidak.  Modul-modul yang memerlukan SObjectizer dapat menjalankan salinan Lingkungan SObjectizer dan yang tidak akan mempengaruhi modul-modul lain dalam aplikasi. </p><br><h2 id="timers-are-part-of-sobjectizer">  Pengatur waktu adalah bagian dari SObjectizer </h2><br><p>  Dukungan timer dalam bentuk pesan yang tertunda dan berkala adalah salah satu pilar SObjectizer.  SObjectizer memiliki beberapa implementasi mekanisme pengatur waktu (timer_wheel, timer_heap, dan timer_list) dan dapat menangani puluhan, ratusan dan ribuan juta pengatur waktu dalam suatu aplikasi.  Seorang pengguna dapat memilih mekanisme penghitung waktu yang paling tepat untuk suatu aplikasi.  Selain itu, pengguna dapat memberikan implementasi timer_thread / timer_manager sendiri jika tidak ada yang standar yang sesuai dengan kondisi pengguna. </p><br><h2 id="sobjectizer-has-various-customization-points-and-tuning-options">  SObjectizer memiliki berbagai titik penyesuaian dan opsi penyetelan </h2><br><p>  SObjectizer memungkinkan penyesuaian beberapa mekanisme penting.  Misalnya, pengguna dapat memilih salah satu implementasi standar timer_thread (atau timer_manager).  Atau bisa memberikan implementasinya sendiri.  Seorang pengguna dapat memilih implementasi dari objek kunci yang digunakan oleh antrian pesan dalam dispatcher SObjectizer.  Atau bisa memberikan implementasinya sendiri. </p><br><p>  Seorang pengguna dapat mengimplementasikan operator sendiri.  Seorang pengguna dapat mengimplementasikan kotak pesannya sendiri.  Seorang pengguna dapat mengimplementasikan amplop pesannya sendiri.  Seorang pengguna dapat mengimplementasikan event_queue_hook sendiri.  Dan sebagainya. </p><br><h1 id="where-sobjectizer-can-or-cant-be-used">  Di mana SObjectizer dapat atau tidak dapat digunakan? </h1><br><p>  Jauh lebih mudah untuk mengatakan di mana SObjectizer tidak dapat digunakan dengan alasan objektif.  Jadi kami memulai diskusi dengan menghitung area-area tersebut dan kemudian kami akan memberikan beberapa contoh penggunaan SObjectizer di masa lalu (dan tidak hanya di masa lalu). </p><br><h2 id="where-sobjectizer-cant-be-used">  Di mana SObjectizer tidak dapat digunakan? </h2><br><h3 id="tasks-related-to-parallel-computing">  Tugas yang terkait dengan komputasi paralel </h3><br><p>  Seperti yang telah dikatakan di atas, model Actor dan CSP bukanlah pilihan yang baik untuk komputasi berperforma tinggi dan area lain dari komputasi Paralel.  Jadi jika Anda harus melakukan beberapa matriks atau stream video transcode maka alat seperti OpenMP, Intel TBB, cpp-taskflow, HPX atau MPI akan lebih cocok. </p><br><h3 id="hard-real-time-systems">  Sistem real-time yang sulit </h3><br><p>  Terlepas dari kenyataan bahwa SObjectizer berakar pada sistem SCADA, implementasi SObjectizer (alias SObjectizer-5) saat ini tidak dapat digunakan dalam sistem waktu nyata yang sulit.  Ini terutama karena penggunaan memori dinamis dalam implementasi SObjectizer: pesan adalah objek yang dialokasikan secara dinamis (namun, SObjectizer dapat menggunakan objek yang telah dialokasikan sebelumnya sebagai pesan), operator menggunakan memori dinamis untuk antrian pesan, bahkan batas waktu untuk status agen menggunakan objek yang dialokasikan secara dinamis untuk melakukan pengecekan waktu. </p><br><p>  Sayangnya, istilah "waktu nyata" sangat sering digunakan di dunia modern.  Sering dikatakan tentang layanan web waktu nyata, seperti "aplikasi web waktu nyata" atau "analisis web waktu nyata" dan seterusnya.  Istilah "on-line" atau "live" lebih tepat untuk aplikasi seperti itu daripada istilah "real-time", bahkan dalam bentuk "real-time lunak".  Jadi, jika kita berbicara tentang sesuatu seperti "aplikasi web real-time" maka SObjectizer dapat dengan mudah digunakan dalam sistem "real-time" tersebut. </p><br><h3 id="constrained-embedded-systems">  Sistem embedded yang terkendala </h3><br><p>  SObjectizer bergantung pada pustaka standar C ++: <code>std::thread</code> digunakan untuk manajemen thread, <code>std::atomic</code> , <code>std::mutex</code> , <code>std::condition_variable</code> digunakan untuk sinkronisasi data, RTTI dan <code>dynamic_cast</code> digunakan insize SObjectizer (misalnya , <code>std::type_index</code> digunakan untuk identifikasi jenis pesan), pengecualian C ++ digunakan untuk pelaporan kesalahan. </p><br><p>  Ini berarti bahwa SObjectizer tidak dapat digunakan di lingkungan di mana fasilitas perpustakaan standar tersebut tidak tersedia.  Sebagai contoh, dalam pengembangan embedded embedded system di mana hanya bagian dari C ++ dan C ++ stdlib dapat digunakan. </p><br><h2 id="where-sobjectizer-was-used-in-the-past">  Di mana SObjectizer digunakan di masa lalu? </h2><br><p>  Sekarang kami mencoba untuk berbicara singkat tentang beberapa kasus penggunaan penggunaan SObjectizer di masa lalu (dan tidak hanya di masa lalu).  Sayangnya, ini bukan informasi lengkap karena ada beberapa masalah. </p><br><p>  Pertama-tama, kita tidak tahu tentang semua penggunaan SObjectizer.  SObjectizer adalah perangkat lunak gratis yang dapat digunakan bahkan dalam proyek berpemilik.  Jadi beberapa orang hanya mendapatkan SObjectizer dan menggunakannya tanpa memberikan umpan balik kepada kami.  Terkadang kami memperoleh beberapa informasi tentang penggunaan SObjectizer (tetapi tanpa detail), terkadang kami tidak tahu apa-apa. </p><br><p>  Masalah kedua adalah izin untuk berbagi informasi tentang penggunaan SObjectizer dalam proyek tertentu.  Kami telah menerima izin itu sangat jarang, dalam kebanyakan kasus pengguna SObjectizer tidak ingin membuka detail implementasi proyek mereka (kadang-kadang kami memahami alasannya, kadang tidak). </p><br><p>  Kami mohon maaf atas fakta bahwa informasi yang diberikan terlihat sangat langka dan tidak berisi perincian.  Meskipun demikian, ada beberapa contoh penggunaan SObjectizer: </p><br><ul><li>  Gerbang agregasi SMS / USSD yang menangani lebih dari 500 juta pesan per bulan; </li><li>  bagian dari sistem yang melayani pembayaran online melalui ATM dari salah satu bank terbesar Rusia; </li><li>  pemodelan simulasi proses ekonomi (sebagai bagian dari penelitian Ph.D.); </li><li>  akuisisi data terdistribusi dan sistem analitik.  Data dikumpulkan pada titik yang didistribusikan di seluruh dunia oleh perintah dari simpul pusat.  MQTT digunakan sebagai transportasi untuk kontrol dan distribusi data yang diperoleh; </li><li>  lingkungan pengujian untuk memeriksa sistem kontrol real-time untuk peralatan kereta api; </li><li>  sistem kontrol otomatis untuk pemandangan teater.  Rincian lebih lanjut dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ; </li><li>  komponen platform manajemen data dalam sistem periklanan online. </li></ul><br><h1 id="a-taste-of-sobjectizer">  Rasa SObjectizer </h1><br><p>  Mari kita lihat beberapa contoh sederhana untuk mencicipi SObjectizer.  Itu adalah contoh yang sangat sederhana yang, kami harap, tidak memerlukan penjelasan tambahan kecuali komentar dalam kode. </p><br><h2 id="the-traditional-hello-world-example-in-actor-models-style">  Contoh "Halo, Dunia" tradisional dalam gaya Model Aktor </h2><br><p>  Contoh paling sederhana dengan hanya satu agen yang bereaksi terhadap <code>hello</code> pesan dan menyelesaikan pekerjaannya: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; // Message to be sent to an agent. struct hello { std::string greeting_; }; // Demo agent. class demo final : public so_5::agent_t { void on_hello(mhood_t&lt;hello&gt; cmd) { std::cout &lt;&lt; "Greeting received: " &lt;&lt; cmd-&gt;greeting_ &lt;&lt; std::endl; // Now agent can finish its work. so_deregister_agent_coop_normally(); } public: // There is no need is a separate constructor. using so_5::agent_t::agent_t; // Preparation of agent to work inside SObjectizer. void so_define_agent() override { // Subscription to 'hello' message. so_subscribe_self().event(&amp;demo::on_hello); } }; int main() { // Run SObjectizer instance. so_5::launch([](so_5::environment_t &amp; env) { // Make and register an instance of demo agent. auto mbox = env.introduce_coop([](so_5::coop_t &amp; coop) { auto * a = coop.make_agent&lt;demo&gt;(); return a-&gt;so_direct_mbox(); }); // Send hello message to registered agent. so_5::send&lt;hello&gt;(mbox, "Hello, World!"); }); }</span></span></span></span></code> </pre> <br><h2 id="another-version-of-hello-world-with-agents-and-publishsubscribe-model">  Versi lain dari "Halo, Dunia" dengan agen dan model Terbitkan / Berlangganan </h2><br><p>  Contoh paling sederhana dengan beberapa agen, semuanya bereaksi terhadap instance yang sama dari pesan <code>hello</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; using namespace std::string_literals; // Message to be sent to an agent. struct hello { std::string greeting_; }; // Demo agent. class demo final : public so_5::agent_t { const std::string name_; void on_hello(mhood_t&lt;hello&gt; cmd) { std::cout &lt;&lt; name_ &lt;&lt; ": greeting received: " &lt;&lt; cmd-&gt;greeting_ &lt;&lt; std::endl; // Now agent can finish its work. so_deregister_agent_coop_normally(); } public: demo(context_t ctx, std::string name, so_5::mbox_t board) : agent_t{std::move(ctx)} , name_{std::move(name)} { // Create a subscription for hello message from board. so_subscribe(board).event(&amp;demo::on_hello); } }; int main() { // Run SObjectizer instance. so_5::launch([](so_5::environment_t &amp; env) { // Mbox to be used for speading hello message. auto board = env.create_mbox(); // Create several agents in separate coops. for(const auto &amp; n : {"Alice"s, "Bob"s, "Mike"s}) env.register_agent_as_coop(env.make_agent&lt;demo&gt;(n, board)); // Spread hello message to all subscribers. so_5::send&lt;hello&gt;(board, "Hello, World!"); }); }</span></span></span></span></code> </pre> <br><p>  Jika kita menjalankan contoh itu, kita dapat menerima sesuatu seperti itu: </p><br><pre> <code class="plaintext hljs">Alice: greeting received: Hello, World! Bob: greeting received: Hello, World! Mike: greeting received: Hello, World!</code> </pre> <br><h2 id="hello-world-example-in-csp-style">  Contoh "Halo, Dunia" dalam gaya CSP </h2><br><p>  Mari kita lihat contoh SObjectizer tanpa aktor, cukup <code>std::thread</code> dan saluran CSP-like. </p><br><h3 id="very-simple-version">  Versi yang sangat sederhana </h3><br><p>  Ini adalah versi yang sangat sederhana yang tidak terkecuali aman: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; // Message to be sent to a channel. struct hello { std::string greeting_; }; void demo_thread_func(so_5::mchain_t ch) { // Wait while hello received. so_5::receive(so_5::from(ch).handle_n(1), [](so_5::mhood_t&lt;hello&gt; cmd) { std::cout &lt;&lt; "Greeting received: " &lt;&lt; cmd-&gt;greeting_ &lt;&lt; std::endl; }); } int main() { // Run SObjectizer in a separate thread. so_5::wrapped_env_t sobj; // Channel to be used. auto ch = so_5::create_mchain(sobj); std::thread demo_thread{demo_thread_func, ch}; // Send a greeting. so_5::send&lt;hello&gt;(ch, "Hello, World!"); // Wait for demo thread. demo_thread.join(); }</span></span></span></span></code> </pre> <br><h3 id="more-robust-but-still-simple-version">  Versi yang lebih kuat, namun tetap sederhana </h3><br><p>  Ini adalah versi modifikasi dari contoh yang ditunjukkan di atas dengan tambahan keamanan pengecualian: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; // Message to be sent to a channel. struct hello { std::string greeting_; }; void demo_thread_func(so_5::mchain_t ch) { // Wait while hello received. so_5::receive(so_5::from(ch).handle_n(1), [](so_5::mhood_t&lt;hello&gt; cmd) { std::cout &lt;&lt; "Greeting received: " &lt;&lt; cmd-&gt;greeting_ &lt;&lt; std::endl; }); } int main() { // Run SObjectizer in a separate thread. so_5::wrapped_env_t sobj; // Demo thread. We need object now, but thread will be started later. std::thread demo_thread; // Auto-joiner for the demo thread. auto demo_joiner = so_5::auto_join(demo_thread); // Channel to be used. This channel will be automatically closed // in the case of an exception. so_5::mchain_master_handle_t ch_handle{ so_5::create_mchain(sobj), so_5::mchain_props::close_mode_t::retain_content }; // Now we can run demo thread. demo_thread = std::thread{demo_thread_func, *ch_handle}; // Send a greeting. so_5::send&lt;hello&gt;(*ch_handle, "Hello, World!"); // There is no need to wait for something explicitly. }</span></span></span></span></code> </pre> <br><h2 id="a-rather-simple-hsm-example-blinking_led">  Contoh HSM yang agak sederhana: blinking_led </h2><br><p>  Ini adalah contoh standar dari distribusi SObjectizer.  Agen utama dari contoh ini adalah HSM yang dapat dijelaskan oleh statechart berikut: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/eca/679/59d/eca67959d472d154ce57878d4ffe0120.png" alt="statinkart blinking_led"></p><br><p>  Kode sumber contoh: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;so_5/all.hpp&gt; class blinking_led final : public so_5::agent_t { state_t off{ this }, blinking{ this }, blink_on{ initial_substate_of{ blinking } }, blink_off{ substate_of{ blinking } }; public : struct turn_on_off final : public so_5::signal_t {}; blinking_led( context_t ctx ) : so_5::agent_t{ ctx } { this &gt;&gt;= off; off.just_switch_to&lt; turn_on_off &gt;( blinking ); blinking.just_switch_to&lt; turn_on_off &gt;( off ); blink_on .on_enter( []{ std::cout &lt;&lt; "ON" &lt;&lt; std::endl; } ) .on_exit( []{ std::cout &lt;&lt; "off" &lt;&lt; std::endl; } ) .time_limit( std::chrono::milliseconds{1500}, blink_off ); blink_off .time_limit( std::chrono::milliseconds{750}, blink_on ); } }; int main() { try { so_5::launch( []( so_5::environment_t &amp; env ) { auto m = env.introduce_coop( []( so_5::coop_t &amp; coop ) { auto led = coop.make_agent&lt; blinking_led &gt;(); return led-&gt;so_direct_mbox(); } ); auto pause = []( unsigned int v ) { std::this_thread::sleep_for( std::chrono::seconds{v} ); }; std::cout &lt;&lt; "Turn blinking on for 10s" &lt;&lt; std::endl; so_5::send&lt; blinking_led::turn_on_off &gt;( m ); pause( 10 ); std::cout &lt;&lt; "Turn blinking off for 5s" &lt;&lt; std::endl; so_5::send&lt; blinking_led::turn_on_off &gt;( m ); pause( 5 ); std::cout &lt;&lt; "Turn blinking on for 5s" &lt;&lt; std::endl; so_5::send&lt; blinking_led::turn_on_off &gt;( m ); pause( 5 ); std::cout &lt;&lt; "Stopping..." &lt;&lt; std::endl; env.stop(); } ); } catch( const std::exception &amp; ex ) { std::cerr &lt;&lt; "Error: " &lt;&lt; ex.what() &lt;&lt; std::endl; } return 0; }</span></span></span></span></code> </pre> <br><h2 id="timers-overload-control-for-an-agent-and-active_obj-dispatcher">  Pengatur waktu, kontrol kelebihan untuk agen dan dispatcher active_obj </h2><br><p>  Kontrol overload adalah salah satu masalah utama bagi para aktor: antrian pesan untuk aktor biasanya tidak terbatas dan ini dapat menyebabkan pertumbuhan antrian yang tidak terkendali jika produsen pesan yang cepat mengirim pesan lebih cepat maka penerima dapat menanganinya.  Contoh berikut menunjukkan fitur SObjectizer seperti <em>batas pesan</em> .  Hal ini memungkinkan untuk membatasi jumlah pesan dalam antrian agen dan mempertahankan penerima dari pesan yang berlebihan. </p><br><p>  Contoh ini juga menunjukkan penggunaan timer dalam bentuk pesan berkala.  Ikatan agen ke dispatcher active_obj juga ditampilkan di sana.  Mengikat ke operator itu berarti bahwa setiap agen dari koperasi akan bekerja pada utas pekerja sendiri (misalnya agen menjadi objek aktif). </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; using namespace std::chrono_literals; // Message to be sent to the consumer. struct task { int task_id_; }; // An agent for utilization of unhandled tasks. class trash_can final : public so_5::agent_t { public: // There is no need is a separate constructor. using so_5::agent_t::agent_t; // Preparation of agent to work inside SObjectizer. void so_define_agent() override { // Subscription to 'task' message. // Event-handler is specified in the form of a lambda-function. so_subscribe_self().event([](mhood_t&lt;task&gt; cmd) { std::cout &lt;&lt; "unhandled task: " &lt;&lt; cmd-&gt;task_id_ &lt;&lt; std::endl; }); } }; // The consumer of 'task' messages. class consumer final : public so_5::agent_t { public: // We need the constructor. consumer(context_t ctx, so_5::mbox_t trash_mbox) : so_5::agent_t{ctx + // Only three 'task' messages can wait in the queue. limit_then_redirect&lt;task&gt;(3, // All other messages will go to that mbox. [trash_mbox]{ return trash_mbox; })} { // Define a reaction to incoming 'task' message. so_subscribe_self().event([](mhood_t&lt;task&gt; cmd) { std::cout &lt;&lt; "handling task: " &lt;&lt; cmd-&gt;task_id_ &lt;&lt; std::endl; std::this_thread::sleep_for(75ms); }); } }; // The producer of 'test' messages. class producer final : public so_5::agent_t { const so_5::mbox_t dest_; so_5::timer_id_t task_timer_; int id_counter_{}; // Type of periodic signal to produce new 'test' message. struct generate_next final : public so_5::signal_t {}; void on_next(mhood_t&lt;generate_next&gt;) { // Produce a new 'task' message. so_5::send&lt;task&gt;(dest_, id_counter_); ++id_counter_; // Should the work be stopped? if(id_counter_ &gt;= 10) so_deregister_agent_coop_normally(); } public: producer(context_t ctx, so_5::mbox_t dest) : so_5::agent_t{std::move(ctx)} , dest_{std::move(dest)} {} void so_define_agent() override { so_subscribe_self().event(&amp;producer::on_next); } // This method will be automatically called by SObjectizer // when agent starts its work inside SObjectizer Environment. void so_evt_start() override { // Initiate a periodic message with no initial delay // and repetition every 25ms. task_timer_ = so_5::send_periodic&lt;generate_next&gt;(*this, 0ms, 25ms); } }; int main() { // Run SObjectizer instance. so_5::launch([](so_5::environment_t &amp; env) { // Make and register coop with agents. // All agents will be bound to active_obj dispatcher and will // work on separate threads. env.introduce_coop( so_5::disp::active_obj::make_dispatcher(env).binder(), [](so_5::coop_t &amp; coop) { auto * trash = coop.make_agent&lt;trash_can&gt;(); auto * handler = coop.make_agent&lt;consumer&gt;(trash-&gt;so_direct_mbox()); coop.make_agent&lt;producer&gt;(handler-&gt;so_direct_mbox()); }); }); }</span></span></span></span></code> </pre> <br><p>  Jika kita menjalankan contoh itu, kita dapat melihat output berikut: </p><br><pre> <code class="plaintext hljs">handling task: 0 handling task: 1 unhandled task: 5 unhandled task: 6 handling task: 2 unhandled task: 8 unhandled task: 9 handling task: 3 handling task: 4 handling task: 7</code> </pre> <br><p>  Output ini menunjukkan bahwa beberapa pesan yang tidak dapat masuk ke batas yang ditentukan ditolak dan dialihkan ke penerima lain. </p><br><h2 id="more-examples">  Lebih banyak contoh </h2><br><p>  Contoh yang kurang lebih mirip dengan kode dari aplikasi kehidupan nyata dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">proyek demo Udang</a> kami.  Serangkaian contoh menarik lainnya dapat ditemukan dalam mini-seri ini tentang "masalah makan filsuf" klasik: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">bagian 1</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">bagian 2</a> .  Dan, tentu saja, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">banyak contoh di SObjectizer itu sendiri</a> . </p><br><h1 id="what-about-the-performance">  Bagaimana dengan kinerjanya? </h1><br><p>  Ada jawaban yang sangat sederhana: lebih dari cukup untuk kita.  SObjectizer dapat mendistribusikan jutaan pesan per detik, dan kecepatan sebenarnya tergantung pada jenis dispatcher yang digunakan, jenis pesan, profil beban, perangkat keras / OS / kompiler yang digunakan dan sebagainya.  Dalam aplikasi nyata, kami biasanya hanya menggunakan sebagian kecil dari kecepatan SObjectizer. </p><br><p>  Kinerja SObjectizer untuk tugas khusus Anda sangat tergantung pada tugas Anda, solusi khusus tugas itu, pada perangkat keras atau lingkungan virtual Anda, pada versi kompiler dan OS Anda.  Jadi cara terbaik untuk menemukan jawaban untuk pertanyaan itu adalah dengan membuat tolok ukur sendiri yang akan spesifik untuk tugas Anda dan bereksperimen dengannya. </p><br><p>  Jika Anda ingin angka dari beberapa tolok ukur sintetis maka ada beberapa program dalam folder test / so_5 / bench dari distribusi SObjectizer. </p><br><h2 id="a-note-about-comparison-with-different-tools">  Catatan tentang perbandingan dengan alat yang berbeda </h2><br><p>  Kami berpikir bahwa permainan pembandingan membandingkan kecepatan berbagai alat adalah permainan pemasaran.  Kami melakukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">upaya</a> di masa lalu tetapi dengan cepat menyadari bahwa itu hanya buang-buang waktu saja.  Jadi kita tidak memainkan game itu sekarang.  Kami menghabiskan waktu dan sumber daya kami hanya pada tolok ukur yang memungkinkan kami memeriksa tidak adanya penurunan kinerja, untuk menyelesaikan beberapa kasus sudut (seperti kinerja kotak MPMC dengan jumlah pelanggan yang besar atau kinerja agen dengan ratusan ribu pelanggan), untuk mempercepat beberapa operasi SObjectizer-spesifik (seperti pendaftaran / deregistrasi koperasi). </p><br><p>  Jadi kami meninggalkan perbandingan kecepatan untuk mereka yang menyukai permainan itu dan punya waktu untuk memainkannya. </p><br><h1 id="why-sobjectizer-does-look-exactly-as-it-is">  Mengapa SObjectizer terlihat persis seperti apa adanya? </h1><br><p>  Ada beberapa "kerangka aktor" untuk C ++, dan semuanya terlihat berbeda.  Tampaknya ia memiliki beberapa alasan obyektif: setiap kerangka kerja memiliki fitur unik dan menargetkan berbagai tujuan.  Selain itu, aktor dalam C ++ dapat diimplementasikan dengan sangat berbeda.  Jadi pertanyaan utamanya bukanlah "mengapa kerangka X tidak terlihat seperti kerangka Y?", Tetapi "mengapa kerangka X memang terlihat seperti itu?" </p><br><p>  Sekarang kita akan mencoba menjelaskan beberapa alasan di balik fitur-fitur SObjectizer utama secara singkat.  Kami harap ini memungkinkan pemahaman yang lebih baik tentang kemampuan SObjectizer.  Tetapi sebelum kita mulai perlu menyebutkan satu hal yang sangat penting: SObjectizer belum pernah menjadi eksperimen.  Itu diciptakan untuk memecahkan kerja kehidupan nyata dan telah berevolusi berdasarkan pengalaman kehidupan nyata. </p><br><h2 id="agents-are-objects-of-classes-derived-from-agent_t">  Agen adalah objek kelas yang berasal dari agent_t </h2><br><p>  Agen (alias aktor) dalam SObjectzer adalah objek kelas yang ditentukan pengguna yang harus diturunkan dari <code>agent_t</code> class khusus.  Ini mungkin terlihat berlebihan dalam contoh mainan kecil, tetapi pengalaman kami menunjukkan bahwa pendekatan sangat menyederhanakan pengembangan perangkat lunak nyata di mana agen biasanya memiliki ukuran dalam beberapa ratus baris (Anda dapat melihat salah satu contoh di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">sini</a> , tetapi posting blog ini ada di Rusia).  Terkadang bahkan dalam beberapa ribu baris. </p><br><p>  Pengalaman menunjukkan kepada kita bahwa agen sederhana dengan versi pertama dalam seratus baris menjadi jauh lebih gemuk dan kompleks dalam beberapa tahun mendatang evolusi.  Jadi, setelah lima tahun Anda dapat menemukan monster dalam ribuan baris dengan puluhan metode. </p><br><p>  Penggunaan kelas memungkinkan kita untuk mengelola kompleksitas agen.  Kita bisa menggunakan warisan kelas.  Dan kita bisa menggunakan kelas template juga.  Ini adalah teknik yang sangat berguna yang sangat menyederhanakan pengembangan keluarga agen dengan logika serupa di dalamnya. </p><br><h2 id="messages-as-objects-of-user-structsclasses">  Pesan sebagai objek pengguna / kelas pengguna </h2><br><p>  Pesan di SObjectizer adalah objek struct atau kelas yang ditentukan pengguna.  Setidaknya ada dua alasan untuk itu: </p><br><ul><li>  pengembangan SObjectizer-5 dimulai pada 2010 ketika C ++ 11 belum distandarisasi.  Jadi pada awalnya, kami tidak dapat menggunakan fitur C ++ 11 seperti templat variadic dan <code>std::tuple</code> class.  Satu-satunya pilihan yang kami miliki adalah penggunaan objek kelas yang diwarisi dari <code>message_t</code> kelas khusus.  Sekarang tidak perlu untuk menurunkan jenis pesan dari <code>message_t</code> , tetapi SObjectizer membungkus objek pengguna ke objek yang di-message-message, di bawah kap; </li><li>  isi pesan dapat dengan mudah diubah tanpa modifikasi tanda tangan penangan acara.  Dan ada kontrol dari kompiler: jika Anda menghapus beberapa bidang dari pesan atau mengubah jenisnya maka kompiler akan memberi tahu Anda tentang akses yang salah ke bidang itu. </li></ul><br><p>  Penggunaan pesan sebagai objek juga memungkinkan untuk bekerja dengan pesan yang telah dialokasikan sebelumnya dan untuk menyimpan pesan yang diterima ke beberapa wadah dan mengirimnya kembali nanti. </p><br><h2 id="coops-of-agents">  Koperasi agen </h2><br><p>  Sekelompok agen mungkin adalah salah satu fitur unik dari SObjectizer.  Koperasi adalah sekelompok agen yang harus ditambahkan dan dihapus dari SObjectizer dengan cara transaksi.  Ini berarti bahwa jika sebuah koperasi berisi tiga agen maka semua agen tersebut harus ditambahkan ke SObjectizer dengan sukses atau tidak ada satupun dari mereka yang harus ditambahkan.  Demikian pula, ketiga agen harus dihapus dari SObjectizer atau ketiga agen harus melanjutkan pekerjaan mereka. </p><br><p>  Kebutuhan di dalam koperasi ditemukan segera setelah dimulainya kehidupan SObjectizer.  Menjadi jelas bahwa agen akan dibuat oleh kelompok, bukan oleh satu contoh.  Coops diciptakan untuk menyederhanakan kehidupan pengembang: tidak perlu mengontrol pembuatan agen berikutnya dan menghapus agen yang dibuat sebelumnya jika pembuatan agen baru gagal. </p><br><p>  Sebuah koperasi juga dapat dilihat sebagai pengawas dalam mode semua-untuk-satu: jika agen dari koperasi gagal maka seluruh koperasi akan dihapus dari Lingkungan SObjectizer dan dimusnahkan (pengguna dapat bereaksi terhadap hal itu dan membuat kembali kandang lagi). </p><br><h2 id="message-boxes">  Kotak pesan </h2><br><p>  Kotak pesan adalah fitur unik lain milik SObjectizer.  Pesan dalam SObjectizer dikirim ke kotak pesan (mbox), bukan ke agen secara langsung.  Mungkin ada satu penerima di belakang mbox, atau mungkin ada satu juta pelanggan, atau tidak ada satu. </p><br><p>  Mboxes memungkinkan kami untuk mendukung fungsionalitas dasar model Publish-Berlangganan.  Mbox dapat dilihat sebagai MQ-broker dan jenis pesan dapat dilihat sebagai topik. </p><br><p>  Mbox memungkinkan kami juga menerapkan berbagai bentuk pengiriman pesan yang menarik.  Misalnya, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">mbox round-robin</a> yang menyebarkan pesan antara pelanggan secara round-robin.  Ada juga kotak penyimpanan yang menampung pesan yang terakhir dikirim dan mengirim ulang secara otomatis untuk setiap pelanggan baru.  Ada juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">pembungkus sederhana di sekitar libmosquitto</a> yang memungkinkan untuk menggunakan MQTT sebagai transportasi untuk aplikasi terdistribusi. </p><br><h2 id="agents-as-hsm">  Agen sebagai HSM </h2><br><p>  Agen di SObjectizer adalah mesin negara.  Itu dari awal hanya karena SObjectizer memiliki akar di bidang SCADA, di mana mesin negara secara aktif digunakan.  Tetapi dengan cepat menjadi jelas bahwa agen dalam bentuk mesin negara dapat berguna bahkan di ceruk yang berbeda (seperti aplikasi telekomunikasi dan keuangan). </p><br><p>  Dukungan mesin keadaan hierarkis (mis. Penangan on_enter / on_exit, status bersarang, batas waktu dan sebagainya) ditambahkan setelah beberapa waktu menggunakan SObjectizer dalam produksi.  Dan fitur ini membuat SObjectizer alat yang lebih kuat dan nyaman. </p><br><h2 id="usage-of-c-exceptions">  Penggunaan pengecualian C ++ </h2><br><p>  Pengecualian C ++ digunakan dalam SObjectizer sebagai mekanisme pelaporan kesalahan utama.  Terlepas dari kenyataan bahwa penggunaan pengecualian C ++ terkadang bisa mahal, kami memutuskan untuk menggunakan pengecualian alih-alih kode kesalahan. </p><br><p>  Kami memiliki pengalaman negatif dengan kode kesalahan di SObjectizer-4, di mana pengecualian tidak digunakan.  Ini menyebabkan ketidaktahuan kesalahan dalam kode aplikasi dan kadang-kadang tindakan penting tidak dilakukan karena ada kesalahan membuat koperasi baru atau mengirim pesan.  Tetapi kesalahan ini diabaikan dan fakta itu ditemukan jauh kemudian. </p><br><p>  Penggunaan pengecualian C ++ di SObjectizer-5 memungkinkan penulisan kode yang lebih benar dan kuat.  Dalam kasus biasa, pengecualian dilemparkan oleh SObjectizer sangat jarang sehingga penggunaan pengecualian tidak berdampak negatif pada kinerja SObjectizer atau kinerja aplikasi yang ditulis di atas SObjectizer. </p><br><h2 id="no-support-for-distributed-applications-out-of-box">  Tidak ada dukungan untuk aplikasi terdistribusi "out of box" </h2><br><p>  SObjectzer-5 tidak memiliki dukungan bawaan untuk aplikasi terdistribusi.  Ini berarti bahwa SObjectizer mendistribusikan pesan hanya di dalam satu proses.  Jika Anda perlu mengatur distribusi pesan antar-proses atau antar-catatan maka Anda harus mengintegrasikan beberapa jenis IPC dalam aplikasi Anda. </p><br><p>  Ini bukan karena kami tidak dapat mengimplementasikan beberapa bentuk IPC di SObjectizer.  Kami sudah memilikinya di SObjectizer-4.  Dan karena kami memiliki pengalaman seperti itu, kami memutuskan untuk tidak melakukannya di SObjectizer-5.  Kami belajar bahwa tidak ada satu jenis IPC yang sangat cocok untuk kondisi yang berbeda. </p><br><p>  Jika Anda ingin memiliki komunikasi antar-simpul yang baik dalam aplikasi Anda, Anda harus memilih protokol dasar yang sesuai.  Misalnya, jika Anda harus menyebarkan jutaan paket kecil dengan beberapa data yang berumur pendek (seperti distribusi pengukuran kondisi cuaca saat ini) maka Anda harus menggunakan satu IPC.  Tetapi jika Anda harus mentransfer BLOB besar (seperti streaming video 4K / 8K atau arsip dengan data keuangan di dalamnya) maka Anda harus menggunakan jenis IPC lain. </p><br><p>  Dan kami tidak berbicara tentang ketidakberdayaan dengan perangkat lunak yang ditulis dalam berbagai bahasa ... </p><br><p>  Anda dapat percaya bahwa beberapa "kerangka kerja aktor" universal dapat memberi Anda IPC yang bagus untuk kondisi yang berbeda.  Tetapi kita tahu bahwa itu hanya omong kosong pemasaran.  Pengalaman kami menunjukkan kepada kita bahwa jauh lebih sederhana dan lebih aman untuk menambahkan IPC yang Anda butuhkan dalam aplikasi Anda kemudian mengandalkan ide, kebutuhan, dan pengetahuan penulis dari "kerangka aktor" pihak ke-3. </p><br><p>  SObjectizer memungkinkan menggabungkan berbagai jenis IPC dalam bentuk mbox khusus.  Jadi itu memungkinkan menyembunyikan fakta distribusi pesan melalui jaringan dari pengguna SObjectizer. </p><br><h1 id="instead-of-the-conclusion">  Alih-alih kesimpulannya </h1><br><p>  Kerangka kerja SObjectizer bukan yang besar, tapi itu bukan yang kecil.  Jadi tidak mungkin untuk memberi pembaca kesan yang cukup mendalam tentang SObjectizer hanya dalam satu ikhtisar.  Karena itu, kami mengundang Anda untuk melihat proyek SObjectizer. </p><br><p>  SObjectizer sendiri hidup di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">GitHub</a> .  Ada Wiki proyek di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">GitHub</a> dan kami sarankan untuk memulai dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">SObjectizer 5.6 Dasar</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">dasar</a> dan kemudian pergi ke artikel dari seri Mendalam.  Bagi mereka yang ingin masuk lebih dalam, kami dapat merekomendasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Mari kita lihat di bawah bagian sungkup SObjectizer</a> . </p><br><p>  Jika Anda memiliki pertanyaan, Anda dapat bertanya kepada kami di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">grup SObjectizer di grup</a> Google. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458202/">https://habr.com/ru/post/id458202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458170/index.html">Perendaman dalam jaringan saraf convolutional. Bagian 5/10 - 18</a></li>
<li><a href="../id458176/index.html">Penghalang exaflops akan diatasi pada 2021</a></li>
<li><a href="../id458184/index.html">Haxe dan PHP: pengetikan statis, fungsi panah, metaprogramming, dan banyak lagi</a></li>
<li><a href="../id458186/index.html">WAL di PostgreSQL: 1. Buffer cache</a></li>
<li><a href="../id458190/index.html">Saya mengerti, itu berarti saya ada: ulasan tentang Deep Learning in Computer Vision (bagian 2)</a></li>
<li><a href="../id458204/index.html">Cara mengevaluasi kinerja penyimpanan di Linux: benchmark menggunakan alat terbuka</a></li>
<li><a href="../id458206/index.html">Sublime Text 3 untuk tata letak situs. Sesuaikan tampilan dan instal plugin. Panduan Pemula</a></li>
<li><a href="../id458208/index.html">Acara digital di Moskow dari 01 Juli hingga 07 Juli</a></li>
<li><a href="../id458214/index.html">Pentest-laboratorium "Pentestit Test lab 12" - bagian penuh</a></li>
<li><a href="../id458218/index.html">Operasi maksilofasial atau tidak? Itu pertanyaannya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>