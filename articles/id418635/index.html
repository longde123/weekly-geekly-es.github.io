<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ—¨ï¸ â¬ ğŸ“• Membuat mesin arcade emulator. Bagian 1 ğŸ›Œ ğŸ‘©ğŸ¾â€ğŸ¤ âœŠğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Menulis emulator mesin arcade adalah proyek pendidikan yang hebat, dan dalam tutorial ini kita akan melihat sangat detail pada seluruh proses pengemba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membuat mesin arcade emulator. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418635/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6eb/735/b99/6eb735b9990860a94f9ef0a18ba46a82.jpg" alt="gambar"></div><br>  Menulis emulator mesin arcade adalah proyek pendidikan yang hebat, dan dalam tutorial ini kita akan melihat sangat detail pada seluruh proses pengembangan.  Ingin benar-benar mendapatkan prosesor Anda?  Kemudian membuat emulator adalah cara terbaik untuk mempelajarinya. <br><br>  Anda akan membutuhkan pengetahuan tentang C, serta pengetahuan assembler.  Jika Anda tidak tahu bahasa assembly, maka menulis emulator adalah cara terbaik untuk mempelajarinya.  Anda juga perlu menguasai matematika heksadesimal (juga dikenal sebagai basis 16 atau hanya "hex").  Saya akan berbicara tentang topik ini. <br><br>  Saya memutuskan untuk memilih emulator untuk mesin Space Invaders, yang menggunakan prosesor 8080. Game ini dan prosesor ini sangat populer, karena di Internet Anda dapat menemukan banyak informasi tentang mereka.  Anda akan membutuhkannya untuk menyelesaikan proyek. <br><br>  Seluruh kode sumber tutorial diunggah ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> .  Jika Anda belum menguasai bekerja dengan git, maka pada halaman github ada tombol "Unduh ZIP" yang memungkinkan Anda untuk mengunduh arsip dengan semua kode. <br><a name="habracut"></a><br><h1>  Pengantar angka biner dan heksadesimal </h1><br>  Dalam matematika "biasa", sistem bilangan desimal digunakan.  Setiap digit angka dapat memiliki nilai dari nol hingga sembilan, dan ketika kami melebihi 9, kami menambahkan satu ke nomor di digit berikutnya dan mulai lagi dari nol.  Ini semua sangat sederhana dan mudah, dan Anda mungkin tidak pernah memikirkannya. <br><br>  Anda mungkin tahu atau mendengar bahwa komputer bekerja dengan data biner.  Geeks komputer memanggil basis-10 desimal matematika, dan basis panggilan biner-2.  Dalam notasi biner, setiap digit angka hanya dapat memiliki dua nilai, nol atau satu.  Dalam kode biner, penghitungannya adalah sebagai berikut: 0, 1, 10, 11, 100, 101, 110, 111, 1000. Ini bukan angka desimal, jadi Anda tidak dapat memanggilnya "nol, satu, sepuluh, sebelas, seratus, seratus satu".  Mereka diucapkan sebagai "nol, satu, satu-nol, satu-satu, satu-nol-nol", dll.  Saya jarang membaca angka-angka biner dengan suara keras, tetapi jika perlu, Anda harus menunjukkan dengan jelas sistem angka yang digunakan.  Sepuluh, sebelas dan seratus tidak memiliki arti dalam notasi biner. <br><br>  Dalam notasi desimal, angka memiliki digit berikut: unit, puluhan, ratusan, ribuan, puluhan ribu, dll.  Dalam sistem biner, angka-angka berikut: unit, deuces, merangkak, delapan, dll.  <strong>Dalam ilmu komputer, nilai setiap bit biner disebut bit.</strong>  <strong>8 bit membentuk satu byte.</strong> <br><br>  Dalam istilah biner, serangkaian angka dengan cepat menjadi sangat panjang.  Untuk mewakili angka desimal 20.000 dalam bentuk biner, diperlukan 16 digit: 0b100111000100000.  Untuk memperbaiki masalah ini, akan lebih mudah untuk menggunakan sistem angka heksadesimal, juga dikenal sebagai base-16 (atau hex).  Di base-16, setiap digit berisi 16 nilai.  Untuk nilai dari nol hingga sembilan, karakter yang sama digunakan seperti pada basis-10, tetapi untuk 6 nilai yang tersisa, pergantian digunakan dalam bentuk 6 huruf pertama dari alfabet, dari A hingga F. <br><br>  Akun dalam sistem heksadesimal dilakukan sebagai berikut: 0 1 2 3 4 5 6 7 8 9 ABCDEF 10 11 12, dll.  Dalam heksadesimal, puluhan, ratusan dan seterusnya tidak memiliki arti yang sama seperti dalam desimal, sehingga orang mengucapkan angka secara terpisah.  Misalnya, $ A57 diucapkan dengan keras sebagai "A-five-seven."  Untuk kejelasan, Anda juga dapat menambahkan hex, misalnya, "A-five-tujuh-hex."  Dalam sistem bilangan heksadesimal, setara dengan angka desimal 20.000 adalah $ 4E20 - bentuk yang jauh lebih ringkas dibandingkan dengan 16 bit dari sistem biner. <br><br>  Saya pikir sistem heksadesimal dipilih karena konversi yang sangat alami dari biner ke heksadesimal dan sebaliknya.  Setiap digit hex sesuai dengan 4 bit (4 bit) dari nomor biner yang sama.  <strong>2 digit hex terdiri dari satu byte (8 bit).</strong>  Satu digit heksadesimal dapat disebut nibble, dan beberapa orang bahkan menuliskannya melalui y sebagai â€œnybbleâ€. <br><br><table><tbody><tr><th colspan="4">  Setiap digit hex adalah 4 digit biner </th></tr><tr><td>  Hex </td><td>  A </td><td>  5 </td><td>  7 </td></tr><tr><td>  Biner </td><td>  1010 </td><td>  0101 </td><td>  0111 </td></tr></tbody></table><br>  Saat menulis kode C, diyakini bahwa angka tersebut adalah desimal (basis-10), kecuali jika ditandai sebaliknya.  Untuk memberi tahu kompiler C bahwa angka tersebut adalah biner, kami menambahkan angka nol dan huruf b dalam huruf kecil, seperti ini: <code>0b1101101</code> .  Angka heksadesimal dapat ditulis dalam kode C dengan menambahkan di awal nol dan x dalam huruf kecil: <code>0xA57</code> .  Beberapa bahasa assembly menggunakan tanda dolar $: <code>$A57</code> untuk menunjukkan nomor hex. <br><br>  Jika Anda memikirkannya, hubungan antara angka-angka biner, heksadesimal, dan desimal cukup jelas, tetapi bagi insinyur pertama, yang telah memikirkan hal ini sebelum penemuan komputer, ini seharusnya menjadi momen wawasan. <br><br>  Mengerti semua ini?  Bagus <br><br><h1>  Pengantar singkat untuk prosesor </h1><br>  <em>Jika sudah mengetahui hal ini, Anda dapat melewati bagian ini dengan aman.</em> <br><br>  Central processing unit (CPU) adalah mesin yang dirancang untuk menjalankan program.  Blok dasar CPU adalah register dan instruksi.  Sebagai pengembang perangkat lunak, Anda dapat memperlakukan register ini sebagai variabel.  Dalam prosesor 8080 kami, di antara register lain, ada register 8-bit yang disebut A, B, C, D, dan E. Register ini dapat diartikan sebagai kode C berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> A, B, C, D, E;</code> </pre> <br>  Semua prosesor juga memiliki program penghitung (Program Counter, PC).  Anda bisa menganggapnya sebagai pointer. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* pc;</code> </pre> <br>  Untuk CPU, program adalah urutan angka heksadesimal.  Setiap instruksi bahasa rakitan di 8080 sesuai dengan 1-3 byte dalam program.  Untuk mengetahui perintah mana yang sesuai dengan nomor mana, manual prosesor (atau informasi lain tentang prosesor 8080 dari Internet) berguna. <br><br>  Nama-nama perintah (instruksi) seringkali mnemonik dari operasi yang dilakukan oleh perintah-perintah ini.  Mnemonic untuk memuat di 8080 adalah MOV (bergerak), dan ADD digunakan untuk melakukan penambahan. <br><br><h4>  Contohnya </h4><br>  Nilai memori saat ini ditunjukkan oleh penghitung instruksi adalah 0x79.  Ini sesuai dengan instruksi <code>MOV A,C</code> prosesor 8080. Kode rakitan ini dalam kode C terlihat seperti <code>A=C;</code>  . <br><br>  Jika bukan nilai di PC akan menjadi 0x80, maka prosesor akan menjalankan <code>ADD B</code>  Dalam C, ini terkait dengan string <code>A = A + B;</code>  . <br><br>  Daftar lengkap instruksi 8080 prosesor dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Untuk mengimplementasikan emulator kami, kami akan menggunakan informasi ini. <br><br><h4>  Pengaturan waktu </h4><br>  Dalam CPU, pelaksanaan setiap instruksi membutuhkan sejumlah waktu (timing) tertentu, yang diukur dalam siklus.  Dalam prosesor modern, informasi ini mungkin sulit diperoleh, karena timing tergantung pada banyak aspek yang berbeda.  Tetapi dalam prosesor yang lebih tua seperti 8080, timingnya konstan dan informasi ini sering diberikan oleh produsen prosesor.  Sebagai contoh, instruksi transfer dari register ke register MOV membutuhkan 1 siklus. <br><br>  Informasi pengaturan waktu berguna untuk menulis kode efisien dalam prosesor.  Seorang programmer dapat berusaha menghindari instruksi yang membutuhkan banyak siklus untuk diselesaikan. <br><br>  Yang lebih penting bagi kami adalah bahwa kami akan menggunakan informasi pengaturan waktu untuk meniru prosesor.  Agar gim bekerja dengan cara yang sama seperti pada aslinya, instruksi harus dijalankan dengan kecepatan yang benar.  Beberapa emulator berusaha keras dalam hal ini, tetapi ketika kita sampai pada ini, kita harus memutuskan akurasi apa yang ingin kita dapatkan. <br><br><h1>  Operasi logis </h1><br>  Sebelum menutup topik angka biner dan heksadesimal, kita harus berbicara tentang operasi logis.  Anda mungkin sudah terbiasa menggunakan logika dalam kode Anda, misalnya, dalam konstruksi seperti <code>if ((conditionA) and (conditionB))</code> .  Dalam program yang bekerja secara langsung dengan perangkat keras, Anda sering harus memanipulasi bit angka individual. <br><br><h3>  DAN operasi </h3><br>  Berikut ini semua hasil yang mungkin dari operasi AND (AND) (tabel kebenaran) antara dua angka bit tunggal. <br><br><table><tbody><tr><td>  x </td><td>  y </td><td>  Hasil </td></tr><tr><td>  0 </td><td>  0 </td><td>  0 </td></tr><tr><td>  0 </td><td>  1 </td><td>  0 </td></tr><tr><td>  1 </td><td>  0 </td><td>  0 </td></tr><tr><td>  1 </td><td>  1 </td><td>  1 </td></tr></tbody></table><br>  Hasil AND sama dengan unity hanya ketika kedua nilai sama dengan unity.  Ketika kita menggabungkan dua angka dengan operasi AND, AND untuk setiap bit dari satu angka adalah AND dengan bit yang sesuai dari angka lainnya.  Hasilnya disimpan dalam bit nomor tujuan ini.  Mungkin lebih baik hanya dengan melihat contoh: <br><br><table><tbody><tr><td></td><td colspan="8">  biner </td><td>  hex </td></tr><tr><td>  sumber x </td><td>  0 </td><td>  1 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  1 </td><td>  $ 6 miliar </td></tr><tr><td>  sumber y </td><td>  1 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  $ D2 </td></tr><tr><td>  x DAN y </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  $ 42 </td></tr></tbody></table><br>  Dalam C, operasi AND logis adalah ampersand sederhana "&amp;". <br><br><h3>  Operasi OR (OR) </h3><br>  Operasi ATAU bekerja dengan cara yang sama.  Satu-satunya perbedaan adalah bahwa hasilnya akan sama dengan satu jika setidaknya satu dari nilai x atau y sama dengan satu. <br><br><table><tbody><tr><td>  x </td><td>  y </td><td>  Hasil </td></tr><tr><td>  0 </td><td>  0 </td><td>  0 </td></tr><tr><td>  0 </td><td>  1 </td><td>  1 </td></tr><tr><td>  1 </td><td>  0 </td><td>  1 </td></tr><tr><td>  1 </td><td>  1 </td><td>  1 </td></tr></tbody></table><br><table><tbody><tr><td></td><td colspan="8">  biner </td><td>  hex </td></tr><tr><td>  sumber x </td><td>  0 </td><td>  1 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  1 </td><td>  $ 6 miliar </td></tr><tr><td>  sumber y </td><td>  1 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  $ D2 </td></tr><tr><td>  x ATAU y </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  1 </td><td>  $ Fb </td></tr></tbody></table><br>  Di C, operasi ATAU logis ditunjukkan oleh bilah vertikal "|". <br><br><h3>  Mengapa ini penting? </h3><br>  Di banyak prosesor yang lebih tua, dan terutama di mesin arcade, gim seringkali membutuhkan bekerja dengan hanya satu bit dari jumlahnya.  Seringkali ada kode yang serupa: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/*  1:     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buttons_ptr = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-number"><span class="hljs-number">0x2043</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buttons = *buttons_ptr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buttons &amp; <span class="hljs-number"><span class="hljs-number">0x4</span></span>) HandleLeftButton(); <span class="hljs-comment"><span class="hljs-comment">/*  2:  LED-    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * LED_pointer = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) <span class="hljs-number"><span class="hljs-number">0x2089</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> led = *LED_pointer; led = led | <span class="hljs-number"><span class="hljs-number">0x40</span></span>; <span class="hljs-comment"><span class="hljs-comment">//,  LED   6 *LED_pointer = led; /*  3:   LED- */ char * LED_pointer = (char *) 0x2089; char led = *LED_pointer; led = led &amp; 0xBF; //  6 *LED_pointer = led;</span></span></code> </pre> <br>  Dalam Contoh 1, alamat $ 2043 yang dialokasikan dalam memori adalah alamat tombol pada panel kontrol.  Kode ini membaca dan merespons tombol yang ditekan.  (Tentu saja, di Space Invaders kode ini akan menggunakan bahasa assembly!) <br><br>  Dalam Contoh 2, permainan ingin menyalakan indikator LED, yang terletak di bit 6 dari alamat $ 2089 yang dialokasikan dalam memori.  Kode harus membaca nilai yang ada, hanya mengubah satu bit, dan menulisnya kembali. <br><br>  Dalam contoh 3, Anda harus mematikan indikator dari contoh 2, sehingga kode harus mengatur ulang bit 6 dari alamat $ 2089.  Ini dapat dilakukan dengan melakukan operasi DAN untuk byte kontrol indikator dengan nilai yang hanya bit 6 adalah nol. Jadi kita hanya akan mempengaruhi 6, meninggalkan bit yang tersisa tidak berubah. <br><br>  Ini biasanya disebut "topeng."  Dalam C, mask biasanya ditulis menggunakan operator NOT, dilambangkan dengan tilde ("~").  Karena itu, alih-alih menulis <code>0xBF</code> , saya hanya menulis <code>~0x40</code> dan mendapatkan nomor yang sama, tetapi tanpa banyak usaha. <br><br><h1>  Pengantar bahasa assembly </h1><br>  Jika Anda membaca tutorial ini, Anda mungkin akrab dengan pemrograman komputer, misalnya, dalam Java atau Python.  Bahasa-bahasa ini memungkinkan Anda untuk melakukan banyak pekerjaan hanya dalam beberapa baris kode.  Kode dianggap ditulis dengan cerdik jika bekerja sebanyak mungkin dalam beberapa baris sebanyak mungkin, bahkan mungkin menggunakan fungsi pustaka built-in.  Bahasa semacam itu disebut "bahasa tingkat tinggi." <br><br>  Sebaliknya, dalam bahasa assembly, tidak ada fitur bawaan yang menyelamatkan jiwa, dan banyak baris kode sederhana mungkin diperlukan untuk menyelesaikan tugas-tugas sederhana.  Bahasa assembly dianggap bahasa tingkat rendah.  Di dalamnya, Anda harus terbiasa berpikir dengan gaya "urutan langkah apa yang harus diambil untuk menyelesaikan tugas ini?" <br><br>  Hal terpenting yang perlu Anda ketahui tentang bahasa assembler adalah bahwa setiap baris diterjemahkan ke dalam satu perintah prosesor. <br><br>  Pertimbangkan konstruksi seperti itu dari bahasa C: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = b + <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br>  Dalam bahasa assembly, tugas ini harus dilakukan dalam urutan berikut: <br><br><ol><li>  Masukkan alamat variabel B ke dalam register 1 </li><li>  Muat konten alamat memori ini ke register 2 </li><li>  Tambahkan nilai langsung 0x64 untuk mendaftar 2 </li><li>  Masukkan alamat variabel A ke dalam register 1 </li><li>  Tulis isi register 2 ke alamat yang tersimpan di register 1 </li></ol><br>  Dalam kode, akan terlihat seperti ini: <br><br><pre> <code class="hljs pgsql"> lea a1, #<span class="hljs-meta"><span class="hljs-meta">$1000</span></span> ;   a lea a2, #<span class="hljs-meta"><span class="hljs-meta">$1008</span></span> ;   b <span class="hljs-keyword"><span class="hljs-keyword">move</span></span>.l d0,(a2) <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>.l d0, #<span class="hljs-meta"><span class="hljs-meta">$64</span></span> mov (a1),d0</code> </pre> <br>  Perlu diperhatikan hal berikut: <br><br><ul><li>  Dalam bahasa tingkat tinggi, kompiler memutuskan di mana menempatkan variabel dalam memori.  Saat menulis kode dalam assembler, Anda sendiri bertanggung jawab untuk setiap alamat memori yang akan Anda gunakan. </li><li>  Dalam sebagian besar bahasa assembly, tanda kurung berarti "memori di alamat ini." </li><li>  Dalam sebagian besar bahasa assembler, # menunjukkan angka aljabar, juga disebut nilai langsung.  Misalnya, pada baris 1 dari contoh di atas, kode sebenarnya menulis nilai # 0x1000 untuk mendaftarkan a1.  Jika kode itu tampak seperti <code>move.l a1, ($1000)</code> , maka a1 akan menerima isi memori di alamat 0x1000. </li><li>  Setiap prosesor memiliki bahasa rakitan sendiri, dan kode porting dari satu prosesor ke prosesor lain mungkin sulit. </li><li>  Ini bukan bahasa rakitan prosesor nyata, saya datang dengan itu sebagai contoh. </li></ul><br>  Namun, ada satu hal yang sama antara programmer pintar tingkat tinggi dan penyihir assembler.  Programmer assembler menganggapnya suatu kehormatan untuk menyelesaikan tugas seefisien mungkin dan meminimalkan jumlah instruksi yang digunakan.  Kode untuk mesin arcade biasanya sangat dioptimalkan dan semua jus diperas dari setiap byte dan siklus ekstra. <br><br><h1>  Tumpukan </h1><br>  Mari kita bicara sedikit tentang bahasa assembly.  Dalam program komputer yang agak rumit dalam assembler subrutin digunakan.  Sebagian besar CPU memiliki struktur yang disebut stack. <br><br>  Bayangkan tumpukan dalam bentuk tumpukan.  Jika kami perlu menyimpan nomor, kami meletakkannya di bagian atas tumpukan.  Ketika kita perlu membawanya kembali, kita mengambilnya dari atas tumpukan.  Pemrogram assembler memanggil nomor yang muncul di tumpukan "push," dan muncul itu disebut "pop." <br><br>  Katakanlah program saya perlu memanggil subrutin.  Saya dapat menulis kode serupa: <br><br><pre> <code class="hljs css"> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1000</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">d0</span></span> ;  <span class="hljs-selector-tag"><span class="hljs-selector-tag">d0</span></span>   0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1004</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> ;     0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1008</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">d1</span></span> ;  <span class="hljs-selector-tag"><span class="hljs-selector-tag">d1</span></span>   0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1010</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> ;  .. 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1014</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">a0</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1018</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x101C</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">a1</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1020</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1024</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-id"><span class="hljs-selector-id">#0x1030</span></span> ;   0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1028</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x102C</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">jmp</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#0x2040</span></span> ;   <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x2040</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1030</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a1</span></span>, (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>) ;    0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1034</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sub</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> ;    0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1038</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a0</span></span>, (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>) ;    0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x103c</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sub</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span>  ..</code> </pre> <br>  Kode yang ditunjukkan di atas mendorong nilai d0, d1, a0 dan a1 ke stack.  Sebagian besar prosesor menggunakan penunjuk tumpukan.  Ini bisa berupa register biasa, dengan konvensi yang digunakan sebagai stack pointer, atau register khusus dengan fungsi untuk instruksi tertentu. <br><br>  Pada prosesor dalam seri 68K, penunjuk tumpukan hanya ditentukan oleh konvensi, atau register biasa.  Dalam prosesor 8080 kami, register SP adalah register khusus.  Ini memiliki perintah PUSH dan POP yang menulis dan pop dari tumpukan hanya dalam satu perintah. <br><br>  Dalam proyek emulator kami, kami tidak akan menulis kode dari awal.  Tetapi jika Anda perlu menganalisis program dalam bahasa assembly, maka ada baiknya belajar mengenali konstruksi semacam itu. <br><br><h4>  Bahasa tingkat tinggi </h4><br>  Saat menulis program dalam bahasa tingkat tinggi, semua operasi menyimpan dan memulihkan register dilakukan dengan setiap panggilan fungsi.  Kami tidak memikirkannya, karena kompilator berurusan dengan mereka.  Panggilan fungsi dalam bahasa tingkat tinggi dapat menghabiskan banyak memori dan waktu prosesor. <br><br>  Pernahkah Anda mengalami program mogok saat memanggil subrutin dalam loop tak terbatas?  Ini bisa terjadi karena setiap panggilan fungsi mendorong nilai register ke stack, dan pada titik tertentu memori kehabisan stack.  (Jika tumpukan tumbuh terlalu besar, ini disebut stack overflow, atau stack overflow.) <br><br>  Anda mungkin pernah mendengar tentang fungsi sebaris.  Mereka menghindari menyimpan dan mengembalikan register dengan memasukkan kode rutin dalam fungsi panggilan.  Kode menjadi lebih besar, tetapi berkat ini, beberapa perintah dan operasi baca / tulis ke memori disimpan. <br><br><h4>  Hubungi Konvensi </h4><br>  Saat menulis program assembler yang hanya memanggil kode Anda, Anda dapat memutuskan sendiri bagaimana rutinitas akan berkomunikasi satu sama lain.  Misalnya, bagaimana saya kembali ke fungsi panggilan setelah rutinitas selesai?  Salah satu caranya adalah dengan menulis alamat pengirim ke register tertentu.  Yang lain adalah menempatkan alamat kembali di atas tumpukan.  Sangat sering, keputusan tergantung pada apa yang didukung prosesor.  8080 memiliki perintah CALL yang mendorong alamat pengirim suatu fungsi ke stack.  Mungkin Anda akan menggunakan perintah 8080 ini untuk mengimplementasikan panggilan subrutin. <br><br>  Satu keputusan lagi perlu dibuat.  Apakah pelestarian register merupakan tanggung jawab fungsi panggilan atau subrutin?  Dalam contoh di atas, register disimpan oleh fungsi panggilan.  Tetapi bagaimana jika kita memiliki 32 register?  Menyimpan dan memulihkan 32 register ketika rutin hanya menggunakan sebagian kecil dari mereka akan membuang-buang waktu. <br><br>  Pertukaran mungkin merupakan pendekatan campuran.  Misalkan kita memilih kebijakan di mana rutin dapat menggunakan register r10-r32 tanpa menyimpan kontennya, tetapi tidak dapat menghancurkan r1-r9.  Dalam situasi yang serupa, fungsi panggilan mengetahui yang berikut: <br><br><ul><li>  Ketika kembali dari suatu fungsi, isi r1-r9 akan tetap tidak berubah </li><li>  Saya tidak bisa bergantung pada isi r10-r32 </li><li>  Jika saya membutuhkan nilai di r10-r32 setelah memanggil subrutin, maka sebelum memanggilnya saya perlu menyimpannya di suatu tempat </li></ul><br>  Demikian pula, setiap rutin tahu yang berikut: <br><br><ul><li>  Saya dapat menghancurkan r10-r32 </li><li>  Jika saya ingin menggunakan r1-r9, maka saya perlu menyimpan konten dan mengembalikannya sebelum kembali ke fungsi yang memanggil saya </li></ul><br><h4>  Abi </h4><br>  Pada kebanyakan platform modern, kebijakan semacam itu dibuat oleh para insinyur dan diterbitkan dalam dokumen yang disebut ABI (Application Binary Interface).  Berkat dokumen ini, pembuat kompiler tahu cara mengkompilasi kode yang dapat memanggil kode yang dikompilasi oleh kompiler lain.  Jika Anda ingin menulis kode assembler yang dapat berfungsi dalam lingkungan seperti itu, maka Anda perlu mengetahui ABI dan menulis kode sesuai dengannya. <br><br>  Mengetahui ABI juga membantu dalam kode debug ketika Anda tidak memiliki akses ke sumber.  ABI menentukan lokasi parameter untuk fungsi, jadi ketika mempertimbangkan subprogram apa pun, Anda dapat memeriksa alamat ini untuk memahami apa yang diteruskan ke fungsi. <br><br><h4>  Kembali ke emulator </h4><br>  Sebagian besar kode perakitan yang ditulis tangan, terutama untuk prosesor dan game arcade yang lebih lama, tidak mengikuti ABI.  Program disusun dan mungkin tidak memiliki banyak rutinitas.  Setiap rutin menyimpan dan mengembalikan register hanya dalam keadaan darurat. <br><br>  Jika Anda ingin memahami apa yang dilakukan program, alangkah baiknya memulai dengan menandai alamat yang ditargetkan untuk perintah CALL. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418635/">https://habr.com/ru/post/id418635/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418625/index.html">Panggilan rahasia kepada Andy Grove yang membantu Apple membeli NeXT</a></li>
<li><a href="../id418627/index.html">Lebih lanjut tentang metode untuk memecahkan sistem persamaan aljabar linier</a></li>
<li><a href="../id418629/index.html">Cara memverifikasi secara independen apakah Anda dapat mematenkan produk Anda dan melakukan pencarian paten</a></li>
<li><a href="../id418631/index.html">7 pedoman kode javascript</a></li>
<li><a href="../id418633/index.html">Reaktivitas JavaScript: Contoh Sederhana dan Intuitif</a></li>
<li><a href="../id418637/index.html">Kubernet kepada massa: Slurm dimulai pada 3 Agustus</a></li>
<li><a href="../id418639/index.html">Akka Streaming untuk manusia biasa</a></li>
<li><a href="../id418641/index.html">Kesalahan yang membuat desainer tidak berkembang</a></li>
<li><a href="../id418643/index.html">Sit vs stand: bagaimana cara kerjanya lebih baik?</a></li>
<li><a href="../id418645/index.html">Makalah dari konferensi musim semi C ++ Russia 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>