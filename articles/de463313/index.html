<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧓 👨🏽‍🍳 🥀 Ein alternativer Ansatz zum Abonnieren von Ereignissen, oder ist EventObject wirklich notwendig? 🖱️ 👨‍👩‍👦 🕵🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zusammenfassung 


 Der Zweck dieses Artikels ist der Versuch, eine Beschreibung von Ereignisverteilungssystemen aus einem anderen Blickwinkel zu betr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ein alternativer Ansatz zum Abonnieren von Ereignissen, oder ist EventObject wirklich notwendig?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463313/"><h2 id="rezyume">  Zusammenfassung </h2><br><p>  Der Zweck dieses Artikels ist der Versuch, eine Beschreibung von Ereignisverteilungssystemen aus einem anderen Blickwinkel zu betrachten. <br><br>  Zum Zeitpunkt dieses Schreibens implementieren die meisten führenden <strong>PHP-</strong> Frameworks ein Ereignissystem, das auf einer Beschreibung eines <em>EventObject basiert</em> . <br><br>  Dies ist zum Standard in PHP geworden, was kürzlich durch die Übernahme des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PSR / Event-Dispatcher-</a> Standards bestätigt wurde. <br><br>  Es stellt sich jedoch heraus, dass die Beschreibung des Ereignisobjekts wenig zur Entwicklung des Listeners beiträgt.  Für Details unter Kat. </p><a name="habracut"></a><br><h2 id="v-chyom-problema">  Was ist das Problem </h2><br><p>  Schauen wir uns die Rollen und Ziele derer an, die <em>EventObject</em> in der Entwicklung verwenden. </p><br><ol><li><p>  Ein Entwickler (A), der die Möglichkeit festlegt, Anweisungen von Drittanbietern durch Generieren eines Ereignisses in seinen Prozess einzufügen. </p><br><p>  Der Entwickler beschreibt das <em>EventObject</em> oder seine Signatur über eine Schnittstelle. </p><br><p>  Bei der Beschreibung von <em>EventObject ist es das Ziel des</em> Entwicklers, anderen Entwicklern eine Beschreibung des Datenobjekts zu geben und in einigen Anwendungsfällen den Mechanismus der Interaktion mit dem Hauptthread über dieses Objekt zu beschreiben. </p><br></li><li><p>  Entwickler (B), der den "Listener" beschreibt. </p><br><p>  Der Entwickler abonniert das angegebene Ereignis.  In den meisten Fällen sollte die Listener-Beschreibung dem <strong>aufrufbaren</strong> Typ entsprechen. </p><br><p>  Gleichzeitig scheut der Entwickler nicht, Klassen oder Methoden des Listeners zu benennen.  Es gibt jedoch eher eine Einschränkung, dass der Handler ein <em>EventObject</em> als Argument empfängt. </p><br></li></ol><br><p>  Als der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">psr / event-dispatcher</a> von der Arbeitsgruppe übernommen wurde, wurden viele Optionen für die Verwendung von Ereignisverteilungssystemen analysiert. </p><br><p>  Der psr-Standard erwähnt die folgenden Anwendungsfälle: </p><br><ol><li>  One-Way-Hinweis - "Ich habe etwas getan, wenn Sie interessiert sind" </li><li>  Objektverbesserung - "Hier ist eine Sache, bitte ändern Sie sie, bevor ich etwas damit mache" </li><li>  Sammlung - "Gib mir all deine Sachen, damit ich mit dieser Liste etwas anfangen kann" </li><li>  alternative Kette - "Hier ist das Ding, der erste von euch, der damit fertig wird, es tut und dann aufhört" </li></ol><br><p>  Gleichzeitig warf die Arbeitsgruppe viele Fragen zur ähnlichen Verwendung von Ereignisverteilungssystemen auf, die damit zusammenhängen, dass jeder Anwendungsfall eine „Unsicherheit“ aufweist, die von der Implementierung des <em>Dispatcher-</em> Objekts abhängt. </p><br><p>  In den oben für Entwickler (B) beschriebenen Rollen gibt es keine bequeme und gut lesbare Möglichkeit zu verstehen, welche der Optionen für die Verwendung des Ereignissystems von Entwickler (A) ausgewählt wurde.  Der Entwickler muss immer den Beschreibungscode nicht nur des <em>EventObjects</em> , sondern auch des Codes, in dem dieses Ereignis generiert wird, <em>überprüfen</em> . </p><br><p>  Infolgedessen ist die Signatur eine Beschreibung des Ereignisobjekts, die die Arbeit des Entwicklers erleichtern soll (B). Dieser Job ist nicht gut. </p><br><p>  Ein weiteres Problem ist das nicht immer gerechtfertigte Vorhandensein eines separaten Objekts, das zusätzlich die bereits in den Systemen beschriebenen Entitäten beschreibt. </p><br><pre><code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">MyApp</span></span>\<span class="hljs-title"><span class="hljs-title">Customer</span></span>\<span class="hljs-title"><span class="hljs-title">Events</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">MyApp</span></span>\<span class="hljs-title"><span class="hljs-title">Customer</span></span>\<span class="hljs-title"><span class="hljs-title">CustomerNameInterface</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">MyFramevork</span></span>\<span class="hljs-title"><span class="hljs-title">Event</span></span>\<span class="hljs-title"><span class="hljs-title">SomeEventInterface</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomerNameChangedEvent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeEventInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** *     * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> int */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCustomerId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** *    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCustomerName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomerNameInterface</span></span></span></span>; }</code> </pre> <br><p>  Im obigen Beispiel wurde das <em>CustomerNameInterface-</em> Objekt bereits im System beschrieben. </p><br><p>  Dies erinnert an die übermäßige Einführung neuer Konzepte.  Wenn wir beispielsweise eine Methode implementieren müssen, indem wir in das Namensänderungsprotokoll des Clients schreiben, kombinieren wir die Methodenargumente nicht in einer separaten Entität, sondern verwenden die Standardbeschreibung einer Methode des Formulars: </p><br><pre> <code class="php hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeToLogCustomerNameChange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( int $customerId, CustomerNameInterface $customerName )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Infolgedessen sehen wir die folgenden Probleme: </p><br><ol><li>  schlechte Listener-Code-Signatur </li><li>  Unsicherheit des Dispatchers </li><li>  Rückgabetypunsicherheit </li><li>  Einführung vieler zusätzlicher Entitäten wie <em>SomeEventObject</em> </li></ol><br><h2 id="posmotrim-na-eto-s-inoy-tochki-zreniya">  Betrachten wir es aus einer anderen Perspektive </h2><br><p>  Wenn eines der Probleme eine schlechte Beschreibung des Listeners ist, betrachten wir das Ereignisverteilungssystem nicht anhand der Beschreibung des Ereignisobjekts, sondern anhand der Beschreibung des Listeners. </p><br><p>  Entwickler (A) beschreibt, wie der Listener beschrieben werden soll. </p><br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">MyApp</span></span>\<span class="hljs-title"><span class="hljs-title">Customer</span></span>\<span class="hljs-title"><span class="hljs-title">Events</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomerNameChangedListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCustomerNameChange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( int $customerId, CustomerNameInterface $customerName )</span></span></span></span>; }</code> </pre> <br><p>  Der ausgezeichnete Entwickler (A) konnte eine Beschreibung des Hörers und der übertragenen Daten an Drittentwickler weitergeben. </p><br><p>  Beim Schreiben eines Listeners gibt der Entwickler (B) <em>CustomerNameChangedListener</em> in die <em>Implementierungsumgebung ein,</em> und die IDE kann seiner Klasse eine Beschreibung der Listener-Methode hinzufügen.  <strong>Die Code-Vervollständigung ist</strong> großartig. </p><br><p>  Werfen wir einen Blick auf die neue Signatur der Listener-Methode.  Schon ein kurzer Blick genügt, um zu verstehen, dass die Version des verwendeten Ereignisverteilungssystems "Einwegbenachrichtigung" lautet. </p><br><p>  Die Eingabedaten werden nicht als Referenz übertragen, was bedeutet, dass es keine Möglichkeit gibt, sie in irgendeiner Weise so zu ändern, dass die Änderungen in den Hauptstrom fallen.  Fehlender Rückgabewert, keine Rückmeldung vom Haupt-Thread. </p><br><p>  Was ist mit anderen Anwendungsfällen?  Spielen wir mit der Beschreibung der Ereignis-Listener-Oberfläche. </p><br><hr><br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">MyApp</span></span>\<span class="hljs-title"><span class="hljs-title">Customer</span></span>\<span class="hljs-title"><span class="hljs-title">Events</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomerNameChangedListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCustomerNameChange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( int $customerId, CustomerNameInterface $customerName )</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomerNameInterface</span></span></span></span>; }</code> </pre> <br><p>  Es gab eine Anforderung für den Rückgabewert, was bedeutet, dass der Listener einen anderen Wert zurückgeben kann (aber nicht muss), wenn er mit der angegebenen Schnittstelle übereinstimmt.  Anwendungsfall: "Objektverbesserung". </p><br><hr><br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">MyApp</span></span>\<span class="hljs-title"><span class="hljs-title">Customer</span></span>\<span class="hljs-title"><span class="hljs-title">Events</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomerNameChangedListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> ItemInterface[] */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCustomerNameChange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( int $customerId, CustomerNameInterface $customerName )</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span></span>; }</code> </pre> <br><p>  Es gab eine Anforderung für den Rückgabewert eines bestimmten Typs, anhand derer verstanden werden kann, dass dies ein Element der Sammlung ist.  Anwendungsfall: "Sammlung". </p><br><hr><br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">MyApp</span></span>\<span class="hljs-title"><span class="hljs-title">Customer</span></span>\<span class="hljs-title"><span class="hljs-title">Events</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomerNameChangedListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCustomerNameChange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( int $customerId, CustomerNameInterface $customerName )</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VoteInterface</span></span></span></span>; }</code> </pre> <br><p>  Anwendungsfall: "Alternative Kette, Abstimmung." </p><br><hr><br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">MyFramework</span></span>\<span class="hljs-title"><span class="hljs-title">Events</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventControllInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stopPropagation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">MyApp</span></span>\<span class="hljs-title"><span class="hljs-title">Customer</span></span>\<span class="hljs-title"><span class="hljs-title">Events</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomerNameChangedListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCustomerNameChange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( int $customerId, CustomerNameInterface $customerName, EventControllInterface &amp;$eventControll )</span></span></span></span>; }</code> </pre><br><p>  <em>Ohne Diskussion ist es gut oder schlecht, die Ausbreitung von Ereignissen zu stoppen.</em> </p><br><p>  Diese Option wird eindeutig gelesen. Der Hauptthread bietet dem Listener die Möglichkeit, das Ereignis zu stoppen. </p><br><p>  Wenn wir also zur Beschreibung des Listeners übergehen, erhalten wir bei der Entwicklung viel besser lesbare Signaturen der Listener-Methoden. </p><br><p>  Zusätzlich haben wir die Möglichkeit, auf den Haupt-Thread explizit zu verweisen auf: </p><br><ol><li>  Akzeptanz von Änderungen eingehender Daten </li><li>  Rückgabetypen außer eingehenden Typen </li><li>  explizite Übertragung eines Objekts, mit dem die Ausbreitung eines Ereignisses gestoppt werden soll </li></ol><br><h2 id="kak-realizovat-podpisku-na-sobytie">  So implementieren Sie ein Ereignisabonnement </h2><br><p>  Optionen können unterschiedlich sein.  Die allgemeine Bedeutung aller Optionen beruht auf der Tatsache, dass wir das <em>ListenerProvider-</em> Objekt (das Objekt, das die Möglichkeit bietet, das Ereignis zu abonnieren) irgendwie darüber informieren müssen, zu welchem ​​Ereignis die spezifische Schnittstelle gehört. </p><br><p>  Sie können die Konvertierung des übergebenen Objekts in einen aufrufbaren Typ als Beispiel betrachten.  Es versteht sich, dass es viele Möglichkeiten geben kann, zusätzliche Metainformationen zu erhalten: </p><br><ol><li>  kann wie im Beispiel explizit übergeben werden </li><li>  kann in Anmerkungen von Listener-Schnittstellen gespeichert werden </li><li>  Sie können den Namen der Listener-Oberfläche als Namen der Ereignisse verwenden </li></ol><br><hr><br><p>  <strong>Beispiel für die Implementierung eines Abonnements</strong> </p><br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">MyFramework</span></span>\<span class="hljs-title"><span class="hljs-title">Events</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListenerProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $handlerAssociation = []; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHandlerAssociation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( string $handlerInterfaceName, string $handlerMethodName, string $eventName )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;handlerAssociation[$handlerInterfaceName] = [ <span class="hljs-string"><span class="hljs-string">'methodName'</span></span> =&gt; $handlerMethodName, <span class="hljs-string"><span class="hljs-string">'eventName'</span></span> =&gt; $eventName ]; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object $handler)</span></span></span><span class="hljs-function"> </span></span>{ $hasAssociation = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;handlerAssociation <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $handlerInterfaceName =&gt; $handlerMetaData ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( $handler interfaceof $handlerInterfaceName ) { $methodName = $handlerMetaData[<span class="hljs-string"><span class="hljs-string">'methodName'</span></span>]; $eventName = $handlerMetaData[<span class="hljs-string"><span class="hljs-string">'eventName'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;addListener($eventName, [$handler, $methodName]); $hasAssociation = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !$hasAssociation ) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>(<span class="hljs-string"><span class="hljs-string">'Unknown handler object'</span></span>); } } }</code> </pre> <br><p>  Wir fügen dem Abonnementobjekt eine Konfigurationsmethode hinzu, die für jede Listener-Schnittstelle ihre Metadaten beschreibt, z. B. die aufgerufene Methode und den Namen des Ereignisses. </p><br><p>  Nach diesen Daten wandeln wir zum Zeitpunkt des Abonnements den übergebenen $ -Handler in ein <strong>aufrufbares</strong> Objekt um, das die aufgerufene Methode angibt. </p><br><p>  Wenn Sie bemerken, impliziert der Code, dass ein $ handler-Objekt viele Ereignis-Listener-Schnittstellen implementieren kann und für jede von ihnen abonniert wird.  Dies ist ein Analogon von <em>SubscriberInterface</em> für das Massenabonnieren eines Objekts für mehrere Ereignisse.  Wie Sie sehen können, ist in der obigen Implementierung kein separater Mechanismus erforderlich, da <code>addSubscriber(SubscriberInterface $subscriber)</code> funktioniert. </p><br><h2 id="dispatcher">  Dispatcher </h2><br><p>  Leider läuft der beschriebene Ansatz der als psr / event-dispatcher-Standard akzeptierten Schnittstelle zuwider </p><br><p>  Da müssen wir kein Objekt an Dispatcher übergeben.  Ja, Sie können ein Objekt wie Zucker übergeben: </p><br><pre> <code class="php hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $eventName, ...$arguments)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } public function getEventName(): string { // ... } public function getArguments(): array { // ... } }</span></span></code> </pre> <br><p>  Und verwenden Sie es, wenn Sie ein Ereignis auf der psr-Schnittstelle generieren, aber es ist einfach nur hässlich. </p><br><p>  In guter Weise würde die Dispatcher-Oberfläche folgendermaßen besser aussehen: </p><br><pre> <code class="php hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventDispatcherInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispatch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $eventName, ...$arguments)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispatchStopabled</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $eventName, ...$arguments)</span></span></span></span>; }</code> </pre> <br><p>  Warum zwei Methoden?  Es ist schwierig, alle Anwendungsfälle in einer einzigen Implementierung zu kombinieren.  Es ist besser, für jeden Anwendungsfall eine eigene Methode hinzuzufügen. Es wird eindeutig interpretiert, wie der Dispatcher die von den Listenern zurückgegebenen Werte verarbeitet. </p><br><p>  Das ist alles  Es wäre interessant, mit der Community zu diskutieren, ob der beschriebene Ansatz das Recht auf Leben hat. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463313/">https://habr.com/ru/post/de463313/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463301/index.html">Gonkey - Microservice Testing Tool</a></li>
<li><a href="../de463303/index.html">Facebook hört schließlich auf, Anzeigen für Telefonnummern zu schalten, die für 2FA eingegeben werden</a></li>
<li><a href="../de463305/index.html">Tools zum Analysieren und Debuggen von .NET-Anwendungen</a></li>
<li><a href="../de463307/index.html">Fallstudie zur Kommunikation mit einem „schweren“ Kunden</a></li>
<li><a href="../de463311/index.html">CTT in Serverlösungen. Die zweite Version + die Ankündigung der dritten, mit der Fähigkeit zu berühren</a></li>
<li><a href="../de463317/index.html">Technische Details zum Hacken der Capital One Bank auf AWS</a></li>
<li><a href="../de463321/index.html">Usability-Körbe und Kassen: Analyse der 20 besten russischen Nischen-Online-Shops</a></li>
<li><a href="../de463325/index.html">Game Designer Reflection: Charaktere für ein Spiel, das nicht herausgekommen ist</a></li>
<li><a href="../de463327/index.html">Vue.js: 3 Anti-Patterns</a></li>
<li><a href="../de463329/index.html">Entwicklung dynamischer Baumdiagramme mit SVG und Vue.js.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>