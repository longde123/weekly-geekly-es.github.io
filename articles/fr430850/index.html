<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüè≠ üíÉüèø üò† Apple Metal chez MAPS.ME üôáüèΩ üõ©Ô∏è ‚úçüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour √† tous! 

 Dans le monde, il existe un grand nombre d'applications sur OpenGL, et il semble qu'Apple ne soit pas tout √† fait d'accord avec cel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apple Metal chez MAPS.ME</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/430850/"><img src="https://habrastorage.org/webt/jf/bk/ix/jfbkixzquc9k0dnnqnaorskj4bk.png" alt="image" align="left">  Bonjour √† tous! <br><br>  Dans le monde, il existe un grand nombre d'applications sur OpenGL, et il semble qu'Apple ne soit pas tout √† fait d'accord avec cela.  Depuis iOS 12 et MacOS Mojave, OpenGL est obsol√®te.  Nous avons int√©gr√© Apple Metal dans MAPS.ME et sommes pr√™ts √† partager notre exp√©rience et nos r√©sultats.  Nous vous dirons comment refa√ßonner notre moteur graphique, quelles difficult√©s nous avons d√ª affronter et, surtout, combien de FPS nous avons maintenant. <br><br>  Tous ceux qui sont int√©ress√©s ou envisagent d'ajouter le support Apple Metal au moteur graphique sont les bienvenus √† cat. <br><a name="habracut"></a><br><h2>  Probl√®me </h2><br>  Notre moteur graphique a √©t√© con√ßu comme multiplateforme, et comme OpenGL est, en fait, la seule API graphique multiplateforme pour l'ensemble des plates-formes qui nous int√©ressent (iOS, Android, MacOS et Linux), nous l'avons choisi comme base.  Nous n'avons pas fait un niveau d'abstraction suppl√©mentaire qui cacherait les fonctionnalit√©s sp√©cifiques √† OpenGL, mais, heureusement, nous avons laiss√© le potentiel de sa mise en ≈ìuvre. <br><br>  Avec l'av√®nement de la nouvelle g√©n√©ration d'API graphiques Apple Metal et Vulkan, nous avons bien s√ªr envisag√© la possibilit√© de leur apparition dans notre application, cependant, nous avons √©t√© arr√™t√©s par ce qui suit: <br><br><ol><li>  Vulkan ne pouvait fonctionner que sur Android et Linux, et Apple Metal ne pouvait fonctionner que sur iOS et MacOS.  Nous ne voulions pas perdre la multiplicit√© des plates-formes au niveau de l'API graphique, cela compliquerait les processus de d√©veloppement et de d√©bogage, augmenterait la quantit√© de travail. </li><li>  Une application sur Apple Metal ne peut pas √™tre construite et ex√©cut√©e sur un simulateur iOS (√† propos, jusqu'√† pr√©sent), ce qui compliquerait √©galement notre d√©veloppement et ne nous permettrait pas de nous d√©barrasser compl√®tement d'OpenGL. </li><li>  Le framework Qt, que nous utilisons pour cr√©er des outils internes, ne supportait que OpenGL ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vulkan est maintenant support√©</a> ). </li><li>  Apple Metal n'avait pas et n'a pas d'API C ++, ce qui nous obligerait √† proposer des abstractions non seulement pour le runtime, mais aussi pour la phase de construction de l'application, lorsqu'une partie du moteur est compil√©e en Objective-C ++, et une autre, beaucoup plus grande, en C ++. </li><li>  Nous n'√©tions pas pr√™ts √† cr√©er un moteur s√©par√© ou une branche de code distincte sp√©cifiquement pour iOS. </li><li>  La mise en ≈ìuvre a √©t√© √©valu√©e au moins six mois dans le travail d'un d√©veloppeur graphique. </li></ol><br>  Lorsqu'au printemps 2018, Apple a annonc√© le transfert d'OpenGL au statut obsol√®te, il est devenu clair qu'il n'√©tait plus possible de reporter, et les probl√®mes ci-dessus devaient √™tre r√©solus d'une mani√®re ou d'une autre.  De plus, nous travaillons depuis longtemps √† l'optimisation de la vitesse d'application et de la consommation d'√©nergie, et Apple Metal semblait √™tre en mesure de vous aider. <br><br><h2>  S√©lection de d√©cision </h2><br>  Presque imm√©diatement, nous avons remarqu√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MoltenVK</a> .  Ce framework √©mule l'API Vulkan en utilisant Apple Metal, et son code source a √©t√© r√©cemment ouvert.  L'utilisation de MoltenVK, semble-t-il, permettrait de remplacer OpenGL par Vulkan, et n'aurait pas du tout √† g√©rer l'int√©gration s√©par√©e d'Apple Metal.  De plus, les d√©veloppeurs de Qt ont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">refus√© un support s√©par√© pour le rendu sur Apple Metal</a> en faveur de MoltenVK.  Cependant, nous avons √©t√© arr√™t√©s: <br><br><ul><li>  la n√©cessit√© de prendre en charge les appareils Android sur lesquels Vulkan n'est pas disponible; </li><li>  l'impossibilit√© de d√©marrer sur le simulateur iOS sans la pr√©sence de repli sur OpenGL; </li><li>  l'incapacit√© √† utiliser les outils Apple pour le d√©bogage, le profilage et la pr√©compilation des shaders, car MoltenVK g√©n√®re des shaders en temps r√©el pour Apple Metal √† partir des codes source SPIR-V ou GLSL; </li><li>  la n√©cessit√© d'attendre les mises √† jour et les corrections de bugs de MoltenVK lors de la sortie de nouvelles versions de Metal; </li><li>  l'impossibilit√© d'une subtile optimisation sp√©cifique au Metal, mais non sp√©cifique ou inexistante pour Vulkan. </li></ul><br>  Il s'est av√©r√© que nous devons enregistrer OpenGL, ce qui signifie que nous ne pouvons pas nous passer de l'abstraction du moteur de l'API graphique.  Apple Metal, OpenGL ES et √† l'avenir Vulkan seront utilis√©s pour cr√©er des composants internes ind√©pendants du moteur graphique, qui peuvent √™tre compl√®tement interchangeables.  OpenGL jouera le r√¥le d'option de secours lorsque Metal ou Vulkan ne sont pas disponibles pour une raison ou une autre. <br><br>  Le plan de mise en ≈ìuvre √©tait le suivant: <br><br><ol><li>  Refactorisation du moteur graphique pour abstraire l'API graphique utilis√©e. </li><li>  Rendre √† Apple Metal pour la version iOS de l'application. </li><li>  Faites des rep√®res appropri√©s pour la vitesse de rendu et la consommation d'√©nergie pour voir si les API graphiques modernes de niveau inf√©rieur peuvent b√©n√©ficier au produit. </li></ol><br><h2>  Diff√©rences cl√©s entre OpenGL et Metal </h2><br>  Pour comprendre comment abstraire l'API graphique, d√©terminons d'abord quelles sont les principales diff√©rences conceptuelles entre OpenGL et Metal. <br><br><ol><li>  On pense, et non sans raison, que Metal est une API de niveau inf√©rieur.  Cependant, cela ne signifie pas que vous devez √©crire dans l'assembleur ou impl√©menter la rast√©risation vous-m√™me.  Le m√©tal peut √™tre appel√© une API de bas niveau dans le sens o√π il effectue un tr√®s petit nombre d'actions implicites, c'est-√†-dire que presque toutes les actions doivent √™tre √©crites sur le programmeur lui-m√™me.  OpenGL fait beaucoup de choses implicitement, √† commencer par la prise en charge d'une r√©f√©rence implicite √† un contexte OpenGL et la liaison de ce contexte au flux dans lequel il a √©t√© cr√©√©. </li><li>  En Metal, "non" validation en temps r√©el des √©quipes.  En mode d√©bogage, la validation, bien s√ªr, existe et est bien meilleure que dans de nombreuses autres API, principalement en raison de son int√©gration √©troite avec Xcode.  Mais lorsque le programme est envoy√© √† l'utilisateur, il n'y a plus de validation, le programme se bloque simplement sur la toute premi√®re erreur.  Inutile de dire qu'OpenGL ne plante que dans les cas les plus extr√™mes.  La pratique la plus courante: ignorer l'erreur et continuer √† travailler. </li><li>  Metal peut pr√©compiler les shaders et cr√©er des biblioth√®ques √† partir d'eux.  Dans OpenGL, les shaders sont compil√©s √† partir de la source dans le processus du programme, car cela est responsable de l'impl√©mentation sp√©cifique de bas niveau d'OpenGL sur un p√©riph√©rique particulier.  Des diff√©rences et / ou des erreurs dans la mise en ≈ìuvre des compilateurs de shaders conduisent parfois √† des bugs fantastiques, en particulier sur les appareils Android de marques chinoises. </li><li>  OpenGL utilise activement la machine √† √©tats, qui ajoute des effets secondaires √† presque toutes les fonctions.  Ainsi, les fonctions OpenGL ne sont pas des fonctions pures et l'ordre et l'historique des appels sont souvent importants.  Metal n'utilise pas implicitement les √©tats et ne les conserve pas plus longtemps que n√©cessaire pour le rendu.  Les √©tats existent en tant qu'objets pr√©cr√©√©s et d√©faillants. </li></ol><br><h2>  Refonte et int√©gration du moteur graphique M√©tal </h2><br>  Le processus de refactorisation du moteur graphique consistait essentiellement √† trouver la meilleure solution pour se d√©barrasser des fonctionnalit√©s OpenGL que notre moteur utilisait activement.  Embedding Metal, √† partir de l'une des √©tapes, s'est d√©roul√© en parall√®le. <br><br><ul><li>  Comme d√©j√† indiqu√©, l'API OpenGL poss√®de une entit√© implicite appel√©e un contexte.  Le contexte est associ√© √† un thread sp√©cifique, et la fonction OpenGL appel√©e dans ce thread lui-m√™me trouve et utilise ce contexte.  Metal, Vulkan (oui, et d'autres API, par exemple, Direct3D) ne fonctionnent pas de cette fa√ßon, ils ont des objets explicites similaires appel√©s p√©riph√©rique ou instance.  L'utilisateur cr√©e lui-m√™me ces objets et est responsable de leur transfert vers diff√©rents sous-syst√®mes.  C'est √† travers ces objets que tous les appels aux commandes graphiques sont effectu√©s. <br><br>  Nous avons appel√© notre objet abstrait un contexte graphique, et dans le cas d'OpenGL il d√©core simplement les appels des commandes OpenGL, et dans le cas de Metal il contient l'interface racine MTLDevice √† travers laquelle les commandes Metal sont appel√©es. <br><br>  Bien s√ªr, j'ai d√ª distribuer cet objet (et puisque nous avons un rendu multi-thread, puis m√™me plusieurs de ces objets) sur tous les sous-syst√®mes. <br><br>  Nous avons cach√© la cr√©ation de files d'attente de commandes, d'encodeurs et leur gestion dans le contexte graphique, afin de ne pas propager des entit√©s qui n'existent tout simplement pas dans OpenGL. </li><li>  La perspective de la disparition de la validation des commandes graphiques sur les appareils des utilisateurs ne nous plaisait pas ouvertement.  Une large gamme d'appareils et de versions de syst√®me d'exploitation n'a pas pu √™tre enti√®rement couverte par notre service d'assurance qualit√©.  Par cons√©quent, nous avons d√ª ajouter des journaux d√©taill√©s o√π nous avions pr√©c√©demment re√ßu une erreur significative de l'API graphique.  Bien s√ªr, cette validation n'a √©t√© ajout√©e qu'aux emplacements potentiellement dangereux et critiques du moteur graphique, car couvrir l'int√©gralit√© du moteur avec un code de diagnostic est pratiquement impossible et g√©n√©ralement pr√©judiciable aux performances.  La nouvelle r√©alit√© est que les tests utilisateur et le d√©bogage avec les journaux sont d√©sormais du pass√©, du moins en termes de rendu. </li><li>  Notre pr√©c√©dent syst√®me de shaders n'√©tait pas adapt√© √† la refactorisation; j'ai d√ª le r√©√©crire compl√®tement.  Il ne s'agit pas seulement de la pr√©compilation des shaders et de leur validation au stade de l'assemblage du projet.  OpenGL utilise les variables dites uniformes pour passer des param√®tres aux shaders.  Le transfert de donn√©es structur√© n'est disponible qu'avec OpenGL ES 3.0, et comme nous prenons toujours en charge OpenGL ES 2.0, nous n'avons tout simplement pas utilis√© cette m√©thode.  Le m√©tal nous a fait utiliser des structures de donn√©es pour passer des param√®tres, et pour OpenGL nous avons d√ª trouver des mappages de champs de structure √† des variables uniformes.  De plus, j'ai d√ª r√©√©crire chacun des shaders dans le Metal Shading Language. </li><li>  Lors de l'utilisation d'objets d'√©tat, nous devions opter pour une astuce.  Dans OpenGL, tous les √©tats, en r√®gle g√©n√©rale, sont d√©finis imm√©diatement avant le rendu, et dans Metal, il doit s'agir d'un objet pr√©c√©demment cr√©√© et valid√©.  Notre moteur, √©videmment, utilisait l'approche OpenGL, et le refactoring avec la cr√©ation pr√©liminaire d'objets d'√©tat √©tait comparable √† une r√©√©criture compl√®te du moteur.  Pour couper ce n≈ìud, nous avons cr√©√© un cache d'√©tat √† l'int√©rieur du contexte graphique.  La premi√®re fois qu'une combinaison unique de param√®tres d'√©tat est g√©n√©r√©e, un objet d'√©tat est cr√©√© dans Metal et plac√© dans le cache.  Pour la deuxi√®me fois et les suivantes, l'objet est simplement r√©cup√©r√© du cache.  Cela fonctionne dans nos cartes, car le nombre de combinaisons diff√©rentes de param√®tres d'√©tat n'est pas trop grand (environ 20-30).  Pour un moteur graphique de jeu complexe, cette m√©thode ne convient gu√®re. </li></ul><br>  En cons√©quence, apr√®s environ 5 mois de travail, nous avons pu lancer MAPS.ME pour la premi√®re fois avec un rendu complet sur Apple Metal.  Il √©tait temps de d√©couvrir ce qui s'√©tait pass√©. <br><br><h2>  Test de vitesse de rendu </h2><br><h4>  Technique exp√©rimentale </h4><br>  Nous avons utilis√© diff√©rentes g√©n√©rations d'appareils Apple dans l'exp√©rience.  Tous ont √©t√© mis √† jour vers iOS 12. Le m√™me script utilisateur a √©t√© ex√©cut√© sur la navigation sur toutes les cartes (d√©placement et mise √† l'√©chelle).  Le script a √©t√© con√ßu pour garantir une identit√© presque compl√®te des processus au sein de l'application chaque fois qu'il a √©t√© d√©marr√© sur chaque appareil.  Comme lieu de test, nous avons choisi la zone de Los Angeles - l'une des zones les plus charg√©es de MAPS.ME. <br><br>  Tout d'abord, le script a √©t√© ex√©cut√© avec un rendu sur OpenGL ES 3.0, puis sur le m√™me appareil avec un rendu sur Apple Metal.  Entre les d√©marrages, l'application a √©t√© compl√®tement d√©charg√©e de la m√©moire. <br>  Les indicateurs suivants ont √©t√© mesur√©s: <br><br><ul><li>  FPS (images par seconde) pour l'ensemble de l'image; </li><li>  FPS pour la partie de la trame qui est uniquement engag√©e dans le rendu, √† l'exclusion de la pr√©paration des donn√©es et des autres op√©rations trame par trame; </li><li>  Le pourcentage de trames lentes (sup√©rieures √† ~ 30 ms), c'est-√†-dire  ceux que l'≈ìil humain peut percevoir comme des saccades. </li></ul><br>  Lors de la mesure des FPS, le dessin directement sur l'√©cran de l'appareil a √©t√© exclu, car la synchronisation verticale avec le taux de rafra√Æchissement de l'√©cran ne permet pas d'obtenir des r√©sultats fiables.  Par cons√©quent, le cadre a √©t√© dessin√© dans la texture en m√©moire.  Pour synchroniser le CPU et le GPU, OpenGL a utilis√© un appel suppl√©mentaire √† <code>glFinish</code> , tandis qu'Apple Metal a utilis√© <code>waitUntilCompleted</code> pour <code>MTLFrameCommandBuffer</code> . <br><br><table><tbody><tr><th width="100"></th><th width="100">  iPhone 6s </th><th width="100"></th><th width="100">  iPhone 7+ </th><th width="100"></th><th width="100">  iPhone 8 </th><th width="100"></th></tr><tr><th></th><th>  Opengl </th><th>  M√©tal </th><th>  Opengl </th><th>  M√©tal </th><th>  Opengl </th><th>  M√©tal </th></tr><tr><td>  Fps </td><td>  106 </td><td>  160 </td><td>  159 </td><td>  221 </td><td>  196 </td><td>  298 </td></tr><tr><td>  FPS (rendu uniquement) </td><td>  157 </td><td>  596 </td><td>  247 </td><td>  597 </td><td>  271 </td><td>  833 </td></tr><tr><td>  Fraction d'images lentes (&lt;30 ips) </td><td>  4,13% </td><td>  1,25% </td><td>  5,45% </td><td>  0,76% </td><td>  1,5% </td><td>  0,29% </td></tr></tbody></table><br><table><tbody><tr><th width="100"></th><th width="100">  iPhone X </th><th width="100"></th><th width="100">  iPad Pro 12,9 pouces </th><th width="100"></th></tr><tr><th></th><th>  Opengl </th><th>  M√©tal </th><th>  Opengl </th><th>  M√©tal </th></tr><tr><td>  Fps </td><td>  145 </td><td>  210 </td><td>  104 </td><td>  137 </td></tr><tr><td>  FPS (rendu uniquement) </td><td>  248 </td><td>  705 </td><td>  147 </td><td>  463 </td></tr><tr><td>  Fraction d'images lentes (&lt;30 ips) </td><td>  0,15% </td><td>  0,15% </td><td>  17,52% </td><td>  4,46% </td></tr></tbody></table><br><table><tbody><tr><th width="100"></th><th width="100">  iPhone 6s </th><th width="100">  iPhone 7+ </th><th width="100">  iPhone 8 </th><th width="100">  iPhone X </th><th width="100">  iPad Pro 12,9 pouces </th></tr><tr><td>  Acc√©l√©ration du cadre sur m√©tal (N fois) </td><td>  1,5 </td><td>  1,39 </td><td>  1,52 </td><td>  1,45 </td><td>  1,32 </td></tr><tr><td>  Acc√©l√©ration du rendu sur Metal (N fois) </td><td>  3,78 </td><td>  2,41 </td><td>  3.07 </td><td>  2,84 </td><td>  3,15 </td></tr><tr><td>  Am√©lioration des images lentes (N fois) </td><td>  3.3 </td><td>  7.17 </td><td>  5.17 </td><td>  1 </td><td>  3,93 </td></tr></tbody></table><br><h4>  Analyse des r√©sultats </h4><br>  En moyenne, le gain de performances du cadre avec Apple Metal √©tait de 43%.  La valeur minimale est fix√©e sur l'iPad Pro 12,9 '- 32%, le maximum - 52% sur l'iPhone 8. Il y a une d√©pendance: plus la r√©solution d'√©cran est basse, plus Apple Metal d√©passe OpenGL ES 3.0. <br><br>  Si nous √©valuons la partie du cadre directement responsable du rendu, la vitesse de rendu moyenne sur Apple Metal a √©t√© multipli√©e par 3.  Cela indique une organisation nettement meilleure et, par cons√©quent, l'efficacit√© de l'API Apple Metal par rapport √† OpenGL ES 3.0. <br><br>  Le nombre d'images lentes (plus de ~ 30 ms) sur Apple Metal a √©t√© r√©duit d'environ 4 fois.  Cela signifie que la perception des animations et des d√©placements sur la carte est devenue plus fluide.  Le pire r√©sultat a √©t√© enregistr√© sur l'iPad Pro 12,9 'avec une r√©solution de 2732 x 2048 pixels: OpenGL ES 3.0 donne environ 17,5% d'images lentes, tandis qu'Apple Metal - seulement 4,5%. <br><br><h2>  Test de puissance </h2><br><h4>  Technique exp√©rimentale </h4><br>  La consommation d'√©nergie a √©t√© test√©e sur iPhone 8 sur iOS 12. Le m√™me sc√©nario utilisateur a √©t√© ex√©cut√© - navigation sur la carte (d√©placement et mise √† l'√©chelle) pendant 1 heure.  Le script a √©t√© con√ßu pour garantir une identit√© presque compl√®te des processus au sein de l'application √† chaque d√©marrage.  La r√©gion de Los Angeles a √©galement √©t√© choisie comme lieu de test. <br><br>  Nous avons utilis√© l'approche suivante pour mesurer la consommation d'√©nergie.  L'appareil n'est pas connect√© au chargement.  Dans les param√®tres du d√©veloppeur, la journalisation de l'alimentation est activ√©e.  Avant de commencer l'exp√©rience, l'appareil est compl√®tement charg√©.  L'exp√©rience se termine √† la fin du script.  √Ä la fin de l'exp√©rience, l'√©tat de charge de la batterie a √©t√© enregistr√© et les journaux de consommation d'√©nergie ont √©t√© import√©s dans l'utilitaire pour profiler la batterie dans Xcode.  Nous avons enregistr√© combien de frais ont √©t√© d√©pens√©s pour le GPU.  De plus, nous avons ici pond√©r√© le rendu en incluant l'affichage du sch√©ma de m√©tro et l'anticr√©nelage plein √©cran. <br><br>  La luminosit√© de l'√©cran n'a pas chang√© dans tous les cas.  Aucun autre processus que le syst√®me et MAPS.ME n'a √©t√© ex√©cut√©.  Le mode avion a √©t√© activ√©, le Wi-Fi et le GPS ont √©t√© d√©sactiv√©s.  De plus, plusieurs mesures de contr√¥le ont √©t√© effectu√©es. <br><br>  En cons√©quence, pour chacun des indicateurs, une comparaison de Metal avec OpenGL a √©t√© form√©e, puis les ratios ont √©t√© moyenn√©s pour obtenir une estimation agr√©g√©e. <br><br><table><tbody><tr><th width="100"></th><th width="100">  Opengl </th><th width="100">  M√©tal </th><th width="100">  Gain </th></tr><tr><td>  Drain de batterie </td><td>  32% </td><td>  28% </td><td>  12,5% </td></tr><tr><td>  Profilage de l'utilisation de la batterie dans Xcode </td><td>  1,95% </td><td>  1,83% </td><td>  6,16% </td></tr></tbody></table><br><h4>  Analyse des r√©sultats </h4><br>  En moyenne, la consommation d'√©nergie de la version de rendu sur Apple Metal s'est l√©g√®rement am√©lior√©e.  La consommation d'√©nergie de notre application GPU n'est pas tr√®s affect√©e, environ 2%, car MAPS.ME ne peut pas √™tre qualifi√© de tr√®s charg√© en termes d'utilisation du GPU.  Un petit gain est probablement obtenu en r√©duisant les co√ªts de calcul lors de la pr√©paration d'instructions pour le GPU sur le CPU, qui, malheureusement, ne peuvent pas √™tre distingu√©s √† l'aide d'outils de profilage. <br><br><h2>  R√©sum√© </h2><br>  L'int√©gration du m√©tal nous a co√ªt√© 5 mois de d√©veloppement.  Cependant, deux d√©veloppeurs l'ont fait presque √† tour de r√¥le.  √âvidemment, nous avons gagn√© de mani√®re significative en performance de rendu, nous avons gagn√© un peu en consommation d'√©nergie.  De plus, nous avons eu l'occasion d'int√©grer de nouvelles API graphiques, en particulier Vulkan, avec beaucoup moins d'efforts.  Presque compl√®tement ¬´tri√©¬ª le moteur graphique, en cons√©quence, nous avons trouv√© et corrig√© plusieurs vieux bogues et probl√®mes de performances. <br><br>  √Ä la question de savoir si notre projet a vraiment besoin d'√™tre rendu sur Apple Metal, nous sommes pr√™ts √† r√©pondre par l'affirmative.  Ce n'est pas tant que nous aimons l'innovation, ou qu'Apple puisse enfin abandonner OpenGL.  Nous sommes juste en 2018, et OpenGL est apparu dans le lointain 1997, il est grand temps de passer √† l'√©tape suivante. <br><br>  <b>PS</b> Jusqu'√† ce que nous lancions la fonctionnalit√© sur tous les appareils iOS.  Pour l'activer manuellement, tapez <code>?metal</code> dans la barre de recherche et red√©marrez l'application.  Pour retourner le rendu √† OpenGL, entrez la commande <code>?gl</code> et red√©marrez l'application. <br><br>  <b>PPS</b> MAPS.ME est un projet open-source.  Vous pouvez lire le code source sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430850/">https://habr.com/ru/post/fr430850/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430838/index.html">Les merveilles du marketing de foule ou comment promouvoir une entreprise avec des avis</a></li>
<li><a href="../fr430840/index.html">Quelles preuves peuvent convaincre les math√©maticiens s'il n'y a pas de preuves rigoureuses?</a></li>
<li><a href="../fr430842/index.html">Nous utilisons la blockchain pour lutter contre la corruption et la cyberintimidation</a></li>
<li><a href="../fr430844/index.html">Comment choisir une batterie pour UPS</a></li>
<li><a href="../fr430846/index.html">Quoi de neuf: les d√©tails sur la mise en ≈ìuvre de la nouvelle architecture Zen 2 sont devenus connus</a></li>
<li><a href="../fr430852/index.html">Coh√©rence et garanties ACID dans les syst√®mes de stockage distribu√©s</a></li>
<li><a href="../fr430854/index.html">¬´JS devient plus mature¬ª: entretien avec le comit√© du programme HolyJS 2018 Moscou</a></li>
<li><a href="../fr430856/index.html">Toute la v√©rit√© sur RTOS. Article # 21. Bo√Ætes aux lettres: introduction et services de base</a></li>
<li><a href="../fr430860/index.html">T√©l√©chargez, enregistrez et visualisez le PDF dans Swift</a></li>
<li><a href="../fr430862/index.html">"Monstres dans les jeux - comment inciter un joueur √† vous d√©tester"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>