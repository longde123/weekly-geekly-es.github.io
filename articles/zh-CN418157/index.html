<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕗 🍔 🕜 该书“优雅的对象。 Java版» 🐡 😱 ➗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="嗨，habrozhiteli！ 本书认真修改了面向对象编程（OOP）的本质和原理，可以比喻为“ Lobachevsky OOP”。 拥有20年经验的开发人员Egor Bugaenko批判性地分析了OOP的教条，并提出以全新的方式研究这种范例。 因此，他认为静态方法，getter，setter和可变方...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>该书“优雅的对象。 Java版»</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/418157/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/w_/ty/kk/w_tykkzjrz7fxozztm-4tp4asci.jpeg" align="left" alt="图片"></a> 嗨，habrozhiteli！ 本书认真修改了面向对象编程（OOP）的本质和原理，可以比喻为“ Lobachevsky OOP”。 拥有20年经验的开发人员<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Egor Bugaenko</a>批判性地分析了OOP的教条，并提出以全新的方式研究这种范例。 因此，他认为静态方法，getter，setter和可变方法带有污名，并认为这是邪恶的。 对于新手程序员来说，这本书可能成为启迪或震惊，而对于经验丰富的程序员，这是必修课。 <br><br><h3> 摘录“不要使用静态方法” </h3><br> 啊，静态方法...我最喜欢的主题之一。 我花了几年时间才意识到这个问题的重要性。 现在，我一直后悔花了很多时间来编写程序性软件而不是面向对象软件。 我是盲人，但现在我已经看到了。 静态方法在OOP中的问题甚至比没有NULL常量大。 原则上，静态方法不应该使用Java和其他面向对象的语言编写，但是，they，它们在那里。 我们不应该知道Java中的static关键字之类的东西，但是，a，是强制的。.我不知道是谁将它们带到Java的，但是它们纯属邪恶..静态方法，不是此功能的作者。 我希望如此。 <br><a name="habracut"></a><br> 让我们看看什么是静态方法以及为什么仍要创建它们。 假设我需要通过HTTP请求加载网页的功能。 我创建了这样一个“类”： <br><br><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WebPage</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">String uri</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  HTTP- //     UTF8- } }</span></span></code> </pre> <br> 使用它非常方便： <br><br><pre> <code class="hljs pgsql">String html = WebPage.<span class="hljs-keyword"><span class="hljs-keyword">read</span></span>("http://www.java.com");</code> </pre> <br>  read（）方法属于我反对的方法类。 我建议改为使用一个对象（我还根据2.4节的建议更改了方法名称）： <br><br><pre> <code class="hljs java"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WebPage</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String uri; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">content</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  HTTP- //     UTF8- } }</span></span></code> </pre> <br> 使用方法如下： <br><br><pre> <code class="hljs vbscript"><span class="hljs-built_in"><span class="hljs-built_in">String</span></span> html = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebPage(<span class="hljs-string"><span class="hljs-string">"http://www.java.com"</span></span>) .content();</code> </pre> <br> 您可以说它们之间没有太大区别。 静态方法的工作速度更快，因为我们不需要每次下载网页时都创建一个新对象。 只需调用static方法，它将完成工作，您将获得结果并将继续工作..无需弄乱对象和垃圾收集器。 另外，我们可以将几个静态方法分组到一个实用程序类中，并命名为WebUtils。 <br><br> 这些方法将有助于加载网页，获取统计信息，确定响应时间等。其中将包含许多方法，并且使用它们既简单又直观。 另外，如何应用静态方法也是很直观的。 每个人都了解他们的工作方式。 只需编写WebPage.read（），然后-您猜对了！  -页面将被读取。 我们给了计算机指令，然后它执行了..简单明了，对吧？ 不！ <br><br> 在任何情况下，静态方法都可以清楚地表明一个糟糕的程序员根本不了解OOP。 在任何情况下都没有理由采用静态方法。 关心性能并不重要。 静态方法是对面向对象范例的嘲弄。 它们以Java，Ruby，C ++，PHP和其他语言存在。 不幸的是 我们不能扔掉它们，也不能重写所有包含静态方法的开源库，但是我们可以停止在代码中使用它们。 <br><br> 我们必须停止使用静态方法。 <br><br> 现在，让我们从几个不同的角度来看它们，并讨论它们的实际缺点。 我可以提前将它们概括给您：静态方法会降低软件的可维护性。 这不应该让您感到惊讶。 一切都归结为可维护性。 <br><br><h3> 目标与计算机思维 </h3><br> 最初，我将此部分称为“目标与过程思维”，但后来将其重命名。  “过程思维”的含义几乎相同，但是“像计算机一样思考”一词更能说明问题。.我们从汇编，C，COBOL，Basic，Pascal等早期编程语言继承了这种思维方式。 范例的基础是计算机为我们工作，我们告诉他该怎么做，并给他明确的指示，例如： <br><br><pre> <code class="hljs cmake"> CMP AX, BX JNAE <span class="hljs-keyword"><span class="hljs-keyword">greater</span></span> MOV CX, BX RET <span class="hljs-keyword"><span class="hljs-keyword">greater</span></span>: MOV CX, AX RET</code> </pre> <br> 这是Intel 8086处理器的汇编程序“例程”，它查找并返回两个数字中较大的一个。 我们将它们分别放入寄存器AX和BX中，结果落入寄存器CX中。 这是完全相同的C代码： <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; }</code> </pre> <br>  “这怎么了？”  -你问。 没什么..这个代码一切都很好-它可以正常工作，这就是所有计算机的工作方式。 他们希望我们给他们指示，他们将一个接一个地跟随。。多年来，我们以这种方式编写程序。 这种方法的优点是我们保持靠近处理器的方向，以指导其进一步移动。 我们掌控一切，计算机将按照我们的指示进行操作。 我们告诉计算机如何找到两个较大的数字。 我们做出决定，他跟随他们。 从脚本的开始到结束，执行流程始终是一致的。 <br><br> 这种线性思维方式称为“像计算机一样思考”。 计算机有时会开始执行指令，有时会完成指令。 用C编写代码时，我们不得不这样思考。 以分号分隔的运算符从上到下。 此样式是从汇编程序继承的。 <br> 尽管比汇编程序更高级的语言具有过程，子例程和其他抽象机制，但它们并不能消除一致的思维方式，程序仍从上到下运行。 编写小型程序时，这种方法没有什么问题，但是在更大范围内，很难像这样想。 <br><br> 看一下用功能编程语言Lisp编写的相同代码： <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defun</span></span> max (<span class="hljs-name"><span class="hljs-name">ab</span></span>) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> ab) ab))</code> </pre> <br> 您能说出这段代码的执行开始和结束的地方吗？ 不行 我们不知道处理器将如何获得结果，或者if函数将如何工作。 我们离处理器很远。 我们认为它是功能，而不是计算机。 当我们需要新事物时，我们对其进行定义： <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">def</span></span> x (<span class="hljs-name"><span class="hljs-name">max</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>))</code> </pre> <br> 我们定义而不是给处理器指令。 通过这一行，我们将x绑定到（最大5 9）。 我们不要求计算机计算两个数字中的较大者。 我们简单地说x是两个数字中的较大者。 我们不控制如何以及何时计算它。 请注意，这很重要：x是较大的数字。 关系“是”（“待”，“待”）是功能，逻辑和面向对象的编程范例与过程范例之间的区别。 <br><br> 凭着计算机的思维定势，我们掌控着指令流。 使用面向对象的思维方式，我们只需确定谁是谁，并让他们在需要时进行交互即可。 这是在OOP中计算两个数字中较大的一个的样子： <br><br><pre> <code class="hljs java"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Max</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Number</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Number a; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Number b; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Number left, Number right)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a = left; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b = right; } }</code> </pre> <br> 因此，我将使用它： <br><br><pre> <code class="hljs pgsql">Number x = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Max(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>);</code> </pre> <br> 看，我不是在计算两个数字中的较大者。 我确定x是两个数字中的较大者。 我并不真正担心Max类对象中的内容以及它如何实现Number接口。 我不给处理器有关此计算的说明。 我只是实例化对象。 这与Lisp中的def非常相似。从这个意义上说，OOP与函数编程非常相似。 <br><br> 相反，OOP中的静态方法与C或汇编器中的子例程相同。 它们与OOP不相关，因此迫使我们以面向对象的语法编写过程代码。 这是Java代码： <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> x = Math.max(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>);</code> </pre> <br> 这是完全错误的，不应在实际的面向对象设计中使用。 <br><br><h3> 声明式与命令式 </h3><br> 命令式编程“用改变程序状态的运算符来描述计算”。另一方面，声明式编程“在不描述其执行流程的情况下表达了计算逻辑”（我引用维基百科）。 实际上，我们在前几页中都谈到了这一点。 命令式编程与计算机的操作类似-顺序执行指令。 声明式编程更接近自然思维方式，在这种思维方式中我们拥有实体和实体之间的关系。 显然，声明性编程是一种更强大的方法，但是命令性方法对于过程程序员更易于理解。 为什么声明式方法更强大？ 不要切换，几页之后我们就到了重点。 <br><br> 这与静态方法有什么关系？ 不管它是静态方法还是对象，我们都必须在某个地方写（a&gt; b），对吗？ 是的，完全正确。 静态方法和对象都只是if语句的包装，该语句执行将a与b比较的任务。 区别在于其他类，对象和方法如何使用此功能。 这是一个很大的区别。 考虑一个例子。 <br> 说我有一个间隔，该间隔限制为两个整数，一个应该落入其中的整数..我必须确保它是。 如果max（）方法是静态的，这就是我要做的事情： <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">between</span></span>(<span class="hljs-type"><span class="hljs-type">int</span></span> l, <span class="hljs-type"><span class="hljs-type">int</span></span> r, <span class="hljs-type"><span class="hljs-type">int</span></span> x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Math.min(Math.max(l, x), r); }</code> </pre> <br> 我们需要在（）之间创建另一个静态方法，该方法使用两个可用的静态方法Math.min（）和Math.max（）。 只有一种方法可以执行此操作-命令式方法，因为该值会立即计算出来。 拨打电话时，我立即得到结果： <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = Math.between(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  9</span></span></code> </pre> <br> 在（）之间调用后，我得到了数字9。 拨打电话后，我的处理器将立即开始进行此计算。 这是当务之急。 然后，声明式方法是什么样的？ <br><br> 在这里，看看： <br><br><pre> <code class="hljs java"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Between</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Number</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Number num; Between(Number left, Number right, Number x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.num = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Min(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Max(left, x), right); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">intValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.num.intValue(); } }</code> </pre> <br> 这就是我将如何使用它： <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Number</span></span> y = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Between(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   !</span></span></code> </pre> <br> 感觉有所不同？ 她非常重要。 这种风格是声明性的，因为我没有告诉处理器需要立即进行计算。 我只是确定了它的含义，然后由用户决定何时（以及是否有必要）使用intValue（）方法来计算变量y。 也许永远也不会计算出来，我的处理器永远也不会知道数字是9 ..我所做的只是声明y是什么。 刚刚宣布。 我还没有给处理器做任何工作。 如定义中所示，表达的逻辑未描述过程。 <br><br> 我已经听到：“好，我了解你。 有两种方法-声明式和过程式，但是为什么第一种优于第二种？” 前面我提到过，显然声明式方法更强大，但没有解释原因。 现在我们已经通过示例研究了这两种方法，我们将讨论声明式方法的优点。 <br><br> 首先，它更快。 乍一看，它似乎较慢。 但是，如果您仔细看一看，就会发现实际上它更快，因为性能的优化完全掌握在我们手中。 确实，至少在编写本书时可用的大多数编程语言中，创建Between类的实例比调用static between（）方法要花费更长的时间。我真的希望我们在不久的将来拥有一种语言在其中实例化对象将与调用方法一样快。 但是我们还没有来找他。 这就是为什么当执行路径简单明了时声明式方法较慢的原因。 <br><br> 如果我们在谈论对静态方法的简单调用，那么它肯定比创建对象的实例并调用其方法要快。 但是，如果我们有许多静态方法，那么在解决问题时将依次调用它们，而不仅仅是处理我们真正需要的结果。 怎么样： <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> doIt() { <span class="hljs-type"><span class="hljs-type">int</span></span> x = Math.<span class="hljs-keyword"><span class="hljs-keyword">between</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-comment"><span class="hljs-comment">/*  ? */</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span>.println("x=" + x); } }</code> </pre> <br> 在此示例中，无论是否需要它的值，我们都将计算x。在两种情况下，处理器都会找到值9.使用声明性方法的下一个方法是否能像上一个方法一样快地工作？ <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> doIt() { <span class="hljs-type"><span class="hljs-type">Integer</span></span> x = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Between</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-comment"><span class="hljs-comment">/*  ? */</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span>.println("x=" + x); } }</code> </pre> <br> 我认为声明性代码会更快。 最好进行优化。 它并没有告诉处理器该怎么做，相反，它允许处理器确定真正需要何时何地需要结果-计算是按需执行的。 <br><br> 底线是声明式方法更快，因为它是最佳方法。 与面向对象编程中的命令式相比，这是支持声明式方法的第一个论点。 命令式样式在OOP中绝对不占地方，并且第一个原因是性能优化..您不应该说控制代码的优化越多，遵循的就越多。 我们自己做，而不是将计算过程的优化留给编译器，虚拟机或处理器。 <br><br> 第二个论点是多态性。 简而言之，多态性是打破代码块之间的依赖关系的能力。 假设我想更改确定数字是否落入特定间隔的算法。 它本身很原始，但是我想更改它。 我不想使用Max和Min类。 我希望他使用if-then-else语句进行比较。.这是声明式执行的方法： <br><br><pre> <code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Between</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Number</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Number num; Between(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> left, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> right, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Min(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Max(left, x), right)); } Between(Number number) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.num = number; } }</code> </pre> <br> 这与上一个示例中的Between类相同，但是具有一个附加的构造函数。 现在，我可以将其与另一种算法一起使用： <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">Integer</span></span> x = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Between</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> IntegerWithMyOwnAlgorithm(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>) );</code> </pre> <br> 这可能不是最好的示例，因为Between类非常原始，但是我希望您理解我的意思。  Between类很容易与Max和Min类分开，因为它们是类。 在面向对象的编程中，对象是完全公民，但静态方法不是。 我们可以将对象作为参数传递给构造函数，但是我们不能对static方法执行相同的操作。 在OOP中，对象与对象关联，与对象通信并与它们交换数据。 为了将一个对象与其他对象完全分离，我们必须确保该对象在其任何方法（请参见第3.6节）以及主构造函数中均不使用new运算符。 <br><br> 让我重复一遍：要完全将一个对象与其他对象分离，只需确保new运算符的任何方法（包括主构造函数）都未使用new运算符。 <br><br> 您可以使用命令性代码片段进行相同的解耦和重构吗？ <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> y = Math.<span class="hljs-keyword"><span class="hljs-keyword">between</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>);</code> </pre> <br> 不，你不能。 静态之间（）方法使用两种静态方法，即min（）和max（），在完全重写之前，您将无法做任何事情。 以及如何重写它？ 将第四个参数传递给新的静态方法？ <br><br> 它看起来有多丑？ 我觉得很好 <br><br> 这是我支持声明式编程风格的第二个论点-它减少了对象的内聚力并使它非常优雅。.更不用说内聚力越少意味着可维护性越强的事实。 <br><br> 主张声明式方法优于命令式的第三个论点-声明式方法说明了结果，而命令式说明了获得结果的唯一方法。 第二种方法远没有第一种方法直观。 我必须首先“执行”脑海中的代码，以了解预期的结果。 这是一种必要的方法： <br><br><pre> <code class="hljs pgsql">Collection&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; evens = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> LinkedList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> number : numbers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (number % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) { evens.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(number); } }</code> </pre> <br> 要了解这段代码的作用，我必须仔细阅读一下，可视化此循环。.实际上，我必须执行处理器的作用-遍历整个数字数组并将偶数放入新列表中。 这是相同的算法，以声明性风格编写： <br><br><pre> <code class="hljs pgsql">Collection&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; evens = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Filtered( numbers, <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Predicate&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt;() { @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">boolean</span></span> suitable(<span class="hljs-type"><span class="hljs-type">Integer</span></span> number) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> number % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>; } } );</code> </pre> <br> 这一段代码比上一段代码更接近英语。 它的内容如下：“ evens是一个过滤的集合，仅包含那些偶数元素。” 我不知道Filtered类如何创建集合-它使用for语句还是其他。 在阅读此代码时，我只需要知道该集合已被过滤即可。 隐藏实现细节，并表示行为。 <br><br> 我意识到，对于本书的某些读者来说，理解第一个片段会更容易..它更短一些，并且与您每天在处理的代码中看到的非常相似。 我向您保证，这是一个习惯问题。 这是一种欺骗性的感觉。 从对象及其行为而不是算法及其执行开始思考，您将获得真正的认知。 声明式样式直接与对象及其行为有关，而命令式则与算法及其执行直接有关。 <br><br> 如果您发现此代码很丑陋，请尝试使用Groovy，例如： <br><br><pre> <code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evens</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Filtered</span></span>( numbers, { <span class="hljs-type"><span class="hljs-type">Integer</span></span> number -&gt; number % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> } );</code> </pre> <br> 第四个参数是代码完整性。 再看一下前两个片段。 请注意，在第二个片段中，我们将evens声明为一个运算符-evens = Filtered（...）。 这意味着负责计算此集合的所有代码行都彼此相邻，并且不能错误地分开。 相反，在第一个片段中没有明显的“胶合”线。 您可以轻松地错误地更改其顺序，并且算法会中断。 <br><br> 在这样简单的代码中，这是一个小问题，因为算法很明显。 但是，如果命令性代码的片段较大（例如50行），则可能很难理解哪些代码行彼此相关..我们在不可变对象的讨论中较早地讨论了时间级联的问题。.声明式编程风格也有助于消除这种级联，因此可维护性得到改善。 <br><br> 可能仍然有争论，但是从我的角度来看，我引用了与OOP相关的最重要的观点。 我希望我能够说服您声明式的样式是您所需要的。 你们中有些人可能会说：“是的，我理解您的意思。 在适当的时候，我将结合声明式和命令式方法。 当我需要快速地做一些简单的事情时（例如计算两个数字中的较大者），我将使用有意义的对象和静态方法。“ ..”不，你错了！“  -我会回答你的。 您不得将它们组合在一起。.切勿使用命令式样式。 这不是教条..这有一个非常务实的解释。 <br><br> 命令式不能与纯粹的声明式技术结合使用。      ,   —      . <br><br> ,       — max()  min().     ,     .      ,  ,    ..         —   Between,     between().     ? , ,   ,   ,  .       .    ,        Between.  ,      - ,        . <br><br>      - :      ,       —     .      . <br><br> «    ! —  . —   ?»    …   ,     .   - ,     - (     ). ,    ,   — .    ,     ..           ,         .    ,    , —  ,   ,     ,       .  ,   Apache Commons    FileUtils.readLines(),       .        : <br><br><pre> <code class="hljs java"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileLines</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> File file; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Iterator&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Arrays.asList( FileUtils.readLines(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.file) ).iterator(); } }</code> </pre> <br> ,       ,      : <br><br><pre> <code class="hljs lisp">Iterable&lt;String&gt; lines = new FileLines(<span class="hljs-name"><span class="hljs-name">f</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>        FileLines,        .     .    ,          ,     —  FileLines.    ,       . <br><br><h3> - </h3><br>   -      ,     ,      (    -)..  ,  java.lang.Math —   -.      Java, Ruby ,  ,      .     ?       .   1.1           ,   —   . -   , : <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Math { private Math() { //   } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">int</span></span> max(<span class="hljs-type"><span class="hljs-type">int</span></span> a, <span class="hljs-type"><span class="hljs-type">int</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &lt; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } }</code> </pre> <br>    ,   -,    ,   ,     .   , ,   ,     . <br><br> - —      - . - —        —    .   ,    ,      . - —    ..    . <br><br><h3>  «» </h3><br>  «» —  ,   ,     . ,       ,          .     : <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Math</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Math INSTANCE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Math(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Math</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Math </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInstance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Math.INSTANCE; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &lt; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } }</code> </pre> <br>     .     Math,   INSTANCE..      ,   getInstance().   ,       .      INSTANCE —  getInstance(). <br><br> «»    ,      .    ,     .      ,   .  , , ,      ,     -,      .     - Math,    ,     : <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Math</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Math</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &lt; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } }</code> </pre> <br>      max(): <br><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">Math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); <span class="hljs-comment"><span class="hljs-comment">// - Math.getInstance().max(5, 9); // </span></span></code> </pre> <br>   ? ,     ,     .    ,         -?         Java-. ,      : «   ». 例如： <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">User</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> User INSTANCE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> User </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInstance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User.INSTANCE; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">String txt</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = txt; } }</code> </pre> <br>    ,           .     «,     ».       -,    , -  . .. ,           -: «  »..    .      ..  -,    ,     : <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">User</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User.name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">String txt</span></span></span><span class="hljs-function">)</span></span> { User.name = txt; } }</code> </pre> <br>  -  ,         . ,    ?     ?      ,   —  ,   ,  - —    ,   .  ,    ,       setInstance()   getInstance().   ,     . ,     : <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Math</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.getInstance</span></span>()<span class="hljs-selector-class"><span class="hljs-selector-class">.max</span></span>(5, 9);</code> </pre> <br>      Math.  ,  Math — ,    .       ,         Math ,     .         ,    .    ,  , ,       -,     .  ,   ,   Math.max()     -.    ?   : <br><br><pre> <code class="hljs cmake"><span class="hljs-keyword"><span class="hljs-keyword">Math</span></span> <span class="hljs-keyword"><span class="hljs-keyword">math</span></span> = new FakeMath(); <span class="hljs-keyword"><span class="hljs-keyword">Math</span></span>.setInstance(<span class="hljs-keyword"><span class="hljs-keyword">math</span></span>);</code> </pre> <br>  «»      ,    .   :    -  ,     .  -   —     . - —     —    . <br><br> ,   ?   -,     ,   . 怎么了 ,      —  ,  ,  ..       .      .    ,        : <br><br><pre> <code class="hljs mel">#include &lt;stdio&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> line = <span class="hljs-number"><span class="hljs-number">0</span></span>; void echo(char* <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>) { printf(<span class="hljs-string"><span class="hljs-string">"[%d] %s\n"</span></span>, ++line, <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>); }</code> </pre> <br>      echo(),    line.    line          *.-..   .   Java  ,         .  Java,    Ruby     --,   . 怎么了         .    .      .   . ,         .   ,      ,    GOTO. <br><br> ,       , -      Java,     «»..      - ,      .      . <br>    .   . <br><br> «  ? —  . —   ,           ,    ?» ,   ,      ,        .    -  .    ? ! <br><br>      ,     . <br><br> ,      ,         ..   .  .     ,    .   ,     :    ,    ,     . . , ,      ,       .      ,   —  ,      2.1. <br><br>     .     . <br><br><h3>   </h3><br>     :            ,        ()? ,    ,     ,      .. ,    ?      Lisp, Clojure  Haskell  Java  C++? <br><br>  ,       : <br><br><pre> <code class="hljs java"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Max</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Number</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a = left; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b = right; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">intValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a &gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b ? <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b; } }</code> </pre> <br>      : <br><br><pre> <code class="hljs pgsql">Number x = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Max(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>);</code> </pre> <br>        Lisp ,      : <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defn</span></span> max (<span class="hljs-name"><span class="hljs-name">ab</span></span>) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> ab) ab))</code> </pre> <br> ,    ?   Lisp  . <br><br>       ,     ,    —  .   -   ,      -  -,   .   ,  -  Java,     ,  Java  ,     -.  —  ,   .    . <br><br>  ,   -        .  -,    Java,   (   ) ,    .    . <br><br><h3>   </h3><br> ,    .   —  -   .    —   - , —   ,       ,  : <br><br><pre> <code class="hljs lisp">names = new Sorted( <span class="hljs-name"><span class="hljs-name">new</span></span> Unique( <span class="hljs-name"><span class="hljs-name">new</span></span> Capitalized( <span class="hljs-name"><span class="hljs-name">new</span></span> Replaced( <span class="hljs-name"><span class="hljs-name">new</span></span> FileNames( <span class="hljs-name"><span class="hljs-name">new</span></span> Directory( <span class="hljs-string"><span class="hljs-string">"/var/users/*.xml"</span></span> ) ), <span class="hljs-string"><span class="hljs-string">"([^.]+)\\.xml"</span></span>, <span class="hljs-string"><span class="hljs-string">"$1"</span></span> ) ) ) )<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  ,    ,     -.   ,     3.2.    ,     names,        ,     ,    .   ,    ,      ,   .    . <br><br>          ? ,  ,    ,       . <br><br>  ,     .  Directory, FileNames, Replaced, Capitalized, Unique  Sorted — ,        .      .       . <br><br>      ,      (   ).  , Unique —  Iterable,     .  FileNames —    ,    . <br>      -       .       ,     ..  -    app.run(),      .          if, for, switch  while.   ,    . <br><br>  if   Java      ,   .       Java ,      If?     : <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">float</span></span> rate; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (client.age() &gt; <span class="hljs-number"><span class="hljs-number">65</span></span>){ <span class="hljs-attribute"><span class="hljs-attribute">rate</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>; } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">rate</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>     - : <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> rate = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">If</span></span>( client.age() &gt; <span class="hljs-number"><span class="hljs-number">65</span></span>, <span class="hljs-number"><span class="hljs-number">2.5</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span> );</code> </pre> <br>    ? <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> rate = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">If</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Greater(client.age(), <span class="hljs-number"><span class="hljs-number">65</span></span>), <span class="hljs-number"><span class="hljs-number">2.5</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span> );</code> </pre> <br>  ,  : <br><br><pre> <code class="hljs lisp">float rate = new If( <span class="hljs-name"><span class="hljs-name">new</span></span> GreaterThan( <span class="hljs-name"><span class="hljs-name">new</span></span> AgeOf(<span class="hljs-name"><span class="hljs-name">client</span></span>), <span class="hljs-number"><span class="hljs-number">65</span></span> ), <span class="hljs-number"><span class="hljs-number">2.5</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span> )<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>    -   .     —  ,   rate. <br><br>    ,      ,      .   if, for, switch  while.    If, For, Switch  While.  ? <br><br>       ,      .    .            .   ,    .. ,            . <br>   ,  -  —       . <br><br>       ?  ,   :        .     ,        .             .     .      ,    —  . <br><br>  :           static —      ,     ,  . <br><br>  »这本书的更多信息可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在出版商的网站上找到</a> <br><br>    20%   — <b>Java</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN418157/">https://habr.com/ru/post/zh-CN418157/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN418145/index.html">当Telegram被封锁时，公司遭受的第一起针对Roskomnadzor的诉讼</a></li>
<li><a href="../zh-CN418147/index.html">沉默的Ruby执行：事务性Rails / PostgreSQL惊悚片</a></li>
<li><a href="../zh-CN418151/index.html">介绍识别情绪的任务</a></li>
<li><a href="../zh-CN418153/index.html">Kolesa Android Meetup视频：关于MVVM，反模式和模块化开发</a></li>
<li><a href="../zh-CN418155/index.html">二极体 发光二极管 齐纳二极管</a></li>
<li><a href="../zh-CN418159/index.html">设计师去哪儿：俄罗斯，东欧和独联体国家的著名奖项</a></li>
<li><a href="../zh-CN418161/index.html">在斯坦福大学，开发了室温流电池</a></li>
<li><a href="../zh-CN418163/index.html">生产测试：Netflix Chaos自动化平台</a></li>
<li><a href="../zh-CN418165/index.html">Quasar，Sobaken和Vermin：揭示正在进行的网络间谍活动的细节</a></li>
<li><a href="../zh-CN418167/index.html">ScadaPy：添加IEC 60870-5-104协议</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>