<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💢 ⬛️ 🌔 Detail dinamis: game kompiler rahasia, kebocoran memori, nuansa kinerja 💆 🧚🏽 🧙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreplay 

 Pertimbangkan kode berikut: 



//Any native COM object var comType = Type.GetTypeFromCLSID(new Guid("E13B6688-3F39-11D0-96F6-00A0C9191601...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Detail dinamis: game kompiler rahasia, kebocoran memori, nuansa kinerja</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466657/"><h2>  Foreplay </h2><br><br>  Pertimbangkan kode berikut: <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Any native COM object var comType = Type.GetTypeFromCLSID(new Guid("E13B6688-3F39-11D0-96F6-00A0C9191601")); while (true) { dynamic com = Activator.CreateInstance(comType); //do some work Marshal.FinalReleaseComObject(com); }</span></span></code> </pre> <br><br>  Tanda tangan metode <i>Marshal.FinalReleaseComObject</i> adalah sebagai berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FinalReleaseComObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Object o</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br><br>  Kami membuat objek COM sederhana, melakukan beberapa pekerjaan, dan segera melepaskannya.  Tampaknya apa yang salah?  Ya, membuat objek di dalam infinite loop bukanlah praktik yang baik, tetapi <i>GC</i> akan mengambil semua pekerjaan kotor.  Kenyataannya sedikit berbeda: <br><br><img src="https://habrastorage.org/webt/mt/xo/rx/mtxorxomorvksyskqgtn3b3z7_g.png"><br><br>  Untuk memahami mengapa memori bocor, Anda perlu memahami cara kerja <i>dinamis</i> .  Sudah ada beberapa artikel tentang hal ini di Habré, misalnya yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> , tetapi mereka tidak membahas detail implementasi, jadi kami akan melakukan penelitian kami sendiri. <br><br><a name="habracut"></a><br><br>  Pertama, kita akan memeriksa secara rinci mekanisme kerja yang <i>dinamis</i> , kemudian kita akan mengurangi pengetahuan yang diperoleh menjadi satu gambar dan pada akhirnya kita akan membahas alasan kebocoran ini dan bagaimana cara menghindarinya.  Sebelum masuk ke dalam kode, mari kita perjelas data sumber: kombinasi faktor apa yang menyebabkan kebocoran? <br><br><h2>  Eksperimennya </h2><br><br>  Mungkin membuat banyak objek <i>COM asli</i> adalah ide yang buruk?  Mari kita periksa: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Any native COM object var comType = Type.GetTypeFromCLSID(new Guid("E13B6688-3F39-11D0-96F6-00A0C9191601")); while (true) { dynamic com = Activator.CreateInstance(comType); }</span></span></code> </pre> <br><br>  Semuanya baik saat ini: <br><br><img src="https://habrastorage.org/webt/l2/x4/01/l2x401f_4vsbrysnx1zctwoyfjk.png"><br><br>  Mari kembali ke versi asli kode, tetapi ubah jenis objek: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Any managed type include managed COM var type = typeof(int); while (true) { dynamic com = Activator.CreateInstance(type); //do some work Marshal.FinalReleaseComObject(com); }</span></span></code> </pre> <br><br>  Dan lagi, tidak ada kejutan: <br><br><img src="https://habrastorage.org/webt/09/lm/bv/09lmbvpiklt9lo43b1fv9wzhdhu.png"><br><br>  Mari kita coba opsi ketiga: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Simple COM object var comType = Type.GetTypeFromCLSID(new Guid("435356F9-F33F-403D-B475-1E4AB512FF95")); while (true) { dynamic com = Activator.CreateInstance(comType); //do some work Marshal.FinalReleaseComObject((object) com); }</span></span></code> </pre> <br><br>  Nah sekarang, kita pasti harus mendapatkan perilaku yang sama!  Hah?  Tidak :( <br><br><img src="https://habrastorage.org/webt/uu/2p/l1/uu2pl1_xtrmpc4kuuy3mwdh_7la.png"><br><br>  Gambaran serupa akan terjadi jika Anda mendeklarasikan com sebagai <i>objek</i> atau jika Anda bekerja dengan <i>COM Managed</i> .  Ringkas hasil eksperimen: <br><br><ol><li>  Membuat <i>instance</i> objek <i>COM asli</i> dengan sendirinya tidak menyebabkan kebocoran - <i>GC</i> berhasil mengatasi dengan membersihkan memori </li><li>  Saat bekerja dengan kelas <i>Managed</i> apa pun, kebocoran tidak terjadi </li><li>  Ketika secara eksplisit melemparkan objek ke <i>objek</i> , semuanya juga baik-baik saja </li></ol><br><br>  Ke depan, ke poin pertama kita dapat menambahkan fakta bahwa bekerja dengan objek <i>dinamis</i> (memanggil metode atau bekerja dengan properti) dengan sendirinya juga tidak menyebabkan kebocoran.  Kesimpulannya menunjukkan sendiri: kebocoran memori terjadi ketika kita melewati objek <i>dinamis</i> (tanpa konversi tipe "manual") yang mengandung <i>COM asli</i> , sebagai parameter metode. <br><br><h2>  Kita harus masuk lebih dalam </h2><br><br>  Saatnya untuk mengingat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">apa arti</a> <i>dinamika</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> : <br><br><div class="spoiler">  <b class="spoiler_title">Referensi cepat</b> <div class="spoiler_text"><blockquote>  C # 4.0 menyediakan tipe <b>dinamis baru</b> .  Tipe ini menghindari pengecekan tipe statis oleh kompiler.  Dalam kebanyakan kasus, ini berfungsi sebagai tipe <b>objek</b> .  Pada waktu kompilasi, diasumsikan bahwa elemen yang dinyatakan <b>dinamis</b> mendukung operasi apa pun.  Ini berarti Anda tidak perlu memikirkan dari mana objek itu berasal - dari COM API, bahasa dinamis seperti IronPython, menggunakan refleksi, atau dari tempat lain.  Selain itu, jika kode tidak valid, kesalahan akan dilempar ke dalam runtime. <br><br>  Sebagai contoh, jika metode <b>exampleMethod1</b> dalam kode berikut memiliki tepat satu parameter, kompiler mengakui bahwa panggilan pertama ke metode <b>ec.exampleMethod1 (10, 4)</b> tidak valid karena mengandung dua parameter.  Ini akan menghasilkan kesalahan kompilasi.  Pemanggilan metode kedua, <b>dynamic_ec.exampleMethod1 (10, 4)</b> tidak diperiksa oleh kompiler, karena <b>dynamic_ec</b> dinyatakan <b>dinamis</b> , oleh karena itu.  tidak akan ada kesalahan kompilasi.  Namun demikian, kesalahan tidak akan luput dari perhatian selamanya - itu akan terdeteksi di runtime. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { ExampleClass ec = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExampleClass(); <span class="hljs-comment"><span class="hljs-comment">//      ,  exampleMethod1    . //ec.exampleMethod1(10, 4); dynamic dynamic_ec = new ExampleClass(); //      ,  //      dynamic_ec.exampleMethod1(10, 4); //        ,  //  ,      dynamic_ec.someMethod("some argument", 7, null); dynamic_ec.nonexistentMethod(); }</span></span></code> </pre> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExampleClass</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExampleClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExampleClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exampleMethod1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exampleMethod2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> str</span></span></span><span class="hljs-function">)</span></span> { } }</code> </pre> <br></blockquote><br></div></div><br><br>  Kode yang menggunakan variabel <i>dinamis</i> mengalami perubahan signifikan selama kompilasi.  Kode ini: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> com = Activator.CreateInstance(comType); Marshal.FinalReleaseComObject(com);</code> </pre> <br><br>  Berubah menjadi sebagai berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> instance = Activator.CreateInstance(typeFromClsid); <span class="hljs-comment"><span class="hljs-comment">// ISSUE: reference to a compiler-generated field if (Foo.o__0.p__0 == null) { // ISSUE: reference to a compiler-generated field Foo.o__0.p__0 = CallSite&lt;Action&lt;CallSite, Type, object&gt;&gt;.Create(Binder.InvokeMember(CSharpBinderFlags.ResultDiscarded, "FinalReleaseComObject", (IEnumerable&lt;Type&gt;) null, typeof (Foo), (IEnumerable&lt;CSharpArgumentInfo&gt;) new CSharpArgumentInfo[2] { CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.IsStaticType, (string) null), CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (string) null) })); } // ISSUE: reference to a compiler-generated field // ISSUE: reference to a compiler-generated field Foo.o__0.p__0.Target((CallSite) Foo.o__0.p__0, typeof (Marshal), instance);</span></span></code> </pre> <br><br>  Di mana <b>o__0</b> adalah kelas statis yang dihasilkan, dan <b>p__0</b> adalah bidang statis di dalamnya: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">o__0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> CallSite&lt;Action&lt;CallSite, Type, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;&gt; p__0; }</code> </pre> <br><br>  <i>Catatan: untuk setiap interaksi dengan <i>dinamis</i> , bidang CallSite dibuat.</i>  <i>Ini, seperti yang akan dilihat nanti, diperlukan untuk mengoptimalkan kinerja.</i> <br><br>  Perhatikan bahwa tidak ada lagi <i>dinamika</i> yang tersisa - objek kita sekarang disimpan dalam variabel tipe <i>objek</i> .  Mari kita telusuri kode yang dihasilkan.  Pertama, sebuah ikatan dibuat, yang menggambarkan apa dan apa yang kita lakukan: <br><br><pre> <code class="cs hljs">Binder.InvokeMember(CSharpBinderFlags.ResultDiscarded, <span class="hljs-string"><span class="hljs-string">"FinalReleaseComObject"</span></span>, (IEnumerable&lt;Type&gt;) <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (Foo), (IEnumerable&lt;CSharpArgumentInfo&gt;) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CSharpArgumentInfo[<span class="hljs-number"><span class="hljs-number">2</span></span>] { CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.IsStaticType, (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-literal"><span class="hljs-literal">null</span></span>), CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-literal"><span class="hljs-literal">null</span></span>) })</code> </pre> <br><br>  Ini adalah deskripsi operasi dinamis kami.  Biarkan saya mengingatkan Anda bahwa kami melewati variabel <i>dinamis</i> ke metode <i>FinalReleaseComObject</i> . <br><br><ul><li>  CSharpBinderFlags.ResultDiscarded - hasil dari eksekusi metode tidak digunakan di masa depan </li><li>  "FinalReleaseComObject" - nama metode yang disebut </li><li>  typeof (Foo) - konteks operasi;  jenis panggilan </li></ul><br><br>  <b>CSharpArgumentInfo</b> - deskripsi parameter yang mengikat.  Dalam kasus kami: <br><br><ul><li>  CSharpArgumentInfo.Create (CSharpArgumentInfoFlags.GunakanCompileTimeType | CSharpArgumentInfoFlags.IsStaticType, (string) null) - deskripsi parameter pertama - kelas Marshal: statis dan jenisnya harus dipertimbangkan saat mengikat </li><li>  CSharpArgumentInfo.Create (CSharpArgumentInfoFlags.None, (string) null) - deskripsi parameter metode, biasanya tidak ada informasi tambahan. </li></ul><br><br>  Jika itu bukan masalah memanggil metode, tetapi, misalnya, memanggil properti dari objek <i>dinamis</i> , maka hanya akan ada satu <b>CSharpArgumentInfo</b> yang menggambarkan objek <i>dinamis</i> itu sendiri. <br><br>  <b>CallSite</b> adalah pembungkus ekspresi dinamis.  Ini berisi dua bidang penting bagi kami: <br><br><ul><li>  T publik </li><li>  Target T publik </li></ul><br><br>  Dari kode yang dihasilkan, jelas bahwa ketika operasi apa pun dilakukan, <b>Target</b> dipanggil dengan parameter yang menggambarkannya: <br><br><pre> <code class="cs hljs">Foo.o__0.p__0.Target((CallSite) Foo.o__0.p__0, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (Marshal), instance);</code> </pre> <br><br>  Sehubungan dengan <b>CSharpArgumentInfo yang</b> dijelaskan di atas <b>,</b> kode ini berarti yang berikut: Anda perlu memanggil metode FinalReleaseComObject pada kelas Marshal statis dengan parameter instance.  Pada saat panggilan pertama, delegasi yang sama disimpan di <b>Target</b> seperti dalam <b>Pembaruan</b> .  Delegasi <b>Pembaruan</b> bertanggung jawab atas dua tugas penting: <br><br><ol><li>  Mengikat operasi dinamis ke operasi statis (mekanisme pengikatan berada di luar cakupan artikel ini) </li><li>  Formasi Cache </li></ol><br><br>  Kami tertarik pada poin kedua.  Perlu dicatat di sini bahwa ketika bekerja dengan objek dinamis, kita perlu memeriksa validitas operasi setiap kali.  Ini adalah tugas yang agak intensif sumber daya, jadi saya ingin men-cache hasil pemeriksaan tersebut.  Berkenaan dengan memanggil metode dengan parameter, kita perlu mengingat yang berikut: <br><br><ol><li>  Jenis yang disebut metode ini </li><li>  Jenis objek yang dilewatkan oleh parameter (untuk memastikan bahwa itu dapat dilemparkan ke jenis parameter) </li><li>  Apakah operasinya valid </li></ol><br><br>  Kemudian, ketika memanggil <b>Target</b> lagi, kita tidak perlu melakukan binding yang relatif mahal: cukup bandingkan tipenya dan, jika cocok, panggil fungsi objektif.  Untuk mengatasi masalah ini, <i>ExpressionTree</i> dibuat untuk setiap operasi dinamis, yang menyimpan <i>kendala</i> dan <i>fungsi tujuan</i> yang terikat ekspresi dinamis. <br><br>  Fungsi ini dapat terdiri dari dua jenis: <br><br><ul><li>  <i>Binding error</i> : misalnya, suatu metode dipanggil pada objek <i>dinamis</i> yang tidak ada atau objek <i>dinamis</i> tidak dapat dikonversi ke jenis parameter yang dilewati: maka Anda perlu membuang pengecualian seperti <i>Microsoft.CSharp.RuntimeBinderException: 'NoSuchMember'</i> </li><li>  Tantangannya legal: maka lakukan saja tindakan yang diperlukan </li></ul><br><br>  <i>ExpressionTree</i> ini dibentuk selama pelaksanaan delegasi <b>Pembaruan</b> dan disimpan dalam <b>Target</b> .  <b>Target</b> - <i>L0</i> cache, kita akan berbicara lebih banyak tentang cache nanti. <br><br>  Jadi, <b>Target</b> menyimpan <i>ExpressionTree</i> terakhir yang dihasilkan melalui delegasi <b>Pembaruan</b> .  Mari kita lihat bagaimana <i>aturan</i> ini terlihat seperti contoh dari tipe <i>Managed yang</i> diteruskan ke metode <i>Boo</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Foo</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> instance = Activator.CreateInstance(type); Boo(instance); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { } }</code> </pre> <br><br><pre> <code class="cs hljs">.Lambda CallSite.Target&lt;System.Action`<span class="hljs-number"><span class="hljs-number">3</span></span>[Actionsss.CallSite,ConsoleApp12.Foo,System.Object]&gt;( Actionsss.CallSite $$site, ConsoleApp12.Foo $$arg0, System.Object $$arg1) { .Block() { .If ($$arg0 .TypeEqual ConsoleApp12.Foo &amp;&amp; $$arg1 .TypeEqual System.Int32) { .Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Block() { .Call $$arg0.Boo((System.Object)((System.Int32)$$arg1)); .Default(System.Object) } } } .Else { .Default(System.Void) }; .Block() { .Constant&lt;Actionsss.Ast.Expression&gt;(IIF((($arg0 TypeEqual Foo) AndAlso ($arg1 TypeEqual Int32)), returnUnamedLabel_0 ({ ... }) , default(Void))); .Label .LabelTarget CallSiteBinder.UpdateLabel: }; .Label .If ( .Call Actionsss.CallSiteOps.SetNotMatched($$site) ) { .Default(System.Void) } .Else { .Invoke (((Actionsss.CallSite`1[System.Action`3[Actionsss.CallSite,ConsoleApp12.Foo,System.Object]])$$site).Update)( $$site, $$arg0, $$arg1) } .LabelTarget #Label1: } }</span></span></code> </pre> <br><br>  Blok paling penting bagi kami: <br><br><pre> <code class="cs hljs">.If ($$arg0 .TypeEqual ConsoleApp12.Foo &amp;&amp; $$arg1 .TypeEqual System.Int32)</code> </pre> <br><br>  <i>$$ arg0</i> dan <i>$$ arg1</i> adalah parameter yang disebut <b>Target</b> : <br><pre> <code class="cs hljs">Foo.o__0.p__0.Target((CallSite) Foo.o__0.p__0, &lt;b&gt;<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>&lt;/b&gt;, &lt;b&gt;instance&lt;/b&gt;);</code> </pre> <br><br>  Diterjemahkan ke dalam manusia, ini berarti yang berikut: <br><br>  Kami telah memverifikasi bahwa jika parameter pertama adalah tipe <i>Foo</i> dan yang kedua adalah <i>Int32</i> , maka Anda dapat memanggil <i>Boo ((objek) $$ arg1 dengan aman)</i> . <br><br><pre> <code class="cs hljs">.Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Block() { .Call $$arg0.Boo((System.Object)((System.Int32)$$arg1)); .Default(System.Object) }</span></span></code> </pre> <br><br>  <i>Catatan: jika terjadi kesalahan yang mengikat, blok Label1 terlihat seperti ini:</i> <br><pre> <code class="cs hljs">.Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Throw .New Microsoft.CSharp.RuntimeBinderException("NoSuchMember")</span></span></code> </pre> <br><br>  Pemeriksaan ini disebut <b>kendala</b> .  <b>Ada</b> dua jenis <b>batasan</b> : menurut jenis objek dan berdasarkan contoh spesifik objek (objek harus persis sama).  Jika setidaknya salah satu batasan gagal, kami harus memeriksa kembali ekspresi dinamis untuk validitas, untuk ini kami akan memanggil delegasi <b>Pembaruan</b> .  Menurut skema yang sudah kami ketahui, ia akan melakukan penjilidan dengan tipe baru dan menyimpan <i>ExpressionTree</i> baru di <b>Target</b> . <br><br><h2>  Cache </h2><br><br>  Kami telah menemukan bahwa <b>Target</b> adalah <b>cache L0</b> .  Setiap kali <b>Target</b> dipanggil, hal pertama yang akan kita lakukan adalah melewati batasan yang sudah tersimpan di dalamnya.  Jika batasan gagal dan ikatan baru dihasilkan, maka aturan lama berjalan secara bersamaan ke <b>L1</b> dan <b>L2</b> .  Di masa mendatang, ketika Anda melewatkan cache <i>L0</i> , aturan dari <i>L1</i> dan <i>L2</i> akan dicari sampai ditemukan yang sesuai. <br><br><ul><li>  <i>L1</i> : Sepuluh aturan terakhir yang telah meninggalkan <i>L0</i> (disimpan langsung di <i>CallSite</i> ) </li><li>  <i>L2</i> : 128 aturan terakhir yang dibuat menggunakan contoh binder spesifik (yaitu <i>CallSiteBinder</i> , unik untuk setiap <i>CallSite</i> ) </li></ul><br><br>  Sekarang kita akhirnya dapat menambahkan detail ini menjadi satu kesatuan dan menjelaskan dalam bentuk algoritma apa yang terjadi ketika <i>Foo.Bar (someDynamicObject) dipanggil</i> : <br><br>  1. Binder dibuat yang mengingat konteks dan metode yang dipanggil di tingkat tanda tangan mereka <br><br>  2. Pertama kali operasi dipanggil, <i>ExpressionTree</i> dibuat, yang menyimpan: <br>  2.1 <b>Keterbatasan</b> .  Dalam hal ini, ini akan menjadi dua batasan pada jenis parameter pengikatan saat ini <br>  2.2 <b>Fungsi obyektif</b> : <i>melemparkan beberapa pengecualian</i> (dalam hal ini tidak mungkin, karena <i>dinamika</i> apa pun akan berhasil mengarah ke objek) atau panggilan ke metode <i>Bilah</i> <br><br>  3. Kompilasi dan jalankan ExpressionTree yang dihasilkan <br><br>  4. Ketika Anda mengingat kembali operasi, dua opsi dimungkinkan: <br>  4.1 <b>Batasan berhasil</b> : cukup panggil <i>Bar</i> <br>  4.2 <b>Batasan tidak berfungsi</b> : ulangi langkah 2 untuk parameter pengikatan baru <br><br>  Jadi, dengan contoh tipe <i>Managed</i> , menjadi semakin jelas bagaimana <i>dinamika</i> bekerja dari dalam.  Dalam kasus yang dijelaskan, kami tidak akan pernah melewatkan cache, karena jenisnya selalu sama *, oleh karena itu <b>Pembaruan akan</b> dipanggil tepat sekali ketika <i>CallSite</i> diinisialisasi.  Kemudian, untuk setiap panggilan, hanya batasan yang akan diperiksa dan fungsi tujuan akan dipanggil segera.  Ini sesuai dengan pengamatan kami terhadap ingatan: tidak ada perhitungan - tidak ada kebocoran. <br><br>  <i>* Untuk alasan ini, kompiler menghasilkan CallSites untuk masing-masing: kemungkinan kehilangan cache L0 sangat berkurang</i> <br><br>  Saatnya untuk mengetahui bagaimana skema ini berbeda dalam kasus objek <i>COM asli</i> .  Mari kita lihat <i>ExpressionTree</i> : <br><br><pre> <code class="cs hljs">.Lambda CallSite.Target&lt;System.Action`<span class="hljs-number"><span class="hljs-number">3</span></span>[Actionsss.CallSite,ConsoleApp12.Foo,System.Object]&gt;( Actionsss.CallSite $$site, ConsoleApp12.Foo $$arg0, System.Object $$arg1) { .Block() { .If ($$arg0 .TypeEqual ConsoleApp12.Foo &amp;&amp; .Block(System.Object $var1) { $var1 = .Constant&lt;System.WeakReference&gt;(System.WeakReference).Target; $var1 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (System.Object)$$arg1 == $var1 }) { .Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Block() { .Call $$arg0.Boo((System.__ComObject)$$arg1); .Default(System.Object) } } } .Else { .Default(System.Void) }; .Block() { .Constant&lt;Actionsss.Ast.Expression&gt;(IIF((($arg0 TypeEqual Foo) AndAlso {var Param_0; ... }), returnUnamedLabel_1 ({ ... }) , default(Void))); .Label .LabelTarget CallSiteBinder.UpdateLabel: }; .Label .If ( .Call Actionsss.CallSiteOps.SetNotMatched($$site) ) { .Default(System.Void) } .Else { .Invoke (((Actionsss.CallSite`1[System.Action`3[Actionsss.CallSite,ConsoleApp12.Foo,System.Object]])$$site).Update)( $$site, $$arg0, $$arg1) } .LabelTarget #Label1: } }</span></span></code> </pre> <br><br>  Dapat dilihat bahwa perbedaannya hanya pada batasan kedua: <br><br><pre> <code class="cs hljs">.If ($$arg0 .TypeEqual ConsoleApp12.Foo &amp;&amp; .Block(System.Object $var1) { $var1 = .Constant&lt;System.WeakReference&gt;(System.WeakReference).Target; $var1 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (System.Object)$$arg1 == $var1 })</code> </pre> <br><br>  Jika dalam kasus kode <i>Terkelola</i> kami memiliki dua batasan pada jenis objek, maka di sini kita melihat bahwa pembatasan kedua memeriksa kesetaraan contoh melalui <i>WeakReference</i> . <br><br>  <i>Catatan: Pembatasan instance selain objek COM juga digunakan untuk TransparentProxy</i> <br><br>  Dalam praktiknya, berdasarkan pengetahuan kami tentang operasi cache, ini berarti bahwa setiap kali kami membuat kembali objek <i>COM</i> dalam satu loop, kami akan kehilangan cache <i>L0</i> (dan <i>L1 / L2</i> juga, karena aturan lama dengan tautan akan disimpan di sana untuk contoh lama).  Asumsi pertama yang meminta Anda di kepala adalah bahwa cache aturan mengalir.  Tetapi kode di sana cukup sederhana dan semuanya baik-baik saja di sana: aturan lama dihapus dengan benar.  Pada saat yang sama, menggunakan <i>WeakReference</i> di <i>ExpressionTree</i> tidak menghalangi <i>GC</i> dari mengumpulkan objek yang tidak perlu. <br><br>  <i>Mekanisme untuk menyimpan aturan dalam cache L1:</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MaxRules = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRule</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T newRule</span></span></span><span class="hljs-function">)</span></span> { T[] rules = Rules; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rules == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Rules = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { newRule }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } T[] temp; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rules.Length &lt; (MaxRules - <span class="hljs-number"><span class="hljs-number">1</span></span>)) { temp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T[rules.Length + <span class="hljs-number"><span class="hljs-number">1</span></span>]; Array.Copy(rules, <span class="hljs-number"><span class="hljs-number">0</span></span>, temp, <span class="hljs-number"><span class="hljs-number">1</span></span>, rules.Length); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { temp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T[MaxRules]; Array.Copy(rules, <span class="hljs-number"><span class="hljs-number">0</span></span>, temp, <span class="hljs-number"><span class="hljs-number">1</span></span>, MaxRules - <span class="hljs-number"><span class="hljs-number">1</span></span>); } temp[<span class="hljs-number"><span class="hljs-number">0</span></span>] = newRule; Rules = temp; }</code> </pre> <br><br>  Jadi apa masalahnya?  Mari kita coba memperjelas hipotesis: kebocoran memori terjadi di suatu tempat ketika mengikat objek <i>COM</i> . <br><br><h2>  Eksperimen, bagian 2 </h2><br><br>  Sekali lagi, mari kita beralih dari kesimpulan spekulatif ke eksperimen.  Pertama, mari kita ulangi apa yang dilakukan kompiler untuk kita: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Simple COM object var comType = Type.GetTypeFromCLSID(new Guid("435356F9-F33F-403D-B475-1E4AB512FF95")); var autogeneratedBinder = Binder.InvokeMember(CSharpBinderFlags.ResultDiscarded, "Boo", null, typeof(Foo), new CSharpArgumentInfo[2] { CSharpArgumentInfo.Create( CSharpArgumentInfoFlags.UseCompileTimeType, null), CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, null) }); var callSite = CallSite&lt;Action&lt;CallSite, Foo, object&gt;&gt;.Create(autogeneratedBinder); while (true) { object instance = Activator.CreateInstance(comType); callSite.Target(callSite, this, instance); }</span></span></code> </pre> <br><br>  Kami memeriksa: <br><br><img src="https://habrastorage.org/webt/bf/-u/k6/bf-uk6jtzrfh8_pyzaagi0p8cr4.png"><br><br>  Kebocoran itu telah dipertahankan.  Adil.  Tapi apa alasannya?  Setelah mempelajari kode binder (yang kita tinggalkan di belakang kurung), jelas bahwa satu-satunya hal yang mempengaruhi jenis objek kita adalah opsi pembatasan.  Mungkin ini bukan soal benda <i>COM</i> , tapi pengikat?  Tidak ada banyak pilihan, mari kita memprovokasi pengikatan berganda untuk tipe yang <i>Dikelola</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> instance = Activator.CreateInstance(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> autogeneratedBinder = Binder.InvokeMember(CSharpBinderFlags.ResultDiscarded, <span class="hljs-string"><span class="hljs-string">"Boo"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Foo), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CSharpArgumentInfo[<span class="hljs-number"><span class="hljs-number">2</span></span>] { CSharpArgumentInfo.Create( CSharpArgumentInfoFlags.UseCompileTimeType, <span class="hljs-literal"><span class="hljs-literal">null</span></span>), CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, <span class="hljs-literal"><span class="hljs-literal">null</span></span>) }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callSite = CallSite&lt;Action&lt;CallSite, Foo, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;&gt;.Create(autogeneratedBinder); callSite.Target(callSite, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, instance); }</code> </pre> <br><br><img src="https://habrastorage.org/webt/-y/an/hj/-yanhjj9jkmqr8bl2adf9rvjsvs.png"><br><br>  Wow!  Sepertinya kita menangkapnya.  Masalahnya tidak sama sekali dengan <i>objek COM</i> , seperti yang tampak bagi kita pada awalnya, hanya karena keterbatasan pada contoh, ini adalah satu-satunya kasus di mana pengikatan terjadi berkali-kali di dalam loop kita.  Dalam semua kasus lain, saya mendapatkan <i>cache L0</i> dan mengikatnya sekali. <br><br><h2>  Kesimpulan </h2><br><br><h3>  Kebocoran memori </h3><br><br>  Jika Anda bekerja dengan variabel <i>dinamis</i> yang mengandung <i>COM asli</i> atau <i>TransparentProxy</i> , jangan pernah berikan mereka sebagai parameter metode.  Jika Anda masih perlu melakukan ini, gunakan pemeran eksplisit ke <i>objek</i> dan kemudian kompiler akan tertinggal di belakang Anda <br><br>  <b>Salah</b> : <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> com = Activator.CreateInstance(comType); <span class="hljs-comment"><span class="hljs-comment">//do some work Marshal.FinalReleaseComObject(com);</span></span></code> </pre> <br><br>  <b>Dengan benar</b> : <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> com = Activator.CreateInstance(comType); <span class="hljs-comment"><span class="hljs-comment">//do some work Marshal.FinalReleaseComObject((object) com);</span></span></code> </pre><br><br>  Sebagai tindakan pencegahan tambahan, cobalah untuk instantiate objek seperti itu sesering mungkin.  Sebenarnya untuk semua versi <i>.NET Framework</i> .  (Untuk saat ini) tidak terlalu relevan untuk.  <i>Inti NET</i> , karena tidak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ada dukungan untuk</a> objek <i>COM dinamis</i> . <br><br><h3>  Performa </h3><br><br>  Adalah kepentingan Anda bahwa kesalahan cache jarang terjadi, karena dalam hal ini tidak perlu menemukan aturan yang sesuai dalam cache tingkat tinggi.  Kehilangan dalam cache <i>L0</i> akan terjadi terutama dalam kasus ketidakcocokan jenis objek <i>dinamis</i> dengan pembatasan yang dipertahankan. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> com = GetSomeObject(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSomeObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//:      //:         }</span></span></code> </pre> <br><br>  Namun, dalam praktiknya, Anda mungkin tidak akan melihat perbedaan dalam kinerja kecuali jika jumlah panggilan ke fungsi ini diukur dalam jutaan atau jika variabilitas jenis tidak terlalu besar.  Biaya jika terjadi <i>kesalahan</i> pada cache <i>L0</i> sedemikian rupa, <i>N</i> adalah jumlah jenis: <br><br><ul><li>  <i>N</i> &lt;10.  Jika Anda terlewatkan, lakukan saja aturan <i>L1</i> cache yang ada </li><li>  10 &lt; <i>N &lt;128</i> .  Pencacahan <i>L1</i> dan <i>L2</i> cache (maksimum 10 dan <i>N</i> iterasi).  Membuat dan mengisi array 10 elemen </li><li>  <i>N</i> &gt; 128.  Iterasi lebih dari <i>L1</i> dan <i>L2</i> cache.  Buat dan isi array 10 dan 128 elemen.  Jika Anda melewatkan cache <i>L2</i> , mengikat kembali </li></ul><br><br>  Dalam kasus kedua dan ketiga, beban pada GC akan meningkat. <br><br><h2>  Kesimpulan </h2><br><br>  Sayangnya, kami tidak menemukan alasan sebenarnya untuk kebocoran memori, ini akan membutuhkan studi terpisah dari pengikat tersebut.  Untungnya, <i>WinDbg</i> memberikan petunjuk untuk penyelidikan lebih lanjut: sesuatu yang buruk terjadi di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DLR</a> .  Kolom pertama adalah jumlah objek <br><br><img src="https://habrastorage.org/webt/n_/6g/xf/n_6gxf7etpsj2fg17odfa0varvy.png"><br><br><h2>  Bonus </h2><br><br>  <b>Mengapa casting ke <i>objek</i> secara eksplisit mencegah kebocoran?</b> <br>  Jenis apa pun dapat dilemparkan ke <i>objek</i> , sehingga operasi tidak lagi dinamis. <br><br>  <b>Mengapa tidak ada kebocoran saat bekerja dengan bidang dan metode objek COM?</b> <br>  Inilah yang tampak seperti <i>ExpressionTree</i> untuk akses bidang: <br><br><pre> <code class="cs hljs">.If ( .Call System.Dynamic.ComObject.IsComObject($$arg0) ) { .Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Dynamic GetMember ComMarks(.Call System.Dynamic2.ComObject.ObjectToComObject($$arg0)) } }</span></span></code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466657/">https://habr.com/ru/post/id466657/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466643/index.html">Intisari materi menarik untuk pengembang seluler # 314 (pada 2 - 8 September)</a></li>
<li><a href="../id466647/index.html">Telepon untuk kuda dan orkestra tanpa pianis. Cara membuat tugas olahraga di ujung depan</a></li>
<li><a href="../id466649/index.html">Akhir pekan di mobil listrik</a></li>
<li><a href="../id466651/index.html">Memilih antara XML dan SQL untuk menggulung skrip LiquiBase menggunakan Java / Spring / H2 sebagai contoh</a></li>
<li><a href="../id466653/index.html">Game debug untuk NES: bagaimana hal itu terjadi hari ini</a></li>
<li><a href="../id466659/index.html">Ulasan Kubecost untuk menghemat uang di Kubernetes di awan</a></li>
<li><a href="../id466661/index.html">Gelar Master Jarak Di Luar Negeri: Catatan Sebelum Tesis</a></li>
<li><a href="../id466663/index.html">Eksperimen sederhana dengan mikrokontroler STM32F103 (Blue Tablet)</a></li>
<li><a href="../id466665/index.html">CSS overflow dan kehilangan data</a></li>
<li><a href="../id466667/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 379 (2 - 8 September 2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>