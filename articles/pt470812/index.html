<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚗 👨🏾‍🎓 🕣 Cartucho Tarantool: Fragmento Lua Backend em três linhas 🧑🏽 ➕ 🚓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No Mail.ru Group, temos o Tarantool, um servidor de aplicativos baseado em Lua e um banco de dados unido. É rápido e elegante, mas os recursos de um ú...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cartucho Tarantool: Fragmento Lua Backend em três linhas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/470812/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/tg/6f/71/tg6f71dbjoo5m5qm5ebndfjxjdu.jpeg"></div><br>  No Mail.ru Group, temos o Tarantool, um servidor de aplicativos baseado em Lua e um banco de dados unido.  É rápido e elegante, mas os recursos de um único servidor são sempre limitados.  A escala vertical também não é a panacéia.  É por isso que o Tarantool possui algumas ferramentas para dimensionamento horizontal, ou o módulo vshard <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">[1]</a> .  Ele permite que você espalhe dados por vários servidores, mas será necessário mexer com eles por um tempo para configurá-los e seguir a lógica de negócios. <br><br>  Boas notícias: obtivemos nossa parcela de falhas (por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">[2]</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">[3]</a> ) e criamos outra estrutura, que simplifica significativamente a solução para esse problema. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O cartucho Tarantool</a> é a nova estrutura para o desenvolvimento de sistemas distribuídos complexos.  Ele permite que você se concentre em escrever a lógica de negócios em vez de resolver problemas de infraestrutura.  Abaixo, mostrarei como essa estrutura funciona e como ela poderia ajudar na criação de serviços distribuídos. <br><a name="habracut"></a><br><h2>  Então, qual é exatamente o problema? </h2><br>  Temos Tarantool e vshard - o que mais queremos? <br><br>  Primeiro, é uma questão de conveniência.  Vshard está configurado nas tabelas Lua.  Mas, para que um sistema distribuído de vários processos Tarantool funcione corretamente, a configuração deve ser a mesma em todos os lugares.  Ninguém gostaria de fazê-lo manualmente, para que todos os tipos de scripts, Ansible e sistemas de implantação sejam usados. <br><br>  O próprio cartucho gerencia a configuração vshard com base em <i>sua própria configuração distribuída</i> .  De fato, é um arquivo YAML simples e sua cópia é armazenada em todas as instâncias do Tarantool.  Em outras palavras, a estrutura monitora sua configuração para que seja a mesma em todos os lugares. <br><br>  Segundo, é novamente uma questão de conveniência.  A configuração do Vshard não está relacionada ao desenvolvimento da lógica de negócios e apenas distrai um desenvolvedor de seu trabalho.  Quando discutimos a arquitetura de um projeto, o assunto provavelmente diz respeito a componentes separados e sua interação.  É muito cedo para pensar em implantar um cluster para três datacenters. <br><br>  Resolvemos esses problemas repetidamente e, em algum momento, conseguimos desenvolver uma abordagem para simplificar o trabalho com o aplicativo durante todo o seu ciclo de vida: criação, desenvolvimento, teste, CI / CD, manutenção. <br><br>  Cartucho introduz o conceito de papéis para cada processo Tarantool.  As funções permitem que o desenvolvedor se concentre em escrever código.  Todas as funções disponíveis no projeto podem ser executadas na instância única do Tarantool, e isso seria suficiente para teste. <br><br>  Principais recursos do cartucho Tarantool: <br><br><ul><li>  orquestração automatizada de cluster; <br></li><li>  funcionalidade de aplicativo expandida com novas funções; <br></li><li>  modelo de aplicativo para desenvolvimento e implantação; <br></li><li>  sharding automático embutido; <br></li><li>  integração com o framework Luatest; <br></li><li>  gerenciamento de cluster usando WebUI e API; <br></li><li>  ferramentas de empacotamento e implantação. <br></li></ul><br><h2>  Olá Mundo! </h2><br>  Mal posso esperar para mostrar a estrutura em si, então vamos salvar a história sobre arquitetura para mais tarde e começar com uma tarefa fácil.  Supondo que o Tarantool já esteja instalado, tudo o que precisamos fazer é <br><br><pre><code class="plaintext hljs">$ tarantoolctl rocks install cartridge-cli $ export PATH=$PWD/.rocks/bin/:$PATH</code> </pre> <br>  Como resultado, os utilitários de linha de comando são instalados, o que permite criar seu primeiro aplicativo a partir do modelo: <br><br><pre> <code class="plaintext hljs">$ cartridge create --name myapp</code> </pre> <br>  E aqui está o que temos: <br><br><pre> <code class="plaintext hljs">myapp/ ├── .git/ ├── .gitignore ├── app/roles/custom.lua ├── deps.sh ├── init.lua ├── myapp-scm-1.rockspec ├── test │ ├── helper │ │ ├── integration.lua │ │ └── unit.lua │ ├── helper.lua │ ├── integration/api_test.lua │ └── unit/sample_test.lua └── tmp/</code> </pre> <br>  Este é um repositório git com um "Olá, Mundo!", Pronto para uso.  aplicação.  Vamos tentar executá-lo depois de instalar as dependências (incluindo a própria estrutura): <br><br><pre> <code class="plaintext hljs">$ tarantoolctl rocks make $ ./init.lua --http-port 8080</code> </pre> <br>  Lançamos um nó do nosso futuro aplicativo sharded.  Se você estiver curioso, poderá abrir imediatamente a interface da Web, que é executada no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">localhost</a> : 8080, use o mouse para configurar um cluster de um nó e aproveitar o resultado, mas não fique animado muito cedo.  O aplicativo ainda não sabe fazer nada de útil, então falarei sobre a implantação mais tarde e agora é hora de escrever algum código. <br><br><h2>  Desenvolvendo aplicativos </h2><br>  Imagine que estamos projetando um sistema que deve receber dados, salvá-los e criar um relatório uma vez por dia. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc6/dba/8a2/dc6dba8a2a2ff31693cff9a825c44b7f.png"></div><br>  Então, desenhamos um diagrama com três componentes: gateway, armazenamento e agendador.  Vamos continuar trabalhando na arquitetura.  Como usamos vshard como armazenamento, vamos adicionar vshard-router e vshard-storage ao diagrama.  Nem o gateway nem o planejador acessarão diretamente o armazenamento - um roteador é criado explicitamente para esta tarefa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/151/eb0/ac5/151eb0ac5b9d8a1a6217e0992b502089.png"></div><br>  Este diagrama parece abstrato porque os componentes ainda não refletem o que criaremos no projeto.  Vamos ter que ver como esse projeto corresponde ao Tarantool real, para que agrupemos nossos componentes pelo processo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fdc/781/a46/fdc781a46e819a67232bfcd308605b5d.png"></div><br>  Não faz muito sentido manter o vshard-router e gateway em instâncias separadas.  Por que passaríamos pela rede mais uma vez, se isso já é de responsabilidade do roteador?  Eles devem ser executados no mesmo processo, ou seja, o gateway e o vshard.router.cfg devem ser inicializados no mesmo processo e interagir localmente. <br><br>  Durante a fase de design, foi conveniente trabalhar com três componentes, mas como desenvolvedor, não quero pensar em lançar três instâncias do Tarantool enquanto escrevia o código.  Preciso executar os testes e verificar se escrevi o código do gateway corretamente.  Ou talvez queira mostrar um novo recurso aos meus colegas de trabalho.  Por que eu teria problemas com a implantação de três instâncias?  Assim, nasceu o conceito de papéis.  Uma função é um módulo Lua regular e o Cartridge gerencia seu ciclo de vida.  Neste exemplo, existem quatro: gateway, roteador, armazenamento e agendador.  Outro projeto pode ter mais papéis.  Todas as funções podem ser iniciadas em um processo, e isso seria suficiente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e1/49c/95a/1e149c95aed1d5dc7cf73e298198c719.png"></div><br>  E quando o assunto se refere à implantação na preparação ou produção, atribuímos um conjunto separado de funções a cada processo do Tarantool, dependendo dos recursos de hardware subjacentes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f9/b59/1d7/1f9b591d794e4b459b863f0da01f042b.png"></div><br><h2>  Gerenciamento de topologia </h2><br>  Também devemos armazenar informações sobre as funções em execução em algum lugar.  E "algures" significa a configuração distribuída acima mencionada.  A coisa mais importante aqui é a topologia de cluster.  Aqui você pode ver 3 grupos de replicação de 5 processos Tarantool: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb6/118/a0f/eb6118a0f7c2381ce82491bd65272ec5.png"></div><br>  Como não queremos perder os dados, tratamos as informações sobre os processos em execução com cuidado.  O cartucho monitora a configuração usando uma confirmação de duas fases.  Assim que queremos atualizar a configuração, ele primeiro verifica se as instâncias estão disponíveis e prontas para aceitar a nova configuração.  Depois disso, a configuração é aplicada na segunda fase.  Assim, mesmo se uma instância estiver temporariamente indisponível, nada poderá dar errado.  A configuração simplesmente não será aplicada e você verá um erro com antecedência. <br><br>  A seção de topologia também possui um parâmetro tão importante quanto o líder de cada grupo de replicação.  Geralmente, esta é a instância que aceita as gravações.  O restante geralmente é somente leitura, embora possa haver exceções.  Às vezes, desenvolvedores corajosos não têm medo de conflitos e podem gravar dados em várias réplicas ao mesmo tempo.  No entanto, algumas operações não devem ser executadas duas vezes.  É por isso que temos um líder. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f96/b85/7f3/f96b857f346a756f27c05651b85a9886.png"></div><br><h2>  Ciclo de vida da função </h2><br>  Para que uma arquitetura de projeto contenha funções abstratas, a estrutura deve, de alguma forma, ser capaz de gerenciá-las.  Naturalmente, as funções são gerenciadas sem reiniciar o processo Tarantool.  Existem quatro retornos de chamada projetados para gerenciamento de funções.  O próprio cartucho os chama, dependendo das informações da configuração distribuída, aplicando a configuração às funções específicas. <br><br><pre> <code class="plaintext hljs">function init() function validate_config() function apply_config() function stop()</code> </pre> <br>  Cada função tem uma função <code>init</code> .  É chamado uma vez: quando a função está ativada ou quando o Tarantool é reiniciado.  Aqui é conveniente, por exemplo, inicializar box.space.create, ou o planejador pode executar alguma fibra em segundo plano que concluiria a tarefa em intervalos regulares. <br><br>  A função <code>init</code> sozinha pode não ser suficiente.  O cartucho permite que as funções acessem a configuração distribuída usada para armazenar a topologia.  Na mesma configuração, podemos declarar uma nova seção e armazenar uma parte da configuração de negócios lá.  No meu exemplo, isso pode ser um esquema de dados ou configurações de agendamento para a função de agendador. <br><br>  O cluster chama <code>validate_config</code> e <code>apply_config</code> toda vez que a configuração distribuída é alterada.  Quando uma configuração é aplicada em uma confirmação de duas fases, o cluster verifica se cada função em cada servidor está pronta para aceitar essa nova configuração e, se necessário, relata um erro ao usuário.  Quando todos concordam com a configuração, <code>apply_config</code> é chamado. <br><br>  As funções também suportam um método de <code>stop</code> para limpar o lixo.  Se dissermos que não há necessidade do agendador neste servidor, ele pode parar as fibras que ele iniciou usando <code>init</code> . <br><br>  As funções podem interagir umas com as outras.  Estamos acostumados a escrever chamadas de função Lua, mas o processo pode não ter a função necessária.  Para facilitar o acesso à rede, usamos um módulo auxiliar chamado rpc (chamada de procedimento remoto), construído com base no módulo Tarantool net.box padrão.  Isso pode ser útil, por exemplo, se o seu gateway desejar solicitar ao agendador diretamente para executar a tarefa agora, em vez de em um dia. <br><br>  Outro ponto importante é garantir a tolerância a falhas.  O cartucho usa o protocolo SWIM <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">[4]</a> para monitorar a saúde.  Em suma, os processos trocam "rumores" uns com os outros via UDP, ou seja, todo processo conta a seus vizinhos as últimas notícias e eles respondem.  Se de repente não houver resposta, Tarantool suspeita que algo está errado e, depois de um tempo, declara a morte e envia essa mensagem a todos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/748/1ff/6f2/7481ff6f235c9833ac93d4aa310e2911.png"></div><br>  Com base neste protocolo, o cartucho organiza o failover automático.  Cada processo monitora seu ambiente e, se o líder parar subitamente de responder, a réplica poderá reivindicar sua função, e o Cartucho configurará as funções em execução de acordo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49a/925/53b/49a92553be1edd2834c373b14cf17431.png"></div><br>  Você precisa ter cuidado aqui, pois alternar com frequência pode resultar em conflitos de dados durante a replicação.  O failover automático certamente não deve ser ativado aleatoriamente.  Você deve ter uma idéia clara do que está acontecendo e garantir que a replicação não falhe quando o líder se recuperar e recuperar sua coroa. <br><br>  De tudo o que foi dito, as funções podem parecer semelhantes aos microsserviços.  Em certo sentido, eles são apenas módulos nos processos do Tarantool e existem várias diferenças fundamentais.  Primeiro, todas as funções do projeto devem viver na mesma base de código.  E todos os processos do Tarantool devem ser executados na mesma base de código, para que não haja surpresas, como quando tentamos inicializar o agendador, mas simplesmente não há agendador.  Além disso, não devemos permitir diferenças nas versões do código, porque o comportamento do sistema é complicado de prever e depurar em tal situação. <br><br>  Ao contrário do Docker, não podemos simplesmente pegar uma "imagem" de uma função, transferi-la para outra máquina e executá-la lá.  Nossas funções não são tão isoladas quanto os contêineres do Docker.  Além disso, não podemos executar duas funções idênticas na mesma instância.  O papel está lá ou não;  em certo sentido, é um singleton.  E em terceiro lugar, as funções devem ser as mesmas dentro de todo o grupo de replicação porque, caso contrário, pareceria ridículo: os dados são iguais, mas o comportamento é diferente. <br><br><h2>  Ferramentas de implantação </h2><br>  Prometi mostrar a você como o Cartucho poderia ajudar a implantar aplicativos.  Para facilitar a vida, a estrutura cria pacotes RPM: <br><br><pre> <code class="plaintext hljs">$ cartridge pack rpm myapp # will create ./myapp-0.1.0-1.rpm $ sudo yum install ./myapp-0.1.0-1.rpm</code> </pre> <br>  O pacote instalado contém quase tudo o que você precisa: o aplicativo e as dependências Lua instaladas.  O Tarantool também chega ao servidor como uma dependência de pacote RPM, e nosso serviço está pronto para o lançamento.  Isso tudo é feito usando o systemd, mas primeiro, devemos fazer algumas configurações, pelo menos especificar o URI de cada processo.  Três seriam suficientes para o nosso exemplo. <br><br><pre> <code class="plaintext hljs">$ sudo tee /etc/tarantool/conf.d/demo.yml &lt;&lt;CONFIG myapp.router: {"advertise_uri": "localhost:3301", "http_port": 8080} myapp.storage_A: {"advertise_uri": "localhost:3302", "http_enabled": False} myapp.storage_B: {"advertise_uri": "localhost:3303", "http_enabled": False} CONFIG</code> </pre> <br>  Há um aspecto interessante que deve ser considerado: em vez de especificar apenas a porta do protocolo binário, especificamos o endereço público de todo o processo, incluindo o nome do host.  Estamos fazendo isso porque os nós do cluster devem saber como se conectar.  Seria uma má idéia usar o endereço 0.0.0.0 como advertise_uri, pois deveria ser um endereço IP externo, em vez de um soquete.  Nada funciona sem ele, portanto, o Cartucho simplesmente não deixaria o nó com o advertise_uri errado iniciar. <br><br>  Agora que a configuração está pronta, podemos iniciar os processos.  Como uma unidade systemd comum não permite iniciar vários processos, as chamadas unidades instanciadas instalam os aplicativos no cartucho: <br><br><pre> <code class="plaintext hljs">$ sudo systemctl start myapp@router $ sudo systemctl start myapp@storage_A $ sudo systemctl start myapp@storage_B</code> </pre> <br>  Especificamos a porta HTTP para a interface da web do cartucho na configuração: 8080. Vamos lá e dar uma olhada: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4d/c41/8fc/c4dc418fca8a18c3f3dd2c4430bd1eaa.png"></div><br>  Podemos ver que os processos ainda não estão configurados, embora já estejam em execução.  O cartucho ainda não sabe como a replicação deve ser executada e não pode decidir por conta própria; portanto, está aguardando nossas ações.  Não temos muitas opções de escolha: a vida de um novo cluster começa com a configuração do primeiro nó.  Em seguida, adicionamos outros nós ao cluster, atribuímos funções a eles e a implantação pode ser considerada concluída com êxito. <br><br>  Vamos tomar uma bebida e relaxar após uma longa semana de trabalho.  O aplicativo está pronto para uso. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95e/78c/fc5/95e78cfc50600fc8b3acf86d3f553242.png"></div><br><h2>  Resultados </h2><br>  E os resultados?  Teste, use, deixe comentários e crie tickets no Github. <br><br><h2>  Referências </h2><br>  [1] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tarantool »2.2» Referência »Referência de rochas» Módulo vshard</a> <br>  [2] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como implementamos o núcleo dos negócios de investimento do Alfa-Bank com base no Tarantool</a> <br>  [3] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Arquitetura de cobrança de próxima geração: transição para Tarantool</a> <br>  [4] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SWIM - Cluster Building Protocol.</a> <br>  [5] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub - tarantool / cartucho-cli</a> <br>  [6] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub - tarantool / cartucho</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt470812/">https://habr.com/ru/post/pt470812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt470800/index.html">P - antecipação, bem como o Programa Preliminar DUMP Kazan. Veja os relatórios que passaram na seleção do moedor de carne</a></li>
<li><a href="../pt470802/index.html">Backup, Parte 6: Comparando ferramentas de backup</a></li>
<li><a href="../pt470804/index.html">Prêmio Alice: 5 idéias do vencedor</a></li>
<li><a href="../pt470806/index.html">Problema fundamental de teste</a></li>
<li><a href="../pt470808/index.html">Astra Linux "Eagle" Common Edition: existe vida após o Windows</a></li>
<li><a href="../pt470814/index.html">Materiais do android-mitap: ferramentas para autotestes | Yandex Mapkit 3 | design de aplicação | UI orientada a servidor</a></li>
<li><a href="../pt470816/index.html">Rússia - TPA - Bielorrússia: aqui o terceiro não é de todo supérfluo</a></li>
<li><a href="../pt470818/index.html">Caça ao bug, XSS às cegas e truques da Fox</a></li>
<li><a href="../pt470820/index.html">Um teste rápido de dezenas de hipóteses: como saímos da rotina e discutimos em outra cidade</a></li>
<li><a href="../pt470822/index.html">Monitoramento de temperatura na empresa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>