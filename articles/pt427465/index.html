<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîú üë©üèº‚Äç‚öïÔ∏è üèì O que acontece nos bastidores em C #: o b√°sico de trabalhar com a pilha ‚ôàÔ∏è üó£Ô∏è ‚åõÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sugiro olhar para tudo o que est√° por tr√°s de linhas simples de objetos de inicializa√ß√£o, m√©todos de chamada e passagem de par√¢metros. Bem, √© claro, u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O que acontece nos bastidores em C #: o b√°sico de trabalhar com a pilha</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427465/">  Sugiro olhar para tudo o que est√° por tr√°s de linhas simples de objetos de inicializa√ß√£o, m√©todos de chamada e passagem de par√¢metros.  Bem, √© claro, usar essas informa√ß√µes na pr√°tica est√° subtraindo a pilha do m√©todo de chamada. <br><br><h3>  Isen√ß√£o de responsabilidade </h3><br>  Antes de come√ßar a hist√≥ria, recomendo fortemente que voc√™ leia o primeiro post sobre o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">StructLayout</a> , porque  existe um exemplo que ser√° usado neste artigo. <br><br>  Todo o c√≥digo por tr√°s do n√≠vel superior √© apresentado no modo de <b>depura√ß√£o</b> , √© ele quem mostra a base conceitual.  Al√©m disso, todos os itens acima s√£o considerados para uma plataforma de 32 bits.  A otimiza√ß√£o do JIT √© um t√≥pico separado e importante que n√£o ser√° considerado aqui. <br><br>  Gostaria tamb√©m de advertir que este artigo n√£o cont√©m material que deve ser usado em projetos reais. <br><br><h3>  Comece com a teoria </h3><br>  Qualquer c√≥digo acaba se tornando um conjunto de comandos da m√°quina.  O mais compreens√≠vel √© sua representa√ß√£o na forma de instru√ß√µes em linguagem Assembly que correspondem diretamente a uma (ou v√°rias) instru√ß√µes da m√°quina. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ya/yv/k7/yayvk7f2o3tfr5flwaybim4u1m8.jpeg"></div><a name="habracut"></a><br>  Antes de passar para um exemplo simples, sugiro que voc√™ se familiarize com o que √© uma pilha de software.  <b>A pilha de software</b> √© principalmente uma parte da mem√≥ria usada como regra para armazenar v√°rios tipos de dados (como regra, eles podem ser chamados de <i>dados tempor√°rios</i> ).  Tamb√©m vale lembrar que a pilha cresce em dire√ß√£o a endere√ßos mais baixos.  Ou seja, quanto mais tarde o objeto for empurrado para a pilha, menor ser√° o seu endere√ßo. <br><br>  Agora, vejamos o pr√≥ximo trecho de c√≥digo na linguagem Assembler (omiti algumas das chamadas inerentes ao modo de depura√ß√£o). <br><br>  C #: <br><br><pre><code class="plaintext hljs">public class StubClass { public static int StubMethod(int fromEcx, int fromEdx, int fromStack) { int local = 5; return local + fromEcx + fromEdx + fromStack; } public static void CallingMethod() { int local1 = 7, local2 = 8, local3 = 9; int result = StubMethod(local1, local2, local3); } }</code> </pre> <br>  Asm: <br><br><pre> <code class="plaintext hljs">StubClass.StubMethod(Int32, Int32, Int32) 1: push ebp 2: mov ebp, esp 3: sub esp, 0x10 4: mov [ebp-0x4], ecx 5: mov [ebp-0x8], edx 6: xor edx, edx 7: mov [ebp-0xc], edx 8: xor edx, edx 9: mov [ebp-0x10], edx 10: nop 11: mov dword [ebp-0xc], 0x5 12: mov eax, [ebp-0xc] 13: add eax, [ebp-0x4] 14: add eax, [ebp-0x8] 15: add eax, [ebp+0x8] 16: mov [ebp-0x10], eax 17: mov eax, [ebp-0x10] 18: mov esp, ebp 19: pop ebp 20: ret 0x4 StubClass.CallingMethod() 1: push ebp 2: mov ebp, esp 3: sub esp, 0x14 4: xor eax, eax 5: mov [ebp-0x14], eax 6: xor edx, edx 7: mov [ebp-0xc], edx 8: xor edx, edx 9: mov [ebp-0x8], edx 10: xor edx, edx 11: mov [ebp-0x4], edx 12: xor edx, edx 13: mov [ebp-0x10], edx 14: nop 15: mov dword [ebp-0x4], 0x7 16: mov dword [ebp-0x8], 0x8 17: mov dword [ebp-0xc], 0x9 18: push dword [ebp-0xc] 19: mov ecx, [ebp-0x4] 20: mov edx, [ebp-0x8] 21: call StubClass.StubMethod(Int32, Int32, Int32) 22: mov [ebp-0x14], eax 23: mov eax, [ebp-0x14] 24: mov [ebp-0x10], eax 25: nop 26: mov esp, ebp 27: pop ebp 28: ret</code> </pre><br>  A primeira coisa que voc√™ deve prestar aten√ß√£o √© nos registros e opera√ß√µes <b>EBP</b> e <b>ESP</b> com eles. <br><br>  Um equ√≠voco entre meus amigos √© que o registro <b>EBP</b> est√° de alguma forma relacionado a um ponteiro para o topo da pilha.  Devo dizer que n√£o √© assim. <br><br>  O registro <b>ESP</b> √© respons√°vel pelo ponteiro para o topo da pilha.  Assim, com cada <b>comando PUSH</b> (coloca o valor no topo da pilha), o valor desse registro √© decrementado (a pilha cresce em dire√ß√£o a endere√ßos mais baixos) e, a cada opera√ß√£o <b>POP</b> , √© incrementada.  O comando <b>CALL</b> tamb√©m envia o endere√ßo de retorno para a pilha, diminuindo tamb√©m o valor do registro <b>ESP</b> .  De fato, a altera√ß√£o do registro <b>ESP</b> n√£o √© realizada apenas quando essas instru√ß√µes s√£o executadas (por exemplo, quando chamadas de interrup√ß√£o s√£o executadas, o mesmo acontece quando as instru√ß√µes <b>CALL</b> s√£o executadas). <br><br>  Considere o StubMethod. <br><br>  Na primeira linha, o conte√∫do do registro <b>EBP</b> √© salvo (pressionado na pilha).  Antes de retornar da fun√ß√£o, esse valor ser√° restaurado. <br><br>  A segunda linha armazena o valor atual da parte superior do endere√ßo da pilha (o valor do registro <b>ESP</b> √© inserido no <b>EBP</b> ).  Nesse caso, o registro <b>EBP</b> √© um tipo de zero no contexto da chamada atual.  O endere√ßamento √© realizado em rela√ß√£o a ele.  Em seguida, movemos o topo da pilha para quantas posi√ß√µes precisarmos para armazenar vari√°veis ‚Äã‚Äãe par√¢metros locais (terceira linha).  Algo como alocar mem√≥ria para todas as necessidades locais. <br><br>  Todos os itens acima s√£o chamados de fun√ß√£o de pr√≥logo. <br><br>  Depois disso, o acesso √†s vari√°veis ‚Äã‚Äãna pilha ocorre atrav√©s do <b>EBP</b> armazenado, o que indica o local onde as vari√°veis ‚Äã‚Äãdesse m√©todo espec√≠fico come√ßam. <br>  A seguir, √© apresentada a inicializa√ß√£o das vari√°veis ‚Äã‚Äãlocais. <br><br>  Lembrete sobre a <i>chamada r√°pida</i> : o .net nativo usa a <i>conven√ß√£o de</i> chamada da chamada <i>r√°pida</i> . <br>  O contrato rege a localiza√ß√£o e a ordem dos par√¢metros passados ‚Äã‚Äãpara a fun√ß√£o. <br>  Com a <i>chamada r√°pida, o</i> primeiro e o segundo par√¢metros s√£o passados ‚Äã‚Äãpelos registradores <b>ECX</b> e <b>EDX</b> , respectivamente, e os par√¢metros subsequentes s√£o passados ‚Äã‚Äãpela pilha. <br><br>  Para m√©todos n√£o est√°ticos, o primeiro par√¢metro est√° impl√≠cito e cont√©m o endere√ßo do objeto no qual o m√©todo √© chamado (endere√ßa isso). <br><br>  Nas linhas 4 e 5, os par√¢metros que foram transmitidos pelos registradores (os 2 primeiros) s√£o armazenados na pilha. <br><br>  A seguir, √© necess√°rio limpar o espa√ßo da pilha para vari√°veis ‚Äã‚Äãlocais e inicializar vari√°veis ‚Äã‚Äãlocais. <br><br>  Vale lembrar que o resultado da fun√ß√£o est√° no registro <b>EAX</b> . <br><br>  Nas linhas 12-16, as vari√°veis ‚Äã‚Äãnecess√°rias s√£o adicionadas.  Chamo sua aten√ß√£o para a linha 15. H√° uma chamada para o endere√ßo, mais do que o in√≠cio da pilha, ou seja, para a pilha do m√©todo anterior.  Antes de chamar, o m√©todo de chamada envia o par√¢metro para o topo da pilha.  Aqui n√≥s lemos.  O resultado da adi√ß√£o √© recuperado do registro <b>EAX</b> e empurrado para a pilha.  Como esse √© o valor de retorno do StubMethod, ele √© colocado novamente no <b>EAX</b> .  Obviamente, esses conjuntos absurdos de instru√ß√µes s√£o inerentes apenas ao modo de depura√ß√£o, mas mostram como nosso c√≥digo parece exatamente sem um otimizador inteligente que fa√ßa a maior parte do trabalho. <br><br>  As linhas 18 e 19 restauram o <b>EBP</b> anterior (o m√©todo de chamada) e o ponteiro para o topo da pilha (no momento em que o m√©todo foi chamado). <br><br>  A √∫ltima linha retorna.  Sobre o valor 0x4 vou dizer um pouco menor. <br>  Essa sequ√™ncia de comandos √© chamada de ep√≠logo da fun√ß√£o. <br><br>  Agora vamos dar uma olhada no CallingMethod.  Vamos direto para a linha 18. Aqui colocamos o terceiro par√¢metro no topo da pilha.  Observe que fazemos isso usando a instru√ß√£o <b>PUSH</b> , ou seja, o valor do <b>ESP</b> √© diminu√≠do.  Os outros 2 par√¢metros s√£o colocados nos registradores ( <i>chamada r√°pida</i> ).  A seguir, √© chamada o m√©todo StubMethod.  Agora, lembre-se da instru√ß√£o <b>RET 0x4</b> .  A seguinte pergunta √© poss√≠vel aqui: o que √© 0x4?  Como mencionei acima, colocamos os par√¢metros da fun√ß√£o chamada na pilha.  Mas agora n√£o precisamos deles.  0x4 indica que o byte precisa ser limpo da pilha ap√≥s a chamada da fun√ß√£o.  Como havia um par√¢metro, voc√™ precisa limpar 4 bytes. <br><br>  Aqui est√° uma imagem de pilha de amostra: <br><br><img src="https://habrastorage.org/webt/vz/eo/vz/vzeovzr2rvkuetuzi4xyp4iuxye.png"><br><br>  Portanto, se nos virarmos e vermos o que est√° no verso da pilha imediatamente ap√≥s chamar o m√©todo, a primeira coisa que veremos √© o <b>EBP</b> empurrado para a pilha (na verdade, isso aconteceu na primeira linha do m√©todo atual).  Em seguida, haver√° um endere√ßo de retorno que indica onde a execu√ß√£o continuar√° (usada pela instru√ß√£o <b>RET</b> ).  E atrav√©s desses campos, veremos os pr√≥prios par√¢metros da fun√ß√£o atual (a partir do 3¬∫, os par√¢metros s√£o transmitidos pelos registros anteriores).  E por tr√°s deles est√° a pilha do pr√≥prio m√©todo de chamada! <br>  Os primeiro e segundo campos mencionados explicam o deslocamento em + 0x8 ao se referir aos par√¢metros. <br>  Assim, os par√¢metros devem estar no topo da pilha em uma ordem estritamente definida quando a fun√ß√£o √© chamada.  Portanto, antes de chamar o m√©todo, cada par√¢metro √© enviado para a pilha. <br>  Mas e se voc√™ n√£o pression√°-los e a fun√ß√£o ainda os aceitar? <br><br><h3>  Um pequeno exemplo </h3><br>  Portanto, todos os fatos declarados acima me fizeram ter um desejo irresist√≠vel de ler a pilha de um m√©todo que chamar√° minha fun√ß√£o.  O pensamento de que, literalmente, em uma posi√ß√£o do terceiro argumento (ser√° o mais pr√≥ximo da pilha do m√©todo de chamada), s√£o os dados preciosos que eu quero tanto obter, n√£o me deixaram dormir. <br><br>  Portanto, para ler a pilha do m√©todo de chamada, preciso ir um pouco al√©m dos par√¢metros. <br><br>  Ao se referir a par√¢metros, o c√°lculo do endere√ßo de um par√¢metro √© baseado apenas no fato de o m√©todo de chamada colocar todos eles na pilha. <br><br>  Mas a passagem impl√≠cita pelo par√¢metro <b>EDX</b> (quem se importa - o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo anterior</a> ) sugere que podemos superar o compilador em alguns casos. <br><br>  A ferramenta que eu fiz isso √© chamada StructLayoutAttribute (recursos no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeiro artigo</a> ).  // Algum dia vou aprender algo diferente desse atributo, prometo. <br><br>  Usamos a mesma t√©cnica favorita com tipos de refer√™ncia. <br><br>  Ao mesmo tempo, se os m√©todos sobrepostos tiverem um n√∫mero diferente de par√¢metros, obtemos que o compilador n√£o enviar√° os que precisamos para a pilha (como o imagin√°rio, porque n√£o sabe quais). <br>  No entanto, o m√©todo realmente chamado (com o mesmo deslocamento de outro tipo) aborda os endere√ßos positivos relativos √† sua pilha, ou seja, aqueles em que planeja encontrar os par√¢metros. <br><br>  Mas l√° ele n√£o os encontra e come√ßa a ler a pilha do m√©todo de chamada. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo Spoiler</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using System; using System.Runtime.InteropServices; namespace Magic { public class StubClass { public StubClass(int id) { Id = id; } public int Id; } [StructLayout(LayoutKind.Explicit)] public class CustomStructWithLayout { [FieldOffset(0)] public Test1 Test1; [FieldOffset(0)] public Test2 Test2; } public class Test1 { public virtual void Useless(int skipFastcall1, int skipFastcall2, StubClass adressOnStack) { adressOnStack.Id = 189; } } public class Test2 { public virtual int Useless() { return 888; } } class Program { static void Main() { Test2 objectWithLayout = new CustomStructWithLayout { Test2 = new Test2(), Test1 = new Test1() }.Test2; StubClass adressOnStack = new StubClass(3); objectWithLayout.Useless(); Console.WriteLine($"MAGIC - {adressOnStack.Id}"); // MAGIC - 189 } } }</code> </pre><br></div></div><br>  Eu n√£o vou dar o c√≥digo da linguagem assembler, est√° tudo bem claro l√°, mas se voc√™ tiver perguntas, tentarei respond√™-las nos coment√°rios <br><br>  Entendo perfeitamente que esse exemplo n√£o pode ser usado na pr√°tica, mas, na minha opini√£o, pode ser muito √∫til para entender o esquema geral do trabalho. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt427465/">https://habr.com/ru/post/pt427465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt427451/index.html">Conectar tarefas do phpStorm ao Bitrix24</a></li>
<li><a href="../pt427453/index.html">Como eu fiz a transmiss√£o de som no Raspberry Pi</a></li>
<li><a href="../pt427457/index.html">A Terceira Onda de Intelig√™ncia Artificial e Sistemas de Seguran√ßa do Estado</a></li>
<li><a href="../pt427459/index.html">L√¢mpadas LED Diall da loja Castorama</a></li>
<li><a href="../pt427461/index.html">A beleza das fun√ß√µes N√ÉO an√¥nimas em JavaScript</a></li>
<li><a href="../pt427467/index.html">A introdu√ß√£o mais curta √† Programa√ß√£o Reativa</a></li>
<li><a href="../pt427469/index.html">Receitas e lucros de fabricantes de eletr√¥nicos, ou com mais margem</a></li>
<li><a href="../pt427471/index.html">Desenvolvemos transporte n√£o tripulado no ensino m√©dio com LEGO EV3</a></li>
<li><a href="../pt427473/index.html">Quais problemas do l√≠der da equipe podem ser resolvidos com a ajuda do jogo</a></li>
<li><a href="../pt427475/index.html">Android LiveData no Kotlin usando Retrofit e corotinas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>