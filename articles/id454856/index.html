<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌵 🧑🏽 💞 Kami menganalisis kerentanan validasi sertifikat SSL / TLS dalam perangkat lunak non-browser 🕛 🌕 👇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Awalnya dikembangkan untuk browser, protokol SSL / TLS kemudian menjadi standar de facto untuk semua komunikasi Internet yang aman. Sekarang digunakan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami menganalisis kerentanan validasi sertifikat SSL / TLS dalam perangkat lunak non-browser</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454856/"><p> Awalnya dikembangkan untuk browser, protokol SSL / TLS kemudian menjadi standar de facto untuk semua komunikasi Internet yang aman.  Sekarang digunakan untuk administrasi jarak jauh dari infrastruktur virtual yang digunakan di cloud, untuk mentransfer rincian pembayaran pelanggan dari server e-commerce ke pemroses pembayaran seperti PayPal dan Amazon, untuk mengirim data lokal ke penyimpanan cloud, menyimpan korespondensi dalam pesan instan dan otentikasi server dalam aplikasi mobile iOS dan Android. </p><br><p>  Daftar situasi di mana pertukaran informasi yang sangat sensitif membutuhkan keamanan maksimum cukup mengesankan.  Dalam artikel ini, kita akan memeriksa bagaimana keamanan komunikasi ini dipastikan dalam praktiknya. </p><br><p><img src="https://habrastorage.org/webt/qz/-m/fl/qz-mflldhumqjvdsr5kmhxhwh_e.jpeg"></p><a name="habracut"></a><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- Protokol SSL / TLS: mereka menginginkan yang terbaik ...</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- ... tetapi ternyata seperti biasa: contoh gagal verifikasi sertifikat SSL / TLS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- Kerentanan logis dari protokol SSL / TLS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- Kerentanan implementasi protokol SSL / TLS umum lainnya</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- Akar penyebab kerentanan dalam protokol SSL / TLS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- Satu sendok madu dalam satu tong tar</a> </p><br><a name="a1"></a><br><h1 id="ssltls-protokol-hoteli-kak-luchshe">  Protokol SSL / TLS: kami menginginkan yang terbaik ... </h1><br><p>  Secara teori, koneksi protokol SSL / TLS yang aman harus memastikan kerahasiaan, keandalan dan integritas komunikasi perangkat lunak klien dan server, bahkan di hadapan penyerang canggih aktif dari jaringan: ketika jaringan sepenuhnya diambil oleh musuh, DNS diracuni, dan titik akses dan router, switch dan WiFi dikendalikan oleh penyerang;  penyerang yang, antara lain, mengontrol backend SSL / TLS.  Selain itu, ketika perangkat lunak klien mencoba menyambung ke server yang sah, penyerang dapat mengubah alamat jaringan server (misalnya, melalui keracunan DNS), dan alih-alih server yang sah, mengarahkan klien ke server jahatnya. </p><br><p>  Keamanan komunikasi dalam kondisi keras seperti itu, seperti yang Anda tahu, sepenuhnya bergantung pada kecukupan verifikasi sertifikat kriptografi yang disediakan oleh server ketika membuat koneksi.  Termasuk kecukupan implementasi satu set cipher (ciphersuite), yang digunakan klien dan server saat bertukar data.  Agar koneksi SSL / TLS sepenuhnya aman, perangkat lunak klien, antara lain, harus dengan hati-hati memverifikasi bahwa: </p><br><ul><li>  sertifikat yang dikeluarkan oleh lembaga sertifikasi saat ini; </li><li>  masa berlakunya belum kedaluwarsa (atau sertifikat belum dicabut); </li><li>  daftar nama yang tercantum dalam sertifikat berisi domain tempat Anda terhubung. </li></ul><br><a name="a2"></a><br><h1 id="a-poluchilos-kak-vsegda-primery-provalnoy-proverki-ssltls-sertifikata">  ... tetapi ternyata seperti biasa: contoh gagal verifikasi sertifikat SSL / TLS </h1><br><p>  Namun, di banyak aplikasi dan perpustakaan, yang keamanan komunikasinya sangat kritis, prosedur untuk memeriksa sertifikat SSL / TLS, dan bahkan EV-SSL, sertifikat verifikasi diperpanjang [4], sama sekali tidak berhasil.  Di semua sistem operasi populer: Linux, Windows, Android dan iOS.  Di antara perangkat lunak yang rentan, perpustakaan, dan layanan middleware, berikut ini dapat dibedakan [1]: </p><br><ul><li>  Pustaka EC2 Java Amazon dan semua klien front-end berbasis cloud dibangun atas dasar itu. </li><li>  SDK perdagangan Amazon dan PayPal, yang bertanggung jawab atas pengiriman detail pembayaran dari situs (di mana infrastruktur perdagangan online digunakan) ke gateway pembayaran. </li><li>  “Keranjang” terpadu, seperti osCommerce, ZenCart, Ubercart, dan PrestaShop, yang sama sekali tidak memvalidasi sertifikat. </li><li>  Kode AdMob digunakan oleh perangkat lunak seluler untuk menampilkan iklan kontekstual. </li><li>  Antarmuka komponen ujung depan ElephantDrive dan FilesAnywhere, bertanggung jawab untuk berinteraksi dengan penyimpanan cloud. </li><li>  Pustaka Android Pusher dan semua perangkat lunak yang menggunakan API Pusher untuk mengontrol pengiriman pesan instan (misalnya, Gaug.es GitHub). </li><li>  Apache HttpClient (versi 3.x);  Apache Libcloud  dan semua koneksi klien ke server Apache ActiveMQ, dll. </li><li>  Layanan middleware SOAP Java, termasuk Apache Axis, Axis 2, Codehaus XFire;  serta semua perangkat lunak yang dibangun berdasarkan layanan middleware ini. </li><li>  Alat API Balancing Beban Elastis </li><li>  Implementasi Weberknecht dari WebSockets. </li><li>  Serta semua perangkat lunak seluler yang dibangun atas dasar perpustakaan dan layanan middleware yang tercantum di atas (untuk memahami apa layanan middleware, lihat Gambar 1);  termasuk klien iOS dari penyedia hosting Rackspace. </li></ul><br><p><img src="https://habrastorage.org/webt/h6/9q/u6/h69qu6qopmj-_h8pcexpzcuzth0.png">  <em><strong>Gambar 1.</strong> Apa itu layanan middleware</em> </p><br><p>  Selain itu, dalam [2] bahkan lebih dari seratus aplikasi seluler yang rentan terdaftar (lihat Gambar. 2).  Termasuk: Google Cloud Messaging Android, Daftar Kata Sandi Pusat Bisnis Angie, Klien Jaringan Global AT&amp;T, CapitalOne Spark Pay, Cisco OnPlus (akses jarak jauh), Dukungan Teknis Cisco, Cisco Webex, Kata Sandi WebEx Cisco, Domino Pizza, E-Trade, Freelancer , Google Earth, Huntington Mobile (Bank), Akuntan Daring Pajak Intuit, iTunes Connect, Microsoft Skype, Oracle Now, Pinterest, SafeNet (klien VPN), SouthWest Airlines, Uber, Bank AS - Akses Online, WesternUnion, WordPress, Yahoo!  Keuangan, Yahoo!  Mail </p><br><p><img src="https://habrastorage.org/webt/u4/qz/rd/u4qzrdgik4ygb_j1jalyckamwmo.png">  <em><strong>Gambar 2.</strong> Pilihan kecil dari daftar aplikasi seluler yang rentan</em> </p><br><a name="a3"></a><br><h1 id="logicheskie-uyazvimosti-ssltls-protokola">  SSL / TLS Kerentanan Logis </h1><br><p>  Koneksi SSL / TLS dari semua ini dan banyak perangkat lunak lain rentan terhadap berbagai serangan MiTM.  Pada saat yang sama, serangan MiTM dapat dilakukan, seringkali bahkan tanpa memalsukan sertifikat dan tanpa mencuri kunci pribadi dimana server menandatangani sertifikat mereka.  Serangan MiTM dapat dilakukan dengan hanya mengeksploitasi kerentanan logis yang ada dalam prosedur untuk memeriksa sertifikat SSL / TLS di sisi perangkat lunak klien.  Akibatnya, penyerang MiTM dapat, misalnya, mengumpulkan token otorisasi, nomor kartu kredit, nama, alamat, dll.  - dari pedagang mana pun yang menggunakan aplikasi web pemrosesan pembayaran yang rentan. </p><br><p>  Vendor perangkat lunak seluler, yang mengambil kode sampel AdMob untuk menghubungkan aplikasi mereka dengan akun AdMob, juga rentan - mereka memungkinkan penyerang untuk menangkap kredensial dan mendapatkan akses ke semua layanan Google-nya.  Misalnya, karena verifikasi sertifikat yang salah pada messenger seperti Trillian dan AIM, penyerang MiTM dapat mencuri kredensial login untuk semua layanan Google (termasuk Gmail), Yahoo !;  dan juga ke layanan Windows Live (termasuk SkyDrive).  Kerentanan lain yang memengaruhi perangkat lunak web non-browser modern termasuk: penggunaan ekspresi reguler yang salah ketika membandingkan nama host;  mengabaikan hasil validasi sertifikat;  penutupan verifikasi disengaja atau tidak disengaja.  [1] </p><br><a name="a4"></a><br><h1 id="drugie-rasprostranyonnye-uyazvimosti-realizacii-ssltls-protokola">  Kerentanan implementasi protokol SSL / TLS umum lainnya </h1><br><p>  Dan tentu saja, kita tidak boleh lupa bahwa bahkan jika tidak ada kesalahan logis dalam implementasi protokol SSL / TLS (kecuali tentu saja seseorang masih mempercayainya), perlindungan dapat dilewati dengan mencuri kunci privat [12], dengan menggunakan 0day- eksploitasi untuk hal-hal seperti keyboard, browser, sistem operasi, utilitas dan firmware [3];  dengan mengorbankan routing BGP [10];  atau menyerang SSL / TLS melalui perangkat keras (lihat Gambar 3) [8] dan / atau perangkat lunak [9] memotong saluran. </p><br><p><img src="https://habrastorage.org/webt/ia/ft/cx/iaftcxtvwltpvjrjsrl1kveoeoe.png">  <em><strong>Gambar 3.</strong> Serangan SSL pada perangkat keras</em> </p><br><p>  Selain itu, penyerang dapat melakukan serangan MiTM praktis tidak terlihat, menyalahgunakan mekanisme caching sesi SSL / TLS diimplementasikan dalam kelas SSLSessionCache.  Mekanisme ini memeriksa validitas sertifikat hanya pada koneksi awal;  juga tidak mampu membatalkan sesi komunikasi dengan benar setelah menghapus sertifikat dari perangkat.  Selain itu, setelah me-reboot perangkat Android (melalui opsi "Restart" atau "Matikan"), Anda dapat terus melihat lalu lintas terenkripsi dari beberapa aplikasi yang tidak memulai setelah reboot, tetapi bekerja sebelum reboot.  Jadi misalnya dengan Google Maps terjadi.  Dalam [2], dijelaskan bagaimana, berkat cacat caching ini, penyerang dapat sepenuhnya mengatur dan menghapus "sertifikat tak terlihat" secara transparan untuk pengguna, dan kemudian membuat koneksi jaringan dengan aplikasi apa pun. </p><br><p><img src="https://habrastorage.org/webt/ug/jc/nl/ugjcnltgragwjfsa3uqtswrwkoe.png">  <em><strong>Gambar 4.</strong> Retrospektif enkripsi rentan</em> </p><br><p>  Kerentanan umum lainnya dalam implementasi protokol SSL / TLS termasuk enkripsi yang rentan (lihat Gambar 4) [5], penggunaan kembali GCM (Mode Galois / Kontra; tanggapan dengan otentikasi Galois) [6], trik dengan CNG (CryptoAPI-NG ) di Schannel (lihat Gambar. 5) [7], verifikasi yang salah dari rantai kepercayaan [2], verifikasi yang salah dari nama host [11]. </p><br><p><img src="https://habrastorage.org/webt/er/yb/sn/erybsnnakygfotqkha9beavus-g.png">  <em><strong>Gambar 5.</strong> Trik CNG: menarik rahasia dari Schannel</em> </p><br><p>  Verifikasi rantai kepercayaan yang salah adalah situasi di mana aplikasi web benar-benar menerima sertifikat apa pun yang menunjukkan nama host yang benar, tanpa memeriksa dengan otoritas sertifikat apa itu ditandatangani.  Ini memungkinkan Anda untuk mencegat dan mendekripsi kata sandi dan / atau nomor kartu kredit.  Dan dalam beberapa kasus bahkan melakukan injeksi kode berbahaya.  Dalam perangkat lunak Android, kerentanan ini menembus, misalnya, ketika antarmuka X509TrustManger yang disesuaikan dibuat yang mengabaikan pengecualian CertificateException.  Atau ketika pengembang perangkat lunak memasukkan panggilan ke metode SslErrorHandler.proceed () ke dalam kode komponen WebViews.  [2] </p><br><p>  Verifikasi nama host yang salah adalah situasi ketika aplikasi web menerima sertifikat tanpa memastikan bahwa host dari mana sertifikat ini masuk dalam daftar host tepercaya.  Dalam perangkat lunak Android, kerentanan ini menembus, misalnya, ketika antarmuka HostnameVerifier dibuat, yang mengembalikan TRUE dalam kondisi apa pun.  Atau ketika pengembang perangkat lunak memasukkan panggilan ke metode SslErrorHandler.proceed () ke dalam kode komponen WebViews.  [2] </p><br><a name="a5"></a><br><h1 id="korennaya-prichina-suschestvovaniya-uyazvimostey-v-ssltls-protokole">  Akar penyebab kerentanan dalam protokol SSL / TLS </h1><br><p>  Penyebab utama dari sebagian besar kerentanan ini adalah desain API yang mengerikan dari perpustakaan SSL / TLS (termasuk JSSE, OpenSSL, dan GnuTLS).  Serta desain perpustakaan transfer data yang sama buruknya (seperti cURL, Apache HttpClient, dan urllib), yang masing-masing merupakan pembungkus tingkat tinggi untuk perpustakaan SSL / TLS.  Belum lagi layanan middleware (seperti Apache Axis, Axis 2, atau Codehaus XFire), yang merupakan pembungkus tingkat lebih tinggi, dan yang semakin meningkatkan "bola salju" dari desain yang mengerikan.  Alih-alih melakukan dialog dengan pengembang aplikasi (sering jauh dari pemrograman sistem) dalam bahasa yang dia pahami (dalam hal kerahasiaan dan otentikasi), disarikan dari detail tingkat rendah implementasi protokol SSL / TLS, API ini membuang banyak parameter SSL / TLS tingkat rendah pada orang miskin tidak bisa dimengerti olehnya.  Mereka membutuhkan perangkat lunak tingkat tinggi untuk mengekspos opsi tingkat rendah dengan benar;  mengimplementasikan fungsi verifikasi nama host dan menangani interpretasi nilai-nilai yang dikembalikan oleh operasi tingkat rendah. </p><br><p>  Akibatnya, pengembang aplikasi menggunakan API SSL / TLS secara tidak benar: mereka keliru menafsirkan keragaman parameter, opsi, efek samping, dan nilai pengembalian.  Misalnya [1]: </p><br><ul><li>  Perpustakaan PHP Layanan Pembayaran Fleksibel Amazon berupaya mengaktifkan validasi nama host dengan menetapkan parameter CURLOPT_SSL_VERIFYHOST menjadi TRUE (di perpustakaan cURL).  Namun, nilai default yang benar untuk parameter ini adalah 2;  jika Anda memberinya nilai TRUE, maka parameter ini tidak terlihat untuk pengembang yang menetapkan nilai 1, dan seterusnya.  verifikasi sertifikat dinonaktifkan. </li><li>  Pustaka PHP Standar Pembayaran PayPal - mendapatkan kesalahan yang sama;  Selain itu, pada saat implementasi yang sebelumnya, rentan, diperbarui (yaitu, satu kesalahan dihapus, satu lainnya ditambahkan). </li><li>  Contoh lain adalah Lynx, browser berorientasi teks.  Ini memverifikasi sertifikat yang ditandatangani sendiri - tetapi hanya jika fungsi verifikasi sertifikat GnuTLS mengembalikan nilai negatif.  Namun, fungsi ini mengembalikan 0 untuk beberapa kesalahan;  termasuk dalam kasus di mana sertifikat ditandatangani oleh badan yang tidak dipercaya.  Karena hal ini, rantai kepercayaan di Lynx rusak. </li></ul><br><p>  Selain itu, pengembang aplikasi sering salah memahami jenis jaminan keamanan apa yang disediakan oleh perpustakaan SSL / TLS tertentu.  Oleh karena itu, di alam liar, seseorang dapat menemukan kasus klinis di mana dalam aplikasi yang secara mendasar membutuhkan komunikasi yang aman (misalnya, berinteraksi dengan prosesor pembayaran), perpustakaan SSL / TLS digunakan yang sama sekali tidak memeriksa sertifikat SSL / TLS.  Lebih sederhana, tetapi lebih banyak kasus pembunuhan adalah ketika pengembang dari salah satu lapisan perangkat lunak menengah diam-diam menonaktifkan prosedur untuk memeriksa sertifikat SSL / TLS (ia dapat melakukan ini, misalnya, untuk menguji sistem, dan setelah pengujian lupa mengaktifkannya kembali).  Pada saat yang sama, kode program tingkat tinggi menggunakan lapisan perantara ini yakin bahwa verifikasi sertifikat dilakukan.  T.O.  Kesalahan SSL / TLS sering disembunyikan di kedalaman satu atau beberapa lapisan pustaka antara sekaligus - membuatnya hampir mustahil untuk mendeteksi masalah ini. </p><br><p>  Misalnya, di JSSE (Java Secure Socket Extension), antarmuka SSLSocketFactory diperpanjang tanpa suara mengecek nama host jika bidang "algoritma" di klien SSL diatur ke NULL atau ke string kosong, dan bukan ke HTTPS.  Meskipun fakta ini disebutkan dalam panduan referensi JSSE, banyak implementasi protokol SSL Java menggunakan SSLSocketFactory tanpa melakukan validasi nama host ... </p><br><a name="a6"></a><br><h1 id="lozhka-myoda-v-bochku-dyogtya">  Satu sendok madu dalam satu tong tar </h1><br><p>  Jadi, pada kenyataannya, ternyata di sebagian besar perangkat lunak web non-browser, verifikasi sertifikat SSL / TLS benar-benar dinonaktifkan atau diterapkan secara tidak benar.  Gambar 7 menunjukkan klasifikasi kerentanan protokol SSL / TLS saat ini.  Beberapa kerentanan ini, tetapi tidak semua, telah dijelaskan dan / atau disebutkan di atas.  Anda dapat membiasakan diri dengan kerentanan yang disebutkan tetapi tidak dijelaskan dengan membaca materi yang tercantum dalam daftar pustaka. </p><br><p><img src="https://habrastorage.org/webt/qc/zm/pr/qczmpr2oacz3cprgolpbb4ryhxm.png">  <em><strong>Gambar 6.</strong> Klasifikasi kerentanan yang relevan untuk SSL / TLS</em> </p><br><p>  Nah, untuk menambahkan satu sendok madu ke tong tar, perlu dicatat bahwa dalam [1] itu dijelaskan secara rinci / dimengerti / populer / kompeten bagaimana SSL harus dilaksanakan, dengan mengacu pada RFC.  Kami belum pernah menemukan deskripsi yang lebih baik, yang secara teknis akurat dan pada saat yang sama dapat dimengerti.  Juga di [1], perpustakaan SSL yang paling umum dianalisis, dengan klasifikasi berdasarkan tingkat abstraksi (tingkat rendah / tingkat tinggi).  Semua dengan diagram dan algoritma ringkas dalam pseudo-code.  Kerentanan produk tertentu dijelaskan secara rinci, dengan kode yang salah dan kode kesalahan.  Jadi jika tiba-tiba seseorang sekali lagi memiliki keinginan untuk membuat implementasi kerangka SSL / TLS, yang akan menjadi perkecualian untuk mengatakan "mereka menginginkan yang terbaik, tetapi ternyata seperti biasa", maka [1] adalah awal yang ideal untuk ini. </p><br><div class="spoiler">  <b class="spoiler_title">Daftar pustaka</b> <div class="spoiler_text"><p>  <strong>1.</strong> <em>Martin Georgiev, Rishita Anubhai, Subodh Iyengar.</em>  Kode Paling Berbahaya di Dunia: Memvalidasi Sertifikat SSL dalam Perangkat Lunak Non-Browser // Proses konferensi ACM 2012 tentang keamanan komputer dan komunikasi.  2012. hal.  38-49. <br>  <strong>2.</strong> <em>Tony Trummer.</em>  Kegagalan SSL Seluler // Proses Konferensi Keamanan HITB.  2015 <br>  <strong>3.</strong> <em>Kellen Evan Person.</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Kerja Ciphersuites: TLS dalam Potongan</a> // 2017. <br>  <strong>4.</strong> <em>Catalin Cimpanu.</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Extended Validation (EV) Certificate Disalahgunakan untuk Membuat Situs Phising yang Tidak Dapat</a> Dipercayai // BleepingComputer  2017 <br>  <strong>5.</strong> <em>David Adrian.</em>  A Retrospektif tentang Penggunaan Kriptografi Ekspor // Black Hat.  2016 <br>  <strong>6.</strong> <em>Sean Devlin.</em>  Lawan Nonce-Disrespecting: Serangan Pemalsuan Praktis pada GCM di TLS // Black Hat.  2016 <br>  <strong>7.</strong> <em>Jake Kambic.</em>  Cunning with CNG: Mengumpulkan Rahasia dari Schannel // Black Hat.  2016 <br>  <strong>8.</strong> <em>Valeria Bertacco.</em>  Menyiksa OpenSSL // Black Hat.  2012 <br>  <strong>9.</strong> <em>Tom van Goethem.</em>  HEIST: Informasi Enkripsi HTTP Dapat Dicuri Melalui TCP-Windows // Black Hat.  2016 <br>  <strong>10.</strong> <em>Artyom Gavrichenkov.</em>  Https Breaking Dengan BGP Hijacking // Black Hat.  2016 <br>  <strong>11.</strong> <em>Chris Stone, Tom Chothia.</em>  Spinner: Deteksi Pinning Tanpa Semi-Otomatis tanpa Verifikasi Hostname // Prosiding Konferensi Aplikasi Keamanan Komputer Tahunan (ACSAC) 2017. <br>  <strong>12.</strong> <em>Marco Ortisi.</em>  Pulihkan Kunci Pribadi RSA dari Sesi TLS dengan Perfect Forward Secrecy // Black Hat.  2016 </p><br><p>  <strong>PS.</strong>  Artikel ini awalnya diterbitkan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hacker</a> . </p></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454856/">https://habr.com/ru/post/id454856/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454832/index.html">Mengapa minggu kerja empat hari adalah kisah yang buruk</a></li>
<li><a href="../id454834/index.html">Istilah sebenarnya dari studi mengetik mengetik dengan motivasi rendah</a></li>
<li><a href="../id454840/index.html">Hati-hati pindah ke Belanda bersama istri dan hipoteknya. Bagian 2: menyiapkan dokumen dan memindahkan</a></li>
<li><a href="../id454844/index.html">Odigest: menarik bagi desainer untuk minggu ini</a></li>
<li><a href="../id454850/index.html">Evolusi algoritma tunggal</a></li>
<li><a href="../id454860/index.html">Mari kita bantu QueryProvider menangani string yang diinterpolasi</a></li>
<li><a href="../id454864/index.html">Bagaimana proses pengembangan di berbagai perusahaan</a></li>
<li><a href="../id454868/index.html">Kompilasi C di WebAssembly tanpa Emscripten</a></li>
<li><a href="../id454872/index.html">Space Invaders: sekarang dalam 512 byte (Assembler x86)</a></li>
<li><a href="../id454874/index.html">Sedikit tentang multitasking dalam mikrokontroler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>