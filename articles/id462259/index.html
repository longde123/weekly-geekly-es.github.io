<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ˜¡ ğŸ¤² ğŸ‘©ğŸ¾â€ğŸ³ Membuat pengontrol untuk rumah pintar ğŸ‘ƒğŸ½ ğŸ–•ğŸ¿ ğŸ†˜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami membuat pengontrol untuk rumah pintar dan tidak hanya. 

 Dalam artikel sebelumnya, saya menggambarkan pengembangan sistem secara keseluruhan. Da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membuat pengontrol untuk rumah pintar</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462259/">  Kami membuat pengontrol untuk rumah pintar dan tidak hanya. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dalam artikel sebelumnya,</a> saya menggambarkan pengembangan sistem secara keseluruhan.  Dalam hal ini, saya akan menjelaskan pengembangan pengontrol yang bertanggung jawab atas sensor polling dan modul I / O.  "Mengapa menemukan kembali kemudi?"  - kamu bertanya.  Pertama, ini menarik, dan kedua, anehnya, tidak ada solusi OpenSource untuk pengontrol yang mencakup perangkat lunak dan perangkat keras.  Artikel ini ditujukan untuk orang-orang yang sedikit berpengalaman dalam elektronik dan pengembangan linux tertanam. <br><br>  Membuat pengontrol, Anda katakan, sangat rumit - Anda perlu membuat papan, menulis perangkat lunak, mencetak kasing.  Namun dalam kenyataannya, semuanya sedikit lebih rumit, itulah yang dituangkan untuk saya, tetapi pada prinsipnya Anda benar: <br><a name="habracut"></a><br>  1. perangkat keras pengontrol <br><br>  - Pilihan papan cpu untuk controller <br>  - Pilihan pengontrol IO <br>  - Pilihan catu daya <br>  - blok diagram pengontrol <br>  - pengembangan papan silang untuk pengontrol <br>  - pengembangan papan untuk modul RS-485 <br>  - produksi papan <br><br>  2. perangkat lunak untuk pengontrol <br><br>  - Pilihan sistem bangun untuk kernel linux dan rootfs <br>  - struktur partisi kartu SD <br>  - pilihan bootloader dan memuat rootf yang diperlukan <br>  - perubahan pohon perangkat <br>  - pilihan sistem untuk mengumpulkan debet yang diperdagangkan <br>  - menulis sistem pembangunan <br>  - menulis inti komunikasi <br>  - menulis gateway mqtt (poin pengontrol diskrit / analog -&gt; topik mqtt) <br>  - Menulis parser Google dan membangun file konfigurasi json untuk gateway <br>  - menulis monitor titik untuk mengakses titik-titik pengontrol <br>  - mount sistem file hanya baca <br><br>  3. kasus pengontrol <br><br>  - Apa yang seharusnya, konektor, pendingin, kursi untuk papan, hipotek untuk klip untuk kurung pada dinrake. <br>  - desain dan pencetakan <br><br>  Beberapa kata tentang perangkat keras. <br><br>  Mungkin hanya yang paling putus asa sekarang mengambil prosesor terpisah, memori, flash, power controller, beberapa ratus komponen dan mulai memahat semuanya.  Sisanya menggunakan hasil kerja orang lain, lebih cepat dan lebih mudah.  Anda hanya perlu membuka browser dan menulis "komputer papan tunggal" dan menghabiskan sisa hari memilih yang tepat.  Saya membutuhkan banyak port serial dan diharapkan papan mendukung -40 Â° C hingga + 85 Â° C, sehingga pilihannya jatuh pada BeagleBone Black (BBB).  Juga pada BBB, semua periferal terhubung ke dua konektor PBD dari 46 pin dengan peningkatan 2,54, yang nyaman untuk pembuatan prototipe dan pengembangan papan-silang.  Diperlukan papan silang untuk menggabungkan semua komponen dalam satu papan, bagi saya itu adalah papan cpu, catu daya, pengontrol IO, dan papan saluran RS485.  Selain itu, papan silang inilah yang harus diperbaiki pada kasing dan ada konektor untuk daya dan kabel RS485. <br><br><img src="https://habrastorage.org/webt/oy/jo/6j/oyjo6jzy2qtidg-9ehm5zmtnqtg.jpeg"><br><br>  Jadi, kami menemukan papan cpu, hal berikutnya yang harus diputuskan adalah apakah perlu untuk menempatkan pengontrol Input / Output (IO) pada cross-board atau tidak.  Saya meletakkannya di papan tulis, dan saya belum berhasil menggunakannya.  Satu-satunya hal yang dia lakukan adalah menunda dimulainya BBB untuk 1s setelah menerapkan daya dan melayani tombol reset. <br><br>  Catu daya untuk controller, saya mengambil MeanWell NSD10-12S5 siap pakai, mengembangkannya untuk satu perangkat adalah usaha yang tidak berarti, saya hanya mengambilnya untuk konsumsi dan hanya itu.  Jangan memperhatikan LCD, ada di papan tulis, tapi saya tidak menerapkan dukungan. <br><br><img src="https://habrastorage.org/webt/uu/ub/hx/uuubhxrvgg7imxkdmtk6rjsojtu.jpeg"><br><br><img src="https://habrastorage.org/webt/hd/wn/l2/hdwnl2uo05wm6isu1pudumcx8zk.jpeg"><br><br>  Beberapa kata tentang kartu saluran RS485. <br><br>  Ada 4 antarmuka BBB serial pada papan silang.  Jadi di sana Anda dapat meletakkan semua jenis saluran yang Anda butuhkan, RS485, CAN, modul Zigbee ... <br><br>  Saya membutuhkan saluran RS485, jadi saya membuatnya hanya, mereka dengan kontrol transmisi / penerimaan otomatis dan dengan isolasi galvanik.  Mengapa tidak menggunakan kontrol transceiver dengan BBB, karena TI secara resmi berhenti mendukung strobo untuk RS485 pada driver perangkat serial.  Anda dapat menemukan tambalan untuk driver, Anda dapat menambahkannya sendiri, tetapi mengapa?  Setelah membuat saluran itu sendiri, Anda dapat meletakkannya di papan mana saja, misalnya, di RaspberyPi, di mana tidak pernah ada dukungan seperti itu, jika ada, maka perbaiki saya.  Strobo untuk driver rs485 dikonfigurasi pada attiny10, murah dan ceria. <br><br>  Kami kembali ke perangkat lunak. <br><br>  Memilih sistem build untuk kernel linux dan rootfs. <br><br>  Ada beberapa sistem semacam ini, yang paling populer adalah Yocto dan BuildRoot.  Jika Anda perlu mengembangkan proyek besar, jika Anda punya banyak waktu dan keinginan untuk menulis resep, maka Yocto adalah pilihan Anda.  Dengan bantuan BuildRoot, Anda dapat mengumpulkan semua yang Anda butuhkan untuk peluncuran papan yang sederhana sangat, sangat sederhana, karena  Saya membuat sistem di Beaglebone Black (selanjutnya BBB) kemudian: <br><br><ol><li>  baca apa yang tertulis di sini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/en/post/448638</a> </li><li>  bersihkan </li><li>  buat beaglebone_defconfig </li><li>  membuat </li></ol><br>  Itu saja.  Sekarang semua yang Anda butuhkan untuk menjalankan papan terletak di folder / buildroot / output / images. <br><br>  Semuanya terlihat sangat sederhana dan tidak menarik, sehingga Anda bisa melakukan sedikit lebih rumit: <br><br><ol><li>  mengintegrasikan buildroot ke sistem build Anda, mengunduhnya dengan skrip, ingat untuk menggunakan tag stabil, dan jangan mengambil pengembangan terakhir </li><li>  tulis defconfig Anda dan letakkan skrip di folder / buildroot / configs sebelum merakit buildroot, jangan lupa bahwa semua defconfigs harus diakhiri dengan * _defconfig, jika tidak buildroot tidak melihatnya </li><li>  salin post-build.sh Anda ke board / beaglebone / post-build.sh </li><li>  buat skrip yang akan melakukan n1, n2 dan n3 untuk Anda </li></ol><br>  Akibatnya, buildroot akan menghasilkan zImage dan rootfs.tar <br><br>  Memilih struktur partisi kartu SD: <br><br>  Mengenai hal ini, saya pikir, tidak perlu memusatkan banyak perhatian. <br>  Saya membuat 4 bagian BOOT / ROOT_1 / ROOT_2 / DATA. <br>  Bagian BOOT berisi semua yang Anda butuhkan untuk bootstrap: MLO, barebox.bin, barebox.env, am335x-boneblack.dtb, zImage, boot.txt. <br><br>  ROOT_1 dan ROOT_2 berisi rootfs, pilihannya ditulis dalam file boot.txt (lihat di bawah).  Semua partisi ini dipasang sebagai hanya baca untuk menghindari crash sistem file ketika daya dimatikan.  DATA berisi konfigurasi desain, ketika mengubah yang tidak perlu membangun kembali kode. <br><br>  Struktur partisi seperti itu di masa depan akan membuatnya mudah untuk menulis komponen pembaruan perangkat lunak.  Komponen ini akan menimpa salah satu bagian ROOT_1 / ROOT_2, yang tidak digunakan sekarang, dan kemudian hanya mengubah file boot.txt jika Anda tidak perlu mengubah kernel. <br><br>  Memilih bootloader. <br><br>  Saya punya banyak percobaan dengan bootloader untuk BBB.  Pada awalnya saya menggunakan, seperti semua orang, U-Boot yang dihasilkan BuildRoot.  Tetapi saya tidak menyukainya, mungkin, tentu saja, ini masalah kebiasaan, tetapi bagi saya sepertinya terlalu banyak, sangat berat dan sulit dikonfigurasikan.  Kemudian, saya berpikir bahwa tidak akan buruk untuk memulai sistem dengan cepat, dalam 2-3 detik, dan mengajukan X-Loader sehingga akan memuat kernel, saya berhasil, tetapi sekali lagi ada masalah konfigurasi, dan waktu mulai untuk saya tidak kritis (sistem pada boot sistemd dengan sendirinya dengan sendirinya, bahkan jika Anda menghapus semua yang tidak diperlukan). <br><br>  Pada akhirnya, saya memilih barebox, saya sangat menyukai kesederhanaannya, plus situs tersebut memiliki semua dokumentasi (www.barebox.org). <br><br>  Misalnya, untuk memuat rootfs dari partisi pertama atau kedua, Anda hanya perlu: <br><br>  1. pada bagian boot, buat file boot.txt yang akan mengekspor variabel tipe â€œexport BOOT_NUM = Xâ€ <br><br>  2. buat dua skrip / env / boot / sdb1 / env / boot / sdb2 untuk menjelaskan opsi-opsi boot, misalnya: <br><br><pre><code class="plaintext hljs">echo "botting with mmcblk0p2 as rootfs..." global.bootm.image=/boot/zImage global.bootm.oftree=/boot/am335x-boneblack.dtb global.linux.bootargs.console="console=ttyO0,115200" global.linux.bootargs.debug="earlyprintk ignore_loglevel" global.linux.bootargs.base="root=/dev/mmcblk0p2 ro rootfstype=ext4 rootwait"</code> </pre> <br>  3. buat skrip / env / boot / sd di mana, tergantung pada BOOT_NUM, mulai skrip sdb1 atau sdb2 <br><br>  4. atur variabel boot.default <br><br><pre> <code class="plaintext hljs">nv boot.default=sd saveenv</code> </pre> <br>  5. Lebih lanjut mengubah BOOT_NUM di boot.txt kami akan memuat rootfs dari partisi pertama atau kedua, yang di masa depan dapat digunakan untuk pembaruan perangkat lunak. <br><br>  Perubahan ke bagan perangkat. <br><br>  Karena saya menggunakan MODBUS RTU via RS485 untuk berkomunikasi dengan modul, saya perlu mengaktifkan hampir semua port serial yang ada di BBB.  Untuk melakukan ini, Anda harus mengaktifkannya kembali di pohon perangkat, karena  Secara default, sebagian besar dimatikan. <br><br>  Itu akan benar untuk membuat tambalan Anda untuk file am335x-bone-common.dtsi dari paket buildrut dan menerapkannya setiap kali sebelum merakitnya, tetapi kemalasan menang dan saya hanya mengeluarkan semua file yang saya butuhkan, mengubah semua yang saya butuhkan dan membangunnya dengan tangan saya. <br><br>  Karena  ini dilakukan sekali, itu mungkin dan jadi: <br><br>  1. Buat folder dengan file yang diperlukan untuk perakitan: <br><br><pre> <code class="plaintext hljs">am335x-bone-common.dtsi am335x-boneblack-common.dtsi am335x-boneblack.dts am33xx-clocks.dtsi am33xx.dtsi am33xx.h gpio.h omap.h tps65217.dtsi</code> </pre> <br>  2. Dalam file am335x-bone-common.dtsi, Anda harus mengonfigurasi pin dengan benar dan tidak mengaktifkan driver port: <br><br><pre> <code class="plaintext hljs">uart1_pins: pinmux_uart1_pins { pinctrl-single,pins = &lt; AM33XX_IOPAD(0x980, PIN_INPUT_PULLUP | MUX_MODE0) AM33XX_IOPAD(0x984, PIN_OUTPUT_PULLDOWN | MUX_MODE0) &gt;; }; uart2_pins: pinmux_uart2_pins { pinctrl-single,pins = &lt; AM33XX_IOPAD(0x950, PIN_INPUT_PULLUP | MUX_MODE1) AM33XX_IOPAD(0x954, PIN_OUTPUT_PULLDOWN | MUX_MODE1) &gt;; }; uart4_pins: pinmux_uart4_pins { pinctrl-single,pins = &lt; AM33XX_IOPAD(0x870, PIN_INPUT_PULLUP | MUX_MODE6) AM33XX_IOPAD(0x874, PIN_OUTPUT_PULLDOWN | MUX_MODE6) &gt;; }; uart5_pins: pinmux_uart5_pins { pinctrl-single,pins = &lt; AM33XX_IOPAD(0x8C4, PIN_INPUT_PULLUP | MUX_MODE4) AM33XX_IOPAD(0x8C0, PIN_OUTPUT_PULLDOWN | MUX_MODE4) &gt;; }; &amp;uart1 { pinctrl-names = "default"; pinctrl-0 = &lt;&amp;uart1_pins&gt;; status = "okay"; }; &amp;uart2 { pinctrl-names = "default"; pinctrl-0 = &lt;&amp;uart2_pins&gt;; status = "okay"; }; &amp;uart4 { pinctrl-names = "default"; pinctrl-0 = &lt;&amp;uart4_pins&gt;; status = "okay"; }; &amp;uart5 { pinctrl-names = "default"; pinctrl-0 = &lt;&amp;uart5_pins&gt;; status = "okay"; };</code> </pre><br>  3. Selanjutnya, sedikit keajaiban, dan file selesai am335x-boneblack.dtb terletak di direktori yang sama: <br><br><pre> <code class="plaintext hljs">a. sudo apt-get install device-tree-compiler</code> </pre> <br>  b.  jalankan preprocessor: <br><br><pre> <code class="plaintext hljs">cpp -Wp,-MD,am335x-boneblack.dtb.d.pre.tmp -nostdinc -Iinclude -Isrc -Itestcase-data -undef -D__DTS__ -x assembler-with-cpp -o am335x-boneblack.dtb.dts.tmp am335x-boneblack.dts</code> </pre> <br>  c.  jalankan kompiler itu sendiri: <br><br><pre> <code class="plaintext hljs">dtc -O dtb -o am335x-boneblack.dtb -b 0 -i src -d am335x-boneblack.dtb.d.dtc.tmp am335x-boneblack.dtb.dts.tmp</code> </pre> <br>  4. am335x-boneblack.dtb harus diletakkan di partisi boot di sebelah kernel dan di skrip startup untuk barebox tambahkan baris berikut - " <code>global.bootm.oftree=/boot/am335x-boneblack.dtb</code> " <br><br>  Memilih sistem untuk mengumpulkan debet yang diperdagangkan. <br><br>  Seperti yang Anda ketahui, sistem tanpa bug tidak ada, serta analisis sistem multi-utas tanpa jejak.  Sangat mudah jika jejak-jejak ini tidak ditampilkan hanya di konsol, tetapi dikumpulkan menggunakan sesuatu yang khusus dibuat untuk ini, sehingga akan mungkin untuk mengurutkannya berdasarkan proses, menerapkan filter, dll.  Dan saya hanya tahu satu sistem bagus yang mudah dibangun di bawah host dan target.  Ini adalah DLT, jika Anda belum pernah mendengar tentang ini, maka itu tidak masalah, semua kesenjangan pengetahuan dapat dengan mudah ditutupi dengan membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di.projects.genivi.org/wiki/display/PROJ/Diagnostic+Log+and+Trace</a> . <br>  Sistem ini terdiri dari dlt-daemon dan dlt-viewer.  Seperti namanya, dlt-daemon berjalan pada target, dan dlt-viewer pada host.  Plus untuk semua ini, ke biner Anda, dari mana kami ingin mengumpulkan jejak, Anda perlu menautkan lib lib. <br><br><img src="https://habrastorage.org/webt/oi/go/b-/oigob-peuxj5pdvmkdr0vzu5wkc.png"><br><br>  Secara umum, semuanya nyaman, bagaimana mengumpulkan jejak dan menganalisisnya, saya sarankan. <br><br>  Menulis sistem pembangunan. <br><br>  Mengapa menulis sistem build, karena Anda dapat mengunduh semuanya dari repositori, membangunnya dengan tangan Anda, membangun berdasarkan rootfs dan cadar ini, pengontrol berfungsi.  Tetapi untuk mengulangi trik semacam itu dalam sebulan akan lebih sulit, dan dalam dua - ini umumnya tidak mungkin.  Sekali lagi, Anda harus mengingat apa, di mana harus meletakkan, apa yang harus dibangun dan bagaimana memulainya.  Oleh karena itu, setelah menghabiskan banyak waktu pada awalnya, Anda menyimpannya nanti, plus Anda mendapatkan kesempatan untuk membangun dengan nyaman di bawah host dan target.  Sistem build terdiri dari sekumpulan skrip yang pertama-tama menyiapkan host untuk build, mengunduh komponen pihak ketiga, seperti buildroot, mosquitto, DLT daemon, dari repositori mereka, membangunnya, meletakkannya di tempat mereka.  Dan kemudian Anda dapat meluncurkan pembangunan proyek Anda.  Jika build di bawah host tidak sulit dilakukan, maka Anda harus selalu mengutak-atik build di bawah target, dan akan lebih baik jika skrip melakukannya. <br><br>  Buildroot dapat dikonfigurasi sehingga menjalankan skrip post-build setelah membentuk rootfs, yang akan terletak di buildroot / output / target.  Ini memberi Anda peluang besar untuk meletakkan semua yang Anda butuhkan di sana.  Dan kemudian, gambar sistem file sudah akan berisi semua yang Anda butuhkan untuk memulai sistem Anda. <br><br>  Resepnya kira-kira seperti ini: <br><br><ol><li>  Anda perlu menyalin binari Anda di suatu tempat di buildroot / output / target, misalnya di / opt / bin </li><li>  jika ada konfigurasi, maka lakukan hal yang sama dengannya, hanya di / opt / etc </li><li>  salin binari pihak ketiga, bagi saya itu mosquitto, daemon DLT, lib dan konfigurasi mereka </li><li>  Untuk memulai sistem itu sendiri ketika memuat controller, Anda perlu menyalin layanan systemd Anda, lebih baik untuk menggabungkannya ke target Anda dan mengaktifkannya kembali dengan membuat symlink di multi-user. </li><li>  salin fstab yang dimodifikasi (mengapa, saya akan memberi tahu Anda nanti) </li></ol><br>  Setelah itu, Anda hanya perlu membongkar buildroot / output / images / rootfs.tar ke bagian yang diinginkan dari kartu SD dan nyalakan daya. <br><br><pre> <code class="plaintext hljs">build git repo: https://github.com/azhigaylo/build</code> </pre> <br>  Menulis inti komunikasi. <br><br>  Konsep ini setua modbus itu sendiri. <br><br>  Setiap perangkat I / O dalam jaringan modbus memiliki (16 bit) register yang tersedia untuk membaca, membaca / menulis, di mana data disimpan dan melalui mana perangkat ini dikendalikan.  Controller, pada gilirannya, memiliki array diskrit (status dan nilai byte) dan titik analog (status dan nilai float), di mana ia menyimpan status semua parameter. <br><br>  Jadi, tugas inti komunikasi sederhana - mengumpulkan data dari perangkat I / O menggunakan protokol modbus, memetakannya ke titik-titik pengontrol dan menyediakan akses ke titik-titik ini untuk tingkat atas.  Dan jika Anda perlu mengelola sesuatu, maka semuanya ada di arah lain - perangkat logis (lebih lanjut tentang itu nanti) harus berlangganan ke titik pengontrol dan menulis ke titik ini memulai terjemahan parameter ini ke perangkat output air fisik. <br><br><img src="https://habrastorage.org/webt/1v/zb/x4/1vzbx4smmroaleak2dy4jol9gno.jpeg"><br><br>  Untuk menyusun data dan bekerja dengan perangkat, Anda dapat memperkenalkan konsep perangkat logis yang akan menampilkan keadaan perangkat fisik di perangkat lunak Anda. <br><br>  Saya juga memutuskan untuk membagi perangkat logis menjadi dua kelompok: <br><br><ol><li>  Standar (modul Aries input / output diskrit), yang jumlah modbus register dengan datanya diketahui sebelumnya, dan itu cukup hanya untuk menentukan titik-titik pengontrol tempat menyimpan data ini. </li><li>  Perangkat pengguna, bagi mereka perlu untuk secara mandiri menggambarkan pemetaan register modbus ke titik-titik pengontrol. </li></ol><br>  Dari semua hal di atas, masuk akal untuk memiliki semacam konfigurator untuk pengontrol, apakah itu hanya konfigurasi json atau alat yang ditulis sendiri yang menghasilkan konfigurasi biner, apa pun yang sesuai.  Saya memiliki pilihan kedua, karena ada ide untuk menulis inti komunikasi sehingga dapat dengan mudah dijalankan tidak hanya pada papan Linux tetapi juga pada Arduin dengan FreeRtos, mengubah level PAL dalam perangkat lunak. <br><br>  Di konfigurator untuk setiap perangkat, Anda perlu mengatur nomor port pengontrol rs485, alamat perangkat, dan titik pengontrol di mana status komunikasi dengan perangkat ditampilkan, plus untuk setiap perangkat standar salurannya dijelaskan, dan untuk perangkat pengguna, registernya dipetakan ke titik-titik. <br><br><img src="https://habrastorage.org/webt/p7/gh/cu/p7ghcubristizrus5hzq_zlfo5i.jpeg"><br><br><img src="https://habrastorage.org/webt/xr/go/nk/xrgonkcogvsn-6j2vjktiiryrlw.jpeg"><br><br>  File konfigurasi seperti itu, yang berisi semua data yang diperlukan pada pembangunan jaringan modbus, memungkinkan Anda untuk tidak mengubah kode sumber untuk proyek jika Anda perlu menambah / menghapus / mengubah perangkat input / output, cukup untuk mengubah parameter dalam konfigurator dan menyimpannya dalam file konfigurasi. <br><br>  Pada saat startup, inti komunikasi mem-parsing konfigurasi dan membuat berdasarkan daftar perangkat logis untuk setiap port controller rs485, kemudian utas dibuat untuk setiap port dan polling siklik perangkat fisik dimulai. <br><br><pre> <code class="plaintext hljs">core git repo: https://github.com/azhigaylo/homebrain_core</code> </pre> <br>  Menulis gateway mqtt. <br><br>  Sebenarnya - titik pengontrol Anda, baik diskrit maupun analog, dengan antarmuka berpemilik untuk mengaksesnya, tidak terlalu menarik bagi siapa pun.  Jadi hanya ada satu jalan keluar - mqtt.  Saya pikir saya tidak akan melebih-lebihkan jika saya mengatakan bahwa ini adalah protokol yang paling umum untuk bertukar pesan kecil, plus itu sangat sederhana dan dapat dimengerti untuk digunakan.  Jadi ketika saya perlu mengirimkan data dari controller - saya tidak berpikir panjang tentang apa yang harus digunakan. <br><br><img src="https://habrastorage.org/webt/o_/sf/w0/o_sfw0yj5i-ptu7ohxdqdvnmw68.jpeg"><br><br>  Karena  Saya memiliki banyak parameter, lalu selalu ada kebingungan dalam file konfigurasi gateway, di mana pemetaan titik-titik pengontrol ke topik mqtt gateway didaftarkan.  Google membantu tabel, dan menulis parser csv dari tabel ini di file konfigurasi json untuk gateway. <br><br><img src="https://habrastorage.org/webt/b-/wt/zm/b-wtzmutugygf-_8mj5odnnrguw.jpeg"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gateway git repo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">parser git repo</a> <br><br>  Monitor titik penulisan. <br><br>  Terkadang sangat berguna untuk melihat apa yang terjadi dengan titik-titik pengontrol, untuk ini saya menulis sebuah aplikasi kecil yang terhubung langsung ke inti komunikasi dan membaca status titik-titik diskrit dan analog.  Saya cukup akrab dengan UI, jadi saya dapat entah bagaimana membuang aplikasi ke QML, itu bekerja dengan derit, Anda dapat menghitung poinnya, Anda dapat menulisnya, tetapi saya tidak membutuhkan lebih banyak. <br><br><pre> <code class="plaintext hljs">pointmonitor git repo: https://github.com/azhigaylo/pointmonitor</code> </pre> <br>  Pasang sistem file hanya baca. <br><br>  Biasanya, beberapa orang memperhatikan ini, dan bahkan dalam proyek produksi, Anda dapat menemukan perangkat di mana partisi dengan rootfs dapat ditulis.  Cepat atau lambat ini menyebabkan crash pada semua, bahkan sistem file yang paling stabil.  Karena  Karena pengontrol dapat dimatikan kapan saja, itu hanya masalah waktu / kasus ketika ini terjadi.  Untuk meminimalkan probabilitas ini, Anda perlu sedikit mengotak-atik fstab, dan sebelum membangun gambar rootfs, letakkan di sana, seperti dijelaskan di atas.  Di fstab, pertama, Anda perlu me-mount sistem file sebagai hanya baca, dan kedua, semua yang dapat diubah dapat dipetakan ke tmpfs. <br><br>  Fstab saya adalah ini, mungkin berbeda untuk Anda: <br><br><pre> <code class="plaintext hljs">/dev/root / auto ro 0 1 tmpfs /tmp tmpfs nodev,nosuid,size=50M 0 0 tmpfs /srv tmpfs nodev,size=50M 0 0 tmpfs /var/log tmpfs defaults,noatime,size=50M 0 0 tmpfs /var/tmp tmpfs defaults,noatime,size=50M 0 0 tmpfs /var/run tmpfs defaults,noatime,size=50M 0 0 tmpfs /var/lib tmpfs defaults,noatime,size=10M 0 0</code> </pre> <br>  Badan pengontrol <br><br>  Sebuah printer 3D telah lama dimasukkan dalam bagian masthead untuk setiap insinyur petani kolektif, sayangnya saya tidak memilikinya, tetapi sedang bekerja.  Baru-baru ini, kegembiraan karyawan lain untuknya telah hilang, saya menggunakan ini ketika mencetak semua yang saya butuhkan dan tidak perlu, Anda bisa diyakinkan dengan membaca posting saya sebelumnya. <br><br>  Kami menggambar di FreeCAD, kami menghasilkan gcode di Cura dan kami mendapatkan kasing, tanpa lupa membuat kursi untuk papan, guntingan untuk konektor dan pendingin dan hipotek untuk klip pada rel din. <br><br><img src="https://habrastorage.org/webt/7m/yc/y6/7mycy6gz9axqfvspdk_cmyz5oc8.jpeg"><br><br><img src="https://habrastorage.org/webt/j5/i3/dv/j5i3dvtfcb8wkpn1t0uphq7d9lg.jpeg"><br><br>  Nah, itu saja, sekarang kami memiliki papan, perangkat lunak pada kartu SD dan kasing.  Kami mengambil file (saya tidak bercanda) dan menghubungkan semuanya bersama-sama, menghubungkan daya, kabel RS485 dan semuanya mulai berfungsi.  Dan Anda berkata sulit, sulit ... </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462259/">https://habr.com/ru/post/id462259/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462243/index.html">Meningkatkan Kinerja Front-end Magento Dengan ReactJS</a></li>
<li><a href="../id462245/index.html">auto git membagi dua sebagai contoh dari kernel Linux</a></li>
<li><a href="../id462251/index.html">Apakah mode penyamaran di browser adalah fiksi?</a></li>
<li><a href="../id462253/index.html">Eksperimen pertama menggunakan protokol streaming pada contoh CPU dan komunikasi prosesor di Redd FPGA</a></li>
<li><a href="../id462257/index.html">Kafka di Kubernetes - apakah itu bagus?</a></li>
<li><a href="../id462263/index.html">Pedal ke lantai: buat manipulator kaki lain untuk PC</a></li>
<li><a href="../id462265/index.html">Python dan kubus</a></li>
<li><a href="../id462267/index.html">Mengenal Penganalisis Statis PVS-Studio untuk Java</a></li>
<li><a href="../id462269/index.html">John Romero to Doom: 80s Game Dev</a></li>
<li><a href="../id462271/index.html">Kode kunci di iOS: bagaimana Apple beralih dari pertahanan ke pertahanan untuk menjaga satu perbatasan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>