<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐣 🤷🏼 🧜🏽 SQL HowTo: création de chaînes à l'aide de fonctions de fenêtre 👨‍💼 👨‍👧‍👦 🤚🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parfois, lors de l'analyse des données, le problème se pose de distinguer des «chaînes» dans un échantillon - c'est-à-dire des séquences ordonnées d' ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SQL HowTo: création de chaînes à l'aide de fonctions de fenêtre</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483460/">  Parfois, lors de l'analyse des données, le <b>problème</b> se pose de <b>distinguer des «chaînes» dans un échantillon</b> - c'est-à-dire des <u>séquences ordonnées d'</u> enregistrements, pour chacune desquelles <u>une certaine condition est remplie</u> . <br><br>  Cela peut être soit une condition sur les données de l'enregistrement lui-même, soit une expression complexe par rapport à un ou plusieurs enregistrements précédents - par exemple, la longueur de l'intervalle entre les échantillons de temps de fermeture. <br><br><img src="https://habrastorage.org/webt/fx/nc/ld/fxncldmr0bpfaufpa2tosjozqy8.png"><br><br>  Les solutions traditionnelles offrent différentes options de «self join», lorsque l'échantillon se connecte à lui-même, ou l'utilisation de certains faits «en dehors des données» - par exemple, que les enregistrements doivent avoir une étape strictement définie (N + 1, «pour chaque jour», ... ) <br><br>  La première option conduit souvent à la <b>complexité quadratique de l'</b> algorithme en termes de nombre d'enregistrements, ce qui est <a href="https://habr.com/ru/post/479298/">inacceptable dans les grands échantillons</a> , et la seconde <b>peut facilement «s'effondrer»</b> s'il n'y a soudainement aucun échantillon dans les données source. <br><br>  Mais cette tâche nous aidera à résoudre efficacement <a href="https://postgrespro.ru/docs/postgresql/12/functions-window" rel="nofollow">les fonctions de fenêtre</a> dans PostgreSQL. <br><a name="habracut"></a><br><h2>  Tâche: compter l'argent des autres </h2><br>  Prenons le cas le plus simple d'une chaîne - lorsque la condition de continuité est déterminée par les données de l'enregistrement lui-même. <br><br>  Toutes les autres opérations ne doivent pas être effectuées séparément.  Mais dans un souci de clarté de l'algorithme, je vais le décomposer en étapes successives, et <u>à la fin je montrerai quoi et comment optimiser</u> . <br><br>  Imaginons que nous ayons une petite banque qui gère les soldes des comptes clients dans le tableau.  Dès que la réception et la transaction des dépenses ont lieu, cette date est utilisée pour enregistrer le montant total de la facture à la fin de la journée. <br><blockquote>  Après de longues vacances du Nouvel An, la banque a décidé de récompenser ses clients - et chaque personne qui a ouvert un compte cette année accumule en outre + 1% du <u>solde quotidien moyen</u> pour <b>la plus longue période continue</b> lorsque le <u>compte n'a pas été «réinitialisé»</u> . </blockquote>  Il s'agit ici de notre critère de continuité de la "chaîne".  Eh bien, l'ordre des données sera déterminé par les dates des soldes. <br><br>  Ils nous ont apporté un tel CSV et ont demandé de calculer rapidement qui et combien une telle générosité de la banque devrait obtenir: <br><br><pre><code class="plaintext hljs">date;client;balance 01.01.2020;;150 01.01.2020;;100 02.01.2020;;100 02.01.2020;;150 03.01.2020;;200 05.01.2020;;0 06.01.2020;;50 08.01.2020;;0 08.01.2020;;200 09.01.2020;;0 09.01.2020;;0 10.01.2020;;5</code> </pre> <br>  Il suffit de noter quelques faits notables sur ces données: <br><br><ul><li>  01.01 était un jour férié, et la banque n'a pas fonctionné.  Par conséquent, aucun des clients n'a enregistré de changements dans le solde ce jour-là, mais ils ont de l'argent dans leurs comptes.  Autrement dit, les algorithmes de "force brute" qui itèrent le jour ne fonctionneront pas normalement. </li><li>  04.01 Alice n'a effectué aucune opération, il n'y a donc pas d'entrée.  Mais avant le 05.01, le montant sur son compte était non nul - cela devra être pris en compte dans l'analyse. </li><li>  Nous effectuons l'analyse le 01.01-12.01, mais le solde du compte d'Alice à la fin de cette période est non nul.  Nous tenons également compte de la nécessité de limiter la période. </li></ul><br><h2>  CSV à table </h2><br>  La meilleure façon d'importer depuis CSV est d' <a href="https://www.postgresqltutorial.com/import-csv-file-into-posgresql-table/" rel="nofollow">utiliser l'opérateur COPY</a> .  Mais nous allons essayer de le faire à travers des expressions régulières pour nous échauffer: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TEMPORARY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to_date</span></span>(prt[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'DD.MM.YYYY'</span></span>) dt , prt[<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">client</span></span> , prt[<span class="hljs-number"><span class="hljs-number">3</span></span>]::<span class="hljs-built_in"><span class="hljs-built_in">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) balance <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> regexp_split_to_array(<span class="hljs-keyword"><span class="hljs-keyword">str</span></span>, <span class="hljs-string"><span class="hljs-string">';'</span></span>) prt <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> regexp_split_to_table( $$ <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>;client;balance 01.01.2020;;150 01.01.2020;;100 02.01.2020;;100 02.01.2020;;150 03.01.2020;;200 05.01.2020;;0 06.01.2020;;50 08.01.2020;;0 08.01.2020;;200 09.01.2020;;0 09.01.2020;;0 10.01.2020;;5 $$ , E'\\n') str ) T WHERE str &lt;&gt; '' OFFSET 1 ) T;</code> </pre> <br>  Il s'agit d'une méthode «malhonnête» dans le sens où elle ne digère pas correctement, par exemple en protégeant un séparateur dans le corps d'un champ.  Mais pour la plupart des applications simples - adaptées. <br><br><h2>  Étape 1: corriger la condition de l'application </h2><br>  Dans notre cas, la condition de continuité de chaîne est un équilibre non nul.  Nous l'avons affiché dans un champ séparé, pour plus de clarté, en ordre chronologique par client: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * , balance &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> cond <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">client</span></span>, dt;</code> </pre><br><pre> <code class="plaintext hljs">dt | client | balance | cond ------------------------------------ 2020-01-01 |  | 150.00 | t 2020-01-02 |  | 100.00 | t 2020-01-03 |  | 200.00 | t 2020-01-05 |  | 0.00 | f 2020-01-06 |  | 50.00 | t 2020-01-08 |  | 0.00 | f 2020-01-09 |  | 0.00 | f 2020-01-10 |  | 5.00 | t 2020-01-01 |  | 100.00 | t 2020-01-02 |  | 150.00 | t 2020-01-08 |  | 200.00 | t 2020-01-09 |  | 0.00 | f</code> </pre><br><h2>  Étape 2: Calculez les disparus </h2><br>  Notez que le montant de Bob n'a pas changé du 02.01 au 08.01.  Et selon les conditions du problème, nous devons calculer le reste <u>quotidien moyen</u> - c'est-à-dire que nous avons besoin d'informations sur ces jours «manqués».  Ou au moins le nombre de jours où la valeur est restée la même: <br><br><pre> <code class="sql hljs">coalesce(lead(dt) OVER(PARTITION BY client ORDER BY dt), '2020-01-12') - dt days</code> </pre> <br><pre> <code class="plaintext hljs">dt | client | balance | cond | days ------------------------------------------- 2020-01-01 |  | 150.00 | t | 1 2020-01-02 |  | 100.00 | t | 1 2020-01-03 |  | 200.00 | t | 2 2020-01-05 |  | 0.00 | f | 1 2020-01-06 |  | 50.00 | t | 2 2020-01-08 |  | 0.00 | f | 1 2020-01-09 |  | 0.00 | f | 1 2020-01-10 |  | 5.00 | t | 2 2020-01-01 |  | 100.00 | t | 1 2020-01-02 |  | 150.00 | t | 6 2020-01-08 |  | 200.00 | t | 1 2020-01-09 |  | 0.00 | f | 3</code> </pre><br>  En utilisant <a href="https://postgrespro.ru/docs/postgresql/12/functions-window" rel="nofollow">la fonction de fenêtre lead (),</a> nous avons appris la date du <u>prochain</u> enregistrement dans l'ordre, et par <b>fusion, nous avons</b> limité l'intervalle pour le dernier.  Dans le même temps, ils ont utilisé la propriété utile que la <b>différence de deux dates dans PostgreSQL renvoie un nombre entier de jours</b> entre elles. <br><br>  En bonus presque gratuit, nous avons obtenu les mêmes informations pour les enregistrements avec un solde nul.  Mais s'il y a beaucoup de lignes avec une condition non remplie qui ne nous intéressent pas, il est logique <a href="https://habr.com/ru/post/479508/">de conduire de</a> tels <a href="https://habr.com/ru/post/479508/">calculs sous CASE</a> afin d'économiser les ressources du serveur. <br><br><h2>  Étape 3: Trouvez les points d'arrêt </h2><br>  Le début de chaque chaîne qui nous intéresse est le point où la valeur de la condition précédemment calculée change par rapport à l'enregistrement <u>précédent</u> .  Nous utiliserons la fonction <b>lag ()</b> pour trouver de tels points: <br><br><pre> <code class="sql hljs">lag(cond) OVER(PARTITION BY client ORDER BY dt) IS DISTINCT FROM cond chain_start</code> </pre> <br><pre> <code class="plaintext hljs">dt | client | balance | cond | days | chain_start --------------------------------------------------------- 2020-01-01 |  | 150.00 | t | 1 | t 2020-01-02 |  | 100.00 | t | 1 | f 2020-01-03 |  | 200.00 | t | 2 | f 2020-01-05 |  | 0.00 | f | 1 | t 2020-01-06 |  | 50.00 | t | 2 | t 2020-01-08 |  | 0.00 | f | 1 | t 2020-01-09 |  | 0.00 | f | 1 | f 2020-01-10 |  | 5.00 | t | 2 | t 2020-01-01 |  | 100.00 | t | 1 | t 2020-01-02 |  | 150.00 | t | 6 | f 2020-01-08 |  | 200.00 | t | 1 | f 2020-01-09 |  | 0.00 | f | 3 | t</code> </pre><br>  En utilisant l'opérateur <b>IS DISTINCT FROM</b> au lieu de &lt;&gt;, nous avons évité les problèmes de comparaison avec NULL pour les premiers enregistrements de chaque client.  En conséquence, toutes les lignes où la valeur TRUE est le début d'une nouvelle chaîne et FALSE est sa continuation. <br><br><h2>  Étape 4: enchaînez les liens </h2><br>  Pour regrouper des données au sein de chaque chaîne individuelle, il est plus facile d'attribuer <b>le même identifiant</b> à tous ses enregistrements.  Le numéro de série de la chaîne elle-même est parfait pour elle.  Et il est exactement égal au <b>nombre de «débuts» de chaînes</b> qui ont été trouvés plus haut dans l'échantillon. <br><br>  Ils peuvent être calculés soit par la somme «fenêtre» de la somme des valeurs booléennes ({boolean} :: integer), soit en comptant le nombre d'enregistrements correspondant à la condition count (*) FILTER (WHERE {boolean}).  Nous utiliserons la deuxième option: <br><br><pre> <code class="sql hljs">count(*) FILTER(WHERE chain_start) OVER(PARTITION BY client ORDER BY dt) grpid</code> </pre> <br><pre> <code class="plaintext hljs">dt | client | balance | cond | days | chain_start | grpid ----------------------------------------------------------------- 2020-01-01 |  | 150.00 | t | 1 | t | 1 2020-01-02 |  | 100.00 | t | 1 | f | 1 2020-01-03 |  | 200.00 | t | 2 | f | 1 2020-01-06 |  | 50.00 | t | 2 | t | 2 2020-01-10 |  | 5.00 | t | 2 | t | 3 2020-01-01 |  | 100.00 | t | 1 | t | 1 2020-01-02 |  | 150.00 | t | 6 | f | 1 2020-01-08 |  | 200.00 | t | 1 | f | 1</code> </pre><br>  À cette étape, nous connaissons déjà la longueur de tous les maillons de chaque chaîne, nous n'avons plus besoin d'enregistrements "sans intérêt", il suffit donc de les filtrer. <br><br><h2>  Étape 5: Mettre les chaînes </h2><br>  Pour calculer la moyenne de tous les jours d'une chaîne, nous avons besoin du nombre total de jours et du solde «intégral»: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">client</span></span> , <span class="hljs-keyword"><span class="hljs-keyword">min</span></span>(dt) chain_dt , <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">days</span></span> * balance) balance , <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">days</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">days</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, grpid <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, grpid;</code> </pre> <br><pre> <code class="plaintext hljs">client | chain_dt | balance | days -------------------------------------  | 2020-01-01 | 650.00 | 4  | 2020-01-06 | 100.00 | 2  | 2020-01-10 | 10.00 | 2  | 2020-01-01 | 1200.00 | 8</code> </pre><br><h2>  Étape 6: recherche de sommets appliqués </h2><br>  En utilisant <b>DISTINCT ON,</b> nous laisserons un seul enregistrement (avec une valeur maximale de jours) pour chaque client: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DISTINCT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">client</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">client</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">days</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre> <br><pre> <code class="plaintext hljs">client | chain_dt | balance | days -------------------------------------  | 2020-01-01 | 650.00 | 4  | 2020-01-01 | 1200.00 | 8</code> </pre><br>  En fait, c'est tout, tout ce qui reste est ... <br><br><h2>  Nous combinons et optimisons </h2><br><div class="spoiler">  <b class="spoiler_title">Demande sommaire</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> step123 <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * , <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> cond <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> lag(cond) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span>(w) <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DISTINCT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> cond <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> chain_start , <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> cond <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">coalesce</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">lead</span></span>(dt) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span>(w), <span class="hljs-string"><span class="hljs-string">'2020-01-12'</span></span>) - dt <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">days</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tbl , LATERAL(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> balance &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> cond) T WINDOW w <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">client</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> dt) ) , step4 <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * , <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) FILTER(<span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> chain_start) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">client</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> dt) grpid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> step123 <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> cond ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DISTINCT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">client</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">client</span></span> , <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">days</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span>(w) <span class="hljs-keyword"><span class="hljs-keyword">days</span></span> , <span class="hljs-keyword"><span class="hljs-keyword">min</span></span>(dt) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span>(w) chain_dt , <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">days</span></span> * balance) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span>(w) balance <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> step4 WINDOW w <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">client</span></span>, grpid) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre></div></div><br>  Ici, nous avons combiné et optimisé les trois premières étapes: <br><br><ul><li>  <b>La sous-requête LATERAL</b> nous a permis de calculer un champ supplémentaire sans passer par la sélection et de l'utiliser immédiatement dans la fonction </li><li>  la suppression d'une définition générale sous <b>WINDOW</b> aide PostgreSQL à ne pas faire de double tri pour former une «fenêtre» et calculer les deux fonctions dans un nœud WindowAgg </li><li>  Le <b>calcul de la fonction</b> «paresseux» <b>sous CASE</b> réduit le nombre d'opérations effectuées </li></ul><br>  De même, nous avons combiné les deux étapes suivantes.  Mais l'ordre de la «fenêtre» pour le calcul des agrégats (client, grpid) et de l'uniformisation (client, somme (jours)) ne coïncidait pas, il y a donc toujours deux nœuds de tri dans le dernier bloc - avant WindowAgg et avant Unique. <br><br><img src="https://habrastorage.org/webt/8h/nq/2_/8hnq2_rny7scq8l_lo0qml_oayc.png"><br>  <a href="https://explain.tensor.ru/archive/explain/33705f55485a31a59d37945d63f26696:0:2020-01-12" rel="nofollow">[regardez expliquez.tensor.ru]</a> <br><br>  Je note que lors de la numérotation des chaînes <b>, la condition WHERE est d'abord remplie</b> , de sorte que les nombres générés par la <u>fonction de fenêtre</u> s'avèrent être séquentiels. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr483460/">https://habr.com/ru/post/fr483460/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr483444/index.html">Rapport DORA 2019: comment améliorer les performances de DevOps</a></li>
<li><a href="../fr483446/index.html">Les scientifiques ont trouvé une nouvelle façon de réduire les niveaux de fer dans l'eau potable</a></li>
<li><a href="../fr483448/index.html">Disney - Le plus grand double sens de l'histoire de l'humanité</a></li>
<li><a href="../fr483454/index.html">Passer de Mercurial à GIT dans Atlassian Bitbucket avec enregistrer des fichiers en cyrillique</a></li>
<li><a href="../fr483458/index.html">Assistant de base de données GreenPig</a></li>
<li><a href="../fr483462/index.html">Tais-toi et prends mon argent</a></li>
<li><a href="../fr483466/index.html">Présentation de la méthode de rétropropagation</a></li>
<li><a href="../fr483468/index.html">Tests d'intégration Flutter - C'est facile</a></li>
<li><a href="../fr483470/index.html">Pose de tuiles efficacement (Pro CSS, SVG, motif et plus)</a></li>
<li><a href="../fr483472/index.html">Supprimer tout: comment effacer les données et restaurer le SSD NVMe aux paramètres d'usine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>