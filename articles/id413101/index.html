<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëèüèº üìß ‚õΩÔ∏è STM32F4 Papan Debug dalam Faktor Bentuk Raspberry Pi üë®üèø‚Äçüè≠ üëâüèª üö´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selamat siang, Khabrovit sayang! Saya ingin memperkenalkan proyek saya kepada publik - papan debug kecil berdasarkan STM32, tetapi dalam faktor bentuk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>STM32F4 Papan Debug dalam Faktor Bentuk Raspberry Pi</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413101/"><p><img src="https://habrastorage.org/webt/m_/xs/9t/m_xs9tnnhio8gxliqrjhdj3zxxw.jpeg" alt="gambar" align="left">  Selamat siang, Khabrovit sayang!  Saya ingin memperkenalkan proyek saya kepada publik - papan debug kecil berdasarkan STM32, tetapi dalam faktor bentuk Raspberry Pi.  Ini berbeda dari papan debug lain karena memiliki geometri yang kompatibel dengan kasing Raspberry Pi dan modul ESP8266 sebagai modem nirkabel.  Dan juga tambahan bagus dalam bentuk konektor untuk kartu micro-SD dan penguat stereo.  Untuk memanfaatkan semua kekayaan ini, saya mengembangkan perpustakaan tingkat tinggi dan program demo (dalam C ++ 11).  Dalam artikel ini saya ingin menjelaskan secara rinci bagian perangkat keras dan perangkat lunak dari proyek ini. </p><a name="habracut"></a><br><p>  Siapa yang bisa mendapat manfaat dari proyek ini?  Mungkin, hanya untuk mereka yang ingin menyolder papan ini sendiri, karena saya tidak mempertimbangkan opsi apa pun untuk produksi skala kecil.  Ini adalah hobi murni.  Menurut pendapat saya, papan mencakup berbagai tugas yang mungkin timbul dalam kerangka kerajinan rumah kecil menggunakan WiFi dan suara. </p><br><p>  Untuk mulai dengan, saya akan mencoba menjawab pertanyaan mengapa ini semua.  Motivator utama proyek ini adalah sebagai berikut: </p><br><ul><li>  Pilihan platform STM32 adalah murni karena pertimbangan estetika - Saya suka rasio harga / kinerja, ditambah berbagai periferal, ditambah ekosistem pengembangan yang besar dan nyaman dari produsen pengontrol (sw4stm, cubeMX, perpustakaan HAL). </li><li>  Tentu saja, ada banyak papan debug dari produsen pengontrol itu sendiri (Discovery, Nucleo), serta dari produsen pihak ketiga (misalnya, Olimex).  Tetapi untuk mengulangi banyak dari mereka di rumah dalam faktor bentuk mereka adalah masalah bagi saya, setidaknya.  Dalam versi saya, kami memiliki topologi dua lapisan sederhana dan komponen yang nyaman untuk penyolderan manual. </li><li>  Untuk perangkat mereka, saya ingin memiliki casing yang layak untuk menutupi kualitas rendah dari elektronik di dalamnya.  Setidaknya ada dua platform populer yang memiliki sejumlah besar kasus yang paling beragam: Arduino dan Raspberry Pi.  Yang kedua menurut saya lebih nyaman dalam hal lokasi guntingan untuk konektor.  Karena itu, sebagai donor untuk geometri dewan, saya memilihnya. </li><li>  Pengontrol yang saya pilih di papan memiliki USB, SDIO, I2S, jaringan.  Di sisi lain, antarmuka yang sama ini juga berguna untuk platform hobi rumah.  Itulah sebabnya, selain controller dengan harness standar, saya menambahkan konektor USB, kartu SD, jalur audio (digital-to-analog converter dan amplifier), serta modul nirkabel berbasis ESP8266. </li></ul><br><h2 id="shema-i-komponenty">  Sirkuit dan komponen </h2><br><p>  Sepertinya saya bahwa papan yang cukup bagus dengan karakteristik dan komponen berikut telah berubah: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">STM32F405RG</a> controller: ARM 32-bit Cortex-M4 dengan coprocessor matematika, frekuensi hingga 168 MHz, memori 1 Mb flash, RAM 196 Kb. <br><img src="https://habrastorage.org/webt/w1/je/fb/w1jefbi3tuwerk7nyio5awywiky.png" alt="Pin pengontrol yang digunakan"><br><img src="https://habrastorage.org/webt/-a/ta/sr/-atasrnz4pajsqagowftqvzok5q.png" alt="Pengikatan pengontrol"></li><li>  Konektor SWD untuk memprogram pengontrol (6 pin). </li><li>  Atur ulang tombol untuk reboot. </li><li>  LED tiga warna.  Di satu sisi, tiga pin pengontrol hilang.  Di sisi lain, mereka masih akan hilang karena kontak yang terbatas pada konektor GPIO, dan untuk debugging LED seperti itu, masalahnya sangat berguna. </li><li>  HSE frekuensi tinggi (16 MHz untuk clock core) dan LSE frekuensi rendah (32,7680 kHz untuk clock real-time) kuarsa. </li><li>  Pin GPIO dengan pitch 2,54 mm kompatibel dengan papan prototyping. </li><li>  Di tempat jack audio 3,5 mm dari Raspberry Pi, saya menempatkan konektor daya 5 volt.  Sekilas, keputusan itu kontroversial.  Tapi ada pro.  Daya dari konektor USB secara opsional hadir (detail di bawah), tetapi ini adalah opsi yang buruk untuk men-debug sirkuit, karena waktu sebelum membakar port USB komputer dalam kasus ini bisa sangat singkat. </li></ul><br><p><img src="https://habrastorage.org/webt/0s/qk/mk/0sqkmkrm5j1lt5bhkaiftrpz-y8.png" alt="Sirkuit daya"></p><br><ul><li>  Port mini-USB  Di satu sisi, itu terhubung melalui chip perlindungan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">STF203-22.TCT</a> ke port USB-OTG controller.  Di sisi lain, pin daya VBUS terhubung ke konektor GPIO.  Jika Anda menghubungkannya ke pin + 5V, papan akan diberi daya dari port USB. </li></ul><br><p><img src="https://habrastorage.org/webt/4q/te/om/4qteom17ikstddtnjafa78pqpme.png" alt="Sirkuit USB"></p><br><ul><li>  Konektor untuk kartu memori micro-SD dengan harness: resistor pull-up 47 kŒ©, transistor manajemen daya ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">P-channel MOSFET BSH205</a> ) dan LED hijau kecil di saluran listrik. </li></ul><br><p><img src="https://habrastorage.org/webt/qb/3x/el/qb3xelfstpguacjkqhnss45nlxk.png" alt="Garis kartu micro sd"></p><br><p>  Gerbang transistor terhubung ke pin PA15 pengontrol.  Ini adalah kontak sistem dari pengontrol JTDI, yang menarik karena pada posisi awal itu dikonfigurasikan sebagai output dengan tegangan tingkat tinggi (pull-up).  Karena SWD digunakan sebagai pengganti JTAG untuk pemrograman, kontak ini tetap bebas dan dapat digunakan untuk tujuan lain, misalnya, mengendalikan transistor.  Ini nyaman - ketika daya diterapkan ke papan, kartu memori tidak aktif, untuk menyalakannya, Anda perlu menerapkan tingkat rendah untuk pin PA15. </p><br><ul><li>  Konverter digital-ke-analog berdasarkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UDA1334</a> .  Chip ini tidak memerlukan sinyal clock eksternal, yang memudahkan penggunaannya.  Data ditransmisikan melalui bus I2S.  Di sisi lain, Datasheet merekomendasikan penggunaan kapasitor polar sebanyak 5 pada 47 ŒºF.  Ukuran penting dalam hal ini.  Yang terkecil yang ternyata dibeli adalah tantalum dengan ukuran 1411, yang bahkan tidak murah.  Namun, saya akan menulis tentang harga secara lebih rinci di bawah ini.  Untuk daya analog, digunakan stabilizer liniernya sendiri, kekuatan bagian digital dihidupkan / dimatikan oleh transistor ganda. </li></ul><br><p><img src="https://habrastorage.org/webt/4f/rh/ea/4frheacnbm39nin0t79ubdatfy8.png" alt="Sirkuit DAC"></p><br><ul><li>  Amplifier dua saluran berdasarkan pada dua chip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">31AP2005</a> .  Keuntungan utama mereka adalah sejumlah kecil komponen pengikat (hanya filter daya dan filter input).  Output audio - 4 platform dengan pitch 2,54 mm.  Bagi saya sendiri, saya belum memutuskan apa yang terbaik - opsi seadanya atau, seperti pada raspberry, colokan 3,5 mm.  Sebagai aturan, 3,5 mm dikaitkan dengan headphone, dalam kasus kami, kami berbicara tentang menghubungkan speaker. </li></ul><br><p><img src="https://habrastorage.org/webt/ke/ge/qa/kegeqak09asea0z1npbr7u9clyw.png" alt="Penguat sirkuit"></p><br><ul><li>  Modul terakhir adalah selendang ESP11 dengan pengikat (daya, soket pemrograman) sebagai modem WiFi.  Kesimpulan papan UART terhubung ke controller dan secara bersamaan output ke konektor eksternal (untuk bekerja dengan papan langsung dari terminal dan pemrograman).  Ada saklar daya (eksternal eksternal atau kontrol dari mikrokontroler).  Ada LED tambahan untuk menunjukkan daya dan konektor "FLASH" untuk meletakkan papan dalam mode pemrograman. </li></ul><br><p><img src="https://habrastorage.org/webt/3d/cq/1d/3dcq1dpb4u-iog9jbnix9icc1ac.png" alt="Sirkuit ESP"></p><br><p>  Tentu saja, ESP8266 itu sendiri adalah pengontrol yang baik, tetapi masih kalah dengan STM32F4 baik dalam kinerja maupun periferal.  Ya, dan ukuran dengan harga modul ini mengisyaratkan bahwa itu adalah unit modem tumpah untuk kakaknya.  Modul ini dikendalikan oleh USRT menggunakan protokol teks <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AT</a> . </p><br><p>  Beberapa foto: <br> <a href=""><img src="https://habrastorage.org/webt/if/zv/di/ifzvdi77bc5vhkauczq8kwfa6mg.jpeg"></a> <br> <a href=""><img src="https://habrastorage.org/webt/dg/go/lz/dggolzrzpwxghtqnwtdyf_plogo.jpeg"></a> </p><br><h2 id="podgotovka-modulya-esp11">  Mempersiapkan Modul ESP11 </h2><br><p>  ESP8266 adalah hal yang terkenal.  Saya yakin banyak yang sudah akrab dengannya, jadi panduan terperinci akan berlebihan di sini.  Karena fitur skematis menghubungkan modul ESP11 ke papan, saya hanya akan memberikan panduan singkat bagi mereka yang ingin mengubah firmware-nya: </p><br><ul><li>  Saya akan menggunakan utilitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">esptool</a> untuk bekerja dengan ESP.  Berbeda dengan utilitas standar dari pabrikan, esptool adalah platform independen. </li><li>  Untuk memulai, nyalakan mode daya eksternal dengan jumper ESP-PWR (kami menutup kontak 1 dan 2), dan sambungkan modul ke komputer melalui adaptor USART-USB.  Adaptor terhubung ke pin GRD / RX / TD.  Kami menyediakan daya ke papan: <br> <a href=""><img src="https://habrastorage.org/webt/qk/sg/_u/qksg_updoacqtvh5a_bmczc_poe.jpeg"></a> </li><li>  Kami memastikan bahwa adaptor dikenali oleh sistem operasi.  Dalam contoh saya, saya menggunakan adaptor berbasis FT232, jadi dengan daftar perangkat itu harus terlihat sebagai FT232 Serial (UART) IC: <br><pre><code class="bash hljs">&gt; lsusb ... Bus 001 Device 010: ID 0483:3748 STMicroelectronics ST-LINK/V2 Bus 001 Device 009: ID 0403:6001 Future Technology Devices International, Ltd FT232 Serial (UART) IC ...</code> </pre> </li><li>  ESP8266 sendiri berbeda dalam jumlah memori flash.  Dalam praktiknya, dalam modul ESP11 yang sama, saya menjumpai 512 KB (4 Mbit) dan 1 MB (8 Mbit).  Jadi, hal pertama yang perlu diperiksa adalah berapa banyak memori yang digunakan dalam modul yang digunakan.  Matikan daya dari papan, dan letakkan modul ke mode pemrograman, tutup jumper "FLASH": </li></ul><br><p> <a href=""><img src="https://habrastorage.org/webt/dr/i8/8p/dri88pfduzkumw9u2_euqtz2_va.jpeg"></a> </p><br><ul><li>  Nyalakan daya, jalankan esptool dengan parameter berikut </li></ul><br><pre> <code class="bash hljs">&gt; esptool.py --port /dev/ttyUSB0 flash_id Connecting.... Detecting chip <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>... ESP8266 Chip is ESP8266EX Uploading stub... Running stub... Stub running... Manufacturer: e0 Device: 4014 Detected flash size: 1MB Hard resetting...</code> </pre> <br><ul><li>  esptool melaporkan bahwa, dalam hal ini, kita berurusan dengan modul dengan memori 1 MB. </li><li>  Untuk versi dengan 1 MB, Anda dapat menggunakan firmware terbaru, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ESP8266 AT Bin V1.6.1</a> .  Tapi itu tidak cocok untuk versi dengan 4 Mbit, yang Anda perlu menggunakan sesuatu yang lebih tua, misalnya yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> .  Firmware terdiri dari beberapa file, alamat awal setiap file ditunjukkan dalam dokumen resmi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ESP8266 AT Instruction Set</a> .  Alamat awal ini digunakan sebagai parameter utilitas esptool.  Misalnya, untuk modul dengan 1 MB, parameter esptool akan terlihat seperti ini (semua file yang diperlukan harus diekstraksi terlebih dahulu dari arsip firmware dan dikumpulkan di direktori kerja) <br><pre> <code class="bash hljs">&gt; esptool.py --port /dev/ttyUSB0 write_flash 0x00000 boot.bin 0x01000 user1.1024.new.2.bin 0x7E000 blank.bin 0xFB000 blank.bin 0xFC000 esp_init_data_default.bin 0xFE000 blank.bin</code> </pre> </li><li>  Kami menyuplai daya ke board, menjalankan esptool dengan parameter yang ditentukan. </li><li>  Setelah menyelesaikan skrip, matikan daya dari papan, buka jumper "FLASH", nyalakan kontrol daya dari mikrokontroler.  Modul siap bekerja. </li></ul><br><h2 id="programmnoe-obespechenie">  Perangkat lunak </h2><br><p>  Ada program pengujian di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> .  Dia melakukan yang berikut: </p><br><ul><li>  menampilkan pengontrol pada frekuensi maksimum (168 MHz) </li><li>  mengaktifkan jam waktu nyata </li><li>  mengaktifkan kartu SD dan membaca konfigurasi jaringan darinya.  Pustaka FatFS digunakan untuk bekerja dengan sistem file. </li><li>  membangun koneksi ke WLAN yang ditentukan </li><li>  terhubung ke server NTP yang ditentukan dan meminta waktu saat itu darinya.  Memimpin waktu. </li><li>  memonitor status beberapa port yang ditentukan.  Jika statusnya telah berubah, kirim pesan teks ke server TCP yang ditentukan. </li><li>  ketika Anda mengklik tombol eksternal, ia membaca file * .wav yang ditentukan dari kartu SD dan memutarnya dalam mode asinkron (I2S menggunakan pengontrol DMA). </li><li>  bekerja dengan ESP11 juga diimplementasikan dalam mode asinkron (sejauh ini tanpa DMA, hanya pada interupsi) </li><li>  masuk melalui USART1 (pin PB6 / PB7) </li><li>  dan, tentu saja, LED berkedip. </li></ul><br><p>  Di Habr√© ada banyak artikel yang ditujukan untuk pemrograman STM32 pada tingkat yang agak rendah (hanya dengan manajemen register atau CMSIS).  Misalnya, dari yang relatif terakhir: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tiga</a> .  Artikel-artikelnya, tentu saja, sangat berkualitas tinggi, tetapi pendapat subjektif saya adalah bahwa untuk pengembangan produk satu kali, pendekatan ini, mungkin, membenarkan dirinya sendiri.  Tetapi untuk proyek hobi jangka panjang, ketika Anda ingin semuanya menjadi indah dan dapat dikembangkan, pendekatan ini terlalu rendah.  Salah satu alasan popularitas Arduino tepatnya sebagai platform perangkat lunak, menurut pendapat saya, adalah bahwa penulis Arduino telah meninggalkan tingkat yang begitu rendah untuk arsitektur berorientasi objek.  Oleh karena itu, saya memutuskan untuk pergi ke arah yang sama dan menambahkan lapisan berorientasi objek tingkat tinggi di perpustakaan HAL. </p><br><p>  Dengan demikian, tiga tingkatan program diperoleh: </p><br><ul><li>  Pabrikan Libraries (HAL, FatFS, di masa depan USB-OTG) membentuk yayasan </li><li>  Pustaka StmPlusPlus saya didasarkan pada yayasan ini.  Ini termasuk satu set kelas dasar (seperti System, IOPort, IOPin, Timer, RealTimeClock, Usart, Spi, I2S), satu set kelas driver perangkat eksternal (seperti SdCard, Esp11, DcfReceiver, Dac_MCP49x1, AudioDac_UDA1334 dan sejenisnya), serta kelas layanan seperti pemutar asinkron WAV. </li><li>  Berdasarkan perpustakaan StmPlusPlus, aplikasi itu sendiri sedang dibangun. </li></ul><br><p>  Adapun dialek bahasa.  Meskipun saya agak kuno, saya tetap di C ++ 11.  Standar ini memiliki beberapa fitur yang sangat berguna untuk mengembangkan firmware: kelas enum, memanggil konstruktor dengan kurung kurawal untuk mengontrol jenis parameter yang dilewati, dan wadah statis seperti std :: array.  Ngomong-ngomong, di Habr√© ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel bagus</a> tentang hal ini. </p><br><h3 id="biblioteka-stmplusplus">  Perpustakaan StmPlusPlus </h3><br><p>  Kode pustaka lengkap dapat dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> .  Di sini saya hanya akan memberikan beberapa contoh kecil untuk menunjukkan struktur, ide dan masalah yang dihasilkan oleh ide ini. </p><br><p>  <strong>Contoh pertama</strong> adalah kelas untuk polling secara berkala keadaan pin (misalnya, tombol) dan memanggil pawang ketika keadaan ini berubah: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> :</span></span> IOPin { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventHandler</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onButtonPressed</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Button *, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numOccured)</span></span></span><span class="hljs-function"> </span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>; }; Button (PortName name, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pin, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pull, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RealTimeClock &amp; _rtc, duration_ms _pressDelay = <span class="hljs-number"><span class="hljs-number">50</span></span>, duration_ms _pressDuration = <span class="hljs-number"><span class="hljs-number">300</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EventHandler * _handler)</span></span></span><span class="hljs-function"> </span></span>{ handler = _handler; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">periodic</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RealTimeClock &amp; rtc; duration_ms pressDelay, pressDuration; time_ms pressTime; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> currentState; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> numOccured; EventHandler * handler; };</code> </pre> <br><p>  Konstruktor mendefinisikan semua parameter tombol: </p><br><pre> <code class="cpp hljs">Button::Button (PortName name, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pin, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pull, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RealTimeClock &amp; _rtc, duration_ms _pressDelay, duration_ms _pressDuration): IOPin{name, pin, GPIO_MODE_INPUT, pull, GPIO_SPEED_LOW}, rtc{_rtc}, pressDelay{_pressDelay}, pressDuration{_pressDuration}, pressTime{INFINITY_TIME}, currentState{<span class="hljs-literal"><span class="hljs-literal">false</span></span>}, numOccured{<span class="hljs-number"><span class="hljs-number">0</span></span>}, handler{<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>} { <span class="hljs-comment"><span class="hljs-comment">// empty }</span></span></code> </pre> <br><p>  Jika menangani peristiwa seperti itu bukan prioritas, maka menggunakan interupsi jelas berlebihan.  Oleh karena itu, berbagai skenario penekanan (misalnya, satu tekan atau tahan) diimplementasikan dalam prosedur periodik, yang harus secara berkala dipanggil dari kode program utama.  secara berkala menganalisis perubahan status dan secara sinkron memanggil pengendali virtual onButtonPressed, yang harus diimplementasikan dalam program utama: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Button::periodic () { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> newState = (gpioParameters.Pull == GPIO_PULLUP)? !getBit() : getBit(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentState == newState) { <span class="hljs-comment"><span class="hljs-comment">// state is not changed: check for periodical press event if (currentState &amp;&amp; pressTime != INFINITY_TIME) { duration_ms d = rtc.getUpTimeMillisec() - pressTime; if (d &gt;= pressDuration) { handler-&gt;onButtonPressed(this, numOccured); pressTime = rtc.getUpTimeMillisec(); ++numOccured; } } } else if (!currentState &amp;&amp; newState) { pressTime = rtc.getUpTimeMillisec(); numOccured = 0; } else { duration_ms d = rtc.getUpTimeMillisec() - pressTime; if (d &lt; pressDelay) { // nothing to do } else if (numOccured == 0) { handler-&gt;onButtonPressed(this, numOccured); } pressTime = INFINITY_TIME; } currentState = newState; }</span></span></code> </pre> <br><p>  Keuntungan utama dari pendekatan ini adalah keragaman logika dan kode untuk mendeteksi suatu peristiwa dari prosesnya.  Ini bukan HAL_GetTick yang digunakan untuk menghitung waktu, yang, karena tipenya (uint32_t), disetel ulang dengan melimpah setiap 2 ^ 32 milidetik (setiap 49 hari).  Saya mengimplementasikan kelas saya sendiri RealTimeClock, yang menghitung milidetik sejak awal program, atau menyalakan pengontrol seperti uint64_t, yang menghasilkan sekitar 5 ^ 8 tahun. </p><br><p>  <strong>Contoh kedua</strong> adalah bekerja dengan antarmuka perangkat keras, yang ada beberapa di controller.  Misalnya, SPI.  Dari sudut pandang program utama, sangat mudah untuk memilih hanya antarmuka yang diinginkan (SPI1 / SPI2 / SPI3), dan semua parameter lain yang bergantung pada antarmuka ini akan dikonfigurasikan oleh konstruktor kelas. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Spi</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> TIMEOUT = <span class="hljs-number"><span class="hljs-number">5000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeviceName</span></span></span><span class="hljs-class"> {</span></span> SPI_1 = <span class="hljs-number"><span class="hljs-number">0</span></span>, SPI_2 = <span class="hljs-number"><span class="hljs-number">1</span></span>, SPI_3 = <span class="hljs-number"><span class="hljs-number">2</span></span>, }; Spi (DeviceName _device, IOPort::PortName sckPort, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> sckPin, IOPort::PortName misoPort, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> misoPin, IOPort::PortName mosiPort, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mosiPin, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pull = GPIO_NOPULL); <span class="hljs-function"><span class="hljs-function">HAL_StatusTypeDef </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> direction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> prescaler, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dataSize = SPI_DATASIZE_8BIT, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CLKPhase = SPI_PHASE_1EDGE)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">HAL_StatusTypeDef </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> HAL_StatusTypeDef </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeBuffer</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pSize)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HAL_SPI_Transmit(hspi, pData, pSize, TIMEOUT); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: DeviceName device; IOPin sck, miso, mosi; SPI_HandleTypeDef *hspi; SPI_HandleTypeDef spiParams; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enableClock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">disableClock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; };</code> </pre> <br><p>  Parameter pin dan parameter antarmuka disimpan secara lokal di kelas.  Sayangnya, saya memilih opsi implementasi yang tidak sepenuhnya berhasil, ketika pengaturan parameter tergantung pada antarmuka tertentu diimplementasikan secara langsung: </p><br><pre> <code class="cpp hljs">Spi::Spi (DeviceName _device, IOPort::PortName sckPort, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> sckPin, IOPort::PortName misoPort, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> misoPin, IOPort::PortName mosiPort, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mosiPin, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pull): device(_device), sck(sckPort, sckPin, GPIO_MODE_AF_PP, pull, GPIO_SPEED_HIGH, <span class="hljs-literal"><span class="hljs-literal">false</span></span>), miso(misoPort, misoPin, GPIO_MODE_AF_PP, pull, GPIO_SPEED_HIGH, <span class="hljs-literal"><span class="hljs-literal">false</span></span>), mosi(mosiPort, mosiPin, GPIO_MODE_AF_PP, pull, GPIO_SPEED_HIGH, <span class="hljs-literal"><span class="hljs-literal">false</span></span>), hspi(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (device) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DeviceName::SPI_1: <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> SPI1 sck.setAlternate(GPIO_AF5_SPI1); miso.setAlternate(GPIO_AF5_SPI1); mosi.setAlternate(GPIO_AF5_SPI1); spiParams.Instance = SPI1; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> break; ... case DeviceName::SPI_3: #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> SPI3 sck.setAlternate(GPIO_AF6_SPI3); miso.setAlternate(GPIO_AF6_SPI3); mosi.setAlternate(GPIO_AF6_SPI3); spiParams.Instance = SPI3; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> break; } spiParams.Init.Mode = SPI_MODE_MASTER; spiParams.Init.DataSize = SPI_DATASIZE_8BIT; spiParams.Init.CLKPolarity = SPI_POLARITY_HIGH; spiParams.Init.CLKPhase = SPI_PHASE_1EDGE; spiParams.Init.FirstBit = SPI_FIRSTBIT_MSB; spiParams.Init.TIMode = SPI_TIMODE_DISABLE; spiParams.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE; spiParams.Init.CRCPolynomial = 7; spiParams.Init.NSS = SPI_NSS_SOFT; }</span></span></code> </pre> <br><p>  Skema yang sama mengimplementasikan prosedur enableClock dan disableClock, yang tidak dapat diperluas dan buruk portabel untuk pengontrol lainnya.  Dalam hal ini, lebih baik menggunakan templat di mana parameter templat adalah nama antarmuka HAL (SPI1, SPI2, SPI3), parameter pin (GPIO_AF5_SPI1), dan sesuatu yang mengontrol jam on / off.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ada</a> artikel yang menarik tentang topik ini, meskipun meninjau pengontrol AVR, yang, bagaimanapun, tidak membuat perbedaan mendasar. </p><br><p>  Awal dan akhir transfer dikendalikan oleh dua metode start / stop: </p><br><pre> <code class="cpp hljs">HAL_StatusTypeDef Spi::start (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> direction, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> prescaler, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> dataSize, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> CLKPhase) { hspi = &amp;spiParams; enableClock(); spiParams.Init.Direction = direction; spiParams.Init.BaudRatePrescaler = prescaler; spiParams.Init.DataSize = dataSize; spiParams.Init.CLKPhase = CLKPhase; HAL_StatusTypeDef status = HAL_SPI_Init(hspi); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status != HAL_OK) { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Can not initialize SPI "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)device &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span> &lt;&lt; status); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> status; } <span class="hljs-comment"><span class="hljs-comment">/* Configure communication direction : 1Line */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spiParams.Init.Direction == SPI_DIRECTION_1LINE) { SPI_1LINE_TX(hspi); } <span class="hljs-comment"><span class="hljs-comment">/* Check if the SPI is already enabled */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((spiParams.Instance-&gt;CR1 &amp; SPI_CR1_SPE) != SPI_CR1_SPE) { <span class="hljs-comment"><span class="hljs-comment">/* Enable SPI peripheral */</span></span> __HAL_SPI_ENABLE(hspi); } USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Started SPI "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)device &lt;&lt; <span class="hljs-string"><span class="hljs-string">": BaudRatePrescaler = "</span></span> &lt;&lt; spiParams.Init.BaudRatePrescaler &lt;&lt; <span class="hljs-string"><span class="hljs-string">", DataSize = "</span></span> &lt;&lt; spiParams.Init.DataSize &lt;&lt; <span class="hljs-string"><span class="hljs-string">", CLKPhase = "</span></span> &lt;&lt; spiParams.Init.CLKPhase &lt;&lt; <span class="hljs-string"><span class="hljs-string">", Status = "</span></span> &lt;&lt; status); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> status; } HAL_StatusTypeDef Spi::stop () { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Stopping SPI "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)device); HAL_StatusTypeDef retValue = HAL_SPI_DeInit(&amp;spiParams); disableClock(); hspi = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retValue; }</code> </pre> <br><p>  <strong>Bekerja dengan antarmuka perangkat keras menggunakan interupsi</strong> .  Kelas mengimplementasikan antarmuka I2S menggunakan pengontrol DMA.  I2S (Inter-IC Sound) adalah perangkat keras dan perangkat lunak tambahan pada SPI, yang dengan sendirinya, misalnya, memilih frekuensi jam dan mengontrol saluran tergantung pada protokol audio dan bit rate. </p><br><p>  Dalam hal ini, kelas I2S diwarisi dari kelas "port", yaitu, I2S adalah port dengan properti khusus.  Beberapa data disimpan dalam struktur HAL (plus untuk kenyamanan, dikurangi untuk jumlah data).  Beberapa data ditransfer dari kode utama melalui tautan (misalnya, struktur irqPrio). </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I2S</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IOPort { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IRQn_Type I2S_IRQ = SPI2_IRQn; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IRQn_Type DMA_TX_IRQ = DMA1_Stream4_IRQn; I2S (PortName name, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pin, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InterruptPriority &amp; prio); <span class="hljs-function"><span class="hljs-function">HAL_StatusTypeDef </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> standard, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> audioFreq, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dataFormat)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> HAL_StatusTypeDef </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transmit</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HAL_I2S_Transmit_DMA(&amp;i2s, pData, size); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processI2SInterrupt</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ HAL_I2S_IRQHandler(&amp;i2s); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processDmaTxInterrupt</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ HAL_DMA_IRQHandler(&amp;i2sDmaTx); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: I2S_HandleTypeDef i2s; DMA_HandleTypeDef i2sDmaTx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InterruptPriority &amp; irqPrio; };</code> </pre> <br><p>  Konstruktornya menetapkan semua parameter statis: </p><br><pre> <code class="cpp hljs">I2S::I2S (PortName name, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pin, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InterruptPriority &amp; prio): IOPort{name, GPIO_MODE_INPUT, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW, pin, <span class="hljs-literal"><span class="hljs-literal">false</span></span>}, irqPrio{prio} { i2s.Instance = SPI2; i2s.Init.Mode = I2S_MODE_MASTER_TX; i2s.Init.Standard = I2S_STANDARD_PHILIPS; <span class="hljs-comment"><span class="hljs-comment">// will be re-defined at communication start i2s.Init.DataFormat = I2S_DATAFORMAT_16B; // will be re-defined at communication start i2s.Init.MCLKOutput = I2S_MCLKOUTPUT_DISABLE; i2s.Init.AudioFreq = I2S_AUDIOFREQ_44K; // will be re-defined at communication start i2s.Init.CPOL = I2S_CPOL_LOW; i2s.Init.ClockSource = I2S_CLOCK_PLL; i2s.Init.FullDuplexMode = I2S_FULLDUPLEXMODE_DISABLE; i2sDmaTx.Instance = DMA1_Stream4; i2sDmaTx.Init.Channel = DMA_CHANNEL_0; i2sDmaTx.Init.Direction = DMA_MEMORY_TO_PERIPH; i2sDmaTx.Init.PeriphInc = DMA_PINC_DISABLE; i2sDmaTx.Init.MemInc = DMA_MINC_ENABLE; i2sDmaTx.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD; i2sDmaTx.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD; i2sDmaTx.Init.Mode = DMA_NORMAL; i2sDmaTx.Init.Priority = DMA_PRIORITY_LOW; i2sDmaTx.Init.FIFOMode = DMA_FIFOMODE_ENABLE; i2sDmaTx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL; i2sDmaTx.Init.MemBurst = DMA_PBURST_SINGLE; i2sDmaTx.Init.PeriphBurst = DMA_PBURST_SINGLE; }</span></span></code> </pre> <br><p>  Awal transfer data dikendalikan oleh metode start, yang bertanggung jawab untuk mengonfigurasi parameter port, clocking antarmuka, mengkonfigurasi interupsi, memulai DMA, memulai antarmuka itu sendiri dengan parameter transmisi yang ditentukan. </p><br><pre> <code class="cpp hljs">HAL_StatusTypeDef I2S::start (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> standard, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> audioFreq, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> dataFormat) { i2s.Init.Standard = standard; i2s.Init.AudioFreq = audioFreq; i2s.Init.DataFormat = dataFormat; setMode(GPIO_MODE_AF_PP); setAlternate(GPIO_AF5_SPI2); __HAL_RCC_SPI2_CLK_ENABLE(); HAL_StatusTypeDef status = HAL_I2S_Init(&amp;i2s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status != HAL_OK) { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Can not start I2S: "</span></span> &lt;&lt; status); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HAL_ERROR; } __HAL_RCC_DMA1_CLK_ENABLE(); __HAL_LINKDMA(&amp;i2s, hdmatx, i2sDmaTx); status = HAL_DMA_Init(&amp;i2sDmaTx); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status != HAL_OK) { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Can not initialize I2S DMA/TX channel: "</span></span> &lt;&lt; status); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HAL_ERROR; } HAL_NVIC_SetPriority(I2S_IRQ, irqPrio.first, irqPrio.second); HAL_NVIC_EnableIRQ(I2S_IRQ); HAL_NVIC_SetPriority(DMA_TX_IRQ, irqPrio.first + <span class="hljs-number"><span class="hljs-number">1</span></span>, irqPrio.second); HAL_NVIC_EnableIRQ(DMA_TX_IRQ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HAL_OK; }</code> </pre> <br><p>  Prosedur berhenti melakukan yang sebaliknya: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> I2S::stop () { HAL_NVIC_DisableIRQ(I2S_IRQ); HAL_NVIC_DisableIRQ(DMA_TX_IRQ); HAL_DMA_DeInit(&amp;i2sDmaTx); __HAL_RCC_DMA1_CLK_DISABLE(); HAL_I2S_DeInit(&amp;i2s); __HAL_RCC_SPI2_CLK_DISABLE(); setMode(GPIO_MODE_INPUT); }</code> </pre> <br><p>  Ada beberapa fitur menarik di sini: </p><br><ul><li>  Interupsi yang digunakan dalam hal ini didefinisikan sebagai konstanta statis.  Ini minus untuk portabilitas ke pengontrol lain. </li><li>  Pengaturan kode semacam itu memastikan bahwa pin port selalu dalam status GPIO_MODE_INPUT saat tidak ada transmisi.  Ini merupakan nilai tambah. </li><li>  Prioritas interupsi ditransfer dari luar, yaitu, ada peluang bagus untuk mengatur peta prioritas interupsi di satu tempat kode utama.  Ini juga merupakan nilai tambah. </li><li>  Prosedur berhenti menonaktifkan pencatatan jam kerja DMA1.  Dalam hal ini, penyederhanaan ini dapat memiliki konsekuensi yang sangat negatif jika orang lain terus menggunakan DMA1.  Masalahnya diselesaikan dengan membuat daftar konsumen yang terpusat dari perangkat tersebut, yang akan bertanggung jawab untuk pengaturan waktu. </li><li>  Penyederhanaan lain - prosedur mulai tidak membawa antarmuka ke keadaan semula jika terjadi kesalahan (ini adalah minus, tetapi mudah diperbaiki).  Pada saat yang sama, kesalahan dicatat lebih detail, yang merupakan nilai tambah. </li><li>  Saat menggunakan kelas ini, kode utama harus mencegat SPI2_IRQn dan DMA1_Stream4_IRQn menyela dan memastikan bahwa penangan processI2SInterrupt dan processDmaTxInterrupt yang sesuai dipanggil. </li></ul><br><h3 id="osnovnaya-programma">  Program utama </h3><br><p>  Program utama ditulis menggunakan perpustakaan yang dijelaskan di atas dengan cukup sederhana: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ HAL_Init(); <span class="hljs-function"><span class="hljs-function">IOPort </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">defaultPortA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IOPort::PortName::A, GPIO_MODE_INPUT, GPIO_PULLDOWN)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">IOPort </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">defaultPortB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IOPort::PortName::B, GPIO_MODE_INPUT, GPIO_PULLDOWN)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">IOPort </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">defaultPortC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IOPort::PortName::C, GPIO_MODE_INPUT, GPIO_PULLDOWN)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// System frequency 168MHz System::ClockDiv clkDiv; clkDiv.PLLM = 16; clkDiv.PLLN = 336; clkDiv.PLLP = 2; clkDiv.PLLQ = 7; clkDiv.AHBCLKDivider = RCC_SYSCLK_DIV1; clkDiv.APB1CLKDivider = RCC_HCLK_DIV8; clkDiv.APB2CLKDivider = RCC_HCLK_DIV8; clkDiv.PLLI2SN = 192; clkDiv.PLLI2SR = 2; do { System::setClock(clkDiv, FLASH_LATENCY_3, System::RtcType::RTC_EXT); } while (System::getMcuFreq() != 168000000L); MyApplication app; appPtr = &amp;app; app.run(); }</span></span></code> </pre> <br><p>  Di sini kita menginisialisasi pustaka HAL, mengkonfigurasi semua pin pengontrol dengan input (GPIO_MODE_INPUT / PULLDOWN) secara default.  Kami mengatur frekuensi controller, mulai jam (termasuk jam real-time dari kuarsa eksternal).  Setelah itu, sedikit bergaya Java, kita membuat instance dari aplikasi kita dan memanggil metode menjalankannya, yang mengimplementasikan semua logika aplikasi. </p><br><p>  Di bagian terpisah, kita harus mendefinisikan semua interupsi yang digunakan.  Karena kita menulis dalam C ++, dan interupsi adalah hal-hal dari dunia C, kita perlu menutupi mereka sesuai: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SysTick_Handler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ HAL_IncTick(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (appPtr != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { appPtr-&gt;getRtc().onMilliSecondInterrupt(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DMA2_Stream3_IRQHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ Devices::SdCard::getInstance()-&gt;processDmaRxInterrupt(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DMA2_Stream6_IRQHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ Devices::SdCard::getInstance()-&gt;processDmaTxInterrupt(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SDIO_IRQHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ Devices::SdCard::getInstance()-&gt;processSdIOInterrupt(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SPI2_IRQHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ appPtr-&gt;getI2S().processI2SInterrupt(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DMA1_Stream4_IRQHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ appPtr-&gt;getI2S().processDmaTxInterrupt(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HAL_I2S_TxCpltCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(I2S_HandleTypeDef *channel)</span></span></span><span class="hljs-function"> </span></span>{ appPtr-&gt;processDmaTxCpltCallback(channel); } ... }</code> </pre> <br><p>  Kelas MyApplication menyatakan semua perangkat yang digunakan, memanggil konstruktor untuk semua perangkat ini, dan juga mengimplementasikan penangan peristiwa yang diperlukan: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RealTimeClock::EventHandler, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RealTimeClock::EventHandler, WavStreamer::EventHandler, Devices::Button::EventHandler { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> INPUT_PINS = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Number of monitored input pins private: UsartLogger log; RealTimeClock rtc; IOPin ledGreen, ledBlue, ledRed; PeriodicalEvent heartbeatEvent; IOPin mco; // Interrupt priorities InterruptPriority irqPrioI2S; InterruptPriority irqPrioEsp; InterruptPriority irqPrioSd; InterruptPriority irqPrioRtc; // SD card IOPin pinSdPower, pinSdDetect; IOPort portSd1, portSd2; SdCard sdCard; bool sdCardInserted; // Configuration Config config; // ESP Esp11 esp; EspSender espSender; // Input pins std::array&lt;IOPin, INPUT_PINS&gt; pins; std::array&lt;bool, INPUT_PINS&gt; pinsState; // I2S2 Audio I2S i2s; AudioDac_UDA1334 audioDac; WavStreamer streamer; Devices::Button playButton; ...</span></span></code> </pre> <br><p>  Faktanya, semua perangkat yang digunakan dinyatakan secara statis, yang berpotensi menyebabkan peningkatan memori yang digunakan, tetapi sangat menyederhanakan akses ke data.  Dalam konstruktor kelas MyApplication, perlu memanggil perancang semua perangkat, setelah itu, pada saat prosedur dijalankan dimulai, semua perangkat mikrokontroler yang digunakan akan diinisialisasi: </p><br><pre> <code class="cpp hljs"> MyApplication::MyApplication () : <span class="hljs-comment"><span class="hljs-comment">// logging log(Usart::USART_1, IOPort::B, GPIO_PIN_6, GPIO_PIN_7, 115200), // RTC rtc(), ledGreen(IOPort::C, GPIO_PIN_1, GPIO_MODE_OUTPUT_PP), ledBlue(IOPort::C, GPIO_PIN_2, GPIO_MODE_OUTPUT_PP), ledRed(IOPort::C, GPIO_PIN_3, GPIO_MODE_OUTPUT_PP), heartbeatEvent(rtc, 10, 2), mco(IOPort::A, GPIO_PIN_8, GPIO_MODE_AF_PP), // Interrupt priorities irqPrioI2S(6, 0), // I2S DMA interrupt priority: 7 will be also used irqPrioEsp(5, 0), irqPrioSd(3, 0), // SD DMA interrupt priority: 4 will be also used irqPrioRtc(2, 0), // SD card pinSdPower(IOPort::A, GPIO_PIN_15, GPIO_MODE_OUTPUT_PP, GPIO_PULLDOWN, GPIO_SPEED_HIGH, true, false), pinSdDetect(IOPort::B, GPIO_PIN_3, GPIO_MODE_INPUT, GPIO_PULLUP), portSd1(IOPort::C, /* mode = */GPIO_MODE_OUTPUT_PP, /* pull = */GPIO_PULLUP, /* speed = */GPIO_SPEED_FREQ_VERY_HIGH, /* pin = */GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12, /* callInit = */false), portSd2(IOPort::D, /* mode = */GPIO_MODE_OUTPUT_PP, /* pull = */GPIO_PULLUP, /* speed = */GPIO_SPEED_FREQ_VERY_HIGH, /* pin = */GPIO_PIN_2, /* callInit = */false), sdCard(pinSdDetect, portSd1, portSd2), sdCardInserted(false), // Configuration config(pinSdPower, sdCard, "conf.txt"), //ESP esp(rtc, Usart::USART_2, IOPort::A, GPIO_PIN_2, GPIO_PIN_3, irqPrioEsp, IOPort::A, GPIO_PIN_1), espSender(rtc, esp, ledRed), // Input pins pins { { IOPin(IOPort::A, GPIO_PIN_4, GPIO_MODE_INPUT, GPIO_PULLUP), IOPin(IOPort::A, GPIO_PIN_5, GPIO_MODE_INPUT, GPIO_PULLUP), IOPin(IOPort::A, GPIO_PIN_6, GPIO_MODE_INPUT, GPIO_PULLUP), IOPin(IOPort::A, GPIO_PIN_7, GPIO_MODE_INPUT, GPIO_PULLUP), IOPin(IOPort::C, GPIO_PIN_4, GPIO_MODE_INPUT, GPIO_PULLUP), IOPin(IOPort::C, GPIO_PIN_5, GPIO_MODE_INPUT, GPIO_PULLUP), IOPin(IOPort::B, GPIO_PIN_0, GPIO_MODE_INPUT, GPIO_PULLUP), IOPin(IOPort::B, GPIO_PIN_1, GPIO_MODE_INPUT, GPIO_PULLUP) } }, // I2S2 Audio Configuration // PB10 --&gt; I2S2_CK // PB12 --&gt; I2S2_WS // PB15 --&gt; I2S2_SD i2s(IOPort::B, GPIO_PIN_10 | GPIO_PIN_12 | GPIO_PIN_15, irqPrioI2S), audioDac(i2s, /* power = */ IOPort::B, GPIO_PIN_11, /* mute = */ IOPort::B, GPIO_PIN_13, /* smplFreq = */ IOPort::B, GPIO_PIN_14), streamer(sdCard, audioDac), playButton(IOPort::B, GPIO_PIN_2, GPIO_PULLUP, rtc) { mco.activateClockOutput(RCC_MCO1SOURCE_PLLCLK, RCC_MCODIV_5); }</span></span></code> </pre> <br><p>  Sebagai contoh, pengendali acara untuk mengklik tombol yang memulai / berhenti memainkan file WAV: </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MyApplication::onButtonPressed (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Devices::Button * b, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> numOccured) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b == &amp;playButton) { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"play button pressed: "</span></span> &lt;&lt; numOccured); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (streamer.isActive()) { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">" Stopping WAV"</span></span>); streamer.stop(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">" Starting WAV"</span></span>); streamer.start(AudioDac_UDA1334::SourceType:: STREAM, config.getWavFile()); } } }</code> </pre> <br><p>  Dan akhirnya, metode jalankan utama menyelesaikan konfigurasi perangkat (misalnya, menetapkan MyApplication sebagai pengendali event), dan memulai loop tanpa akhir, di mana ia secara berkala mengakses perangkat yang memerlukan perhatian berkala: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MyApplication::run () { <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>.initInstance(); USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Oscillator frequency: "</span></span> &lt;&lt; System::getExternalOscillatorFreq() &lt;&lt; <span class="hljs-string"><span class="hljs-string">", MCU frequency: "</span></span> &lt;&lt; System::getMcuFreq()); HAL_StatusTypeDef status = HAL_TIMEOUT; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { status = rtc.start(<span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-number"><span class="hljs-number">2047</span></span> + <span class="hljs-number"><span class="hljs-number">7</span></span>, RTC_WAKEUPCLOCK_RTCCLK_DIV2, irqPrioRtc, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"RTC start status: "</span></span> &lt;&lt; status); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (status != HAL_OK); sdCard.setIrqPrio(irqPrioSd); sdCard.initInstance(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sdCard.isCardInserted()) { updateSdCardState(); } USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Input pins: "</span></span> &lt;&lt; pins.size()); pinsState.fill(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Pin state: "</span></span> &lt;&lt; fillMessage()); esp.assignSendLed(&amp;ledGreen); streamer.stop(); streamer.setHandler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); streamer.setVolume(<span class="hljs-number"><span class="hljs-number">1.0</span></span>); playButton.setHandler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reportState = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { updateSdCardState(); playButton.periodic(); streamer.periodic(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isInputPinsChanged()) { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Input pins change detected"</span></span>); ledBlue.putBit(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); reportState = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } espSender.periodic(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (espSender.isOutputMessageSent()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reportState) { espSender.sendMessage(config, <span class="hljs-string"><span class="hljs-string">"TCP"</span></span>, config.getServerIp(), config.getServerPort(), fillMessage()); reportState = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!reportState) { ledBlue.putBit(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (heartbeatEvent.isOccured()) { ledGreen.putBit(heartbeatEvent.occurance() == <span class="hljs-number"><span class="hljs-number">1</span></span>); } } }</code> </pre> <br><h3 id="nemnogo-eksperimentov">  Sedikit eksperimen </h3><br><p>   ‚Äî    .    ‚Äî 168 MHz. ,   ,      172 MHz   180 MHz,          ,      ,         MCO.     ,   USART  I2S, ,  ,      HAL. </p><br><h2 id="cena">  </h2><br><p>        .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=http://htmlpreview.github.io/%3F">github</a>     .    - ,            <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mouser</a> (   ).     37      .            .  ,        STM  Olimex,      . </p><br><h2 id="problemy-i-perspektivy">    </h2><br><p>        .       ,   : </p><br><ul><li>        (   ).  ,       ,            .       :     4  8 .        PLL,         . </li><li>    ,       .      47 ŒºF  . ,    . </li><li>   SWD      .    -  ,     .     . </li><li>     .     SMD ,    .       3       . </li></ul><br><h2 id="dokumentaciya">  Dokumentasi </h2><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a>   GPL v3: </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://docs.google.com/viewer%3Furl%3D"></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://docs.google.com/viewer%3Furl%3D"></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://docs.google.com/viewer%3Furl%3D"> </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://docs.google.com/viewer%3Furl%3D"> </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=http://htmlpreview.github.io/%3F"> </a> </li></ul><br><p>  Terima kasih atas perhatian anda! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id413101/">https://habr.com/ru/post/id413101/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id413091/index.html">Pencatatan yang nyaman di SpringBoot + Log4j2 + Maven</a></li>
<li><a href="../id413093/index.html">Untuk mengantisipasi balapan pedagang ruang angkasa di Amerika Serikat dan Cina</a></li>
<li><a href="../id413095/index.html">Aplikasi Teknologi Jaringan Saraf Tiruan: Pengembangan Perangkat Lunak</a></li>
<li><a href="../id413097/index.html">Berdasarkan perangkat lunak tingkat perusahaan, telah diuji jutaan kali: openSUSE Leap 15 dirilis</a></li>
<li><a href="../id413099/index.html">Downclocking ram di macbook</a></li>
<li><a href="../id413103/index.html">3CX v15.5 Pembaruan 5 Beta dan integrasi REST dengan AmoCRM dirilis</a></li>
<li><a href="../id413105/index.html">Catatan dari penyedia IoT. Aktivasi dan keamanan di LoraWAN</a></li>
<li><a href="../id413107/index.html">Terjemahan dari wiki proyek Svelto.ECS. Kerangka kerja ECS untuk Unity3D</a></li>
<li><a href="../id413109/index.html">Cara Membangun Platform Integrasi Produk SaaS: Pengalaman Cloud Checkout Poster</a></li>
<li><a href="../id413111/index.html">STM32 + NetBeans =?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>