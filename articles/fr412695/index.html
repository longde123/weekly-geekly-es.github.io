<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🔧 🤷🏻 🙆🏿 L'image globale des tests unitaires 💂🏼 👨‍👩‍👦‍👦 💗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ce n'est pas un guide sur les caractères que vous devez entrer dans l'éditeur de code pour obtenir des tests unitaires. C'est une nourriture pour l'es...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>L'image globale des tests unitaires</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/412695/"><img src="https://habrastorage.org/webt/di/az/zt/diazzt3uova8gflxtil7ecuxggu.png"><br><br>  Ce n'est pas un guide sur les caractères que vous devez entrer dans l'éditeur de code pour obtenir des tests unitaires.  C'est une nourriture pour l'esprit, qui doit être consommée <b>avant de</b> prendre ces mesures. <br><br>  Le sujet des tests unitaires n'est pas aussi simple qu'il y paraît.  Beaucoup d'entre nous, les développeurs, viennent aux tests unitaires sous la pression des clients, des employés, des collègues, de leurs idoles, etc.  Nous comprenons rapidement sa valeur et, après avoir terminé les préparatifs techniques, nous oublions le tableau général, si jamais nous l'avons compris.  Dans cet article, je parlerai brièvement de ce que les tests unitaires sont à la fois et de ce qui ne l'est pas en général, et en PHP, et en même temps, je décrirai la place qu'occupent les tests unitaires dans l'AQ. <br><a name="habracut"></a><br><h2>  Qu'est-ce que le test? </h2><br>  Avant de plonger dans les tests unitaires, vous devez étudier la théorie du test lui-même afin de ne pas faire d'erreurs comme celles faites par les auteurs de l'un des frameworks PHP les plus populaires: ils ont montré des tests d'intégration sur leur site Web et les ont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">appelés</a> tests unitaires.  Non, Laravel, ce ne sont pas des tests unitaires.  Bien que cela ne m'empêche pas de toujours aimer ce cadre. <br><br>  Les tests de logiciels sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">définis</a> comme «une enquête menée pour fournir aux parties intéressées des informations sur la qualité des produits».  Cela s'oppose au "test logiciel est un gaspillage du budget du projet par les développeurs qui ne font rien d'important et demandent ensuite plus de temps et d'argent, car" rien "peut être très cher."  Rien de nouveau ici. <br><br>  Voici ma brève histoire de devenir un test: <br><br><ul><li>  1822 - Moteur de différence (Charles Babbage). </li><li>  1843 - Moteur analytique (Ada Lovelace). </li><li>  1878 - Edison introduit le terme «bug». </li><li>  1957 - Test et débogage de programmes (Charles Baker). </li><li>  1958 - La première équipe de test de logiciels (Gerald Weinberg). </li><li>  1968 - Crisis PO (Friedrich Bauer). </li><li>  Années 1970 - Modèle de cascade, modèle relationnel, décomposition, analyse critique ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">procédure pas à pas</a> ), conception et inspection de code, qualité et métriques, modèles de conception. </li><li>  Années 80 - Analyse CRUD, architecture système, autotest, modèle V, fiabilité, coût de la qualité, méthodes d'utilisation, modèles de conception OOP. </li><li>  Années 1990 - Scrum, tests d'utilisabilité, MoSCoW, tests heuristiques, automatisation et tests de logiciels. </li></ul><br>  Si vous vous référez à une génération de milléniaux comme moi, vous pourriez être étonné que les équipes de test aient existé LONGTEMPS avant votre naissance.  Arrêtez-vous un instant, inspirez, expirez, calmez-vous. <br>  L'histoire montre comment le type de test considéré comme «suffisamment bon» pour les parties intéressées a changé au fil du temps.  Phases approximatives qui ont été guidées lors des tests: <br><br><ul><li>  ... - Débogage 1956 </li><li>  1957-1978 Démonstration </li><li> 1979 - 1982 destruction </li><li>  1983 - 1987 estimation </li><li>  1988 - ... prévention </li></ul><br>  Par conséquent, des tests unitaires sont nécessaires pour <b>éviter les</b> écarts entre le projet et la mise en œuvre. <br><br><h2>  Qu'est-ce que le test vraiment? </h2><br>  Il existe différentes classifications des tests de logiciels.  Pour mieux comprendre la place du test unitaire, je ne citerai que les approches les plus répandues. <br><br>  Les tests sont: statiques et dynamiques, «boîte» (boîte blanche, boîte noire, boîte grise), niveaux et types.  Chaque approche utilise des critères de classification différents. <br><br><h2>  Tests statiques et dynamiques </h2><br>  Les tests statiques sont effectués sans exécution de code.  Cela comprend la relecture, la vérification, la révision du code (lors de l'observation du travail d'une autre programmation / paire), l'analyse critique, les inspections, etc. <br><br>  Les tests dynamiques pour obtenir les résultats corrects nécessitent l'exécution de code.  Par exemple, pour les <b>tests unitaires</b> , l'intégration, le système, l'acceptation et d'autres tests.  Autrement dit, les tests sont effectués à l'aide de données dynamiques, d'entrée et de sortie. <br><br><h2>  Approche boîte </h2><br>  Selon cette approche, tous les tests logiciels sont divisés en trois types de boîtes: <br><br><ul><li>  <b>Les</b> tests en <b>boîte blanche</b> vérifient les structures et modules internes, ignorent les fonctionnalités attendues pour les utilisateurs finaux.  Il peut s'agir de tests API, d'injection de pannes, de <b>tests unitaires, de tests d'</b> intégration. </li><li>  <b>Les</b> tests de la <b>boîte noire</b> s'intéressent davantage à <b>ce que fait le</b> logiciel, et non à la <b>façon dont</b> il le fait.  Cela signifie que les testeurs ne sont pas tenus de comprendre l'objet de test ou de comprendre comment il fonctionne sous le capot.  Ce type de test s'adresse aux utilisateurs finaux, leur expérience d'interaction avec une interface visible.  Les boîtes noires incluent les tests basés sur des modèles, les tests d'utilisation, les tables de transition d'état, les tests de spécifications, etc. </li><li>  Les tests de type « <b>boîte grise</b> » sont conçus avec une connaissance des algorithmes logiciels et des structures de données (boîte blanche), mais sont effectués au niveau de l'utilisateur (boîte noire).  Cela comprend les tests de régression et les tests de modèle. </li></ul><br>  Maintenant, pour vous dérouter, je dirai que les <b>tests unitaires</b> peuvent également s'appliquer à la «boîte noire», car vous pouvez comprendre le module testé, mais pas l'ensemble du système.  Bien que pour moi, ce soit toujours une "boîte blanche", et je vous suggère d'être d'accord avec cela. <br><br><h2>  Niveaux de test </h2><br>  Leur nombre varie, généralement entre 4 et 6, et ils sont tous utiles.  Les noms peuvent également être différents, selon la culture adoptée par l'entreprise, vous pouvez connaître les tests «d'intégration» comme «fonctionnels», les tests «système» comme «automatisés», etc.  Pour simplifier, je décrirai 5 niveaux: <br><br><ol><li>  <b>Tests unitaires</b> </li><li>  Test d'intégration. </li><li>  Test des interfaces des composants. </li><li>  Test du système. </li><li>  Test d'acceptation opérationnelle. </li></ol><br>  <b>Les tests unitaires testent</b> la fonctionnalité d'un morceau de code particulier, généralement une fonction à la fois.  Les tests d'intégration vérifient les interfaces entre les composants afin que les modules assemblés forment un système qui fonctionne comme prévu.  C'est un point important, car un grand nombre de tests, appelés tests unitaires, sont en fait des tests d'intégration et les développeurs les considèrent comme des modules.  Si vous avez l'intention d'utiliser plusieurs modules - cela teste l'intégration entre eux, et non les modules eux-mêmes.  Le test des interfaces des composants vérifie les données transférées entre les différents modules.  Par exemple, nous avons reçu des données du module 1 - vérifiées - transférées au module 2 - vérifiées.  Les tests du système sont des tests de bout en bout pour vérifier la conformité à toutes les exigences.  Des tests d'acceptation opérationnelle sont effectués pour vérifier l'état de préparation opérationnelle.  Il n'est pas fonctionnel, seule la fonctionnalité des services est vérifiée, si des sous-systèmes endommagent l'environnement et d'autres services. <br><br><h2>  Types de tests </h2><br>  Chaque type de test, quel que soit son niveau, peut également être divisé en d'autres types.  Il existe plus de 20 types courants.  Le plus courant: <br><br><ul><li>  <b>Test de régression</b> . </li><li>  Test d'acceptation. </li><li>  Test de fumée </li><li>  Uat </li><li>  <b>Essais destructifs</b> . </li><li>  Test de performance. </li><li>  <b>Test continu</b> . </li><li>  Tests d'utilisabilité. </li><li>  Test de sécurité. </li></ul><br>  D'après le nom, il est clair pourquoi tel ou tel type de test est prévu.  Gras sont les tests unitaires en PHP.  Si vous le souhaitez, vous pouvez appliquer chacun de ces termes aux tests unitaires.  Cependant, la principale variété de tests unitaires sont des tests de régression, qui vérifient si tous les modules du système sont exécutés correctement après avoir apporté des modifications au code. <br><br>  Vous savez maintenant que les tests unitaires sont dynamiques, appartiennent à la classe «boîte blanche», sont effectués au niveau du module, sont des tests de régression, mais les tests unitaires peuvent être compris comme de nombreux types de tests.  Alors, quels sont vraiment les tests unitaires? <br><br><h2>  Qu'est-ce qu'un test unitaire? </h2><br>  Un modèle en V est une représentation graphique des niveaux, types et objectifs ci-dessus dans le cycle de vie du développement logiciel. <br><br><img src="https://habrastorage.org/webt/-z/sk/ee/-zskeemvq28-zgepwlt7cbd6xjw.jpeg"><br><br>  Après avoir vérifié et approuvé les exigences détaillées du produit, lorsqu'ils ont commencé à écrire du code, les tests unitaires deviennent la première ligne de défense contre toute incohérence.  Par conséquent, les entreprises qui comprennent ce qu'elles font forcent les développeurs à utiliser des tests unitaires ou même TDD, car il est beaucoup moins cher de corriger les bogues dans les phases initiales que dans les phases ultérieures. <br><br>  Et c'est juste.  Les tests unitaires présentent de nombreux avantages.  Ce sont: <br><br><ul><li>  Isolez chaque partie du programme et vérifiez son exactitude. </li><li>  Aidez à détecter les problèmes tôt. </li><li>  Ils incitent les développeurs à penser en termes d'entrée, de sortie et de conditions erronées. </li><li>  Ils donnent au code un aspect pratique pour les tests, facilitent la refactorisation future. </li><li>  Simplifiez l'intégration des modules de travail (!). </li><li>  Remplacez partiellement la documentation technique. </li><li>  Obligé de séparer l'interface de l'implémentation. </li><li>  Ils prouvent que le code du module fonctionne comme prévu (au moins mathématiquement). </li><li>  Peut être utilisé comme suite de tests de régression de bas niveau. </li><li>  Démontrer les progrès de l'intégration système incomplète. </li><li>  Réduisez le coût de la correction des bogues (avec TDD - encore plus). </li><li>  Ils vous permettent d'améliorer l'architecture de l'application en déterminant la responsabilité des modules. </li><li>  Si vous pouvez le tester, vous pouvez le connecter à votre système. </li><li>  Les tests unitaires sont amusants! </li></ul><br>  Cependant, il y a certaines limitations auxquelles vous avez pensé, probablement en lisant cette liste: <br><br><ul><li>  Les tests unitaires ne détectent pas les erreurs d'intégration. </li><li>  Chaque expression booléenne nécessite au moins deux tests et le nombre augmente rapidement. </li><li>  Les tests unitaires sont tout aussi bogués que le code qu'ils testent. </li><li>  La liaison des tests à quelques cadres ou bibliothèques spécifiques peut limiter le flux de travail. </li><li>  La plupart des tests sont écrits une fois le développement terminé.  C'est triste.  Utilisez TDD! </li><li>  Peut-être qu'après un peu de refactoring, le système fonctionnera comme avant, mais les tests échoueront. </li><li>  Le coût du développement augmente. </li><li>  Erreur humaine: commenter les tests cassés. </li><li>  Erreur humaine: ajout de solutions de contournement au code spécifiquement pour réussir les tests unitaires. </li></ul><br>  Ce dernier me tue le plus.  (Presque) dans chaque projet, directement dans le code source de l'application de travail, je trouve des lignes comme «s'il s'agit d'un test unitaire, charge une base de données SQLite de substitution, sinon charge une autre base de données», ou «s'il s'agit d'un test unitaire, n'envoie pas d'e-mail, sinon envoyer ", etc.  Si votre application a une mauvaise architecture, ne prétendez pas que vous pouvez réparer un logiciel moche avec un bon test, cela ne s'améliorera pas. <br><br>  J'ai souvent discuté avec des collègues et des clients de ce qu'est un bon test unitaire.  Il: <br><br><ul><li>  Vite. </li><li>  Automatisé. </li><li>  Contrôle entièrement toutes ses dépendances. </li><li>  Fiable: il peut être lancé dans n'importe quel ordre, indépendamment des autres tests. </li><li>  Il ne peut être exécuté qu'en mémoire (pas d'interaction avec la base de données, lecture / écriture dans le système de fichiers). </li><li>  Renvoie toujours un seul résultat. </li><li>  Pratique pour la lecture et l'accompagnement. </li><li>  Ne teste pas la configuration SUT (système sous test). </li><li>  A une TÂCHE UNIQUE clairement définie. </li><li>  Il est bien nommé (et suffisamment compréhensible pour éviter le débogage juste pour comprendre ce qui échoue). </li></ul><br>  Pour ceux qui ont souri après avoir lu «automatisé»: je ne voulais pas intégrer PHPUnit ou JUnit dans les pipelines CI.  Le fait est que si vous modifiez le code, enregistrez-le et ne savez pas si les modules réussissent leurs tests, ils ne sont pas automatisés, mais le devraient.  L'option gagnante est le suivi des fichiers. <br><br><h2>  Que devrait-on soumettre aux tests unitaires? </h2><br>  Dans les systèmes normaux, des tests unitaires doivent être écrits pour: <br><br><ul><li>  Modules - parties isolées et indivisibles du système qui exécutent une tâche (fonction, méthode, classe). </li><li>  Méthodes publiques. </li><li>  Des méthodes protégées, mais seulement dans de rares cas et quand personne ne le voit. </li><li>  Bugs et leurs correctifs. </li></ul><br>  La définition d'un test unitaire dépend du développeur qui a écrit le code.  En PHP, c'est presque toujours une méthode ou une fonction de classe, car c'est un <b>logiciel indivisible qui a du sens en soi</b> .  Plusieurs fois, j'ai vu comment les développeurs utilisaient un tableau de miniclasses à une méthode en tant que module unique.  Cela est logique si une fonctionnalité minimale nécessite plusieurs objets. <br><br>  Vous pouvez donc déterminer vous-même ce qu'est un module pour vous.  Ou vous pouvez tester les méthodes une par une, rendant la vie plus facile à ce type qui travaillera ensuite avec le code. <br><br>  Si vous n'effectuez pas de tests unitaires, je vous propose de le faire après le prochain gros bug.  Vérifiez à quelle méthode il sera associé, écrivez un test qui a échoué avec les bons arguments et le bon résultat, corrigez le bogue, relancez le test unitaire.  S'il est passé, vous pouvez être sûr que ce bogue a dû être corrigé pour la dernière fois (en tenant compte de vos scénarios d'entrée spécifiques). <br><br>  Cette approche facilite la compréhension des tests unitaires.  Analysez chaque méthode séparément.  Les fournisseurs de données peuvent vous aider à déterminer les entrées et les sorties de tout scénario qui vous vient à l'esprit, donc quoi qu'il arrive, vous saurez à quoi vous attendre. <br><br><h2>  Ce qui n'a PAS besoin d'être testé </h2><br>  Il est un peu plus difficile de déterminer que vous n'avez pas besoin de tester.  J'ai essayé de compiler une liste d'éléments qui <b>n'ont pas besoin</b> d' <b>être</b> soumis à des tests unitaires: <br><br><ul><li>  Fonctionnalité hors du champ des modules (!) </li><li>  Intégration de modules avec d'autres modules (!) </li><li>  Comportement non isolé (dépendances immuables, bases de données réelles, réseau) </li><li>  Méthodes privées et sécurisées. </li><li>  Méthodes statiques. </li><li>  Bibliothèques externes. </li><li>  Votre cadre. </li></ul><br>  Je suis sûr que les tests unitaires ne doivent être appliqués à aucune des solutions ci-dessus, à l'exception des méthodes statiques.  J'aime faire valoir que statique, par essence, signifie procéduralité et, dans de nombreux cas, la procéduralité est globale.  Si la méthode statique appelle une autre méthode statique, cette dépendance ne peut pas être remplacée.  Cela signifie que vous testez maintenant de manière isolée.  Et puis ce n'est plus un test unitaire.  D'un autre côté, c'est la partie du code qui peut vivre seule, elle a un but, et elle doit être testée pour s'assurer que, quelle que soit la partie de ce système stupide que la partie testée du code appelle, elle ne cassera pas.  Par conséquent, je pense que vous pouvez tester des méthodes statiques si vous êtes sûr que la sortie de votre test ne peut pas être modifiée par un autre test et que le langage ou le framework vous permet de tester nativement. <br><br><h2>  Comment écrire des tests unitaires? </h2><br><ul><li>  Écrivez un code adapté aux tests unitaires, puis testez-le. </li><li>  Écrivez un code adapté aux tests unitaires, puis testez-le. </li><li>  Écrivez un code adapté aux tests unitaires, puis testez-le. </li></ul><br>  Si «alors testez-le» ne suffit pas, alors <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">laracasts.com</a> a de très bonnes vidéos sur les tests unitaires PHP.  Il existe de nombreux sites dédiés à la même tâche dans d'autres langues.  Je ne vois aucune raison d'expliquer comment je fais des tests unitaires, car les outils changent assez rapidement, et lorsque vous lisez ce texte, je peux passer de PHPUnit à Kahlan.  Ou pas.  Qui sait. <br><br>  Mais répondre à la première question (comment écrire du code adapté aux tests unitaires) est beaucoup plus facile et il est peu probable que la situation change beaucoup au fil du temps: <br><br><ul><li>  <b>SOLIDE</b> </li><li>  <b>SEC</b> </li><li>  L'absence de <b>nouveaux</b> mots clés dans le constructeur. </li><li>  L'absence de <b>boucles</b> dans le constructeur (et de transitions, si spécifié). </li><li>  Manque de méthodes, paramètres et classes statiques. </li><li>  Manque de méthodes setup (): les objets doivent être complètement initialisés après la construction. </li><li>  L'absence de singleton (statut mondial) et d'autres antipatternes non testables. </li><li>  Le manque d'objets omnipotents (objets de Dieu). </li><li>  Manque de classes à fonctionnalités mixtes (classes à préoccupations mixtes). </li><li>  Pas de dépendances cachées. </li></ul><br>  Maintenant, sachant ce que sont les tests unitaires et ce qui ne sont pas, ce dont vous avez besoin et ce que vous n'avez pas besoin de tester, quelle place prennent les tests unitaires dans le cycle de vie du développement logiciel, il vous sera plus facile de les implémenter.  Reste à trouver un framework ou une bibliothèque à votre goût.  En cas de doute, prenez le cadre / langage standard de facto. <br><br>  En conclusion: les tests unitaires sont très importants pour les développeurs et les entreprises.  Ils doivent être écrits, il existe des méthodes éprouvées qui vous aideront à couvrir facilement les modules avec des tests, principalement en préparant les modules eux-mêmes.  Mais toutes ces techniques n'ont pas de sens sans la connaissance de la théorie des tests décrite dans cet article.  Vous devez être capable de distinguer les tests unitaires des tests d'autres types.  Et lorsque vous avez une compréhension claire dans votre tête, il vous sera alors beaucoup plus facile d'écrire des tests. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr412695/">https://habr.com/ru/post/fr412695/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr412685/index.html">Suivi de chemin GPU Unity - Partie 2</a></li>
<li><a href="../fr412687/index.html">Implémentez IdM. Procédures et moyens techniques - du basique à l'IdM</a></li>
<li><a href="../fr412689/index.html">L'analyse informatique prédictive rationalise la surveillance des applications distribuées</a></li>
<li><a href="../fr412691/index.html">Blague de 5 ans sur Facebook ou histoire médico-légale</a></li>
<li><a href="../fr412693/index.html">Écrivez du code facile à supprimer et à déboguer</a></li>
<li><a href="../fr412697/index.html">L'IoT en tant que matière universelle pour une université technique multidisciplinaire</a></li>
<li><a href="../fr412699/index.html">Explication simple des principes SOLID</a></li>
<li><a href="../fr412701/index.html">Le chauffage le plus intelligent</a></li>
<li><a href="../fr412703/index.html">Lors d'une conférence avec Veeam: bilan de VeeamON 2018 et invitation au VeeamON Forum à Moscou</a></li>
<li><a href="../fr412705/index.html">Piratage du système: comment nous avons changé la sélection et l'adaptation des développeurs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>