<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨â€ğŸ”§ ğŸ¤·ğŸ» ğŸ™†ğŸ¿ L'image globale des tests unitaires ğŸ’‚ğŸ¼ ğŸ‘¨â€ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦ ğŸ’—</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ce n'est pas un guide sur les caractÃ¨res que vous devez entrer dans l'Ã©diteur de code pour obtenir des tests unitaires. C'est une nourriture pour l'es...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>L'image globale des tests unitaires</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/412695/"><img src="https://habrastorage.org/webt/di/az/zt/diazzt3uova8gflxtil7ecuxggu.png"><br><br>  Ce n'est pas un guide sur les caractÃ¨res que vous devez entrer dans l'Ã©diteur de code pour obtenir des tests unitaires.  C'est une nourriture pour l'esprit, qui doit Ãªtre consommÃ©e <b>avant de</b> prendre ces mesures. <br><br>  Le sujet des tests unitaires n'est pas aussi simple qu'il y paraÃ®t.  Beaucoup d'entre nous, les dÃ©veloppeurs, viennent aux tests unitaires sous la pression des clients, des employÃ©s, des collÃ¨gues, de leurs idoles, etc.  Nous comprenons rapidement sa valeur et, aprÃ¨s avoir terminÃ© les prÃ©paratifs techniques, nous oublions le tableau gÃ©nÃ©ral, si jamais nous l'avons compris.  Dans cet article, je parlerai briÃ¨vement de ce que les tests unitaires sont Ã  la fois et de ce qui ne l'est pas en gÃ©nÃ©ral, et en PHP, et en mÃªme temps, je dÃ©crirai la place qu'occupent les tests unitaires dans l'AQ. <br><a name="habracut"></a><br><h2>  Qu'est-ce que le test? </h2><br>  Avant de plonger dans les tests unitaires, vous devez Ã©tudier la thÃ©orie du test lui-mÃªme afin de ne pas faire d'erreurs comme celles faites par les auteurs de l'un des frameworks PHP les plus populaires: ils ont montrÃ© des tests d'intÃ©gration sur leur site Web et les ont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">appelÃ©s</a> tests unitaires.  Non, Laravel, ce ne sont pas des tests unitaires.  Bien que cela ne m'empÃªche pas de toujours aimer ce cadre. <br><br>  Les tests de logiciels sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dÃ©finis</a> comme Â«une enquÃªte menÃ©e pour fournir aux parties intÃ©ressÃ©es des informations sur la qualitÃ© des produitsÂ».  Cela s'oppose au "test logiciel est un gaspillage du budget du projet par les dÃ©veloppeurs qui ne font rien d'important et demandent ensuite plus de temps et d'argent, car" rien "peut Ãªtre trÃ¨s cher."  Rien de nouveau ici. <br><br>  Voici ma brÃ¨ve histoire de devenir un test: <br><br><ul><li>  1822 - Moteur de diffÃ©rence (Charles Babbage). </li><li>  1843 - Moteur analytique (Ada Lovelace). </li><li>  1878 - Edison introduit le terme Â«bugÂ». </li><li>  1957 - Test et dÃ©bogage de programmes (Charles Baker). </li><li>  1958 - La premiÃ¨re Ã©quipe de test de logiciels (Gerald Weinberg). </li><li>  1968 - Crisis PO (Friedrich Bauer). </li><li>  AnnÃ©es 1970 - ModÃ¨le de cascade, modÃ¨le relationnel, dÃ©composition, analyse critique ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">procÃ©dure pas Ã  pas</a> ), conception et inspection de code, qualitÃ© et mÃ©triques, modÃ¨les de conception. </li><li>  AnnÃ©es 80 - Analyse CRUD, architecture systÃ¨me, autotest, modÃ¨le V, fiabilitÃ©, coÃ»t de la qualitÃ©, mÃ©thodes d'utilisation, modÃ¨les de conception OOP. </li><li>  AnnÃ©es 1990 - Scrum, tests d'utilisabilitÃ©, MoSCoW, tests heuristiques, automatisation et tests de logiciels. </li></ul><br>  Si vous vous rÃ©fÃ©rez Ã  une gÃ©nÃ©ration de millÃ©niaux comme moi, vous pourriez Ãªtre Ã©tonnÃ© que les Ã©quipes de test aient existÃ© LONGTEMPS avant votre naissance.  ArrÃªtez-vous un instant, inspirez, expirez, calmez-vous. <br>  L'histoire montre comment le type de test considÃ©rÃ© comme Â«suffisamment bonÂ» pour les parties intÃ©ressÃ©es a changÃ© au fil du temps.  Phases approximatives qui ont Ã©tÃ© guidÃ©es lors des tests: <br><br><ul><li>  ... - DÃ©bogage 1956 </li><li>  1957-1978 DÃ©monstration </li><li> 1979 - 1982 destruction </li><li>  1983 - 1987 estimation </li><li>  1988 - ... prÃ©vention </li></ul><br>  Par consÃ©quent, des tests unitaires sont nÃ©cessaires pour <b>Ã©viter les</b> Ã©carts entre le projet et la mise en Å“uvre. <br><br><h2>  Qu'est-ce que le test vraiment? </h2><br>  Il existe diffÃ©rentes classifications des tests de logiciels.  Pour mieux comprendre la place du test unitaire, je ne citerai que les approches les plus rÃ©pandues. <br><br>  Les tests sont: statiques et dynamiques, Â«boÃ®teÂ» (boÃ®te blanche, boÃ®te noire, boÃ®te grise), niveaux et types.  Chaque approche utilise des critÃ¨res de classification diffÃ©rents. <br><br><h2>  Tests statiques et dynamiques </h2><br>  Les tests statiques sont effectuÃ©s sans exÃ©cution de code.  Cela comprend la relecture, la vÃ©rification, la rÃ©vision du code (lors de l'observation du travail d'une autre programmation / paire), l'analyse critique, les inspections, etc. <br><br>  Les tests dynamiques pour obtenir les rÃ©sultats corrects nÃ©cessitent l'exÃ©cution de code.  Par exemple, pour les <b>tests unitaires</b> , l'intÃ©gration, le systÃ¨me, l'acceptation et d'autres tests.  Autrement dit, les tests sont effectuÃ©s Ã  l'aide de donnÃ©es dynamiques, d'entrÃ©e et de sortie. <br><br><h2>  Approche boÃ®te </h2><br>  Selon cette approche, tous les tests logiciels sont divisÃ©s en trois types de boÃ®tes: <br><br><ul><li>  <b>Les</b> tests en <b>boÃ®te blanche</b> vÃ©rifient les structures et modules internes, ignorent les fonctionnalitÃ©s attendues pour les utilisateurs finaux.  Il peut s'agir de tests API, d'injection de pannes, de <b>tests unitaires, de tests d'</b> intÃ©gration. </li><li>  <b>Les</b> tests de la <b>boÃ®te noire</b> s'intÃ©ressent davantage Ã  <b>ce que fait le</b> logiciel, et non Ã  la <b>faÃ§on dont</b> il le fait.  Cela signifie que les testeurs ne sont pas tenus de comprendre l'objet de test ou de comprendre comment il fonctionne sous le capot.  Ce type de test s'adresse aux utilisateurs finaux, leur expÃ©rience d'interaction avec une interface visible.  Les boÃ®tes noires incluent les tests basÃ©s sur des modÃ¨les, les tests d'utilisation, les tables de transition d'Ã©tat, les tests de spÃ©cifications, etc. </li><li>  Les tests de type Â« <b>boÃ®te grise</b> Â» sont conÃ§us avec une connaissance des algorithmes logiciels et des structures de donnÃ©es (boÃ®te blanche), mais sont effectuÃ©s au niveau de l'utilisateur (boÃ®te noire).  Cela comprend les tests de rÃ©gression et les tests de modÃ¨le. </li></ul><br>  Maintenant, pour vous dÃ©router, je dirai que les <b>tests unitaires</b> peuvent Ã©galement s'appliquer Ã  la Â«boÃ®te noireÂ», car vous pouvez comprendre le module testÃ©, mais pas l'ensemble du systÃ¨me.  Bien que pour moi, ce soit toujours une "boÃ®te blanche", et je vous suggÃ¨re d'Ãªtre d'accord avec cela. <br><br><h2>  Niveaux de test </h2><br>  Leur nombre varie, gÃ©nÃ©ralement entre 4 et 6, et ils sont tous utiles.  Les noms peuvent Ã©galement Ãªtre diffÃ©rents, selon la culture adoptÃ©e par l'entreprise, vous pouvez connaÃ®tre les tests Â«d'intÃ©grationÂ» comme Â«fonctionnelsÂ», les tests Â«systÃ¨meÂ» comme Â«automatisÃ©sÂ», etc.  Pour simplifier, je dÃ©crirai 5 niveaux: <br><br><ol><li>  <b>Tests unitaires</b> </li><li>  Test d'intÃ©gration. </li><li>  Test des interfaces des composants. </li><li>  Test du systÃ¨me. </li><li>  Test d'acceptation opÃ©rationnelle. </li></ol><br>  <b>Les tests unitaires testent</b> la fonctionnalitÃ© d'un morceau de code particulier, gÃ©nÃ©ralement une fonction Ã  la fois.  Les tests d'intÃ©gration vÃ©rifient les interfaces entre les composants afin que les modules assemblÃ©s forment un systÃ¨me qui fonctionne comme prÃ©vu.  C'est un point important, car un grand nombre de tests, appelÃ©s tests unitaires, sont en fait des tests d'intÃ©gration et les dÃ©veloppeurs les considÃ¨rent comme des modules.  Si vous avez l'intention d'utiliser plusieurs modules - cela teste l'intÃ©gration entre eux, et non les modules eux-mÃªmes.  Le test des interfaces des composants vÃ©rifie les donnÃ©es transfÃ©rÃ©es entre les diffÃ©rents modules.  Par exemple, nous avons reÃ§u des donnÃ©es du module 1 - vÃ©rifiÃ©es - transfÃ©rÃ©es au module 2 - vÃ©rifiÃ©es.  Les tests du systÃ¨me sont des tests de bout en bout pour vÃ©rifier la conformitÃ© Ã  toutes les exigences.  Des tests d'acceptation opÃ©rationnelle sont effectuÃ©s pour vÃ©rifier l'Ã©tat de prÃ©paration opÃ©rationnelle.  Il n'est pas fonctionnel, seule la fonctionnalitÃ© des services est vÃ©rifiÃ©e, si des sous-systÃ¨mes endommagent l'environnement et d'autres services. <br><br><h2>  Types de tests </h2><br>  Chaque type de test, quel que soit son niveau, peut Ã©galement Ãªtre divisÃ© en d'autres types.  Il existe plus de 20 types courants.  Le plus courant: <br><br><ul><li>  <b>Test de rÃ©gression</b> . </li><li>  Test d'acceptation. </li><li>  Test de fumÃ©e </li><li>  Uat </li><li>  <b>Essais destructifs</b> . </li><li>  Test de performance. </li><li>  <b>Test continu</b> . </li><li>  Tests d'utilisabilitÃ©. </li><li>  Test de sÃ©curitÃ©. </li></ul><br>  D'aprÃ¨s le nom, il est clair pourquoi tel ou tel type de test est prÃ©vu.  Gras sont les tests unitaires en PHP.  Si vous le souhaitez, vous pouvez appliquer chacun de ces termes aux tests unitaires.  Cependant, la principale variÃ©tÃ© de tests unitaires sont des tests de rÃ©gression, qui vÃ©rifient si tous les modules du systÃ¨me sont exÃ©cutÃ©s correctement aprÃ¨s avoir apportÃ© des modifications au code. <br><br>  Vous savez maintenant que les tests unitaires sont dynamiques, appartiennent Ã  la classe Â«boÃ®te blancheÂ», sont effectuÃ©s au niveau du module, sont des tests de rÃ©gression, mais les tests unitaires peuvent Ãªtre compris comme de nombreux types de tests.  Alors, quels sont vraiment les tests unitaires? <br><br><h2>  Qu'est-ce qu'un test unitaire? </h2><br>  Un modÃ¨le en V est une reprÃ©sentation graphique des niveaux, types et objectifs ci-dessus dans le cycle de vie du dÃ©veloppement logiciel. <br><br><img src="https://habrastorage.org/webt/-z/sk/ee/-zskeemvq28-zgepwlt7cbd6xjw.jpeg"><br><br>  AprÃ¨s avoir vÃ©rifiÃ© et approuvÃ© les exigences dÃ©taillÃ©es du produit, lorsqu'ils ont commencÃ© Ã  Ã©crire du code, les tests unitaires deviennent la premiÃ¨re ligne de dÃ©fense contre toute incohÃ©rence.  Par consÃ©quent, les entreprises qui comprennent ce qu'elles font forcent les dÃ©veloppeurs Ã  utiliser des tests unitaires ou mÃªme TDD, car il est beaucoup moins cher de corriger les bogues dans les phases initiales que dans les phases ultÃ©rieures. <br><br>  Et c'est juste.  Les tests unitaires prÃ©sentent de nombreux avantages.  Ce sont: <br><br><ul><li>  Isolez chaque partie du programme et vÃ©rifiez son exactitude. </li><li>  Aidez Ã  dÃ©tecter les problÃ¨mes tÃ´t. </li><li>  Ils incitent les dÃ©veloppeurs Ã  penser en termes d'entrÃ©e, de sortie et de conditions erronÃ©es. </li><li>  Ils donnent au code un aspect pratique pour les tests, facilitent la refactorisation future. </li><li>  Simplifiez l'intÃ©gration des modules de travail (!). </li><li>  Remplacez partiellement la documentation technique. </li><li>  ObligÃ© de sÃ©parer l'interface de l'implÃ©mentation. </li><li>  Ils prouvent que le code du module fonctionne comme prÃ©vu (au moins mathÃ©matiquement). </li><li>  Peut Ãªtre utilisÃ© comme suite de tests de rÃ©gression de bas niveau. </li><li>  DÃ©montrer les progrÃ¨s de l'intÃ©gration systÃ¨me incomplÃ¨te. </li><li>  RÃ©duisez le coÃ»t de la correction des bogues (avec TDD - encore plus). </li><li>  Ils vous permettent d'amÃ©liorer l'architecture de l'application en dÃ©terminant la responsabilitÃ© des modules. </li><li>  Si vous pouvez le tester, vous pouvez le connecter Ã  votre systÃ¨me. </li><li>  Les tests unitaires sont amusants! </li></ul><br>  Cependant, il y a certaines limitations auxquelles vous avez pensÃ©, probablement en lisant cette liste: <br><br><ul><li>  Les tests unitaires ne dÃ©tectent pas les erreurs d'intÃ©gration. </li><li>  Chaque expression boolÃ©enne nÃ©cessite au moins deux tests et le nombre augmente rapidement. </li><li>  Les tests unitaires sont tout aussi boguÃ©s que le code qu'ils testent. </li><li>  La liaison des tests Ã  quelques cadres ou bibliothÃ¨ques spÃ©cifiques peut limiter le flux de travail. </li><li>  La plupart des tests sont Ã©crits une fois le dÃ©veloppement terminÃ©.  C'est triste.  Utilisez TDD! </li><li>  Peut-Ãªtre qu'aprÃ¨s un peu de refactoring, le systÃ¨me fonctionnera comme avant, mais les tests Ã©choueront. </li><li>  Le coÃ»t du dÃ©veloppement augmente. </li><li>  Erreur humaine: commenter les tests cassÃ©s. </li><li>  Erreur humaine: ajout de solutions de contournement au code spÃ©cifiquement pour rÃ©ussir les tests unitaires. </li></ul><br>  Ce dernier me tue le plus.  (Presque) dans chaque projet, directement dans le code source de l'application de travail, je trouve des lignes comme Â«s'il s'agit d'un test unitaire, charge une base de donnÃ©es SQLite de substitution, sinon charge une autre base de donnÃ©esÂ», ou Â«s'il s'agit d'un test unitaire, n'envoie pas d'e-mail, sinon envoyer ", etc.  Si votre application a une mauvaise architecture, ne prÃ©tendez pas que vous pouvez rÃ©parer un logiciel moche avec un bon test, cela ne s'amÃ©liorera pas. <br><br>  J'ai souvent discutÃ© avec des collÃ¨gues et des clients de ce qu'est un bon test unitaire.  Il: <br><br><ul><li>  Vite. </li><li>  AutomatisÃ©. </li><li>  ContrÃ´le entiÃ¨rement toutes ses dÃ©pendances. </li><li>  Fiable: il peut Ãªtre lancÃ© dans n'importe quel ordre, indÃ©pendamment des autres tests. </li><li>  Il ne peut Ãªtre exÃ©cutÃ© qu'en mÃ©moire (pas d'interaction avec la base de donnÃ©es, lecture / Ã©criture dans le systÃ¨me de fichiers). </li><li>  Renvoie toujours un seul rÃ©sultat. </li><li>  Pratique pour la lecture et l'accompagnement. </li><li>  Ne teste pas la configuration SUT (systÃ¨me sous test). </li><li>  A une TÃ‚CHE UNIQUE clairement dÃ©finie. </li><li>  Il est bien nommÃ© (et suffisamment comprÃ©hensible pour Ã©viter le dÃ©bogage juste pour comprendre ce qui Ã©choue). </li></ul><br>  Pour ceux qui ont souri aprÃ¨s avoir lu Â«automatisÃ©Â»: je ne voulais pas intÃ©grer PHPUnit ou JUnit dans les pipelines CI.  Le fait est que si vous modifiez le code, enregistrez-le et ne savez pas si les modules rÃ©ussissent leurs tests, ils ne sont pas automatisÃ©s, mais le devraient.  L'option gagnante est le suivi des fichiers. <br><br><h2>  Que devrait-on soumettre aux tests unitaires? </h2><br>  Dans les systÃ¨mes normaux, des tests unitaires doivent Ãªtre Ã©crits pour: <br><br><ul><li>  Modules - parties isolÃ©es et indivisibles du systÃ¨me qui exÃ©cutent une tÃ¢che (fonction, mÃ©thode, classe). </li><li>  MÃ©thodes publiques. </li><li>  Des mÃ©thodes protÃ©gÃ©es, mais seulement dans de rares cas et quand personne ne le voit. </li><li>  Bugs et leurs correctifs. </li></ul><br>  La dÃ©finition d'un test unitaire dÃ©pend du dÃ©veloppeur qui a Ã©crit le code.  En PHP, c'est presque toujours une mÃ©thode ou une fonction de classe, car c'est un <b>logiciel indivisible qui a du sens en soi</b> .  Plusieurs fois, j'ai vu comment les dÃ©veloppeurs utilisaient un tableau de miniclasses Ã  une mÃ©thode en tant que module unique.  Cela est logique si une fonctionnalitÃ© minimale nÃ©cessite plusieurs objets. <br><br>  Vous pouvez donc dÃ©terminer vous-mÃªme ce qu'est un module pour vous.  Ou vous pouvez tester les mÃ©thodes une par une, rendant la vie plus facile Ã  ce type qui travaillera ensuite avec le code. <br><br>  Si vous n'effectuez pas de tests unitaires, je vous propose de le faire aprÃ¨s le prochain gros bug.  VÃ©rifiez Ã  quelle mÃ©thode il sera associÃ©, Ã©crivez un test qui a Ã©chouÃ© avec les bons arguments et le bon rÃ©sultat, corrigez le bogue, relancez le test unitaire.  S'il est passÃ©, vous pouvez Ãªtre sÃ»r que ce bogue a dÃ» Ãªtre corrigÃ© pour la derniÃ¨re fois (en tenant compte de vos scÃ©narios d'entrÃ©e spÃ©cifiques). <br><br>  Cette approche facilite la comprÃ©hension des tests unitaires.  Analysez chaque mÃ©thode sÃ©parÃ©ment.  Les fournisseurs de donnÃ©es peuvent vous aider Ã  dÃ©terminer les entrÃ©es et les sorties de tout scÃ©nario qui vous vient Ã  l'esprit, donc quoi qu'il arrive, vous saurez Ã  quoi vous attendre. <br><br><h2>  Ce qui n'a PAS besoin d'Ãªtre testÃ© </h2><br>  Il est un peu plus difficile de dÃ©terminer que vous n'avez pas besoin de tester.  J'ai essayÃ© de compiler une liste d'Ã©lÃ©ments qui <b>n'ont pas besoin</b> d' <b>Ãªtre</b> soumis Ã  des tests unitaires: <br><br><ul><li>  FonctionnalitÃ© hors du champ des modules (!) </li><li>  IntÃ©gration de modules avec d'autres modules (!) </li><li>  Comportement non isolÃ© (dÃ©pendances immuables, bases de donnÃ©es rÃ©elles, rÃ©seau) </li><li>  MÃ©thodes privÃ©es et sÃ©curisÃ©es. </li><li>  MÃ©thodes statiques. </li><li>  BibliothÃ¨ques externes. </li><li>  Votre cadre. </li></ul><br>  Je suis sÃ»r que les tests unitaires ne doivent Ãªtre appliquÃ©s Ã  aucune des solutions ci-dessus, Ã  l'exception des mÃ©thodes statiques.  J'aime faire valoir que statique, par essence, signifie procÃ©duralitÃ© et, dans de nombreux cas, la procÃ©duralitÃ© est globale.  Si la mÃ©thode statique appelle une autre mÃ©thode statique, cette dÃ©pendance ne peut pas Ãªtre remplacÃ©e.  Cela signifie que vous testez maintenant de maniÃ¨re isolÃ©e.  Et puis ce n'est plus un test unitaire.  D'un autre cÃ´tÃ©, c'est la partie du code qui peut vivre seule, elle a un but, et elle doit Ãªtre testÃ©e pour s'assurer que, quelle que soit la partie de ce systÃ¨me stupide que la partie testÃ©e du code appelle, elle ne cassera pas.  Par consÃ©quent, je pense que vous pouvez tester des mÃ©thodes statiques si vous Ãªtes sÃ»r que la sortie de votre test ne peut pas Ãªtre modifiÃ©e par un autre test et que le langage ou le framework vous permet de tester nativement. <br><br><h2>  Comment Ã©crire des tests unitaires? </h2><br><ul><li>  Ã‰crivez un code adaptÃ© aux tests unitaires, puis testez-le. </li><li>  Ã‰crivez un code adaptÃ© aux tests unitaires, puis testez-le. </li><li>  Ã‰crivez un code adaptÃ© aux tests unitaires, puis testez-le. </li></ul><br>  Si Â«alors testez-leÂ» ne suffit pas, alors <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">laracasts.com</a> a de trÃ¨s bonnes vidÃ©os sur les tests unitaires PHP.  Il existe de nombreux sites dÃ©diÃ©s Ã  la mÃªme tÃ¢che dans d'autres langues.  Je ne vois aucune raison d'expliquer comment je fais des tests unitaires, car les outils changent assez rapidement, et lorsque vous lisez ce texte, je peux passer de PHPUnit Ã  Kahlan.  Ou pas.  Qui sait. <br><br>  Mais rÃ©pondre Ã  la premiÃ¨re question (comment Ã©crire du code adaptÃ© aux tests unitaires) est beaucoup plus facile et il est peu probable que la situation change beaucoup au fil du temps: <br><br><ul><li>  <b>SOLIDE</b> </li><li>  <b>SEC</b> </li><li>  L'absence de <b>nouveaux</b> mots clÃ©s dans le constructeur. </li><li>  L'absence de <b>boucles</b> dans le constructeur (et de transitions, si spÃ©cifiÃ©). </li><li>  Manque de mÃ©thodes, paramÃ¨tres et classes statiques. </li><li>  Manque de mÃ©thodes setup (): les objets doivent Ãªtre complÃ¨tement initialisÃ©s aprÃ¨s la construction. </li><li>  L'absence de singleton (statut mondial) et d'autres antipatternes non testables. </li><li>  Le manque d'objets omnipotents (objets de Dieu). </li><li>  Manque de classes Ã  fonctionnalitÃ©s mixtes (classes Ã  prÃ©occupations mixtes). </li><li>  Pas de dÃ©pendances cachÃ©es. </li></ul><br>  Maintenant, sachant ce que sont les tests unitaires et ce qui ne sont pas, ce dont vous avez besoin et ce que vous n'avez pas besoin de tester, quelle place prennent les tests unitaires dans le cycle de vie du dÃ©veloppement logiciel, il vous sera plus facile de les implÃ©menter.  Reste Ã  trouver un framework ou une bibliothÃ¨que Ã  votre goÃ»t.  En cas de doute, prenez le cadre / langage standard de facto. <br><br>  En conclusion: les tests unitaires sont trÃ¨s importants pour les dÃ©veloppeurs et les entreprises.  Ils doivent Ãªtre Ã©crits, il existe des mÃ©thodes Ã©prouvÃ©es qui vous aideront Ã  couvrir facilement les modules avec des tests, principalement en prÃ©parant les modules eux-mÃªmes.  Mais toutes ces techniques n'ont pas de sens sans la connaissance de la thÃ©orie des tests dÃ©crite dans cet article.  Vous devez Ãªtre capable de distinguer les tests unitaires des tests d'autres types.  Et lorsque vous avez une comprÃ©hension claire dans votre tÃªte, il vous sera alors beaucoup plus facile d'Ã©crire des tests. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr412695/">https://habr.com/ru/post/fr412695/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr412685/index.html">Suivi de chemin GPU Unity - Partie 2</a></li>
<li><a href="../fr412687/index.html">ImplÃ©mentez IdM. ProcÃ©dures et moyens techniques - du basique Ã  l'IdM</a></li>
<li><a href="../fr412689/index.html">L'analyse informatique prÃ©dictive rationalise la surveillance des applications distribuÃ©es</a></li>
<li><a href="../fr412691/index.html">Blague de 5 ans sur Facebook ou histoire mÃ©dico-lÃ©gale</a></li>
<li><a href="../fr412693/index.html">Ã‰crivez du code facile Ã  supprimer et Ã  dÃ©boguer</a></li>
<li><a href="../fr412697/index.html">L'IoT en tant que matiÃ¨re universelle pour une universitÃ© technique multidisciplinaire</a></li>
<li><a href="../fr412699/index.html">Explication simple des principes SOLID</a></li>
<li><a href="../fr412701/index.html">Le chauffage le plus intelligent</a></li>
<li><a href="../fr412703/index.html">Lors d'une confÃ©rence avec Veeam: bilan de VeeamON 2018 et invitation au VeeamON Forum Ã  Moscou</a></li>
<li><a href="../fr412705/index.html">Piratage du systÃ¨me: comment nous avons changÃ© la sÃ©lection et l'adaptation des dÃ©veloppeurs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>