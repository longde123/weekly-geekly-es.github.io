<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🔬 👃 👩🏿 Konsistenz- und ACID-Garantien in verteilten Speichersystemen 👍🏻 🤸🏾 🛒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Verteilte Systeme werden verwendet, wenn eine horizontale Skalierung erforderlich ist, um Leistungsindikatoren bereitzustellen, die darauf hinweisen, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Konsistenz- und ACID-Garantien in verteilten Speichersystemen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/gridgain/blog/430852/">  Verteilte Systeme werden verwendet, wenn eine horizontale Skalierung erforderlich ist, um Leistungsindikatoren bereitzustellen, die darauf hinweisen, dass ein vertikal skaliertes System nicht in der Lage ist, angemessenes Geld bereitzustellen. <br><br>  Wie der Übergang von einem Single-Thread-Paradigma zu einem Multi-Thread-Paradigma erfordert die Migration zu einem verteilten System eine Art Eintauchen und Verständnis dafür, wie es im Inneren funktioniert und worauf Sie achten müssen. <br><br>  Eines der Probleme, mit denen eine Person konfrontiert ist, die ein Projekt auf ein verteiltes System migrieren oder ein Projekt darauf starten möchte, ist das zu wählende Produkt. <br><br>  Als Unternehmen, das bei der Entwicklung solcher Systeme „einen Hund gefressen“ hat, helfen wir unseren Kunden, fundierte Entscheidungen in Bezug auf verteilte Speichersysteme zu treffen.  Wir veröffentlichen auch eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihe von Webinaren</a> für ein breiteres Publikum, die sich auf Grundprinzipien in einer einfachen Sprache konzentrieren. Unabhängig von den spezifischen Essenspräferenzen können wichtige Funktionen festgelegt werden, um die Auswahl zu vereinfachen. <br><br>  Dieser Artikel basiert auf unseren Materialien zur Konsistenz und zu ACID-Garantien in verteilten Systemen. <br><a name="habracut"></a><br><h1>  Was ist das und warum wird es benötigt? </h1><br>  " <b>Datenkonsistenz</b> (manchmal <i>Datenkonsistenz</i> ) ist <i>Datenkonsistenz</i> untereinander, Datenintegrität und interne Konsistenz."  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> ) <br><br>  Konsistenz bedeutet, dass Anwendungen jederzeit sicher sein können, dass sie mit der richtigen, technisch relevanten Version der Daten arbeiten, und sich bei Entscheidungen darauf verlassen können. <br><br>  In verteilten Systemen wird die Gewährleistung der Konsistenz immer schwieriger und teurer, da eine ganze Reihe neuer Herausforderungen im Zusammenhang mit dem Netzwerkaustausch zwischen verschiedenen Knoten, der Möglichkeit des Ausfalls einzelner Knoten und - häufig - dem Fehlen eines einzelnen Speichers, der zur Überprüfung dienen kann, auftreten. <br><br>  Wenn ich beispielsweise ein System mit 4 Knoten habe: A, B, C und D, das Bankgeschäfte abwickelt, und die Knoten C und D von A und B getrennt sind (z. B. aufgrund von Netzwerkproblemen), ist dies jetzt möglicherweise nicht der Fall Ich habe Zugriff auf einen Teil der Transaktion.  Wie verhalte ich mich in dieser Situation?  Unterschiedliche Systeme verfolgen unterschiedliche Ansätze. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lm/8p/gw/lm8pgwmqnfcsp0uifu1hgiizhqg.png"></div><br>  Auf der obersten Ebene gibt es zwei Schlüsselrichtungen, die im CAP-Theorem ausgedrückt werden. <br><br>  „ <b>Das CAP-Theorem</b> (auch als <b>Brewer-Theorem bekannt</b> ) ist eine heuristische Aussage, dass es bei jeder Implementierung von verteiltem Computing möglich ist, nicht mehr als zwei der folgenden drei Eigenschaften bereitzustellen: <br><br><ul><li>  Datenkonsistenz (Eng. Konsistenz) - In allen Rechenknoten zu einem bestimmten Zeitpunkt widersprechen sich die Daten nicht. </li><li>  Verfügbarkeit (engl. Verfügbarkeit) - Jede Anfrage an ein verteiltes System endet mit einer korrekten Antwort, jedoch ohne Garantie, dass die Antworten aller Knoten des Systems übereinstimmen. </li><li>  Partitionstoleranz - Die Aufteilung eines verteilten Systems in mehrere isolierte Abschnitte führt nicht zu einer falschen Antwort von jedem Abschnitt. “ </li></ul><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> ) <br><br>  Wenn der CAP-Satz von Konsistenz spricht, impliziert er eine ziemlich strenge Definition, einschließlich der Linearisierung von Aufzeichnungen und Messwerten, und legt nur Konsistenz beim Schreiben einzelner Werte fest.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Martin Kleppman</a> ) <br><br>  Das CAP-Theorem besagt, dass wir, wenn wir gegen Netzwerkprobleme resistent sein wollen, im Allgemeinen entscheiden müssen, ob wir Opfer bringen wollen: Konsistenz oder Zugänglichkeit.  Es gibt auch eine erweiterte Version dieses Theorems - PACELC ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> ), die zusätzlich darüber spricht, dass wir auch ohne Netzwerkprobleme zwischen Antwortgeschwindigkeit und Konsistenz wählen müssen. <br><br>  Und obwohl auf den ersten Blick ein Eingeborener aus der Welt der klassischen DBMS zu sein scheint, dass die Wahl offensichtlich ist und Konsistenz das Wichtigste ist, was wir haben, ist dies bei weitem nicht immer der Fall, was das explosive Wachstum einer Reihe von NoSQL-DBMS deutlich macht, die eine andere Wahl getroffen haben und Trotzdem haben sie eine riesige Nutzerbasis.  Apache Cassandra mit seiner berühmten Konsistenz ist ein gutes Beispiel. <br><br>  Dies alles ist auf die Tatsache zurückzuführen, dass dies eine <i>Entscheidung ist</i> , die impliziert, dass wir etwas opfern und nicht immer bereit sind, es zu opfern. <br><br>  Oft wird das Problem der Konsistenz in verteilten Systemen einfach dadurch gelöst, dass diese Konsistenz aufgegeben wird. <br><br>  Es ist jedoch notwendig und wichtig zu verstehen, wann die Ablehnung dieser Konsistenz akzeptabel ist und wann sie eine kritische Geschäftsanforderung darstellt. <br><br>  Wenn ich beispielsweise eine Komponente entwerfe, die für das Speichern von Benutzersitzungen verantwortlich ist, ist mir die Konsistenz hier höchstwahrscheinlich nicht so wichtig, und Datenverlust ist nicht kritisch, wenn er nur in problematischen Fällen auftritt - sehr selten.  Das Schlimmste, was passieren wird, ist, dass sich der Benutzer anmelden muss, und für viele Unternehmen hat dies nur geringe Auswirkungen auf ihre finanzielle Leistung. <br><br>  Wenn ich den Datenstrom von Sensoren analysiere, ist es in vielen Fällen völlig unkritisch, einen Teil der Daten zu verlieren und für kurze Zeit ein Downsampling durchzuführen, insbesondere wenn ich die Daten endlich sehe. <br><br>  Wenn ich jedoch ein Bankensystem aufbaue, ist die Konsistenz der Bargeldtransaktionen für mein Unternehmen von entscheidender Bedeutung.  Wenn ich eine Strafe für das Darlehen eines Kunden erhalten habe, weil ich die Zahlung einfach nicht rechtzeitig gesehen habe, obwohl er im System war, ist dies sehr, sehr schlecht.  Außerdem kann der Kunde das gesamte Geld mehrmals von meiner Kreditkarte abheben, da ich zum Zeitpunkt der Transaktion Netzwerkprobleme hatte und die Abhebungsinformationen keinen Teil meines Clusters erreichten. <br><br>  Wenn Sie einen teuren Einkauf in einem Online-Shop tätigen, möchten Sie nicht, dass Ihre Bestellung trotz des Erfolgsberichts auf der Webseite vergessen wird. <br><br>  Wenn Sie sich jedoch für Konsistenz entscheiden, opfern Sie die Zugänglichkeit.  Und oft wird dies erwartet, höchstwahrscheinlich sind Sie mehr als einmal persönlich darauf gestoßen. <br><br>  Es ist besser, wenn im Warenkorb des Online-Shops die Meldung "Später versuchen, ein verteiltes DBMS ist nicht verfügbar" angezeigt wird, als wenn der Erfolg gemeldet und die Bestellung vergessen wird.  Es ist besser, eine Ablehnung einer Transaktion aufgrund der Nichtverfügbarkeit der Dienstleistungen der Bank zu erhalten, als den Erfolg und dann das Verfahren mit der Bank zu beeinträchtigen, da er vergessen hat, dass Sie den Kredit bezahlt haben. <br><br>  Wenn wir uns schließlich das erweiterte PACELC-Theorem ansehen, dann verstehen wir, dass wir selbst bei normalem Betrieb des Systems bei Auswahl der Konsistenz niedrige Latenzen opfern und möglicherweise eine geringere maximale Leistung erzielen können. <br><br>  Beantworten Sie daher die Frage „Warum ist dies erforderlich?“: Wenn es für Ihre Aufgabe wichtig ist, über aktuelle, konsistente Daten zu verfügen, führt die Alternative zu erheblichen Verlusten, die größer sind als die vorübergehende Nichtverfügbarkeit des Dienstes für den Zeitraum des Vorfalls oder dessen geringere Leistung. <br><br><h1>  Wie kann man das bereitstellen? </h1><br>  Dementsprechend ist die erste Entscheidung, die Sie treffen müssen, wo Sie sich im CAP-Theorem befinden. Sie möchten im Falle eines Vorfalls Konsistenz oder Verfügbarkeit. <br><br>  Als nächstes müssen Sie verstehen, auf welcher Ebene Sie Änderungen vornehmen möchten.  Vielleicht haben Sie gerade genug atomare Datensätze, die sich auf ein einzelnes Objekt auswirken, da MongoDB in der Lage und in der Lage war (jetzt erweitert es dies um zusätzliche Unterstützung für vollwertige Transaktionen).  Ich möchte Sie daran erinnern, dass der CAP-Satz nichts über die Konsistenz von Schreibvorgängen mit mehreren Objekten aussagt: Das System kann durchaus CP sein (d. H. Zugänglichkeitskonsistenz bevorzugen) und gleichzeitig nur atomare Einzeldatensätze bereitstellen. <br><br>  Wenn Ihnen dies nicht ausreicht, nähern wir uns dem Konzept vollwertiger verteilter ACID-Transaktionen. <br><br>  Ich stelle fest, dass wir selbst in der schönen neuen Welt der verteilten ACID-Transaktionen oft etwas opfern müssen.  Beispielsweise haben einige verteilte Speichersysteme verteilte Transaktionen, jedoch nur innerhalb einer einzelnen Partition.  Beispielsweise unterstützt das System den I-Teil möglicherweise nicht auf der von Ihnen benötigten Ebene, ohne Isolation oder mit einer unzureichenden Anzahl von Isolationsstufen. <br><br>  Diese Einschränkungen wurden häufig aus irgendeinem Grund vorgenommen: entweder um die Implementierung zu vereinfachen oder um beispielsweise die Leistung zu verbessern oder um etwas anderes zu tun.  Sie sind für eine große Anzahl von Fällen ausreichend, daher sollten Sie sie nicht als Nachteile für sich betrachten. <br><br>  Sie müssen verstehen, ob diese Einschränkungen für Ihr spezifisches Szenario ein Problem darstellen.  Wenn nicht, haben Sie mehr Auswahlmöglichkeiten und können beispielsweise Leistungsindikatoren oder der Fähigkeit des Systems, Katastrophenverträglichkeit usw. bereitzustellen, mehr Gewicht beimessen.  Schließlich dürfen wir nicht vergessen, dass in einer Reihe von Systemen diese Parameter so angepasst werden können, dass das System je nach Konfiguration CP oder AP sein kann. <br><br>  Wenn unser Produkt CP sein soll, hat es normalerweise entweder einen Quorum-Ansatz für die Datenauswahl oder dedizierte Knoten, die die Haupteigentümer der Datensätze sind. Alle Datenänderungen werden durch sie geleitet, und bei Netzwerkproblemen, wenn diese Hauptknoten nicht geben können Als Antwort wird angenommen, dass die Daten im Prinzip nicht abgerufen oder nicht vermittelt werden können, wenn eine externe, leicht zugängliche Komponente (z. B. der ZooKeeper-Cluster) sagen kann, welches der Clustersegmente das Hauptsegment ist, die aktuelle Version der Daten enthält und die Anforderung effektiv bedienen kann  s. <br><br>  Wenn wir nicht nur an CP interessiert sind, sondern an der Unterstützung vollwertiger verteilter ACID-Transaktionen, wird häufig eine einzige Wahrheitsquelle verwendet, beispielsweise ein zentraler Festplattenspeicher, bei dem unsere Knoten tatsächlich nur als Caches dienen, die deaktiviert werden können Festschreibungszeit oder das mehrphasige Festschreibungsprotokoll wird angewendet. <br><br>  Der erste Single-Disk-Ansatz vereinfacht auch die Implementierung, bietet geringe Latenzen bei verteilten Transaktionen, wird jedoch gegen eine sehr eingeschränkte Skalierbarkeit bei Lasten mit großem Aufzeichnungsvolumen eingetauscht. <br><br>  Der zweite Ansatz bietet viel mehr Freiheit bei der Skalierung und ist wiederum in zwei- ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> ) und dreiphasige ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> ) Festschreibungsprotokolle unterteilt. <br><br>  Stellen Sie sich ein zweiphasiges Commit vor, das beispielsweise Apache Ignite verwendet. <br><br><img src="https://habrastorage.org/webt/ha/1a/qx/ha1aqxrjarg8g-x81wdn2i3xcoe.png"><br>  ￼ <br>  Das Festschreibungsverfahren ist in zwei Phasen unterteilt: Vorbereiten und Festschreiben. <br><br>  In der Vorbereitungsphase wird eine Nachricht über die Vorbereitung des Commits vorbereitet, und jeder Teilnehmer führt bei Bedarf eine Sperre durch, führt alle Vorgänge bis einschließlich des tatsächlichen Commits aus und sendet die Vorbereitung an seine Replikate, sofern dies vom Produkt angenommen wird.  Wenn mindestens einer der Teilnehmer aus irgendeinem Grund mit einer Ablehnung antwortete oder sich als nicht verfügbar herausstellte - die Daten änderten sich nicht tatsächlich, gab es kein Commit.  Die Teilnehmer setzen Änderungen zurück, lösen Sperren und kehren in ihren ursprünglichen Zustand zurück. <br><br>  In der Festschreibungsphase wird die tatsächliche Ausführung der Festschreibung an die Clusterknoten gesendet.  Wenn aus irgendeinem Grund einige der Knoten nicht verfügbar waren oder mit einem Fehler geantwortet haben, wurden die Daten zu diesem Zeitpunkt in ihr Redo-Log eingegeben (da die Vorbereitung erfolgreich war), und das Festschreiben kann in jedem Fall zumindest in einem ausstehenden Zustand abgeschlossen werden. <br><br>  Wenn der Koordinator ausfällt, wird das Festschreiben in der Vorbereitungsphase abgebrochen. In der Festschreibungsphase kann ein neuer Koordinator ausgewählt werden. Wenn alle Knoten die Vorbereitung abgeschlossen haben, kann er überprüfen und sicherstellen, dass die Festschreibungsphase abgeschlossen ist. <br><br>  Verschiedene Produkte haben ihre eigenen Implementierungs- und Optimierungsfunktionen.  So können beispielsweise einige Produkte in einigen Fällen ein 2-Phasen-Commit auf ein 1-Phasen-Commit reduzieren und so erheblich an Leistung gewinnen. <br><br><h1>  Schlussfolgerungen </h1><br>  Wichtigste Schlussfolgerung: Verteilte Speichersysteme sind ein ziemlich entwickelter Markt, und Produkte darauf können eine hohe Datenkonsistenz bieten. <br><br>  Darüber hinaus befinden sich Produkte dieser Kategorie an verschiedenen Punkten der Konsistenzskala, von vollständig AP-Produkten ohne Transaktionsfähigkeit bis zu CP-Produkten, die zusätzlich vollwertige ACID-Transaktionen bereitstellen.  Einige Produkte können auf die eine oder andere Weise konfiguriert werden. <br><br>  Wenn Sie wählen, was Sie brauchen, müssen Sie die Bedürfnisse Ihres Falles berücksichtigen und gut verstehen, welche Opfer und Kompromisse Sie bereit sind, weil nichts umsonst passiert, und wenn Sie einen auswählen, werden Sie höchstwahrscheinlich etwas anderes ablehnen. <br><br>  Bei der Bewertung von Produkten von dieser Seite ist Folgendes zu beachten: <br><br><ul><li>  wo sie im CAP-Theorem stehen; </li><li>  Unterstützen sie verteilte ACID-Transaktionen? </li><li>  Welche Einschränkungen erlegen sie verteilten Transaktionen auf (z. B. nur innerhalb einer einzelnen Partition usw.)? </li><li>  Bequemlichkeit und Effizienz bei der Verwendung verteilter Transaktionen sowie deren Integration in andere Produktkomponenten. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430852/">https://habr.com/ru/post/de430852/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430840/index.html">Welche Beweise können Mathematiker überzeugen, wenn es keine strengen Beweise gibt?</a></li>
<li><a href="../de430842/index.html">Wir verwenden Blockchain, um Korruption und Cybermobbing zu bekämpfen</a></li>
<li><a href="../de430844/index.html">So wählen Sie eine Batterie für die USV</a></li>
<li><a href="../de430846/index.html">Was ist neu: Details zur Implementierung der neuen Zen 2-Architektur wurden bekannt</a></li>
<li><a href="../de430850/index.html">Apple Metal bei MAPS.ME</a></li>
<li><a href="../de430854/index.html">„JS wird reifer“: ein Interview mit dem Moskauer Programmkomitee HolyJS 2018</a></li>
<li><a href="../de430856/index.html">Die ganze Wahrheit über RTOS. Artikel 21. Postfächer: Einführung und Basisdienste</a></li>
<li><a href="../de430860/index.html">Laden Sie PDF in Swift herunter, speichern Sie es und zeigen Sie es an</a></li>
<li><a href="../de430862/index.html">"Monster in Spielen - wie man einen Spieler dazu bringt, dich zu hassen"</a></li>
<li><a href="../de430864/index.html">Streichhölzer sind kein Spielzeug?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>