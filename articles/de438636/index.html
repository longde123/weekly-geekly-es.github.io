<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👦 💅🏿 👩🏻‍🚒 Fehlerhafte Einbettung von Funktionen in Go 👨🏿‍🎓 😮 👎🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Entspricht der unten gezeigte Code der Leistung? 


// (A). HasPrefix . return strings.HasPrefix(s, "#") // (B). HasPrefix. return len(s) >= len("#") ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fehlerhafte Einbettung von Funktionen in Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438636/"><p><img src="https://habrastorage.org/webt/lm/rt/rk/lmrtrkww5knurdsaznutrksterk.jpeg"></p><br><p>  Entspricht der unten gezeigte Code der Leistung? </p><br><pre><code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// (A).  HasPrefix  . return strings.HasPrefix(s, "#") // (B).    HasPrefix. return len(s) &gt;= len("#") &amp;&amp; s[:len("#")] == "#"</span></span></code> </pre> <br><p>  Die Antwort ist <strong>nein</strong> . </p><br><p>  Für Details und Erklärungen frage ich unter Katze. </p><a name="habracut"></a><br><hr><br><p>  Guten Tag, bevor Sie das Thema eröffnen, möchte ich mich vorstellen. <br>  Mein Name ist Iskander und von Zeit zu Zeit sende ich Commits an das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Golang / Go-</a> Repository. </p><br><img src="https://habrastorage.org/webt/ls/jy/t3/lsjyt3z-jg1l5dx2nlecj17lbks.png" alt="Bild" align="left"><br><p>  Früher habe ich dies im Auftrag des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intel Go-</a> Teams getan, aber unsere Wege gingen auseinander und jetzt bin ich ein unabhängiger Mitarbeiter.  Vor kurzem habe ich in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vk</a> im Infrastruktur-Team gearbeitet. </p><br><p>  In meiner Freizeit mache ich verschiedene Tools für Go, wie z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Go-Kritiker</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Go-Consistent</a> .  Ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zeichne auch Gophers</a> . </p><br><p><br></p><br><h1 id="measure-it">  Messen Sie es! </h1><br><p>  Fahren Sie sofort mit dem Vergleich fort und skizzieren Sie den Benchmark: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> benchmark <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"strings"</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"#string"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkHasPrefixCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { _ = strings.HasPrefix(s, <span class="hljs-string"><span class="hljs-string">"#"</span></span>) _ = strings.HasPrefix(s, <span class="hljs-string"><span class="hljs-string">"x"</span></span>) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkHasPrefixInlined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { _ = <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s) &gt;= <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(<span class="hljs-string"><span class="hljs-string">"#"</span></span>) &amp;&amp; s[:<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(<span class="hljs-string"><span class="hljs-string">"#"</span></span>)] == <span class="hljs-string"><span class="hljs-string">"#"</span></span> _ = <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s) &gt;= <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(<span class="hljs-string"><span class="hljs-string">"x"</span></span>) &amp;&amp; s[:<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(<span class="hljs-string"><span class="hljs-string">"x"</span></span>)] == <span class="hljs-string"><span class="hljs-string">"x"</span></span> } }</code> </pre> <br><p>  Anstatt Ihnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benchstat</a> zu empfehlen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zeige</a> ich Ihnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benchrun</a> . </p><br><p>  Mit einem Befehl können wir beide Benchmarks ausführen und einen Vergleich erhalten: </p><br><pre> <code class="bash hljs">go-benchrun HasPrefixCall HasPrefixInlined -v -count=10 . Benchstat results: name old time/op new time/op delta HasPrefixCall-8 9.15ns ± 1% 0.36ns ± 3% -96.09% (p=0.000 n=10+9)</code> </pre> <br><p>  Die Option mit manueller Einbettung ist viel schneller als der Code, der durch Einbetten des Funktionskörpers in den Compiler erhalten wurde.  Versuchen wir herauszufinden, warum dies geschieht. </p><br><h1 id="stringshasprefix">  string.HasPrefix </h1><br><p>  Erinnern Sie sich an die Implementierung von <code>strings.HasPrefix</code> : </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// HasPrefix tests whether the string s begins with prefix. func HasPrefix(s, prefix string) bool { return len(s) &gt;= len(prefix) &amp;&amp; s[0:len(prefix)] == prefix }</span></span></code> </pre> <br><p>  Die <code>HasPrefix</code> Funktion <code>HasPrefix</code> vom Compiler integriert. <br>  Sie können dies wie folgt überprüfen: </p><br><pre> <code class="bash hljs">go build -gcflags=<span class="hljs-string"><span class="hljs-string">'-m=2'</span></span> strings 2&gt;&amp;1 | grep <span class="hljs-string"><span class="hljs-string">'can inline HasPrefix'</span></span></code> </pre> <br><p>  Um <code>strings.HasPrefix</code> aus Option <code>(A)</code> aufzurufen, erhalten wir den folgenden Maschinencode: </p><br><pre> <code class="plaintext hljs"> MOVQ (TLS), CX CMPQ SP, 16(CX) JLS more_stack fn_body: SUBQ $40, SP MOVQ BP, 32(SP) LEAQ 32(SP), BP XCHGL AX, AX MOVQ s+56(SP), AX CMPQ AX, $1 JGE compare_strings XORL AX, AX MOVB AL, ~ret1+64(SP) MOVQ 32(SP), BP ADDQ $40, SP return: RET compare_strings: MOVQ s+48(SP), AX MOVQ AX, (SP) LEAQ go.string."#"(SB), AX MOVQ AX, 8(SP) MOVQ $1, 16(SP) CALL runtime.memequal(SB) MOVBLZX 24(SP), AX JMP return more_stack: CALL runtime.morestack_noctxt(SB) JMP fn_body</code> </pre> <br><p>  Ignorieren Sie die Tatsache, dass der Code wie Nudeln aussieht. </p><br><p>  Worauf Sie achten sollten: </p><br><ul><li>  <code>strings.HasPrefix</code> wirklich eingefügt, kein Aufruf. </li><li>  Um Zeichenfolgen zu vergleichen, wird <code>runtime.memequal</code> . </li></ul><br><p>  Aber was wird dann für die manuell eingebaute Version generiert, den Code aus Beispiel <code>(B)</code> ? </p><br><pre> <code class="plaintext hljs"> MOVQ s+16(SP), AX CMPQ AX, $1 JLT different_length MOVQ s+8(SP), AX CMPB (AX), $35 // 35 -   "#" SETEQ AL return: MOVB AL, "".~ret1+24(SP) RET different_length: XORL AX, AX JMP 22</code> </pre> <br><p>  Und hier generiert der Compiler keinen Aufruf von <code>runtime.memequal</code> und ein einzelnes Zeichen wird direkt verglichen.  Idealerweise hätte er dasselbe für die erste Option tun sollen. </p><br><p>  Wir beobachten die schwache Seite des Go-Optimierers und werden sie analysieren. </p><br><h1 id="optimizacii-konstantnyh-vyrazheniy">  Optimierung des konstanten Ausdrucks </h1><br><p>  Der Grund, warum der Aufruf von <code>strings.HasPrefix(s, "#")</code> optimiert werden kann, liegt darin, dass das Präfixargument eine Konstante ist.  Wir kennen seine Länge und seinen Inhalt.  Es macht keinen Sinn, <code>runtime.memequal</code> für kurze Zeichenfolgen <code>runtime.memequal</code> . Es ist schneller, Zeichen "an Ort und Stelle" zu vergleichen, um einen zusätzlichen Aufruf zu vermeiden. </p><br><p>  Wie Sie wissen, bestehen Compiler normalerweise aus mindestens zwei Teilen: dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Compiler-Frontend</a> und dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Compiler-Backend</a> .  Die erste arbeitet mit einer übergeordneten Ansicht, die zweite befindet sich näher an der Maschine und die Zwischenansicht sieht aus wie ein Anweisungsstrom.  Mehrere Versionen von Go haben die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SSA-</a> Darstellung bereits für Optimierungen im Backend-Teil des Compilers verwendet. </p><br><p>  Eine konstante Faltung wie <code>{10*2 =&gt; 20}</code> ist im Backend implementiert.  Im Allgemeinen befinden sich die meisten Operationen, die mit dem Verringern der Berechnungskosten von Ausdrücken verbunden sind, in diesem Teil des Compilers.  Es gibt jedoch Ausnahmen. </p><br><p>  Eine Ausnahme bildet die Optimierung konstanter String-Vergleiche.  Wenn der Compiler einen String- (oder Teilstring-) Vergleich sieht, bei dem einer oder beide Operanden Konstanten sind, wird effizienterer Code generiert als ein Aufruf von <code>runtime.memequal</code> . </p><br><p>  Den dafür verantwortlichen Quellcode sehen Sie in der Datei <a href="">cmd / compile / internal / gc / walk.go: 3362</a> . </p><br><p>  Das Einbetten von Funktionen erfolgt vor dem Start dieser Optimierungen, aber auch im Frontend-Teil des Compilers. </p><br><p>  Es scheint, dass diese Optimierung in unserem Fall trotzdem nicht funktioniert. </p><br><h1 id="kak-go-vstraivaet-vyzovy-funkciy">  Funktionsweise Einbetten von Funktionsaufrufen </h1><br><p>  So wird die Einbettung erfolgen: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//    : return strings.HasPrefix(s, "#") //  : func HasPrefix(s, prefix string) bool //    : _s, _prefix := s, "#" return len(s) &gt;= len(prefix) &amp;&amp; s[:len(prefix)] == prefix</span></span></code> </pre> <br><p>  Beim Einbetten von Funktionen weist der Compiler temporären Variablen Argumente zu, wodurch Optimierungen <a href="">unterbrochen werden</a> , da der Algorithmus in <a href="">walk.go</a> keine Konstanten, sondern Argumente mit Variablen sieht.  Das ist das Problem. </p><br><p>  Dies beeinträchtigt übrigens nicht die Backend-Optimierungen, über die die SSA verfügt.  Dort gibt es jedoch noch andere Probleme, beispielsweise die Unfähigkeit, Sprachkonstrukte auf hoher Ebene für einen effektiven Vergleich wiederherzustellen (die Arbeiten zur Beseitigung dieses Nachteils sind seit mehreren Jahren „geplant“). </p><br><h1 id="eschyo-odin-primer-escape-analysis">  Ein weiteres Beispiel: Fluchtanalyse </h1><br><p>  Stellen Sie sich eine Funktion vor, die wichtig ist, um einen temporären Puffer auf dem Stapel zuzuweisen: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">businessLogic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { buf := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>) <span class="hljs-comment"><span class="hljs-comment">// buf    //    . return nil }</span></span></code> </pre> <br><p>  Da <code>buf</code> nicht "wegläuft", kann der Compiler diese 16 Bytes auf dem Stapel ohne Zuordnung auf dem Heap zuweisen.  Nochmals alles dank des konstanten Wertes beim Aufruf von <code>make</code> .  Um Speicher auf dem Stapel zuzuweisen, ist es wichtig, die erforderliche Größe zu kennen, die Teil des dem Funktionsaufruf zugewiesenen Rahmens ist. </p><br><p>  Angenommen, wir wollten in Zukunft temporäre Puffer unterschiedlicher Größe zuweisen und einige Logik in Methoden einkapseln.  Wir haben eine neue Abstraktion eingeführt und beschlossen, den neuen Typ <code>tmpBuf</code> .  Die Designfunktion ist sehr einfach: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newTmpBuf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sizeHint </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmpBuf</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmpBuf{buf: <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, sizeHint)} }</code> </pre> <br><p>  Anpassung des Originalbeispiels: </p><br><pre> <code class="diff hljs">func businessLogic() error { - buf := make([]byte, 0, 16) + buf := newTmpBuf(16) // buf    //    . return nil }</code> </pre> <br><p>  Der Konstruktor wird eingebettet, aber die Zuordnung befindet sich jetzt immer auf dem Heap, aus demselben Grund, aus dem Argumente über temporäre Variablen übergeben werden.  Bei der Escape-Analyse wird <code>make([]byte, 0, _sizeHint)</code> , das für optimierte Anrufe nicht unter die Erkennungsmuster fällt. </p><br><p>  Wenn wir "alles wie Menschen" hätten, würde das Problem nicht bestehen. Nach dem Einbetten des <code>newTmpBuf</code> Konstruktors wäre klar, dass die Größe in der Kompilierungsphase noch bekannt ist. </p><br><p>  Dies stört fast mehr als die Situation beim Vergleichen von Zeichenfolgen. </p><br><h1 id="gorizonty-go-113">  Horizonte gehen 1.13 </h1><br><p>  Die Situation kann leicht korrigiert werden und ich habe bereits den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Teil der Entscheidung</a> gesendet. </p><br><img src="https://habrastorage.org/webt/uv/gv/16/uvgv16e70jy6qdip9wju_vqzvog.png" alt="Bild" align="left"><br><p>  Wenn Sie der Meinung sind, dass das im Artikel beschriebene Problem wirklich eine Lösung benötigt, setzen Sie bitte einen Daumen hoch in das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">entsprechende Problem</a> . </p><br><p></p><hr><br><br><p>  Mein Standpunkt ist, dass das Einbetten von Code mit Ihren Händen, nur weil er in der aktuellen Version von Go schneller funktioniert, falsch ist.  Es ist notwendig, diesen Fehler im Optimierer zu beheben, zumindest bis zu dem Punkt, an dem die oben beschriebenen Beispiele ohne unerwartete Leistungsrückgänge funktionieren. </p><br><p>  Wenn alles nach Plan verläuft, wird diese Optimierung in der Version Go 1.13 enthalten sein. </p><br><p>  Vielen Dank für Ihre Aufmerksamkeit. </p><br><h1 id="dopolnenie-predlozhennoe-reshenie">  Ergänzung: Lösungsvorschlag </h1><br><p>  Dieser Abschnitt ist für die Mutigsten, die nicht müde sind zu lesen. </p><br><p>  Wir haben also mehrere Stellen, die schlechter funktionieren, wenn Variablen anstelle ihrer Werte direkt verwendet werden.  Die vorgeschlagene Lösung besteht darin, eine neue Funktion im Frontend des Compilerteils einzuführen, mit der Sie den letzten gebundenen Wert nach Namen abrufen können.  Geben Sie danach bei jeder Optimierung, die einen konstanten Wert erwartet, nicht auf, wenn eine Variable erkannt wird, sondern erhalten Sie diesen zuvor gespeicherten Status. </p><br><p>  Die Signatur unserer neuen Funktion könnte folgendermaßen aussehen: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getConstValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n *Node)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span></span></code> </pre> <br><p>  Die Definition des <code>Node</code> finden Sie in der Datei <a href="">syntax.go</a> . </p><br><p>  Jede Variablendefinition verfügt über ein <code>Node</code> Tag mit einem <code>ONAME</code> Tag.  In <code>Node.Name.Defn</code> meisten dieser Variablen einen Initialisierungswert. </p><br><p>  Wenn <code>Node</code> bereits ein Literal ist, müssen Sie nichts tun und wir geben nur <code>n</code> .  Wenn dies <code>ONAME</code> (Variable) ist, können Sie versuchen, denselben Initialisierungswert aus <code>n.Name.Defn</code> zu extrahieren. </p><br><p>  Aber was ist mit den Änderungen zwischen dem Deklarieren und Lesen einer Variablen, für die wir <code>getConstValue</code> ?  Wenn wir uns auf schreibgeschützte Variablen beschränken, gibt es kein Problem.  Das Frontend von Go verfügt bereits über spezielle Knotenflags, die ähnliche Namen kennzeichnen.  Wenn die Variable geändert wurde, gibt <code>getConstValue</code> keinen Initialisierungswert zurück. </p><br><p>  Programmierer ändern in der Regel nicht die Eingabeargumente von numerischen Typen und Zeichenfolgentypen, und dies ermöglicht es, mit diesem primitiven Algorithmus eine relativ große Anzahl von Fällen abzudecken. </p><br><p>  Jetzt sind wir bereit, die Implementierung zu prüfen: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getConstValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n *Node)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ONAME    definition. if n.Op != ONAME || n.Name.Defn == nil { return n } //   ,     . // ,    ,     //      escape analysis' . maybeModified := n.Assigned() || n.Name.Defn.Assigned() || n.Addrtaken() if maybeModified { return n } // OAS - Node  . // n.Name.Defn.Left -  LHS. // n.Name.Defn.Right -  RHS. // consttype(v)     . //   CTxxx,      . if n.Name.Defn.Op == OAS { v := n.Name.Defn.Right if v != nil &amp;&amp; consttype(v) != CTxxx { return v } } return n }</span></span></code> </pre> <br><p>  So ändert sich der Code, was von den Konstanten abhängt: </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- i := indexconst(r) + i := indexconst(getConstValue(r))</span></span></code> </pre> <br><p>  Großartig und es funktioniert sogar: </p><br><pre> <code class="go hljs">n := <span class="hljs-number"><span class="hljs-number">10</span></span> xs := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, n) <span class="hljs-comment"><span class="hljs-comment">//     !</span></span></code> </pre> <br><p>  Vor dieser Änderung konnte die Escape-Analyse den Wert <code>10</code> bis <code>n</code> nicht erhalten, weshalb ich davon ausgegangen bin, dass <code>xs</code> auf dem Heap platziert werden muss. </p><br><p>  Der obige Code ähnelt syntaktisch der beim Einbetten beobachteten Situation.  <code>n</code> kann eine temporäre Variable sein, die hinzugefügt wird, wenn das Argument übergeben wird. </p><br><p>  Leider gibt es Nuancen. </p><br><p>  Wir haben das Problem für lokale Variablen gelöst, die über <a href="">OAS eingeführt wurden</a> , aber Go initialisiert die Variablen für integrierte Funktionen über <a href="">OAS2</a> .  Aus diesem Grund benötigen wir eine zweite Änderung, die die Funktion <code>getConstValue</code> und den Code des Inliners selbst geringfügig ändert, da <code>OAS2</code> unter anderem kein geeignetes <code>Defn</code> Feld hat. </p><br><p>  Das waren schlechte Nachrichten.  Gute Nachrichten: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">#gocontributing</a> channel erschien in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">russischsprachigen Lücke</a> , wo Sie Ihre Ideen und Pläne teilen, Fragen stellen und alles diskutieren können, was mit der Teilnahme an der Go-Entwicklung zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tun hat</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438636/">https://habr.com/ru/post/de438636/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438626/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 284 (28. Januar - 3. Februar)</a></li>
<li><a href="../de438628/index.html">Benachrichtigung über den Status der Änderung der SharedState-Komponente</a></li>
<li><a href="../de438630/index.html">Google+ Sic Transit Gloria Mundi ...</a></li>
<li><a href="../de438632/index.html">Hardcore 2D RPG Gamedev Diaries, Vol.0 - INTRO oder "How I Got Here"</a></li>
<li><a href="../de438634/index.html">In Büros ist es entweder zu heiß oder zu kalt: Gibt es eine bessere Möglichkeit, die Temperatur anzupassen?</a></li>
<li><a href="../de438638/index.html">Wir analysieren das Protokoll der Pager-Nachrichten POCSAG, Teil 2</a></li>
<li><a href="../de438640/index.html">Offene elektronische Hochgeschwindigkeitswährung</a></li>
<li><a href="../de438642/index.html">Die Grundlagen der reaktiven Programmierung mit RxJS</a></li>
<li><a href="../de438644/index.html">Die Sicherheit von Algorithmen für maschinelles Lernen. Schützen und Testen von Modellen mit Python</a></li>
<li><a href="../de438646/index.html">Informationen zum Erstellen von Budget-Stereobildern auf Fingern (Stereogramm, Anaglyphe, Stereoskop)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>