<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë¶ üíÖüèø üë©üèª‚Äçüöí Fehlerhafte Einbettung von Funktionen in Go üë®üèø‚Äçüéì üòÆ üëéüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Entspricht der unten gezeigte Code der Leistung? 


// (A). HasPrefix . return strings.HasPrefix(s, "#") // (B). HasPrefix. return len(s) >= len("#") ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fehlerhafte Einbettung von Funktionen in Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438636/"><p><img src="https://habrastorage.org/webt/lm/rt/rk/lmrtrkww5knurdsaznutrksterk.jpeg"></p><br><p>  Entspricht der unten gezeigte Code der Leistung? </p><br><pre><code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// (A).  HasPrefix  . return strings.HasPrefix(s, "#") // (B).    HasPrefix. return len(s) &gt;= len("#") &amp;&amp; s[:len("#")] == "#"</span></span></code> </pre> <br><p>  Die Antwort ist <strong>nein</strong> . </p><br><p>  F√ºr Details und Erkl√§rungen frage ich unter Katze. </p><a name="habracut"></a><br><hr><br><p>  Guten Tag, bevor Sie das Thema er√∂ffnen, m√∂chte ich mich vorstellen. <br>  Mein Name ist Iskander und von Zeit zu Zeit sende ich Commits an das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Golang / Go-</a> Repository. </p><br><img src="https://habrastorage.org/webt/ls/jy/t3/lsjyt3z-jg1l5dx2nlecj17lbks.png" alt="Bild" align="left"><br><p>  Fr√ºher habe ich dies im Auftrag des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intel Go-</a> Teams getan, aber unsere Wege gingen auseinander und jetzt bin ich ein unabh√§ngiger Mitarbeiter.  Vor kurzem habe ich in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vk</a> im Infrastruktur-Team gearbeitet. </p><br><p>  In meiner Freizeit mache ich verschiedene Tools f√ºr Go, wie z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Go-Kritiker</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Go-Consistent</a> .  Ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zeichne auch Gophers</a> . </p><br><p><br></p><br><h1 id="measure-it">  Messen Sie es! </h1><br><p>  Fahren Sie sofort mit dem Vergleich fort und skizzieren Sie den Benchmark: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> benchmark <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"strings"</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"#string"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkHasPrefixCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { _ = strings.HasPrefix(s, <span class="hljs-string"><span class="hljs-string">"#"</span></span>) _ = strings.HasPrefix(s, <span class="hljs-string"><span class="hljs-string">"x"</span></span>) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkHasPrefixInlined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { _ = <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s) &gt;= <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(<span class="hljs-string"><span class="hljs-string">"#"</span></span>) &amp;&amp; s[:<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(<span class="hljs-string"><span class="hljs-string">"#"</span></span>)] == <span class="hljs-string"><span class="hljs-string">"#"</span></span> _ = <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s) &gt;= <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(<span class="hljs-string"><span class="hljs-string">"x"</span></span>) &amp;&amp; s[:<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(<span class="hljs-string"><span class="hljs-string">"x"</span></span>)] == <span class="hljs-string"><span class="hljs-string">"x"</span></span> } }</code> </pre> <br><p>  Anstatt Ihnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benchstat</a> zu empfehlen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zeige</a> ich Ihnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benchrun</a> . </p><br><p>  Mit einem Befehl k√∂nnen wir beide Benchmarks ausf√ºhren und einen Vergleich erhalten: </p><br><pre> <code class="bash hljs">go-benchrun HasPrefixCall HasPrefixInlined -v -count=10 . Benchstat results: name old time/op new time/op delta HasPrefixCall-8 9.15ns ¬± 1% 0.36ns ¬± 3% -96.09% (p=0.000 n=10+9)</code> </pre> <br><p>  Die Option mit manueller Einbettung ist viel schneller als der Code, der durch Einbetten des Funktionsk√∂rpers in den Compiler erhalten wurde.  Versuchen wir herauszufinden, warum dies geschieht. </p><br><h1 id="stringshasprefix">  string.HasPrefix </h1><br><p>  Erinnern Sie sich an die Implementierung von <code>strings.HasPrefix</code> : </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// HasPrefix tests whether the string s begins with prefix. func HasPrefix(s, prefix string) bool { return len(s) &gt;= len(prefix) &amp;&amp; s[0:len(prefix)] == prefix }</span></span></code> </pre> <br><p>  Die <code>HasPrefix</code> Funktion <code>HasPrefix</code> vom Compiler integriert. <br>  Sie k√∂nnen dies wie folgt √ºberpr√ºfen: </p><br><pre> <code class="bash hljs">go build -gcflags=<span class="hljs-string"><span class="hljs-string">'-m=2'</span></span> strings 2&gt;&amp;1 | grep <span class="hljs-string"><span class="hljs-string">'can inline HasPrefix'</span></span></code> </pre> <br><p>  Um <code>strings.HasPrefix</code> aus Option <code>(A)</code> aufzurufen, erhalten wir den folgenden Maschinencode: </p><br><pre> <code class="plaintext hljs"> MOVQ (TLS), CX CMPQ SP, 16(CX) JLS more_stack fn_body: SUBQ $40, SP MOVQ BP, 32(SP) LEAQ 32(SP), BP XCHGL AX, AX MOVQ s+56(SP), AX CMPQ AX, $1 JGE compare_strings XORL AX, AX MOVB AL, ~ret1+64(SP) MOVQ 32(SP), BP ADDQ $40, SP return: RET compare_strings: MOVQ s+48(SP), AX MOVQ AX, (SP) LEAQ go.string."#"(SB), AX MOVQ AX, 8(SP) MOVQ $1, 16(SP) CALL runtime.memequal(SB) MOVBLZX 24(SP), AX JMP return more_stack: CALL runtime.morestack_noctxt(SB) JMP fn_body</code> </pre> <br><p>  Ignorieren Sie die Tatsache, dass der Code wie Nudeln aussieht. </p><br><p>  Worauf Sie achten sollten: </p><br><ul><li>  <code>strings.HasPrefix</code> wirklich eingef√ºgt, kein Aufruf. </li><li>  Um Zeichenfolgen zu vergleichen, wird <code>runtime.memequal</code> . </li></ul><br><p>  Aber was wird dann f√ºr die manuell eingebaute Version generiert, den Code aus Beispiel <code>(B)</code> ? </p><br><pre> <code class="plaintext hljs"> MOVQ s+16(SP), AX CMPQ AX, $1 JLT different_length MOVQ s+8(SP), AX CMPB (AX), $35 // 35 -   "#" SETEQ AL return: MOVB AL, "".~ret1+24(SP) RET different_length: XORL AX, AX JMP 22</code> </pre> <br><p>  Und hier generiert der Compiler keinen Aufruf von <code>runtime.memequal</code> und ein einzelnes Zeichen wird direkt verglichen.  Idealerweise h√§tte er dasselbe f√ºr die erste Option tun sollen. </p><br><p>  Wir beobachten die schwache Seite des Go-Optimierers und werden sie analysieren. </p><br><h1 id="optimizacii-konstantnyh-vyrazheniy">  Optimierung des konstanten Ausdrucks </h1><br><p>  Der Grund, warum der Aufruf von <code>strings.HasPrefix(s, "#")</code> optimiert werden kann, liegt darin, dass das Pr√§fixargument eine Konstante ist.  Wir kennen seine L√§nge und seinen Inhalt.  Es macht keinen Sinn, <code>runtime.memequal</code> f√ºr kurze Zeichenfolgen <code>runtime.memequal</code> . Es ist schneller, Zeichen "an Ort und Stelle" zu vergleichen, um einen zus√§tzlichen Aufruf zu vermeiden. </p><br><p>  Wie Sie wissen, bestehen Compiler normalerweise aus mindestens zwei Teilen: dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Compiler-Frontend</a> und dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Compiler-Backend</a> .  Die erste arbeitet mit einer √ºbergeordneten Ansicht, die zweite befindet sich n√§her an der Maschine und die Zwischenansicht sieht aus wie ein Anweisungsstrom.  Mehrere Versionen von Go haben die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SSA-</a> Darstellung bereits f√ºr Optimierungen im Backend-Teil des Compilers verwendet. </p><br><p>  Eine konstante Faltung wie <code>{10*2 =&gt; 20}</code> ist im Backend implementiert.  Im Allgemeinen befinden sich die meisten Operationen, die mit dem Verringern der Berechnungskosten von Ausdr√ºcken verbunden sind, in diesem Teil des Compilers.  Es gibt jedoch Ausnahmen. </p><br><p>  Eine Ausnahme bildet die Optimierung konstanter String-Vergleiche.  Wenn der Compiler einen String- (oder Teilstring-) Vergleich sieht, bei dem einer oder beide Operanden Konstanten sind, wird effizienterer Code generiert als ein Aufruf von <code>runtime.memequal</code> . </p><br><p>  Den daf√ºr verantwortlichen Quellcode sehen Sie in der Datei <a href="">cmd / compile / internal / gc / walk.go: 3362</a> . </p><br><p>  Das Einbetten von Funktionen erfolgt vor dem Start dieser Optimierungen, aber auch im Frontend-Teil des Compilers. </p><br><p>  Es scheint, dass diese Optimierung in unserem Fall trotzdem nicht funktioniert. </p><br><h1 id="kak-go-vstraivaet-vyzovy-funkciy">  Funktionsweise Einbetten von Funktionsaufrufen </h1><br><p>  So wird die Einbettung erfolgen: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//    : return strings.HasPrefix(s, "#") //  : func HasPrefix(s, prefix string) bool //    : _s, _prefix := s, "#" return len(s) &gt;= len(prefix) &amp;&amp; s[:len(prefix)] == prefix</span></span></code> </pre> <br><p>  Beim Einbetten von Funktionen weist der Compiler tempor√§ren Variablen Argumente zu, wodurch Optimierungen <a href="">unterbrochen werden</a> , da der Algorithmus in <a href="">walk.go</a> keine Konstanten, sondern Argumente mit Variablen sieht.  Das ist das Problem. </p><br><p>  Dies beeintr√§chtigt √ºbrigens nicht die Backend-Optimierungen, √ºber die die SSA verf√ºgt.  Dort gibt es jedoch noch andere Probleme, beispielsweise die Unf√§higkeit, Sprachkonstrukte auf hoher Ebene f√ºr einen effektiven Vergleich wiederherzustellen (die Arbeiten zur Beseitigung dieses Nachteils sind seit mehreren Jahren ‚Äûgeplant‚Äú). </p><br><h1 id="eschyo-odin-primer-escape-analysis">  Ein weiteres Beispiel: Fluchtanalyse </h1><br><p>  Stellen Sie sich eine Funktion vor, die wichtig ist, um einen tempor√§ren Puffer auf dem Stapel zuzuweisen: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">businessLogic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { buf := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>) <span class="hljs-comment"><span class="hljs-comment">// buf    //    . return nil }</span></span></code> </pre> <br><p>  Da <code>buf</code> nicht "wegl√§uft", kann der Compiler diese 16 Bytes auf dem Stapel ohne Zuordnung auf dem Heap zuweisen.  Nochmals alles dank des konstanten Wertes beim Aufruf von <code>make</code> .  Um Speicher auf dem Stapel zuzuweisen, ist es wichtig, die erforderliche Gr√∂√üe zu kennen, die Teil des dem Funktionsaufruf zugewiesenen Rahmens ist. </p><br><p>  Angenommen, wir wollten in Zukunft tempor√§re Puffer unterschiedlicher Gr√∂√üe zuweisen und einige Logik in Methoden einkapseln.  Wir haben eine neue Abstraktion eingef√ºhrt und beschlossen, den neuen Typ <code>tmpBuf</code> .  Die Designfunktion ist sehr einfach: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newTmpBuf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sizeHint </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmpBuf</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmpBuf{buf: <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, sizeHint)} }</code> </pre> <br><p>  Anpassung des Originalbeispiels: </p><br><pre> <code class="diff hljs">func businessLogic() error { - buf := make([]byte, 0, 16) + buf := newTmpBuf(16) // buf    //    . return nil }</code> </pre> <br><p>  Der Konstruktor wird eingebettet, aber die Zuordnung befindet sich jetzt immer auf dem Heap, aus demselben Grund, aus dem Argumente √ºber tempor√§re Variablen √ºbergeben werden.  Bei der Escape-Analyse wird <code>make([]byte, 0, _sizeHint)</code> , das f√ºr optimierte Anrufe nicht unter die Erkennungsmuster f√§llt. </p><br><p>  Wenn wir "alles wie Menschen" h√§tten, w√ºrde das Problem nicht bestehen. Nach dem Einbetten des <code>newTmpBuf</code> Konstruktors w√§re klar, dass die Gr√∂√üe in der Kompilierungsphase noch bekannt ist. </p><br><p>  Dies st√∂rt fast mehr als die Situation beim Vergleichen von Zeichenfolgen. </p><br><h1 id="gorizonty-go-113">  Horizonte gehen 1.13 </h1><br><p>  Die Situation kann leicht korrigiert werden und ich habe bereits den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Teil der Entscheidung</a> gesendet. </p><br><img src="https://habrastorage.org/webt/uv/gv/16/uvgv16e70jy6qdip9wju_vqzvog.png" alt="Bild" align="left"><br><p>  Wenn Sie der Meinung sind, dass das im Artikel beschriebene Problem wirklich eine L√∂sung ben√∂tigt, setzen Sie bitte einen Daumen hoch in das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">entsprechende Problem</a> . </p><br><p></p><hr><br><br><p>  Mein Standpunkt ist, dass das Einbetten von Code mit Ihren H√§nden, nur weil er in der aktuellen Version von Go schneller funktioniert, falsch ist.  Es ist notwendig, diesen Fehler im Optimierer zu beheben, zumindest bis zu dem Punkt, an dem die oben beschriebenen Beispiele ohne unerwartete Leistungsr√ºckg√§nge funktionieren. </p><br><p>  Wenn alles nach Plan verl√§uft, wird diese Optimierung in der Version Go 1.13 enthalten sein. </p><br><p>  Vielen Dank f√ºr Ihre Aufmerksamkeit. </p><br><h1 id="dopolnenie-predlozhennoe-reshenie">  Erg√§nzung: L√∂sungsvorschlag </h1><br><p>  Dieser Abschnitt ist f√ºr die Mutigsten, die nicht m√ºde sind zu lesen. </p><br><p>  Wir haben also mehrere Stellen, die schlechter funktionieren, wenn Variablen anstelle ihrer Werte direkt verwendet werden.  Die vorgeschlagene L√∂sung besteht darin, eine neue Funktion im Frontend des Compilerteils einzuf√ºhren, mit der Sie den letzten gebundenen Wert nach Namen abrufen k√∂nnen.  Geben Sie danach bei jeder Optimierung, die einen konstanten Wert erwartet, nicht auf, wenn eine Variable erkannt wird, sondern erhalten Sie diesen zuvor gespeicherten Status. </p><br><p>  Die Signatur unserer neuen Funktion k√∂nnte folgenderma√üen aussehen: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getConstValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n *Node)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span></span></code> </pre> <br><p>  Die Definition des <code>Node</code> finden Sie in der Datei <a href="">syntax.go</a> . </p><br><p>  Jede Variablendefinition verf√ºgt √ºber ein <code>Node</code> Tag mit einem <code>ONAME</code> Tag.  In <code>Node.Name.Defn</code> meisten dieser Variablen einen Initialisierungswert. </p><br><p>  Wenn <code>Node</code> bereits ein Literal ist, m√ºssen Sie nichts tun und wir geben nur <code>n</code> .  Wenn dies <code>ONAME</code> (Variable) ist, k√∂nnen Sie versuchen, denselben Initialisierungswert aus <code>n.Name.Defn</code> zu extrahieren. </p><br><p>  Aber was ist mit den √Ñnderungen zwischen dem Deklarieren und Lesen einer Variablen, f√ºr die wir <code>getConstValue</code> ?  Wenn wir uns auf schreibgesch√ºtzte Variablen beschr√§nken, gibt es kein Problem.  Das Frontend von Go verf√ºgt bereits √ºber spezielle Knotenflags, die √§hnliche Namen kennzeichnen.  Wenn die Variable ge√§ndert wurde, gibt <code>getConstValue</code> keinen Initialisierungswert zur√ºck. </p><br><p>  Programmierer √§ndern in der Regel nicht die Eingabeargumente von numerischen Typen und Zeichenfolgentypen, und dies erm√∂glicht es, mit diesem primitiven Algorithmus eine relativ gro√üe Anzahl von F√§llen abzudecken. </p><br><p>  Jetzt sind wir bereit, die Implementierung zu pr√ºfen: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getConstValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n *Node)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ONAME    definition. if n.Op != ONAME || n.Name.Defn == nil { return n } //   ,     . // ,    ,     //      escape analysis' . maybeModified := n.Assigned() || n.Name.Defn.Assigned() || n.Addrtaken() if maybeModified { return n } // OAS - Node  . // n.Name.Defn.Left -  LHS. // n.Name.Defn.Right -  RHS. // consttype(v)     . //   CTxxx,      . if n.Name.Defn.Op == OAS { v := n.Name.Defn.Right if v != nil &amp;&amp; consttype(v) != CTxxx { return v } } return n }</span></span></code> </pre> <br><p>  So √§ndert sich der Code, was von den Konstanten abh√§ngt: </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- i := indexconst(r) + i := indexconst(getConstValue(r))</span></span></code> </pre> <br><p>  Gro√üartig und es funktioniert sogar: </p><br><pre> <code class="go hljs">n := <span class="hljs-number"><span class="hljs-number">10</span></span> xs := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, n) <span class="hljs-comment"><span class="hljs-comment">//     !</span></span></code> </pre> <br><p>  Vor dieser √Ñnderung konnte die Escape-Analyse den Wert <code>10</code> bis <code>n</code> nicht erhalten, weshalb ich davon ausgegangen bin, dass <code>xs</code> auf dem Heap platziert werden muss. </p><br><p>  Der obige Code √§hnelt syntaktisch der beim Einbetten beobachteten Situation.  <code>n</code> kann eine tempor√§re Variable sein, die hinzugef√ºgt wird, wenn das Argument √ºbergeben wird. </p><br><p>  Leider gibt es Nuancen. </p><br><p>  Wir haben das Problem f√ºr lokale Variablen gel√∂st, die √ºber <a href="">OAS eingef√ºhrt wurden</a> , aber Go initialisiert die Variablen f√ºr integrierte Funktionen √ºber <a href="">OAS2</a> .  Aus diesem Grund ben√∂tigen wir eine zweite √Ñnderung, die die Funktion <code>getConstValue</code> und den Code des Inliners selbst geringf√ºgig √§ndert, da <code>OAS2</code> unter anderem kein geeignetes <code>Defn</code> Feld hat. </p><br><p>  Das waren schlechte Nachrichten.  Gute Nachrichten: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">#gocontributing</a> channel erschien in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">russischsprachigen L√ºcke</a> , wo Sie Ihre Ideen und Pl√§ne teilen, Fragen stellen und alles diskutieren k√∂nnen, was mit der Teilnahme an der Go-Entwicklung zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tun hat</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438636/">https://habr.com/ru/post/de438636/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438626/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 284 (28. Januar - 3. Februar)</a></li>
<li><a href="../de438628/index.html">Benachrichtigung √ºber den Status der √Ñnderung der SharedState-Komponente</a></li>
<li><a href="../de438630/index.html">Google+ Sic Transit Gloria Mundi ...</a></li>
<li><a href="../de438632/index.html">Hardcore 2D RPG Gamedev Diaries, Vol.0 - INTRO oder "How I Got Here"</a></li>
<li><a href="../de438634/index.html">In B√ºros ist es entweder zu hei√ü oder zu kalt: Gibt es eine bessere M√∂glichkeit, die Temperatur anzupassen?</a></li>
<li><a href="../de438638/index.html">Wir analysieren das Protokoll der Pager-Nachrichten POCSAG, Teil 2</a></li>
<li><a href="../de438640/index.html">Offene elektronische Hochgeschwindigkeitsw√§hrung</a></li>
<li><a href="../de438642/index.html">Die Grundlagen der reaktiven Programmierung mit RxJS</a></li>
<li><a href="../de438644/index.html">Die Sicherheit von Algorithmen f√ºr maschinelles Lernen. Sch√ºtzen und Testen von Modellen mit Python</a></li>
<li><a href="../de438646/index.html">Informationen zum Erstellen von Budget-Stereobildern auf Fingern (Stereogramm, Anaglyphe, Stereoskop)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>