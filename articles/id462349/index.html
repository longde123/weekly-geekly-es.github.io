<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👲🏿 🦊 🎐 RESTinio adalah server HTTP asinkron. Contoh sederhana dari praktik: mengembalikan sejumlah besar data sebagai respons 🤱🏼 🤥 😃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baru-baru ini, saya kebetulan mengerjakan aplikasi yang seharusnya mengontrol kecepatan koneksi keluarnya. Sebagai contoh, menghubungkan ke satu URL, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RESTinio adalah server HTTP asinkron. Contoh sederhana dari praktik: mengembalikan sejumlah besar data sebagai respons</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462349/"><p><img src="https://habrastorage.org/webt/a6/kc/zt/a6kcztqtbqzp5shvd5wcz-8zzl0.jpeg"></p><br><p>  Baru-baru ini, saya kebetulan mengerjakan aplikasi yang seharusnya mengontrol kecepatan koneksi keluarnya.  Sebagai contoh, menghubungkan ke satu URL, aplikasi harus membatasi dirinya sendiri, katakanlah, 200KiB / detik.  Dan menghubungkan ke URL lain - hanya 30KiB / detik. </p><br><p>  Poin paling menarik di sini adalah menguji batasan-batasan ini.  Saya membutuhkan server HTTP yang akan memberikan lalu lintas pada kecepatan tertentu, misalnya, 512KiB / detik.  Kemudian saya bisa melihat apakah aplikasi tersebut benar-benar tahan terhadap kecepatan 200KiB / detik atau jika rusak ke kecepatan yang lebih tinggi. </p><br><p>  Tapi di mana mendapatkan server HTTP seperti itu? </p><br><p>  Karena saya ada hubungannya dengan server HTTP <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RESTinio yang</a> tertanam dalam aplikasi C ++, saya belum menemukan yang lebih baik daripada dengan cepat melemparkan server uji HTTP sederhana di lutut saya yang dapat mengirim aliran panjang data keluar ke klien. </p><br><p>  Tentang betapa sederhananya dan ingin diceritakan dalam artikel.  Pada saat yang sama, cari tahu di komentar apakah ini benar-benar sederhana atau apakah saya menipu diri sendiri.  Pada prinsipnya, artikel ini dapat dianggap sebagai kelanjutan dari artikel sebelumnya tentang RESTinio yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"RESTinio adalah server HTTP asinkron. Asynchronous"</a> .  Oleh karena itu, jika seseorang tertarik untuk membaca tentang aplikasi RESTinio yang asli, walaupun tidak terlalu serius, maka Anda dapat melakukannya. </p><a name="habracut"></a><br><h1 id="obschaya-ideya">  Ide umum </h1><br><p>  Gagasan umum dari server uji yang disebutkan di atas sangat sederhana: ketika klien terhubung ke server dan melakukan permintaan GET HTTP, timer diaktifkan yang berjalan sekali per detik.  Ketika timer dipicu, blok data berikutnya dari ukuran yang diberikan dikirim ke klien. </p><br><h2 id="no-vse-neskolko-slozhnee">  Tapi semuanya sedikit lebih rumit </h2><br><p>  Jika klien membaca data pada kecepatan yang lebih lambat daripada yang dikirim server, maka hanya mengirim N kilobyte satu detik sekali bukan ide yang baik.  Karena data akan mulai menumpuk di soket dan ini tidak akan menghasilkan sesuatu yang baik. </p><br><p>  Oleh karena itu, saat mengirim data, disarankan untuk mengontrol kesiapan soket untuk menulis di sisi server HTTP.  Selama soket siap (artinya, terlalu banyak data belum terakumulasi di dalamnya), Anda dapat mengirim bagian baru.  Tetapi jika tidak siap, maka Anda harus menunggu sampai soket siap untuk direkam. </p><br><p>  Kedengarannya masuk akal, tetapi operasi I / O tersembunyi di jeroan ayam itik RESTINO ... Bagaimana saya bisa mengetahui apakah data selanjutnya dapat ditulis atau tidak? </p><br><p>  Anda bisa keluar dari situasi ini jika Anda menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">notifiers setelah-tulis</a> , yang ada di RESTinio.  Sebagai contoh, kita dapat menulis ini: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">request_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req)</span></span></span><span class="hljs-function"> </span></span>{ req-&gt;create_response() <span class="hljs-comment"><span class="hljs-comment">//   . ... //   . .done([](const auto &amp; ec) { ... //         . }); }</span></span></code> </pre> <br><p>  Lambda yang diteruskan ke metode <code>done()</code> akan dipanggil ketika RESTinio selesai menulis data keluar.  Dengan demikian, jika soket tidak siap untuk merekam untuk beberapa waktu, maka lambda tidak akan dipanggil segera, tetapi setelah soket datang ke keadaan semestinya dan menerima semua data keluar. </p><br><p>  Karena penggunaan notifiers setelah-tulis, logika server pengujian adalah sebagai berikut: </p><br><ul><li>  kirim kumpulan data berikutnya, hitung waktu ketika kami perlu mengirim kumpulan berikutnya dalam kegiatan normal; </li><li>  kami menggantung setelah menulis notifier pada bagian data berikutnya; </li><li>  ketika pemberitahuan setelah menulis dipanggil, kami memeriksa untuk melihat apakah kumpulan berikutnya telah tiba.  Jika ya, maka segera lakukan pengiriman bagian selanjutnya.  Jika tidak, maka cock timer. </li></ul><br><p>  Hasilnya, ternyata segera setelah perekaman mulai melambat, pengiriman data baru akan berhenti.  Dan lanjutkan ketika soket siap menerima data keluar baru. </p><br><h2 id="i-esche-nemnogo-slozhnogo-chunked_output">  Dan sedikit lebih rumit: chunked_output </h2><br><p>  RESTinio mendukung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tiga cara untuk menghasilkan respons terhadap permintaan HTTP</a> .  Metode paling sederhana, yang digunakan secara default, tidak cocok dalam kasus ini, karena  Saya membutuhkan aliran data keluar yang hampir tak ada habisnya.  Dan aliran seperti itu, tentu saja, tidak dapat <code>set_body</code> ke satu panggilan ke metode <code>set_body</code> . </p><br><p>  Oleh karena itu, server pengujian yang dijelaskan menggunakan apa yang disebut  <em>chunked_output</em> .  Yaitu  saat membuat jawaban, saya menunjukkan kepada RESTinio bahwa jawabannya akan dibentuk sebagian.  Kemudian saya secara berkala memanggil metode <code>append_chunk</code> untuk menambahkan bagian selanjutnya pada jawaban dan <code>flush</code> untuk menulis bagian yang terakumulasi ke soket. </p><br><h1 id="a-davayte-uzhe-posmotrim-v-kod">  Dan mari kita lihat kodenya! </h1><br><p>  Mungkin sudah cukup bahwa kata-kata pembuka sudah cukup dan sudah waktunya untuk beralih ke kode itu sendiri, yang dapat ditemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam repositori ini</a> .  Mari kita mulai dengan fungsi <code>request_processor</code> , yang dipanggil untuk memproses setiap permintaan HTTP yang valid.  Pada saat yang sama, mari kita mempelajari fungsi-fungsi yang dipanggil dari <code>request_processor</code> .  Baiklah, maka kita akan melihat bagaimana sebenarnya <code>request_processor</code> dipetakan ke satu atau permintaan HTTP lain yang masuk. </p><br><h2 id="funkciya-request_processor-i-eyo-podruchnye">  Fungsi Request_processor dan pembantunya </h2><br><p>  Fungsi <code>request_processor</code> dipanggil untuk memproses permintaan GET HTTP yang saya butuhkan.  Itu disampaikan sebagai argumen: </p><br><ul><li>  Asio-shny io_context di mana semua pekerjaan dilakukan (itu akan diperlukan, misalnya, untuk pengatur waktu pengadukan); </li><li>  ukuran satu bagian dari respons.  Yaitu  jika saya perlu memberikan aliran keluar dengan kecepatan 512KiB / detik, maka nilai 512KiB akan diteruskan sebagai parameter ini; </li><li>  sejumlah bagian dalam respons.  Dalam hal aliran harus memiliki panjang yang terbatas.  Misalnya, jika Anda ingin memberikan streaming dengan kecepatan 512KiB / detik selama 5 menit, maka nilai 300 akan diteruskan sebagai parameter ini (60 blok per menit selama 5 menit); </li><li>  Nah, permintaan yang masuk sendiri untuk diproses. </li></ul><br><p>  Di dalam <code>request_processor</code> , sebuah objek dibuat dengan informasi tentang permintaan dan parameter pemrosesannya, setelah itu proses ini dimulai: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request_processor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( asio_ns::io_context &amp; ctx, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunk_size, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count, restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">request_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> data = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;response_data&gt;( ctx, chunk_size, req-&gt;create_response&lt;<span class="hljs-keyword"><span class="hljs-keyword">output_t</span></span>&gt;(), count); data-&gt;response_ .append_header(restinio::http_field::server, <span class="hljs-string"><span class="hljs-string">"RESTinio"</span></span>) .append_header_date_field() .append_header( restinio::http_field::content_type, <span class="hljs-string"><span class="hljs-string">"text/plain; charset=utf-8"</span></span>) .flush(); send_next_portion(data); }</code> </pre> <br><p>  Jenis <code>response_data</code> , berisi semua parameter yang terkait dengan permintaan, terlihat seperti ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">response_data</span></span></span><span class="hljs-class"> {</span></span> asio_ns::io_context &amp; io_ctx_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> chunk_size_; <span class="hljs-keyword"><span class="hljs-keyword">response_t</span></span> response_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> counter_; response_data( asio_ns::io_context &amp; io_ctx, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> chunk_size, <span class="hljs-keyword"><span class="hljs-keyword">response_t</span></span> response, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> counter) : io_ctx_{io_ctx} , chunk_size_{chunk_size} , response_{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(response)} , counter_{counter} {} };</code> </pre> <br><p>  Perlu dicatat di sini bahwa salah satu alasan untuk penampilan struktur <code>response_data</code> adalah bahwa objek bertipe <code>restinio::response_builder_t&lt;restinio::chunked_output_t&gt;</code> (yaitu, tipe ini tersembunyi di belakang alias pendek <code>response_t</code> ) adalah tipe yang dapat dipindahkan, tetapi bukan tipe yang dapat disalin (oleh analogi dengan <code>std::unique_ptr</code> ).  Oleh karena itu, objek ini tidak bisa hanya ditangkap dalam fungsi lambda, yang kemudian membungkus dirinya dalam <code>std::function</code> .  Tetapi jika Anda menempatkan objek respons dalam instance <code>response_data</code> dibuat secara dinamis, maka pointer pintar ke instance <code>reponse_data</code> sudah dapat ditangkap dalam fungsi lambda tanpa masalah, dan kemudian menyimpan lambda ini ke <code>std::function</code> . </p><br><h3 id="funkciya-send_next_portion">  Fungsi Send_next_portion </h3><br><p>  Fungsi <code>send_next_portion</code> dipanggil setiap kali ketika perlu untuk mengirim bagian selanjutnya dari respons kepada klien.  Tidak ada yang rumit terjadi di dalamnya, sehingga terlihat cukup sederhana dan ringkas: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_next_portion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response_data_shptr data)</span></span></span><span class="hljs-function"> </span></span>{ data-&gt;response_.append_chunk(make_buffer(data-&gt;chunk_size_)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">1u</span></span> == data-&gt;counter_) { data-&gt;response_.flush(); data-&gt;response_.done(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { data-&gt;counter_ -= <span class="hljs-number"><span class="hljs-number">1u</span></span>; data-&gt;response_.flush(make_done_handler(data)); } }</code> </pre> <br><p>  Yaitu  kirim bagian selanjutnya.  Dan, jika bagian ini adalah yang terakhir, maka kami menyelesaikan pemrosesan permintaan.  Dan jika bukan yang terakhir, maka <code>flush</code> dikirim ke metode <code>flush</code> , yang dibuat, mungkin, oleh fungsi paling kompleks dari contoh ini. </p><br><h3 id="funkciya-make_done_handler">  Fungsi make_done_handler </h3><br><p>  Fungsi <code>make_done_handler</code> bertanggung jawab untuk membuat lambda yang akan diteruskan ke RESTinio sebagai pemberi notifikasi setelah menulis.  Pemberitahu ini harus memeriksa apakah rekaman bagian tanggapan berikutnya telah berhasil diselesaikan.  Jika ya, maka Anda perlu mencari tahu apakah bagian selanjutnya harus segera dikirim (yaitu, ada "rem" di soket dan laju pengiriman tidak dapat dipertahankan), atau setelah jeda.  Jika Anda perlu jeda, maka itu disediakan melalui pengukur waktu. </p><br><p>  Secara umum, tindakan sederhana, tetapi dalam kode Anda mendapatkan lambda di dalam lambda, yang dapat membingungkan orang-orang yang tidak terbiasa dengan "modern" C ++.  Yang tidak beberapa tahun disebut modern;) </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_done_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response_data_shptr data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> next_timepoint = steady_clock::now() + <span class="hljs-number"><span class="hljs-number">1</span></span>s; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [=](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; ec) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!ec) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> now = steady_clock::now(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(now &lt; next_timepoint) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> timer = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;asio_ns::steady_timer&gt;(data-&gt;io_ctx_); timer-&gt;expires_after(next_timepoint - now); timer-&gt;async_wait([timer, data](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; ec) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!ec) send_next_portion(data); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> data-&gt;io_ctx_.post([data] { send_next_portion(data); }); } }; }</code> </pre> <br><p>  Menurut pendapat saya, kesulitan utama dalam kode ini berasal dari kekhasan pembuatan dan peleton pengatur waktu di Asio.  Menurut pendapat saya, ternyata entah bagaimana terlalu bertele-tele.  Tapi memang ada, itu benar.  Tetapi Anda tidak perlu menarik perpustakaan tambahan apa pun. </p><br><h2 id="podklyuchenie-express-like-routera">  Menghubungkan router seperti ekspres </h2><br><p>  <code>send_next_portion</code> , <code>send_next_portion</code> dan <code>make_done_handler</code> ditunjukkan di atas <code>send_next_portion</code> merupakan versi pertama dari server pengujian saya, ditulis secara harfiah dalam 15 atau 20 menit. </p><br><p>  Tetapi setelah beberapa hari menggunakan server uji ini, ternyata ada kelemahan serius di dalamnya: selalu mengembalikan aliran respons dengan kecepatan yang sama.  Dikompilasi pada kecepatan 512KiB / detik - memberikan semua 512KiB / detik.  Dikompilasi ulang dengan kecepatan 20KiB / detik - akan memberikan kepada semua orang 20KiB / detik dan tidak ada yang lain.  Apa yang merepotkan, karena  menjadi perlu untuk dapat menerima jawaban dari "ketebalan" yang berbeda. </p><br><p>  Kemudian muncul ide: bagaimana jika kecepatan balik diminta langsung di URL?  Misalnya, mereka mengajukan permintaan ke <code>localhost:8080/</code> dan menerima respons pada kecepatan yang telah ditentukan.  Dan jika Anda mengajukan permintaan ke <code>localhost:8080/128K</code> , maka mereka mulai menerima respons dengan kecepatan 128KiB / detik. </p><br><p>  Kemudian pikiran itu melangkah lebih jauh: dalam URL Anda juga dapat menentukan jumlah bagian individu dalam respons.  Yaitu  permintaan <code>localhost:8080/128K/3000</code> akan menghasilkan aliran 3000 bagian dengan kecepatan 128KiB / detik. </p><br><p>  Tidak masalah  RESTinio memiliki kemampuan untuk menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">router kueri yang dibuat di bawah pengaruh ExpressJS</a> .  Akibatnya, ada fungsi untuk menggambarkan penangan untuk permintaan HTTP yang masuk: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_router</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(asio_ns::io_context &amp; ctx)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> router = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;<span class="hljs-keyword"><span class="hljs-keyword">router_t</span></span>&gt;(); router-&gt;http_get(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, [&amp;ctx](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>) { request_processor(ctx, <span class="hljs-number"><span class="hljs-number">100u</span></span>*<span class="hljs-number"><span class="hljs-number">1024u</span></span>, <span class="hljs-number"><span class="hljs-number">10000u</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); }); router-&gt;http_get( <span class="hljs-string"><span class="hljs-string">R"(/:value(\d+):multiplier([MmKkBb]?))"</span></span>, [&amp;ctx](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> params) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> chunk_size = extract_chunk_size(params); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">0u</span></span> != chunk_size) { request_processor(ctx, chunk_size, <span class="hljs-number"><span class="hljs-number">10000u</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_rejected(); }); router-&gt;http_get( <span class="hljs-string"><span class="hljs-string">R"(/:value(\d+):multiplier([MmKkBb]?)/:count(\d+))"</span></span>, [&amp;ctx](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> params) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> chunk_size = extract_chunk_size(params); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> count = restinio::cast_to&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(params[<span class="hljs-string"><span class="hljs-string">"count"</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">0u</span></span> != chunk_size &amp;&amp; <span class="hljs-number"><span class="hljs-number">0u</span></span> != count) { request_processor(ctx, chunk_size, count, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_rejected(); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> router; }</code> </pre> <br><p>  Di sini penanganan permintaan HTTP GET dibentuk untuk tiga jenis URL: </p><br><ul><li>  dari bentuk <code>http://localhost/</code> ; </li><li>  dari bentuk <code>http://localhost/&lt;speed&gt;[&lt;U&gt;]/</code> ; </li><li>  dari bentuk <code>http://localhost/&lt;speed&gt;[&lt;U&gt;]/&lt;count&gt;/</code> </li></ul><br><p>  Di mana <code>speed</code> adalah angka yang menentukan kecepatan, dan <code>U</code> adalah pengganda opsional yang menunjukkan di mana satuan kecepatan diatur.  Jadi <code>128</code> atau <code>128b</code> berarti kecepatan 128 byte per detik.  Dan <code>128k</code> adalah 128 kilobyte per detik. </p><br><p>  Setiap URL memiliki fungsi lambda sendiri, yang memahami parameter yang diterima, jika semuanya baik-baik saja, ia memanggil fungsi <code>request_processor</code> ditunjukkan di atas. </p><br><p>  Fungsi helper <code>extract_chunk_size</code> sebagai berikut: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> extract_chunk_size(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> restinio::router::<span class="hljs-keyword"><span class="hljs-keyword">route_params_t</span></span> &amp; params) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> multiplier = [](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> sv) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sv.empty() || <span class="hljs-string"><span class="hljs-string">"B"</span></span> == sv || <span class="hljs-string"><span class="hljs-string">"b"</span></span> == sv) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1u</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-string"><span class="hljs-string">"K"</span></span> == sv || <span class="hljs-string"><span class="hljs-string">"k"</span></span> == sv) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1024u</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1024u</span></span>*<span class="hljs-number"><span class="hljs-number">1024u</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::cast_to&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(params[<span class="hljs-string"><span class="hljs-string">"value"</span></span>]) * multiplier(params[<span class="hljs-string"><span class="hljs-string">"multiplier"</span></span>]); }</code> </pre> <br><p>  Di sini, C ++ lambda digunakan untuk meniru fungsi lokal dari bahasa pemrograman lain. </p><br><h2 id="funkciya-main">  Fungsi utama </h2><br><p>  Tetap melihat bagaimana semua ini berjalan di fungsi utama: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">router_t</span></span> = restinio::router::<span class="hljs-keyword"><span class="hljs-keyword">express_router_t</span></span>&lt;&gt;; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">traits_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_single_thread_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">logger_t</span></span> = restinio::<span class="hljs-keyword"><span class="hljs-keyword">single_threaded_ostream_logger_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">request_handler_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">router_t</span></span>; }; asio_ns::io_context io_ctx; restinio::run( io_ctx, restinio::on_this_thread&lt;<span class="hljs-keyword"><span class="hljs-keyword">traits_t</span></span>&gt;() .port(<span class="hljs-number"><span class="hljs-number">8080</span></span>) .address(<span class="hljs-string"><span class="hljs-string">"localhost"</span></span>) .write_http_response_timelimit(<span class="hljs-number"><span class="hljs-number">60</span></span>s) .request_handler(make_router(io_ctx))); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Apa yang terjadi di sini: </p><br><ol><li>  Karena saya tidak memerlukan router permintaan biasa (yang tidak bisa melakukan apa-apa sama sekali dan meletakkan semua pekerjaan di pundak programmer), saya mendefinisikan properti baru untuk server HTTP saya.  Untuk melakukan ini, saya mengambil properti standar dari server HTTP single-threaded (ketik <code>restinio::default_single_thread_traits_t</code> ) dan menunjukkan bahwa instance router seperti-ekspres akan digunakan sebagai penangan permintaan.  Pada saat yang sama, untuk mengontrol apa yang terjadi di dalam, saya menunjukkan bahwa server HTTP menggunakan logger nyata (secara default, <code>null_logger_t</code> digunakan yang tidak mencatat apa pun). </li><li>  Karena saya perlu memiringkan pengatur waktu di dalam notifiers setelah-tulis, saya memerlukan contoh io_context yang bisa saya gunakan.  Karena itu, saya membuatnya sendiri.  Ini memberi saya kesempatan untuk mengirimkan tautan ke io_context saya di fungsi <code>make_router</code> . </li><li>  Tetap hanya untuk memulai server HTTP dalam versi single-threaded pada io_context yang saya buat sebelumnya.  Fungsi <code>restinio::run</code> akan mengembalikan kontrol hanya ketika server HTTP menyelesaikan tugasnya. </li></ol><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>  Artikel itu tidak menunjukkan kode lengkap dari server pengujian saya, hanya poin utamanya.  Kode lengkap, yang sedikit lebih besar karena typedef tambahan dan fungsi tambahan, agak lebih otentik.  Anda bisa melihatnya di <a href="">sini</a> .  Pada saat penulisan, ini adalah 185 baris, termasuk baris kosong dan komentar.  Nah, 185 baris ini ditulis dalam beberapa pendekatan dengan durasi total hampir tidak lebih dari satu jam. </p><br><p>  Saya menyukai hasil ini dan tugasnya menarik.  Dalam istilah praktis, alat bantu yang saya butuhkan dengan cepat diperoleh.  Dan dalam hal pengembangan lebih lanjut dari RESTinio, beberapa pemikiran muncul. </p><br><p>  Secara umum, jika orang lain belum mencoba RESTinio, maka saya mengundang Anda untuk mencoba.  Proyek itu sendiri hidup di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> .  Anda dapat mengajukan pertanyaan atau mengungkapkan saran Anda di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">grup Google</a> atau di sini di komentar. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462349/">https://habr.com/ru/post/id462349/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462333/index.html">Membuat chatbot percakapan sederhana dengan python</a></li>
<li><a href="../id462335/index.html">Jangan membaca, baca kembali</a></li>
<li><a href="../id462337/index.html">Statistik situs dan repositori kecil Anda</a></li>
<li><a href="../id462339/index.html">Bagaimana pelatihan genggam terkait dengan standar internal Amazon dan bagaimana pengaruhnya terhadap pandangan dunia perusahaan?</a></li>
<li><a href="../id462347/index.html">Sepuluh hari pertama dalam perjalanan dari burung hantu ke burung awal: tidur, diet, diet dan olahraga</a></li>
<li><a href="../id462353/index.html">FAQ Keamanan Protokol LoRaWAN</a></li>
<li><a href="../id462355/index.html">Pemrograman JavaScript Asinkron (Panggilan Balik, Janji, RxJ)</a></li>
<li><a href="../id462357/index.html">Prototipe pertama: Unikern sebagai tahap dalam evolusi Linux</a></li>
<li><a href="../id462359/index.html">Dat - protokol apa itu dan siapa yang menggunakannya</a></li>
<li><a href="../id462365/index.html">Keterbatasan Pembelajaran Mesin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>