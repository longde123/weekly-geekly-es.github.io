<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§š ğŸ‘©ğŸ»â€ğŸš€ ğŸ‘©ğŸ¿â€ğŸ¤â€ğŸ‘©ğŸ½ Menjadikan Tower Defense sebagai Game Persatuan - Bagian 1 ğŸ—’ï¸ ğŸ– ğŸš£ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Game menara pertahanan semakin populer, dan ini tidak mengherankan - sedikit yang bisa dibandingkan dengan kesenangan mengamati garis pertahanan Anda ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menjadikan Tower Defense sebagai Game Persatuan - Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413837/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c5/894/e67/6c5894e675d3be7fedc6bf87038b2188.png" alt="gambar"></div><br>  Game menara pertahanan semakin populer, dan ini tidak mengherankan - sedikit yang bisa dibandingkan dengan kesenangan mengamati garis pertahanan Anda sendiri yang menghancurkan musuh-musuh jahat!  Dalam tutorial dua bagian ini, kita akan membuat game menara pertahanan di mesin <em>Unity</em> ! <br><br>  Anda akan belajar bagaimana melakukan hal berikut: <br><br><ul><li>  Buat gelombang musuh </li><li>  Buat mereka mengikuti titik rute </li><li>  Bangun dan tingkatkan menara, dan juga ajarkan mereka cara memecah musuh menjadi piksel kecil </li></ul><br>  Pada akhirnya, kita mendapatkan kerangka permainan, yang dapat dikembangkan lebih lanjut! <br><a name="habracut"></a><br><blockquote>  <em>Catatan</em> : Anda memerlukan pengetahuan Unity dasar (misalnya, Anda perlu tahu bagaimana aset dan komponen ditambahkan, apa cetakan) dan dasar-dasar <em>C #</em> .  Untuk mempelajari semua ini, saya sarankan Anda membaca tutorial tentang Unity oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sean Duffy</a> atau seri <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Beginning C # with Unity</a> oleh Brian Mockley. </blockquote><br>  Saya akan bekerja di Unity untuk OS X, tetapi tutorial ini juga cocok untuk Windows. <br><br><h2>  Melalui jendela menara gading </h2><br>  Dalam tutorial ini, kami akan membuat game menara pertahanan tempat musuh (bug kecil) merangkak ke cookie milik Anda dan antek Anda (tentu saja, ini adalah monster!).  Pemain dapat menempatkan monster di titik-titik strategis dan meningkatkannya untuk emas. <br><br>  Pemain harus membunuh semua bug sampai mereka mendapatkan cookie.  Setiap gelombang musuh baru menjadi semakin sulit dikalahkan.  Permainan berakhir ketika Anda selamat dari semua gelombang (kemenangan!) Atau ketika lima musuh merangkak ke cookie (kalah!). <br><br>  Ini adalah screenshot dari game yang sudah selesai: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/782/a94/fef/782a94fefd675365aba52fbfc4008ab6.png"></div><br>  <i>Monster, satukan!</i>  <i>Lindungi cookie!</i> <br><br><h2>  Mulai bekerja </h2><br>  Unduh <a href="">proyek</a> ini <a href="">kosong</a> , buka <em>zipnya</em> , dan buka proyek <em>TowerDefense-Part1-Starter</em> di Unity. <br><br>  Proyek draft memiliki aset grafik dan suara, animasi siap pakai dan beberapa skrip yang berguna.  Skrip tidak terkait langsung dengan game menara pertahanan, jadi saya tidak akan membicarakannya di sini.  Namun, jika Anda ingin mempelajari lebih lanjut tentang membuat animasi 2D di Unity, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Tutorial Unity 2D">tutorial Unity 2D ini</a> . <br><br>  Proyek ini juga mengandung cetakan, yang akan kami tambahkan nanti untuk membuat karakter.  Akhirnya, ada adegan dalam proyek dengan latar belakang dan antarmuka pengguna yang disesuaikan. <br><br>  Buka <em>GameScene yang</em> terletak di folder <em>Adegan</em> dan atur mode Game ke rasio aspek <em>4: 3</em> sehingga semua label cocok dengan latar belakang dengan benar.  Dalam mode Game, Anda akan melihat yang berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fb7/050/bda/fb7050bda1d91c148f65e70a7c217083.png"></div><br>  <em>Karangan:</em> <br><br><ul><li>  Grafik untuk proyek ini diambil dari paket Wiki Wenderlich gratis!  Karya grafis lainnya dapat ditemukan di situs web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="gameartguppy">gameartguppy-</a> nya. </li><li>  Musik yang hebat diambil dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Benound">BenSound</a> , yang memiliki soundtrack keren lainnya! </li><li>  Saya juga berterima kasih kepada Michael Jesper untuk fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="goyangan kamera">goyangan kamera yang</a> sangat berguna <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="goyangan kamera">.</a> </li></ul>  . <br><h2>  Tempat itu ditandai dengan tanda silang: lokasi monster </h2><br>  Monster hanya bisa ditempatkan pada titik yang ditandai dengan <em>x</em> . <br><br>  Untuk menambahkannya ke adegan, seret <em>Images \ Objects \ openspot</em> dari <em>Project Browser</em> ke jendela <em>Scene</em> .  Sementara posisi itu tidak penting bagi kami. <br><br>  Setelah Anda memilih <em>Openspot</em> dalam hierarki, klik <em>Tambahkan Komponen</em> di <em><em>Inspektur</em></em> dan pilih <em>Box Collider 2D</em> .  Di jendela Scene, Unity akan menampilkan collider persegi panjang dengan garis hijau.  Kami akan menggunakan collider ini untuk mengenali klik mouse di lokasi ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/271/6a9/3da/2716a93da69de6b5cf73a7edfc794210.png"></div><br>  Tambahkan komponen <em>Audio \ Audio Source</em> ke <em>Openspot</em> dengan cara yang sama.  Untuk parameter <em>AudioClip</em> komponen Sumber Audio, pilih file <em>tower_place yang</em> terletak di folder <em>Audio</em> dan nonaktifkan <em>Play On Sedarlah</em> . <br><br>  Kita perlu membuat 11 poin lagi.  Meskipun ada godaan untuk mengulangi semua langkah ini, Unity memiliki solusi yang lebih baik: <em>Prefab</em> ! <br><br>  Seret <em>Openspot</em> dari <em>Hierarki</em> ke folder <em>Rak itan</em> di dalam <em>Browser Proyek</em> .  Namanya akan berubah menjadi biru dalam Hierarki, yang artinya melekat pada cetakan.  Sesuatu seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad3/cb2/6a0/ad3cb26a0d51c893dd040e8f4f5dfea6.gif"></div><br>  Sekarang kami memiliki cetakan prefab, kami dapat membuat salinan sebanyak yang kami suka.  Cukup seret dan lepas <em>Openspot</em> dari folder <em>Rak itan</em> di dalam <em>Browser Proyek</em> ke dalam jendela <em>Adegan</em> .  Ulangi ini 11 kali dan 12 objek openspot akan muncul di layar. <br><br>  Sekarang gunakan <em>Inspektur</em> untuk mengatur 12 objek OpenSpot ini dengan koordinat berikut: <br><br><ul><li>  (X: -5.2, Y: 3.5, Z: 0) </li><li>  (X: -2.2, Y: 3.5, Z: 0) </li><li>  (X: 0,8, Y: 3,5, Z: 0) </li><li>  (X: 3,8, Y: 3,5, Z: 0) </li><li>  (X: -3,8, Y: 0,4, Z: 0) </li><li>  (X: -0,8, Y: 0,4, Z: 0) </li><li>  (X: 2.2, Y: 0.4, Z: 0) </li><li>  (X: 5.2, Y: 0.4, Z: 0) </li><li>  (X: -5.2, Y: -3.0, Z: 0) </li><li>  (X: -2.2, Y: -3.0, Z: 0) </li><li>  (X: 0,8, Y: -3,0, Z: 0) </li><li>  (X: 3,8, Y: -3,0, Z: 0) </li></ul><br>  Ketika Anda melakukan ini, pemandangannya akan terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69e/248/fb2/69e248fb213cfee35ce43f5f9c14baeb.png"></div><br><h2>  Kami menempatkan monster </h2><br>  Untuk mempermudah penempatan, ada <em>Rakasa</em> Rak <em>Rak di</em> folder <em>Rak Gudang</em> proyek. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c65/908/80a/c6590880acbdbac94bd15ec023311235.png"></div><br>  <i>Monster Rakasa Siap Pakai</i> <br><br>  Saat ini, itu terdiri dari objek permainan kosong dengan tiga sprite yang berbeda dan animasi penembakan sebagai anak-anak. <br><br>  Setiap sprite adalah monster dengan tingkat kekuatan yang berbeda.  Rak pabrikan juga berisi komponen <em>Sumber Audio</em> , yang akan diluncurkan untuk memutar suara ketika monster menembakkan laser. <br><br>  Sekarang kita akan membuat skrip yang akan <em>meng</em> - <em>host</em> <em>Monster</em> di <em>Openspot</em> . <br><br>  Di <em>Browser Proyek,</em> pilih objek <em>Openspot</em> di folder <em>Rak itan</em> .  Di <em>Inspektur,</em> klik <em>Tambah Komponen</em> , lalu pilih <em>Script Baru</em> dan <em>beri</em> nama script <em>PlaceMonster</em> .  Pilih <em>C Sharp</em> sebagai bahasa dan klik <em>Buat dan Tambah</em> .  Karena kami menambahkan skrip ke prefab <i>Openspot</i> , semua objek Openpot dalam adegan sekarang akan memiliki skrip ini.  Hebat! <br><br>  Klik dua kali pada skrip untuk membukanya di IDE.  Kemudian tambahkan dua variabel: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject monsterPrefab; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameObject monster;</code> </pre> <br>  Kami akan membuat instance objek yang disimpan di <code>monsterPrefab</code> untuk membuat monster, dan menyimpannya di <code>monster</code> sehingga dapat dimanipulasi selama permainan. <br><br><h3>  Satu monster per poin </h3><br>  Agar hanya satu monster yang dapat diletakkan pada satu titik, tambahkan metode berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanPlaceMonster</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> monster == <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Di <code>CanPlaceMonster()</code> kita dapat memeriksa apakah variabel <code>monster</code> masih <code>null</code> .  Jika demikian, maka tidak ada monster di titik itu, dan kita bisa menempatkannya. <br><br>  Sekarang tambahkan kode berikut untuk menempatkan monster ketika pemain mengklik GameObject ini: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//1 void OnMouseUp() { //2 if (CanPlaceMonster()) { //3 monster = (GameObject) Instantiate(monsterPrefab, transform.position, Quaternion.identity); //4 AudioSource audioSource = gameObject.GetComponent&lt;AudioSource&gt;(); audioSource.PlayOneShot(audioSource.clip); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">   } }</span></span></code> </pre> <br>  Kode ini menemukan monster ketika Anda mengklik mouse atau menyentuh layar.  Bagaimana cara kerjanya? <br><br><ol><li>  Unity secara otomatis memanggil <code>OnMouseUp</code> ketika seorang pemain menyentuh GameObject fisik collider. </li><li>  Ketika dipanggil, metode ini menempatkan monster jika <code>CanPlaceMonster()</code> mengembalikan <code>true</code> . </li><li>  Kami membuat monster menggunakan metode <code>Instantiate</code> , yang membuat instance dari prefab yang diberikan dengan posisi dan rotasi yang ditentukan.  Dalam hal ini, kami menyalin <code>monsterPrefab</code> , memberikannya posisi GameObject saat ini dan tidak ada rotasi, mentransfer hasilnya ke <code>GameObject</code> dan menyimpannya ke <code>monster</code> </li><li>  Pada akhirnya, kami memanggil <code>PlayOneShot</code> untuk memainkan efek suara yang melekat pada komponen <code>AudioSource</code> objek. </li></ol><br>  Sekarang skrip <code>PlaceMonster</code> kami dapat memiliki monster baru, tetapi kami masih perlu menentukan cetakan. <br><br><h3>  Menggunakan Prefab Kanan </h3><br>  Simpan file dan kembali ke Unity. <br><br>  Untuk mengatur variabel <em>monsterPrefab</em> , pertama-tama pilih objek <em>Openspot</em> dari folder <em>Rak itan</em> di browser proyek. <br><br>  Di <em><em>Inspektur,</em></em> klik pada lingkaran di sebelah kanan bidang <em>Rakasa Rakasa</em> komponen <em>PlaceMonster (Script)</em> dan pilih <em>Rakasa</em> di kotak dialog yang muncul. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b87/8bc/9c7/b878bc9c77c6e7c63a54f4a87d2a7c42.gif"></div><br>  Itu saja.  Luncurkan adegan dan buat monster di tempat yang berbeda dengan mengklik mouse atau menyentuh layar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/095/f08/01d/095f0801ddbbc91ce0eca144a22d4f7b.png"></div><br>  Hebat!  Sekarang kita bisa membuat monster.  Namun, mereka terlihat seperti kekacauan aneh, karena semua sprite anak monster itu ditarik.  Sekarang kita akan memperbaikinya. <br><br><h2>  Naikkan level monster </h2><br>  Gambar di bawah ini menunjukkan bahwa dengan peningkatan level, monster terlihat semakin menakutkan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a92/23d/480/a9223d480dda51f941c3b0b82f9f0dd6.png"></div><br>  <i>Manis sekali!</i>  <i>Tetapi jika Anda mencoba mencuri cookie-nya, monster ini akan berubah menjadi seorang pembunuh.</i> <br><br>  Script digunakan sebagai dasar untuk implementasi sistem level monster.  Ini melacak kekuatan monster di setiap level dan, tentu saja, level monster saat ini. <br><br>  Tambahkan skrip ini. <br><br>  Pilih <em>Rak Pabrikan / Rakasa</em> di <em>Browser Proyek</em> .  Tambahkan skrip <em>C #</em> baru yang disebut <em>MonsterData</em> .  Buka skrip di IDE dan tambahkan kode berikut di <i>atas</i> kelas <code>MonsterData</code> . <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MonsterLevel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cost; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject visualization; }</code> </pre> <br>  Jadi kami membuat <code>MonsterLevel</code> .  Ini mengelompokkan harga (dalam emas, yang akan kami dukung di bawah) dan representasi visual dari tingkat monster. <br><br>  Kami menambahkan di atas <code>[System.Serializable]</code> sehingga instance kelas dapat dimodifikasi di inspektur.  Ini memungkinkan kita untuk dengan cepat mengubah semua nilai kelas Level, bahkan ketika game sedang berjalan.  Ini sangat berguna untuk menyeimbangkan permainan. <br><br><h3>  Mengatur Level Monster </h3><br>  Dalam kasus kami, kami akan menyimpan <code>MonsterLevel</code> ditentukan di <code>List&lt;T&gt;</code> . <br><br>  Mengapa tidak menggunakan <code>MonsterLevel[]</code> ?  Kita perlu indeks objek <code>MonsterLevel</code> tertentu beberapa kali.  Meskipun mudah untuk menulis kode untuk ini, kita masih harus menggunakan <code>IndexOf()</code> , yang mengimplementasikan fungsionalitas <code>Lists</code> .  Tidak masuk akal untuk menemukan kembali roda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aae/85f/785/aae85f7854f44c8f418c5fde22153a53.jpg"></div><br>  <i>Menciptakan kembali sepeda motor biasanya merupakan ide yang buruk.</i> <br><br>  Di bagian atas <em>MonsterData.cs,</em> tambahkan konstruksi berikut <code>using</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic;</code> </pre> <br>  Ini memberi kita akses ke struktur data umum sehingga kita bisa menggunakan kelas <code>List&lt;T&gt;</code> dalam skrip. <br><br><blockquote>  <em>Catatan</em> : generalisasi adalah konsep C # yang kuat.  Mereka memungkinkan Anda untuk menentukan struktur data tipe aman tanpa harus mematuhi tipe tersebut.  Ini berguna untuk kelas kontainer seperti daftar dan set.  Untuk mempelajari lebih lanjut tentang struktur generik, baca buku <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Pengantar C # Generics">Pengantar C # Generik</a> . </blockquote><br>  Sekarang tambahkan variabel berikut ke <code>MonsterData</code> untuk menahan daftar <code>MonsterLevel</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;MonsterLevel&gt; levels;</code> </pre> <br>  Berkat generalisasi, kami dapat menjamin bahwa <code>List</code> dari <code>level</code> hanya akan berisi objek <code>MonsterLevel</code> . <br><br>  Simpan file dan beralih ke Unity untuk mengkonfigurasi setiap level. <br><br>  Pilih <em>Rak itan / Rakasa</em> di <em>Browser Proyek</em> .  <em><em>Inspektur</em></em> sekarang menampilkan bidang <em>Levels</em> dari komponen <em>MonsterData (Script)</em> .  Atur <em>ukuran</em> ke <em>3</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/660/dda/a18/660ddaa185b824721453ca1c892eedff.png"></div><br>  Selanjutnya, tetapkan <em>biaya</em> untuk setiap level: <br><br><ul><li>  <em>Elemen 0</em> : <em>200</em> </li><li>  <em>Elemen 1</em> : <em>110</em> </li><li>  <em>Elemen 2</em> : <em>120</em> </li></ul><br>  Sekarang kami menetapkan nilai bidang tampilan visual. <br><br>  Perluas <em>Rakasa / Rakasa</em> di peramban Proyek untuk melihat anak-anaknya.  Tarik anak <em>Monster0</em> ke dalam bidang <em>Elemen 0</em> <em>visualisasi</em> . <br><br>  Selanjutnya, atur <em>Elemen 1</em> ke <em>Monster1</em> , dan <em>Elemen 2</em> ke <em>Monster2</em> .  GIF menunjukkan proses ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/662/404/e30/662404e30bd808e1cf9a9d34b47d4d61.gif"></div><br>  Saat Anda memilih <em>Rak itan / Rakasa</em> , <em>Rak itan</em> akan terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/80b/e4d/17e/80be4d17e9894cf291b7be8a44152044.png"></div><br><h3>  Setel level saat ini </h3><br>  Kembali ke <em>MonsterData.cs</em> di IDE dan tambahkan variabel lain ke <code>MonsterData</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MonsterLevel currentLevel;</code> </pre> <br>  Dalam variabel private <code>currentLevel</code> kita akan menyimpan level monster saat ini. <br><br>  Sekarang atur <code>currentLevel</code> dan buat itu terlihat oleh skrip lain.  Tambahkan baris berikut ke <code>MonsterData</code> bersama dengan deklarasi variabel instan: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//1 public MonsterLevel CurrentLevel { //2 get { return currentLevel; } //3 set { currentLevel = value; int currentLevelIndex = levels.IndexOf(currentLevel); GameObject levelVisualization = levels[currentLevelIndex].visualization; for (int i = 0; i &lt; levels.Count; i++) { if (levelVisualization != null) { if (i == currentLevelIndex) { levels[i].visualization.SetActive(true); } else { levels[i].visualization.SetActive(false); } } } } }</span></span></code> </pre> <br>  Potongan kode C # yang cukup besar, bukan?  Mari kita lakukan secara berurutan: <br><br><ol><li>  Atur <em>properti</em> variabel <code>currentLevel</code> variabel.  Dengan mengatur properti, kita dapat menyebutnya seperti variabel lain: baik sebagai <code>CurrentLevel</code> (di dalam kelas) atau sebagai <code>monster.CurrentLevel</code> (di luar).  Kita dapat mendefinisikan perilaku apa pun dalam metode pengambil atau penyetel properti, dan dengan hanya membuat pengambil, penyetel, atau keduanya, kita dapat mengontrol properti properti: baca-saja, hanya-tulis, dan tulis / baca. </li><li>  Di pengambil, kami mengembalikan nilai <code>currentLevel</code> . </li><li>  Di setter, kami menetapkan <code>currentLevel</code> nilai baru.  Kemudian kita mendapatkan indeks level saat ini.  Akhirnya, kami menggilir semua <em>tingkatan</em> dan mengaktifkan / menonaktifkan tampilan visual tergantung pada <code>currentLevelIndex</code> .  Ini bagus karena ketika <code>currentLevel</code> berubah, sprite memperbarui secara otomatis.  Properti adalah hal yang sangat nyaman! </li></ol><br>  Tambahkan implementasi <code>OnEnable</code> berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CurrentLevel = levels[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br>  Di sini kita mengatur <code>CurrentLevel</code> saat menempatkan.  Ini memastikan bahwa hanya sprite yang diinginkan yang ditampilkan. <br><br><blockquote>  <em>Catatan</em> : penting untuk menginisialisasi properti di <code>OnEnable</code> , dan bukan di <code>OnStart</code> , karena kami memanggil metode ordinal saat membuat instance prefab. <br><br>  <code>OnEnable</code> akan dipanggil segera ketika cetakan dibuat (jika cetakan disimpan dalam keadaan diaktifkan), tetapi <code>OnStart</code> tidak dipanggil sampai objek mulai berjalan sebagai bagian dari adegan. <br><br>  Kami perlu memverifikasi data ini sebelum menempatkan monster, jadi kami inisialisasi ke <code>OnEnable</code> . </blockquote><br>  Simpan file dan kembali ke Unity.  Jalankan proyek dan tempatkan monster;  mereka sekarang menampilkan sprite yang benar dari level terendah. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/08e/16e/549/08e16e5498d12f78d106d873d34c8d1b.png"></div><br><h3>  Peningkatan Monster </h3><br>  Kembali ke IDE dan tambahkan metode berikut ke <code>MonsterData</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> MonsterLevel </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNextLevel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentLevelIndex = levels.IndexOf (currentLevel); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxLevelIndex = levels.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentLevelIndex &lt; maxLevelIndex) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> levels[currentLevelIndex+<span class="hljs-number"><span class="hljs-number">1</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br>  Di <code>GetNextLevel</code> kita mendapatkan indeks <code>currentLevel</code> dan indeks level tertinggi;  jika monster belum mencapai level maksimum, maka level berikutnya kembali.  Jika tidak, <code>null</code> dikembalikan. <br><br>  Anda dapat menggunakan metode ini untuk mengetahui apakah upgrade monster dimungkinkan. <br><br>  Untuk menaikkan level monster, tambahkan metode berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseLevel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentLevelIndex = levels.IndexOf(currentLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentLevelIndex &lt; levels.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>) { CurrentLevel = levels[currentLevelIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>]; } }</code> </pre> <br>  Di sini kita mendapatkan indeks level saat ini, dan kemudian memastikan bahwa ini bukan level maksimum, memeriksa bahwa itu kurang dari level. <code>levels.Count - 1</code> .  Jika demikian, maka <code>CurrentLevel</code> ke level berikutnya. <br><br><h3>  Memeriksa Fungsi Peningkatan </h3><br>  Simpan file dan kembali ke <em>PlaceMonster.cs</em> di IDE.  Tambahkan metode baru: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanUpgradeMonster</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (monster != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { MonsterData monsterData = monster.GetComponent&lt;MonsterData&gt;(); MonsterLevel nextLevel = monsterData.GetNextLevel(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextLevel != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Pertama kita periksa apakah ada monster yang bisa diperbaiki dengan membandingkan variabel <code>monster</code> dengan <code>null</code> .  Jika ini benar, maka kita mendapatkan level monster saat ini dari <code>MonsterData</code> -nya. <br><br>  Kemudian kami memeriksa apakah level berikutnya tersedia, yaitu, apakah <code>GetNextLevel()</code> tidak mengembalikan <code>null</code> .  Jika peningkatan level dimungkinkan, maka kami mengembalikan <code>true</code> ;  jika tidak, kembalikan <code>false</code> . <br><br><h3>  Kami menerapkan peningkatan untuk emas </h3><br>  Untuk mengaktifkan opsi pemutakhiran, tambahkan cabang <code>else if</code> ke <code>OnMouseUp</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CanPlaceMonster()) { <span class="hljs-comment"><span class="hljs-comment">//      } else if (CanUpgradeMonster()) { monster.GetComponent&lt;MonsterData&gt;().IncreaseLevel(); AudioSource audioSource = gameObject.GetComponent&lt;AudioSource&gt;(); audioSource.PlayOneShot(audioSource.clip); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">   }</span></span></code> </pre> <br>  Kami memeriksa kemungkinan peningkatan menggunakan <code>CanUpgradeMonster()</code> .  Jika memungkinkan, kita mengakses komponen <code>GetComponent()</code> menggunakan <code>GetComponent()</code> dan memanggil <code>IncreaseLevel()</code> , yang meningkatkan level monster.  Akhirnya, kami meluncurkan Monster <em>AudioSource</em> . <br><br>  Simpan file dan kembali ke Unity.  Jalankan game, tempatkan dan tingkatkan <i>sejumlah</i> monster (tetapi untuk sekarang). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb7/495/bed/cb7495bed8ebcd3993439de25a08a0e7.png"></div><br><h2>  Membayar Emas - Manajer Game </h2><br>  Meskipun kita bisa segera membangun dan meningkatkan monster apa pun, tetapi apakah itu akan menarik dalam game? <br><br>  Mari kita lihat masalah emas.  Masalah dengan pelacakan itu adalah kita harus mentransfer informasi antara objek permainan yang berbeda. <br><br>  Gambar di bawah ini menunjukkan semua objek yang harus mengambil bagian dalam hal ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e35/8cd/6f4/e358cd6f461c75385f61f1c12862a16b.png"></div><br>  <i>Semua objek permainan yang dipilih harus tahu berapa banyak emas yang dimiliki pemain.</i> <br><br>  Untuk menyimpan data ini, kami akan menggunakan objek umum yang dapat diakses oleh objek lain. <br><br>  Klik kanan pada <em>Hierarki</em> dan pilih <em>Buat Kosong</em> .  Beri nama objek <em>GameManager</em> baru. <br><br>  Tambahkan skrip <em>C #</em> baru yang disebut <em>GameManagerBehavior ke GameManager</em> , lalu buka di IDE.  Kami akan menampilkan jumlah total emas pemain di label, jadi di bagian atas file tambahkan baris berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI;</code> </pre> <br>  Ini akan memungkinkan kita untuk mengakses kelas UI seperti <code>Text</code> , yang digunakan untuk label.  Sekarang tambahkan variabel berikut ke kelas: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text goldLabel;</code> </pre> <br>  Ini akan menyimpan tautan ke komponen <code>Text</code> digunakan untuk menampilkan jumlah emas yang dimiliki pemain. <br><br>  Sekarang <code>GameManager</code> tahu tentang label, bagaimana kita menyinkronkan jumlah emas yang disimpan dalam variabel dan nilai yang ditampilkan dalam label?  Kami akan membuat properti. <br><br>  Tambahkan kode berikut ke <code>GameManagerBehavior</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> gold; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Gold { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gold; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { gold = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; goldLabel.GetComponent&lt;Text&gt;().text = <span class="hljs-string"><span class="hljs-string">"GOLD: "</span></span> + gold; } }</code> </pre> <br>  Apakah dia tampak akrab?  Kode ini mirip dengan <code>CurrentLevel</code> , yang kami atur di <code>Monster</code> .  Pertama kita membuat variabel <code>gold</code> pribadi untuk menampung jumlah emas saat ini.  Lalu kita atur properti <code>Gold</code> (tiba-tiba, kan?) Dan terapkan pengambil dan penyetel. <br><br>  Sang pengambil hanya mengembalikan nilai <code>gold</code> .  Setter lebih menarik.  Selain mengatur nilai variabel, itu juga menetapkan bidang <code>text</code> untuk <code>goldLabel</code> untuk menampilkan nilai emas baru. <br><br>  Bagaimana kita akan bermurah hati?  Tambahkan baris berikut ke <code>Start()</code> untuk memberi pemain <em>1000</em> emas, atau kurang jika Anda menyesal atas uang itu: <br><br><pre> <code class="cs hljs">Gold = <span class="hljs-number"><span class="hljs-number">1000</span></span>;</code> </pre> <br><h3>  Menetapkan objek label ke skrip </h3><br>  Simpan file dan kembali ke Unity.  Di <em>Hirarki,</em> pilih <em>GameManager</em> .  Di <em><em>Inspektur,</em></em> klik pada lingkaran di sebelah kanan <em>Label Emas</em> .  Di kotak dialog <em>Select Text</em> , pilih tab <em>Scene</em> dan pilih <em>GoldLabel</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/05e/82e/956/05e82e95690113e0086020a817e2718c.png"></div><br>  Jalankan adegan dan label akan menampilkan <em>Emas: 1000</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a97/b8f/b45/a97b8fb455f50659176371e484a280e6.png"></div><br><h3>  Memeriksa "dompet" pemain </h3><br>  Buka skrip <em>PlaceMonster.cs</em> di IDE dan tambahkan variabel instance berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameManagerBehavior gameManager;</code> </pre> <br>  Kami akan menggunakan <code>gameManager</code> untuk mengakses komponen <code>GameManagerBehavior</code> dari objek <code>GameManagerBehavior</code> <em>di</em> layar.  Untuk menentukannya, tambahkan yang berikut ke <code>Start()</code> : <br><br><pre> <code class="cs hljs">gameManager = GameObject.Find(<span class="hljs-string"><span class="hljs-string">"GameManager"</span></span>).GetComponent&lt;GameManagerBehavior&gt;();</code> </pre> <br>  Kami mendapatkan GameObject bernama GameManager menggunakan fungsi <code>GameObject.Find()</code> , yang mengembalikan objek game pertama yang ditemukan dengan nama itu.  Kemudian kita mendapatkan komponen <code>GameManagerBehavior</code> dan menyimpannya untuk masa depan. <br><br><blockquote>  <em>Catatan</em> : Anda bisa melakukan ini dengan menyetel bidang di editor Unity atau dengan menambahkan metode statis ke <code>GameManager</code> yang mengembalikan instance singleton dari mana kita bisa mendapatkan <code>GameManagerBehavior</code> . <br><br>  Namun, dalam blok kode yang ditunjukkan di atas ada kuda hitam: metode <code>Find</code> , yang bekerja lebih lambat selama eksekusi aplikasi;  tetapi nyaman dan dapat digunakan dalam jumlah sedang. </blockquote><br><h3>  Ambil uangku! </h3><br>  Kami belum mengurangi emas, jadi kami akan menambahkan baris ini <em>dua kali</em> ke <code>OnMouseUp()</code> , menggantikan masing-masing komentar <code>// TODO:  </code> : <br><br><pre> <code class="cs hljs">gameManager.Gold -= monster.GetComponent&lt;MonsterData&gt;().CurrentLevel.cost;</code> </pre> <br>  Simpan file dan kembali ke Unity, perbarui beberapa monster dan lihat pembaruan nilai Gold.  Sekarang kami mengurangi emas, tetapi pemain dapat membangun monster selama mereka memiliki cukup ruang;  mereka hanya meminjam uang. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/581/2fe/eaf/5812feeafd4b9d316f8294db56d55789.png"></div><br>  <i>Kredit tak terbatas?</i>  <i>Hebat!</i>  <i>Tapi kita tidak bisa membiarkannya.</i>  <i>Pemain harus bisa bertaruh monster sementara dia memiliki cukup emas.</i> <br><br><h3>  Cek Emas untuk Monster </h3><br>  Beralih di IDE ke <em>PlaceMonster.cs</em> dan ganti konten <code>CanPlaceMonster()</code> berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cost = monsterPrefab.GetComponent&lt;MonsterData&gt;().levels[<span class="hljs-number"><span class="hljs-number">0</span></span>].cost; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> monster == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; gameManager.Gold &gt;= cost;</code> </pre> <br>  Kami <code>MonsterData</code> penempatan monster dari <code>levels</code> di <code>MonsterData</code> -nya.  Lalu kita periksa <code>monster</code> bukan <code>null</code> , dan itu <code>gameManager.Gold</code> lebih dari harga ini. <br><br>  Tugas untuk Anda: tambahkan secara independen ke <code>CanUpgradeMonster()</code> centang apakah pemain memiliki cukup emas. <br><br><div class="spoiler">  <b class="spoiler_title">Solusi di dalam</b> <div class="spoiler_text">  Ganti baris: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre> <br>  tentang ini: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gameManager.Gold &gt;= nextLevel.cost;</code> </pre> <br>  Ini akan memeriksa apakah pemain memiliki lebih banyak <em>Emas</em> daripada harga upgrade. </div></div><br>  Simpan dan jalankan adegan di Unity.  Sekarang cobalah cara menambahkan monster tanpa batas! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24b/f58/b6a/24bf58b6a0a1d4258295902f5d05c6bd.png"></div><br>  <i>Sekarang kita hanya dapat membangun sejumlah monster.</i> <br><br><h2>  Kebijakan menara: musuh, gelombang, dan titik arah </h2><br>  Inilah saatnya untuk "membuka jalan" bagi musuh-musuh kita.  Musuh muncul di titik pertama rute, pindah ke yang berikutnya dan ulangi prosesnya hingga mencapai cookie. <br><br>  Anda dapat membuat musuh bergerak seperti ini: <br><br><ol><li>  Atur jalan yang akan diikuti musuh </li><li>  Pindahkan musuh di sepanjang jalan </li><li>  Putar musuh sehingga dia melihat ke depan </li></ol><br><h3>  Membuat jalan dari titik arah </h3><br>  Klik kanan pada <em>Hierarchy</em> dan pilih <em>Create Empty</em> untuk membuat objek game baru yang kosong.  Beri nama <em>Jalan</em> dan posisikan di <em>(0, 0, 0)</em> . <br><br>  Sekarang klik kanan pada <em>Road</em> in the <em>Hierarchy</em> dan buat objek game kosong lainnya sebagai anak Road.  Beri nama <em>Waypoint0</em> dan letakkan di titik <em>(-12, 2, 0)</em> - dari sini musuh akan memulai gerakan mereka. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78a/21a/044/78a21a0443e9b71b4c28064196cd0f8f.png"></div><br>  Demikian pula, buat lima titik rute lagi dengan nama dan posisi berikut: <br><br><ul><li>  Waypoint1: (X: 7, Y: 2, Z: 0) </li><li>  Waypoint2: (X: 7, Y: -1, Z: 0) </li><li>  Waypoint3: (X: -7.3, Y: -1, Z: 0) </li><li>  Waypoint4: (X: -7.3, Y: -4.5, Z: 0) </li><li>  Waypoint5: (X: 7, Y: -4.5, Z: 0) </li></ul><br>  Tangkapan layar di bawah ini menunjukkan titik rute dan jalur yang dihasilkan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c5/894/e67/6c5894e675d3be7fedc6bf87038b2188.png"></div><br><h2>  Membuat musuh </h2><br>  Sekarang buat beberapa musuh sehingga mereka bisa bergerak di sepanjang jalan.  Ada prefab <em>Musuh</em> di folder <em>Rak itan</em> .  Posisinya adalah <em>(-20, 0, 0)</em> , jadi instance baru akan dibuat di luar layar. <br><br>  Dalam semua hal lain, ini dikonfigurasi hampir dengan cara yang sama seperti Rakasa Rakasa, memiliki <code>AudioSource</code> dan anak <code>Sprite</code> , dan kita dapat memutar sprite ini di masa depan tanpa memutar bar kesehatan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d46/5c7/b09/d465c7b0950d7c718abcb8869263753c.png"></div><br><h3>  Kami menggerakkan musuh di sepanjang jalan </h3><br>  Tambahkan skrip <em>C #</em> baru yang disebut <em>MoveEnemy</em> ke <em>prefab \ prefab Musuh</em> .  Buka skrip di IDE dan tambahkan variabel berikut: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">HideInInspector</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject[] waypoints; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentWaypoint = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lastWaypointSwitchTime; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>;</code> </pre> <br>  Di <code>waypoints</code> , salinan titik rute disimpan dalam array, dan baris <code>[HideIn <em>inspector</em> ]</code> atas <code>waypoints</code> memastikan bahwa kami tidak dapat secara tidak sengaja mengubah bidang ini di <em><em>Inspektur</em></em> , tetapi masih akan memiliki akses ke sana dari skrip lain. <br><br>  <code>currentWaypoint</code> melacak dari mana rute musuh dari pada saat ini, dan <code>lastWaypointSwitchTime</code> menyimpan waktu ketika musuh melewatinya.  Selain itu, kami menyimpan <code>speed</code> musuh. <br><br>  Tambahkan baris ini ke <code>Start()</code> : <br><br><pre> <code class="cs hljs">lastWaypointSwitchTime = Time.time;</code> </pre> <br>  Jadi kami menginisialisasi <code>lastWaypointSwitchTime</code> dengan nilai waktu saat ini. <br><br>  Agar musuh bergerak di sepanjang rute, tambahkan kode berikut ke <code>Update()</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 Vector3 startPosition = waypoints [currentWaypoint].transform.position; Vector3 endPosition = waypoints [currentWaypoint + 1].transform.position; // 2 float pathLength = Vector3.Distance (startPosition, endPosition); float totalTimeForPath = pathLength / speed; float currentTimeOnPath = Time.time - lastWaypointSwitchTime; gameObject.transform.position = Vector2.Lerp (startPosition, endPosition, currentTimeOnPath / totalTimeForPath); // 3 if (gameObject.transform.position.Equals(endPosition)) { if (currentWaypoint &lt; waypoints.Length - 2) { // 3.a currentWaypoint++; lastWaypointSwitchTime = Time.time; // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">     } else { // 3.b Destroy(gameObject); AudioSource audioSource = gameObject.GetComponent&lt;AudioSource&gt;(); AudioSource.PlayClipAtPoint(audioSource.clip, transform.position); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">   } }</span></span></code> </pre> <br>  Mari kita menganalisis kode langkah demi langkah: <br><br><ol><li>  Dari berbagai titik rute, kami mendapatkan posisi awal dan akhir dari segmen rute saat ini. </li><li>  Kami menghitung waktu yang diperlukan untuk mencakup seluruh jarak menggunakan rumus <em>waktu = jarak / kecepatan</em> , dan kemudian menentukan waktu saat ini pada rute.  Menggunakan <code>Vector2.Lerp</code> , kami menginterpolasi posisi musuh saat ini antara segmen awal dan akhir yang tepat. </li><li>  Periksa apakah musuh telah mencapai <code>endPosition</code> .  Jika ya, maka kami memproses dua skenario yang mungkin: <br><ol><li>  Musuh belum mencapai titik terakhir rute, jadi tambah nilai <code>currentWaypoint</code> dan perbarui <code>lastWaypointSwitchTime</code> .  Nanti kita akan menambahkan kode untuk mengubah musuh sehingga dia melihat ke arah gerakannya. </li><li>  Musuh telah mencapai titik terakhir dari rute, lalu kita hancurkan dan mulai efek suara.  Nanti kita akan menambahkan kode yang mengurangi <code>health</code> pemain. </li></ol></li></ol><br>  Simpan file dan kembali ke Unity. <br><br><h3>  Kami memberi tahu musuh tentang arah gerakan </h3><br>  Dalam kondisi saat ini, musuh tidak mengetahui urutan titik rute. <br><br>  Pilih <em>Jalan</em> di <em>Hirarki</em> dan tambahkan skrip <em>C #</em> baru yang disebut <em>SpawnEnemy</em> .  Buka di IDE dan tambahkan variabel berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject[] waypoints;</code> </pre> <br>  Kami akan menggunakan <code>waypoints</code> untuk menyimpan referensi ke titik lewat dalam adegan dalam urutan yang diinginkan. <br><br>  Simpan file dan kembali ke Unity.  Pilih <em>Road</em> di <em>Hierarchy</em> dan atur <em>Size of</em> the <em>Waypoints</em> array menjadi <em>6</em> . <br><br>  Seret setiap anak Jalan ke dalam bidang dengan menempelkan <em>Waypoint0</em> di <em>Elemen 0</em> , <em>Waypoint1</em> di <em>Elemen 1,</em> dan seterusnya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95a/1e3/251/95a1e3251247a04f62f8a618b681c052.gif"></div><br>  Sekarang kami memiliki array yang berisi titik rute dalam urutan yang benar - ingat, musuh tidak pernah mundur, mereka terus-menerus berjuang untuk mendapatkan hadiah yang manis. <br><br><h3>  Periksa cara kerjanya </h3><br>  Buka <em>SpawnEnemy</em> di IDE dan tambahkan variabel berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject testEnemyPrefab;</code> </pre> <br>  Ini akan menyimpan referensi ke <code>testEnemyPrefab</code> <em>Musuh</em> di <code>testEnemyPrefab</code> . <br><br>  Untuk membuat musuh saat menjalankan skrip, tambahkan kode berikut ke <code>Start()</code> : <br><br><pre> <code class="cs hljs">Instantiate(testEnemyPrefab).GetComponent&lt;MoveEnemy&gt;().waypoints = waypoints;</code> </pre> <br>  Jadi kami akan membuat salinan cetakan baru yang disimpan di <code>testEnemy</code> dan memberinya rute. <br><br>  Simpan file dan kembali ke Unity.  Pilih objek <em>Jalan</em> di <em>Hirarki</em> dan pilih prefab <em>Musuh</em> untuk parameter <em>Uji Musuh</em> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Luncurkan proyek dan lihat bagaimana musuh bergerak di sepanjang jalan (di GIF, untuk kejelasan, kecepatannya meningkat 20 kali). </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b6/b10/384/0b6b1038491a74c27d6b42860e44365e.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Melihat bahwa dia tidak selalu melihat ke mana dia pergi? </font><font style="vertical-align: inherit;">Ini lucu, tapi kami mencoba membuat game profesional. </font><font style="vertical-align: inherit;">Oleh karena itu, di bagian kedua tutorial kami akan mengajarkan musuh untuk berharap.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ke mana harus pergi selanjutnya? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami telah melakukan banyak hal dan dengan cepat bergerak menuju pembuatan game pertahanan menara kami sendiri. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemain dapat membuat sejumlah monster, dan musuh berlari di sepanjang jalan, menuju cookie kami. </font><font style="vertical-align: inherit;">Pemain memiliki emas dan mereka dapat meningkatkan monster. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unduh hasil akhirnya </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada bagian </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kedua,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kita akan mempertimbangkan penciptaan gelombang besar musuh dan kehancuran mereka. </font><font style="vertical-align: inherit;">Sampai ketemu lagi!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id413837/">https://habr.com/ru/post/id413837/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id413817/index.html">Pemrosesan data kompetitif heterogen real-time secara ketat satu kali</a></li>
<li><a href="../id413819/index.html">Jujur tentang pasar TI di Rusia</a></li>
<li><a href="../id413823/index.html">Booming pekerjaan yang tidak berarti</a></li>
<li><a href="../id413827/index.html">Proyek Kubernetes berusia 4 tahun</a></li>
<li><a href="../id413831/index.html">Versi baru Tesla Autopilot akan dirilis pada bulan Agustus, untuk pertama kalinya dengan "fitur mengemudi yang sepenuhnya otonom"</a></li>
<li><a href="../id413839/index.html">AI, tentu saja praktis. Pengumpulan dan penelitian gambar</a></li>
<li><a href="../id413841/index.html">Alternatif untuk Produk Google</a></li>
<li><a href="../id413843/index.html">Waymo di depan yang lain: robomobiles perusahaan telah bergulir 11 juta kilometer</a></li>
<li><a href="../id413847/index.html">Monumen pemicu "Hidup"</a></li>
<li><a href="../id413849/index.html">Sennheiser Brand History: Freedom and Visioning</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>