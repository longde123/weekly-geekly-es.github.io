<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèæ üåí üöë Como o codec de v√≠deo funciona. Parte 2. O que, por que, como üë©üèΩ‚Äçüíª üòï üöµüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parte I: No√ß√µes b√°sicas de v√≠deo e imagem 

  

 O que? Um codec de v√≠deo √© um software / hardware que compacta e / ou descompacta o v√≠deo digital. 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como o codec de v√≠deo funciona. Parte 2. O que, por que, como</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/480430/"><h3>  Parte I: <a href="https://habr.com/ru/company/edison/blog/481418/">No√ß√µes b√°sicas de v√≠deo e imagem</a> </h3><br><hr><br> <a href="https://habr.com/ru/company/edison/blog/480430/"><img src="https://habrastorage.org/webt/ta/r8/lt/tar8ltvwz2ubkwwudgcjws-sa9a.png" alt="Hist√≥ria do Kodek"></a> <br><br>  <b>O que?</b>  Um codec de v√≠deo √© um software / hardware que compacta e / ou descompacta o v√≠deo digital. <br><br>  <b>Para que?</b>  Apesar de certas limita√ß√µes em termos de largura de banda, <br>  e em termos de quantidade de espa√ßo de armazenamento, o mercado exige cada vez mais v√≠deos de alta qualidade.  Lembre-se de como, na √∫ltima postagem, calculamos o m√≠nimo necess√°rio para 30 quadros por segundo, 24 bits por pixel, com uma resolu√ß√£o de 480x240?  Recebeu 82,944 Mbps sem compacta√ß√£o.  A compress√£o √© a √∫nica maneira de transferir HD / FullHD / 4K para telas de TV e Internet.  Como isso √© alcan√ßado?  Agora vamos considerar brevemente os principais m√©todos. <a name="habracut"></a><blockquote> <a href="https://www.edsd.ru/" title="EDISON Software - desenvolvimento web"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON Software - desenvolvimento web"></a> <br clear="right">  A tradu√ß√£o foi feita com o apoio do software EDISON. <br><br>  Estamos envolvidos na <a href="https://www.edsd.ru/integratsiya-sistem-videonablyudeniya-axxon-next-i-sureview-immix">integra√ß√£o de sistemas de vigil√¢ncia por v√≠deo</a> , bem como no <a href="https://www.edsd.ru/prilozhenie-dlya-mikrotomografa">desenvolvimento de um microtom√≥grafo</a> . </blockquote><h3>  Codec vs Container </h3><br>  Um erro comum para iniciantes √© confundir um codec de v√≠deo digital e um cont√™iner de v√≠deo digital.  Um cont√™iner √© um determinado formato.  Um wrapper contendo metadados de v√≠deo (e possivelmente √°udio).  O v√≠deo compactado pode ser considerado como uma carga √∫til do cont√™iner. <br><br>  Normalmente, uma extens√£o de arquivo de v√≠deo indica um tipo de cont√™iner.  Por exemplo, o arquivo video.mp4 provavelmente √© um cont√™iner <i>MPEG-4 Parte 14</i> e o arquivo video.mkv provavelmente √© uma <a href="https://ru.wikipedia.org/wiki/Matroska">boneca</a> russa.  Para ter total confian√ßa no codec e no formato do cont√™iner, voc√™ pode usar o <a href="https://www.ffmpeg.org/">FFmpeg</a> ou o <a href="https://mediaarea.net/ru/MediaInfo">MediaInfo</a> . <br><br><h3>  Um pouco de hist√≥ria </h3><br>  Antes de chegarmos a <b>Como?</b>  , vamos explorar um pouco da hist√≥ria para entender um pouco melhor alguns codecs antigos. <br><br>  O codec de v√≠deo <b>H.261</b> apareceu em 1990 (tecnicamente - em 1988) e foi criado para funcionar com uma taxa de transfer√™ncia de dados de 64 Kbps.  Ele j√° usou id√©ias como subamostragem de cores, macroblocos etc.  Em 1995, foi publicado o padr√£o de codec de v√≠deo <b>H.263</b> , desenvolvido at√© 2001. <br><br>  Em 2003, a primeira vers√£o do <b>H.264 / AVC</b> foi conclu√≠da.  No mesmo ano, o TrueMotion lan√ßou seu codec de v√≠deo gratuito que comprime o v√≠deo com perdas chamado <b>VP3</b> .  Em 2008, o Google comprou esta empresa, lan√ßando o <b>VP8</b> no mesmo ano.  Em dezembro de 2012, o Google lan√ßou o <b>VP9</b> e √© suportado em aproximadamente ¬æ do mercado de navegadores (incluindo dispositivos m√≥veis). <br><br>  <b>O AV1</b> √© um novo codec de v√≠deo de c√≥digo aberto gratuito desenvolvido <b>pela Open Media Alliance</b> ( <b>AOMedia</b> ), que inclui empresas conhecidas como Google, Mozilla, Microsoft, Amazon, Netflix, AMD, ARM, NVidia, Intel e Cisco. .  A primeira vers√£o do codec 0.1.0 foi publicada em 7 de abril de 2016. <br><br><h3>  Nascimento do AV1 </h3><br>  No in√≠cio de 2015, o Google trabalhou no <b>VP10</b> , o Xiph (que pertence √† Mozilla) trabalhou no <b>Daala</b> e a Cisco criou seu codec de v√≠deo gratuito chamado <b>Thor</b> . <br><br>  Em seguida, a <b>MPEG LA</b> anunciou pela primeira vez limites anuais para <b>HEVC</b> ( <b>H.265</b> ) e uma taxa 8 vezes maior que para H.264, mas eles logo mudaram as regras novamente: <br><br>  sem limite anual, <br>  taxa de conte√∫do (0,5% da receita) e <br>  os custos unit√°rios s√£o cerca de 10 vezes superiores aos do H.264. <br><br>  <i>A Open Media Alliance</i> foi criada por empresas de v√°rios campos: fabricantes de equipamentos (Intel, AMD, ARM, Nvidia, Cisco), provedores de conte√∫do (Google, Netflix, Amazon), fabricantes de navegadores (Google, Mozilla) e outros. <br><br>  As empresas tinham um objetivo comum - um codec de v√≠deo sem royalties.  Depois vem o <b>AV1</b> com uma licen√ßa de patente muito mais simples.  Timothy B. Terriberry fez uma apresenta√ß√£o impressionante, que se tornou a fonte do conceito atual do AV1 e seu modelo de licen√ßa. <br><br>  Voc√™ ficar√° surpreso ao saber que pode analisar o codec AV1 por meio de um navegador (os interessados ‚Äã‚Äãpodem ir ao <a href="http://aomanalyzer.org/">aomanalyzer.org</a> ). <br><br><img src="https://habrastorage.org/webt/wa/zz/tv/wazztvoifpc4l11k2_8jzdmiffk.png" alt="imagem"><br><br><h3>  Codec universal </h3><br>  Vamos analisar os mecanismos b√°sicos subjacentes ao codec de v√≠deo universal.  A maioria desses conceitos √© √∫til e usada em codecs modernos, como <b>VP9</b> , <b>AV1</b> e <b>HEVC</b> .  Eu aviso que muitas coisas explicadas ser√£o simplificadas.  Exemplos do mundo real √†s vezes ser√£o usados ‚Äã‚Äã(como √© o caso do H.264) para demonstrar a tecnologia. <br><br><h3>  1¬∫ passo - dividir a imagem </h3><br>  O primeiro passo √© dividir o quadro em v√°rias se√ß√µes, subse√ß√µes e muito mais. <br><br><img width="420" height="238" src="https://habrastorage.org/webt/lo/ze/q1/lozeq18ppa9po16q2ykeiazibpk.png" alt="imagem"><br><br>  Para que?  Existem muitas raz√µes.  Quando dividimos a imagem, podemos prever com mais precis√£o o vetor de movimento usando pequenas se√ß√µes para pequenas partes m√≥veis.  Quanto a um plano de fundo est√°tico, voc√™ pode restringir-se a se√ß√µes maiores. <br><br>  Normalmente, os codecs organizam essas se√ß√µes em se√ß√µes (ou fragmentos), macroblocos (ou blocos de uma √°rvore de codifica√ß√£o) e muitas subse√ß√µes.  O tamanho m√°ximo dessas parti√ß√µes varia, o HEVC define 64x64, enquanto o AVC usa 16x16, e as subse√ß√µes podem ser divididas em 4x4. <br><br>  Lembre-se das variedades de quadros do √∫ltimo artigo ?!  O mesmo pode ser aplicado aos blocos, para que possamos ter um fragmento I, bloco B, macrobloco P, etc. <br><br>  Para aqueles que querem praticar, veja como a imagem ser√° dividida em se√ß√µes e subse√ß√µes.  Para fazer isso, voc√™ pode usar o <a href="https://software.intel.com/en-us/video-pro-analyzer">Intel Video Pro Analyzer</a> j√° mencionado no artigo anterior (o que √© pago, mas com uma vers√£o de avalia√ß√£o gratuita, que tem um limite nos 10 primeiros quadros).  As se√ß√µes do <b>VP9</b> s√£o analisadas aqui: <br><br><img width="711" height="370" src="https://habrastorage.org/webt/ub/n1/yh/ubn1yh-_d5n68swbd0bgc-lxbha.png" alt="imagem"><br><br><h3>  2¬∫ passo - previs√£o </h3><br>  Assim que tivermos se√ß√µes, podemos fazer previs√µes <s>astrol√≥gicas</s> sobre elas.  Para <b>a previs√£o INTER,</b> √© necess√°rio transferir <b>vetores de movimento</b> e o restante, e para a previs√£o INTRA, a <b>dire√ß√£o da previs√£o</b> e o restante s√£o transmitidos. <br><br><h3>  3¬∫ passo - convers√£o </h3><br>  Depois de obtermos o bloco residual (a se√ß√£o prevista ‚Üí a se√ß√£o real), √© poss√≠vel transform√°-lo de forma a saber quais pixels podem ser descartados, mantendo a qualidade geral.  Existem algumas transforma√ß√µes que fornecem comportamento preciso. <br><br>  Embora existam outros m√©todos, vamos considerar mais detalhadamente a <b>transforma√ß√£o discreta de cosseno</b> ( <b>DCT</b> - da <i>transforma√ß√£o discreta de cosseno</i> ).  Principais recursos do DCT: <br><br><ul><li>  Converte blocos de pixels em blocos de tamanho igual de coeficientes de frequ√™ncia. </li><li>  Sela a energia, ajudando a eliminar a redund√¢ncia espacial. </li><li>  Fornece reversibilidade. </li></ul><br>  2 de fevereiro de 2017 Sintra R.J.  (Cintra, RJ) e Bayer F.M.  (Bayer FM) publicou um artigo sobre convers√£o tipo DCT para compacta√ß√£o de imagem, exigindo apenas 14 adi√ß√µes. <br><br>  N√£o se preocupe se voc√™ n√£o entender os benef√≠cios de cada item.  Agora, com exemplos concretos, verificaremos seu valor real. <br><br>  Vamos pegar um bloco de 8x8 pixels como este: <br><br><img width="354" height="139" src="https://habrastorage.org/webt/tf/di/up/tfdiuplow4tut1aww2lrfydamyi.png" alt="imagem"><br><br>  Este bloco √© renderizado na seguinte imagem 8 por 8 pixels: <br><br><img width="362" height="380" src="https://habrastorage.org/webt/rq/gj/hj/rqgjhjuplvgdadziupv-ogpdazo.png" alt="imagem"><br><br>  Aplique o DCT a esse bloco de pixels e obtenha um bloco de coeficientes de tamanho 8x8: <br><br><img width="623" height="141" src="https://habrastorage.org/webt/3c/oh/i8/3cohi8vd2yjmxurbzrfhlabc_ni.png" alt="imagem"><br><br>  E se renderizarmos esse bloco de coeficientes, obteremos a seguinte imagem: <br><br><img width="401" height="328" src="https://habrastorage.org/webt/np/b0/v2/npb0v2_58_1hxinqekagzf6phzi.png" alt="imagem"><br><br>  Como voc√™ pode ver, isso n√£o √© como a imagem original.  Voc√™ pode perceber que o primeiro coeficiente √© muito diferente de todos os outros.  Esse primeiro coeficiente √© conhecido como coeficiente DC, representando todas as amostras na matriz de entrada, algo semelhante ao valor m√©dio. <br><br>  Esse bloco de coeficientes tem uma propriedade interessante: separa os componentes de alta frequ√™ncia dos de baixa frequ√™ncia. <br><br><img width="293" height="129" src="https://habrastorage.org/webt/n0/4u/1z/n04u1zqlixaeggiw_yfg3umocsy.jpeg" alt="imagem"><br><br>  Na imagem, a maior parte da energia est√° concentrada em frequ√™ncias mais baixas; portanto, se voc√™ converter a imagem em seus componentes de frequ√™ncia e descartar os coeficientes de frequ√™ncia mais altos, poder√° reduzir a quantidade de dados necess√°rios para descrever a imagem sem sacrificar muito a qualidade da imagem. <blockquote>  Frequ√™ncia significa a rapidez com que o sinal muda. </blockquote>  Vamos tentar aplicar o conhecimento adquirido no exemplo de teste, convertendo a imagem original em sua frequ√™ncia (bloco de coeficientes) usando o DCT e descartando alguns dos coeficientes menos importantes. <br><br>  Primeiro, converta-o para o dom√≠nio da frequ√™ncia. <br><br><img width="623" height="141" src="https://habrastorage.org/webt/3c/oh/i8/3cohi8vd2yjmxurbzrfhlabc_ni.png" alt="imagem"><br><br>  Em seguida, descartamos parte (67%) dos coeficientes, principalmente o lado inferior direito. <br><br><img width="624" height="139" src="https://habrastorage.org/webt/h5/dq/ww/h5dqwwheilwuuasgm7xxijdxmt8.png" alt="imagem"><br><br>  Por fim, restauramos a imagem desse bloco de coeficientes descartados (lembre-se de que deve ser revers√≠vel) e comparamos com o original. <br><br><img src="https://habrastorage.org/webt/6j/c6/1z/6jc61zgpg5r-vxxh3j0dxjeatha.png" alt="imagem"><br><br>  Vemos que ela se assemelha √† imagem original, mas h√° muitas diferen√ßas em rela√ß√£o √† original.  Jogamos 67,1875% e ainda temos algo que se assemelha √† fonte original.  Voc√™ poderia deliberadamente descartar os coeficientes para obter uma imagem de qualidade ainda melhor, mas este √© o pr√≥ximo t√≥pico. <blockquote><h4>  Cada coeficiente √© gerado usando todos os pixels. </h4><br><br>  Importante: cada coeficiente n√£o √© exibido diretamente em um pixel, mas √© uma soma ponderada de todos os pixels.  Este gr√°fico incr√≠vel mostra como o primeiro e o segundo coeficientes s√£o calculados usando pesos exclusivos para cada √≠ndice. <br><br><img width="381" height="550" src="https://habrastorage.org/webt/ix/uv/hw/ixuvhwvqvclyzq6astn1d5vsaac.jpeg" alt="imagem"><br><br>  Voc√™ tamb√©m pode tentar visualizar o DCT observando imagens simples com base nele.  Por exemplo, aqui est√° o s√≠mbolo A gerado usando cada peso do coeficiente: <br><br><img width="241" height="81" src="https://habrastorage.org/webt/oq/ua/3t/oqua3tnacmh7nsucvodymeqzqa0.gif" alt="imagem"></blockquote><br><br><h3>  4¬∫ passo - quantiza√ß√£o </h3><br>  Depois de jogarmos alguns coeficientes na etapa anterior, na √∫ltima etapa (transforma√ß√£o), produzimos uma forma especial de quantiza√ß√£o.  Neste ponto, √© permitido perder informa√ß√µes.  Ou, mais simplesmente, quantizaremos os coeficientes para obter a compacta√ß√£o. <br><br>  Como um bloco de coeficientes pode ser quantizado?  Um dos m√©todos mais simples ser√° a quantiza√ß√£o uniforme; quando pegamos um bloco, dividimos por um valor (por 10) e arredondamos o que aconteceu. <br><br><img width="770" height="168" src="https://habrastorage.org/webt/i8/1a/os/i81aosymefwhnp0jboibq0dd_4i.png" alt="imagem"><br><br>  Podemos reverter esse bloco de coeficientes?  Sim, podemos multiplicar pelo mesmo valor pelo qual dividimos. <br><br><img width="770" height="168" src="https://habrastorage.org/webt/ys/vs/51/ysvs514v-u_hrteesekxdrkjp9c.png" alt="imagem"><br><br>  Essa abordagem n√£o √© a melhor, pois n√£o leva em considera√ß√£o a import√¢ncia de cada coeficiente.  Pode-se usar a matriz quantizadora em vez de um √∫nico valor, e essa matriz pode usar a propriedade DCT, quantizando a maior parte do canto inferior direito e uma minoria do canto superior esquerdo. <br><br><h3>  5 passo - codifica√ß√£o de entropia </h3><br>  Depois de quantizarmos os dados (blocos de imagens, fragmentos, quadros), ainda podemos compact√°-los sem perda.  Existem muitas maneiras algor√≠tmicas de compactar dados.  Vamos nos familiarizar brevemente com alguns deles, para uma compreens√£o mais profunda, voc√™ pode ler o livro ‚Äú <a href="https://www.amazon.com/Understanding-Compression-Data-Modern-Developers/dp/1491961538/">Entendendo a Compacta√ß√£o: Compacta√ß√£o de Dados para Desenvolvedores Modernos</a> ‚Äù (‚Äú <a href="https://www.amazon.com/Understanding-Compression-Data-Modern-Developers/dp/1491961538/">Entendendo a Compacta√ß√£o: Compacta√ß√£o de Dados para Desenvolvedores Modernos</a> ‚Äù). <br><br><h3>  Codifica√ß√£o de v√≠deo com VLC </h3><br>  Suponha que tenhamos um fluxo de caracteres: <b>a</b> , <b>e</b> , <b>r</b> e <b>t</b> .  A probabilidade (variando de 0 a 1) de quantas vezes cada s√≠mbolo ocorre no fluxo √© apresentada nesta tabela. <div class="scrollable-table"><table><tbody><tr><th></th><th>  a </th><th>  e </th><th>  r </th><th>  t </th></tr><tr><th>  Probabilidade </th><td align="center">  0,3 </td><td align="center">  0,3 </td><td align="center">  0,2 </td><td align="center">  0,2 </td></tr></tbody></table></div>  Podemos atribuir c√≥digos bin√°rios √∫nicos (de prefer√™ncia pequenos) aos c√≥digos mais prov√°veis ‚Äã‚Äãe maiores, menos prov√°veis. <div class="scrollable-table"><table><tbody><tr><th></th><th>  a </th><th>  e </th><th>  r </th><th>  t </th></tr><tr><th>  Probabilidade </th><td align="center">  0,3 </td><td align="center">  0,3 </td><td align="center">  0,2 </td><td align="center">  0,2 </td></tr><tr><th>  C√≥digo bin√°rio </th><td align="center">  0 0 </td><td align="center">  10 </td><td align="center">  110 </td><td align="center">  1110 </td></tr></tbody></table></div>  Comprimimos o fluxo, assumindo que, no final, gastamos 8 bits para cada caractere.  Sem compress√£o em um personagem, seriam necess√°rios 24 bits.  Se cada caractere for substitu√≠do por seu c√≥digo, obteremos economia! <br><br>  O primeiro passo √© codificar o caractere <b>e</b> , que √© 10, e o segundo caractere √© <b>a</b> , que √© adicionado (n√£o matematicamente): [10] [0] e, finalmente, o terceiro caractere <b>t</b> , que torna nosso bitstream final comprimido igual [10] [0] [1110] ou <b>1001110</b> , que requer apenas 7 bits (3,4 vezes menos espa√ßo que o original). <br><br>  Observe que cada c√≥digo deve ser um c√≥digo exclusivo com um prefixo.  <a href="https://en.wikipedia.org/wiki/Huffman_coding">O algoritmo de Huffman</a> ajudar√° a encontrar esses n√∫meros.  Embora esse m√©todo n√£o exista falhas, existem codecs de v√≠deo que ainda oferecem esse m√©todo algor√≠tmico para compacta√ß√£o. <br><br>  Tanto o codificador quanto o decodificador devem ter acesso √† tabela de s√≠mbolos com seus c√≥digos bin√°rios.  Portanto, tamb√©m √© necess√°rio enviar uma tabela na entrada. <br><br><h3>  Codifica√ß√£o aritm√©tica </h3><br>  Suponha que tenhamos um fluxo de caracteres: <b>a</b> , <b>e</b> , <b>r</b> , se sua probabilidade √© representada por esta tabela. <div class="scrollable-table"><table><tbody><tr><th></th><th>  a </th><th>  e </th><th>  r </th><th>  s </th><th>  t </th></tr><tr><th>  Probabilidade </th><td align="center">  0,3 </td><td align="center">  0,3 </td><td align="center">  0,15 </td><td align="center">  0,05 </td><td align="center">  0,2 </td></tr></tbody></table></div>  Com esta tabela, constru√≠mos intervalos contendo todos os caracteres poss√≠veis, classificados pelo maior n√∫mero. <br><br><img width="713" height="86" src="https://habrastorage.org/webt/v2/et/wv/v2etwv7gqr0imlymbanupu6k3fw.png" alt="imagem"><br><br>  Agora vamos codificar um fluxo de tr√™s caracteres: <b>comer</b> . <br><br>  Primeiro, selecione o primeiro caractere <b>e</b> , que est√° no sub-intervalo de 0,3 a 0,6 (n√£o incluindo).  Pegamos esse subintervalo e o dividimos novamente nas mesmas propor√ß√µes de antes, mas j√° para esse novo intervalo. <br><br><img width="731" height="86" src="https://habrastorage.org/webt/fv/ra/lx/fvralxpih4rt9d6zowmweah5r8m.png" alt="imagem"><br><br>  Vamos continuar a codificar nosso fluxo de <b>comer</b> .  Agora, pegamos o segundo caractere <b>a</b> , que est√° no novo subintervalo de 0,3 a 0,39, e depois pegamos nosso √∫ltimo caractere <b>te</b> , repetindo o mesmo processo novamente, obtemos a √∫ltima sub-banda de 0,354 a 0,372. <br><br><img width="735" height="388" src="https://habrastorage.org/webt/eh/bj/nz/ehbjnz3uckrkkfoei5bt2gqh1zk.png" alt="imagem"><br><br>  S√≥ precisamos selecionar um n√∫mero no √∫ltimo sub-intervalo de 0,354 a 0,372.  Vamos escolher 0,36 (mas voc√™ pode escolher qualquer outro n√∫mero neste sub-intervalo).  Somente com esse n√∫mero podemos restaurar nosso fluxo original.  √â como se estiv√©ssemos desenhando uma linha dentro de intervalos para codificar nosso fluxo. <br><br><img width="712" height="231" src="https://habrastorage.org/webt/a2/y2/ye/a2y2yerdhz8bied1n-4o8pqfiic.png" alt="imagem"><br><br>  A opera√ß√£o reversa (isto √©, <i>decodifica√ß√£o</i> ) √© igualmente simples: com nosso n√∫mero 0,36 e nosso intervalo inicial, podemos iniciar o mesmo processo.  Mas agora, usando esse n√∫mero, revelamos o fluxo codificado usando esse n√∫mero. <br><br>  Com o primeiro intervalo, notamos que nosso n√∫mero corresponde a uma fatia, portanto, esse √© o nosso primeiro caractere.  Agora, novamente, compartilhamos essa sub-banda, executando o mesmo processo de antes.  Aqui voc√™ pode ver que 0,36 corresponde ao caractere <b>a</b> e, ap√≥s repetir o processo, chegamos ao √∫ltimo caractere <b>t</b> (formando nosso fluxo original codificado <b>eat</b> ). <br><br>  Tanto o codificador quanto o decodificador devem ter uma tabela de probabilidades de s√≠mbolos; portanto, √© necess√°rio envi√°-lo nos dados de entrada. <br><br>  Muito elegante, n√£o √©?  Algu√©m que veio com essa solu√ß√£o foi muito esperto.  Alguns codecs de v√≠deo usam essa t√©cnica (ou, em qualquer caso, oferecem-na como uma op√ß√£o). <br><br>  A id√©ia √© comprimir um fluxo de bits quantificado sem perdas.  Certamente neste artigo n√£o h√° toneladas de detalhes, raz√µes, compromissos, etc.  Mas voc√™, se voc√™ √© um desenvolvedor, deve saber mais.  Novos codecs est√£o tentando usar algoritmos diferentes de codifica√ß√£o de entropia, como o <b>ANS</b> . <br><br><h3>  6 etapas - formato bitstream </h3><br>  Depois de fazer tudo isso, resta descompactar os quadros compactados no contexto das etapas executadas.  O decodificador deve ser informado explicitamente das decis√µes tomadas pelo codificador.  O decodificador deve receber todas as informa√ß√µes necess√°rias: profundidade de bits, espa√ßo de cores, resolu√ß√£o, informa√ß√µes sobre previs√µes (vetores de movimento, predi√ß√£o INTER direcional), perfil, n√≠vel, taxa de quadros, tipo de quadro, n√∫mero de quadros e muito mais. <br><br>  Vamos dar uma olhada no fluxo de bits <b>H.264</b> .  Nosso primeiro passo √© criar um fluxo de bits H.264 m√≠nimo (o FFmpeg, por padr√£o, adiciona todos os par√¢metros de codifica√ß√£o, como o <b>SEI NAL</b> - um pouco mais adiante, descobriremos o que √©).  Podemos fazer isso usando nosso pr√≥prio reposit√≥rio e o FFmpeg. <br><br> <code>./s/ffmpeg -i /files/i/minimal.png -pix_fmt yuv420p /files/v/minimal_yuv420.h264</code> <br> <br>  Este comando ir√° gerar um fluxo de bits <b>H.264</b> bruto com um quadro, resolu√ß√£o 64x64, com o espa√ßo de cores <b>YUV420</b> .  A imagem a seguir √© usada como moldura. <br><br><img width="64" height="64" src="https://habrastorage.org/webt/dk/94/2b/dk942bnujajisjouk6zpwy9p5i8.png" alt="imagem"><br><br><h3>  H.264 Bitstream </h3><br>  O <b>padr√£o AVC</b> ( <b>H.264</b> ) define que as informa√ß√µes ser√£o enviadas em quadros de macro (no entendimento da rede) chamados <b>NAL</b> (esse √© o n√≠vel de abstra√ß√£o da rede).  O principal objetivo do NAL √© fornecer uma apresenta√ß√£o de v√≠deo "amig√°vel √† rede".  Esse padr√£o deve funcionar em TVs (com base em fluxos), na Internet (com base em pacotes). <br><br><img width="484" height="41" src="https://habrastorage.org/webt/rd/8r/ag/rd8rag_9adq5fnhkh3bp1l84ljw.png" alt="imagem"><br><br>  H√° um marcador de sincroniza√ß√£o para definir os limites dos elementos NAL.  Cada marcador de sincroniza√ß√£o cont√©m o valor <nobr><b>0x00 0x00 0x01,</b></nobr> com exce√ß√£o do primeiro, que √© <nobr><b>0x00 0x00 0x00 0x01.</b></nobr>  Se executarmos o <b>hexdump</b> para o fluxo de bits H.264 gerado, identificaremos pelo menos tr√™s padr√µes NAL no in√≠cio do arquivo. <br><br><img width="451" height="250" src="https://habrastorage.org/webt/ow/vk/uj/owvkujuxd9qw-yft0b2tecxp3oq.png" alt="imagem"><br><br>  Como afirmado, o decodificador deve conhecer n√£o apenas os dados da imagem, mas tamb√©m os detalhes do v√≠deo, quadro, cor, par√¢metros usados ‚Äã‚Äãe muito mais.  O primeiro byte de cada NAL define sua categoria e tipo. <div class="scrollable-table"><table><tbody><tr><th>  Identificador de tipo NAL </th><th>  Descri√ß√£o do produto </th></tr><tr><td align="center">  0 0 </td><td>  Tipo desconhecido </td></tr><tr><td align="center">  1 </td><td>  Fragmento de imagem codificada sem IDR </td></tr><tr><td align="center">  2 </td><td>  Se√ß√£o de dados da fatia codificada <b>A</b> </td></tr><tr><td align="center">  3 </td><td>  Dados de fatia codificada Se√ß√£o <b>B</b> </td></tr><tr><td align="center">  4 </td><td>  Se√ß√£o de dados de fatia codificada em <b>C</b> </td></tr><tr><td align="center">  5 </td><td>  Fragmento IDR codificado de uma imagem IDR </td></tr><tr><td align="center">  6 </td><td>  Informa√ß√µes adicionais sobre a extens√£o SEI </td></tr><tr><td align="center">  7 </td><td>  Conjunto de par√¢metros de sequ√™ncia SPS </td></tr><tr><td align="center">  8 </td><td>  Conjunto de par√¢metros de imagem PPS </td></tr><tr><td align="center">  9 </td><td>  Delimitador de acesso </td></tr><tr><td align="center">  10 </td><td>  Fim da sequ√™ncia </td></tr><tr><td align="center">  11 </td><td>  Fim do fluxo </td></tr><tr><td align="center">  ... </td><td>  ... </td></tr></tbody></table></div>  Normalmente, o primeiro fluxo de bits NAL √© o <b>SPS</b> .  Esse tipo de NAL √© respons√°vel por relatar vari√°veis ‚Äã‚Äãde codifica√ß√£o comuns, como perfil, n√≠vel, resolu√ß√£o e muito mais. <br><br>  Se pularmos o primeiro token de sincroniza√ß√£o, podemos decodificar o primeiro byte para descobrir que tipo de NAL √© o primeiro. <br><br>  Por exemplo, o primeiro byte ap√≥s o marcador de sincroniza√ß√£o √© <i>01100111</i> , onde o primeiro bit ( <i>0</i> ) est√° no campo f <i>orbidden_zero_bit</i> .  Os pr√≥ximos 2 bits ( <i>11</i> ) nos dizem o campo <i>nal_ref_idc,</i> que indica se esse NAL √© um campo de refer√™ncia ou n√£o.  E os 5 bits restantes ( <i>00111</i> ) nos <i>informam o</i> campo <i>nal_unit_type;</i> nesse caso, √© o bloco SPS ( <i>7</i> ) NAL. <br><br>  O segundo byte ( <i>bin√°rio</i> = <i>01100100</i> , <i>hex</i> = <i>0x64</i> , <i>dec</i> = <i>100</i> ) no SPS NAL √© o campo <i>profile_idc,</i> que mostra o perfil que o codificador usou.  Nesse caso, um perfil alto limitado foi usado (isto √©, um perfil alto sem suporte para um segmento B bidirecional). <br><br><img src="https://habrastorage.org/webt/xo/zt/wl/xoztwl_amtveehtmceuijr3wdsm.png" alt="imagem"><br><br>  Se nos familiarizarmos com a especifica√ß√£o do fluxo de bits <b>H.264</b> para o SPS NAL, encontraremos muitos valores para o nome do par√¢metro, categoria e descri√ß√£o.  Por exemplo, vejamos os <i>campos pic_width_in_mbs_minus_1</i> e <i>pic_height_in_map_units_minus_1</i> . <div class="scrollable-table"><table><tbody><tr><th>  Nome do Par√¢metro </th><th>  Categoria </th><th>  Descri√ß√£o do produto </th></tr><tr><td>  pic_width_in_mbs_minus_1 </td><td align="center">  0 0 </td><td align="center">  ue (v) </td></tr><tr><td>  pic_height_in_map_units_minus_1 </td><td align="center">  0 0 </td><td align="center">  ue (v) </td></tr></tbody></table></div>  Se realizarmos algumas opera√ß√µes matem√°ticas com os valores desses campos, obteremos permiss√£o.  Voc√™ pode imaginar <nobr>1920 x 1080</nobr> usando <i>pic_width_in_mbs_minus_1</i> com um valor de <nobr>119 ((119 + 1) * macroblock_size = 120 * 16 = 1920)</nobr> .  Mais uma vez, economizando espa√ßo, em vez de codificar 1920, eles o fizeram com 119. <br><br>  Se continuarmos a verificar o v√≠deo criado em formato bin√°rio (por exemplo: <nobr><i>xxd -b -c 11 v / minimal_yuv420.h264</i></nobr> ), poderemos ir para o √∫ltimo NAL, que √© o pr√≥prio quadro. <br><br><img src="https://habrastorage.org/webt/fc/wt/ru/fcwtruw1ol7zkpc4osveloks_ri.png" alt="imagem"><br><br>  Aqui, vemos seus primeiros valores de 6 bytes: <i>01100101 10001000 10000100 00000000 00100001 11111111</i> .  Como se sabe que o primeiro byte indica o tipo de NAL, neste caso ( <i>00101</i> ), este √© um fragmento de IDR (5) e, em seguida, ser√° poss√≠vel estud√°-lo mais: <br><br><img width="604" height="458" src="https://habrastorage.org/webt/ip/67/gh/ip67gh7uuxizfnt_5oko5oowohk.png" alt="imagem"><br><br>  Usando as informa√ß√µes de especifica√ß√£o, ser√° poss√≠vel decodificar o tipo de fragmento ( <i>slice_type</i> ) e o n√∫mero do quadro ( <i>frame_num</i> ) entre outros campos importantes. <br><br>  Para obter os valores de alguns campos ( <i>ue</i> ( <i>v</i> ), <i>eu</i> ( <i>v</i> ), <i>se</i> ( <i>v</i> ) ou <i>te</i> ( <i>v</i> )), precisamos decodificar o fragmento usando um decodificador especial baseado no <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BA%25D1%2581%25D0%25BF%25D0%25BE%25D0%25BD%25D0%25B5%25D0%25BD%25D1%2586%25D0%25B8%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BA%25D0%25BE%25D0%25B4_%25D0%2593%25D0%25BE%25D0%25BB%25D0%25BE%25D0%25BC%25D0%25B1%25D0%25B0">c√≥digo exponencial de Golomb</a> .  Este m√©todo √© muito eficaz para codificar valores de vari√°veis, especialmente quando existem muitos valores padr√£o. <br><br>  Os valores <i>slice_type</i> e <i>frame_num</i> deste v√≠deo s√£o 7 (fragmento I) e 0 (primeiro quadro). <br><br>  O fluxo de bits pode ser considerado como um protocolo.  Se voc√™ quiser saber mais sobre o fluxo de bits, consulte a especifica√ß√£o <b>ITU H.264</b> .  Aqui est√° uma macro mostrando onde est√£o os dados da imagem ( <b>YUV</b> na forma compactada). <br><br><img src="https://habrastorage.org/webt/sh/ka/sf/shkasfvpn80vva4jfeoxk2be1pe.png" alt="imagem"><br><br>  Voc√™ pode explorar outros fluxos de bits, como <b>VP9</b> , <b>H.265</b> ( <b>HEVC</b> ) ou at√© mesmo nosso novo melhor fluxo de bits <b>AV1</b> .  Eles s√£o todos iguais?  N√£o, mas lidar com pelo menos um deles √© muito mais f√°cil de entender o resto. <blockquote><h4>  Quer praticar?  Explore o fluxo de bits H.264 </h4><br>  Voc√™ pode gerar v√≠deo de quadro √∫nico e usar o MediaInfo para examinar o fluxo de bits <b>H.264</b> .  De fato, nada impede que voc√™ veja o c√≥digo-fonte que analisa o fluxo de bits <b>H.264</b> ( <b>AVC</b> ). <br><br><img src="https://habrastorage.org/webt/b0/n5/7v/b0n57v_h_gb2l2m0evkrhkukr_s.png" alt="imagem"><br><br>  Para praticar, voc√™ pode usar o Intel Video Pro Analyzer (eu j√° disse que o programa √© pago, mas existe uma vers√£o de avalia√ß√£o gratuita com um limite de 10 quadros?). <br><br><img src="https://habrastorage.org/webt/l9/63/ni/l963nix2wqornscrgdpzechdjq8.png" alt="imagem"></blockquote><h3>  Revis√£o </h3><br>  Observe que muitos codecs modernos usam o mesmo modelo que acabaram de aprender.  Aqui, vamos dar uma olhada no diagrama de blocos do codec de v√≠deo <b>Thor</b> .  Ele cont√©m todas as etapas que tomamos.  O objetivo deste post √© que voc√™ entenda pelo menos melhor as inova√ß√µes e a documenta√ß√£o nessa √°rea. <br><br><img width="574" height="507" src="https://habrastorage.org/webt/7q/go/1s/7qgo1so0_mld4wglqvhan3ttwei.png" alt="imagem"><br><br>  Anteriormente, estimava-se que 139 GB de espa√ßo em disco seriam necess√°rios para armazenar um arquivo de v√≠deo com dura√ß√£o de uma hora com qualidade 720p e 30 fps.  Se voc√™ usar os m√©todos discutidos neste artigo (previs√µes internas e entre quadros, convers√£o, quantiza√ß√£o, codifica√ß√£o de entropia etc.), poder√° conseguir (assumindo que gastamos 0,031 bits por pixel), o v√≠deo √© de qualidade bastante satisfat√≥ria, o que ocupa apenas 367,82 MB, n√£o 139 GB de mem√≥ria. <br><br><h3>  Como o H.265 alcan√ßa uma taxa de compress√£o melhor que o H.264? </h3><br>  Agora que voc√™ sabe mais sobre como os codecs funcionam, √© mais f√°cil entender como os novos codecs podem fornecer uma resolu√ß√£o mais alta com menos bits. <br><br>  Ao comparar o <b>AVC</b> e o <b>HEVC</b> , voc√™ n√£o deve esquecer que quase sempre √© uma op√ß√£o entre uma carga de CPU mais alta e uma taxa de compacta√ß√£o. <br><br>  <b>O HEVC</b> tem mais op√ß√µes para se√ß√µes (e subse√ß√µes) que o <b>AVC</b> , mais instru√ß√µes para previs√£o interna, codifica√ß√£o de entropia aprimorada e muito mais.  Todas essas melhorias tornaram o <b>H.265</b> capaz de compactar 50% mais que o <b>H.264</b> . <br><br><img src="https://habrastorage.org/webt/m3/jj/x8/m3jjx88-ppzrakex1sjxlinwjx8.png" alt="imagem"><br><br><hr><br><h3>  Parte I: <a href="https://habr.com/ru/company/edison/blog/481418/">No√ß√µes b√°sicas de v√≠deo e imagem</a> </h3><br><br><hr><br> <a href="https://habr.com/ru/company/edison/blog/485460/"><img align="right" width="404" height="150" src="https://habrastorage.org/webt/2b/9i/gm/2b9igmgpbxunecpetjj6hhqsa9m.png"></a> <br clear="left"><h4>  Leia tamb√©m o blog <br>  Empresa EDISON: </h4><br>  <a href="https://habr.com/ru/company/edison/blog/485460/"><b>20 bibliotecas para</b></a> <a href="https://habr.com/ru/company/edison/blog/485460/"><b><br></b></a>  <a href="https://habr.com/ru/company/edison/blog/485460/"><b>aplica√ß√£o iOS espetacular</b></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt480430/">https://habr.com/ru/post/pt480430/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt480416/index.html">Matem√°tica gen√©rica n√£o segura em C #</a></li>
<li><a href="../pt480420/index.html">Entrevista com Matthew "Oki" O'Connor sobre aterosclerose e seu tratamento</a></li>
<li><a href="../pt480422/index.html">Guia de estilo do Google em C ++. Parte 1</a></li>
<li><a href="../pt480424/index.html">Guia de estilo do Google em C ++. Parte 9</a></li>
<li><a href="../pt480428/index.html">O m√©todo da taquigrafia mais simples. Alfabeto e fonte para ela.</a></li>
<li><a href="../pt480432/index.html">O problema do primeiro visualizador ou a dif√≠cil convers√£o de fluxos de v√≠deo WebRTC em HLS</a></li>
<li><a href="../pt480438/index.html">Eventos digitais em Moscou, de 16 a 22 de dezembro</a></li>
<li><a href="../pt480444/index.html">Detetive Habra: 24 horas a partir da vida de 24 publica√ß√µes</a></li>
<li><a href="../pt480446/index.html">Gravando o proxy reverso Grafana em Go</a></li>
<li><a href="../pt480452/index.html">OWASP Moscow Meetup # 9: Registros de desempenho</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>