<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♨️ 👈 🤰 Metode Generik dalam Karat: Bagaimana Exonum Bergeser dari Besi ke Actix-web 💆🏿 💪🏿 🚄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ekosistem Rust masih tumbuh. Akibatnya, perpustakaan baru dengan fungsionalitas yang ditingkatkan sering dirilis ke komunitas pengembang, sementara pe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Metode Generik dalam Karat: Bagaimana Exonum Bergeser dari Besi ke Actix-web</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/bitfury/blog/439258/">  Ekosistem Rust masih tumbuh.  Akibatnya, perpustakaan baru dengan fungsionalitas yang ditingkatkan sering dirilis ke komunitas pengembang, sementara perpustakaan yang lebih lama menjadi usang.  Ketika kami awalnya merancang Exonum, kami menggunakan kerangka kerja web Iron.  Dalam artikel ini, kami menjelaskan bagaimana kami porting kerangka kerja Exonum ke actix-web menggunakan pemrograman generik. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/tc/vv/ye/tcvvye1qopj5cqsfv3rxp9-_sly.png"></a> <a name="habracut"></a><br><br><h2>  Eksonum dengan zat besi </h2><br>  Dalam platform Exonum, kerangka besi digunakan tanpa abstraksi.  Kami memasang penangan untuk sumber daya tertentu dan memperoleh parameter permintaan dengan mem-parsing URL menggunakan metode tambahan;  hasilnya dikembalikan hanya dalam bentuk string. <br><br>  Prosesnya tampak (kurang-lebih) seperti berikut: <br><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_blocks_response</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, router: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Router) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> blocks = <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |req: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Request| -&gt; IronResult&lt;Response&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.required_param(req, <span class="hljs-string"><span class="hljs-string">"count"</span></span>)?; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> latest: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>&gt; = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.optional_param(req, <span class="hljs-string"><span class="hljs-string">"latest"</span></span>)?; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> skip_empty_blocks: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.optional_param(req, <span class="hljs-string"><span class="hljs-string">"skip_empty_blocks"</span></span>)? .unwrap_or(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> info = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.blocks(count, latest.map(Height), skip_empty_blocks)?; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.ok_response(&amp;::serde_json::to_value(info).unwrap()) }; router.get(<span class="hljs-string"><span class="hljs-string">"/v1/blocks"</span></span>, blocks, <span class="hljs-string"><span class="hljs-string">"blocks"</span></span>); }</code> </pre> <br>  Selain itu, kami menggunakan beberapa plugin middleware dalam bentuk header CORS.  Kami menggunakan mount untuk menggabungkan semua penangan menjadi satu API. <br><br><h2>  Keputusan Kami untuk Beralih dari Besi </h2><br>  Besi adalah perpustakaan yang bagus, dengan banyak plugin.  Namun, itu ditulis pada hari-hari ketika proyek seperti futures dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tokio</a> tidak ada. <br><br>  Arsitektur Besi melibatkan pemrosesan permintaan sinkron, yang dapat dengan mudah dipengaruhi oleh sejumlah besar koneksi yang terbuka secara bersamaan.  Agar skalabel, Iron harus menjadi asinkron, yang akan melibatkan pemikiran ulang dan penulisan ulang seluruh kerangka kerja.  Sebagai hasilnya, kami telah melihat perubahan bertahap dari penggunaan Besi oleh insinyur perangkat lunak. <br><br><h2>  Mengapa Kami Memilih Actix-Web </h2><br>  Actix-web adalah kerangka kerja populer yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berperingkat</a> tinggi pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tolok ukur TechEmpower</a> .  Ini memiliki komunitas pengembang aktif, tidak seperti Iron, dan memiliki API yang dirancang dengan baik dan implementasi berkualitas tinggi berdasarkan kerangka aktor actix.  Permintaan diproses secara tidak sinkron oleh kumpulan utas;  jika meminta pemrosesan panic, aktor secara otomatis dihidupkan ulang. <br><br>  Sebelumnya, muncul kekhawatiran bahwa actix-web berisi banyak kode tidak aman.  Namun, jumlah kode tidak aman berkurang secara signifikan ketika kerangka kerja itu ditulis ulang dalam bahasa pemrograman yang aman - Rust.  Insinyur Bitfury telah meninjau kode ini sendiri dan merasa percaya diri dalam stabilitas jangka panjangnya. <br><br>  Untuk kerangka kerja Exonum, beralih ke actix memecahkan masalah stabilitas operasi.  Kerangka kerja besi dapat gagal jika ada sejumlah besar koneksi.  Kami juga menemukan bahwa API actix-web lebih sederhana, lebih produktif, dan lebih menyatu.  Kami yakin bahwa pengguna dan pengembang akan lebih mudah menggunakan antarmuka pemrograman Exonum, yang sekarang dapat beroperasi lebih cepat berkat desain actix-web. <br><br><h2>  Apa Yang Kami Tuntut dari Kerangka Kerja Web </h2><br>  Selama proses ini kami menyadari bahwa penting bagi kami untuk tidak hanya mengubah kerangka kerja, tetapi juga untuk merancang arsitektur API baru yang independen dari kerangka kerja web tertentu.  Arsitektur seperti itu akan memungkinkan untuk membuat penangan, dengan sedikit atau tanpa keprihatinan tentang spesifik web, dan mentransfernya ke backend apa pun.  Konsepsi ini dapat diimplementasikan dengan menulis sebuah frontend yang akan menerapkan tipe dan sifat dasar. <br><br>  Untuk memahami seperti apa tampilan frontend ini, mari tentukan apa sebenarnya API HTTP itu: <br><br><ul><li>  Permintaan dibuat secara eksklusif oleh klien;  server hanya merespons mereka (server tidak memulai permintaan). </li><li>  Meminta membaca data atau mengubah data. </li><li>  Sebagai hasil dari pemrosesan permintaan, server mengembalikan respons, yang berisi data yang diperlukan, jika berhasil;  atau informasi tentang kesalahan, jika terjadi kegagalan. </li></ul><br>  Jika kita menganalisis semua lapisan abstraksi, ternyata setiap permintaan HTTP hanyalah panggilan fungsi: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span></span>(context: &amp;ServiceContext, query: Query) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;Response, ServiceError&gt;</code> </pre> <br>  Segala sesuatu yang lain dapat dianggap sebagai perpanjangan dari entitas dasar ini.  Jadi, untuk menjadi independen dari implementasi spesifik kerangka kerja web, kita perlu menulis penangan dengan gaya yang mirip dengan contoh di atas. <br><br><h2>  Ciri `Endpoint` untuk Pemrosesan Generik permintaan-HTTP </h2><br>  Pendekatan yang paling sederhana dan langsung adalah mendeklarasikan sifat `Endpoint`, yang menggambarkan implementasi permintaan spesifik: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// A trait describing GET request handlers. It should be possible to call each of the handlers from any freed // thread. This requirement imposes certain restrictions on the trait. Parameters and request results are // configured using associated types. trait Endpoint: Sync + Send + 'static { type Request: DeserializeOwned + 'static; type Response: Serialize + 'static; fn handle(&amp;self, context: &amp;Context, request: Self::Request) -&gt; Result&lt;Self::Response, io::Error&gt;; }</span></span></code> </pre> <br>  Sekarang kita perlu mengimplementasikan penangan ini dalam kerangka kerja tertentu.  Sebagai contoh, di actix-web terlihat seperti berikut: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// Response type in actix-web. Note that they are asynchronous, even though `Endpoint` assumes that // processing is synchronous. type FutureResponse = actix_web::FutureResponse&lt;HttpResponse, actix_web::Error&gt;; // A raw request handler for actix-web. This is what the framework ultimately works with. The handler // receives parameters from an arbitrary context, through which the request parameters are passed. type RawHandler = dyn Fn(HttpRequest&lt;Context&gt;) -&gt; FutureResponse + 'static + Send + Sync; // For convenience, let's put everything we need from the handler into a single structure. #[derive(Clone)] struct RequestHandler { /// The name of the resource. pub name: String, /// HTTP method. pub method: actix_web::http::Method, /// The raw handler. Note that it will be used from multiple threads. pub inner: Arc&lt;RawHandler&gt;, }</span></span></code> </pre> <br>  Kita dapat menggunakan struktur untuk melewatkan parameter permintaan melalui konteks.  Actix-web dapat secara otomatis deserialize parameter menggunakan serde.  Sebagai contoh, a = 15 &amp; b = hello deserialized ke dalam struktur seperti ini: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Deserialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleQuery</span></span></span></span> { a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }</code> </pre> <br>  Fungsi deserialisasi ini sangat sesuai dengan tipe Permintaan yang terkait dari sifat `Endpoint`. <br><br>  Selanjutnya, mari buat sebuah adaptor yang membungkus implementasi spesifik dari `Endpoint` ke dalam RequestHandler untuk actix-web.  Perhatikan fakta bahwa saat melakukannya, informasi tentang jenis Permintaan dan Respons menghilang.  Teknik ini disebut tipe erasure - mengubah pengiriman statis menjadi dinamis. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> RequestHandler { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_endpoint</span></span></span></span>&lt;E: Endpoint&gt;(name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, endpoint: E) -&gt; RequestHandler { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |request: HttpRequest&lt;Context&gt;| -&gt; FutureResponse { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = request.state(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> future = Query::from_request(&amp;request, &amp;()) .map(|query: Query&lt;E::Request&gt;| query.into_inner()) .and_then(|query| endpoint.handle(context, query).map_err(<span class="hljs-built_in"><span class="hljs-built_in">From</span></span>::from)) .and_then(|value| <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(HttpResponse::<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>().json(value))) .into_future(); <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(future) }; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { name: name.to_owned(), method: actix_web::http::Method::GET, inner: Arc::from(index) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Arc&lt;RawHandler&gt;, } } }</code> </pre> <br>  Pada tahap ini, cukup dengan menambahkan penangan untuk permintaan POST, karena kami telah menciptakan sifat yang independen dari detail implementasi.  Namun, kami menemukan bahwa solusi ini tidak cukup canggih. <br><br><h2>  Kekurangan dari Sifat `Endpoint` </h2><br>  Sejumlah besar kode bantu dihasilkan ketika pawang ditulis: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// A structure with the context of the handler. struct ElementCountEndpoint { elements: Rc&lt;RefCell&lt;Vec&lt;Something&gt;&gt;&gt;, } // Implementation of the `Endpoint` trait. impl Endpoint for ElementCountEndpoint { type Request = (); type Result = usize; fn handle(&amp;self, context: &amp;Context, _request: ()) -&gt; Result&lt;usize, io::Error&gt; { Ok(self.elements.borrow().len()) } } // Installation of the handler in the backend. let endpoint = ElementCountEndpoint::new(elements.clone()); let handler = RequestHandler::from_endpoint("/v1/element_count", endpoint); actix_backend.endpoint(handler);</span></span></code> </pre> <br>  Idealnya, kita harus mampu melewati penutupan sederhana sebagai seorang pawang, sehingga secara signifikan mengurangi jumlah kebisingan sintaksis. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> elements = elements.clone(); actix_backend.endpoint(<span class="hljs-string"><span class="hljs-string">"/v1/elements_count"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> || { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(elements.borrow().len()) });</code> </pre> <br>  Di bawah ini kita akan membahas bagaimana ini bisa dilakukan. <br><br><h2>  Perendaman Ringan ke Pemrograman Generik </h2><br>  Kita perlu menambahkan kemampuan untuk secara otomatis menghasilkan adaptor yang mengimplementasikan sifat `Endpoint` dengan tipe terkait yang benar.  Input hanya akan terdiri dari penutupan dengan penangan permintaan HTTP. <br><br>  Argumen dan hasil penutupan dapat memiliki tipe yang berbeda, jadi kami harus bekerja dengan metode kelebihan beban di sini.  Karat tidak mendukung kelebihan beban secara langsung tetapi memungkinkan untuk ditiru menggunakan sifat `Into` dan` From`. <br><br>  Selain itu, tipe nilai penutupan yang dikembalikan tidak harus cocok dengan nilai yang dikembalikan dari implementasi `Endpoint`.  Untuk memanipulasi tipe ini, itu harus diekstraksi dari tipe penutupan yang diterima. <br><br><h2>  Mengambil Jenis dari Karakter `Fn` </h2><br>  Di Rust, setiap penutupan memiliki tipe uniknya sendiri, yang tidak dapat secara eksplisit ditunjukkan dalam program.  Untuk manipulasi dengan penutupan, kami menggunakan sifat `Fn`.  Ciri tersebut berisi tanda tangan dari fungsi dengan jenis argumen dan nilai yang dikembalikan, namun, mengambil elemen-elemen ini secara terpisah tidak mudah dilakukan. <br><br>  Gagasan utamanya adalah menggunakan struktur bantu dari bentuk berikut: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// Simplified example of extracting types from an F closure: Fn(A) -&gt; B. struct SimpleExtractor&lt;A, B, F&gt; { // The original function. inner: F, _a: PhantomData&lt;A&gt;, _b: PhantomData&lt;B&gt;, }</span></span></code> </pre> <br>  Kita harus menggunakan PhantomData, karena Rust mengharuskan semua parameter generik ditunjukkan dalam definisi struktur.  Namun, tipe penutupan atau fungsi F itu sendiri bukan yang generik (meskipun menerapkan sifat `Fn` generik).  Parameter tipe A dan B tidak digunakan secara langsung. <br><br>  Pembatasan sistem tipe Rust inilah yang menghalangi kami untuk menerapkan strategi yang lebih sederhana dengan menerapkan sifat `Endpoint` secara langsung untuk penutupan: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;A, B, F&gt; Endpoint <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> F <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;Context, A) -&gt; B { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Request</span></span></span></span> = A; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span></span> = B; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, context: &amp;Context, request: A) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;B, io::Error&gt; { <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre> <br>  Dalam kasus di atas, kompiler mengembalikan kesalahan: <br><br><pre> <code class="rust hljs">error[E0207]: the <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parameter</span></span></span></span> `A` is not constrained by the <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">self</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">or</span></span></span></span> predicates --&gt; src/main.rs:<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">6</span></span> | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;A, B, F&gt; Endpoint <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> F <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;Context, A) -&gt; B { | ^ unconstrained <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parameter</span></span></span></span></code> </pre> <br>  Struktur bantu SimpleExtractor memungkinkan untuk mendeskripsikan konversi `Dari`.  Konversi ini memungkinkan kami untuk menyimpan fungsi apa pun dan mengekstraksi jenis argumennya: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;A, B, F&gt; <span class="hljs-built_in"><span class="hljs-built_in">From</span></span>&lt;F&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> SimpleExtractor&lt;A, B, F&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;Context, A) -&gt; B, A: DeserializeOwned, B: Serialize, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span></span>(inner: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { SimpleExtractor { inner, _a: PhantomData, _b: PhantomData, } } }</code> </pre> <br>  Kode berikut berhasil dikompilasi: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Deserialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Query</span></span></span></span> { a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }; <span class="hljs-comment"><span class="hljs-comment">// Verification of the ordinary structure. fn my_handler(_: &amp;Context, q: Query) -&gt; String { format!("{} has {} apples.", qb, qa) } let fn_extractor = SimpleExtractor::from(my_handler); // Verification of the closure. let c = 15; let my_closure = |_: &amp;Context, q: Query| -&gt; String { format!("{} has {} apples, but Alice has {}", qb, qa, c) }; let closure_extractor = SimpleExtractor::from(my_closure);</span></span></code> </pre> <br><h2>  Jenis Spesialisasi dan Penanda </h2><br>  Sekarang kita memiliki fungsi dengan tipe argumen parameter secara eksplisit, yang dapat digunakan sebagai ganti sifat `Endpoint`.  Misalnya, kita dapat dengan mudah mengimplementasikan konversi dari SimpleExtractor ke RequestHandler.  Meski begitu, ini bukan solusi lengkap.  Kita perlu entah bagaimana membedakan antara penangan untuk permintaan GET dan POST pada tingkat tipe (dan antara penangan sinkron dan asinkron).  Dalam tugas ini, jenis marker akan membantu kami. <br><br>  Pertama, mari kita menulis ulang SimpleExtractor sehingga dapat membedakan antara hasil sinkron dan asinkron.  Pada saat yang sama, kami akan menerapkan sifat `Dari` untuk masing-masing kasus.  Perhatikan bahwa sifat dapat diimplementasikan untuk varian spesifik dari struktur generik. <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// Generic handler for HTTP-requests. pub struct With&lt;Q, I, R, F&gt; { /// A specific handler function. pub handler: F, /// Structure type containing the parameters of the request. _query_type: PhantomData&lt;Q&gt;, /// Type of the request result. _item_type: PhantomData&lt;I&gt;, /// Type of the value returned by the handler. /// Note that this value can differ from the result of the request. _result_type: PhantomData&lt;R&gt;, } // Implementation of an ordinary synchronous returned value. impl&lt;Q, I, F&gt; From&lt;F&gt; for With&lt;Q, I, Result&lt;I&gt;, F&gt; where F: Fn(&amp;ServiceApiState, Q) -&gt; Result&lt;I&gt;, { fn from(handler: F) -&gt; Self { Self { handler, _query_type: PhantomData, _item_type: PhantomData, _result_type: PhantomData, } } } // Implementation of an asynchronous request handler. impl&lt;Q, I, F&gt; From&lt;F&gt; for With&lt;Q, I, FutureResult&lt;I&gt;, F&gt; where F: Fn(&amp;ServiceApiState, Q) -&gt; FutureResult&lt;I&gt;, { fn from(handler: F) -&gt; Self { Self { handler, _query_type: PhantomData, _item_type: PhantomData, _result_type: PhantomData, } } }</span></span></code> </pre> <br>  Sekarang kita perlu mendeklarasikan struktur yang akan menggabungkan penangan permintaan dengan nama dan jenisnya: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Debug)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NamedWith</span></span></span></span>&lt;Q, I, R, F, K&gt; { <span class="hljs-comment"><span class="hljs-comment">/// The name of the handler. pub name: String, /// The handler with the extracted types. pub inner: With&lt;Q, I, R, F&gt;, /// The type of the handler. _kind: PhantomData&lt;K&gt;, }</span></span></code> </pre> <br>  Selanjutnya, kami mendeklarasikan beberapa struktur kosong yang akan bertindak sebagai tipe marker.  Marker akan memungkinkan kita untuk menerapkan untuk masing-masing penangan kode mereka sendiri untuk mengubah penangan menjadi RequestHandler yang dijelaskan sebelumnya. <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// A handler that does not change the state of the service. In HTTP, GET-requests correspond to this // handler. pub struct Immutable; /// A handler that changes the state of the service. In HTTP, POST, PUT, UPDATE and other similar //requests correspond to this handler, but for the current case POST will suffice. pub struct Mutable;</span></span></code> </pre> <br>  Sekarang kita dapat mendefinisikan empat implementasi yang berbeda dari sifat `Dari` untuk semua kombinasi parameter template R dan K (nilai yang dikembalikan dari penangan dan jenis permintaan). <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// Implementation of a synchronous handler of GET requests. impl&lt;Q, I, F&gt; From&lt;NamedWith&lt;Q, I, Result&lt;I&gt;, F, Immutable&gt;&gt; for RequestHandler where F: Fn(&amp;ServiceApiState, Q) -&gt; Result&lt;I&gt; + 'static + Send + Sync + Clone, Q: DeserializeOwned + 'static, I: Serialize + 'static, { fn from(f: NamedWith&lt;Q, I, Result&lt;I&gt;, F, Immutable&gt;) -&gt; Self { let handler = f.inner.handler; let index = move |request: HttpRequest| -&gt; FutureResponse { let context = request.state(); let future = Query::from_request(&amp;request, &amp;()) .map(|query: Query&lt;Q&gt;| query.into_inner()) .and_then(|query| handler(context, query).map_err(From::from)) .and_then(|value| Ok(HttpResponse::Ok().json(value))) .into_future(); Box::new(future) }; Self { name: f.name, method: actix_web::http::Method::GET, inner: Arc::from(index) as Arc&lt;RawHandler&gt;, } } } // Implementation of a synchronous handler of POST requests. impl&lt;Q, I, F&gt; From&lt;NamedWith&lt;Q, I, Result&lt;I&gt;, F, Mutable&gt;&gt; for RequestHandler where F: Fn(&amp;ServiceApiState, Q) -&gt; Result&lt;I&gt; + 'static + Send + Sync + Clone, Q: DeserializeOwned + 'static, I: Serialize + 'static, { fn from(f: NamedWith&lt;Q, I, Result&lt;I&gt;, F, Mutable&gt;) -&gt; Self { let handler = f.inner.handler; let index = move |request: HttpRequest| -&gt; FutureResponse { let handler = handler.clone(); let context = request.state().clone(); request .json() .from_err() .and_then(move |query: Q| { handler(&amp;context, query) .map(|value| HttpResponse::Ok().json(value)) .map_err(From::from) }) .responder() }; Self { name: f.name, method: actix_web::http::Method::POST, inner: Arc::from(index) as Arc&lt;RawHandler&gt;, } } } // Implementation of an asynchronous handler of GET requests. impl&lt;Q, I, F&gt; From&lt;NamedWith&lt;Q, I, FutureResult&lt;I&gt;, F, Immutable&gt;&gt; for RequestHandler where F: Fn(&amp;ServiceApiState, Q) -&gt; FutureResult&lt;I&gt; + 'static + Clone + Send + Sync, Q: DeserializeOwned + 'static, I: Serialize + 'static, { fn from(f: NamedWith&lt;Q, I, FutureResult&lt;I&gt;, F, Immutable&gt;) -&gt; Self { let handler = f.inner.handler; let index = move |request: HttpRequest| -&gt; FutureResponse { let context = request.state().clone(); let handler = handler.clone(); Query::from_request(&amp;request, &amp;()) .map(move |query: Query&lt;Q&gt;| query.into_inner()) .into_future() .and_then(move |query| handler(&amp;context, query).map_err(From::from)) .map(|value| HttpResponse::Ok().json(value)) .responder() }; Self { name: f.name, method: actix_web::http::Method::GET, inner: Arc::from(index) as Arc&lt;RawHandler&gt;, } } } // Implementation of an asynchronous handler of POST requests. impl&lt;Q, I, F&gt; From&lt;NamedWith&lt;Q, I, FutureResult&lt;I&gt;, F, Mutable&gt;&gt; for RequestHandler where F: Fn(&amp;ServiceApiState, Q) -&gt; FutureResult&lt;I&gt; + 'static + Clone + Send + Sync, Q: DeserializeOwned + 'static, I: Serialize + 'static, { fn from(f: NamedWith&lt;Q, I, FutureResult&lt;I&gt;, F, Mutable&gt;) -&gt; Self { let handler = f.inner.handler; let index = move |request: HttpRequest| -&gt; FutureResponse { let handler = handler.clone(); let context = request.state().clone(); request .json() .from_err() .and_then(move |query: Q| { handler(&amp;context, query) .map(|value| HttpResponse::Ok().json(value)) .map_err(From::from) }) .responder() }; Self { name: f.name, method: actix_web::http::Method::POST, inner: Arc::from(index) as Arc&lt;RawHandler&gt;, } } }</span></span></code> </pre> <br><h2>  Fasad untuk backend </h2><br>  Langkah terakhir adalah untuk merancang fasad yang akan menerima penutupan dan menambahkannya ke dalam backend yang sesuai.  Dalam kasus yang diberikan, kami memiliki backend tunggal - actix-web.  Namun, ada potensi implementasi tambahan di balik fasad.  Misalnya: generator spesifikasi Swagger. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceApiScope</span></span></span></span> { actix_backend: actix::ApiBuilder, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> ServiceApiScope { <span class="hljs-comment"><span class="hljs-comment">/// This method adds an Immutable handler to all backends. pub fn endpoint&lt;Q, I, R, F, E&gt;(&amp;mut self, name: &amp;'static str, endpoint: E) -&gt; &amp;mut Self where // Here we list the typical restrictions which we have encountered earlier: Q: DeserializeOwned + 'static, I: Serialize + 'static, F: Fn(&amp;ServiceApiState, Q) -&gt; R + 'static + Clone, E: Into&lt;With&lt;Q, I, R, F&gt;&gt;, // Note that the list of restrictions includes the conversion from NamedWith into RequestHandler // we have implemented earlier. RequestHandler: From&lt;NamedWith&lt;Q, I, R, F, Immutable&gt;&gt;, { self.actix_backend.endpoint(name, endpoint); self } /// A similar method for Mutable handlers. pub fn endpoint_mut&lt;Q, I, R, F, E&gt;(&amp;mut self, name: &amp;'static str, endpoint: E) -&gt; &amp;mut Self where Q: DeserializeOwned + 'static, I: Serialize + 'static, F: Fn(&amp;ServiceApiState, Q) -&gt; R + 'static + Clone, E: Into&lt;With&lt;Q, I, R, F&gt;&gt;, RequestHandler: From&lt;NamedWith&lt;Q, I, R, F, Mutable&gt;&gt;, { self.actix_backend.endpoint_mut(name, endpoint); self }</span></span></code> </pre> <br>  Perhatikan bagaimana jenis parameter permintaan, jenis hasil permintaan, dan sinkronisasi / asinkron dari pawang diturunkan secara otomatis dari tanda tangannya.  Selain itu, kita perlu secara spesifik menentukan nama dan jenis permintaan. <br><br><h2>  Kerugian dari pendekatan </h2><br>  Pendekatan yang dijelaskan di atas, meskipun cukup efektif, memiliki kelemahan.  Secara khusus, <i>metode endpoint dan endpoint_mut harus mempertimbangkan kekhasan implementasi backend spesifik</i> .  Pembatasan ini mencegah kami menambahkan backend saat bepergian, meskipun fungsi ini jarang diperlukan. <br><br>  Masalah lain adalah bahwa <i>kita tidak dapat menentukan spesialisasi dari seorang pawang tanpa argumen tambahan</i> .  Dengan kata lain, jika kita menulis kode berikut, itu tidak akan dikompilasi karena bertentangan dengan implementasi generik yang ada: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;(), I, F&gt; <span class="hljs-built_in"><span class="hljs-built_in">From</span></span>&lt;F&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> With&lt;(), I, <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;I&gt;, F&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;ServiceApiState) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;I&gt;, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span></span>(handler: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { handler, _query_type: PhantomData, _item_type: PhantomData, _result_type: PhantomData, } } }</code> </pre> <br>  Akibatnya, permintaan yang tidak memiliki parameter apa pun harus tetap menerima string JSON null, yang dideserialisasi ke ().  Masalah ini dapat diselesaikan dengan spesialisasi dalam gaya C ++, tetapi untuk sekarang ini hanya tersedia dalam versi malam dari kompiler dan tidak jelas kapan akan menjadi fitur yang stabil. <br><br>  Demikian pula, <i>jenis nilai yang dikembalikan tidak dapat dikhususkan</i> .  Bahkan jika permintaan tidak menyiratkan tipe tertentu dari nilai yang dikembalikan, masih akan melewati JSON dengan nol. <br><br>  <i>Decoding kueri URL dalam permintaan GET juga membebankan beberapa pembatasan yang tidak jelas pada jenis parameter</i> , tetapi masalah ini lebih berkaitan dengan kekhasan implementasi serde-urlencoded. <br><br><h2>  Kesimpulan </h2><br>  Seperti yang dijelaskan di atas, kami telah mengimplementasikan API yang ditingkatkan, yang memungkinkan pembuatan handler yang sederhana dan jelas, tanpa perlu khawatir tentang spesifikasi web.  Penangan ini dapat bekerja dengan backend apa pun atau bahkan dengan beberapa backend secara bersamaan. <br><br><hr><br><ul><li>  Web: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bitfury.com</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Exonum.com</a> </li><li>  Media Sosial: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Facebook</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Twitter</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LinkedIn</a> </li><li>  R&amp;D: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penelitian dan White Paper</a> </li></ul><br><hr></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439258/">https://habr.com/ru/post/id439258/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439242/index.html">Sekitar Beta dalam 260 Hari: Bagaimana Kami Belajar Mendengarkan Pengguna</a></li>
<li><a href="../id439244/index.html">FAS sangat merekomendasikan pra-instal perangkat lunak Rusia pada telepon pintar dan laptop yang dijual di Federasi Rusia</a></li>
<li><a href="../id439248/index.html">Alan Kay: "Bisakah bangsa Romawi kuno membangun komputer?"</a></li>
<li><a href="../id439252/index.html">6 alasan untuk mengembangkan karir TI di Armenia</a></li>
<li><a href="../id439254/index.html">Segalanya untuk kita</a></li>
<li><a href="../id439260/index.html">Penulis The Witcher masih akan menerima kompensasi dari CD Projekt Red</a></li>
<li><a href="../id439262/index.html">Menyebarkan kode langsung ke wadah buruh pelabuhan. Atau bagaimana tidak menunda-nunda setelah setiap komit</a></li>
<li><a href="../id439264/index.html">Cara mengelola proyek teknis yang rumit tanpa mempekerjakan PM: Pengalaman DataLine</a></li>
<li><a href="../id439266/index.html">Pengalaman membuat game untuk Android sendiri dari awal dan bagaimana itu dikreditkan ke Google Play</a></li>
<li><a href="../id439268/index.html">Bagaimana VR, AR, dan pencetakan 3D bekerja bersama: Pengalaman Konsep VR</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>