<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§öüèΩ ü§¥üèª üåï Nullable Referenztypen in C # 8.0 und statische Analyse üôä üöå üë¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es ist kein Geheimnis, dass Microsoft schon seit einiger Zeit an der 8. Version der C # -Sprache arbeitet. Die neue Sprachversion (C # 8.0) ist bereit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nullable Referenztypen in C # 8.0 und statische Analyse</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/455234/"><p><img src="https://habrastorage.org/getpro/habr/post_images/523/17b/496/52317b4960a8b063bc7b6541e4e2666d.png" alt="Bild 9"></p><br>  Es ist kein Geheimnis, dass Microsoft schon seit einiger Zeit an der 8. Version der C # -Sprache arbeitet.  Die neue Sprachversion (C # 8.0) ist bereits in der aktuellen Version von Visual Studio 2019 verf√ºgbar, befindet sich jedoch noch in der Beta-Phase.  In dieser neuen Version werden einige Funktionen auf etwas nicht offensichtliche oder eher unerwartete Weise implementiert.  Nullable Referenztypen sind einer von ihnen.  Diese Funktion wird angek√ºndigt, um Null Reference Exceptions (NRE) zu bek√§mpfen. <br><a name="habracut"></a><br>  Es ist gut zu sehen, wie sich die Sprache weiterentwickelt, und neue Funktionen zu erwerben, um Entwicklern zu helfen.  Zuf√§llig haben wir vor einiger Zeit die F√§higkeit des C # -Analysators von PVS-Studio, NREs zu erkennen, erheblich verbessert.  Und jetzt fragen wir uns, ob statische Analyseger√§te im Allgemeinen und PVS-Studio im Besonderen sich immer noch die M√ºhe machen sollten, potenzielle Null-Dereferenzen zu diagnostizieren, da solche Dereferenzen zumindest in neuem Code, der Nullable Reference verwendet, "unm√∂glich" werden.  Versuchen wir das zu kl√§ren. <br><br><h2>  Vor- und Nachteile der neuen Funktion </h2><br>  Eine Erinnerung, bevor wir fortfahren: In der neuesten Beta-Version von C # 8.0, die zum Zeitpunkt des Schreibens dieses Beitrags verf√ºgbar ist, sind nullf√§hige Referenztypen standardm√§√üig deaktiviert, dh das Verhalten der Referenztypen hat sich nicht ge√§ndert. <br><br>  Was sind also genau nullbare Referenztypen in C # 8.0, wenn wir diese Option aktivieren?  Es sind im Grunde die gleichen guten alten Referenztypen, au√üer dass Sie jetzt '?'  nach dem <i>Typnamen</i> (zum Beispiel <i>string?</i> ), √§hnlich wie <i>Nullable &lt;T&gt;</i> , d. <i>h.</i> nullable <i>Werttypen</i> (zum Beispiel <i>int?</i> ).  Ohne das '?' Wird unser <i>Zeichenfolgentyp</i> jetzt als nicht nullf√§hige Referenz interpretiert, d. H. Als Referenztyp, dem keine <i>Null</i> zugewiesen werden kann. <br><br>  Die Nullreferenzausnahme ist eine der √§rgerlichsten Ausnahmen f√ºr Ihr Programm, da sie nicht viel √ºber die Quelle aussagt, insbesondere wenn die Ausl√∂semethode eine Reihe von Dereferenzierungsoperationen hintereinander enth√§lt.  Die M√∂glichkeit, die Zuweisung von Nullen zu einer Variablen eines Referenztyps zu verbieten, sieht cool aus. Was ist jedoch mit den F√§llen, in denen das √úbergeben einer <i>Null</i> an eine Methode von einer Ausf√ºhrungslogik abh√§ngt?  Anstelle von <i>null</i> k√∂nnten wir nat√ºrlich ein Literal, eine Konstante oder einfach einen "unm√∂glichen" Wert verwenden, der der Variablen logischerweise nirgendwo anders zugewiesen werden kann.  Dies birgt jedoch das Risiko, einen Absturz des Programms durch eine "stille", aber fehlerhafte Ausf√ºhrung zu ersetzen, was oft schlimmer ist, als sich dem Fehler sofort zu stellen. <br><br>  Was ist dann mit einer Ausnahme?  Eine sinnvolle Ausnahme, die an einem Ort ausgel√∂st wird, an dem ein <i>Fehler</i> aufgetreten ist, ist immer besser als ein <i>NRE</i> irgendwo oben oder unten im Stapel.  Aber es ist nur in Ihrem eigenen Projekt gut, wo Sie die Verbraucher korrigieren k√∂nnen, indem Sie einen <i>Try-Catch-</i> Block einf√ºgen, und es liegt allein in Ihrer Verantwortung.  Bei der Entwicklung einer Bibliothek mit (nicht) nullbaren Referenzen m√ºssen wir sicherstellen, dass eine bestimmte Methode immer einen Wert zur√ºckgibt.  Schlie√ülich ist es selbst in Ihrem eigenen Code nicht immer m√∂glich (oder zumindest einfach), die R√ºckgabe von <i>null</i> durch das Ausl√∂sen von Ausnahmen zu ersetzen (da dies m√∂glicherweise zu viel Code betrifft). <br><br>  Die Nullable-Referenz kann entweder auf globaler Projektebene durch Hinzuf√ºgen der <i>NullableContextOptions-</i> Eigenschaft mit dem Wert <i>enable</i> oder auf Dateiebene mithilfe der Pr√§prozessor-Direktive <i>aktiviert werden</i> : <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable string cantBeNull = string.Empty; string? canBeNull = null; cantBeNull = canBeNull!;</span></span></code> </pre> <br>  Durch die Nullable-Referenzfunktion werden Typen informativer.  Die Methodensignatur gibt Ihnen einen Hinweis auf ihr Verhalten: ob sie eine Nullpr√ºfung hat oder nicht, ob sie <i>null zur√ºckgeben kann</i> oder nicht.  Wenn Sie nun versuchen, eine nullf√§hige Referenzvariable zu verwenden, ohne sie zu √ºberpr√ºfen, gibt der Compiler eine Warnung aus. <br><br>  Dies ist sehr praktisch, wenn Sie Bibliotheken von Drittanbietern verwenden, erh√∂ht jedoch auch das Risiko, dass der Benutzer der Bibliothek irregef√ºhrt wird, da es immer noch m√∂glich ist, mit dem neuen nullverzeihenden Operator (!) Null zu √ºbergeben.  Das hei√üt, das Hinzuf√ºgen nur eines Ausrufezeichens kann alle weiteren Annahmen √ºber die Schnittstelle unter Verwendung solcher Variablen aufheben: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable String GetStr() { return _count &gt; 0 ? _str : null!; } String str = GetStr(); var len = str.Length;</span></span></code> </pre> <br>  Ja, Sie k√∂nnen argumentieren, dass dies eine schlechte Programmierung ist und niemand solchen Code wirklich schreiben w√ºrde, aber solange dies m√∂glicherweise m√∂glich ist, k√∂nnen Sie sich nicht sicher f√ºhlen, wenn Sie sich nur auf den Vertrag verlassen, der durch die Schnittstelle einer bestimmten Methode auferlegt wird ( sagen, dass es nicht <i>null zur√ºckgeben kann</i> ). <br><br>  √úbrigens k√∂nnten Sie den gleichen Code mit mehreren schreiben <i>!</i>  Operatoren, wie C # es Ihnen jetzt erlaubt (und dieser Code ist perfekt kompilierbar): <br><br><pre> <code class="cpp hljs">cantBeNull = canBeNull!!!!!!!;</code> </pre> <br>  Indem wir so schreiben, betonen wir sozusagen die Idee: "Schau, das kann <i>null sein</i> !!!"  (Wir in unserem Team nennen das "emotionale" Programmierung).  Tats√§chlich interpretiert der Compiler (aus Roslyn) beim Erstellen des Syntaxbaums das <i>!</i>  Operator auf die gleiche Weise, wie er regul√§re Klammern interpretiert, was bedeutet, dass Sie so viele schreiben k√∂nnen <i>!</i>  ist wie du willst - genau wie in Klammern.  Aber wenn Sie genug davon schreiben, k√∂nnen Sie den Compiler "niederschlagen".  M√∂glicherweise wird dies in der endg√ºltigen Version von C # 8.0 behoben. <br><br>  Ebenso k√∂nnen Sie die Compiler-Warnung umgehen, wenn Sie ohne √úberpr√ºfung auf eine nullf√§hige Referenzvariable zugreifen: <br><br><pre> <code class="cpp hljs">canBeNull!.ToString();</code> </pre> <br>  F√ºgen wir weitere Emotionen hinzu: <br><br><pre> <code class="cpp hljs">canBeNull!!!?.ToString();</code> </pre> <br>  Eine solche Syntax wird man in echtem Code allerdings kaum jemals sehen.  Durch Schreiben des <i>nullverzeihenden</i> Operators teilen wir dem Compiler mit: "Dieser Code ist in Ordnung, √ºberpr√ºfen Sie, ob er nicht ben√∂tigt wird."  Durch Hinzuf√ºgen des Elvis-Operators sagen wir: ‚ÄûOder vielleicht auch nicht;  Lass es uns f√ºr alle F√§lle √ºberpr√ºfen. ‚Äú <br><br>  Nun k√∂nnen Sie sich vern√ºnftigerweise fragen, warum Variablen mit nicht nullbaren Referenztypen immer noch so einfach <i>Null</i> zugewiesen werden kann, wenn das Konzept dieses Typs impliziert, dass solche Variablen nicht den Wert <i>Null haben k√∂nnen</i> .  Die Antwort ist, dass "unter der Haube" auf IL-Code-Ebene unser nicht nullbarer Referenztyp immer noch ... der gute alte "regul√§re" Referenztyp ist und die gesamte Nullf√§higkeitssyntax eigentlich nur eine Anmerkung f√ºr den integrierten Compiler ist Analysator (der unserer Meinung nach nicht ganz bequem zu bedienen ist, aber darauf werde ich sp√§ter n√§her eingehen).  Pers√∂nlich finden wir es nicht ‚Äûordentlich‚Äú, die neue Syntax einfach als Anmerkung f√ºr ein Drittanbieter-Tool (sogar in den Compiler integriert) aufzunehmen, da die Tatsache, dass dies nur eine Anmerkung ist, m√∂glicherweise √ºberhaupt nicht offensichtlich ist f√ºr den Programmierer, da diese Syntax der Syntax f√ºr nullf√§hige Strukturen sehr √§hnlich ist, jedoch auf v√∂llig andere Weise funktioniert. <br><br>  Zur√ºck zu anderen M√∂glichkeiten, nullbare Referenztypen zu brechen.  Zum Zeitpunkt des Schreibens dieses Artikels, wenn Sie eine L√∂sung haben, die aus mehreren Projekten besteht, √ºbergeben Sie eine Variable eines Referenztyps, z. B. <i>String,</i> von einer in einem Projekt deklarierten Methode an eine Methode in einem anderen Projekt mit dem <i>NullableContext</i> Der Compiler geht davon aus, dass es sich um einen nicht nullbaren String handelt, und der Compiler bleibt stumm.  Und das trotz der Unmengen von <i>[Nullable (1)] -</i> Attributen, die jedem Feld und jeder Methode im IL-Code hinzugef√ºgt wurden, wenn Nullable References aktiviert wurden <i>.</i>  Diese Attribute sollten √ºbrigens ber√ºcksichtigt werden, wenn Sie Reflection verwenden, um die Attribute zu verarbeiten, und davon ausgehen, dass der Code nur Ihre benutzerdefinierten Attribute enth√§lt. <br><br>  Eine solche Situation kann zus√§tzliche Probleme verursachen, wenn eine gro√üe Codebasis an den Nullable Reference-Stil angepasst wird.  Dieser Prozess wird wahrscheinlich eine Weile dauern, Projekt f√ºr Projekt.  Wenn Sie vorsichtig sind, k√∂nnen Sie die neue Funktion nat√ºrlich schrittweise integrieren. Wenn Sie jedoch bereits ein funktionierendes Projekt haben, sind √Ñnderungen daran gef√§hrlich und unerw√ºnscht (wenn es funktioniert, ber√ºhren Sie es nicht!).  Aus diesem Grund haben wir sichergestellt, dass Sie Ihren Quellcode nicht √§ndern oder markieren m√ºssen, um potenzielle <i>NREs</i> zu erkennen, wenn Sie den PVS-Studio-Analysator verwenden.  Um Standorte zu √ºberpr√ºfen, die eine <i>NullReferenceException ausl√∂sen</i> k√∂nnten, f√ºhren <i>Sie</i> einfach den Analysator aus und suchen Sie nach V3080-Warnungen.  Sie m√ºssen weder die Projekteigenschaften noch den Quellcode √§ndern.  Sie m√ºssen keine Anweisungen, Attribute oder Operatoren hinzuf√ºgen.  Legacy-Code muss nicht ge√§ndert werden. <br><br>  Beim Hinzuf√ºgen von Nullable Reference-Unterst√ºtzung zu PVS-Studio mussten wir entscheiden, ob der Analysator davon ausgehen sollte, dass Variablen von nicht nullbaren Referenztypen immer nicht null Werte haben.  Nachdem wir untersucht hatten, wie diese Garantie verletzt werden k√∂nnte, entschieden wir, dass PVS-Studio eine solche Annahme nicht treffen sollte.  Selbst wenn ein Projekt durchgehend nicht nullf√§hige Referenztypen verwendet, kann der Analysator diese Funktion erg√§nzen, indem er bestimmte Situationen erkennt, in denen solche Variablen den Wert <i>null haben k√∂nnen</i> . <br><br><h2>  Wie PVS-Studio nach Nullreferenzausnahmen sucht </h2><br>  Die Datenflussmechanismen im C # -Analysator von PVS-Studio verfolgen m√∂gliche Werte von Variablen w√§hrend des Analyseprozesses.  Dies umfasst auch die interprozedurale Analyse, dh das Aufsp√ºren m√∂glicher Werte, die von einer Methode und ihren verschachtelten Methoden zur√ºckgegeben werden, und so weiter.  Dar√ºber hinaus speichert PVS-Studio Variablen, denen ein <i>Nullwert</i> zugewiesen werden k√∂nnte.  Immer wenn eine solche Variable ohne Pr√ºfung dereferenziert wird, sei es im aktuell analysierten Code oder in einer in diesem Code aufgerufenen Methode, wird eine V3080-Warnung √ºber eine m√∂gliche Nullreferenzausnahme ausgegeben. <br><br>  Die Idee hinter dieser Diagnose ist, dass der Analysator nur dann w√ºtend wird, wenn er eine <i>Nullzuweisung</i> sieht.  Dies ist der Hauptunterschied zwischen dem Verhalten unserer Diagnose und dem des im Compiler integrierten Analysators, der nullf√§hige Referenztypen verarbeitet.  Der eingebaute Analysator zeigt auf jede Dereferenzierung einer nicht aktivierten nullbaren Referenzvariablen - vorausgesetzt, sie wurde nicht durch die Verwendung von <i>!</i>  Bediener oder auch nur eine komplizierte √úberpr√ºfung (es sollte jedoch beachtet werden, dass absolut jeder statische Analysator, wobei PVS-Studio hier keine Ausnahme darstellt, auf die eine oder andere Weise "irregef√ºhrt" werden kann, insbesondere wenn Sie dies beabsichtigen). <br><br>  PVS-Studio hingegen warnt Sie nur, wenn eine <i>Null angezeigt wird</i> (ob im lokalen Kontext oder im Kontext einer externen Methode).  Selbst wenn die Variable von einem nicht nullbaren Referenztyp ist, zeigt der Analysator weiter darauf, wenn dieser Variablen eine Nullzuweisung zugewiesen wird.  Wir glauben, dass dieser Ansatz angemessener (oder zumindest f√ºr den Benutzer bequemer) ist, da nicht der gesamte Code mit Nullpr√ºfungen "verschmiert" werden muss, um m√∂gliche Dereferenzen zu verfolgen. Schlie√ülich war diese Option bereits vor der Nullable-Referenz verf√ºgbar wurden zum Beispiel durch die Verwendung von Vertr√§gen eingef√ºhrt.  Dar√ºber hinaus kann der Analysator jetzt die nicht nullbaren Referenzvariablen selbst besser steuern.  Wenn eine solche Variable "fair" verwendet wird und niemals <i>null</i> zugewiesen wird, sagt PVS-Studio kein Wort.  Wenn die Variable <i>null</i> zugewiesen und dann ohne vorherige √úberpr√ºfung dereferenziert wird, gibt PVS-Studio eine V3080-Warnung aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable String GetStr() { return _count &gt; 0 ? _str : null!; } String str = GetStr(); var len = str.Length; &lt;== V3080: Possible null dereference. Consider inspecting </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'str'</span></span></span></span></code> </pre> <br>  Schauen wir uns nun einige Beispiele an, die zeigen, wie diese Diagnose durch den Code von Roslyn selbst ausgel√∂st wird.  Wir haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Projekt bereits</a> k√ºrzlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºberpr√ºft</a> , aber dieses Mal werden wir nur m√∂gliche Nullreferenzausnahmen untersuchen, die in den vorherigen Artikeln nicht erw√§hnt wurden.  Wir werden sehen, wie PVS-Studio potenzielle NREs erkennt und wie sie mithilfe der neuen Nullable Reference-Syntax behoben werden k√∂nnen. <br><br>  <i>V3080 [CWE-476] M√∂gliche Null-Dereferenzierung innerhalb der Methode.</i>  <i>√úberpr√ºfen Sie das zweite Argument: chainedTupleType.</i>  <i>Microsoft.CodeAnalysis.CSharp TupleTypeSymbol.cs 244</i> <br><br><pre> <code class="cpp hljs">NamedTypeSymbol chainedTupleType; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_underlyingType.Arity &lt; TupleTypeSymbol.RestPosition) { .... chainedTupleType = null; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Create(ConstructTupleUnderlyingType(firstTupleType, chainedTupleType, newElementTypes), elementNames: _elementNames);</code> </pre> <br>  Wie Sie sehen k√∂nnen, kann der Variablen <i>chainedTupleType</i> in einem der Ausf√ºhrungszweige der <i>Nullwert</i> zugewiesen werden.  Es wird dann an die <i>ConstructTupleUnderlyingType-</i> Methode √ºbergeben und dort nach einer <i>Debug.Assert-</i> Pr√ºfung verwendet.  Es ist ein sehr verbreitetes Muster in Roslyn, aber denken Sie daran, dass <i>Debug.Assert</i> in der Release-Version entfernt wurde.  Aus diesem Grund h√§lt der Analysator die Dereferenzierung innerhalb der <i>ConstructTupleUnderlyingType-</i> Methode immer noch f√ºr gef√§hrlich.  Hier ist der Hauptteil dieser Methode, bei der die Dereferenzierung stattfindet: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> NamedTypeSymbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConstructTupleUnderlyingType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( NamedTypeSymbol firstTupleType, NamedTypeSymbol chainedTupleTypeOpt, ImmutableArray&lt;TypeWithAnnotations&gt; elementTypes)</span></span></span><span class="hljs-function"> </span></span>{ Debug.Assert (chainedTupleTypeOpt is null == elementTypes.Length &lt; RestPosition); .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (loop &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... currentSymbol = chainedTupleTypeOpt.Construct(chainedTypes); loop--; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentSymbol; }</code> </pre> <br>  Es ist eigentlich umstritten, ob der Analysator solche Behauptungen ber√ºcksichtigen sollte (einige unserer Benutzer m√∂chten dies) - schlie√ülich ber√ºcksichtigt der Analysator Vertr√§ge von System.Diagnostics.Contracts.  Hier ist ein kleines Beispiel aus der Praxis aus unserer Erfahrung mit Roslyn in unserem eigenen Analyseger√§t.  W√§hrend wir k√ºrzlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Unterst√ºtzung der neuesten Version von Visual Studio hinzugef√ºgt haben</a> , haben wir Roslyn auch auf die 3. Version aktualisiert.  Danach st√ºrzte PVS-Studio auf bestimmten Code ab, auf dem es noch nie zuvor abgest√ºrzt war.  Der Absturz, begleitet von einer Nullreferenzausnahme, w√ºrde nicht in unserem Code, sondern im Code von Roslyn auftreten.  Das Debuggen ergab, dass das Codefragment, in dem Roslyn jetzt abst√ºrzte, <i>genau diese</i> Art von <i>Debug.Assert-</i> basierter <i>Nullpr√ºfung</i> mehrere Zeilen h√∂her <i>aufwies</i> - und diese Pr√ºfung hat offensichtlich nicht geholfen. <br><br>  Es ist ein grafisches Beispiel daf√ºr, wie Sie Probleme mit Nullable Reference bekommen k√∂nnen, da der Compiler <i>Debug.Assert</i> als zuverl√§ssige √úberpr√ºfung in jeder Konfiguration behandelt.  Wenn Sie also <i>#nullable enable</i> hinzuf√ºgen und das Argument <i>chainedTupleTypeOpt</i> als nullf√§hige Referenz markieren <i>, gibt</i> der Compiler keine Warnung zur Dereferenzierung innerhalb der <i>ConstructTupleUnderlyingType-</i> Methode aus. <br><br>  Fahren Sie mit anderen Beispielen f√ºr Warnungen von PVS-Studio fort. <br><br>  <i>V3080 M√∂gliche Null-Dereferenzierung.</i>  <i>Betrachten Sie die √úberpr√ºfung von 'effektivRuleset'.</i>  <i>RuleSet.cs 146</i> <br><br><pre> <code class="cpp hljs">var effectiveRuleset = ruleSet.GetEffectiveRuleSet(includedRulesetPaths); effectiveRuleset = effectiveRuleset.WithEffectiveAction(ruleSetInclude.Action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsStricterThan(effectiveRuleset.GeneralDiagnosticOption, ....)) effectiveGeneralOption = effectiveRuleset.GeneralDiagnosticOption;</code> </pre><br>  Diese Warnung besagt, dass der Aufruf der <i>WithEffectiveAction-</i> Methode m√∂glicherweise <i>null</i> <i>zur√ºckgibt</i> , w√§hrend der der Variablen <i>effektiveRuleset</i> zugewiesene R√ºckgabewert vor der Verwendung nicht √ºberpr√ºft wird ( <i>effektiveRuleset.GeneralDiagnosticOption</i> ).  Hier ist der Hauptteil der <i>WithEffectiveAction-</i> Methode: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RuleSet </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithEffectiveAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ReportDiagnostic action)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_includes.IsEmpty) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(....); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Suppress: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuleSet(....); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } }</code> </pre> <br>  Wenn Nullable Reference f√ºr die Methode <i>GetEffectiveRuleSet aktiviert ist</i> , erhalten wir zwei Stellen, an denen das Verhalten des Codes ge√§ndert werden muss.  Da die oben gezeigte Methode eine Ausnahme ausl√∂sen kann, ist es logisch anzunehmen, dass der Aufruf in einen <i>Try-Catch-</i> Block eingeschlossen ist, und es w√§re richtig, die Methode neu zu schreiben, um eine Ausnahme auszul√∂sen, anstatt <i>null zur√ºckzugeben</i> .  Wenn Sie jedoch einige Anrufe zur√ºckverfolgen, werden Sie feststellen, dass der Fangcode zu weit oben ist, um die Konsequenzen zuverl√§ssig vorherzusagen.  <i>Werfen</i> wir einen Blick auf den Konsumenten der <i>effektivenRuleset-</i> Variablen, der <i>IsStricterThan-</i> Methode: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsStricterThan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ReportDiagnostic action1, ReportDiagnostic action2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action2) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Suppress: ....; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Warn: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action1 == ReportDiagnostic.Error; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Error: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  Wie Sie sehen k√∂nnen, handelt es sich um eine einfache switch-Anweisung, die zwischen zwei Aufz√§hlungen mit <i>ReportDiagnostic.Default</i> als Standardwert w√§hlt.  Schreiben Sie den Anruf am besten wie folgt um: <br><br>  Die Signatur von <i>WithEffectiveAction</i> √§ndert sich: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable public RuleSet? WithEffectiveAction(ReportDiagnostic action)</span></span></code> </pre> <br>  So sieht der Anruf aus: <br><br><pre> <code class="cpp hljs">RuleSet? effectiveRuleset = ruleSet.GetEffectiveRuleSet(includedRulesetPaths); effectiveRuleset = effectiveRuleset?.WithEffectiveAction(ruleSetInclude.Action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsStricterThan(effectiveRuleset?.GeneralDiagnosticOption ?? ReportDiagnostic.Default, effectiveGeneralOption)) effectiveGeneralOption = effectiveRuleset.GeneralDiagnosticOption;</code> </pre> <br>  Da <i>IsStricterThan</i> nur einen Vergleich durchf√ºhrt, kann die Bedingung neu geschrieben werden - zum Beispiel wie <i>folgt</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effectiveRuleset == null || IsStricterThan(effectiveRuleset.GeneralDiagnosticOption, effectiveGeneralOption))</code> </pre> <br>  N√§chstes Beispiel. <br><br>  <i>V3080 M√∂gliche Null-Dereferenzierung.</i>  <i>√úberpr√ºfen Sie 'propertySymbol'.</i>  <i>BinderFactory.BinderFactoryVisitor.cs 372</i> <br><br><pre> <code class="cpp hljs">var propertySymbol = GetPropertySymbol(parent, resultBinder); var accessor = propertySymbol.GetMethod; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)accessor != null) resultBinder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InMethodBinder(accessor, resultBinder);</code> </pre> <br>  Um diese Warnung zu beheben, m√ºssen wir sehen, was als n√§chstes mit der <i>Eigenschaft propertySymbol</i> passiert. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SourcePropertySymbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPropertySymbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( BasePropertyDeclarationSyntax basePropertyDeclarationSyntax, Binder outerBinder)</span></span></span><span class="hljs-function"> </span></span>{ .... NamedTypeSymbol container = GetContainerType(outerBinder, basePropertyDeclarationSyntax); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)container == null) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (SourcePropertySymbol)GetMemberSymbol(propertyName, basePropertyDeclarationSyntax.Span, container, SymbolKind.Property); }</code> </pre> <br>  Auch die <i>GetMemberSymbol-</i> Methode kann unter bestimmten Bedingungen <i>null zur√ºckgeben</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Symbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMemberSymbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> memberName, TextSpan memberSpan, NamedTypeSymbol container, SymbolKind kind)</span></span></span><span class="hljs-function"> </span></span>{ foreach (Symbol sym in container.GetMembers(memberName)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sym.Kind != kind) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sym.Kind == SymbolKind.Method) { .... var implementation = ((MethodSymbol)sym).PartialImplementationPart; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)implementation != null) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InSpan(implementation.Locations[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.syntaxTree, memberSpan)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> implementation; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InSpan(sym.Locations, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.syntaxTree, memberSpan)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sym; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; }</code> </pre> <br>  Wenn nullbare Referenztypen aktiviert sind, √§ndert sich der Aufruf wie folgt: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable SourcePropertySymbol? propertySymbol = GetPropertySymbol(parent, resultBinder); MethodSymbol? accessor = propertySymbol?.GetMethod; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((object)accessor != null) resultBinder = new InMethodBinder(accessor, resultBinder);</span></span></code> </pre> <br>  Es ist ziemlich einfach zu beheben, wenn Sie wissen, wo Sie suchen m√ºssen.  Die statische Analyse kann diesen potenziellen Fehler ohne Aufwand erfassen, indem alle m√∂glichen Werte des Felds aus allen Prozeduraufrufketten erfasst werden. <br><br>  <i>V3080 M√∂gliche Null-Dereferenzierung.</i>  <i>√úberpr√ºfen Sie 'simpleName'.</i>  <i>CSharpCommandLineParser.cs 1556</i> <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> simpleName; simpleName = PathUtilities.RemoveExtension( PathUtilities.GetFileName(sourceFiles.FirstOrDefault().Path)); outputFileName = simpleName + outputKind.GetDefaultExtension(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (simpleName.Length == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !outputKind.IsNetModule()) ....</code> </pre> <br>  Das Problem liegt in der Zeile mit der Pr√ºfung <i>simpleName.Length</i> .  Die Variable <i>simpleName</i> ergibt sich aus der Ausf√ºhrung einer langen Reihe von Methoden und kann <i>null</i> zugewiesen werden.  Wenn Sie neugierig sind, k√∂nnen Sie sich <i>√ºbrigens</i> die <i>RemoveExtension-</i> Methode <i>ansehen</i> , um zu sehen, wie sie sich von <i>Path.GetFileNameWithoutExtension unterscheidet.</i>  Eine <i>Pr√ºfung mit simpleName! = Null</i> w√ºrde ausreichen, aber bei nicht nullbaren Referenztypen √§ndert sich der Code wie folgt: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable public static string? RemoveExtension(string path) { .... } string simpleName;</span></span></code> </pre> <br>  So k√∂nnte der Anruf aussehen: <br><br><pre> <code class="cpp hljs">simpleName = PathUtilities.RemoveExtension( PathUtilities.GetFileName(sourceFiles.FirstOrDefault().Path)) ?? String.Empty;</code> </pre> <br><h2>  Fazit </h2><br>  Nullable Referenztypen k√∂nnen eine gro√üe Hilfe sein, wenn Sie die Architektur von Grund auf neu entwerfen. Die √úberarbeitung des vorhandenen Codes kann jedoch viel Zeit und Sorgfalt erfordern, da dies zu einer Reihe schwer fassbarer Fehler f√ºhren kann.  Dieser Artikel soll Sie nicht davon abhalten, nullf√§hige Referenztypen zu verwenden.  Wir finden diese neue Funktion im Allgemeinen n√ºtzlich, auch wenn die genaue Art und Weise ihrer Implementierung m√∂glicherweise umstritten ist. <br><br>  Denken Sie jedoch immer an die Einschr√§nkungen dieses Ansatzes und denken Sie daran, dass das Aktivieren des Nullable Reference-Modus Sie nicht vor NREs sch√ºtzt und dass es bei Missbrauch selbst zur Quelle dieser Fehler werden kann.  Wir empfehlen, dass Sie die Nullable Reference-Funktion durch ein modernes statisches Analysetool wie PVS-Studio erg√§nzen, das die interprozedurale Analyse unterst√ºtzt, um Ihr Programm vor NREs zu sch√ºtzen.  Jeder dieser Ans√§tze - tiefgreifende interprozedurale Analyse und Annotation von Methodensignaturen (was im Nullable Reference-Modus tats√§chlich der Fall ist) - hat seine Vor- und Nachteile.  Der Analysator stellt Ihnen eine Liste potenziell gef√§hrlicher Orte zur Verf√ºgung und zeigt Ihnen die Konsequenzen der √Ñnderung des vorhandenen Codes.  Wenn irgendwo eine Nullzuweisung vorliegt, zeigt der Analysator auf jeden Verbraucher der Variablen, wo sie ohne Pr√ºfung dereferenziert wird. <br><br>  Sie k√∂nnen dieses Projekt oder Ihre eigenen Projekte auf andere Fehler √ºberpr√ºfen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">laden Sie</a> einfach PVS-Studio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">herunter</a> und probieren Sie es aus. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455234/">https://habr.com/ru/post/de455234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455216/index.html">Doppler-Geschwindigkeitsmesser</a></li>
<li><a href="../de455218/index.html">√ñkosystemansatz zur Gesch√§ftstechnologie</a></li>
<li><a href="../de455224/index.html">Fingermusik: Spielen Sie alles mit Spheros SpecDrums</a></li>
<li><a href="../de455226/index.html">Warum einen angewandten Linguisten bewerben?</a></li>
<li><a href="../de455228/index.html">Derjenige, der Herzog Nukem auferweckt hat: Interview mit Randy Pitchford, Gearbox Wizard</a></li>
<li><a href="../de455236/index.html">Comodo widerruft Zertifikate ohne Grund</a></li>
<li><a href="../de455240/index.html">Verwenden der abgelehnten Fehlerrate zur Verbesserung der Fehlerberichterstattung</a></li>
<li><a href="../de455242/index.html">Weniger Ohren oder wie man den Sound im Spiel nicht von Anfang an verdirbt</a></li>
<li><a href="../de455244/index.html">Comic "L√∂ten ist einfach" in der aktualisierten Version (2019)</a></li>
<li><a href="../de455246/index.html">Die Registrierung f√ºr den Customer Experience Day in St. Petersburg ist am 20. Juni ge√∂ffnet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>