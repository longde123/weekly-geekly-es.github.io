<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ûüèº üë® üôéüèº G√©n√©ration d'ic√¥nes multi-plateformes multi-marques avec Sketch et un script Node.js - Partie # 2 ü•ù ü§∞üèæ üë®üèæ‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il s'agit de la deuxi√®me partie d'un article sur la cr√©ation d'un pipeline qui peut prendre un fichier Sketch et exporter toutes les ic√¥nes incluses d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>G√©n√©ration d'ic√¥nes multi-plateformes multi-marques avec Sketch et un script Node.js - Partie # 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/441042/"><img src="https://habrastorage.org/webt/na/kj/v5/nakjv5srowi99bsjteoqabwtoz8.png"><br><br>  Il s'agit de la deuxi√®me partie d'un article sur la cr√©ation d'un pipeline qui peut prendre un fichier Sketch et exporter toutes les ic√¥nes incluses dans le fichier, dans diff√©rents formats, pour diff√©rentes plates-formes, avec la possibilit√© de tester AB chaque ic√¥ne. <br><br>  Vous pouvez lire la premi√®re partie de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><img src="https://habrastorage.org/webt/s6/lt/2d/s6lt2dttycpvlqbolmyeyacaeas.png"><br><br>  Les fichiers Sketch, avec toutes les ic√¥nes collect√©es, stylis√©es et correctement nomm√©es, √©taient pr√™ts.  Il √©tait maintenant temps de commencer √† √©crire le code. <br><br>  Il suffit de dire que le processus a √©t√© un essai et une erreur: apr√®s l'important noyau de code initial, d√©velopp√© par mon chef d'√©quipe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nikhil Verma</a> (qui a d√©fini les bases du script), j'ai suivi un processus incr√©mentiel qui a n√©cessit√© au moins trois phases de refactoring. et pas mal de r√©visions.  Pour cette raison, je n'entrerai pas dans trop de d√©tails sur la fa√ßon dont le script a √©t√© d√©velopp√©, mais je me concentrerai plut√¥t sur la fa√ßon dont le script fonctionne aujourd'hui, dans sa forme finale. <br><a name="habracut"></a><br><h2>  Le script de construction </h2><br>  Le script de construction - √©crit dans Node.js - est relativement simple dans son flux: une fois les d√©pendances import√©es, a d√©clar√© la liste des fichiers Sketch √† traiter (comme une liste de marques, et pour chaque marque une liste de fichiers pour cette marque) et v√©rifi√© que Sketch est install√© sur le client, le script boucle sur le tableau des marques, et pour chacune d'entre elles, il ex√©cute ces √©tapes dans l'ordre: <br><br><ol><li>  Obtenez les jetons de conception pour la marque (nous avons besoin des valeurs de couleur) </li><li>  Clonez les fichiers Sketch associ√©s √† la marque, d√©compressez-les pour exposer les fichiers JSON internes et manipulez certaines des valeurs internes de ces fichiers JSON (plus d'informations √† ce sujet plus tard) </li><li>  Lire les m√©tadonn√©es pertinentes des fichiers Sketch JSON ( <i>document.json</i> , <i>meta.json</i> et <i>pages / pageUniqueID.json</i> );  en particulier nous avons besoin de la liste des styles partag√©s et de la liste des actifs / ic√¥nes contenus dans les fichiers </li><li>  Apr√®s quelques manipulations suppl√©mentaires des fichiers Sketch JSON, zippez-les en arri√®re et, √† l'aide des fichiers Sketch (clon√©s et mis √† jour), exportez et g√©n√©rez les fichiers de sortie finaux pour les trois plates-formes (iOS, Android, Web mobile) </li></ol><br>  Vous pouvez afficher les parties pertinentes du script de build principal ici: <br><br><pre><code class="plaintext hljs">// ... modules imports here const SKETCH_FILES = { badoo: ['icons_common'], blendr: ['icons_common', 'icons_blendr'], fiesta: ['icons_common', 'icons_fiesta'], hotornot: ['icons_common', 'icons_hotornot'], }; const SKETCH_FOLDER_PATH = path.resolve(__dirname, '../src/'); const SKETCH_TEMP_PATH = path.resolve(SKETCH_FOLDER_PATH, 'tmp'); const DESTINATION_PATH = path.resolve(__dirname, '../dist'); console.log('Build started...'); if (sketchtool.check()) { console.log(`Processing Sketch file via ${sketchtool.version()}`); build(); } else { console.info('You need Sketch installed to run this script'); process.exit(1); } // ---------------------------------------- function build() { // be sure to start with a blank slate del.sync([SKETCH_TEMP_PATH, DESTINATION_PATH]); // process all the brands declared in the list of Sketch files Object.keys(SKETCH_FILES).forEach(async (brand) =&gt; { // get the design tokens for the brand const brandTokens = getDesignTokens(brand); // prepare the Sketch files (unzipped) and get a list of them const sketchUnzipFolders = await prepareSketchFiles({ brand, sketchFileNames: SKETCH_FILES[brand], sketchFolder: SKETCH_FOLDER_PATH, sketchTempFolder: SKETCH_TEMP_PATH }); // get the Sketch metadata const sketchMetadata = getSketchMetadata(sketchUnzipFolders); const sketchDataSharedStyles = sketchMetadata.sharedStyles; const sketchDataAssets = sketchMetadata.assetsMetadata; generateAssetsPDF({ platform: 'ios', brand, brandTokens, sketchDataSharedStyles, sketchDataAssets }); generateAssetsSVGDynamicMobileWeb({ platform: 'mw', brand, brandTokens, sketchDataSharedStyles, sketchDataAssets }); generateAssetsVectorDrawableDynamicAndroid({ platform: 'android', brand, brandTokens, sketchDataSharedStyles, sketchDataAssets }); }); }</code> </pre> <br>  En fait, tout le code du pipeline est beaucoup plus complexe que cela, et la complexit√© r√©side dans les fonctions <b>prepareSketchFiles</b> , <b>getSketchMetadata</b> et <b>generateAssets [format] [platform]</b> .  Je vais essayer de les expliquer plus en d√©tail ci-dessous. <br><br><h2>  Pr√©paration des fichiers d'esquisse </h2><br>  La premi√®re √©tape du processus de construction est la pr√©paration des fichiers Sketch, afin qu'ils puissent √™tre utilis√©s ult√©rieurement pour l'exportation des actifs pour les diff√©rentes plates-formes. <br><br>  Les fichiers associ√©s √† la marque - pour Blendr, par exemple, les fichiers <i>icons_common.sketch</i> et <i>icons_blendr.sketch</i> - sont initialement clon√©s dans un dossier temporaire (plus pr√©cis√©ment, dans un sous-dossier nomm√© d'apr√®s la marque en cours de traitement) et d√©compress√©s. <br><br>  Ensuite, les fichiers JSON internes sont trait√©s, dans un pr√©fixe ajout√© aux actifs qui doivent subir des tests AB, de sorte que lorsqu'ils sont export√©s, ils seront enregistr√©s dans un sous-dossier avec un nom pr√©d√©fini (le nom unique de l'exp√©rience).  Pour comprendre quels actifs sont √† tester, nous v√©rifions simplement si le nom de la page dans laquelle ils sont stock√©s dans Sketch est pr√©fix√© avec <i>"XP_"</i> . <br><br><img src="https://habrastorage.org/webt/k7/qo/df/k7qodfiyytkacnk1uknx_6gxhzw.png"><br>  <i>Une comparaison des noms de calque, √† l'int√©rieur des fichiers Sketch, avant et apr√®s la mise √† jour.</i> <br><br>  Dans l'exemple ci-dessus, lors de l'exportation, les actifs seront enregistr√©s dans le sous-dossier <i>"this__is_an_experiment"</i> , avec un nom de fichier <i>"icon-name [variant-name] .ext"</i> . <br><br><h2>  Lecture des m√©tadonn√©es de l'esquisse </h2><br>  La deuxi√®me √©tape importante du processus consiste √† extraire toutes les m√©tadonn√©es pertinentes des fichiers Sketch, en particulier de leurs fichiers JSON internes.  Comme expliqu√© ci-dessus, ces fichiers sont les deux fichiers principaux ( <i>document.json</i> et <i>meta.json</i> ) et les fichiers de <i>pages</i> ( <i>pages / pageUniqueId.json</i> ). <br><br>  Le <i>fichier document.json</i> est utilis√© pour obtenir la liste des styles partag√©s, qui apparaissent sous la propri√©t√© d'objet <i>layerStyles</i> : <br><br><pre> <code class="plaintext hljs">{ "_class": "document", "do_objectID": "45D2DA82-B3F4-49D1-A886-9530678D71DC", "colorSpace": 1, ... "layerStyles": { "_class": "sharedStyleContainer", "objects": [ { "_class": "sharedStyle", "do_objectID": "9BC39AAD-CDE6-4698-8EA5-689C3C942DB4", "name": "features/feature-like", "value": { "_class": "style", "fills": [ { "_class": "fill", "isEnabled": true, "color": { "_class": "color", "alpha": 1, "blue": 0.10588235408067703, "green": 0.4000000059604645, "red": 1 }, "fillType": 0, "noiseIndex": 0, "noiseIntensity": 0, "patternFillType": 1, "patternTileScale": 1 } ], "blur": {...}, "startMarkerType": 0, "endMarkerType": 0, "miterLimit": 10, "windingRule": 1 } }, ...</code> </pre> <br>  Pour chaque style, nous stockons des informations de base dans un objet valeur-cl√©.  Cela sera utilis√© plus tard chaque fois que nous aurons besoin de r√©cup√©rer le nom d'un style en fonction de son ID unique (dans Sketch, la propri√©t√© <i>do_objectID</i> ): <br><br><pre> <code class="plaintext hljs">const parsedSharedStyles = {}; parsedDocument.layerStyles.objects.forEach((object) =&gt; { parsedSharedStyles[object.do_objectID] = { name: object.name, isFill: _.get(object, 'value.fills[0].color') !== undefined, isBorder: _.get(object, 'value.borders[0].color') !== undefined, }; });</code> </pre> <br><br>  √Ä ce stade, nous nous d√©pla√ßons sur le fichier <i>meta.json</i> pour obtenir la liste des pages, en particulier nous avons besoin de leur <i>identifiant unique</i> et de leur <i>nom</i> : <br><br><pre> <code class="plaintext hljs">{ "commit": "623a23f2c4848acdbb1a38c2689e571eb73eb823", "pagesAndArtboards": { "EE6BE8D9-9FAD-4976-B0D8-AB33D2B5DBB7": { "name": "Icons", "artboards": { "3275987C-CE1B-4369-B789-06366EDA4C98": { "name": "badge-feature-like" }, "C6992142-8439-45E7-A346-FC35FA01440F": { "name": "badge-feature-crush" }, ... "7F58A1C4-D624-40E3-A8C6-6AF15FD0C32D": { "name": "tabbar-livestream" } ... } }, "ACF82F4E-4B92-4BE1-A31C-DDEB2E54D761": { "name": "XP_this__is_an_experiment", "artboards": { "31A812E8-D960-499F-A10F-C2006DDAEB65": { "name": "this__is_an_experiment/tabbar-livestream[variant1]" }, "20F03053-ED77-486B-9770-32E6BA73A0B8": { "name": "this__is_an_experiment/tabbar-livestream[variant2]" }, "801E65A4-3CC6-411B-B097-B1DBD33EC6CC": { "name": "this__is_an_experiment/tabbar-livestream[control]" } } },</code> </pre> <br>  Ensuite, pour chaque page, nous lisons le fichier JSON correspondant sous le dossier des <i>pages</i> (comme d√©j√† dit, le nom du fichier est <i>[pageUniqueId] .json</i> ), et nous passons en revue les actifs contenus dans cette page (ils apparaissent sous forme de couches).  De cette fa√ßon, pour chaque ic√¥ne, nous obtenons son nom, sa largeur / hauteur, les m√©tadonn√©es Sketch pour cette ic√¥ne de couche, et si elle se trouve sur une page d'exp√©rience, le nom du test AB en question et le nom de la variante pour cette ic√¥ne. <br><br>  <i>Remarque</i> : l'objet "page.json" est tr√®s complexe, donc je ne vais pas y entrer ici.  Si vous √™tes curieux et que vous voulez voir √† quoi il ressemble, je vous sugg√®re de cr√©er un nouveau fichier Sketch vierge, d'y ajouter du contenu et de l'enregistrer;  puis renommez son extension en zip, d√©compressez-la et regardez dans l'un des fichiers qui apparaissent sous le dossier "pages". <br><br>  Lors du traitement des plans de travail, nous cr√©ons √©galement une liste d'exp√©riences (avec leurs actifs correspondants) qui seront utilis√©es ult√©rieurement pour d√©terminer quelles options d'ic√¥ne sont utilis√©es et pour quelle exp√©rience, en associant le nom des options d'ic√¥ne √† l'objet "base d'ic√¥nes". <br><br>  Pour chaque fichier Sketch en cours de traitement associ√© √† la marque, nous produisons un objet <i>assetsMetadata</i> qui ressemble √† ceci: <br><br><pre> <code class="plaintext hljs">{ "navigation-bar-edit": { "do_objectID": "86321895-37CE-4B3B-9AA6-6838BEDB0977", ...sketch_artboard_properties, "name": "navigation-bar-edit", "assetname": "navigation-bar-edit", "source": "icons_common", "width": 48, "height": 48 "layers": [ { "do_objectID": "A15FA03C-DEA6-4732-9F85-CA0412A57DF4", "name": "Path", ...sketch_layer_properties, "sharedStyleID": "6A3C0FEE-C8A3-4629-AC48-4FC6005796F5", "style": { ... "fills": [ { "_class": "fill", "isEnabled": true, "color": { "_class": "color", "alpha": 1, "blue": 0.8784313725490196, "green": 0.8784313725490196, "red": 0.8784313725490196 }, } ], "miterLimit": 10, "startMarkerType": 0, "windingRule": 1 }, }, ], ... }, "experiment-name/navigation-bar-edit[variant]": { "do_objectID": "00C0A829-D8ED-4E62-8346-E7EFBC04A7C7", ...sketch_artboard_properties, "name": "experiment-name/navigation-bar-edit[variant]", "assetname": "navigation-bar-edit", "source": "icons_common", "width": 48, "height": 48 ...</code> </pre> <br>  Comme vous pouvez le voir, la m√™me "ic√¥ne" (dans ce cas <i>-ci la barre de navigation-√©dition</i> ) peut √™tre associ√©e √† plusieurs "actifs", en terme d'exp√©riences.  Mais la m√™me ic√¥ne peut appara√Ætre avec le m√™me nom dans un deuxi√®me fichier Sketch associ√© √† la marque, et cela est tr√®s utile: c'est l'astuce que nous avons utilis√©e, pour compiler un ensemble commun d'ic√¥nes, puis d√©finir diff√©rentes variantes d'ic√¥nes sp√©cifiques en fonction de la marque. <br><br>  C'est pourquoi nous avons d√©clar√© les fichiers Sketch associ√©s √† chaque marque particuli√®re sous forme de tableau: <br><br><pre> <code class="plaintext hljs">const SKETCH_FILES = { badoo: ['icons_common'], blendr: ['icons_common', 'icons_blendr'], fiesta: ['icons_common', 'icons_fiesta'], hotornot: ['icons_common', 'icons_hotornot'], };</code> </pre> <br>  Parce que dans ce cas, l'ordre est important.  Et en fait, dans la fonction <i>getSketchMetadata</i> , appel√©e par le script de construction, nous ne <i>renvoyons</i> pas les objets <i>assetsMetadata</i> (un par fichier) sous forme de liste, mais faisons plut√¥t une fusion profonde de chaque objet, l'un dans l'autre, puis nous renvoyer un seul objet <i>assetsMetadata</i> fusionn√©. <br><br>  Ce n'est rien de plus que la fusion "logique" des fichiers Sketch et de leurs ressources en un seul fichier.  Mais la logique n'est pas aussi simple qu'il y para√Æt.  Voici le sch√©ma que nous avons d√ª cr√©er pour comprendre ce qui se passe quand il y a des ic√¥nes avec le m√™me nom (√©ventuellement sous test AB) dans diff√©rents fichiers associ√©s √† la m√™me marque: <br><br><img src="https://habrastorage.org/webt/yg/ug/-6/ygug-6xnds3cvysntithaenmbfw.png"><br>  <i>Le sch√©ma logique du fonctionnement de la "substitution" de la m√™me ic√¥ne, entre un ensemble commun / partag√© d'ic√¥nes et des ic√¥nes sp√©cialement con√ßues pour les √©tiquettes blanches (en consid√©rant √©galement le cas des tests AB)</i> <br><br><h2>  G√©n√©ration des fichiers finaux dans diff√©rents formats pour diff√©rentes plates-formes </h2><br>  La derni√®re √©tape du processus est la g√©n√©ration r√©elle des fichiers d'ic√¥nes avec diff√©rents formats pour les diff√©rentes plates-formes (PDF pour iOS, SVG / JSX pour Web et VectorDrawable pour Android). <br><br>  Comme vous pouvez le voir d'apr√®s le nombre de param√®tres transmis aux fonctions <i>generateAssets [format] [plateforme],</i> c'est la partie la plus complexe du pipeline.  C'est l√† que <b>le processus commence √† se diviser et √† diverger</b> pour les diff√©rentes plates-formes.  Voir ci-dessous le flux logique complet du script, et comment la partie li√©e √† la g√©n√©ration des actifs <b>se divise en trois flux similaires mais non identiques:</b> <br><br> <a href=""><img src="https://habrastorage.org/webt/jv/83/xy/jv83xyzcpvzmn4snh0xakkrfu8k.png"></a> <br><br>  Afin de g√©n√©rer les actifs finaux avec les couleurs correctes associ√©es √† la marque en cours de traitement, nous devons effectuer un autre ensemble de manipulations sur les fichiers JSON Sketch: nous effectuons une boucle it√©rative sur chaque calque auquel un style partag√© est appliqu√© et rempla√ßons le valeurs de couleur avec les couleurs des jetons de conception pour la marque. <br><br>  Pour la g√©n√©ration Android, une manipulation suppl√©mentaire est requise (plus d'informations √† ce sujet plus tard): nous changeons la propri√©t√© de r√®gle de remplissage de chaque couche de <i>pair-impair</i> √† <i>non nulle</i> (ceci est contr√¥l√© par la propri√©t√© "windingRule" dans l'objet JSON, o√π " 1 "signifie" pair-impair "et" 0 "signifie" non nul "). <br><br>  Une fois ces manipulations termin√©es, nous compressons √† nouveau les fichiers Sketch JSON dans un fichier Sketch standard, afin qu'il puisse √™tre trait√© pour exporter les actifs avec les propri√©t√©s mises √† jour (les fichiers clon√©s et mis √† jour sont des fichiers Sketch absolument normaux: ils peuvent √™tre ouverts dans Sketch , visualis√©, √©dit√©, enregistr√©, etc.). <br><br>  √Ä ce stade, nous pouvons utiliser sketchtool ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans un wrapper de n≈ìud</a> ) pour exporter automatiquement tous les actifs dans des formats sp√©cifiques pour des plates-formes sp√©cifiques.  Pour chaque fichier associ√© √† une marque (plus correctement, sa version clon√©e et mise √† jour) nous ex√©cutons cette commande: <br><br><pre> <code class="plaintext hljs">sketchtool.run(`export slices ${cloneSketchFile} --formats=svg &lt;i&gt;--scales=1 &lt;/i&gt;--output=${destinationFolder} --overwriting`);</code> </pre> <br>  Comme vous pouvez le deviner, cette commande exporte les actifs dans un format sp√©cifique, en appliquant une mise √† l'√©chelle facultative (pour l'instant, nous conservons toujours l'√©chelle d'origine) dans un dossier de destination.  L'option <i>--overwriting</i> est cl√© ici: de la m√™me mani√®re que nous faisons une "fusion profonde" des objets assetsMetadata (ce qui √©quivaut √† une "fusion logique" des fichiers Sketch), lorsque nous exportons, nous le faisons √† partir de plusieurs fichiers dans le m√™me dossier (unique par marque / plateforme).  Cela signifie que si un √©l√©ment - identifi√© par son nom de couche - existait d√©j√† dans un fichier Sketch pr√©c√©dent, il sera remplac√© par l'exportation suivante.  Ce qui, encore une fois, n'est rien d'autre qu'une op√©ration de ¬´fusion¬ª. <br><br>  Dans ce cas, cependant, nous pouvons avoir certains actifs qui sont des "fant√¥mes".  Cela se produit lorsqu'une ic√¥ne est test√©e AB dans un fichier, mais remplac√©e dans un fichier suivant.  Dans de tels cas, les fichiers de variantes sont export√©s dans le dossier de destination, r√©f√©renc√©s dans l'objet <i>assetsMetadata en</i> tant qu'actif (avec sa cl√© et ses propri√©t√©s), mais ne sont associ√©s √† aucun actif "de base" (en raison de la fusion profonde des objets <i>assetsMetadata</i> ).  Ces fichiers seront supprim√©s dans une √©tape ult√©rieure, avant la fin du processus. <br><br><hr><br>  Comme mentionn√© ci-dessus, nous avons besoin de diff√©rents formats finaux pour diff√©rentes plates-formes.  Pour iOS, nous voulons des fichiers PDF et nous pouvons les exporter directement avec la commande <i>sketchtool</i> .  Alors que pour Mobile Web, nous voulons des fichiers JSX et pour Android, nous voulons des fichiers VectorDrawable;  pour cette raison, nous exportons les actifs au format SVG dans un dossier interm√©diaire, puis nous les soumettons √† un traitement ult√©rieur. <br><br><h2>  Fichiers PDF pour iOS </h2><br>  Curieusement, PDF est le (seul?) Format pris en charge par Xcode et OS / iOS pour l'importation et le rendu d'actifs vectoriels ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voici une courte explication</a> des raisons techniques derri√®re ce choix d'Apple). <br><br>  Comme nous pouvons exporter directement en PDF via Sketchtool, il n'y a pas besoin d'√©tapes suppl√©mentaires pour cette plate-forme: nous enregistrons simplement les fichiers directement dans le dossier de destination, et c'est tout. <br><br><h2>  Fichiers React / JSX pour le Web </h2><br>  Dans le cas du Web, nous utilisons une biblioth√®que de n≈ìuds appel√©e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">svgr</a> qui convertit les fichiers SVG ordinaires en composants React.  Mais nous voulons faire quelque chose d'encore plus puissant: nous voulons "peindre dynamiquement" l'ic√¥ne lors de l'ex√©cution, avec les couleurs provenant des jetons de conception.  Pour cette raison, juste avant la conversion, nous rempla√ßons dans le SVG les valeurs de <i>remplissage</i> des chemins qui avaient √† l'origine un style partag√© appliqu√©, avec la valeur de jeton correspondante associ√©e √† ce style. <br><br>  Donc, s'il s'agit du fichier <i>badge-feature-like.svg</i> export√© depuis Sketch: <br><br><pre> <code class="plaintext hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;svg width="128px" height="128px" viewBox="0 0 128 128" version="1.1" xmlns="&lt;a href="http://www.w3.org/2000/svg"&gt;http://www.w3.org/2000/svg&lt;/a&gt;" xmlns:xlink="&lt;a href="http://www.w3.org/1999/xlink"&gt;http://www.w3.org/1999/xlink&lt;/a&gt;"&gt; &lt;!-- Generator: sketchtool 52.2 (67145) - &lt;a href="http://www.bohemiancoding.com/sketch"&gt;http://www.bohemiancoding.com/sketch&lt;/a&gt; --&gt; &lt;title&gt;badge-feature-like&lt;/title&gt; &lt;desc&gt;Created with sketchtool.&lt;/desc&gt; &lt;g id="Icons" fill="none" fill-rule="evenodd"&gt; &lt;g id="badge-feature-like"&gt; &lt;circle id="circle" fill="#E71032" cx="64" cy="64" r="64"&gt; &lt;path id="Shape" fill="#FFFFFF" d="M80.4061668,..."&gt;&lt;/path&gt; &lt;/g&gt; &lt;/g&gt; &lt;/svg&gt;</code> </pre> <br>  le dernier √©l√©ment / ic√¥ne de <i>badge-feature-like.js</i> ressemblera √† ceci: <br><br><pre> <code class="plaintext hljs">/* This file is generated automatically - DO NOT EDIT */ /* eslint-disable max-lines,max-len,camelcase */ const React = require('react'); module.exports = function badge_feature_like({ tokens }) { return ( &lt;svg data-origin="pipeline" viewBox="0 0 128 128"&gt; &lt;g fill="none" fillRule="evenodd"&gt; &lt;circle fill={tokens.TOKEN_COLOR_FEATURE_LIKED_YOU} cx={64} cy={64} r={64} /&gt; &lt;path fill="#FFF" d="M80.4061668,..." /&gt; &lt;/g&gt; &lt;/svg&gt; ); };</code> </pre> <br>  Comme vous pouvez le voir, nous avons remplac√© la valeur statique de la couleur de <i>remplissage</i> du cercle par une valeur dynamique qui prend sa valeur dans les jetons de conception (celles-ci seront mises √† la disposition du composant React <i>&lt;Icon /&gt;</i> via l'API Context, mais c'est une autre histoire). <br><br>  Ce remplacement est rendu possible gr√¢ce aux m√©tadonn√©es Sketch pour l'actif stock√© dans l'objet <i>Metadata des actifs</i> : en bouclant r√©cursivement √† travers les couches de l'actif, il est possible de cr√©er un s√©lecteur DOM (dans le cas ci-dessus, ce serait <i>#Icons # badge-feature- comme #circle</i> ) et l'utiliser pour trouver le n≈ìud dans l'arbre SVG, et remplacer la valeur de son attribut <i>fill</i> (pour cette op√©ration, nous utilisons la biblioth√®que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cheerio</a> ). <br><br><h2>  Fichiers vectoriels pour Android </h2><br>  Android prend en charge les graphiques vectoriels en utilisant son format vectoriel personnalis√©, appel√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">VectorDrawable</a> .  Habituellement, la conversion de SVG en VectorDrawable se fait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">directement dans Android Studio</a> par les d√©veloppeurs.  Mais ici, nous voulions automatiser l'ensemble du processus, nous devions donc trouver un moyen de les convertir via du code. <br><br>  Apr√®s avoir examin√© diff√©rentes biblioth√®ques et outils, nous avons d√©cid√© d'utiliser une biblioth√®que appel√©e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">svg2vectordrawable</a> .  Non seulement il est activement maintenu (au moins, meilleur que les autres que nous avons trouv√©s) mais il est √©galement plus complet. <br><br>  Le fait est que VectorDrawable n'est pas en parit√© de fonctionnalit√©s avec SVG: certaines des fonctionnalit√©s avanc√©es de SVG (par exemple les d√©grad√©s radiaux, les masques complexes, etc.) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ne</a> sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pas prises en charge</a> , et certaines n'ont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©t√© prises en</a> charge que r√©cemment (avec Android API 24 et sup√©rieur).  Un inconv√©nient est que dans Android pr√©-24, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la r√®gle de remplissage "pair-impair" n'est pas prise en charge</a> .  Mais chez Badoo, nous devons prendre en charge Android 5 et sup√©rieur.  C'est pourquoi, comme expliqu√© ci-dessus, pour Android, nous devons convertir chaque chemin des fichiers Sketch en un remplissage "non nul". <br><br>  Potentiellement, les concepteurs pourraient le faire manuellement: <br><br><img src="https://habrastorage.org/webt/oj/ec/bp/ojecbp2no3lxsas5uwxcqmobcji.png"><br><br>  mais cela pourrait facilement √™tre ignor√©, et donc √™tre sujet √† l'erreur humaine. <br><br>  Pour cette raison, nous avons ajout√© une √©tape suppl√©mentaire dans notre processus pour Android, o√π nous convertissons automatiquement tous les chemins en <i>non nul</i> dans le Sketch JSON.  C'est ainsi que lorsque nous exportons les ic√¥nes au format SVG, elles sont d√©j√† dans ce format, et chaque VectorDrawable g√©n√©r√© est √©galement compatible avec les appareils Android 5. <br><br>  Le fichier final <i>badge-feature-like.xml</i> dans ce cas ressemble √† ceci: <br><br><pre> <code class="plaintext hljs">&lt;!-- This file is generated automatically - DO NOT EDIT --&gt; &lt;vector xmlns:android="&lt;a href="http://schemas.android.com/apk/res/android"&gt;http://schemas.android.com/apk/res/android&lt;/a&gt;" android:width="128dp" android:height="128dp" android:viewportWidth="128" android:viewportHeight="128"&gt; &lt;path android:fillColor="?color_feature_liked_you" android:pathData="M64 1a63 63 0 1 0 0 126A63 63 0 1 0 64 1z" /&gt; &lt;path android:fillColor="#FFFFFF" android:pathData="M80.406 ..." /&gt; &lt;/vector&gt;</code> </pre> <br>  Comme vous pouvez le voir, √©galement dans les fichiers VectorDrawable, nous injectons des noms de variables pour les couleurs de <i>remplissage</i> , qui sont associ√©es aux jetons de conception via des styles personnalis√©s dans les applications Android. <br><br>  Voici √† quoi ressemble VectorDrawable une fois import√© dans Android Studio: <br><br> <a href=""><img src="https://habrastorage.org/webt/zu/n4/8q/zun48q0knfv8k9xy4amb6eqrxxa.png"></a> <br>  <i>Un exemple d'ic√¥ne VectorDrawable import√©e dans Android Studio</i> <br><br>  Une chose √† noter dans ce cas: Android Studio a une fa√ßon tr√®s stricte et normative d'organiser les actifs: pas de dossier imbriqu√© et tous les noms en minuscules!  Cela signifiait que nous devions trouver un format l√©g√®rement diff√©rent pour leurs noms d'ic√¥nes: dans le cas d'un actif en cours d'exp√©rimentation, son nom sera quelque chose comme <i>ic_icon-name__experiment-name__variant-name</i> . <br><br><h2>  Dictionnaire JSON comme biblioth√®que de ressources </h2><br>  Une fois que les fichiers de ressources sont enregistr√©s dans leur format final, la derni√®re chose qui reste √† faire est de sauvegarder toutes les m√©ta-informations collect√©es pendant le processus de construction, et de les stocker dans un "dictionnaire", afin qu'elles puissent √™tre mises √† disposition plus tard lorsque les actifs sont import√©s et consomm√©s par la base de code des diff√©rentes plateformes. <br><br>  Apr√®s avoir extrait la liste plate des ic√¥nes de l'objet <i>assetsMetadata</i> , nous la <i>parcourons</i> et pour chaque √©l√©ment, nous v√©rifions: <br><br><ul><li>  si c'est un atout normal (par exemple <i>tabbar-livestream</i> ), et si c'est le cas, nous le gardons simplement; </li><li>  s'il s'agit d'une variante dans un test AB (par exemple <i>experiment / tabbar-livestream [variant]</i> ), nous associons son nom, son chemin, le test AB et les noms de variantes, aux propri√©t√©s <i>abtests</i> de l'actif "de base" (dans ce cas, <i>tabbar- livestream</i> ), puis nous supprimons l'entr√©e de variante de la liste / objet (seul le "base" compte); </li><li>  s'il s'agit d'une variante "fant√¥me", nous supprimons le fichier, puis supprimons l'entr√©e de la liste / objet. </li></ul><br>  Une fois la boucle termin√©e, le dictionnaire contiendra la liste de toutes et uniquement les ic√¥nes "de base" (et leurs tests AB, si en cours d'exp√©rimentation).  Pour chacun d'eux, il contiendra son nom, sa taille, son chemin d'acc√®s et, dans le cas o√π une ic√¥ne est en cours de test AB, les informations sur les diff√©rentes options de l'actif. <br><br>  Ce dictionnaire est ensuite enregistr√© au format JSON dans le dossier de destination de la <i>marque</i> et de la <i>plateforme</i> .  Voici, par exemple, le fichier <i>assets.json</i> g√©n√©r√© pour l'application "Blendr" sur "web mobile": <br><br><pre> <code class="plaintext hljs">{ "platform": "mw", "brand": "blendr", "assets": { "badge-feature-like": { "assetname": "badge-feature-like", "path": "assets/badge-feature-like.jsx", "width": 64, "height": 64, "source": "icons_common" }, "navigation-bar-edit": { "assetname": "navigation-bar-edit", "path": "assets/navigation-bar-edit.jsx", "width": 48, "height": 48, "source": "icons_common" }, "tabbar-livestream": { "assetname": "tabbar-livestream", "path": "assets/tabbar-livestream.jsx", "width": 128, "height": 128, "source": "icons_blendr", "abtest": { "this__is_an_experiment": { "control": "assets/this__is_an_experiment/tabbar-livestream__control.jsx", "variant1": "assets/this__is_an_experiment/tabbar-livestream__variant1.jsx", "variant2": "assets/this__is_an_experiment/tabbar-livestream__variant2.jsx" }, "a_second-experiment": { "control": "assets/a_second-experiment/tabbar-livestream__control.jsx", "variantA": "assets/a_second-experiment/tabbar-livestream__variantA.jsx" } } }, ... } }</code> </pre> <br>  La toute derni√®re √©tape consiste √† compresser tous les dossiers de <i>ressources</i> dans.  fichiers <i>zip</i> , afin qu'ils puissent √™tre t√©l√©charg√©s plus facilement. <br><br><h2>  Le r√©sultat final </h2><br>  Le processus d√©crit ci-dessus - depuis le clonage et la manipulation initiaux des fichiers Sketch, jusqu'√† l'exportation (et la conversion) des actifs dans le format souhait√© pour chaque plate-forme prise en charge, jusqu'au stockage des m√©ta-informations collect√©es dans une biblioth√®que d'actifs - est r√©p√©t√© pour chaque marque d√©clar√©e dans le script de construction. <br><br>  Vous trouverez ci-dessous une capture d'√©cran de la structure des dossiers <i>src</i> et <i>dist</i> , une fois le processus de g√©n√©ration termin√©: <br><br><img src="https://habrastorage.org/webt/yg/nc/d9/ygncd9uupdngcnav-rmkrsq1dsg.png"><br>  <i>Structure des dossiers "src" et "dist" apr√®s la fin du processus de construction.</i> <br><br>  √Ä ce stade, avec une simple commande, il est possible de t√©l√©charger toutes les ressources (fichiers JSON, fichiers ZIP et fichiers d'actifs) dans un r√©f√©rentiel distant, et de les rendre disponibles pour toutes les diff√©rentes plates-formes, pour t√©l√©charger et consommer dans leurs bases de code. <br><br>  (La fa√ßon dont les plates-formes r√©elles r√©cup√®rent et traitent les actifs - via des scripts personnalis√©s qui ont √©t√© cr√©√©s ad hoc √† cet effet - d√©passe le cadre de cet article. Mais cela sera probablement couvert tr√®s bient√¥t dans d'autres articles de blog d√©di√©s, par l'un des d'autres d√©veloppeurs qui ont travaill√© avec moi sur ce projet). <br><br><h2>  Conclusions (et le√ßons apprises en cours de route) </h2><br>  J'ai toujours aim√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sketch</a> .  Pendant des ann√©es, il a √©t√© l'outil "de facto" de choix pour la conception (et le d√©veloppement) de sites Web et d'applications.  J'√©tais donc tr√®s int√©ress√© et curieux d'explorer des int√©grations possibles comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">html-sketchapp</a> ou des outils similaires, chapeau que nous pourrions utiliser dans nos workflows et pipelines. <br><br>  Ce flux (id√©al) a toujours √©t√© le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Saint-Graal pour moi</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">et bien d'autres</a> ): <br><br><img src="https://habrastorage.org/webt/kq/7l/n4/kq7ln4kr6txurb-mvh6brqbhnqe.png"><br><br>  Le croquis en tant qu'outil de conception peut √™tre imagin√© comme une "cible" possible de la base de code. <br><br>  Mais je dois admettre que j'ai r√©cemment commenc√© √† me demander si Sketch √©tait toujours le bon outil, en particulier dans le contexte d'un syst√®me de conception.  J'ai donc commenc√© √† explorer de nouveaux outils comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Figma</a> , avec ses API ouvertes, et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Framer X</a> , avec son incroyable int√©gration avec React, car je ne voyais pas d'efforts √©quivalents de Sketch pour progresser vers l'int√©gration avec du code (quel que soit le code). <br><br>  Eh bien, ce projet a chang√© d'avis.  Pas compl√®tement, mais certainement beaucoup. <br><br>  Peut-√™tre que Sketch n'expose pas officiellement ses API, mais la fa√ßon dont ils ont construit la structure interne de leurs fichiers est certainement une sorte d'API "non officielle".  Ils auraient pu utiliser des noms cryptiques ou masquer les cl√©s des objets JSON;  ils ont plut√¥t opt√© pour une convention de d√©nomination s√©mantique claire, facile √† lire et lisible par l'homme.  Je ne peux pas penser que c'est simplement accidentel. <br><br>  Le fait que les fichiers Sketch puissent √™tre manipul√©s m'a ouvert un large √©ventail de d√©veloppements et d'am√©liorations futurs possibles.  Des plugins pour valider la d√©nomination, le style et la structure des couches pour les ic√¥nes, aux int√©grations possibles avec notre wiki et la documentation de notre syst√®me de conception (dans les deux sens), en passant par la cr√©ation d'applications Node h√©berg√©es dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Electron</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Carlo</a> pour faciliter la plupart des t√¢ches r√©p√©titives que les concepteurs doivent entreprendre. <br><br>  Un bonus inattendu de ce projet (du moins pour moi) est que maintenant les fichiers Sketch avec les "ic√¥nes Cosmos" sont devenus une "source de v√©rit√©", tout comme ce qui s'est pass√© avec le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">syst√®me de conception Cosmos</a> .  Si une ic√¥ne n'est pas l√†, elle n'existe pas dans la base de code (ou mieux, elle ne devrait pas exister: mais au moins nous savons que c'est une exception).  Je sais que c'est plut√¥t √©vident maintenant, mais ce n'√©tait pas le cas auparavant, du moins pour moi. <br><br>  Ce qui a commenc√© comme un projet MVP est rapidement devenu une plong√©e profonde (litt√©ralement) dans les fichiers internes de Sketch, avec la r√©alisation que ceux-ci peuvent √™tre manipul√©s.  Nous ne savons pas encore o√π tout cela m√®nera, mais jusqu'√† pr√©sent, cela a √©t√© un succ√®s.  Les concepteurs, les d√©veloppeurs, les PM et les parties prenantes conviennent tous que cela va √©conomiser beaucoup de travail manuel pour tout le monde et √©viter beaucoup d'erreurs potentielles.  Mais cela ouvrira √©galement la porte √† des utilisations d'ic√¥nes jusqu'alors impossibles. <br><br>  Une derni√®re chose: ce que j'ai d√©crit dans ce long article est un pipeline que nous avons construit ici pour r√©soudre <i>nos</i> probl√®mes particuliers, et il est donc n√©cessairement super personnalis√© pour <i>notre</i> contexte.  Gardez √† l'esprit qu'il peut ne pas convenir √† <i>vos</i> besoins commerciaux ou √™tre adapt√© √† <i>votre</i> contexte. <br><br>  Mais ce qui est important pour moi, et ce que je voulais partager, c'est que cela peut √™tre fait.  Peut-√™tre de diff√©rentes mani√®res, avec diff√©rentes approches et diff√©rents formats de sortie, impliquant peut-√™tre moins de complexit√© (c'est-√†-dire: vous n'avez peut-√™tre pas besoin du multimarquage et des tests AB).  Mais maintenant, vous pouvez automatiser le flux de travail impliqu√© dans la livraison de vos ic√¥nes avec un script Node.js personnalis√© et Sketch. <br><br>  Trouvez votre propre fa√ßon de le faire.  C'est amusant (et relativement facile). <br><br><h2>  Cr√©dits </h2><br>  Cet √©norme projet a √©t√© d√©velopp√© en collaboration avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nikhil Verma</a> (Mobile Web), qui a cr√©√© la premi√®re version du script de construction, et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Artem Rudoi</a> (Android) et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Igor Savelev</a> (iOS), qui ont d√©velopp√© les scripts qui importent et consomment les actifs dans leur plates-formes natives respectives.  Merci, les amis, ce fut un plaisir de travailler avec vous sur ce projet et de le voir prendre vie. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr441042/">https://habr.com/ru/post/fr441042/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr441030/index.html">D√©tection des attaques Web avec un autoencodeur Seq2Seq</a></li>
<li><a href="../fr441032/index.html">KeeBee Cr√©er son propre clavier USB √† partir de z√©ro</a></li>
<li><a href="../fr441034/index.html">6 points de croissance de conversion ou comment augmenter la confiance en utilisant un t√©l√©phone sur le site</a></li>
<li><a href="../fr441036/index.html">Comment donner et recevoir des commentaires si vous √™tes moineau-sociophobus</a></li>
<li><a href="../fr441040/index.html">G√©n√©ration d'ic√¥nes multi-plateformes multi-marques avec Sketch et un script Node.js - Partie # 1</a></li>
<li><a href="../fr441044/index.html">L'histoire de la fa√ßon dont nous avons chang√© l'ic√¥ne PVS-Studio</a></li>
<li><a href="../fr441046/index.html">L'histoire de la fa√ßon dont nous avons chang√© l'ic√¥ne PVS-Studio</a></li>
<li><a href="../fr441048/index.html">Bureau pro agressif</a></li>
<li><a href="../fr441050/index.html">Fabriquer une cam√©ra thermique DIY bas√©e sur un Raspberry Pi</a></li>
<li><a href="../fr441052/index.html">16 mars Meetup Badoo PHP: Tests et qualit√© du code. L'inscription est ouverte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>