<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ˜Ÿ ğŸ›ï¸ âŒ¨ï¸ JavaScript sebagai perwujudan kejahatan ğŸ‘¨ğŸ¿â€ğŸ« ğŸŒ˜ ğŸ•¡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pengembang JavaScript sering mengeluh bahwa bahasa pemrograman mereka disalahkan secara tidak adil karena memiliki terlalu banyak fitur yang rumit dan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript sebagai perwujudan kejahatan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/417263/">  Pengembang JavaScript sering mengeluh bahwa bahasa pemrograman mereka disalahkan secara tidak adil karena memiliki terlalu banyak fitur yang rumit dan membingungkan.  Banyak yang berjuang dengan sikap ini terhadap JS, berbicara tentang mengapa mengkritik bahasa ini karena apa yang salah.  Penulis materi, terjemahan yang kami terbitkan hari ini, memutuskan untuk tidak membela JS, alih-alih beralih ke sisi gelap bahasa.  Namun, di sini ia tidak ingin berbicara, misalnya, tentang jebakan yang dibuat JavaScript untuk programmer yang tidak berpengalaman.  Dia tertarik pada pertanyaan tentang apa yang terjadi jika Anda mencoba mengkonfirmasi reputasi buruk bahasa dengan kode yang dapat ditulis oleh seseorang yang tidak peduli sama sekali tentang orang lain. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/fy/w2/lv/fyw2lvruoubpwmlwluamnw0ye-o.jpeg"></a> <br><br>  Dalam contoh bahan ini, banyak mekanisme bahasa akan digunakan.  Banyak yang Anda lihat di sini, omong-omong, bekerja dalam bahasa lain, jadi, dengan uji tuntas, Anda juga dapat menemukan sisi gelapnya.  Tetapi JavaScript, tentu saja, memiliki hadiah nyata untuk semua jenis intimidasi, dan sangat sulit untuk bersaing dengan bahasa lain di area ini.  Jika Anda menulis kode yang harus dikerjakan orang lain, JS memberi Anda banyak kesempatan untuk mengganggu, membingungkan, dan melecehkan serta menipu orang-orang ini.  Faktanya, di sini kita akan mempertimbangkan hanya sebagian kecil dari teknik-teknik tersebut. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Pengubah getter</font> </h2><br>  JavaScript mendukung getter - fungsi yang memungkinkan Anda bekerja dengan apa yang mereka kembalikan dengan properti biasa.  Dalam penggunaan normal, tampilannya seperti ini: <br><br><pre><code class="hljs pgsql">let greeter = {  <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Bob'</span></span>,  <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> hello() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> `Hello ${this.name}`} } console.log(greeter.hello) // Hello Bob greeter.name = <span class="hljs-string"><span class="hljs-string">'World'</span></span>; console.log(greeter.hello) // Hello World</code> </pre> <br>  Jika Anda menggunakan getter, merencanakan kejahatan, maka, misalnya, Anda dapat membuat objek yang dapat merusak diri sendiri: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj = {  foo: <span class="hljs-number"><span class="hljs-number">1</span></span>,  bar: <span class="hljs-number"><span class="hljs-number">2</span></span>,  baz: <span class="hljs-number"><span class="hljs-number">3</span></span>,  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">get</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evil</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keys = Object.keys(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(keys) {        delete <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[keys[<span class="hljs-number"><span class="hljs-number">0</span></span>]]     }     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Nothing to see here'</span></span>;  } }</code> </pre> <br>  Di sini, dengan setiap panggilan ke <code>obj.evil</code> , salah satu properti lain dari objek akan dihapus.  Pada saat yang sama, kode yang bekerja dengan <code>obj.evil</code> tidak akan tahu bahwa sesuatu yang sangat aneh terjadi tepat di bawah hidungnya.  Namun, ini hanya awal dari pembicaraan tentang efek samping berbahaya yang dapat dicapai menggunakan mekanisme JavaScript. <br><br><h2>  <font color="#3AC1EF">Proksi yang tidak terduga</font> </h2><br>  Getters itu hebat, tetapi sudah ada selama bertahun-tahun, banyak pengembang tahu tentang mereka.  Sekarang, berkat proxy, kami memiliki alat yang jauh lebih kuat untuk menghibur objek.  Proxy adalah fitur ES6 yang memungkinkan Anda membuat pembungkus di sekitar objek.  Dengan bantuan mereka, Anda dapat mengontrol apa yang terjadi ketika pengguna mencoba membaca atau menulis properti dari objek yang diproksikan.  Ini memungkinkan, misalnya, untuk membuat objek yang, dalam sepertiga upaya untuk mengakses kunci tertentu dari objek tersebut, akan mengembalikan nilai dengan kunci yang dipilih secara acak. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj = {<span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> handler = {   <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj, prop</span></span></span><span class="hljs-function">) </span></span>{     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() &gt; <span class="hljs-number"><span class="hljs-number">0.33</span></span>) {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj[prop];     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keys = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(obj);       <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key = keys[<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random()*keys.length)]       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj[key];     }   } }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> evilObj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(obj, handler); <span class="hljs-comment"><span class="hljs-comment">//          console.log(evilObj.a); // 1 console.log(evilObj.b); // 1 console.log(evilObj.c); // 3 console.log(evilObj.a); // 2 console.log(evilObj.b); // 2 console.log(evilObj.c); // 3</span></span></code> </pre> <br>  Sayangnya, kekejaman kami sebagian diungkapkan oleh alat pengembang yang mengidentifikasi <code>evilObj</code> sebagai objek bertipe <code>Proxy</code> .  Namun, konstruksi yang dijelaskan di atas, sebelum esensinya yang rendah terungkap, mampu memberikan banyak menit yang menyenangkan bagi mereka yang akan bekerja dengannya. <br><br><h2>  <font color="#3AC1EF">Fungsi menular</font> </h2><br>  Sejauh ini, kita telah berbicara tentang bagaimana objek dapat memodifikasi diri mereka sendiri.  Tetapi, di samping itu, kita dapat membuat fungsi yang tampak tidak bersalah yang menginfeksi objek yang diteruskan kepada mereka, mengubah perilaku mereka.  Sebagai contoh, misalkan kita memiliki fungsi <code>get()</code> sederhana yang memungkinkan Anda untuk mencari properti di objek yang diteruskan dengan aman, dengan mempertimbangkan fakta bahwa objek seperti itu mungkin tidak ada: <br><br><pre> <code class="hljs kotlin">let <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> = (obj, property, <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>) =&gt; {  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!obj) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;  }  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj[property]; }</code> </pre> <br>  Mudah untuk menulis ulang fungsi seperti itu sehingga menginfeksi objek yang ditransfer ke sana, sedikit mengubahnya.  Misalnya, Anda dapat membuat properti yang dibantu untuk mengaksesnya tidak lagi ditampilkan saat mencoba untuk mengulangi kunci objek: <br><br><pre> <code class="hljs pgsql">let <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> = (obj, property, defaultValue) =&gt; {  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!obj || !property <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> defaultValue;  }  let <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = obj[property];  <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> obj[property];  <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.defineProperty(obj, property, {     <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>,     enumerable: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>  })  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj[property]; } let x = {a: <span class="hljs-number"><span class="hljs-number">1</span></span>, b:<span class="hljs-number"><span class="hljs-number">2</span></span> }; console.log(<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.keys(x)); // [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>] console.log(<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(x, <span class="hljs-string"><span class="hljs-string">'a'</span></span>)); console.log(<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.keys(x)); // [<span class="hljs-string"><span class="hljs-string">'b'</span></span>]</code> </pre> <br>  Ini adalah contoh dari intervensi yang sangat halus dalam perilaku suatu objek.  Menghitung kunci dari suatu objek bukanlah operasi yang paling terlihat, karena itu tidak terlalu jarang, tetapi tidak terlalu sering digunakan.  Karena kesalahan yang dapat menyebabkan modifikasi objek tidak dapat dikaitkan dengan kode mereka, mereka dapat ada dalam proyek tertentu untuk beberapa waktu. <br><br><h2>  <font color="#3AC1EF">Kekacauan prototipe</font> </h2><br>  Kami membahas berbagai fitur JS di atas, termasuk beberapa yang cukup baru.  Namun, terkadang tidak ada yang lebih baik dari teknologi yang sudah teruji oleh waktu.  Salah satu fitur JS, yang paling banyak dikritik adalah kemampuan memodifikasi prototipe bawaan.  Fitur ini digunakan pada tahun-tahun awal JS untuk memperluas objek yang disematkan, seperti array.  Berikut cara memperluas kemampuan array standar dengan, katakanlah, menambahkan metode <code>contains</code> ke objek <code>Array</code> prototipe: <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.contains = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.indexOf(item) !== <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br>  Ternyata, jika Anda melakukan sesuatu seperti ini di perpustakaan yang benar-benar digunakan, itu dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengganggu</a> pekerjaan dengan mekanisme dasar bahasa di seluruh aplikasi yang menggunakan perpustakaan ini.  Oleh karena itu, dimasukkannya metode tambahan yang bermanfaat dalam prototipe objek standar dapat dianggap sebagai langkah yang sangat sukses bagi pengembang pasien yang ingin melakukan hal-hal buruk lainnya.  Namun, jika kita berbicara tentang sosiopat yang tidak sabar, mereka dapat ditawari sesuatu dengan cepat, tetapi tidak kalah menarik.  Modifikasi prototipe memiliki satu sifat yang sangat berguna, yang terdiri dari fakta bahwa modifikasi mempengaruhi semua kode yang dieksekusi di lingkungan tertentu, bahkan yang dimuat dari modul atau sedang ditutup.  Akibatnya, jika Anda merancang kode berikut dalam bentuk skrip pihak ketiga (misalnya, itu bisa berupa skrip dari jaringan iklan atau layanan analitik), maka seluruh situs yang menggunakan skrip ini akan rentan terhadap kesalahan kecil. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.map = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr2 = arr.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">acc, val, idx</span></span></span><span class="hljs-function">) =&gt;</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() &gt; <span class="hljs-number"><span class="hljs-number">0.95</span></span>) {        idx = idx + <span class="hljs-number"><span class="hljs-number">1</span></span>     }     <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = acc.length - <span class="hljs-number"><span class="hljs-number">1</span></span> === idx ? (idx - <span class="hljs-number"><span class="hljs-number">1</span></span> ) : idx     acc[index] = fn(val, index, arr);     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> acc;  },[]);  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr2; }</code> </pre> <br>  Di sini kita mendefinisikan kembali metode standar <code>Array.prototype.map</code> sehingga, secara umum, itu berfungsi dengan baik, tetapi dalam 5% kasus itu menukar dua elemen array.  Inilah yang bisa Anda dapatkan setelah beberapa panggilan ke metode ini: <br><br><pre> <code class="hljs powershell">let arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">14</span></span>,<span class="hljs-number"><span class="hljs-number">15</span></span>]; let square = x =&gt; x * x; console.log(arr.map(square)); // [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">25</span></span>,<span class="hljs-number"><span class="hljs-number">36</span></span>,<span class="hljs-number"><span class="hljs-number">49</span></span>,<span class="hljs-number"><span class="hljs-number">64</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span>,<span class="hljs-number"><span class="hljs-number">81</span></span>,<span class="hljs-number"><span class="hljs-number">121</span></span>,<span class="hljs-number"><span class="hljs-number">144</span></span>,<span class="hljs-number"><span class="hljs-number">169</span></span>,<span class="hljs-number"><span class="hljs-number">196</span></span>,<span class="hljs-number"><span class="hljs-number">225</span></span> <span class="hljs-type"><span class="hljs-type">console.log</span></span>(<span class="hljs-type"><span class="hljs-type">arr.map</span></span>(<span class="hljs-type"><span class="hljs-type">square</span></span>)); // [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">25</span></span>,<span class="hljs-number"><span class="hljs-number">36</span></span>,<span class="hljs-number"><span class="hljs-number">49</span></span>,<span class="hljs-number"><span class="hljs-number">64</span></span>,<span class="hljs-number"><span class="hljs-number">81</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span>,<span class="hljs-number"><span class="hljs-number">121</span></span>,<span class="hljs-number"><span class="hljs-number">144</span></span>,<span class="hljs-number"><span class="hljs-number">169</span></span>,<span class="hljs-number"><span class="hljs-number">196</span></span>,<span class="hljs-number"><span class="hljs-number">225</span></span>] <span class="hljs-type"><span class="hljs-type">console.log</span></span>(<span class="hljs-type"><span class="hljs-type">arr.map</span></span>(<span class="hljs-type"><span class="hljs-type">square</span></span>)); // [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">25</span></span>,<span class="hljs-number"><span class="hljs-number">36</span></span>,<span class="hljs-number"><span class="hljs-number">49</span></span>,<span class="hljs-number"><span class="hljs-number">64</span></span>,<span class="hljs-number"><span class="hljs-number">81</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span>,<span class="hljs-number"><span class="hljs-number">121</span></span>,<span class="hljs-number"><span class="hljs-number">144</span></span>,<span class="hljs-number"><span class="hljs-number">169</span></span>,<span class="hljs-number"><span class="hljs-number">196</span></span>,<span class="hljs-number"><span class="hljs-number">225</span></span>]</code> </pre> <br>  Di sini kami meluncurkannya tiga kali.  Apa yang terjadi ketika Anda pertama kali menggunakannya sedikit berbeda dari dua hasil memanggilnya berikut ini.  Ini adalah perubahan kecil, tidak selalu menyebabkan semacam kegagalan.  Dan bagian terbaiknya adalah bahwa tidak mungkin untuk memahami penyebab kesalahan yang jarang terjadi yang disebabkan oleh metode ini tanpa membaca kode sumbernya, yang merupakan penyebab kesalahan ini.  Fungsi kami tidak menarik perhatian saat bekerja dengan alat pengembang, tidak menghasilkan kesalahan saat bekerja dalam mode ketat.  Secara umum, dengan bantuan sesuatu seperti ini, sangat mungkin untuk membuat seseorang gila. <br><br><h2>  <font color="#3AC1EF">Nama yang rumit</font> </h2><br>  Entitas penamaan, seperti yang Anda tahu, adalah salah satu dari dua tugas paling sulit dalam ilmu komputer.  Oleh karena itu, nama-nama buruk diciptakan tidak hanya oleh mereka yang secara sadar berusaha untuk menyakiti orang lain.  Tentu saja, sulit untuk percaya pada pengguna Linux yang berpengalaman.  Mereka memiliki waktu bertahun-tahun untuk mengasosiasikan penyusup TI terburuk (Microsoft) dengan bentuk kejahatan terdalam.  Tetapi nama-nama yang tidak berhasil tidak secara langsung merusak program.  Kami tidak akan membicarakan hal-hal kecil seperti nama dan komentar yang menyesatkan yang kehilangan relevansinya.  Misalnya, tentang seperti: <br><br><pre> <code class="hljs pgsql">//   let arrayOfNumbers = { userid: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Darth Vader'</span></span>};</code> </pre> <br>  Untuk mempelajari ini dan memahami bahwa ada sesuatu yang salah dengan komentar dan dengan nama variabel, mereka yang membaca kode di mana ini terjadi harus melambat dan berpikir sedikit.  Tapi ini omong kosong.  Mari kita bicara tentang hal-hal yang sangat menarik.  Tahukah Anda bahwa sebagian besar karakter Unicode dapat digunakan untuk memberi nama variabel dalam JavaScript?  Jika Anda, dalam hal menetapkan nama variabel, adalah positif, maka Anda akan menyukai gagasan menggunakan nama dalam bentuk ikon ( <b>Habr cut emoji, meskipun dalam aslinya di sini setelah <code>let</code> adalah emoji kakahi</b> ): <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> = { postid: <span class="hljs-number"><span class="hljs-number">123</span></span>, postName: <span class="hljs-string"><span class="hljs-string">'Evil JavaScript'</span></span>}</code> </pre> <br>  Meskipun, kita berbicara tentang hal-hal buruk yang nyata di sini, jadi sebaiknya kita beralih ke karakter yang mirip dengan yang biasanya digunakan untuk memberi nama variabel, tetapi sebenarnya tidak.  Sebagai contoh, mari kita lakukan seperti ini: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> oï½‚j = {}; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj); <span class="hljs-comment"><span class="hljs-comment">// Error!</span></span></code> </pre> <br>  Huruf <code>ï½‚</code> dalam nama <code>oï½‚j</code> mungkin terlihat hampir normal, tetapi itu bukan huruf Latin kecil b.  Ini adalah apa yang disebut huruf latin dengan huruf besar dan lebar penuh b.  Simbol berbeda, sehingga siapa pun yang mencoba memasukkan nama variabel seperti itu secara manual kemungkinan besar akan sangat bingung. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Terlepas dari kisah berbagai hal buruk yang dapat dilakukan menggunakan JavaScript, materi ini ditujukan untuk memperingatkan programmer dari menggunakan trik seperti yang dijelaskan, dan menyampaikan kepada mereka fakta bahwa ini dapat menyebabkan kerusakan nyata.  Penulis materi mengatakan bahwa selalu berguna untuk mengetahui masalah apa yang dapat muncul dalam kode yang ditulis dengan buruk.  Dia percaya bahwa sesuatu yang serupa dapat ditemukan dalam proyek nyata, tetapi berharap ada di sana dalam bentuk yang kurang merusak.  Namun, fakta bahwa programmer yang menulis kode seperti itu tidak berusaha untuk menyakiti orang lain tidak membuatnya lebih mudah untuk bekerja dengan kode tersebut dan men-debug-nya.  Pada saat yang sama, pengetahuan tentang upaya berbahaya apa yang dapat dilakukan dapat memperluas wawasan seorang programmer dan membantunya menemukan sumber kesalahan serupa.  Tidak ada yang bisa sepenuhnya yakin bahwa tidak ada kesalahan dalam kode yang digunakannya.  Mungkin seseorang, mengetahui kecenderungan mereka untuk terlalu curiga, akan mencoba meyakinkan diri mereka sendiri bahwa kecemasan tentang kesalahan semacam itu hanyalah isapan jempol belaka dari imajinasinya.  Namun, ini tidak akan mencegah kesalahan seperti itu, mungkin dengan sengaja dimasukkan ke dalam beberapa kode, untuk membuktikan diri mereka sekali. <br><br>  <b>Pembaca yang budiman!</b>  Sudahkah Anda menemukan sesuatu yang mirip dengan yang dibahas dalam artikel ini? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/xh/-2/n8/xh-2n8h-0cldicbple6-6dque3c.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417263/">https://habr.com/ru/post/id417263/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417249/index.html">Kamar Audit AS memperingatkan: SpaceX dan Boeing sedang menunggu penundaan baru, gangguan AS dalam penerbangan ke ISS dimungkinkan</a></li>
<li><a href="../id417251/index.html">Menggunakan mata Ikan pada Raspberry Pi 3 dengan ROS - Bagian 1</a></li>
<li><a href="../id417255/index.html">Jam Cuckoo Berdasarkan Lego Mindstorms</a></li>
<li><a href="../id417257/index.html">C menunjuk sebagai paradoks linguistik</a></li>
<li><a href="../id417259/index.html">Acara digital di Moskow dari 16 Juli hingga 22 Juli</a></li>
<li><a href="../id417265/index.html">10 besar: laporan terbaik dari DotNext 2017 Moscow</a></li>
<li><a href="../id417269/index.html">Tempat mencari desainer: penghargaan internasional bergengsi</a></li>
<li><a href="../id417271/index.html">Bisakah seorang hacker memblokir Saluran Bahasa Inggris?</a></li>
<li><a href="../id417273/index.html">Realisasi panduan suara berdasarkan YandexSpeechKit</a></li>
<li><a href="../id417275/index.html">7 keterampilan desainer yang efektif. Alat pengembangan karir yang kuat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>