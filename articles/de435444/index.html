<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∂üèª üôãüèº üé™ Wir implementieren OSGI auf der Karaf-Plattform üì§ üòõ üî∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="OSGI ist nicht schwierig 
 Ich habe oft getroffen, dass OSGI schwierig ist. Und au√üerdem hatte er selbst einmal eine solche Meinung. Jahr 2009, um gen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir implementieren OSGI auf der Karaf-Plattform</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435444/"><h2>  OSGI ist nicht schwierig </h2><br>  Ich habe oft getroffen, dass OSGI schwierig ist.  Und au√üerdem hatte er selbst einmal eine solche Meinung.  Jahr 2009, um genau zu sein.  Zu dieser Zeit haben wir Projekte mit Maven Tycho gesammelt und f√ºr Equinox bereitgestellt.  Und es war wirklich schwieriger als das Entwickeln und Zusammenstellen von Projekten f√ºr JavaEE (in diesem Moment erschien gerade die Version von EJB 3, zu der wir gewechselt haben).  Equinox war zum Beispiel viel weniger praktisch als Weblogic, und die Vorteile von OSGI waren mir damals nicht klar. <br><br>  Aber dann, nach vielen Jahren, musste ich ein Projekt an einem neuen Arbeitsplatz beginnen, das auf der Basis von Apache Camel und Apache Karaf konzipiert wurde.  Dies war nicht meine Idee, ich kannte Camel schon lange und beschloss, auch ohne Angebot √ºber Karaf zu lesen.  Ich habe es eines Abends gelesen und festgestellt, dass es hier einfach und fertig ist, fast die gleiche L√∂sung f√ºr einige Probleme eines typischen JavaEE, √§hnlich wie ich es einmal mit Weblogic WLST, Jython und Maven Aether auf meinem Knie gemacht habe. <br><br>  Nehmen wir also an, Sie m√∂chten OSGI auf der Karaf-Plattform ausprobieren.  Mit was fangen wir an? <br><a name="habracut"></a><br><h3>  Wenn Sie ein tieferes Verst√§ndnis wollen </h3><br>  Sie k√∂nnen nat√ºrlich mit dem Lesen der Dokumentation beginnen.  Und mit Habr√© ist das m√∂glich - hier gab es sehr gute Artikel, sagen wir vor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">so</a> langer Zeit.  Aber im Allgemeinen erhielt Karaf bisher unverdient wenig Aufmerksamkeit.  Es gab noch ein paar Bewertungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dies</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das</a> .  Es ist besser, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese</a> Erw√§hnung von Karaf zu √ºberspringen.  Wie sie sagen, lesen Sie keine sowjetischen Zeitungen f√ºr die Nacht ... denn sie werden Ihnen dort sagen, dass Karaf ein OSGI-Rahmen ist - also glauben Sie es nicht.  OSGI-Frameworks sind Apache Felix oder Eclipse Equinox, auf deren Grundlage Karaf nur funktioniert.  Sie k√∂nnen einen von ihnen ausw√§hlen. <br><br>  Es sollte beachtet werden, dass wenn Jboss Fuse oder Apache ServiceMix erw√§hnt wird, es als "Karaf mit vorinstallierten Komponenten" gelesen werden sollte, d. H.  in der Tat - das gleiche, nur vom Verk√§ufer gesammelt.  Ich w√ºrde nicht empfehlen, in der Praxis damit zu beginnen, aber es ist durchaus m√∂glich, beispielsweise √úbersichtsartikel √ºber ServiceMix zu lesen. <br><br>  Zun√§chst werde ich hier ganz kurz herausfinden, was OSGI ist und wof√ºr es verwendet werden kann. <br><br>  Im Gro√üen und Ganzen ist OSGI ein Tool zum Erstellen von Java-Anwendungen aus Modulen.  Ein enges Analogon kann beispielsweise als JavaEE betrachtet werden, und in gewissem Ma√üe k√∂nnen OSGI-Container JavaEE-Module (z. B. Webanwendungen in Form von War) ausf√ºhren, und andererseits enthalten viele JavaEE-Container OSGI als Mittel zur Implementierung von Modularit√§t "f√ºr sich" ".  Das hei√üt, JavaEE und OSGI √§hneln der Kompatibilit√§t und erg√§nzen sich erfolgreich. <br><br>  Ein wichtiger Bestandteil jedes modularen Systems ist die Definition des Moduls selbst.  Im Fall von OSGI wird das Modul als Bundle bezeichnet, und es ist ein JAR-Archiv, das allen Entwicklern mit einigen Erg√§nzungen bekannt ist (das hei√üt, es ist hier beispielsweise Krieg oder Ohr sehr √§hnlich).  In Analogie zu JavaEE k√∂nnen Bundles Dienste exportieren und importieren, bei denen es sich im Wesentlichen um Klassenmethoden handelt (dh ein Dienst ist eine Schnittstelle oder alle √∂ffentlichen Methoden einer Klasse). <br><br>  Die Bundle-Metadaten sind allen META-INF / MANIFEST.MF bekannt.  Die Header des OSGI-Manifests √ºberschneiden sich nicht mit den Headern f√ºr die JRE. Au√üerhalb des OSGI-Container-Bundles befindet sich ein regul√§res JAR.  Es ist wichtig, dass es unter den Metadaten immer Folgendes gibt: <br><br><pre><code class="plaintext hljs">Bundle-SymbolicName: com.example.myosgi Bundle-Version: 1.0.0</code> </pre> <br>  Dies sind die ‚ÄûKoordinaten‚Äú des Bundles, und die Tatsache, dass zwei oder mehr gleichzeitig installierte und funktionierende Versionen desselben Bundles in einem Container installiert werden k√∂nnen, ist wichtig. <br><br>  √Ñhnlich wie bei JavaEE haben Bundles einen Lebenszyklus, der folgenderma√üen aussieht: <img src="https://habrastorage.org/getpro/habr/post_images/b71/a55/263/b71a5526390ea0fd4eaf02a3d5edc67a.png" alt="Bild">  Neben Diensten k√∂nnen Bundles auch Pakete importieren und exportieren (Pakete im √ºblichen Sinne des Begriffs f√ºr Java).  Exportierte Pakete werden im Bundle definiert und anderen Komponenten zur Verf√ºgung gestellt, wenn das Bundle auf dem System installiert wird.  Die importierten werden irgendwo von au√üen definiert, m√ºssen von jemandem exportiert und vom Container f√ºr das Bundle bereitgestellt werden, bevor es funktionieren kann. <br><br>  Paketimporte k√∂nnen als optional deklariert werden, ebenso Serviceimporte.  Es ist sehr wichtig, dass Import und Export einen Hinweis auf die Version (oder den Versionsbereich) enthalten. <br><br><h4>  Unterschiede zu JavaEE </h4><br>  Gut, dass sie sich √§hneln - wir haben verstanden.  Und wie unterscheiden sie sich? <br><br>  Meiner Meinung nach besteht der Hauptunterschied darin, dass OSGI uns viel mehr Flexibilit√§t bietet.  Sobald sich das Bundle im Zustand STARTED befindet, sind die M√∂glichkeiten nur durch Ihre Vorstellungskraft begrenzt.  Angenommen, Sie k√∂nnen problemlos Threads (ja, ja, ich kenne ManagedExecutorService), Verbindungspools zu Datenbanken usw. erstellen.  Ein Container √ºbernimmt nicht im gleichen Umfang die Kontrolle √ºber alle Ressourcen wie JavaEE. <br><br>  Sie k√∂nnen dabei neue Services exportieren.  Versuchen Sie beispielsweise in JavaEE dynamisch ein neues Servlet zu erstellen?  Und hier ist es durchaus m√∂glich, dass der auf der Grundlage des Stegs erstellte Karaf-Servlet-Container sofort von Ihrem erstellten Servlet erkannt wird und den Kunden unter einer bestimmten URL zur Verf√ºgung steht. <br><br>  Dies ist zwar eine leichte Vereinfachung, aber wenn die JavaEE-Anwendung in ihrer klassischen Form haupts√§chlich aus Komponenten besteht: <br><br><ul><li>  passiv, wartet auf einen Anruf vom Client </li><li>  statisch definiert, dh zum Zeitpunkt der Bereitstellung der Anwendung. </li></ul><br>  Andererseits kann eine OSGI-basierte Anwendung Folgendes enthalten: <br><br><ul><li>  aktive und passive geplante Komponenten, Durchf√ºhren von Umfragen, Abh√∂ren eines Sockets usw. </li><li>  Services k√∂nnen dynamisch definiert und ver√∂ffentlicht werden </li><li>  Sie k√∂nnen Framework-Ereignisse abonnieren, z. B. die Registrierung von Diensten, Bundles usw. abh√∂ren, Links zu anderen Bundles und Diensten erhalten und vieles mehr. </li></ul><br>  Ja, unter JavaEE ist vieles davon teilweise auch m√∂glich (z. B. √ºber JNDI), aber im Fall von OSGI wird dies in der Praxis einfacher.  Obwohl es hier wahrscheinlich noch ein paar Risiken gibt. <br><br><h4>  Unterschiede zwischen Karaf und reinem OSGI </h4><br>  Neben dem Karaf-Framework gibt es viele n√ºtzliche Dinge.  Im Wesentlichen ist Karaf ein Tool zur bequemen Verwaltung des OSGI-Frameworks - Installation von Bundles (einschlie√ülich Gruppen), Konfiguration, √úberwachung, Beschreibung des Vorbilds und Gew√§hrleistung der Sicherheit und dergleichen. <br><br><h2>  Und lass uns schon √ºben? </h2><br>  Dann fangen wir gleich mit der Installation an.  Hier gibt es nicht viel zu schreiben - gehen Sie zu karaf.apache.org, laden Sie das Distributionspaket herunter und entpacken Sie es.  Karaf-Versionen unterscheiden sich in der Unterst√ºtzung verschiedener OSGI-Spezifikationen (4, 5 oder 6) und Java-Versionen.  Ich empfehle die 2.x-Familie nicht, aber hier sind 3 (wenn Sie Java 8 haben, wie meine), und 4 k√∂nnen verwendet werden, obwohl heute nur die 4.x-Familie entwickelt wird (aktuelle Version 4.2.2, sie unterst√ºtzt OSGI 6) und Java bis zu 10). <br><br>  Karaf funktioniert unter Windows und Linux einwandfrei. Alles, was Sie zum Erstellen eines Dienstes und zum Autorun ben√∂tigen, ist verf√ºgbar.  Die Unterst√ºtzung f√ºr MacOS und viele andere Unix-Typen wird ebenfalls deklariert. <br><br>  Normalerweise k√∂nnen Sie Karaf sofort starten, wenn Sie im Internet sind.  Wenn nicht, lohnt es sich normalerweise, die Konfigurationsdatei zu reparieren und anzugeben, wo Sie Maven-Repository (s) haben.  Normalerweise wird es ein Corporate Nexus sein oder Artifactory sagen, wer was mag.  Die Karaf-Konfiguration befindet sich im Ordner etc der Distribution.  Die Namen der Konfigurationsdateien sind nicht sehr offensichtlich, aber in diesem Fall ben√∂tigen Sie die Datei org.ops4j.pax.url.mvn.cfg.  Das Format dieser Datei ist Java-Eigenschaften. <br><br>  Sie k√∂nnen die Repositorys sowohl in der Konfigurationsdatei selbst angeben, die Liste der URLs in den Einstellungen auflisten als auch einfach anzeigen, wo sich Ihre settings.xml befindet.  Dort nimmt der Karaf den Standort Ihres Proxys ein, der normalerweise im Intranet bekannt sein muss. <br><br>  Kafar ben√∂tigt mehrere Ports: HTTP, HTTPS (wenn das Web standardm√§√üig nicht konfiguriert ist), SSH, RMI, JMX.  Wenn sie mit Ihnen besch√§ftigt sind oder Sie mehrere Kopien auf demselben Host ausf√ºhren m√∂chten, m√ºssen Sie diese ebenfalls √§ndern.  Es gibt ungef√§hr f√ºnf dieser Ports. <br><br>  Ports wie jmx und rmi - hier: org.apache.karaf.management.cfg, ssh - org.apache.karaf.shell.cfg, um die http / https-Ports zu √§ndern, m√ºssen Sie die Datei etc / erstellen (h√∂chstwahrscheinlich nicht) org.ops4j.pax.web.cfg und schreiben Sie den Wert org.osgi.service.http.port = port, den Sie ben√∂tigen. <br><br>  Dann k√∂nnen Sie es definitiv starten, und in der Regel wird alles beginnen.  F√ºr den industriellen Einsatz m√ºssen Sie nat√ºrlich √Ñnderungen an der Datei bin / setenv oder bin / setenv.bat vornehmen, um beispielsweise die erforderliche Speichermenge zuzuweisen. Zun√§chst ist dies jedoch nicht erforderlich. <br><br>  Sie k√∂nnen Karaf sofort mit der Konsole oder dem Befehl karaf starten oder im Hintergrund mit dem Befehl start server ausf√ºhren und dann √ºber SSH eine Verbindung herstellen.  Dies ist ein Standard-SSH mit Unterst√ºtzung f√ºr SCP und SFTP.  Sie k√∂nnen Befehle ausf√ºhren und Dateien hin und her kopieren.  Es ist m√∂glich, eine Verbindung mit einem beliebigen Client herzustellen. Mein Lieblingswerkzeug ist beispielsweise Far NetBox.  Die Anmeldung erfolgt √ºber Login und Passwort sowie √ºber Schl√ºssel.  In Innereien jsch, mit allem, was es impliziert. <br><br>  Ich empfehle, sofort ein zus√§tzliches Konsolenfenster zu haben, um die Protokolle in data / log / karaf.log anzuzeigen (und andere Dateien sind normalerweise vorhanden, obwohl dies anpassbar ist).  Protokolle sind n√ºtzlich f√ºr Sie, von Kurznachrichten in der Konsole ist nicht alles klar. <br><br>  Ich w√ºrde empfehlen, das Web sofort und die Hawtio-Webkonsole zu installieren.  Diese beiden Dinge erleichtern Ihnen die Navigation im Container und die Steuerung des Prozesses von dort aus (als Bonus erhalten Sie Jolokia und die M√∂glichkeit, √ºber http zu √ºberwachen).  Die Installation von hawtio erfolgt √ºber zwei Befehle von der Karaf-Konsole ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie hier beschrieben</a> ). Leider wird die Version von Karaf 3.x heute nicht mehr unterst√ºtzt (Sie m√ºssen nach √§lteren Versionen von Hawtio suchen). <br><br>  Standardm√§√üig ist https nicht sofort verf√ºgbar. Dazu m√ºssen Sie einige Anstrengungen unternehmen, z. B. das Generieren von Zertifikaten usw. Die Implementierung basiert auf einem Steg, sodass alle diese Bem√ºhungen gr√∂√ütenteils auf die gleiche Weise ausgef√ºhrt werden. <br><br><h2>  OK, es fing an, was kommt als n√§chstes? </h2><br><img src="https://habrastorage.org/webt/lh/ty/ge/lhtygefalzjfywb-3lr088qvrha.png"><br><br>  Was hast du eigentlich erwartet?  Ich sagte, es wird ssh sein.  Tab funktioniert, wenn das so ist. <br><br>  Es ist Zeit, eine Anwendung zu installieren.  Eine Anwendung f√ºr OSGI ist entweder ein Bundle oder besteht aus mehreren Bundles.  Karaf kann Anwendungen in verschiedenen Formaten bereitstellen: <br><br><ul><li>  Ein Glasb√ºndel mit oder ohne OSGI-Manifest </li><li>  XML mit Spring DM oder Blueprint </li><li>  XML mit der sogenannten Funktion, einer Sammlung von Bundles, anderen Funktionen und Ressourcen (Konfigurationsdateien) </li><li>  .kar-Archiv mit mehreren Funktionen und einem Maven-Repository mit Abh√§ngigkeiten </li><li>  JavaEE-Anwendungen (unter bestimmten Bedingungen), z. B. .war </li></ul><br>  Es gibt verschiedene M√∂glichkeiten, dies zu tun: <br><br><ul><li>  Legen Sie die Anwendung im Bereitstellungsordner ab </li><li>  Installieren Sie von der Konsole mit dem Befehl install </li><li>  Installieren Sie die Funktion mit dem Befehl √ºber die Funktion: Konsole installieren </li><li>  kar: installieren </li></ul><br>  Im Allgemeinen ist dies ziemlich √§hnlich wie ein typischer JavaEE-Container, aber es ist etwas praktischer (ich w√ºrde sagen, es ist viel praktischer). <br><br><h3>  Einfaches Glas </h3><br>  Am einfachsten ist es, ein normales Glas zu installieren.  Wenn Sie es im Maven-Repository haben, reicht der Befehl aus, um Folgendes zu installieren: <br><br><pre> <code class="bash hljs">install mvn:groupId/artifactId/version</code> </pre> <br>  Gleichzeitig erkennt Karaf, dass er ein normales Glas vor sich hat, und verarbeitet es, indem er im laufenden Betrieb eine B√ºndelverpackung erstellt, die sogenannte  Wrapper, der ein Standardmanifest generiert, mit Paketimporten und -exporten. <br><br>  Der Sinn, nur ein Glas zu installieren, ist normalerweise nicht gro√ü, da dieses Bundle passiv ist - es exportiert nur Klassen, die anderen Bundles zur Verf√ºgung stehen. <br><br>  Diese Methode wird verwendet, um Komponenten wie Apache Commons Lang zu installieren, zum Beispiel: <br><br><pre> <code class="bash hljs">install mvn:org.apache.commons.lang3/commons-lang/3.8.1</code> </pre> <br>  Aber es hat nicht funktioniert :) Hier sind die richtigen Koordinaten: <br><br><pre> <code class="bash hljs">install mvn:org.apache.commons/commons-lang3/3.8.1</code> </pre> <br>  Mal sehen, was passiert ist: list -u zeigt uns die Bundles und ihre Quellen: <br><br><pre> <code class="bash hljs">karaf@root()&gt; list -u START LEVEL 100 , List Threshold: 50 ID | State | Lvl | Version | Name | Update location ------------------------------------------------------------------------------------------------- 87 | Installed | 80 | 3.8.1 | Apache Commons Lang | mvn:org.apache.commons/commons-lang3/3.8.1 88 | Installed | 80 | 3.6.0 | Apache Commons Lang | mvn:org.apache.commons/commons-lang3/3.6</code> </pre> <br>  Wie Sie sehen, ist es durchaus m√∂glich, zwei Versionen einer Komponente zu installieren.  Speicherort aktualisieren - Hier haben wir das Bundle erhalten und k√∂nnen es bei Bedarf aktualisieren. <br><br><h3>  Jar und Spring Kontext </h3><br>  Wenn sich in Ihrem Glas ein Fr√ºhlingskontext befindet, werden die Dinge interessanter.  Karaf Deployer sucht automatisch nach XML-Kontexten im Ordner META-INF / spring und erstellt sie, wenn alle vom Bundle ben√∂tigten externen Bundles erfolgreich gefunden wurden. <br><br>  Somit werden alle Dienste, die sich innerhalb der Kontexte befanden, bereits gestartet.  Wenn Sie dort beispielsweise Camel Spring hatten, beginnen auch die Kamelrouten.  Dies bedeutet, dass Sie einen REST-Dienst oder einen Dienst, der einen TCP-Port √ºberwacht, bereits starten k√∂nnen.  Das Starten mehrerer Dienste, die an einem Port lauschen, funktioniert nat√ºrlich nicht so. <br><br><h3>  Nur Spring XML-Kontext </h3><br>  Wenn Sie beispielsweise JDBC DataSources-Definitionen in Spring Context hatten, k√∂nnen Sie diese separat in Karaf installieren.  Das hei√üt,  Nehmen Sie eine XML-Datei, die nur eine DataSource in Form von &lt;Bean&gt; oder einem anderen Satz von Komponenten enth√§lt, und legen Sie sie im Bereitstellungsordner ab.  Der Kontext wird auf standardm√§√üige Weise gestartet.  Das einzige Problem ist, dass auf diese Weise erstellte DataSources f√ºr andere Bundles nicht sichtbar sind.  Sie m√ºssen als Dienste nach OSGI exportiert werden.  Dar√ºber - etwas sp√§ter. <br><br><h3>  Fr√ºhling dm </h3><br>  Was ist der Unterschied zwischen Spring DM (OSGI-f√§hige Version) und dem klassischen Spring?  Im klassischen Fall werden also alle Beans im Kontext in der Initialisierungsphase des Kontexts erstellt.  Neue k√∂nnen nicht erscheinen, alte gehen nirgendwo hin.  Bei OSGI k√∂nnen neue Bundles installiert und alte Bundles entfernt werden.  Die Umgebung wird dynamischer, Sie m√ºssen irgendwie reagieren. <br><br>  Die Antwortmethode hei√üt Dienste.  Ein Dienst ist normalerweise eine bestimmte Schnittstelle mit eigenen Methoden, die von einem Bundle ver√∂ffentlicht wird.  Ein Dienst verf√ºgt √ºber Metadaten, mit denen er gesucht und von einem anderen Dienst unterschieden werden kann, der eine √§hnliche Schnittstelle implementiert (offensichtlich von einer anderen DataSource).  Metadaten sind einfache Eigenschaften von Schl√ºsselwerten. <br><br>  Da Dienste angezeigt und ausgeblendet werden k√∂nnen, k√∂nnen diejenigen, die sie ben√∂tigen, entweder beim Start Dienste abonnieren oder Ereignisse anh√∂ren, um Informationen zu ihrem Auftreten oder Verschwinden zu erhalten.  Auf der Spring DM-Ebene wird dies in XML als zwei Elemente implementiert: Service und Referenz, deren grundlegender Zweck recht einfach ist: Ver√∂ffentlichen Sie die vorhandene Bean aus dem Kontext als Service und abonnieren Sie einen externen Service, indem Sie sie im aktuellen Spring-Kontext ver√∂ffentlichen. <br><br>  Dementsprechend findet der Container beim Initialisieren eines solchen Bundles die externen Dienste, die er daf√ºr ben√∂tigt, und ver√∂ffentlicht die darin implementierten Bundles, sodass sie von au√üen zug√§nglich sind.  Ein Bundle wird erst gestartet, nachdem die Service-Links aufgel√∂st wurden. <br><br>  Tats√§chlich ist alles etwas komplizierter, da das Bundle eine Liste √§hnlicher Dienste verwenden und die Liste sofort abonnieren kann.  Das hei√üt,  Ein Dienst hat im Allgemeinen eine Eigenschaft wie Kardinalit√§t, die den Wert 0..N annimmt.  In diesem Fall beschreibt das Abonnement, in dem 0..1 angegeben ist, einen optionalen Dienst. In diesem Fall wird das Bundle erfolgreich gestartet, auch wenn kein solcher Dienst im System vorhanden ist (und anstelle eines Links dazu wird ein Stub angezeigt). <br><br>  Ich stelle fest, dass ein Dienst nur eine beliebige Schnittstelle ist (oder Sie k√∂nnen nur Klassen ver√∂ffentlichen), sodass Sie java.util.Map mit Daten als Dienst gut ver√∂ffentlichen k√∂nnen. <br><br>  Mit dem Dienst k√∂nnen Sie unter anderem Metadaten angeben, und mit der Referenz k√∂nnen Sie anhand dieser Metadaten nach einem Dienst suchen. <br><br><h3>  Blaupause </h3><br>  Blueprint ist die neuere Spring DM-Inkarnation, die etwas einfacher ist.  Wenn Sie im Fr√ºhjahr benutzerdefinierte XML-Elemente haben, sind diese nicht als unn√∂tig vorhanden.  Manchmal verursacht dies immer noch Unannehmlichkeiten, aber ehrlich gesagt - selten.  Wenn Sie kein Projekt aus Spring migrieren, k√∂nnen Sie sofort mit Blueprint beginnen. <br><br>  Das Wesentliche hier ist dasselbe - es ist XML, das die Komponenten beschreibt, aus denen der Bundle-Kontext zusammengestellt wird.  F√ºr diejenigen, die den Fr√ºhling kennen, gibt es √ºberhaupt nichts Unbekanntes. <br><br>  Hier ist ein Beispiel, wie eine DataSource beschrieben und als Service exportiert wird: <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">blueprint</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.osgi.org/xmlns/blueprint/v1.0.0"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"dataSource"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"oracle.jdbc.pool.OracleDataSource"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"URL"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"URL"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"user"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"USER"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"password"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"PASSWORD"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">interface</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"javax.sql.DataSource"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ref</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"dataSource"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ds"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service-properties</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">entry</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"osgi.jndi.service.name"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"jdbc/ds"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service-properties</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">blueprint</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Nun, wir haben diese Datei im Bereitstellungsordner bereitgestellt und uns die Ergebnisse des Befehls list angesehen.  Sie sahen, dass das Bundle nicht gestartet wurde - im Status Indtalled.  Wir versuchen zu starten und erhalten eine Fehlermeldung. <br><br>  Jetzt in der Liste der Bundles im Status Fehlgeschlagen.  Was ist los?  Offensichtlich ben√∂tigt er auch Abh√§ngigkeiten, in diesem Fall ein Jar mit Oracle JDBC-Klassen, genauer gesagt das Paket oracle.jdbc.pool. <br>  Wir finden das erforderliche JAR im Repository oder laden es von der Oracle-Site herunter und installieren es wie zuvor beschrieben.  Unsere DataSource hat begonnen. <br><br>  Wie benutzt man das alles?  Der Service-Link wird in der Blueprint-Referenz aufgerufen (irgendwo im Kontext eines anderen Bundles): <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">reference</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"dataSource"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">interface</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"javax.sql.DataSource"</span></span></span><span class="hljs-tag">/&gt;</span></span></code> </pre> <br>  Dann wird diese Bohne wie √ºblich zu einer Abh√§ngigkeit f√ºr andere Bohnen (im Beispiel camel-sql): <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"sql"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"org.apache.camel.component.sql.SqlComponent"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"dataSource"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ref</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"dataSource"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h3>  Glas und Aktivator </h3><br>  Die kanonische Methode zum Initialisieren von Bundles besteht darin, eine Klasse zu verwenden, die die Activator-Schnittstelle implementiert.  Dies ist eine typische Lebenszyklusschnittstelle, die Start- und Stoppmethoden enth√§lt, die den <i>Kontext √ºbergeben</i> .  In ihnen startet das Bundle normalerweise seine Threads, beginnt bei Bedarf mit dem Abh√∂ren von Ports, abonniert externe Dienste mithilfe der OSGI-API usw.  Dies ist vielleicht der komplexeste, grundlegendste und flexibelste Weg.  Seit drei Jahren habe ich es nie gebraucht. <br><br><h2>  Einstellungen und Konfiguration </h2><br>  Es ist klar, dass eine solche Konfiguration der DataSource, wie im Beispiel gezeigt, nur wenige Personen ben√∂tigen.  Login, Passwort und mehr, alles ist in XML fest codiert.  Es ist notwendig, diese Parameter herauszunehmen. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"url"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"${oracle.ds.url}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"user"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"${oracle.ds.user}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"password"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"${oracle.ds.password}"</span></span></span><span class="hljs-tag">/&gt;</span></span></code> </pre> <br>  Die L√∂sung ist recht einfach und √§hnelt der im klassischen Fr√ºhling verwendeten: An einem bestimmten Punkt im Kontextlebenszyklus werden Eigenschaftswerte aus verschiedenen Quellen ersetzt. <br><br>  Damit beenden wir den ersten Teil.  Wenn Interesse an diesem Thema besteht, wird es fortgesetzt.  Wir werden √ºberlegen, wie Anwendungen aus Bundles zusammengestellt, Systeme auf dieser Plattform konfiguriert, √ºberwacht und automatisch bereitgestellt werden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435444/">https://habr.com/ru/post/de435444/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435430/index.html">Die coolsten Nachrichten CES 2019</a></li>
<li><a href="../de435432/index.html">Neues Jahr, neuer GitHub: Unbegrenzte kostenlose private Repositories</a></li>
<li><a href="../de435436/index.html">5 Trends in der IT-Infrastruktur: Prognose f√ºr 2019</a></li>
<li><a href="../de435438/index.html">PHP: √Ñnderung der Datenbankstruktur in der Teamentwicklung</a></li>
<li><a href="../de435442/index.html">Trichter der Ver√§nderung</a></li>
<li><a href="../de435446/index.html">Verhuff-Algorithmus f√ºr ein beliebiges System mit geraden Zahlen</a></li>
<li><a href="../de435448/index.html">√úber die Erfahrung der Kommunikation mit einem Signalgenerator √ºber QTcpSocket und SCPI</a></li>
<li><a href="../de435450/index.html">Frohes Neues Jahr, Frohes Neues MQTT / UDP</a></li>
<li><a href="../de435452/index.html">End-to-End-Tests von Microservices mit Catcher</a></li>
<li><a href="../de435454/index.html">AOP vs Funktionen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>