<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÖüèª ü¶Ö üë©üèø‚Äçü§ù‚Äçüë©üèΩ Warum brauchen wir virtuelle Funktionen? ‚óæÔ∏è üé∫ üëí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr. Wenn Sie die Antwort auf die Frage im Titel kennen, herzlichen Gl√ºckwunsch, brauchen Sie diesen Artikel nicht. Es richtet sich an Programm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warum brauchen wir virtuelle Funktionen?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458228/"> Hallo Habr.  Wenn Sie die Antwort auf die Frage im Titel kennen, herzlichen Gl√ºckwunsch, brauchen Sie diesen Artikel nicht.  Es richtet sich an Programmieranf√§nger wie mich, die nicht immer alle Feinheiten von C ++ und anderen typisierten Sprachen unabh√§ngig voneinander verstehen k√∂nnen. Wenn dies m√∂glich ist, ist es besser, aus den Fehlern anderer zu lernen. <br><br>  In diesem Artikel werde ich nicht nur die Frage " <i>Warum brauchen wir virtuelle Funktionen in C ++</i> " beantworten, sondern auch ein Beispiel aus meiner Praxis geben.  F√ºr eine kurze Antwort k√∂nnen Sie sich an Suchmaschinen wenden, die Folgendes erzeugen: " <i>Virtuelle Funktionen werden ben√∂tigt, um Polymorphismus bereitzustellen - einer der drei OOP-Wale. Dank ihnen kann die Maschine selbst den Objekttyp per Zeiger bestimmen, ohne den Programmierer mit dieser Aufgabe zu laden.</i> "  Okay, aber die Frage ‚ÄûWarum‚Äú bleibt bestehen, obwohl sie jetzt etwas anders bedeutet: ‚Äû <i>Warum sollten Sie sich auf die Maschine verlassen, zus√§tzliche Zeit und Speicherplatz aufwenden, wenn Sie den Zeiger selbst podcasten k√∂nnen, da die Art des Objekts, auf das er sich bezieht, fast immer bekannt ist?</i> ‚Äú In der Tat l√§sst das Casting auf den ersten Blick virtuelle Funktionen ohne Arbeit, und dies f√ºhrt zu Missverst√§ndnissen und schlechtem Code.  In kleinen Projekten ist der Verlust unsichtbar, aber wie Sie bald sehen werden, erh√∂hen Kasten mit dem Wachstum des Programms die Auflistung in einem fast geometrischen Verlauf. <br><a name="habracut"></a><br>  Lassen Sie uns zun√§chst daran erinnern, wo Castes und virtuelle Funktionen √ºberhaupt ben√∂tigt werden.  Ein Typ geht verloren, wenn einem mit Typ A deklarierten Objekt eine neue Operation zugewiesen wird, um Speicher f√ºr ein Objekt vom Typ B zuzuweisen, das mit Typ A kompatibel ist und normalerweise von A geerbt wird. Meistens ist das Objekt nicht eines, sondern ein gesamtes Array.  Ein Array von Zeigern desselben Typs, von denen jeder auf die Zuweisung eines Speicherbereichs mit Objekten v√∂llig unterschiedlicher Typen wartet.  Hier ist ein Beispiel, das wir betrachten werden. <br><br>  Ich werde mich nicht lange hinziehen, die Aufgabe war folgende: Basierend auf einem Dokument, das mit der Markedit-Hypertext-Markup-Sprache gekennzeichnet ist (Sie k√∂nnen hier dar√ºber lesen), erstellen Sie einen Analysebaum und erstellen Sie eine Datei, die dasselbe Dokument im HTML-Markup enth√§lt.  Meine L√∂sung besteht aus drei aufeinander folgenden Routinen: Analysieren des Quelltextes in Token, Erstellen eines Syntaxbaums aus Token und Erstellen eines darauf basierenden HTML-Dokuments.  Wir interessieren uns f√ºr den zweiten Teil. <br>  Tatsache ist, dass die Knoten des Zielbaums unterschiedliche Typen haben (Abschnitt, Absatz, Textknoten, Link, Fu√ünote usw.), aber f√ºr √ºbergeordnete Knoten werden Zeiger auf untergeordnete Knoten im Array gespeichert und haben daher einen Typ - Knoten. <br><br>  Der Parser selbst funktioniert in vereinfachter Form folgenderma√üen: Er erstellt die ‚ÄûWurzel‚Äú des <b>Baumsyntaxbaums</b> mit dem <b>Stammtyp</b> , deklariert einen <b>open_node-</b> Zeiger vom allgemeinen Typ <b>Node</b> , dem sofort die <b>Baumadresse</b> zugewiesen wird, und die Typvariable des aufgez√§hlten Typs <b>Node_type</b> . Anschlie√üend beginnt die Schleife und <b>iteriert von</b> Anfang an √ºber die Token bis zum letzten.  Bei jeder Iteration wird zuerst der Typ des offenen Knotens <b>open_node</b> in die Typvariable eingegeben (Typen in Form einer Aufz√§hlung werden in der Knotenstruktur gespeichert), gefolgt von der <b>switch-Anweisung</b> , die den Typ des n√§chsten Tokens √ºberpr√ºft (die Token-Typen werden vom Lexer bereits sorgf√§ltig bereitgestellt).  In jedem Zweig des Schalters wird ein anderer Zweig dargestellt, der die Typvariable √ºberpr√ºft, wobei, wie wir uns erinnern, der Typ des offenen Knotens enthalten ist.  Abh√§ngig von seinem Wert werden verschiedene Aktionen ausgef√ºhrt, zum Beispiel: Hinzuf√ºgen einer Knotenliste eines bestimmten Typs zu einem offenen Knoten, √ñffnen eines anderen Knotens eines bestimmten Typs in einem offenen Knoten und <b>√úbergeben</b> seiner Adresse an <b>open_node</b> , Schlie√üen des offenen Knotens, <b>Ausl√∂sen</b> einer Ausnahme.  F√ºr das Thema des Artikels ist das zweite Beispiel interessant.  Jeder offene Knoten (und im Allgemeinen jeder Knoten, der ge√∂ffnet werden kann) enth√§lt bereits ein Array von Zeigern auf Knoten vom Typ <b>Knoten</b> .  Wenn wir einen neuen Knoten in einem ge√∂ffneten Knoten √∂ffnen (wir weisen dem n√§chsten Array-Zeiger den Speicherbereich f√ºr ein Objekt eines anderen Typs zu), bleibt dieser f√ºr einen semantischen C ++ - Analysator eine Instanz des <b>Knotentyps,</b> ohne neue Felder und Methoden zu erwerben.  Ein Zeiger darauf wird jetzt der Variablen <b>open_node zugewiesen</b> , ohne den <b>Knotentyp</b> zu verlieren.  Aber wie arbeitet man mit einem Zeiger eines allgemeinen <b>Knotentyps,</b> wenn man eine Methode aufrufen muss, zum Beispiel einen Absatz?  Zum Beispiel <b>open_bold ()</b> , das einen fetten Schriftknoten darin √∂ffnet?  Schlie√ülich wird <b>open_bold ()</b> als Methode der <b>Paragraph-</b> Klasse deklariert und definiert, und <b>Node ist sich dessen √ºberhaupt</b> nicht bewusst.  Dar√ºber hinaus wird <b>open_node</b> auch als Zeiger auf <b>Node</b> deklariert und muss Methoden von allen Arten von √∂ffnenden Knoten akzeptieren. <br><br>  Hier gibt es zwei L√∂sungen: die offensichtliche und die richtige.  F√ºr einen Anf√§nger ist <b>static_cast offensichtlich</b> , und virtuelle Funktionen sind richtig.  Schauen wir uns zun√§chst einen Zweig des Switch-Parsers an, der mit der ersten Methode geschrieben wurde: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Lexer::BOLD_START: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::SECTION) { open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::PARAGRAPH) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::TITLE) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Title*&gt;(open_node)-&gt;open_bold(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::QUOTE) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Quote*&gt;(open_node)-&gt;open_bold(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::UNORDERED_LIST) { open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (open_node-&gt;get_type() != Node::SECTION) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::ORDERED_LIST) { open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Ordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (open_node-&gt;get_type() != Node::SECTION) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::LINK) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Link*&gt;(open_node)-&gt;open_bold(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">// INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_bold(); break; }</span></span></code> </pre> <br>  Nicht schlecht.  Und jetzt werde ich es nicht lange ziehen, ich werde den gleichen Codeabschnitt zeigen, der mit virtuellen Funktionen geschrieben wurde: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Lexer::BOLD_START: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_bold(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_bold(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::UNORDERED_LIST) { open_node = open_node-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_bold(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">// PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_bold(); break; }</span></span></code> </pre><br>  Der Gewinn ist offensichtlich, aber brauchen wir ihn wirklich?  Schlie√ülich m√ºssen Sie in der <b>Node-</b> Klasse alle Methoden aller abgeleiteten Klassen als virtuell deklarieren und sie irgendwie in jeder abgeleiteten Klasse implementieren.  Die Antwort lautet ja.  Es gibt nicht so viele Methoden speziell in diesem Programm (29), und ihre Implementierung in abgeleiteten Klassen, die nicht mit ihnen verwandt sind, besteht nur aus einer Zeile: <b>throw string ("error!");</b>  .  Sie k√∂nnen den Kreativmodus aktivieren und f√ºr jeden Ausnahmefall eine eindeutige Zeile erstellen.  Vor allem aber - aufgrund der Code-Reduzierung hat sich die Anzahl der Fehler verringert.  Casting ist eine der wichtigsten Ursachen f√ºr Fehler im Code.  Denn nach dem Anwenden von <b>static_cast h√∂rt der</b> Compiler auf zu <b>fluchen,</b> wenn die aufgerufene Klasse in der angegebenen Klasse enthalten ist.  In der Zwischenzeit k√∂nnen verschiedene Klassen unterschiedliche Methoden mit demselben Namen enthalten.  In meinem Fall war 6 im Code versteckt !!!  Fehler, w√§hrend einer von ihnen in mehreren Switch-Zweigen dupliziert wurde.  Da ist sie: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node:: open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Title*&gt;(open_node)-&gt;open_italic();</code> </pre><br>  Als n√§chstes bringe ich unter den Spoilern vollst√§ndige Listen der ersten und zweiten Version des Parsers. <br><br><div class="spoiler">  <b class="spoiler_title">Parser mit Casting</b> <div class="spoiler_text"><pre> <code class="cpp hljs">Root * Parser::parse (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Lexer &amp;lexer) { <span class="hljs-function"><span class="hljs-function">Node * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_node</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tree)</span></span></span></span>; Node::Node_type type; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> i(<span class="hljs-number"><span class="hljs-number">0</span></span>), len(lexer.count()); i &lt; len; i++) { type = open_node-&gt;get_type(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::CITE || type == Node::TEXT || type == Node::NEWLINE || type == Node::NOTIFICATION || type == Node::IMAGE) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"error!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (lexer[i].type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Lexer::NEWLINE: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::ROOT || type == Node::SECTION) ; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::PARAGRAPH) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;add_text(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::TITLE) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Title*&gt;(open_node)-&gt;add_text(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::QUOTE) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Quote*&gt;(open_node)-&gt;add_text(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::UNORDERED_LIST) { open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (open_node-&gt;get_type() != Node::SECTION) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;close(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::ORDERED_LIST) { open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Ordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (open_node-&gt;get_type() != Node::SECTION) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;close(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::LINK) { open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Link*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">// INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); break; } case Lexer::DOUBLE_NEWLINE: { if (type == Node::ROOT || type == Node::SECTION) ; else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } } else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } } else throw string("unexpected double newline!"); break; } case Lexer::UNDERLINE: { if (type == Node::ROOT) open_node = tree-&gt;add_line(); else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;add_line(); } else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;add_line(); } else if (type == Node::TITLE) throw string("unexpected underline inside title!"); else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;add_line(); } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;add_line(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;add_line(); } else // INLINE throw string("unexpected underline inside inline span!"); break; } case Lexer::TITLE_START: { if (lexer[i].lexeme.size() &gt; 7) throw string("invalid title: \"" + lexer[i].lexeme + "\"!"); if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_title(lexer[i].lexeme.size()-1); } else if (type == Node::SECTION) open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_title(lexer[i].lexeme.size()-1); else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_title(lexer[i].lexeme.size()-1); } else if (type == Node::TITLE) throw string("title can't contain another title!"); else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_title(lexer[i].lexeme.size()-1); } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_title(lexer[i].lexeme.size()-1); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_title(lexer[i].lexeme.size()-1); } else if (type == Node::LINK) throw string("link can't contain a title!"); else // INLINE throw string("inline span can't contain a title!"); break; } case Lexer::BOLD_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_bold(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_bold(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_bold(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_bold(); break; } case Lexer::ITALIC_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_italic(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_italic(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_italic(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_italic(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_italic(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_italic(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_italic(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_italic(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_italic(); break; } case Lexer::UNDERLINED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_underlined(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_underlined(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_underlined(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_underlined(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_underlined(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_underlined(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_underlined(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_underlined(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_underlined(); break; } case Lexer::OVERLINED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_overlined(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_overlined(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_overlined(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_overlined(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_overlined(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_overlined(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_overlined(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_overlined(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_overlined(); break; } case Lexer::THROWLINED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_throwlined(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_throwlined(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_throwlined(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_throwlined(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_throwlined(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_throwlined(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_throwlined(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_throwlined(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_throwlined(); break; } case Lexer::SUBSCRIPT_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_subscript(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_subscript(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_subscript(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_subscript(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_subscript(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_subscript(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_subscript(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_subscript(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_subscript(); break; } case Lexer::SUPERSCRIPT_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_superscript(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_superscript(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_superscript(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_superscript(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_superscript(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_superscript(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_superscript(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_superscript(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_superscript(); break; } case Lexer::MARKED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_marked(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_marked(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_marked(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_marked(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_marked(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_marked(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_marked(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_marked(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_marked(); break; } case Lexer::MONOSPACE_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_monospace(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_monospace(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_monospace(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_monospace(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_monospace(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_monospace(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_monospace(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_monospace(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_monospace(); break; } case Lexer::SPAN_OR_IMAGE_FINISH: { if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;close(); else if (type == Node::BOLD || type == Node::ITALIC || type == Node::UNDERLINED || type == Node::OVERLINED || type == Node::THROWLINED || type == Node::SUBSCRIPT || type == Node::SUPERSCRIPT || type == Node::MARKED || type == Node::MONOSPACE) open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;close(); else if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("]"); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("]"); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("]"); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;add_text("]"); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;add_text("]"); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("]"); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("]"); } else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;add_text("&gt;"); break; } case Lexer::LINK_START: { if (i &gt; len-3 || lexer[++i].type != Lexer::TEXT || lexer[++i].type != Lexer::LINK_FINISH) throw string("unclosed link!"); if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); break; } case Lexer::LINK_FINISH: { if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;close(); else if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("&gt;"); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section&gt;(open_node).open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("&gt;"); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("&gt;"); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;add_text("&gt;"); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;add_text("&gt;"); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("&gt;"); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("&gt;"); } else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;add_text("&gt;"); break; } case Lexer::IMAGE_START: { if (i &gt; len-5 || lexer[++i].type != Lexer::TEXT || lexer[++i].type != Lexer::LINK_FINISH || (lexer[++i].type != Lexer::TEXT &amp;&amp; lexer[i].type != Lexer::SPAN_OR_IMAGE_FINISH) || (lexer[i].type == Lexer::TEXT &amp;&amp; lexer[i+1].type != Lexer::SPAN_OR_IMAGE_FINISH)) throw string("unclosed image defintion!"); if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::TITLE) { if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::LINK) { if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else { // INLINE if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } break; } case Lexer::CITE: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); } else if (type == Node::SECTION) open_node = static_cast&lt;Section*&gt;(open_node)-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); } else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;add_image(lexer[i-3].lexeme, lexer[i-1].lexeme); else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); } else if (type == Node::LINK) throw string("link can't contain a cite!"); else // INLINE throw string("inline span can't contain a cite!"); break; } case Lexer::QUOTE_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } else if (type == Node::SECTION) open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } else if (type == Node::TITLE) { open_node = static_cast&lt;Title*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } else if (type == Node::LINK) { open_node = static_cast&lt;Link*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } else { // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } break; } case Lexer::NOTIFICATION: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::TITLE) { open_node = static_cast&lt;Title*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::LINK) { open_node = static_cast&lt;Link*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else { // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } break; } case Lexer::TEXT: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); } else if (type == Node::LINK) { open_node = static_cast&lt;Link*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); } else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); break; } case Lexer::UNORDERED_LIST_ITEM_MARKER: { break; } case Lexer::ORDERED_LIST_ITEM_MARKER: { break; } case Lexer::END: { if (type == Node::ROOT) open_node = tree-&gt;close(); else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;close(); } else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;close(); } else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;close(); } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;close(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;close(); } else // LINK || INLINE throw string("unexpected ending!"); /// ROOT, /// SECTION, /// PARAGRAPH, TITLE, QUOTE, UNORDERED_LIST, ORDERED_LIST, /// BOLD, ITALIC, UNDERLINED, OVERLINED, THROWLINED, SUBSCRIPT, SUPERSCRIPT, MARKED, MONOSPACE, /// LINK break; } } } concatenate(); return tree; }</span></span></code> </pre></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parser mit Zugriff auf virtuelle Methoden</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">Root * Parser::parse (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Lexer &amp;lexer) { <span class="hljs-function"><span class="hljs-function">Node * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_node</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tree)</span></span></span></span>; Node::Node_type type; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> i(<span class="hljs-number"><span class="hljs-number">0</span></span>), len(lexer.count()); i &lt; len; i++) { type = open_node-&gt;get_type(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::CITE || type == Node::TEXT || type == Node::NEWLINE || type == Node::NOTIFICATION || type == Node::IMAGE) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"error!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (lexer[i].type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Lexer::NEWLINE: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::ROOT || type == Node::SECTION) ; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::PARAGRAPH || type == Node::TITLE || type == Node::QUOTE || type == Node::TITLE || type == Node::QUOTE) open_node = open_node-&gt;add_text(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">// LINK, INLINE open_node = open_node-&gt;add_text(lexer[i].lexeme); break; } case Lexer::DOUBLE_NEWLINE: { if (type == Node::ROOT || type == Node::SECTION) ; else if (type == Node::PARAGRAPH || type == Node::QUOTE || type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); } else throw string("unexpected double newline!"); break; } case Lexer::UNDERLINE: { if (type == Node::ROOT) open_node = tree-&gt;add_line(); else if (type == Node::SECTION) { open_node = open_node-&gt;close(); open_node = tree-&gt;add_line(); } else if (type == Node::PARAGRAPH || type == Node::QUOTE || type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;close(); open_node = tree-&gt;add_line(); } else if (type == Node::TITLE) throw string("unexpected underline inside title!"); else if (type == Node::LINK) throw string("unexpected underline inside link!"); else // INLINE throw string("unexpected underline inside inline span!"); break; } case Lexer::TITLE_START: { if (lexer[i].lexeme.size() &gt; 7) throw string("invalid title: \"" + lexer[i].lexeme + "\"!"); if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_title(lexer[i].lexeme.size()-1); } else if (type == Node::SECTION) open_node = open_node-&gt;open_title(lexer[i].lexeme.size()-1); else if (type == Node::PARAGRAPH || type == Node::QUOTE || type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_title(lexer[i].lexeme.size()-1); } else if (type == Node::TITLE) throw string("title can't contain another title!"); else if (type == Node::LINK) throw string("link can't contain a title!"); else // INLINE throw string("inline span can't contain a title!"); break; } case Lexer::BOLD_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_bold(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_bold(); } else if (type == Node::UNORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_bold(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_bold(); break; } case Lexer::ITALIC_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_italic(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_italic(); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_italic(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_italic(); break; } case Lexer::UNDERLINED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_underlined(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_underlined(); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_underlined(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_underlined(); break; } case Lexer::OVERLINED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_overlined(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_overlined(); } else if (type == Node::PARAGRAPH) open_node = open_node-&gt;open_overlined(); else if (type == Node::TITLE) open_node = open_node-&gt;open_overlined(); else if (type == Node::QUOTE) open_node = open_node-&gt;open_overlined(); else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_overlined(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_overlined(); break; } case Lexer::THROWLINED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_throwlined(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_throwlined(); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_throwlined(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_throwlined(); break; } case Lexer::SUBSCRIPT_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_subscript(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_subscript(); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_subscript(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_subscript(); break; } case Lexer::SUPERSCRIPT_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_superscript(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_superscript(); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_superscript(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_superscript(); break; } case Lexer::MARKED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_marked(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_marked(); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_marked(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_marked(); break; } case Lexer::MONOSPACE_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_monospace(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_monospace(); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_monospace(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_monospace(); break; } case Lexer::SPAN_OR_IMAGE_FINISH: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text("]"); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text("]"); } else if (type == Node::PARAGRAPH || type == Node::QUOTE || type == Node::LINK) open_node = open_node-&gt;add_text("]"); else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text("]"); } else // TITLE, INLINE open_node = open_node-&gt;close(); break; } case Lexer::LINK_START: { if (i &gt; len-3 || lexer[++i].type != Lexer::TEXT || lexer[++i].type != Lexer::LINK_FINISH) throw string("unclosed link!"); if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_link(lexer[i-1].lexeme); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_link(lexer[i-1].lexeme); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_link(lexer[i-1].lexeme); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_link(lexer[i-1].lexeme); break; } case Lexer::LINK_FINISH: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text("&gt;"); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text("&gt;"); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text("&gt;"); } else if (type == Node::LINK) open_node = open_node-&gt;close(); else // PARAGRAPH, TITLE, QUOTE, INLINE open_node = open_node-&gt;add_text("&gt;"); break; } case Lexer::IMAGE_START: { if (i &gt; len-5 || lexer[++i].type != Lexer::TEXT || lexer[++i].type != Lexer::LINK_FINISH || (lexer[++i].type != Lexer::TEXT &amp;&amp; lexer[i].type != Lexer::SPAN_OR_IMAGE_FINISH) || (lexer[i].type == Lexer::TEXT &amp;&amp; lexer[i+1].type != Lexer::SPAN_OR_IMAGE_FINISH)) throw string("unclosed image defintion!"); if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = open_node-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = open_node-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = open_node-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = open_node-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::PARAGRAPH || type == Node::QUOTE || type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { if (lexer[i].type == Lexer::TEXT) { open_node = open_node-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = open_node-&gt;add_image(lexer[i-2].lexeme, ""); } else { // TITLE, LINK, INLINE if (lexer[i].type == Lexer::TEXT) { open_node = open_node-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = open_node-&gt;add_image(lexer[i-2].lexeme, ""); } break; } case Lexer::CITE: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); } else if (type == Node::SECTION) open_node = open_node-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); else if (type == Node::PARAGRAPH || type == Node::QUOTE || type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); } else if (type == Node::TITLE) throw string("title cant't contain a cite!"); else if (type == Node::LINK) throw string("link can't contain a cite!"); else // INLINE throw string("inline span can't contain a cite!"); break; } case Lexer::QUOTE_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_quote(); } else if (type == Node::SECTION) open_node = open_node-&gt;open_quote(); else { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_quote(); } break; } case Lexer::NOTIFICATION: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_notification(lexer[i].lexeme); } else { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_notification(lexer[i].lexeme); } break; } case Lexer::TEXT: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text(lexer[i].lexeme); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text(lexer[i].lexeme); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text(lexer[i].lexeme); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;add_text(lexer[i].lexeme); break; } case Lexer::UNORDERED_LIST_ITEM_MARKER: { break; } case Lexer::ORDERED_LIST_ITEM_MARKER: { break; } case Lexer::END: { if (type == Node::ROOT) open_node = tree-&gt;close(); else if (type == Node::SECTION) { open_node = open_node-&gt;close(); open_node = tree-&gt;close(); } else if (type == Node::PARAGRAPH || type == Node::QUOTE || type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;close(); open_node = tree-&gt;close(); } else // LINK || INLINE throw string("unexpected ending!"); break; } } } concatenate(); return tree; }</span></span></code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Von 1357 Zeilen wurde der Code auf 487 reduziert - fast dreimal, ohne die L√§nge der Zeilen! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Frage bleibt: Was ist mit der Vorlaufzeit? </font><font style="vertical-align: inherit;">Wie viele Millisekunden m√ºssen wir f√ºr den Computer selbst bezahlen, um den Typ des offenen Knotens zu bestimmen? </font><font style="vertical-align: inherit;">Ich habe ein Experiment durchgef√ºhrt - ich habe die Parser-Arbeitszeit in Millisekunden im ersten und zweiten Fall f√ºr dasselbe Dokument auf meinem Heimcomputer festgelegt. </font><font style="vertical-align: inherit;">Hier ist das Ergebnis: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Casting - 538 ms. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Virtuelle Funktionen - 1174 ms. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insgesamt 636 ms - eine Geb√ºhr f√ºr die Kompaktheit des Codes und das Fehlen von Fehlern. </font><font style="vertical-align: inherit;">Ist das viel?</font></font> M√∂glicherweise.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir jedoch ein Programm ben√∂tigen, das so schnell wie m√∂glich arbeitet und so wenig Speicher wie m√∂glich ben√∂tigt, w√ºrden wir nicht zu OOP gehen und es insgesamt in Assemblersprache schreiben, eine Woche verbringen und riskieren, eine gro√üe Anzahl von Fehlern zu machen. </font><font style="vertical-align: inherit;">Meine Wahl ist also, wo immer sich </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_cast</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dynamic_cast</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im Programm treffen </font><font style="vertical-align: inherit;">, sie durch virtuelle Funktionen zu ersetzen. </font><font style="vertical-align: inherit;">Was ist deine Meinung?</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458228/">https://habr.com/ru/post/de458228/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458208/index.html">Digitale Veranstaltungen in Moskau vom 01. bis 07. Juli</a></li>
<li><a href="../de458214/index.html">Pentest-Labor "Pentestit Test Lab 12" - volle Passage</a></li>
<li><a href="../de458218/index.html">Kiefer- und Gesichtschirurgie oder nicht? Das ist die Frage</a></li>
<li><a href="../de458220/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 304 (vom 24. bis 30. Juni)</a></li>
<li><a href="../de458224/index.html">Die Software f√ºr die Boeing-737 Max wurde von Outsourcern geschrieben, die 9 US-Dollar pro Stunde verdienen</a></li>
<li><a href="../de458230/index.html">Wie KI, Drohnen und Kameras unsere Stra√üen und Br√ºcken sch√ºtzen</a></li>
<li><a href="../de458240/index.html">Wie k√ºnstliche Intelligenz, Drohnen und Kameras die Sicherheit von Stra√üen und Br√ºcken gew√§hrleisten</a></li>
<li><a href="../de458242/index.html">Der neue Raumschiffoperator in C ++ 20</a></li>
<li><a href="../de458244/index.html">Eine endlose und l√§cherliche Liste dessen, was Sie wissen m√ºssen, um √∂ffentliche Wi-Fi-Netzwerke sicher nutzen zu k√∂nnen</a></li>
<li><a href="../de458246/index.html">Zuf√§llige Zuf√§lle im Leben oder wie sich herausstellte, dass Ihnen in einer Traktorenfabrik ein Kuchen pr√§sentiert wurde</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>