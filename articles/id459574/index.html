<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö£üèª üíà üë≤ Menyelam lebih dalam ke ruang nama Linux, bagian 2 üíâ üë©üèº‚Äçüé® üö≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada bagian sebelumnya, kami hanya mencelupkan jari kaki kami ke perairan namespace dan pada saat yang sama melihat betapa mudahnya untuk memulai pros...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menyelam lebih dalam ke ruang nama Linux, bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459574/"><p>  Pada bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya,</a> kami hanya mencelupkan jari kaki kami ke perairan namespace dan pada saat yang sama melihat betapa mudahnya untuk memulai proses dalam namespace UTS yang terisolasi.  Dalam posting ini kita akan membahas ruang nama Pengguna. </p><br><p>  Di antara sumber daya terkait keamanan lainnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ruang nama pengguna</a> mengisolasi pengidentifikasi pengguna dan grup dalam sistem.  Dalam posting ini, kami akan fokus hanya pada sumber daya ID pengguna dan grup (masing-masing UID dan GID), karena mereka memainkan peran mendasar dalam melakukan pemeriksaan izin dan kegiatan terkait keamanan lainnya di seluruh sistem. </p><br><p>  Di Linux, ID ini hanya bilangan bulat yang mengidentifikasi pengguna dan grup dalam sistem.  Dan beberapa dari mereka ditugaskan untuk setiap proses untuk mengatur operasi / sumber daya yang mana proses ini dapat dan tidak bisa mendapatkan akses.  Kemampuan suatu proses untuk membahayakan tergantung pada izin yang terkait dengan ID yang ditugaskan. <a name="habracut"></a></p><br><h2 id="user-namespaces">  Ruang nama pengguna </h2><br><blockquote>  <em>Kami akan menggambarkan kemampuan ruang nama pengguna hanya menggunakan ID pengguna.</em>  <em>Tindakan yang persis sama berlaku untuk ID grup, yang akan kami bahas nanti dalam posting ini.</em> </blockquote><p> Ruang nama pengguna memiliki salinan pengidentifikasi pengguna dan grup sendiri.  Kemudian isolasi memungkinkan Anda untuk mengaitkan proses dengan set ID lain, tergantung pada namespace pengguna yang saat ini dimiliki.  Sebagai contoh, proses <code>$pid</code> dapat dijalankan dari <code>root</code> (UID 0) di namespace pengguna <strong>P</strong> dan tiba-tiba terus dijalankan dari <code>proxy</code> (UID 13) setelah beralih ke namespace pengguna lain <strong>Q.</strong> </p><br><p>  Ruang pengguna bisa disarangkan!  Ini berarti bahwa instance namespace kustom (induk) dapat memiliki nol atau lebih namespace anak, dan setiap namespace anak dapat, pada gilirannya, memiliki namespace anak sendiri dan seterusnya ... (hingga mencapai batas 32 level bersarang).  Ketika namespace <strong>C</strong> baru dibuat, Linux menetapkan namespace Pengguna saat ini dari proses pembuatan <strong>C</strong> sebagai induk untuk <strong>C</strong> dan ini tidak dapat diubah nanti.  Akibatnya, semua ruang nama pengguna memiliki tepat satu induk, membentuk struktur ruang nama seperti pohon.  Dan, seperti dalam kasus tree, pengecualian aturan ini ada di bagian atas, di mana kita memiliki namespace root (atau awal, default).  Ini, jika Anda belum melakukan semacam sihir kontainer, kemungkinan besar namespace pengguna tempat semua proses Anda berada, karena ini adalah satu-satunya namespace pengguna sejak sistem dimulai. </p><br><blockquote>  <em>Dalam posting ini, kita akan menggunakan perintah meminta P $ dan C $ untuk mengindikasikan shell yang saat ini berjalan di namespace pengguna <strong>P</strong> dan child <strong>C.</strong></em> </blockquote><br><h2 id="mappingi-user-id">  Pemetaan ID Pengguna </h2><br><p>  Namespace pengguna, pada kenyataannya, berisi satu set pengidentifikasi dan beberapa informasi yang menghubungkan ID ini dengan satu set ID dari namespace pengguna lain - duet ini mendefinisikan ide lengkap ID proses yang tersedia dalam sistem.  Mari kita lihat bagaimana tampilannya: </p><br><pre> <code class="bash hljs">P$ whoami iffy P$ id uid=1000(iffy) gid=1000(iffy)</code> </pre> <br><p>  Di jendela terminal lain, mari kita mulai shell menggunakan <code>unshare</code> (flag <code>-U</code> menciptakan proses di namespace pengguna baru): </p><br><pre> <code class="bash hljs">P$ whoami iffy P$ unshare -U bash <span class="hljs-comment"><span class="hljs-comment">#    ,     user namespace C$ whoami nobody C$ id uid=65534(nobody) gid=65534(nogroup) C$ ls -l my_file -rw-r--r-- 1 nobody nogroup 0 May 18 16:00 my_file</span></span></code> </pre> <br><p>  Tunggu sebentar, siapa?  Sekarang kita berada di shell bersarang di <strong>C</strong> , pengguna saat ini menjadi bukan siapa-siapa?  Kami mungkin menduga bahwa karena <strong>C</strong> adalah namespace pengguna baru, prosesnya mungkin memiliki jenis ID yang berbeda.  Karena itu, kami mungkin tidak berharap dia tetap <code>iffy</code> , tetapi <code>nobody</code> ada yang tidak lucu.  Di sisi lain, itu hebat karena kami mendapat isolasi yang kami inginkan.  Proses kami sekarang memiliki substitusi ID yang berbeda (walaupun rusak) dalam sistem - saat ini ia melihat semua orang sebagai <code>nobody</code> - <code>nobody</code> dan setiap kelompok sebagai <code>nogroup</code> . </p><br><p>  Informasi yang menghubungkan UID dari satu ruang nama pengguna ke yang lain disebut <strong>pemetaan ID pengguna</strong> .  Ini adalah tabel pencarian untuk mencocokkan ID di namespace pengguna saat ini untuk ID di namespace lain dan setiap namespace pengguna dikaitkan dengan tepat satu pemetaan UID (selain pemetaan GID lain untuk ID grup). </p><br><p>  Pemetaan ini adalah apa yang rusak di shell <code>unshare</code> kami.  Ternyata ruang nama pengguna baru dimulai dengan pemetaan kosong, dan sebagai hasilnya, Linux menggunakan pengguna yang mengerikan itu secara default.  Kami perlu memperbaiki ini sebelum kami dapat melakukan pekerjaan yang bermanfaat di namespace baru kami.  Misalnya, saat ini, panggilan sistem (seperti <code>setuid</code> ) yang mencoba bekerja dengan UID akan gagal.  Tapi jangan takut!  Sesuai dengan tradisi <em>all-is-file</em> , Linux menyajikan pemetaan ini menggunakan sistem file <code>/proc</code> di <code>/proc/$pid/uid_map</code> (di <code>/proc/$pid/gid_map</code> untuk GID), di mana <code>$pid</code> adalah ID proses.  Kami akan memanggil dua file ini <em>memetakan file.</em> </p><br><h2 id="map-fayly">  File peta </h2><br><p>  File peta adalah file khusus dalam sistem.  Apa yang spesial?  Ya, dengan mengembalikan konten yang berbeda setiap kali Anda membacanya, tergantung pada proses yang Anda baca.  Sebagai contoh, file peta <code>/proc/$pid/uid_maps</code> mengembalikan pemetaan dari UID dari namespace pengguna yang dimiliki oleh proses <code>$pid</code> , UID di namespace pengguna dari proses membaca.  Dan, sebagai hasilnya, konten yang dikembalikan ke proses <strong>X</strong> mungkin berbeda dari apa yang dikembalikan ke proses <strong>Y</strong> , bahkan jika mereka membaca file peta yang sama pada waktu yang sama. </p><br><p>  Secara khusus, proses <strong>X</strong> , yang membaca file peta UID <code>/proc/$pid/uid_map</code> , menerima serangkaian string.  Setiap baris memetakan rentang berkelanjutan UID ke ruang nama pengguna <strong>C dari</strong> proses <code>$pid</code> , yang sesuai dengan rentang UID di ruang nama lain. </p><br><p>  Setiap baris memiliki format <code>$fromID $toID $length</code> , di mana: </p><br><ul><li>  <code>$fromID</code> adalah UID awal rentang untuk namespace pengguna dari proses <code>$pid</code> </li><li>  <code>$lenght</code> adalah panjang rentang. </li><li>  Terjemahan <code>$toID</code> tergantung pada proses membaca <strong>X.</strong>  Jika <strong>X</strong> milik pengguna lain namespace <strong>U</strong> , maka <code>$toID</code> adalah UID awal rentang di <strong>U</strong> yang memetakan dari <code>$fromID</code> .  Jika tidak, <code>$toID</code> adalah UID awal rentang dalam <strong>P</strong> , namespace pengguna induk dari proses <strong>C.</strong> </li></ul><br><p>  Misalnya, jika suatu proses membaca file <code>/proc/1409/uid_map</code> dan di antara baris yang diterima Anda dapat melihat <code>15 22 5</code> , maka UID 15-19 di namespace pengguna proses <code>1409</code> dipetakan ke UID 22-26 dari namespace pengguna terpisah dari proses membaca. </p><br><p>  Di sisi lain, jika suatu proses membaca dari file <code>/proc/$$/uid_map</code> (atau file peta dari setiap proses milik ruang nama pengguna yang sama dengan proses membaca) dan menerima <code>15 22 5</code> , maka UID dari 15 hingga 19 di pengguna namespace <strong>C</strong> memetakan ke dalam UID dari 22 hingga 26 induk untuk namespace pengguna <strong>C.</strong> </p><br><p>  Mari kita coba: </p><br><pre> <code class="bash hljs">P$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $$ 1442 <span class="hljs-comment"><span class="hljs-comment">#   user namespace... C$ echo $$ 1409 # C      ,     C$ cat /proc/1409/uid_map #  #   namespace P      # UIDs    UID    P$ cat /proc/1442/uid_map 0 0 4294967295 # UIDs  0  4294967294  P  #  4294967295 -  ID no user -  C. C$ cat /proc/1409/uid_map 0 4294967295 4294967295</span></span></code> </pre> <br><p>  Ya, itu tidak terlalu menarik, karena ini adalah dua kasus ekstrem, tetapi ada beberapa hal di sana: </p><br><ol><li>  Ruang nama pengguna yang baru dibuat sebenarnya akan memiliki file peta kosong. </li><li>  UID 4294967295 tidak dapat dipetakan dan tidak cocok untuk digunakan bahkan di namespace pengguna <code>root</code> .  Linux menggunakan UID ini secara khusus untuk menunjukkan <strong>tidak adanya ID pengguna</strong> . </li></ol><br><h2 id="napisanie-uid-map-faylov">  Menulis File Peta UID </h2><br><p>  Untuk memperbaiki namespace pengguna kami yang baru dibuat <strong>C</strong> , kami hanya perlu menyediakan pemetaan yang diperlukan dengan menulis kontennya untuk memetakan file untuk setiap proses milik <strong>C</strong> (kami tidak dapat memperbarui file ini setelah menulis ke sana).  Menulis ke file ini memberi tahu Linux dua hal: </p><br><ol><li>  UID apa yang tersedia untuk proses yang terkait dengan namespace pengguna target <strong>C.</strong> </li><li>  UID mana dalam ruang nama pengguna saat ini yang sesuai dengan UID di <strong>C.</strong> </li></ol><br><p>  Sebagai contoh, jika kita menulis berikut ini dari <strong>P</strong> namespace pengguna induk ke dalam file peta untuk namespace <strong>C</strong> anak: </p><br><pre> <code class="plaintext hljs">0 1000 1 3 0 1</code> </pre> <br><p>  kami pada dasarnya memberi tahu Linux bahwa: </p><br><ol><li>  Untuk proses dalam <strong>C</strong> , satu-satunya UID yang ada dalam sistem adalah UID <code>0</code> dan <code>3</code> .  Misalnya, panggilan sistem <code>setuid(9)</code> akan selalu diakhiri dengan sesuatu seperti <em>id pengguna yang tidak valid</em> . </li><li>  UID <code>1000</code> dan <code>0</code> dalam <strong>P</strong> sesuai dengan UID <code>0</code> dan <code>3</code> dalam <strong>C.</strong>  Sebagai contoh, jika sebuah proses yang berjalan dengan UID <code>1000</code> di <strong>P</strong> beralih ke <strong>C</strong> , ia akan menemukan bahwa setelah beralih, UID-nya telah menjadi <code>root</code> <code>0</code> . </li></ol><br><h2 id="vladelec-prostranstv-imyon-i-privilegii">  Namespace dan pemilik hak istimewa </h2><br><p>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting sebelumnya,</a> kami menyebutkan bahwa saat membuat ruang nama baru, akses dengan tingkat pengguna super diperlukan.  Ruang nama pengguna tidak memaksakan persyaratan ini.  Bahkan, fitur lain adalah mereka dapat <em>memiliki</em> ruang nama lain. </p><br><p>  Setiap kali <strong>N</strong> namespace non-pengguna <strong>dibuat</strong> , Linux menetapkan <strong>P</strong> namespace pengguna saat ini <strong>dari</strong> proses yang menciptakan <strong>N untuk</strong> menjadi <em>pemilik</em> namespace <strong>N.</strong>  Jika <strong>P</strong> dibuat bersama dengan ruang nama lain dalam panggilan sistem <code>clone</code> sama, Linux memastikan bahwa <strong>P</strong> akan dibuat terlebih dahulu dan dijadikan pemilik ruang nama lain. </p><br><p>  Pemilik ruang nama adalah penting karena proses yang meminta untuk mengambil tindakan istimewa pada sumber daya yang bukan ruang nama pengguna akan diperiksa hak-hak UID-nya terhadap pemilik ruang nama pengguna ini, dan bukan ruang nama pengguna root.  Misalnya, katakanlah <strong>P</strong> adalah namespace pengguna induk dari anak <strong>C</strong> , dan <strong>P</strong> dan <strong>C</strong> memiliki masing-masing namespace jaringan <strong>M</strong> dan <strong>N.</strong>  Suatu proses mungkin tidak memiliki hak istimewa untuk membuat perangkat jaringan yang termasuk dalam <strong>M</strong> , tetapi mungkin dapat melakukan ini untuk <strong>N.</strong> </p><br><p>  Konsekuensi dari memiliki pemilik namespace bagi kita adalah bahwa kita dapat menghapus persyaratan <code>sudo</code> ketika menjalankan perintah menggunakan <code>unshare</code> atau <code>isolate</code> jika kita juga meminta pembuatan namespace pengguna.  Misalnya, <code>unshare -u bash</code> akan membutuhkan <code>sudo</code> , tetapi <code>unshare -Uu bash</code> tidak akan lagi: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># UID 1000 --      user namespace P. P$ id uid=1000(iffy) gid=1000(iffy) #           # network namespace. P$ ip link add type veth RTNETLINK answers: Operation not permitted #     ,     #  user  network namespace P$ unshare -nU bash # :  sudo C$ ip link add type veth RTNETLINK answers: Operation not permitted # ,  . ,  # UID 0 (root)    ,  #     nobody.   . C$ echo $$ 13294 #   P,   UID 1000  P  UID 0  C P$ echo "0 1000 1" &gt; /proc/13294/uid_map #   ? C$ id uid=0(root) gid=65534(nogroup) C$ ip link add type veth # !</span></span></code> </pre> <br><blockquote>  <em>Sayangnya, kami akan menerapkan kembali persyaratan superuser di posting berikutnya, karena <code>isolate</code> kebutuhan <code>root</code> privilege di root namespace pengguna untuk mengkonfigurasi dengan benar Mount dan Network namespace.</em>  <em>Tetapi kami pasti akan menghapus hak istimewa proses tim untuk memastikan bahwa tim tidak memiliki izin yang tidak perlu.</em> </blockquote><br><h2 id="kak-razreshayutsya-id">  Bagaimana ID dipecahkan </h2><br><p>  Kami baru saja melihat proses berjalan ketika pengguna biasa <code>1000</code> tiba-tiba beralih ke <code>root</code> .  Jangan khawatir, tidak ada peningkatan hak istimewa.  Ingat bahwa ini hanya ID <em>pemetaan</em> : selama proses kami <em>berpikir</em> bahwa itu adalah <code>root</code> pada sistem, Linux tahu bahwa <code>root</code> - dalam kasusnya - berarti UID <code>1000</code> normal (berkat pemetaan kami).  Jadi pada saat namespaces milik namespace pengguna barunya (seperti network namespace di <strong>C</strong> ) mengenali haknya sebagai <code>root</code> , yang lain (seperti namespace jaringan di <strong>P</strong> ) tidak.  Oleh karena itu, proses tidak dapat melakukan apa pun yang tidak dapat dilakukan oleh pengguna <code>1000</code> . </p><br><p>  Setiap kali proses dalam namespace pengguna bersarang melakukan operasi yang memerlukan izin memeriksa - misalnya, membuat file - UID-nya di namespace pengguna ini dibandingkan dengan ID pengguna yang setara di namespace pengguna root dengan melintasi pemetaan di pohon namespace ke root.  Ada gerakan ke arah yang berlawanan, misalnya, ketika dia membaca ID pengguna, seperti yang kita lakukan dengan <code>ls -l my_file</code> .  UID dari pemilik <code>my_file</code> dipetakan dari namespace pengguna root ke yang sekarang dan ID terkait terakhir (atau tidak ada orang jika pemetaan tidak ada di suatu tempat di sepanjang seluruh pohon) diberikan untuk proses membaca. </p><br><h2 id="gruppovye-id">  ID grup </h2><br><p>  Bahkan jika kita root di <strong>C</strong> , kita masih dikaitkan dengan <code>nogroup</code> mengerikan sebagai ID grup kita.  Kita hanya perlu melakukan hal yang sama untuk <code>/proc/$pid/gid_map</code> .  Sebelum kita dapat melakukan ini, kita perlu menonaktifkan panggilan sistem <code>setgroups</code> (ini tidak perlu jika pengguna kita sudah memiliki kemampuan <code>CAP_SETGID</code> di <strong>P</strong> , tetapi kami tidak akan menganggap ini, karena ini biasanya datang dengan hak akses superuser) dengan menulis "tolak "ke file <code>proc/$pid/setgroups</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  13294 -- pid  unshared  C$ id uid=0(root) gid=65534(nogroup) P$ echo deny &gt; /proc/13294/setgroups P$ echo "0 1000 1" &gt; /proc/13294/gid_map #  group ID   C$ id uid=0(root) gid=0(root)</span></span></code> </pre> <br><h2 id="realizaciya">  Implementasi </h2><br><blockquote>  <em>Kode sumber untuk posting ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .</em> </blockquote><p>  Seperti yang Anda lihat, ada banyak kesulitan yang terkait dengan mengelola ruang nama pengguna, tetapi implementasinya cukup sederhana.  Yang perlu kita lakukan adalah menulis banyak baris ke file - itu suram untuk mengetahui apa dan di mana untuk menulis.  Tanpa basa-basi lagi, inilah tujuan kami: </p><br><ol><li>  Mengkloning proses tim di namespace penggunanya sendiri. </li><li>  Tulis dalam file peta UID dan GID dari proses tim. </li><li>  Setel ulang semua hak pengguna super sebelum menjalankan perintah. </li></ol><br><p>  <code>1</code> dicapai dengan hanya menambahkan bendera <code>CLONE_NEWUSER</code> ke panggilan sistem <code>clone</code> kami. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> clone_flags = SIGCHLD | CLONE_NEWUTS | CLONE_NEWUSER;</code> </pre> <br><p>  Untuk <code>2</code> kami menambahkan fungsi <code>prepare_user_ns</code> , yang dengan hati-hati mewakili satu pengguna biasa <code>1000</code> sebagai <code>root</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare_userns</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> path[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> line[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> uid = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(path, <span class="hljs-string"><span class="hljs-string">"/proc/%d/uid_map"</span></span>, pid); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(line, <span class="hljs-string"><span class="hljs-string">"0 %d 1\n"</span></span>, uid); write_file(path, line); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(path, <span class="hljs-string"><span class="hljs-string">"/proc/%d/setgroups"</span></span>, pid); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(line, <span class="hljs-string"><span class="hljs-string">"deny"</span></span>); write_file(path, line); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(path, <span class="hljs-string"><span class="hljs-string">"/proc/%d/gid_map"</span></span>, pid); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(line, <span class="hljs-string"><span class="hljs-string">"0 %d 1\n"</span></span>, uid); write_file(path, line); }</code> </pre> <br><p>  Dan kita akan menyebutnya dari proses utama di namespace pengguna induk tepat sebelum kita memberi sinyal proses perintah. </p><br><pre> <code class="cpp hljs"> ... <span class="hljs-comment"><span class="hljs-comment">//      . int pipe = params.fd[1]; //      namespace ... prepare_userns(cmd_pid); //   ,     . ...</span></span></code> </pre> <br><p>  Untuk langkah <code>3</code> kami memperbarui fungsi <code>cmd_exec</code> untuk memastikan bahwa perintah dijalankan dari <code>1000</code> pengguna yang tidak terjangkau yang kami sediakan dalam pemetaan (ingat bahwa pengguna root <code>0</code> dalam ruang nama pengguna dari proses tim adalah pengguna <code>1000</code> ): </p><br><pre> <code class="cpp hljs"> ... <span class="hljs-comment"><span class="hljs-comment">//   ' '   . await_setup(params-&gt;fd[0]); if (setgid(0) == -1) die("Failed to setgid: %m\n"); if (setuid(0) == -1) die("Failed to setuid: %m\n"); ...</span></span></code> </pre> <br><p>  Dan itu saja!  <code>isolate</code> sekarang memulai proses dalam namespace pengguna yang terisolasi. </p><br><pre> <code class="bash hljs">$ ./isolate sh ===========sh============ $ id uid=0(root) gid=0(root)</code> </pre> <br><p>  Ada beberapa detail dalam posting ini tentang cara kerja ruang nama Pengguna, tetapi pada akhirnya, pengaturan instance relatif tidak menyakitkan.  Pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting berikutnya,</a> kita akan melihat kemungkinan menjalankan perintah di Mount namespace kita sendiri menggunakan <code>isolate</code> (mengungkapkan rahasia di balik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pernyataan</a> <code>FROM</code> dari <code>Dockerfile</code> ).  Di sana kita perlu membantu Linux sedikit lebih banyak untuk mengonfigurasi instance dengan benar. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459574/">https://habr.com/ru/post/id459574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459560/index.html">Kemampuan pusat data kontainer: pusat switching siap pakai di Myanmar dalam 50 hari</a></li>
<li><a href="../id459562/index.html">Pemrograman dibedakan</a></li>
<li><a href="../id459564/index.html">Apa yang perlu diketahui pengembang tentang bisnis</a></li>
<li><a href="../id459568/index.html">Huruf vertikal dalam TI modern</a></li>
<li><a href="../id459570/index.html">Langsung menuju menunjukkan iklan ke bot Google. Bot tidak senang</a></li>
<li><a href="../id459576/index.html">Ekstensi Google Chrome yang berguna untuk Programmer</a></li>
<li><a href="../id459578/index.html">Sistem Manajemen Proyek Terbuka Sektor Publik</a></li>
<li><a href="../id459580/index.html">Sistem telepon virtual</a></li>
<li><a href="../id459582/index.html">Ikhtisar: cara membeli saham perusahaan Amerika dari Rusia</a></li>
<li><a href="../id459584/index.html">Saya menemukan seorang programmer hebat bernama Steve Wozniak</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>