<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐷 👦🏻 🤖 Schnelle Erfassungslisten: Was ist der Unterschied zwischen schwachen, starken und nicht besessenen Links? 🤾 👑 〽️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Joseph Wright, "Gefangener" - Illustration der "starken" Gefangennahme 

 Die Liste der "erfassten" Werte befindet sich vor der Liste der Schließungsp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schnelle Erfassungslisten: Was ist der Unterschied zwischen schwachen, starken und nicht besessenen Links?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444336/"><img src="https://habrastorage.org/webt/ol/xa/zo/olxazojaea9ikajugulkcm6c-24.jpeg"><br>  <i>Joseph Wright, "Gefangener"</i> - Illustration der "starken" Gefangennahme <br><br>  Die Liste der "erfassten" Werte befindet sich vor der Liste der Schließungsparameter und kann Werte aus dem Bereich auf drei verschiedene Arten "erfassen": über die Links "stark", "schwach" oder "nicht besessen".  Wir verwenden es oft, hauptsächlich um starke Referenzzyklen zu vermeiden („starke Referenzzyklen“, auch bekannt als „Haltezyklen“). <br>  Es kann für einen unerfahrenen Entwickler schwierig sein, sich für eine Methode zu entscheiden, sodass Sie viel Zeit damit verbringen können, zwischen „stark“ und „schwach“ oder zwischen „schwach“ und „nicht besessen“ zu wählen. Mit der Zeit werden Sie jedoch feststellen, dass dies die richtige Wahl ist - nur einer. <br><a name="habracut"></a><br>  Erstellen Sie zunächst eine einfache Klasse: <br><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">playSong</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Shake it off!"</span></span>) } }</code> </pre> <br>  Dann schreiben wir eine Funktion, die eine Instanz der <b>Singer-</b> Klasse erstellt und einen Abschluss zurückgibt, der die <b>playSong ()</b> -Methode der <b>Singer-</b> Klasse <b>aufruft</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; () -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> taylor = <span class="hljs-type"><span class="hljs-type">Singer</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> singing = { taylor.playSong() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> singing }</code> </pre> <br>  Schließlich können wir <b>sing ()</b> überall aufrufen, um das Ergebnis des <b>Spielens von playSong () zu erhalten.</b> <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> singFunction = sing() singFunction()</code> </pre> <br><br>  Infolgedessen wird die Zeile „Shake it off!“ Angezeigt. <br><br><h2>  Starke Erfassung </h2><br>  Sofern Sie keine explizite Erfassungsmethode angeben, verwendet Swift eine „starke“ Erfassung.  Dies bedeutet, dass der Verschluss die verwendeten externen Werte erfasst und diese niemals freigibt. <br><br>  Schauen wir uns noch einmal die Funktion <b>sing ()</b> an <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; () -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> taylor = <span class="hljs-type"><span class="hljs-type">Singer</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> singing = { taylor.playSong() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> singing }</code> </pre> <br>  Die <b>Taylor-Konstante wird</b> innerhalb einer Funktion definiert, sodass unter normalen Umständen ihr Platz freigegeben wird, sobald die Funktion ihre Arbeit beendet hat.  Diese Konstante wird jedoch innerhalb des Verschlusses verwendet, was bedeutet, dass Swift seine Anwesenheit automatisch sicherstellt, solange der Verschluss selbst existiert, auch nach dem Ende der Funktion. <br>  Dies ist eine "starke" Erfassung in Aktion.  Wenn Swift <b>zulässt,</b> dass <b>Taylor</b> freigegeben wird, ist das Aufrufen eines Abschlusses unsicher - die Methode <b>taylor.playSong ()</b> ist nicht mehr gültig. <br><br><h2>  "Schwache" Erfassung (schwache Erfassung) </h2><br>  Mit Swift können wir eine „ <u>Erfassungsliste</u> “ erstellen, <u>um</u> zu bestimmen, wie die verwendeten Werte erfasst werden.  Eine Alternative zur „starken“ Erfassung ist „schwach“ und ihre Anwendung führt zu folgenden Konsequenzen: <br><br>  1. „Schwach“ erfasste Werte werden vom Verschluss nicht gehalten und können daher freigegeben und auf <b>Null gesetzt werden</b> . <br><br>  2. Infolge des ersten Absatzes sind „schwach“ erfasste Werte in Swift immer <b>optional</b> . <br>  Wir modifizieren unser Beispiel mit einer „schwachen“ Erfassung und sehen sofort den Unterschied. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; () -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> taylor = <span class="hljs-type"><span class="hljs-type">Singer</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> singing = { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> taylor] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> taylor?.playSong() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> singing }</code> </pre> <br>  <b>[schwacher Taylor]</b> - Dies ist unsere „ <u>Erfassungsliste</u> “, ein spezieller Teil der Abschlusssyntax, in der wir Anweisungen geben, wie die Werte erfasst werden sollen.  Hier sagen wir, dass <b>Taylor</b> "schwach" erfasst werden sollte, also müssen wir <b>Taylor verwenden? .PlaySong ()</b> - jetzt ist es <b>optional</b> , da es jederzeit auf <b>Null gesetzt</b> werden kann. <br><br>  Wenn Sie diesen Code jetzt ausführen, werden Sie <b>feststellen,</b> dass der Aufruf von <b>singFunction ()</b> nicht mehr zu einer Nachricht führt.  Der Grund dafür ist, dass <b>Taylor</b> nur in <b>sing ()</b> existiert und der von dieser Funktion zurückgegebene Verschluss <b>Taylor nicht</b> „stark“ in sich hält. <br><br>  Versuchen Sie nun, <b>taylor? .PlaySong ()</b> in <b>taylor! .PlaySong () zu ändern</b> .  Dies führt zu einem erzwungenen Auspacken von <b>Taylor</b> im Verschluss und dementsprechend zu einem schwerwiegenden Fehler (Auspacken von Inhalten, die <b>nichts</b> enthalten). <br><br><h2>  "Besitzerlose" Erfassung (nicht besessene Erfassung) </h2><br>  Eine Alternative zur "schwachen" Erfassung ist "inhaberlos". <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; () -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> taylor = <span class="hljs-type"><span class="hljs-type">Singer</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> singing = { [<span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> taylor] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> taylor.playSong() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> singing }</code> </pre> <br>  Dieser Code endet auf ähnliche Weise abnormal mit dem oben gezeigten optional bereitgestellten optionalen - nicht besessenen <b>Taylor</b> sagt: "Ich weiß sicher, dass <b>Taylor</b> für die Dauer des Abschlusses existieren wird, daher muss ich ihn nicht im Speicher behalten."  Tatsächlich wird <b>Taylor</b> fast sofort veröffentlicht und dieser Code stürzt ab. <br><br>  <b>Gehen Sie daher</b> äußerst vorsichtig mit nicht <b>besessenen Gegenständen um</b> . <br><br><h2>  Häufige Probleme </h2><br>  Entwickler haben vier Probleme, wenn sie die Werterfassung in Abschlüssen verwenden: <br><br><h3>  1. Schwierigkeiten mit der Position der Erfassungsliste in dem Fall, in dem der Abschluss Parameter annimmt </h3><br>  Dies ist ein häufiges Problem, auf das Sie möglicherweise zu Beginn der Untersuchung von Verschlüssen stoßen, aber glücklicherweise wird Swift uns in diesem Fall helfen. <br><br>  Wenn Sie die Erfassungsliste und die Abschlussparameter zusammen verwenden, wird die Erfassungsliste in eckigen Klammern angezeigt, dann die Abschlussparameter und dann das Schlüsselwort in, das den Beginn des Abschlusskörpers markiert. <br><br><pre> <code class="swift hljs">writeToLog { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] user, message <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>?.addToLog(<span class="hljs-string"><span class="hljs-string">"\(user) triggered event: \(message)"</span></span>) }</code> </pre> <br>  Der Versuch, nach dem Schließen eine Erfassungsliste zu erstellen, führt zu einem Kompilierungsfehler. <br><br><h3>  2. Die Entstehung eines Zyklus starker Verbindungen, der zu einem Speicherverlust führt </h3><br>  Wenn eine Entität A eine Entität B hat und umgekehrt, haben Sie eine Situation, die als „Aufbewahrungszyklus“ bezeichnet wird. <br><br>  Betrachten Sie als Beispiel den Code: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">House</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ownerDetails: (() -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)? <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printDetails</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"This is a great house."</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">deinit</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"I'm being demolished!"</span></span>) } }</code> </pre> <br>  Wir haben die <b>House-</b> Klasse definiert, die eine Eigenschaft (Closure), eine Methode und einen De-Initialisierer enthält, der eine Nachricht anzeigt, wenn eine Instanz der Klasse zerstört wird. <br><br>  Erstellen Sie nun eine <b>Owner-</b> Klasse ähnlich der vorherigen, mit der Ausnahme, dass ihre Closure-Eigenschaft Informationen zum Haus enthält. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Owner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> houseDetails: (() -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)? <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printDetails</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"I own a house."</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">deinit</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"I'm dying!"</span></span>) } }</code> </pre> <br>  Erstellen Sie nun Instanzen dieser Klassen im <b>do-</b> Block.  Wir brauchen keinen catch-Block, aber die Verwendung eines <b>do-</b> Blocks zerstört die Instanzen direkt nach} <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Creating a house and an owner"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> house = <span class="hljs-type"><span class="hljs-type">House</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> owner = <span class="hljs-type"><span class="hljs-type">Owner</span></span>() } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Done"</span></span>)</code> </pre> <br>  Als Ergebnis werden Meldungen angezeigt: "Ein Haus und einen Eigentümer schaffen", "Ich sterbe!", "Ich werde abgerissen!", Dann "Fertig" - alles funktioniert wie es sollte. <br><br>  Erstellen Sie nun eine Schleife mit starken Links. <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Creating a house and an owner"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> house = <span class="hljs-type"><span class="hljs-type">House</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> owner = <span class="hljs-type"><span class="hljs-type">Owner</span></span>() house.ownerDetails = owner.printDetails owner.houseDetails = house.printDetails } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Done"</span></span>)</code> </pre> <br>  Nun erscheint die Meldung „Haus und Eigentümer erstellen“ und dann „Fertig“.  Deinitializer werden nicht aufgerufen. <br><br>  Dies geschah aufgrund der Tatsache, dass das Haus eine Eigenschaft hat, die auf den Eigentümer zeigt, und der Eigentümer eine Eigenschaft hat, die auf das Haus zeigt.  Daher kann keiner von ihnen sicher freigegeben werden.  In einer realen Situation führt dies zu Speicherverlusten, die zu einer schlechten Leistung und sogar zum Absturz der Anwendung führen. <br><br>  Um die Situation zu beheben, müssen wir einen neuen Abschluss erstellen und in ein oder zwei Fällen eine „schwache“ Erfassung verwenden, wie folgt: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Creating a house and an owner"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> house = <span class="hljs-type"><span class="hljs-type">House</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> owner = <span class="hljs-type"><span class="hljs-type">Owner</span></span>() house.ownerDetails = { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> owner] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> owner?.printDetails() } owner.houseDetails = { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> house] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> house?.printDetails() } } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Done"</span></span>)</code> </pre> <br>  Es ist nicht erforderlich, beide erfassten Werte zu deklarieren. Es reicht aus, dies an einem Ort zu tun. Dadurch kann Swift bei Bedarf beide Klassen zerstören. <br><br>  In realen Projekten tritt die Situation eines solch offensichtlichen Zyklus starker Verbindungen selten auf, aber dies spricht umso mehr für die Bedeutung der Verwendung einer „schwachen“ Erfassung mit kompetenter Entwicklung. <br><br><h3>  3. Die versehentliche Verwendung starker Links, normalerweise beim Erfassen mehrerer Werte </h3><br>  Swift verwendet standardmäßig einen starken Griff, was zu unerwartetem Verhalten führen kann. <br>  Betrachten Sie den folgenden Code: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; () -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> taylor = <span class="hljs-type"><span class="hljs-type">Singer</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> adele = <span class="hljs-type"><span class="hljs-type">Singer</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> singing = { [<span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> taylor, adele] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> taylor.playSong() adele.playSong() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> singing }</code> </pre> <br>  Jetzt haben wir zwei Werte, die vom Abschluss erfasst werden, und wir verwenden beide auf die gleiche Weise.  Es wird jedoch nur <b>Taylor</b> als nicht besessen erfasst - <b>Adele wird</b> stark erfasst, da das nicht <b>besessene</b> Schlüsselwort für jeden erfassten Wert verwendet werden muss. <br><br>  Wenn Sie dies absichtlich getan haben, ist alles in Ordnung. Wenn Sie jedoch möchten, dass beide Werte als "nicht <b>besessen</b> " <b>erfasst werden</b> , benötigen Sie Folgendes: <br><br><pre> <code class="swift hljs">[<span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> taylor, <span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> adele]</code> </pre> <br><h3>  4. Kopieren Sie Abschlüsse und teilen Sie erfasste Werte </h3><br>  Der letzte Fall, über den Entwickler stolpern, ist das Kopieren von Fehlern, da die von ihnen erfassten Daten für alle Kopien des Fehlers verfügbar werden. <br>  <b>Stellen</b> Sie sich ein Beispiel für einen einfachen Abschluss vor, der die außerhalb des Abschlusses deklarierte Ganzzahlvariable <b>numberOfLinesLogged</b> erfasst, damit wir den Wert erhöhen und ihn bei jedem <b>Aufruf</b> des Abschlusses ausdrucken können: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> numberOfLinesLogged = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> logger1 = { numberOfLinesLogged += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Lines logged: \(numberOfLinesLogged)"</span></span>) } logger1()</code> </pre> <br>  Daraufhin wird die Meldung "Linien protokolliert: 1" angezeigt. <br>  Jetzt erstellen wir eine Kopie des Abschlusses, die die erfassten Werte zusammen mit dem ersten Abschluss teilt.  Wenn wir also den ursprünglichen Abschluss oder seine Kopie aufrufen, sehen wir den wachsenden Wert der Variablen. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> logger2 = logger1 logger2() logger1() logger2()</code> </pre><br>  Dadurch werden die Meldungen "Zeilen protokolliert: 1" ... "Zeilen protokolliert: 4" <b>ausgedruckt,</b> da <b>logger1</b> und <b>logger2</b> auf dieselbe erfasste Variable <b>numberOfLinesLogged</b> verweisen. <br><br><h2>  Wann man ein "starkes" Capture verwendet, "schwach" und "inhaberlos" </h2><br>  Nachdem wir nun verstanden haben, wie alles funktioniert, versuchen wir zusammenzufassen: <br><br>  1. Wenn Sie sicher sind, dass der erfasste Wert beim Schließen niemals <b>Null wird</b> , können Sie die <b>Option "Nicht besessene Erfassung" verwenden</b> .  Dies ist eine seltene Situation, in der die Verwendung einer „schwachen“ Erfassung zusätzliche Schwierigkeiten verursachen kann, selbst wenn die Verwendung von Guard Let auf einen schwach erfassten Wert innerhalb des Verschlusses erfolgt. <br><br>  2. Wenn Sie einen Zyklus starker Verbindungen haben (Entität A besitzt Entität B und Entität B besitzt Entität A), müssen Sie in einem der Fälle die <b>„schwache Erfassung“ verwenden</b> .  Es muss berücksichtigt werden, welche der beiden Entitäten zuerst freigegeben wird. Wenn also Ansichtscontroller A Ansichtscontroller B darstellt, kann Ansichtscontroller B eine „schwache“ Verknüpfung zurück zu „A“ enthalten. <br><br>  3. Wenn die Möglichkeit eines Zyklus starker Links ausgeschlossen ist, können Sie "starke" Erfassung ( <b>"starke Erfassung"</b> ) verwenden.  Wenn Sie beispielsweise eine Animation ausführen, wird das Selbst innerhalb des Verschlusses, der die Animation enthält, nicht blockiert, sodass Sie eine starke Bindung verwenden können. <br><br>  4. Wenn Sie sich nicht sicher sind, beginnen Sie mit einer „schwachen“ Bindung und ändern Sie diese nur bei Bedarf. <br><br>  Optional - Offizieller Swift Guide: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kurzschlüsse</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Automatische Linkzählung</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444336/">https://habr.com/ru/post/de444336/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444324/index.html">Auf den Spuren von Taschenrechnern: SpeedCrunch</a></li>
<li><a href="../de444326/index.html">SMS-Überwachung des Gewichts von drei Bienenstöcken für 30 US-Dollar</a></li>
<li><a href="../de444328/index.html">Die Neugestaltung der Benutzeroberfläche ist oft Zeitverschwendung</a></li>
<li><a href="../de444330/index.html">Serverless CMS ist endlich ein würdiger Konkurrent für Wordpress</a></li>
<li><a href="../de444332/index.html">Informationssicherheit und Catering: Wie Manager über IT-Produkte denken</a></li>
<li><a href="../de444338/index.html">Kapselung in Python 3</a></li>
<li><a href="../de444340/index.html">Funktionen zur Verwendung des Symboldatentyps in JavaScript</a></li>
<li><a href="../de444342/index.html">Entwicklung einfacher, moderner JavaScript-Anwendungen mit Webpack und fortschrittlichen Webtechnologien</a></li>
<li><a href="../de444344/index.html">10 Schritte zu einem erfolgreichen Python-Projekt</a></li>
<li><a href="../de444346/index.html">GraphQL und Golang</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>