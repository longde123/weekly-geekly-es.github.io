<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüíª üßíüèª ‚ú≥Ô∏è Beschreibung der Prozessorarchitekturen in LLVM mit TableGen ü§≥üèº üí° üíß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im Moment ist LLVM bereits zu einem sehr beliebten System geworden, mit dem viele Menschen aktiv verschiedene Compiler, Analysatoren usw. erstellen. E...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Beschreibung der Prozessorarchitekturen in LLVM mit TableGen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474460/"> Im Moment ist LLVM bereits zu einem sehr beliebten System geworden, mit dem viele Menschen aktiv verschiedene Compiler, Analysatoren usw. erstellen.  Eine gro√üe Anzahl n√ºtzlicher Materialien zu diesem Thema wurde bereits verfasst, auch in russischer Sprache, was eine gute Nachricht ist.  In den meisten F√§llen liegt die Hauptverzerrung in den Artikeln jedoch im Frontend- und Middleend-LLVM.  Nat√ºrlich wird bei der Beschreibung des vollst√§ndigen Schemas des LLVM-Betriebs die Maschinencodegenerierung nicht umgangen, aber im Grunde wird dieses Thema beil√§ufig angesprochen, insbesondere in Ver√∂ffentlichungen in russischer Sprache.  Gleichzeitig verf√ºgt LLVM √ºber einen ziemlich flexiblen und interessanten Mechanismus zur Beschreibung von Prozessorarchitekturen.  Daher wird dieses Material dem etwas vernachl√§ssigten Dienstprogramm TableGen gewidmet, das Teil von LLVM ist. <br><br>  Der Grund, warum der Compiler Informationen √ºber die Architektur jeder der Zielplattformen ben√∂tigen muss, liegt auf der Hand.  Nat√ºrlich hat jedes Prozessormodell seinen eigenen Registersatz, seine eigenen Maschinenanweisungen usw.  Der Compiler muss √ºber alle erforderlichen Informationen verf√ºgen, um g√ºltigen und effizienten Maschinencode generieren zu k√∂nnen.  Der Compiler l√∂st verschiedene plattformspezifische Aufgaben: Verteilt Register usw.  Dar√ºber hinaus f√ºhren LLVM-Backends auch Optimierungen bereits am Maschinen-IR durch, das n√§her an den tats√§chlichen Anweisungen liegt, oder an den Assembler-Anweisungen selbst.  Bei solchen Optimierungen m√ºssen Anweisungen ersetzt und transformiert werden. Dementsprechend sollten alle Informationen √ºber sie verf√ºgbar sein. <br><a name="habracut"></a><br>  Um das Problem der Beschreibung der Prozessorarchitektur zu l√∂sen, hat LLVM ein einziges Format zur Bestimmung der f√ºr den Compiler erforderlichen Prozessoreigenschaften verwendet.  F√ºr jede unterst√ºtzte Architektur enth√§lt eine <code>.td</code> eine Beschreibung in einer speziellen formalen Sprache.  Es wird in <code>.inc</code> Dateien konvertiert, wenn der Compiler mit dem in LLVM enthaltenen Dienstprogramm TableGen erstellt wird.  Die resultierenden Dateien sind zwar C-Quellen, haben jedoch h√∂chstwahrscheinlich eine separate Erweiterung, damit diese automatisch generierten Dateien leicht unterschieden und gefiltert werden k√∂nnen.  Die offizielle Dokumentation f√ºr TableGen ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und enth√§lt alle notwendigen Informationen, es gibt auch eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">formale Beschreibung der Sprache</a> und eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">allgemeine Einf√ºhrung</a> . <br><br>  Dies ist nat√ºrlich ein sehr umfangreiches Thema, bei dem es viele Details gibt, √ºber die Sie einzelne Artikel schreiben k√∂nnen.  In diesem Artikel betrachten wir einfach die grundlegenden Punkte der Beschreibung von Prozessoren, auch ohne einen √úberblick √ºber alle Funktionen. <br><br><h2>  Beschreibung der Architektur in der .td-Datei </h2><br>  Die in TableGen verwendete formale Beschreibungssprache weist also √§hnliche Funktionen wie normale Programmiersprachen auf und erm√∂glicht es Ihnen, die Merkmale der Architektur in einem deklarativen Stil zu beschreiben.  Und so wie ich es verstehe, wird diese Sprache auch allgemein als TableGen bezeichnet.  Das hei√üt  In diesem Artikel verwendet TableGen sowohl den Namen der formalen Sprache selbst als auch das Dienstprogramm, das die daraus resultierenden Artefakte generiert. <br><br>  Moderne Prozessoren sind sehr komplexe Systeme, daher ist es nicht verwunderlich, dass ihre Beschreibung ziemlich umfangreich ist.  Um die Struktur zu erstellen und die Wartung von <code>.td</code> Dateien zu vereinfachen, k√∂nnen sie sich daher unter Verwendung der f√ºr C-Programmierer √ºblichen <code>#include</code> Direktive gegenseitig <code>#include</code> .  Mithilfe dieser Direktive wird immer zuerst die Datei <code>Target.td</code> , die plattformunabh√§ngige Schnittstellen enth√§lt, die implementiert werden m√ºssen, um alle erforderlichen TableGen-Informationen bereitzustellen.  Diese Datei enth√§lt bereits eine <code>.td</code> Datei mit LLVM-Eigenbeschreibungen, enth√§lt jedoch haupts√§chlich Basisklassen wie <code>Register</code> , <code>Instruction</code> , <code>Processor</code> usw., von denen Sie erben m√ºssen, um Ihre eigene Architektur f√ºr den Compiler basierend auf zu erstellen LLVM.  Aus dem vorhergehenden Satz geht klar hervor, dass TableGen den Begriff Klassen hat, der allen Programmierern bekannt ist. <br><br>  Im Allgemeinen hat TableGen nur zwei grundlegende Entit√§ten: <b>Klassen</b> und <b>Definitionen</b> . <br><br><h3>  Klassen </h3><br>  TableGen-Klassen sind wie in allen objektorientierten Programmiersprachen auch Abstraktionen, aber einfachere Entit√§ten. <br><br>  Klassen k√∂nnen Parameter und Felder haben und andere Klassen erben. <br>  Zum Beispiel wird eine der Basisklassen unten dargestellt. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// A class representing the register size, spill size and spill alignment // in bits of a register. class RegInfo&lt;int RS, int SS, int SA&gt; { int RegSize = RS; // Register size in bits. int SpillSize = SS; // Spill slot size in bits. int SpillAlignment = SA; // Spill slot alignment in bits. }</span></span></code> </pre> <br>  Die spitzen Klammern geben die Eingabeparameter an, die den Klasseneigenschaften zugewiesen sind.  In diesem Beispiel k√∂nnen Sie auch feststellen, dass die TableGen-Sprache statisch typisiert ist.  Die Typen, die in TableGen existieren: <code>bit</code> (ein Analogon des Booleschen Typs mit den Werten 0 und 1), <code>int</code> , <code>string</code> , <code>code</code> (ein St√ºck Code, dies ist ein Typ, einfach weil TableGen keine Methoden und Funktionen im √ºblichen Sinne hat, die Codezeilen sind in <code>[{ ... }]</code> ), Bits &lt;n&gt;, Liste &lt;Typ&gt; (Werte werden wie in Python und einigen anderen Programmiersprachen in eckigen Klammern [...] gesetzt), <code>class type</code> , <code>dag</code> . <br><br>  Die meisten Typen sollten verstanden werden, aber wenn sie Fragen haben, werden sie alle ausf√ºhrlich in der Sprachspezifikation beschrieben, die unter dem am Anfang des Artikels angegebenen Link verf√ºgbar ist. <br><br>  Vererbung wird auch durch eine ziemlich vertraute Syntax beschrieben mit <code>:</code> <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X86MemOperand</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">printMethod</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsmOperandClass</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parserMatchClass</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X86MemAsmOperand</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Operand</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iPTR</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">PrintMethod</span></span> = printMethod; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">MIOperandInfo</span></span> = (ops ptr_rc, i8imm, ptr_rc_nosp, i32imm, <span class="hljs-type"><span class="hljs-type">SEGMENT_REG</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">ParserMatchClass</span></span> = parserMatchClass; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">OperandType</span></span> = <span class="hljs-string"><span class="hljs-string">"OPERAND_MEMORY"</span></span>; }</code> </pre> <br>  In diesem Fall kann die erstellte Klasse nat√ºrlich die Werte der in der Basisklasse angegebenen Felder mit dem Schl√ºsselwort <code>let</code> √ºberschreiben.  Au√üerdem k√∂nnen eigene Felder hinzugef√ºgt werden, die der Beschreibung im vorherigen Beispiel √§hneln und den Feldtyp angeben. <br><br><h3>  Definitionen </h3><br>  Definitionen sind bereits konkrete Entit√§ten, Sie k√∂nnen sie mit den vertrauten Objekten aller Objekte vergleichen.  Definitionen werden mit dem Schl√ºsselwort <code>def</code> definiert und k√∂nnen eine Klasse implementieren, Felder von Basisklassen genauso wie oben beschrieben neu definieren und auch eigene Felder haben. <br><br><pre> <code class="swift hljs">def i8mem : <span class="hljs-type"><span class="hljs-type">X86MemOperand</span></span>&lt;<span class="hljs-string"><span class="hljs-string">"printbytemem"</span></span>, <span class="hljs-type"><span class="hljs-type">X86Mem8AsmOperand</span></span>&gt;; def <span class="hljs-type"><span class="hljs-type">X86AbsMemAsmOperand</span></span> : <span class="hljs-type"><span class="hljs-type">AsmOperandClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">Name</span></span> = <span class="hljs-string"><span class="hljs-string">"AbsMem"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">SuperClasses</span></span> = [<span class="hljs-type"><span class="hljs-type">X86MemAsmOperand</span></span>]; }</code> </pre><br><h3>  Multiklassen </h3><br>  Nat√ºrlich hat eine gro√üe Anzahl von Anweisungen in Prozessoren eine √§hnliche Semantik.  Beispielsweise kann es einen Satz von Anweisungen mit drei Adressen geben, die die beiden Formen <code>‚Äúreg = reg op reg‚Äù</code> und <code>‚Äúreg = reg op imm‚Äù</code> annehmen.  In einem Fall werden Werte aus den Registern entnommen und das Ergebnis wird ebenfalls im Register gespeichert, und in dem anderen Fall ist der zweite Operand ein konstanter Wert (unmittelbarer Operand). <br><br>  Das manuelle Auflisten aller Kombinationen ist ziemlich m√ºhsam, das Risiko eines Fehlers steigt.  Nat√ºrlich k√∂nnen sie automatisch durch Schreiben eines einfachen Skripts generiert werden, dies ist jedoch nicht erforderlich, da in der TableGen-Sprache ein Konzept wie mehrere Klassen vorhanden ist. <br><br><pre> <code class="cpp hljs">multiclass ri_inst&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> opc, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> asmstr&gt; { def _rr : inst&lt;opc, !strconcat(asmstr, <span class="hljs-string"><span class="hljs-string">" $dst, $src1, $src2"</span></span>), (ops GPR:$dst, GPR:$src1, GPR:$src2)&gt;; def _ri : inst&lt;opc, !strconcat(asmstr, <span class="hljs-string"><span class="hljs-string">" $dst, $src1, $src2"</span></span>), (ops GPR:$dst, GPR:$src1, Imm:$src2)&gt;; }</code> </pre> <br>  Innerhalb von Multiclasses m√ºssen Sie alle m√∂glichen Formen von Anweisungen mit dem Schl√ºsselwort <code>def</code> .  Dies ist jedoch keine vollst√§ndige Form der zu generierenden Anweisungen.  Gleichzeitig k√∂nnen Sie die Felder in ihnen neu definieren und alles tun, was in den √ºblichen Definitionen m√∂glich ist.  Um echte Definitionen basierend auf einer Mehrfachklasse zu erstellen, m√ºssen Sie das Schl√ºsselwort <code>defm</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Instantiations of the ri_inst multiclass. defm ADD : ri_inst&lt;0b111, "add"&gt;; defm SUB : ri_inst&lt;0b101, "sub"&gt;; defm MUL : ri_inst&lt;0b100, "mul"&gt;;</span></span></code> </pre> <br>  Infolgedessen werden f√ºr jede solche Definition, die durch <code>defm</code> tats√§chlich mehrere Definitionen konstruiert, die eine Kombination aus der Hauptanweisung und allen m√∂glichen Formen sind, die in der Mehrfachklasse beschrieben sind.  In diesem Beispiel werden die folgenden Anweisungen generiert: <code>ADD_rr</code> , <code>ADD_ri</code> , <code>SUB_rr</code> , <code>SUB_ri</code> , <code>MUL_rr</code> , <code>MUL_ri</code> . <br><br>  Multiklassen k√∂nnen nicht nur Definitionen mit <code>def</code> , sondern auch verschachtelte <code>defm</code> , wodurch die Erzeugung komplexer <code>defm</code> erm√∂glicht wird.  Ein Beispiel f√ºr die Erstellung solcher Ketten finden Sie in der offiziellen Dokumentation. <br><br><h3>  Unterziele </h3><br>  Eine weitere grundlegende und n√ºtzliche Sache f√ºr Prozessoren mit unterschiedlichen Variationen des Befehlssatzes ist die Unterst√ºtzung von Unterzielen in LLVM.  Ein Beispiel f√ºr eine Verwendung ist die LLVM-SPARC-Implementierung, die drei Hauptversionen der SPARC-Mikroprozessorarchitektur gleichzeitig abdeckt: Version 8 (V8, 32-Bit-Architektur), Version 9 (V9, 64-Bit-Architektur) und UltraSPARC-Architektur.  Der Unterschied zwischen den Architekturen ist ziemlich gro√ü, eine unterschiedliche Anzahl von Registern unterschiedlichen Typs, eine unterst√ºtzte Bytereihenfolge usw.  In solchen F√§llen <code>XXXSubtarget</code> es sich, bei mehreren Konfigurationen die <code>XXXSubtarget</code> Klasse f√ºr die Architektur zu implementieren.  Die Verwendung dieser Klasse in der Beschreibung f√ºhrt zu den neuen Befehlszeilenoptionen <code>-mcpu=</code> und <code>-mattr=</code> . <br><br>  Neben der <code>Subtarget</code> Klasse selbst ist die <code>Subtarget</code> Klasse wichtig. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SubtargetFeature</span></span></span><span class="hljs-class">&lt;string n, string a, string v, string d, list&lt;SubtargetFeature&gt; i = []&gt; {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Name = n; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Attribute = a; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Value = v; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Desc = d; <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;SubtargetFeature&gt; Implies = i; }</code> </pre> <br>  In der Datei <code>Sparc.td</code> finden Sie Beispiele f√ºr die Implementierung von <code>SubtargetFeature</code> , mit denen Sie die Verf√ºgbarkeit einer Reihe von Anweisungen f√ºr jeden einzelnen Subtyp der Architektur beschreiben k√∂nnen. <br><br><pre> <code class="cpp hljs">def FeatureV9 : SubtargetFeature&lt;<span class="hljs-string"><span class="hljs-string">"v9"</span></span>, <span class="hljs-string"><span class="hljs-string">"IsV9"</span></span>, <span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-string"><span class="hljs-string">"Enable SPARC-V9 instructions"</span></span>&gt;; def FeatureV8Deprecated : SubtargetFeature&lt;<span class="hljs-string"><span class="hljs-string">"deprecated-v8"</span></span>, <span class="hljs-string"><span class="hljs-string">"V8DeprecatedInsts"</span></span>, <span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-string"><span class="hljs-string">"Enable deprecated V8 instructions in V9 mode"</span></span>&gt;; def FeatureVIS : SubtargetFeature&lt;<span class="hljs-string"><span class="hljs-string">"vis"</span></span>, <span class="hljs-string"><span class="hljs-string">"IsVIS"</span></span>, <span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-string"><span class="hljs-string">"Enable UltraSPARC Visual Instruction Set extensions"</span></span>&gt;;</code> </pre><br>  In diesem Fall definiert <code>Sparc.td</code> trotzdem die <code>Proc</code> Klasse, mit der bestimmte Untertypen von SPARC-Prozessoren beschrieben werden, die m√∂glicherweise die oben beschriebenen Eigenschaften aufweisen, einschlie√ülich verschiedener Befehlss√§tze. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Proc</span></span></span><span class="hljs-class">&lt;string Name, list&lt;SubtargetFeature&gt; Features&gt; :</span></span> Processor&lt;Name, NoItineraries, Features&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"generic"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"v8"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"supersparc"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"sparclite"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"f934"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"hypersparc"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"sparclite86x"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"sparclet"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"tsc701"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"v9"</span></span>, [FeatureV9]&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"ultrasparc"</span></span>, [FeatureV9, FeatureV8Deprecated]&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"ultrasparc3"</span></span>, [FeatureV9, FeatureV8Deprecated]&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"ultrasparc3-vis"</span></span>, [FeatureV9, FeatureV8Deprecated, FeatureVIS]&gt;;</code> </pre> <br><h2>  Beziehung zwischen den Eigenschaften von Anweisungen in TableGen und dem LLVM-Backend-Code </h2><br>  Mit den Eigenschaften von Klassen und Definitionen k√∂nnen Sie Architekturmerkmale korrekt generieren und festlegen, es besteht jedoch kein direkter Zugriff auf sie √ºber den LLVM-Backend-Quellcode.  Manchmal m√∂chten Sie jedoch in der Lage sein, einige plattformspezifische Eigenschaften von Anweisungen direkt im Compiler-Code abzurufen. <br><br><h3>  TSFlags </h3><br>  Zu diesem <code>TSFlags</code> verf√ºgt die <code>Instruction</code> Basisklasse √ºber ein spezielles <code>TSFlags</code> Feld mit einer Gr√∂√üe von 64 Bit, das von TableGen in ein Feld von C ++ - Objekten der Klasse <code>MCInstrDesc</code> , das auf der Grundlage der aus der TableGen-Beschreibung empfangenen Daten generiert wird.  Sie k√∂nnen eine beliebige Anzahl von Bits angeben, die Sie zum Speichern von Informationen ben√∂tigen.  Dies kann beispielsweise ein boolescher Wert sein, um anzuzeigen, dass wir eine skalare ALU verwenden. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">TSFlags</span></span>{<span class="hljs-number"><span class="hljs-number">0</span></span>} = <span class="hljs-type"><span class="hljs-type">SALU</span></span>;</code> </pre> <br>  Oder wir k√∂nnen die Art der Anweisung speichern.  Dann brauchen wir nat√ºrlich mehr als ein Bit. <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// Instruction type according to the ISA. IType Type = type; let TSFlags{7-1} = Type.Value;</span></span></code> </pre> <br>  Dadurch wird es m√∂glich, diese Eigenschaften aus der Anweisung im Backend-Code abzurufen. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isSALU = MI.getDesc().TSFlags &amp; SIInstrFlags::SALU;</code> </pre> <br>  Wenn die Eigenschaft komplexer ist, k√∂nnen Sie sie mit dem in TableGen beschriebenen Wert vergleichen, der der automatisch generierten Aufz√§hlung hinzugef√ºgt wird. <br><br><pre> <code class="cpp hljs">(Desc.TSFlags &amp; X86II::FormMask) == X86II::MRMSrcMem</code> </pre> <br><br><h3>  Funktionspr√§dikate </h3><br>  Au√üerdem k√∂nnen Funktionspr√§dikate verwendet werden, um die erforderlichen Informationen zu Anweisungen zu erhalten.  Mit ihrer Hilfe k√∂nnen Sie TableGen zeigen, dass Sie eine Funktion generieren m√ºssen, die entsprechend im Backend-Code verf√ºgbar ist.  Die Basisklasse, mit der Sie eine solche Funktionsdefinition erstellen k√∂nnen, ist unten dargestellt. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Base class for function predicates. class FunctionPredicateBase&lt;string name, MCStatement body&gt; { string FunctionName = name; MCStatement Body = body; }</span></span></code> </pre> <br>  Verwendungsbeispiele finden Sie leicht im Backend f√ºr X86.  Es gibt also eine eigene Zwischenklasse, mit deren Hilfe bereits die notwendigen Definitionen von Funktionen erstellt werden. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Check that a call to method `Name` in class "XXXInstrInfo" (where XXX is // the name of a target) returns true. // // TIIPredicate definitions are used to model calls to the target-specific // InstrInfo. A TIIPredicate is treated specially by the InstrInfoEmitter // tablegen backend, which will use it to automatically generate a definition in // the target specific `InstrInfo` class. // // There cannot be multiple TIIPredicate definitions with the same name for the // same target class TIIPredicate&lt;string Name, MCStatement body&gt; : FunctionPredicateBase&lt;Name, body&gt;, MCInstPredicate; // This predicate evaluates to true only if the input machine instruction is a // 3-operands LEA. Tablegen automatically generates a new method for it in // X86GenInstrInfo. def IsThreeOperandsLEAFn : TIIPredicate&lt;"isThreeOperandsLEA", IsThreeOperandsLEABody&gt;; //   -    ,  -  ,       // Used to generate the body of a TII member function. def IsThreeOperandsLEABody : MCOpcodeSwitchStatement&lt;[LEACases], MCReturnStatement&lt;FalsePred&gt;&gt;;</span></span></code> </pre> <br>  Daher k√∂nnen Sie die <code>isThreeOperandsLEA</code> Methode in C ++ - Code verwenden. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(TII-&gt;isThreeOperandsLEA(MI) || hasInefficientLEABaseReg(Base, Index)) || !TII-&gt;isSafeToClobberEFLAGS(MBB, MI) || Segment.getReg() != X86::NoRegister) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br>  Hier ist TII die <code>getInstrInfo()</code> , die mit der Methode <code>getInstrInfo()</code> vom <code>MCSubtargetInfo</code> f√ºr die gew√ºnschte Architektur abgerufen werden kann. <br><br><h2>  Transformation von Anweisungen w√§hrend Optimierungen.  Anweisungszuordnung </h2><br>  W√§hrend einer gro√üen Anzahl von Optimierungen, die in den sp√§teren Phasen der Kompilierung durchgef√ºhrt werden, entsteht h√§ufig die Aufgabe, alle oder nur einen Teil der Anweisungen eines Formulars in Anweisungen eines anderen Formulars zu konvertieren.  Angesichts der Anwendung der eingangs beschriebenen Multiklassen k√∂nnen wir eine gro√üe Anzahl von Anweisungen mit √§hnlicher Semantik und √§hnlichen Eigenschaften haben.  Im Code k√∂nnten diese Transformationen nat√ºrlich in Form gro√üer <code>switch-case</code> Konstruktionen geschrieben werden, die f√ºr jeden Befehl die entsprechende Transformation zerquetschen.  Teilweise k√∂nnen diese riesigen Konstruktionen mit Hilfe von Makros reduziert werden, die nach bekannten Regeln den notwendigen Namen der Anweisung bilden w√ºrden.  Trotzdem ist dieser Ansatz sehr unpraktisch und schwierig zu pflegen, da alle Befehlsnamen explizit aufgelistet sind.  Das Hinzuf√ºgen einer neuen Anweisung kann sehr leicht zu einem Fehler f√ºhren, weil  Sie m√ºssen daran denken, es allen relevanten Conversions hinzuzuf√ºgen.  LLVM wurde mit diesem Ansatz gequ√§lt und entwickelte einen speziellen Mechanismus, um eine Befehlsform effizient in ein anderes Befehls- <code>Instruction Mapping</code> umzuwandeln. <br><br>  Die Idee ist sehr einfach, es ist notwendig, m√∂gliche Modelle zum Transformieren von Anweisungen direkt in TableGen zu beschreiben.  Daher gibt es in LLVM TableGen eine Basisklasse zur Beschreibung solcher Modelle. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InstrMapping</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// Used to reduce search space only to the instructions using this // relation model. string FilterClass; // List of fields/attributes that should be same for all the instructions in // a row of the relation table. Think of this as a set of properties shared // by all the instructions related by this relationship. list&lt;string&gt; RowFields = []; // List of fields/attributes that are same for all the instructions // in a column of the relation table. list&lt;string&gt; ColFields = []; // Values for the fields/attributes listed in 'ColFields' corresponding to // the key instruction. This is the instruction that will be transformed // using this relation model. list&lt;string&gt; KeyCol = []; // List of values for the fields/attributes listed in 'ColFields', one for // each column in the relation table. These are the instructions a key // instruction will be transformed into. list&lt;list&lt;string&gt; &gt; ValueCols = []; }</span></span></code> </pre> <br>  Schauen wir uns ein Beispiel an, das in der Dokumentation angegeben ist.  Die Beispiele, die im Quellcode zu finden sind, sind jetzt noch einfacher, da nur zwei Spalten in der abschlie√üenden Tabelle enthalten sind.  Im Backend-Code finden Sie die Konvertierung alter Formulare in neue Anweisungsformen, dsp-Anweisungen in mmdsp usw., die mithilfe der Anweisungszuordnung beschrieben werden.  Tats√§chlich ist dieser Mechanismus bisher nicht so weit verbreitet, einfach weil die meisten Backends vor dem Erscheinen erstellt wurden. Damit er funktioniert, m√ºssen Sie immer noch die richtigen Eigenschaften f√ºr die Anweisungen festlegen. Daher ist der Wechsel zu diesem Mechanismus nicht immer einfach. M√∂glicherweise ben√∂tigen Sie einige Refactoring. <br><br>  Also zum Beispiel.  Angenommen, wir haben Formen von Anweisungen ohne Pr√§dikate und Anweisungen, bei denen das Pr√§dikat wahr bzw. falsch ist.  Wir beschreiben sie mit Hilfe einer Multiklasse und einer speziellen Klasse, die wir nur als Filter verwenden werden.  Eine vereinfachte Beschreibung ohne Parameter und viele Eigenschaften kann ungef√§hr so ‚Äã‚Äãaussehen. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PredRel</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">multiclass</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInstruction</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">BaseOpcode</span></span> = name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> { def : <span class="hljs-type"><span class="hljs-type">PredRel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">PredSense</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span>; } def _pt: <span class="hljs-type"><span class="hljs-type">PredRel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">PredSense</span></span> = <span class="hljs-string"><span class="hljs-string">"true"</span></span>; } def _pf: <span class="hljs-type"><span class="hljs-type">PredRel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">PredSense</span></span> = <span class="hljs-string"><span class="hljs-string">"false"</span></span>; } } } defm <span class="hljs-type"><span class="hljs-type">ADD</span></span>: <span class="hljs-type"><span class="hljs-type">MyInstruction</span></span>&lt;‚Äù<span class="hljs-type"><span class="hljs-type">ADD</span></span>‚Äù&gt;; defm <span class="hljs-type"><span class="hljs-type">SUB</span></span>: <span class="hljs-type"><span class="hljs-type">MyIntruction</span></span>&lt;‚Äù<span class="hljs-type"><span class="hljs-type">SUB</span></span>‚Äù&gt;; defm <span class="hljs-type"><span class="hljs-type">MUL</span></span>: <span class="hljs-type"><span class="hljs-type">MyInstruction</span></span>&lt;‚Äù<span class="hljs-type"><span class="hljs-type">MUL</span></span>‚Äù&gt;; ‚Ä¶</code> </pre> <br>  In diesem Beispiel wird √ºbrigens auch gezeigt, wie eine Eigenschaft f√ºr mehrere Definitionen gleichzeitig mit dem Konstrukt <code>let ‚Ä¶ in</code> √ºberschrieben wird.  Infolgedessen verf√ºgen wir √ºber zahlreiche Anweisungen, in denen der Basisname und die Eigenschaft gespeichert sind, die das Formular eindeutig beschreiben.  Anschlie√üend k√∂nnen Sie ein Transformationsmodell erstellen. <br><br><pre> <code class="swift hljs">def getPredOpcode : <span class="hljs-type"><span class="hljs-type">InstrMapping</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,       - PredRel  let FilterClass = "PredRel"; //         ,      let RowFields = ["BaseOpcode"]; //          PredSense. let ColFields = ["PredSense"]; //  ,  ,       ,     PredSense=‚Äù‚Äù let KeyCol = [""]; //   PredSense      let ValueCols = [["true"], ["false"]]; }</span></span></code> </pre> <br>  Infolgedessen wird aus dieser Beschreibung die folgende Tabelle generiert. <br><br><div class="scrollable-table"><table><tbody><tr><th>  PredSense = "" </th><th>  PredSense = "wahr" </th><th>  PredSense = "false" </th></tr><tr><td>  HINZUF√úGEN </td><td>  ADD_pt </td><td>  ADD_pf </td></tr><tr><td>  SUB </td><td>  SUB_pt </td><td>  SUB_pf </td></tr><tr><td>  Mul </td><td>  MUL_pt </td><td>  MUL_pf </td></tr></tbody></table></div><br>  In der <code>.inc</code> Datei wird eine Funktion generiert <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPredOpcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Opcode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">enum</span></span></span></span><span class="hljs-function"><span class="hljs-params"> PredSense inPredSense)</span></span></span></span></code> </pre> <br>  Dieser akzeptiert dementsprechend einen Anweisungscode f√ºr die Konvertierung und den Wert der automatisch generierten PredSense-Aufz√§hlung, die alle m√∂glichen Werte in den Spalten enth√§lt.  Die Implementierung dieser Funktion ist sehr einfach, weil  es gibt das gew√ºnschte Array-Element f√ºr die Anweisung zur√ºck, die f√ºr uns von Interesse ist. <br><br>  Und im Backend-Code reicht es aus, anstatt einen <code>switch-case</code> schreiben, einfach die generierte Funktion aufzurufen, die den Code der konvertierten Anweisung zur√ºckgibt.  Eine einfache L√∂sung, bei der neue Anweisungen hinzugef√ºgt werden, erfordert keine zus√§tzlichen Ma√ünahmen. <br><br><h2>  <code>.inc</code> generierte Artefakte ( <code>.inc</code> Dateien) </h2><br>  Die gesamte Interaktion zwischen der TableGen-Beschreibung und dem LLVM-Backend-Code wird durch die generierten <code>.inc</code> Dateien sichergestellt, die den C-Code enthalten.  Um ein vollst√§ndiges Bild zu erhalten, schauen wir uns an, was genau das ist. <br><br>  Nach jedem Build befinden sich f√ºr jede Architektur mehrere <code>.inc</code> Dateien im Build-Verzeichnis, in denen jeweils separate Informationen zur Architektur gespeichert sind.    <code>&lt;TargetName&gt;GenInstrInfo.inc</code> ,    , <code>&lt;TargetName&gt;GenRegisterInfo.inc</code> ,     ,           <code>&lt;TargetName&gt;GenAsmMatcher.inc</code>  <code>&lt;TargetName&gt;GenAsmWriter.inc</code>  .. <br><br>      ?      , ,    .           <code>&lt;TargetName&gt;GenInstrInfo.inc</code> . <br><br>     namespace     ,   ,   . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> X86 { <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { PHI = <span class="hljs-number"><span class="hljs-number">0</span></span>, ‚Ä¶ ADD16i16 = <span class="hljs-number"><span class="hljs-number">287</span></span>, ADD16mi = <span class="hljs-number"><span class="hljs-number">288</span></span>, ADD16mi8 = <span class="hljs-number"><span class="hljs-number">289</span></span>, ADD16mr = <span class="hljs-number"><span class="hljs-number">290</span></span>, ADD16ri = <span class="hljs-number"><span class="hljs-number">291</span></span>, ADD16ri8 = <span class="hljs-number"><span class="hljs-number">292</span></span>, ADD16rm = <span class="hljs-number"><span class="hljs-number">293</span></span>, ADD16rr = <span class="hljs-number"><span class="hljs-number">294</span></span>, ADD16rr_REV = <span class="hljs-number"><span class="hljs-number">295</span></span>, ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als n√§chstes folgt ein Array, das die Eigenschaften der Anweisungen beschreibt </font></font><code>const MCInstrDesc X86Insts[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die folgenden Arrays enthalten Informationen zu Anweisungsnamen usw. </font><font style="vertical-align: inherit;">Grunds√§tzlich werden alle Informationen in √úbertragungen und Arrays gespeichert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt auch Funktionen, die mit Pr√§dikaten beschrieben wurden. </font><font style="vertical-align: inherit;">Basierend auf der Definition der Funktionspr√§dikate, die im vorherigen Abschnitt erl√§utert wurde, wird die folgende Funktion generiert.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> X86InstrInfo::isThreeOperandsLEA(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MachineInstr &amp;MI) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(MI.getOpcode()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> X86::LEA32r: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> X86::LEA64r: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> X86::LEA64_32r: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> X86::LEA16r: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( MI.getOperand(<span class="hljs-number"><span class="hljs-number">1</span></span>).isReg() &amp;&amp; MI.getOperand(<span class="hljs-number"><span class="hljs-number">1</span></span>).getReg() != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; MI.getOperand(<span class="hljs-number"><span class="hljs-number">3</span></span>).isReg() &amp;&amp; MI.getOperand(<span class="hljs-number"><span class="hljs-number">3</span></span>).getReg() != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; ( ( MI.getOperand(<span class="hljs-number"><span class="hljs-number">4</span></span>).isImm() &amp;&amp; MI.getOperand(<span class="hljs-number"><span class="hljs-number">4</span></span>).getImm() != <span class="hljs-number"><span class="hljs-number">0</span></span> ) || (MI.getOperand(<span class="hljs-number"><span class="hljs-number">4</span></span>).isGlobal()) ) ); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// end of switch-stmt }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die generierten Dateien und Strukturen enthalten jedoch Daten. </font><font style="vertical-align: inherit;">In </font></font><code>X86GenSubtargetInfo.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">finden Sie ein Beispiel f√ºr die Struktur, die im Backend-Code verwendet werden sollte, um Informationen √ºber die Architektur zu erhalten. Im vorherigen Abschnitt stellte sich heraus, dass es sich um TTI handelt.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X86GenMCSubtargetInfo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MCSubtargetInfo { X86GenMCSubtargetInfo(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Triple &amp;TT, StringRef CPU, StringRef FS, ArrayRef&lt;SubtargetFeatureKV&gt; PF, ArrayRef&lt;SubtargetSubTypeKV&gt; PD, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MCWriteProcResEntry *WPR, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MCWriteLatencyEntry *WL, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MCReadAdvanceEntry *RA, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InstrStage *IS, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> *OC, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> *FP) : MCSubtargetInfo(TT, CPU, FS, PF, PD, WPR, WL, RA, IS, OC, FP) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolveVariantSchedClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SchedClass, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MCInst *MI, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CPUID)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> X86_MC::resolveVariantSchedClassImpl(SchedClass, MI, CPUID); } };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei Verwendung </font></font><code>Subtarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zur Beschreibung verschiedener Konfigurationen </font></font><code>XXXGenSubtarget.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird eine Aufz√§hlung mit den beschriebenen Eigenschaften unter Verwendung von </font></font><code>SubtargetFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arrays mit konstanten Werten erstellt, um die Eigenschaften und Untertypen der CPU anzugeben, und es wird eine Funktion generiert </font></font><code>ParseSubtargetFeatures</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die die Zeichenfolge mit dem Optionssatz verarbeitet </font></font><code>Subtarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dar√ºber hinaus sollte die Implementierung der Methode </font></font><code>XXXSubtarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im Backend-Code dem folgenden Pseudocode entsprechen, in dem diese Funktion verwendet werden muss:</font></font><br><br><pre> <code class="cpp hljs">XXXSubtarget::XXXSubtarget(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Module &amp;M, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;FS) { <span class="hljs-comment"><span class="hljs-comment">// Set the default features // Determine default and user specified characteristics of the CPU // Call ParseSubtargetFeatures(FS, CPU) to parse the features string // Perform any additional operations }</span></span></code> </pre> <br>   ,  <code>.inc</code>       ,       ,         .           ,    .        . <br><br><h2>  Fazit </h2><br>    TableGen  LLVM                        LLVM      .            ,       . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474460/">https://habr.com/ru/post/de474460/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474444/index.html">5 weitere gewagte Trainingsprojekte f√ºr den Entwickler (Layer, Squoosh, Rechner, Website Crawler, Music Player)</a></li>
<li><a href="../de474448/index.html">Was das Gehirn eines Studenten in der Computerwelt kann</a></li>
<li><a href="../de474450/index.html">Verwenden Sie keine l√§cherlich kleinen TTL mehr f√ºr DNS</a></li>
<li><a href="../de474452/index.html">Haxe Herbst Statusbericht</a></li>
<li><a href="../de474458/index.html">Kumulative Summe in SQL</a></li>
<li><a href="../de474462/index.html">Riesiger offener Datensatz der russischen Sprachversion 1.0</a></li>
<li><a href="../de474466/index.html">Geschichte des ersten Diablo</a></li>
<li><a href="../de474470/index.html">DDoS-Angriff auf RDP-Dienste: Erkennen und √úberwinden. Erfolgreiche Erfahrung aus Tucha</a></li>
<li><a href="../de474472/index.html">30-Punkte-UX-Checkliste f√ºr mobile Apps</a></li>
<li><a href="../de474474/index.html">Offene Benchmarks f√ºr Lasttests von Servern und Webanwendungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>