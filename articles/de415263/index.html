<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😵 😭 👩‍👧 Wie wir der Karte Eingänge hinzugefügt und die Größe der Basen um 10% reduziert haben 🐈 🤽🏿 🖌️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ende letzten Monats begann 2GIS, Veranden auszustellen. Wir zeigen die Eingänge zu Organisationen seit 2013, und die Eingänge scheinen die gleichen Ei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir der Karte Eingänge hinzugefügt und die Größe der Basen um 10% reduziert haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/2gis/blog/415263/"><img src="https://habrastorage.org/webt/en/6k/fp/en6kfpoagwhj42loeubjzo0rzo0.jpeg"><br><br>  Ende letzten Monats begann 2GIS, Veranden auszustellen.  Wir zeigen die Eingänge zu Organisationen seit 2013, und die Eingänge scheinen die gleichen Eingänge zu sein.  Warum gerade jetzt?  Alle internen Produkte und Prozesse sind fertig. Sie müssen lediglich etwas mehr hinzufügen und die Anzeige in der Benutzeroberfläche korrigieren. <br><br>  Neben der Standardantwort „Es gab andere Prioritäten“ gibt es auch eine nicht ganz Standardantwort: „Es ist nicht so einfach.“  In diesem Artikel geht es darum, welche Schwierigkeiten es gab und wie wir sie gelöst haben. <br><a name="habracut"></a><br>  Erstens ist der Eingang nicht der Eingang.  So kann in einem Eingang mehrere Eingänge führen, meist von verschiedenen Seiten des Gebäudes.  Die Definition des „(mehrstöckigen) Wohnblocks mit gemeinsamem Eingang“ ist ebenfalls falsch.  Es kommt vor, dass ein Eingang in den ersten Stock des Eingangs und der andere in den zweiten und die folgenden Stockwerke führt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zz/w7/pr/zzw7prchtb-1ictjkzvrfd6c_-8.png" alt="Eingang mit zwei Eingängen"></div><br>  Zweitens möchte ich nach Eingängen suchen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yb/ty/ut/ybtyutk7jllplorjkmqiywob1ha.png" alt="Einträge in den solchen Ereignissensen"></div><br>  Dies ist eine ziemlich gefragte Gelegenheit, da die Eingänge bei weitem nicht immer auf offensichtliche Weise angeordnet sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fm/j7/41/fmj741efgjyhdj29y3udi2lsjym.png" alt="Haus mit nicht der betreffenden eingangsnummerierung"></div><br>  Zusätzlich zu den Eingangsnummern gibt es auch Namen (normalerweise aus einem einzelnen Buchstaben). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ef/wk/2d/efwk2d9a_gsaw5vokxqoyiqzuzm.png" alt="Die Buchstaben in den Namen der Veranden"></div><br>  Oder auch wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in Kaliningrad</a> - genau der Treppe ist eine eigene Adresse zugeordnet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rw/iz/4w/rwiz4wywzkk_nnjll6xzrpy5k1o.png" alt="Interessenige Nummerierung der Eingänge in Kaliningrad"></div><br>  Drittens haben wir beschlossen, dass wir, wenn wir nach Eingängen suchen, die Suche nach Wohnungsnummer nicht sofort unterstützen sollten.  Sie entschieden - und sammelten die Wohnungen jedoch bisher ohne Bodenbindung.  Wie bei Eingängen können Wohnungen nicht nur numerische Namen haben (meistens gibt es Varianten mit dem Buchstaben „a“), und die Bereiche sind bei weitem nicht immer durchgehend.  In den alten Häusern von St. Petersburg ist die Nummerierung ziemlich seltsam: Die Wohnungen 1 und 3 können sich im selben Eingang befinden, und die Wohnung 2 kann sich im gegenüberliegenden Teil des Gebäudes befinden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m2/se/uh/m2seuh3ovc_5ob8b1ulcdlru8x8.jpeg" alt="Typischer Eingang des alten Petersburg"></div><br><div class="spoiler">  <b class="spoiler_title">Lyrischer Exkurs zur Datenvalidierung</b> <div class="spoiler_text">  Versuchen Sie nicht, die Validierung der gesammelten Daten sehr intelligent zu gestalten. In der nördlichen Hauptstadt gibt es Fälle, in denen Sie von mehreren Eingängen aus in eine Wohnung gelangen können. In einigen europäischen Siedlungen enthält die Adresse neben dem Haus den Namen des Eingangs und die Wohnungsnummer in diesem Eingang.  Peter gefällt auch mit einem Gebäude mit zwei achten Eingängen. <br></div></div><br>  Viertens möchte ich die Eingänge immer auf der Karte anzeigen, und nicht nur, wenn wir die Informationen eines bestimmten Hauses oder Eingangs studieren. <br><br>  Und schließlich gibt es viele Eingänge - nach aktueller Schätzung gibt es allein in Moskau etwa hunderttausend davon.  Die erste Bewertung „an den Fingern“ ergab einige astronomische Zahlen - wir haben alle sechs Male einen Fehler auf der größeren Seite gemacht. <br><br>  <b>Schlussfolgerungen:</b> <br><br><ul><li>  Wir brauchen eine zusätzliche Einheit, die ihren eigenen Namen hat, eine Liste von Reihen von Wohnungen enthält und an die die Eingänge des Gebäudes angeschlossen werden können. </li><li>  Wir werden nach dieser Entität suchen und ihr eine separate Informationskarte zeigen. </li><li>  Wir sind gezwungen, entweder die von der mobilen Anwendung heruntergeladenen Daten noch einmal zu vergrößern oder diese Daten nur anzuzeigen, wenn eine Netzwerkverbindung besteht, oder uns etwas mit dem Format auszudenken. </li></ul><br><h3>  Zur Lösung kommen </h3><br>  Die ersten beiden Punkte erfordern Änderungen sowohl an internen als auch an externen Produkten, dies ist jedoch eine Routine.  Letzteres ist eine ganz andere Sache.  Da wir Benutzer nicht gerne verärgern möchten, legen wir eine Einschränkung fest: Die Daten sollten offline verfügbar sein, und das Hinzufügen sollte die Größe der Datenbanken nicht erhöhen. <br><br>  Wie?  Einerseits müssen Sie die aktuelle Datengröße reduzieren, andererseits können Sie ein Format zum Speichern von Informationen über Eingänge erstellen, sodass die Menge zusätzlicher Daten minimal ist. <br><br><h3>  Datenvolumen reduzieren </h3><br>  Es gibt zwei Möglichkeiten, dies zu reduzieren: <br><br><ul><li>  Schauen Sie sich die gespeicherten Daten genau an und versuchen Sie, etwas zu finden, auf das wir verzichten können. </li><li>  Überlegen Sie, ob es möglich ist, Daten effizienter zu speichern als jetzt. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Entwicklung des Datenspeicherformats vor der Ära der Veranden</b> <div class="spoiler_text"><h4>  Die allererste und einfachste Option </h4><br>  Die herkömmliche Methode zum Speichern komplexer Daten besteht darin, sie zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">normalisieren</a> , in eine Tabellendatenbank zu stellen und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zusatzindizes zu</a> erstellen.  Einmal hat 2GIS genau das getan, außer um die Größe zu verringern. Der Inhalt jeder Tabelle wurde so sortiert, dass die Zellenwerte so oft wie möglich mit den Werten aus der vorherigen Zeile übereinstimmten.  Wir haben die Spalten unabhängig voneinander gespeichert und Sequenzen mit identischen Werten reduziert. <br><br>  Ein stark vereinfachtes Beispiel für die Optimierung der Lagerung eines Tisches mit Gebäuden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bh/jw/gy/bhjwgyi3kccb_sx2l4zho_pqlsy.png" alt="Ein Beispiel für eine optimierte Tabellenspeicherung"></div><br>  Durch die Normalisierung können Sie die Redundanz reduzieren, aber es gibt auch eine negative Seite: Um ein UI-Element für ein Objekt zu bilden, müssen Sie mehrere Abfragen durchführen, die auf eine große Anzahl von Tabellen zugreifen.  Zu dieser Zeit wurden diese Tabellen jedoch nicht nur verwendet, um Daten für die Anzeige zu erhalten, sondern für fast alle Aufgaben, einschließlich der Textsuche und verschiedener Arten der Reisesuche.  Bei all diesen Aufgaben konnten wir durch normalisierte Daten nur die Menge der verarbeiteten Informationen reduzieren. <br><br>  Die Daten zum Rendern der Karte hatten bereits ein eigenes Binärformat und wurden in einem separaten Block gespeichert.  Allmählich haben wir separate Binärformate erstellt, um die Suche nach Wegbeschreibungen und Textsuchen zu beschleunigen.  In der Datenbank blieben nur Informationen übrig, die zum Anzeigen von Objektkarten sowie zum Verknüpfen einiger Objekte mit anderen verwendet wurden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yd/4k/jh/yd4kjhjwh0pjpbj8bqmvksnqngk.png" alt="Karten und Mitteilungen"></div><br><h4>  Vereinfachen Sie die Arbeit </h4><br>  Wie können Sie die Arbeit mit Daten vereinfachen?  Erhalten Sie alle zum Zeichnen einer Karte erforderlichen Daten auf einmal über die Kennung des Objekts.  Da die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Online-Version</a> bereits alle Daten von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">API</a> für eine Anforderung im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JSON-Format</a> empfängt, können Sie gleichzeitig die von allen unseren Produkten verwendeten Formate kombinieren. <br><br>  Sowohl JSons zum Anzeigen von Karten als auch Mitteilungen müssen für eine begrenzte Anzahl von Objekten mit einer Leistung von mehreren Zehnern gleichzeitig empfangen werden.  Es gibt jedoch Szenarien, in denen einzelne Attribute für große Stichproben bis zu Hunderttausenden gleichzeitig abgerufen werden müssen.  Es ist logischer, solche Attribute in eine separate Entität mit einem separaten Speicherformat zu unterteilen - Eigenschaften.  Eigenschaften können vom Typ sein und effizienter im Binärformat gespeichert werden. <br><br>  Ein naiver Ansatz zum Speichern von json ist die Verwendung einer Schlüsselwertdatenbank.  Nehmen Sie als Beispiel Moskau als das größte unserer Projekte.  Selbst in der einfachsten Form - für jedes Objekt, das json selbst gespeichert ist, 8 Byte Bezeichner und ein Trennzeichen - benötigt das Verzeichnis 1,9 GiB.  Die resultierende Größe ist fast sechsmal größer als die zuvor beschriebene Option, und dies ist immer noch ohne Bindungen und Eigenschaften. <br><br>  Wir haben Objekte absichtlich aufgeblasen, indem wir sie mit Informationen über alles gefüllt haben, was zur Anzeige ihrer Karten erforderlich sein könnte. Sie müssen jedoch weiterhin Feldnamen, Anführungszeichen, Kommas und Klammern speichern. <br><br><h4>  Daten komprimieren </h4><br>  Normalisierung ist nicht der einzige Weg, um Redundanz zu beseitigen.  Der zweite beliebte Weg ist die Komprimierung.  Das lzma-Archiv unserer unglaublich dicken Datei benötigt nur 55 MiB. <br><br>  Natürlich können wir dieses Format nicht direkt verwenden, da wir für den Zugriff auf ein beliebiges Objekt alle zuvor gespeicherten Daten entpacken müssen und lzma-Archive nicht sehr schnell entpackt werden. <br><br>  Wie können wir einerseits einen schnellen Direktzugriff erhalten und andererseits durch Komprimieren der Daten die Größe des erforderlichen Speicherplatzes reduzieren?  Die Antwort ist, Paginierung zu verwenden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ag/lk/jr/aglkjrbolu5w7cclmf-_cuqsjly.png" alt="Binärdateien speicherformat"></div><br>  Nachdem die Daten paginiert sind, können wir sie einzeln komprimieren.  Um auf einen beliebigen Ort zugreifen zu können, müssen wir die Seite entpacken und scannen. Dies ist jedoch viel schneller als das Entpacken und Scannen des gesamten Archivs. <br><br>  In diesem Format werden alle Daten gespeichert - json'y, Beziehungen und Eigenschaften.  Diese Daten müssen noch den Kennungen der Objekte zugeordnet werden.  Für jeden Bezeichner müssen ein oder mehrere Paare <i>&lt;Speichernummer, Datennummer im Speicher&gt; gespeichert werden</i> . <br><br><img src="https://habrastorage.org/webt/7b/db/tz/7bdbtzgxk03-5c189bv4sesw7b8.png" alt="Vereinfachtes Format der Beziehungen zwischen Objektkennung und Daten in Einstellungen"><br>  Alle Seriennummern, Offsets und Größen werden in einem komprimierten Format ähnlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UTF-8</a> gespeichert, wobei kleine Werte nur ein Byte belegen.  Dies ermöglicht es uns, die Größe von Links zu reduzieren, indem wir einfach den Inhalt von binären Repositorys sortieren, um die Häufigkeit des Auftretens zu verringern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/od/9w/zv/od9wzvyv9ql8ps8g2gmmyq8njmo.png" alt="Sortieren und entferneninern"></div><br>  Einige Eigenschaften haben viele Frequenzwerte, und daher ergibt das Sortieren einen großen Größengewinn.  Andererseits kann daher die Seriennummer der Daten nicht für alle Speicher übereinstimmen. <br><br>  Weit davon entfernt, dass alle Objekte Daten in allen Speichern haben, ist das Speichern von Speichernummern effizienter als das Verweisen auf leere Objekte. <br><br><h4>  Beschleunigen Sie den Datenabruf </h4><br>  Das beschriebene Format hat ein Problem.  Um die Nummer des Objekts zu finden, in dem die Indizes für den angegebenen Bezeichner gespeichert sind, müssen wir eine binäre Suche in den Daten des ersten Objekts ausführen.  Dazu müssen Sie entweder 10,9 MiB in den Speicher laden oder 21 zusätzliche Messungen durchführen.  Beide Lösungen sind für uns nicht geeignet. Daher reduzieren wir die Anzahl der Messwerte, indem wir Daten in einem Baum speichern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8b/cx/to/8bcxto_pgnqn7drgqi5hkiae_su.png" alt="Format des Baums für die schnelle Datensuche nach Kennung"></div><br>  Wir gruppieren Daten zu 32 Objekten und speichern in den Zwischenebenen 128 der ersten Bezeichner verschachtelter Knoten.  Wir haben drei Ebenen des Baums hinzugefügt und die Anzahl der zusätzlichen Messwerte auf vier reduziert (unter Berücksichtigung des Caching zuvor gelesener Baumknoten sogar auf 1-3).  Preis - etwas weniger als 400 KiB. <br><br>  In dieser Phase können wir Beziehungen und Eigenschaften ziemlich effizient speichern, aber json nimmt viel Platz ein.  Das ist klar.  Je größer die Seite, desto mehr Objekte gelangen dorthin und desto besser kann der Komprimierungsalgorithmus feststellen, welche Informationen redundant sind.  Auf der anderen Seite müssen wir jedoch mehr Arbeit leisten, um ein einzelnes Objekt zu lesen.  Jsons sind ziemlich große Objekte, und daher gibt es nur sehr wenige davon auf einer Seite.  Daher müssen Sie dem Algorithmus helfen, seine Arbeit besser zu erledigen. <br><br><h4>  Brechen Sie json in Teile </h4><br>  Erstens haben viele Objekte übereinstimmende Datenschemata, nur Attributwerte unterscheiden sich.  Zweitens sind viele Attributwerte auch für Objekte mit unterschiedlichen Schemata gleich.  Wir werden die Schemata und Attributwerte in separate Speicher unterteilen und JSons in der folgenden Form speichern: eine Verknüpfung zu einem Schema + Verknüpfungen zu Attributwerten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pq/n8/ef/pqn8ef7v2wv7bkkvbgguql2vggq.png" alt="Jsons Aufteilung in Schema und Daten"></div><br>  In unserem Datenschema ist die Anzahl der Attributnamen begrenzt.  Wir können sie also in einer separaten Datei ablegen und stattdessen die Nummer speichern.  Wir werden auch einige weitere Änderungen vornehmen, wobei zu berücksichtigen ist, dass JSons immer Objekte sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gq/i_/ak/gqi_akxdvngmmjmgjrg60y-5luu.png" alt="Reales Format zum Bewegen von JSON-Objektschemata"></div><br>  Ja, wir haben unsere Daten im Wesentlichen selbst komprimiert, wodurch der Funktionsumfang des Algorithmus verringert wurde.  Andererseits haben wir den Zugriff auf Daten erheblich verlangsamt, und der Algorithmus hilft immer noch dabei, ähnliche in der Nähe gespeicherte Werte zu komprimieren. <br><br>  Wir haben die Seitengröße auf 1 KiB eingestellt und es stellte sich heraus, dass wir zwar das Format so optimiert haben, dass einerseits das Lesen nicht sehr langsam war und andererseits die Daten so gut wie möglich gepackt wurden, wir aber bereits die „optimierten Tabellen“ sowohl in der Größe als auch in der Größe umgangen haben für eine einfache Bedienung.  Aber nicht umsonst war das alles!  Der maximale Gewinn sollte aus der Komprimierung der Werte von Attributen, Eigenschaften und Schemata resultieren.  Wir stiften zlib an und stellen sicher, dass das Lesen von Daten aus der Datenbank vor dem Hintergrund der restlichen Arbeit wenig Zeit in Anspruch nimmt.  Mit dem Ergebnis zufrieden wechseln wir zu anderen Aufgaben. <br></div></div><br><h3>  Werde das Unnötige los </h3><br>  Wir beginnen zu reduzieren, indem wir nach Daten suchen, die Sie loswerden können.  Es stellt sich heraus, dass wir während der Existenz des Formats gelernt haben, auf die größte Verbindung zu verzichten.  Das sind 10% der Größe! <br><br>  Der Code für diese Daten war noch gebunden, aber die notwendigen Änderungen sind ziemlich trivial.  Bereits veröffentlichte Anwendungen können jedoch nicht einfach geändert werden.  Wir bemühen uns, so lange wie möglich nicht nur rückwärts, sondern auch direkt kompatibel zu bleiben.  Und wenn der erste jedem bekannt ist, denken viele glücklicherweise nicht an den zweiten.  Wir sind gezwungen, dies zu unterstützen, da die Benutzer aus verschiedenen Gründen die automatischen Updates deaktiviert haben und es nicht eilig haben, auf eine neue Version der Anwendung zu wechseln. <br><br><div class="spoiler">  <b class="spoiler_title">Benutzerverteilung nach Version</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ms/ld/kq/msldkqhkepk1gsouayqmglu36zo.png" alt="Benutzerverteilung nach Version"></div><br>  Ganz oben steht die Verteilung der Benutzer nach den neuesten Versionen der Android-Anwendung.  Unten ist iOS. <br><br>  Es ist leicht zu bemerken, dass Benutzer von iOS-Geräten viel schneller aktualisiert werden, aber selbst unter ihnen gibt es viele Benutzer älterer Versionen. <br></div></div><br>  Wir veröffentlichen auch immer noch neue Daten für die eingefrorene Version für Windows Phone.  Und obwohl WP8-Benutzer nur einen kleinen Teil unseres Publikums ausmachen, sind dies in absoluten Zahlen fast 200.000 pro Monat. <br><br>  Wir haben seit langem einen Mechanismus, mit dem wir mehrere Datenformate erstellen und automatisch bestimmen können, welche Versionen welche erhalten sollen.  Die Gelegenheit ist gut, aber Sie müssen noch lernen, wie Sie diese Formate entladen.  Die erste große Aufgabe bestand darin, einen Dienst zu implementieren, der alle Daten empfängt und den neuen für das alte Datenbankformat und den alten für das neue herausfiltert. <br><br>  Ein netter Bonus aus der geleisteten Arbeit ist die Reduzierung der Größe der monatlichen Updates, da sich die Remoteverbindung von Monat zu Monat stark geändert hat und die Größe der Diffs erhöht hat. <br><br>  Wenn Sie sich die verbleibenden Daten ansehen, können Sie insgesamt die gleichen 10% herauspressen, der Preis wird jedoch unvergleichlich höher sein.  Bisher haben wir beschlossen, nicht zu berühren. <br><br><h3>  Optimieren Sie das aktuelle Speicherformat </h3><br>  Wie oben geschrieben, haben wir 1 KiB-Seiten erstellt und nicht alle binären Repositorys gepackt. <br><br>  Das erste, was wir tun, ist zu versuchen, auch Seiten mit Links zu packen und zu überprüfen, ob der Unterschied in der Geschwindigkeit des Datenempfangs im Bereich des Fehlers liegt. <br><br>  Der nächste Punkt ist die Auswahl der optimalen Seitengröße.  Je größer die Seite ist, desto effizienter werden die Daten komprimiert, aber desto langsamer werden die Daten abgerufen.  Und wenn mit zunehmender Seitengröße die Zeit- und Speicherkosten linear ansteigen, wird der Gewinn immer weniger spürbar.  Nach den Tests beschließen wir, die Größe auf 8 KiB zu erhöhen. <br><br><div class="spoiler">  <b class="spoiler_title">Die Auswirkung der Seitengröße auf große Auswahlen</b> <div class="spoiler_text">  Wenn erwartet wird, dass die Seitenvergrößerung kleine Auswahlen verlangsamt, werden große - aus Hunderten von Elementen - sogar beschleunigt.  Dies bedeutet, dass Sie in guter Weise je nach Anwendungsfall der darin gespeicherten Daten unterschiedliche Größen für Speicher auswählen müssen. <br></div></div><br>  Insgesamt können nur diese beiden Punkte die Basis um 18% reduzieren! <br><br><h3>  Ändern Sie das Komprimierungsformat </h3><br>  zlib ist natürlich ein Klassiker, aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zstd</a> bietet eine höhere Dekomprimierungsgeschwindigkeit bei einem höheren Komprimierungsverhältnis.  Darüber hinaus können Sie mit zstd zunächst ein einziges Wörterbuch für alle verfügbaren Daten erstellen, diese dann einmal speichern und mit allen Seiten komprimieren.  Auf diese Weise verlangsamen wir den Prozess des Erstellens einer Datei mit einer Datenbank erheblich, drücken jedoch weitere 8% aus. <br><br><h3>  Veranden hinzufügen </h3><br><h4>  Einfacher Weg </h4><br>  Am einfachsten ist es, jeden Eingang zu einem separaten Objekt zu machen, sie separat zu indizieren (nach groben Schätzungen + 10% der Indexgröße) und ihre Geometrie separat in den Daten zum Zeichnen der Karte zu speichern. <br><br>  Diese Methode erhöht die Basis um insgesamt 3%.  In den vorherigen Phasen haben wir mehr als genug gewonnen, um uns zu beruhigen und mit den Eingängen nach dem üblichen Schema zu arbeiten, aber ... zum Zeitpunkt des Arbeitsbeginns waren wir uns nicht sicher, und die Arbeit an einem alternativen Format verlief parallel. <br><br><div class="spoiler">  <b class="spoiler_title">Detaillierte Bewertung für Interessierte</b> <div class="spoiler_text">  Versuchen wir, die Zunahme der Größe des Pakets mit der Datenbank für jedes Objekt zu bewerten: <br><br>  8 Bytes - Kennung, <br>  6 Bytes - Anzahl der verwendeten Speicher (Daten + fünf Eigenschaften; Eigenschaften werden aus den Hauptdaten extrahiert und in binärer Form gespeichert, da sie häufig für eine große Anzahl von Objekten gleichzeitig benötigt werden). <br>  3 Bytes - Index im Data Warehouse, <br>  2 Bytes - Offsetdaten des Objekts, <br>  5 Bytes - Datenwerte - 2 Bytes pro Schaltung, durchschnittlich 3 Bytes für Wohnungsinformationen (wir glauben, dass es viele Duplikate geben wird und die Daten selbst einmal gespeichert werden), <br>  6 Bytes - Offset-Datenkoordinaten (andere Eigenschaften haben viele doppelte Werte und werden reduziert), <br>  8 Bytes - Koordinatenwerte. <br><br>  Insgesamt 38 Bytes pro Objekt.  Im Fall von Moskau sind dies 4,5 MiB für mehr als 124.000 gesammelte Inputs. <br><br>  Als nächstes müssen wir auch die Verbindung zwischen dem Haus und den Eingängen speichern, es sind 2,5 Bytes für jedes Wohnhaus und 8 Bytes für jeden Eingang.  1 weitere MiB. <br><br>  Nun überlegen wir, wie viel dies alles auf der Karte kosten wird. <br><br>  Zuerst müssen wir die Geometrie speichern.  Bei Polylinien benötigt der erste Punkt immer 8 Bytes, und alle nachfolgenden werden als Unterschiede der erforderlichen Genauigkeit gespeichert.  Hier sind wir mit der Genauigkeit auf Dezimeter zufrieden.  Die meisten Eingaben bestehen aus zwei Punkten, die nicht sehr weit voneinander entfernt sind. Daher kann davon ausgegangen werden, dass die Geometrie selbst 10 Byte belegt.  Insgesamt 1,2 MiB. <br><br>  Wir müssen auch die Eingabe-ID und das Objekt mit seiner Geometrie verknüpfen.  Ein Index ist der gleiche Binärspeicher wie alles andere, nur das Kommunikationsziel (1 Byte), die Schichtnummer (1 Byte) und die Objektnummer (3 Byte) werden gespeichert.  Plus 8 Bytes pro Bezeichner sowie ein Schnellsuchbaum.  Insgesamt weitere 1,5 MiB. <br><br>  Wie bereits am Anfang des Artikels erwähnt, möchten wir die Eingänge ständig auf der Karte anzeigen. Der einfachste Weg, dies zu tun, besteht darin, eine weitere Ebene mit Punkten zu entladen. Sie können die Ebene jedoch auch mit Geometrien wiederverwenden und ein neues <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Symbol</a> erstellen, das das benötigte Bild anzeigt am letzten Punkt der Polylinie. <br><br>  10% des Suchindex sind 5,9 MiB.  Zusammenfassend erhalten wir 14,2 MiB, was nur etwas mehr als 3% entspricht. <br></div></div><br><h4>  Aktuelle Option </h4><br>  Anstatt die Eingänge zu indizieren und den Suchindex aufzublähen, suchen wir nach Häusern, markieren aber zusätzlich die Abfragewörter und wählen daraus Adressen (relevant für die Suche nach Eingängen in Kaliningrad), Eingänge und / oder Wohnungen aus.  So haben wir am Ausgang die Hauskennung und eingegebene Textfelder, über die wir die Treppe finden müssen, die wir brauchen. <br><br><div class="spoiler">  <b class="spoiler_title">Hinweis</b> <div class="spoiler_text">  Dies ist ein kontroverser Punkt.  Auf der einen Seite können wir die Größe der Datenbank reduzieren, auf der anderen Seite wird das Eingabeformat eingeschränkt - die Eingänge werden nicht auf viele Anfragen übertragen, die mit einer ehrlichen Suche korrekt verarbeitet würden. <br></div></div><br>  Anstatt einzelne Objekte zu entladen, fügen wir alle Informationen zu den Eingängen direkt in die Gebäudedaten ein. <br>  Und schließlich übertragen wir einen Teil der Geometrien in das Verzeichnis. <br><br>  Letzteres ist näher zu erläutern. <br><br>  Erstens stellen wir fest, dass die meisten Eingaben zwei Punkte sind und dieselbe Länge haben.  Solche Eingaben können in Form eines Punktes + einer Richtung gespeichert werden, d.h.  Speichern Sie 1 Byte pro Eingabe. <br><br>  Zweitens nehmen wir an, dass die meisten Häuser in modernen Städten typisch sind, daher werden die Verschiebungen der Punkte ihrer Eingänge relativ zum Mittelpunkt des Hauses bis zu einer Wende zusammenfallen. <br><br>  Wir haben bereits die zentralen Punkte der Gebäude.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist, wenn wir eine neue Eigenschaft für das Gebäude hinzufügen - seine ganzzahlige "Richtung" und für jede Eingabe zwei weitere - ganzzahlige Offsets in Dezimetern entlang und senkrecht zur Richtungslinie? Wenn man bedenkt, wie wir JSons mit Informationen speichern, belegt die Eingabegeometrie im Durchschnitt etwas mehr als zwei Bytes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein zusätzlicher Bonus ist, dass wir die Korrespondenz zwischen der Eingabe-ID und der Objektnummer nicht mehr in der Kartenebene speichern müssen, da sich die Geometrie im Verzeichnis befindet.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minus - der Code ist komplizierter geworden. </font><font style="vertical-align: inherit;">Früher haben wir der Karte nur gesagt, dass "solche und solche Objekte anzeigen" sollen, und jetzt, wenn wir die Eingaben anzeigen, extrahieren wir diese Daten aus json und fügen der Karte dynamische Objekte hinzu. </font><font style="vertical-align: inherit;">Hier ist nicht alles sehr beängstigend. </font><font style="vertical-align: inherit;">Zum Zeitpunkt der Anzeige der Pfeiltasten der JSON-Eingaben haben wir bereits die entsprechenden Objekte, dh es ist nicht erforderlich, zusätzlich zur Datenbank zu wechseln. </font><font style="vertical-align: inherit;">Mit den angezeigten Einstiegspunkten ist alles etwas schlechter - jetzt müssen wir im Hintergrund bestimmen, welche Häuser sichtbar sind, die Daten dieser Häuser aus der Datenbank herausziehen, JSons zerlegen und, wenn es Eingaben gibt, dynamische Objekte für sie erstellen.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis</font></font></b> <div class="spoiler_text">  .              ,     ,     0,2% (972   ). <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir bereits zusätzlichen Code geschrieben haben, um die Eingänge zu den Eingängen anzuzeigen, hindert uns nichts daran, Zweipunkteingaben in der Organisation im Verzeichnis zu speichern. </font><font style="vertical-align: inherit;">Der Gewinn ist in diesem Fall gering, aber kostenlos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie viel hat es uns gegeben? </font><font style="vertical-align: inherit;">Aus 3% wurden 0,5%. </font><font style="vertical-align: inherit;">Wir hätten noch weniger tun können, aber wir haben Bezeichner in den Daten belassen (die ziemlich schlecht komprimiert sind), um die Verarbeitung von Benutzernachrichten über ungenaue Eingaben zu vereinfachen.</font></font><br><br><h3>  Ergebnis </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben eine große Anzahl von Eingängen hinzugefügt, während wir die Größe der Datei mit Kartendaten um 0,5% und die Größe der Datei mit den Verzeichnisdaten um 26,6% reduziert haben. </font><font style="vertical-align: inherit;">Letzteres ist immer noch die größte unserer Dateien, aber es ist nur eine der vier „schweren“ Dateien, sodass sich die Gesamtänderung als bescheidener herausstellte - 10,1%.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/s8/p-/_v/s8p-_vjsi9mgzymzwusfn4vsz6g.png" alt="Ändern Sie die Größe der Moskauer Basis im Laufe der Zeit"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Eingänge sind noch nicht abgeholt. </font><font style="vertical-align: inherit;">Die Größe der Stützpunkte wird im Laufe der Zeit etwas zunehmen (nach aktuellen Schätzungen wird das gleiche Moskau um 0,4% zunehmen), aber auf jeden Fall ist das Ziel, die Eingänge freizugeben, ohne die Größe zu erhöhen, mehr als erreicht.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Was weiter? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir über Verbesserungen bei Lebensmitteln sprechen, werden wir die Eingänge und Wohnungen in den Suchtipps sowie bei der Suche nach den Start- und Endpunkten der Suche nach Wegbeschreibungen unterstützen. </font><font style="vertical-align: inherit;">Wir denken auch darüber nach, wichtige Eingänge zu Gebäuden (hauptsächlich in Einkaufszentren) wie Veranden anzuzeigen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In technischen Plänen werden mehrere Ideen überprüft, die zu einer weiteren Reduzierung der Dateigröße mit Referenzdaten führen können, und Sie müssen andere Dateien sorgfältig prüfen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und natürlich werden wir die Fehler korrigieren, die wir bisher haben.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Noch ein Gedanke: Verwenden Sie JSON mit Bedacht </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aus dem oben Gesagten ergibt sich die Schlussfolgerung, dass Sie nicht zu viel über Binärformate nachdenken und einfach JSON verwenden können. </font></font> Dies ist nicht ganz richtig.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das funktioniert bei uns, weil wir gleichzeitig mehrere zehn Objekte von der Kraft erhalten müssen. </font><font style="vertical-align: inherit;">Außerdem verwenden wir Rapidjson, und es ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehr intelligent</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und verbraucht wenig Speicher. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es lohnt sich auch, die Übertragung von JSON-Daten von C ++ auf die Benutzeroberfläche, die in einer anderen Sprache geschrieben sind, einzuschränken. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuerst müssen Sie es in eine Zeichenfolge verwandeln. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweitens werden die im UI-Teil verfügbaren Parser diese Zeile wieder zusammensetzen und dies viel langsamer tun. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist besser, alle Daten von JSON selbst abzurufen und einfache Schnittstellen zu verwenden, die so angepasst sind, dass bestimmte Elemente auf der Benutzeroberfläche angezeigt werden.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415263/">https://habr.com/ru/post/de415263/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415253/index.html">Fotografien aus dem 19. Jahrhundert wurden mithilfe der Technologie des 21. Jahrhunderts restauriert</a></li>
<li><a href="../de415255/index.html">Roskosmos kündigte die Beendigung der Flüge von Protonenraketen an</a></li>
<li><a href="../de415257/index.html">8 Möglichkeiten zur Verbesserung der Datenvisualisierung</a></li>
<li><a href="../de415259/index.html">select / poll / epoll: praktischer Unterschied</a></li>
<li><a href="../de415261/index.html">VFX-Künstler in der Spieleentwicklung: Features, Karriere, Entwicklung</a></li>
<li><a href="../de415265/index.html">Auf der Suche nach einem Nachfolger des KL-7: RACE und AROFLEX</a></li>
<li><a href="../de415269/index.html">Funktionsweise von JS: Abstrakte Syntaxbäume, Analyse und deren Optimierung</a></li>
<li><a href="../de415271/index.html">Wie Gantt-Diagramme das Projektmanagement vereinfachen</a></li>
<li><a href="../de415273/index.html">Erlernen der Grundlagen der Programmierung</a></li>
<li><a href="../de415275/index.html">Das Buch "C # 7 und .NET Core. Plattformübergreifende Entwicklung für Profis. 3. Auflage</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>