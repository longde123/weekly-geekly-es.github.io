<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüî¨ ü§ì üöû Fort Byte Car (e mais) Nativo Americano ü§µüèº ‚úäüèø üéÖüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sim, sim, √© o "byte" e est√° em indiano (n√£o indiano). Vou come√ßar em ordem. Recentemente aqui, em Habr√©, come√ßaram a aparecer artigos sobre bytecode. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fort Byte Car (e mais) Nativo Americano</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431932/"><img src="https://habrastorage.org/getpro/habr/post_images/dbb/a59/e93/dbba59e932ecdb4b0c28896a7e6fc3e3.jpg" alt="imagem"><br><br>  Sim, sim, √© o "byte" e est√° em indiano (n√£o indiano).  Vou come√ßar em ordem.  Recentemente aqui, em Habr√©, come√ßaram a aparecer artigos sobre bytecode.  E uma vez eu me diverti escrevendo sistemas Fort.  Claro, em assembler.  Eles eram de 16 bits.  Eu nunca programei no x86-64.  Mesmo com 32 n√£o podia jogar.  Ent√£o surgiu o pensamento - por que n√£o?  Por que n√£o agitar o forte de 64 bits e at√© com o bytecode?  Sim, e no Linux, onde eu tamb√©m n√£o escrevi nada no sistema. <br><br>  Eu tenho um servidor dom√©stico com Linux.  Em geral, pesquisei um pouco e descobri que o assembler no Linux se chama GAS e o comando as.  Estou conectando via SSH ao servidor, digitando como - sim!  Eu j√° o tenho instalado.  Ainda precisa de um vinculador, digite ld - sim!  Ent√£o, e tente escrever algo interessante no assembler.  Sem civiliza√ß√£o, apenas uma floresta, como √≠ndios reais :) Sem um ambiente de desenvolvimento, apenas uma linha de comando e Midnight Commander.  O editor ser√° o Nano, que fica no meu F4 em mc.  Como o grupo ‚ÄúZero‚Äù est√° cantando?  Um verdadeiro indiano precisa de apenas uma coisa ... O que mais um verdadeiro indiano precisa?  Claro, um depurador.  Digitamos gdb - is!  Bem, pressione Shift + F4 e pronto! <br><a name="habracut"></a><br><h2>  Arquitetura </h2><br>  Para iniciantes, vamos decidir sobre arquitetura.  Com profundidades de bits j√° determinadas, 64 bits.  Nas implementa√ß√µes cl√°ssicas do Fort, os dados e o segmento de c√≥digo s√£o os mesmos.  Mas, tentaremos fazer o certo.  Teremos apenas o c√≥digo no segmento de c√≥digo, os dados no segmento de dados.  Como resultado, obtemos um kernel para a plataforma e um c√≥digo de bytes completamente independente da plataforma. <br><br>  Vamos tentar fazer a m√°quina de bytes empilhados mais r√°pida (mas sem JIT).  Portanto, teremos uma tabela contendo 256 endere√ßos - um para cada comando de byte.  Menos do que tudo - uma verifica√ß√£o extra, estas s√£o 1-2 instru√ß√µes do processador.  E precisamos rapidamente, sem compromisso. <br><br><h4>  Pilhas </h4><br>  Geralmente, nas implementa√ß√µes Fort, a pilha de retorno do processador (* SP) √© usada como uma pilha de dados e a pilha de retorno do sistema fort √© implementada usando outros meios.  De fato, nossa m√°quina ser√° empilhada e o trabalho principal est√° na pilha de dados.  Portanto, vamos fazer o mesmo - o RSP ser√° uma pilha de dados.  Bem, deixe a pilha de retorno ser RBP, que tamb√©m, por padr√£o, funciona com o segmento de pilha.  Assim, teremos tr√™s segmentos de mem√≥ria: um segmento de c√≥digo, um segmento de dados e um segmento de pilha (ele ter√° uma pilha de dados e uma pilha de retorno). <br><br><h4>  Registros </h4><br>  Entro na descri√ß√£o dos registros x86-64 e oops!  Existem at√© 8 registradores de uso geral adicionais (R8 - R16), comparados aos modos de 32 ou 16 bits ... <br><br>  J√° decidiram que precisar√£o de RSP e RBP.  Ainda precisa de um ponteiro (contador) dos comandos do bytecode.  Das opera√ß√µes nesse registro, apenas a leitura da mem√≥ria √© necess√°ria.  Os principais registradores (RAX, RBX, RCX, RDX, RSI, RDI) s√£o mais flex√≠veis, universais, com eles existem muitos comandos especiais.  Eles nos ser√£o √∫teis para v√°rias tarefas e, para o contador de instru√ß√µes de bytecode, levamos um dos novos registros para mim, seja R8. <br><br><h2>  Vamos come√ßar </h2><br>  N√£o tenho experi√™ncia em programa√ß√£o no Linux em linguagem assembly.  Portanto, para iniciantes, encontraremos o "Ol√°, mundo" finalizado para entender como o programa inicia e exibe o texto.  Inesperadamente, para mim, encontrei op√ß√µes com uma sintaxe estranha, na qual at√© a fonte e o receptor s√£o reorganizados.  Como se viu, esta √© a sintaxe da AT&amp;T, e est√° principalmente escrita sob GAS.  Mas h√° outra op√ß√£o de sintaxe, chamada de sintaxe Intel.  Pensando, decidi us√°-lo da mesma forma.  Bem, escreva no in√≠cio de .intel_syntax noprefix. <br><br>  Compile e execute "Ol√°, mundo" para garantir que tudo funcione.  Lendo a ajuda e os experimentos, comecei a usar o seguinte comando para compilar: <br> <code>$ as fort.asm -o fort.o -g -ahlsm &gt;list.txt</code> <br>  Aqui, a op√ß√£o -o indica o arquivo de resultado, a op√ß√£o -g instrui a gerar informa√ß√µes de depura√ß√£o e a op√ß√£o -ahlsm define o formato da listagem.  E eu mantenho a sa√≠da na lista, nela voc√™ pode ver muitas coisas √∫teis.  Admito que no in√≠cio do trabalho n√£o fiz a listagem e nem especifiquei a op√ß√£o -g.  Comecei a usar a op√ß√£o -g ap√≥s o primeiro uso do depurador e comecei a fazer a listagem ap√≥s as macros aparecerem no c√≥digo :) <br><br>  Depois disso, usamos o vinculador, mas aqui n√£o √© mais simples: <br><br> <code>$ ld forth.o -o forth</code> <br>  Bem, corra! <br> <code>$ ./forth <br> Hello, world!</code> <br>  Isso funciona. <br><br><div class="spoiler">  <b class="spoiler_title">Este foi o primeiro quarto.asm (na verdade √© 'Hellow, mundo!', √â claro)</b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix .section .data msg: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> len = . - msg #  len    .section .text .global _start #     _start: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, OFFSET FLAT:msg #     mov edx, len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit xor ebx, ebx #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #  </code> </pre> <br>  A prop√≥sito, descobri mais tarde que no x86-64 √© mais correto usar o syscall para uma chamada do sistema, em vez de int 0x80.  A chamada 0x80 √© considerada obsoleta para essa arquitetura, embora seja suportada. <br></div></div><br>  Um come√ßo foi feito, e agora ... <br><br><h2>  Vamos l√°! </h2><br>  Como haveria pelo menos algumas especificidades, escreveremos o c√≥digo de um comando de byte.  Que seja a palavra Fort "0", colocando 0 no topo da pilha: <br><br><pre> <code class="cpp hljs">bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next</code> </pre><br>  No momento em que esse comando √© executado, o R8 j√° aponta para o pr√≥ximo comando de byte.  √â necess√°rio l√™-lo, aumentar R8, determinar o endere√ßo execut√°vel pelo c√≥digo do comando byte e transferir o controle para ele. <br><br>  Mas ... qual ser√° a profundidade de bits da tabela de endere√ßos de comando de bytes?  Ent√£o eu tive que cavar o novo sistema de comando x86-64 para mim.  Infelizmente, n√£o encontrei comandos que permitam que voc√™ v√° para o deslocamento na mem√≥ria.  Portanto, calcule o endere√ßo ou o endere√ßo estar√° pronto - 64 bits.  N√£o h√° tempo para calcular, o que significa - 64 bits.  Nesse caso, o tamanho da tabela ser√° 256 * 8 = 4096 bytes.  Bem, finalmente, codifique a chamada _next: <br><br><pre> <code class="cpp hljs">_next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-meta"><span class="hljs-meta"># bcmd -   -</span></span></code> </pre><br>  Nada mal, parece-me ... Existem apenas tr√™s instru√ß√µes do processador, ao alternar de um comando de byte para outro. <br><br>  Na verdade, esses comandos n√£o foram t√£o f√°ceis para mim.  Eu tive que me aprofundar no sistema de comando 0x86-64 novamente e encontrar um novo comando MOVZX para mim.  De fato, este comando converte um valor de 8, 16 ou 32 bits em um registro de 64 bits.  Existem duas variantes desse comando: n√£o assinado, onde os d√≠gitos mais altos s√£o preenchidos com zeros e o assinado √© o MOVSX.  Na vers√£o assinada, o sinal se expande, ou seja, para n√∫meros positivos, os zeros v√£o para os d√≠gitos mais altos e, para os negativos, para os d√≠gitos.  Essa op√ß√£o tamb√©m √© √∫til para o comando lit byte. <br><br>  A prop√≥sito, essa op√ß√£o √© a mais r√°pida?  Talvez algu√©m sugira ainda mais r√°pido? <br><br>  Bem, agora temos uma m√°quina de bytes que pode executar uma sequ√™ncia de comandos de bytes e execut√°-los.  √â necess√°rio test√°-lo na pr√°tica, for√ßar a execu√ß√£o de pelo menos uma equipe.  Mas qual?  Zero na pilha?  Mas aqui voc√™ nem sabe o resultado, se voc√™ n√£o olhar para a pilha no depurador ... Mas se o programa for iniciado, ele poder√° ser conclu√≠do :) <br><br>  N√≥s escrevemos um comando de tchau que completa o programa e escreve sobre ele, especialmente porque temos ‚ÄúHellow, world!‚Äù. <br><br><pre> <code class="cpp hljs">bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #  </code> </pre><br>  A √∫nica coisa que resta √© criar uma tabela de endere√ßos de comando de byte, inicializar os registradores e iniciar a m√°quina de bytes.  Ent√£o ... a tabela tem 256 valores e existem dois comandos.  O que h√° nas outras c√©lulas? <br>  O restante ter√° um c√≥digo de opera√ß√£o inv√°lido.  Mas voc√™ n√£o pode verificar, s√£o equipes extras, agora temos tr√™s e, com a verifica√ß√£o, ser√£o cinco.  Ent√£o, faremos um comando como esse - uma equipe ruim.  Primeiro, preenchemos a tabela inteira e come√ßamos a ocupar as c√©lulas com comandos √∫teis.  Deixe o time ruim ter o c√≥digo 0x00, o time bye - 0x01, e o '0' ter√° o c√≥digo 0x02, uma vez que j√° esteja escrito.  Por enquanto, a equipe ruim far√° o mesmo que o adeus, apenas com um c√≥digo e texto de conclus√£o diferentes (eu o colocarei no spoiler, quase o mesmo que o adeus): <br><br><div class="spoiler">  <b class="spoiler_title">bcmd_bad</b> <div class="spoiler_text"><pre> <code class="cpp hljs">bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #  </code> </pre> </div></div>  Agora desenhe uma tabela de endere√ßos.  Por conveni√™ncia, colocaremos oito em cada linha, haver√° 16. A tabela √© bastante grande em tamanho: <br><br><div class="spoiler">  <b class="spoiler_title">Tabela de Endere√ßo do Comando Byte</b> <div class="spoiler_text"><pre> <code class="cpp hljs">bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad</code> </pre> </div></div>  N√≥s escrevemos o corpo do programa de bytes.  Para fazer isso, atribua c√≥digos de comando √†s vari√°veis ‚Äã‚Äãdo assembler.  Teremos os seguintes acordos: <br><br><ul><li>  Os endere√ßos para executar comandos de byte come√ßar√£o em bcmd_ </li><li>  Os c√≥digos de comando em si ser√£o armazenados em vari√°veis ‚Äã‚Äãcome√ßando com b_ </li></ul><br>  Assim, o corpo do programa de bytes ser√° assim: <br><br><pre> <code class="cpp hljs">start: .byte b_bye</code> </pre><br>  Declare o tamanho da pilha de dados como stack_size.  Que seja at√© agora 1024. Na inicializa√ß√£o, faremos RBP = RSP - stack_size. <br><br><div class="spoiler">  <b class="spoiler_title">Na verdade, obtemos um c√≥digo de programa (adiante.asm)</b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye msg_hello: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> msg_hello_len = . - msg_hello bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_bye .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start jmp _next _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_num0 = <span class="hljs-number"><span class="hljs-number">0x02</span></span> bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next</code> </pre><br></div></div><br>  Compilar, execute: <br><br> <code>$ as fort.asm -o fort.o -g -ahlsm &gt;list.txt <br> $ ld forth.o -o forth <br> $ ./forth <br> bye! <br></code> <br>  Isso funciona!  Nosso primeiro programa de bytecode de um byte foi lan√ßado :) <br>  Obviamente, ser√° assim se tudo for feito corretamente.  E se n√£o, ent√£o o resultado provavelmente ser√° este: <br><br> <code>$ ./forth <br>   <br></code> <br>  Claro, outras op√ß√µes s√£o poss√≠veis, mas eu me deparei com isso com mais frequ√™ncia.  E precisamos de um depurador. <br><br><div class="spoiler">  <b class="spoiler_title">Letra da m√∫sica Debugger</b> <div class="spoiler_text">  Como j√° mencionado, usei o GDB.  Este √© um depurador bastante poderoso, mas com uma interface de linha de comando.  Execut√°-lo √© muito simples: <br><br><pre> <code class="plaintext hljs">$ gdb ./forth GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1 Copyright (C) 2016 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type "show copying" and "show warranty" for details. This GDB was configured as "x86_64-linux-gnu". Type "show configuration" for configuration details. For bug reporting instructions, please see: &lt;http://www.gnu.org/software/gdb/bugs/&gt;. Find the GDB manual and other documentation resources online at: &lt;http://www.gnu.org/software/gdb/documentation/&gt;. For help, type "help". Type "apropos word" to search for commands related to "word"... Reading symbols from ./forth...done. (gdb)</code> </pre> <br>  Em seguida, inserindo comandos, n√≥s depuramos.  Tive horas suficientes para encontrar alguns comandos necess√°rios e aprender a us√°-los para depura√ß√£o.  Aqui est√£o elas: <br>  b &lt;r√≥tulo&gt; - define um ponto de interrup√ß√£o <br>  l &lt;label&gt; - exibir c√≥digo fonte <br>  r - inicia ou reinicia o programa <br>  ir - visualizar status de registros do processador <br>  s - passo <br><br>  A prop√≥sito, lembre-se de que voc√™ precisa compilar o programa com a op√ß√£o -g?  Caso contr√°rio, as tags e o c√≥digo-fonte n√£o estar√£o dispon√≠veis.  Nesse caso, ser√° poss√≠vel depurar apenas por c√≥digo desmontado e usar os endere√ßos na mem√≥ria.  N√≥s, √© claro, somos √≠ndios, mas n√£o na mesma medida ... </div></div><br>  Mas de alguma forma o programa faz muito pouco.  N√≥s apenas dizemos "Ol√°" para ela, e ela imediatamente diz "Tchau!".  Vamos fazer o verdadeiro "Ol√°, mundo!"  no bytecode.  Para fazer isso, coloque o endere√ßo e o comprimento da string na pilha, execute o comando que exibe a string e, em seguida, o comando bye.  Para fazer tudo isso, novos comandos s√£o necess√°rios: digite para gerar a sequ√™ncia e acenda para colocar o endere√ßo e o comprimento da sequ√™ncia.  Primeiro, escrevemos o tipo, deixe seu c√≥digo ser 0x80.  Novamente, precisamos desse peda√ßo de c√≥digo com a chamada sys_write: <br><br><pre> <code class="cpp hljs">b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rcx push r8 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   pop r8 jmp _next</code> </pre><br>  Aqui pegamos o endere√ßo e o comprimento da string da pilha de dados usando comandos POP.  Chamar int 0x80 pode alterar o registro de R8, ent√£o n√≥s o salvamos.  N√≥s n√£o fizemos isso antes porque o programa estava terminando.  O conte√∫do desses registros n√£o se importava.  Agora, este √© um comando de byte comum, ap√≥s o qual o c√≥digo de byte continua sendo executado e voc√™ precisa se comportar. <br><br>  Agora vamos escrever o lit.  Esta ser√° a nossa primeira equipe com par√¢metros.  Ap√≥s o byte com o c√≥digo para este comando, haver√° bytes contendo o n√∫mero que ele colocar√° na pilha.  A pergunta surge imediatamente - que profundidade de bit √© necess√°ria aqui?  Para colocar qualquer n√∫mero, voc√™ precisa de 64 bits.  Mas, cada vez que o comando ocupar√° 9 bytes, o que colocaria um n√∫mero?  Perdemos a compacta√ß√£o, uma das principais propriedades do bytecode, e o c√≥digo do forte tamb√©m ... <br><br>  A solu√ß√£o √© simples - faremos v√°rios comandos para diferentes profundidades de bits.  Estes ser√£o lit8, lit16, lit32 e lit64.  Para n√∫meros pequenos, usaremos lit8 e lit16, para n√∫meros maiores - lit32 e lit64.  N√∫meros pequenos s√£o mais comumente usados ‚Äã‚Äãe, para eles, ser√° o comando mais curto, que leva dois bytes.  Nada mal! .. Vamos criar os c√≥digos desses comandos 0x08 - 0x0B. <br><br><pre> <code class="cpp hljs">b_lit8 = <span class="hljs-number"><span class="hljs-number">0x08</span></span> bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> bcmd_lit16: movsx rax, word ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> push rax jmp _next b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> bcmd_lit32: movsx rax, dword ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> push rax jmp _next b_lit64 = <span class="hljs-number"><span class="hljs-number">0x0B</span></span> bcmd_lit64: mov rax, [r8] add r8, <span class="hljs-number"><span class="hljs-number">8</span></span> push rax jmp _next</code> </pre> <br>  Aqui usamos o comando MOVSX - esta √© uma vers√£o ic√¥nica do comando MOVZX j√° conhecido por n√≥s.  R8, temos um contador de comandos de bytes.  Carregamos nele o valor do tamanho desejado, movemos para o pr√≥ximo comando e colocamos o valor convertido em 64 bits na pilha. <br><br>  <b>N√£o se esque√ßa de adicionar os endere√ßos das novas equipes na tabela √†s posi√ß√µes desejadas.</b> <br><br>  Est√° tudo pronto para escrever seu primeiro programa "Ol√°, mundo!"  no nosso bytecode.  Vamos trabalhar com o compilador!  :) <br><br><pre> <code class="cpp hljs">start: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_bye</code> </pre> <br>  Usamos dois comandos iluminados diferentes: lit64, que colocaria o endere√ßo da string na pilha, e lit8, com o qual colocamos o comprimento na pilha.  Em seguida, executamos mais dois comandos de byte: type e bye. <br>  Compilar, execute: <br><br><pre> <code class="plaintext hljs">$ as fort.asm -o fort.o -g -ahlsm &gt;list.txt $ ld forth.o -o forth $ ./forth Hello, world! bye!</code> </pre><br>  Ganhou nosso bytecode!  Este √© o resultado que deve ser, se estiver tudo bem. <br><br><div class="spoiler">  <b class="spoiler_title">Fonte completa</b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye msg_hello: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> msg_hello_len = . - msg_hello bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x00</span></span> .quad bcmd_lit8, bcmd_lit16, bcmd_lit32, bcmd_lit64, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x10</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x20</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x30</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x40</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x60</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_type, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x80</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_bye .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start jmp _next _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_num0 = <span class="hljs-number"><span class="hljs-number">0x02</span></span> bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next b_lit8 = <span class="hljs-number"><span class="hljs-number">0x08</span></span> bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> bcmd_lit16: movsx rax, word ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> push rax jmp _next b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> bcmd_lit32: movsx rax, dword ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> push rax jmp _next b_lit64 = <span class="hljs-number"><span class="hljs-number">0x0B</span></span> bcmd_lit64: mov rax, [r8] add r8, <span class="hljs-number"><span class="hljs-number">8</span></span> push rax jmp _next b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rcx push r8 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   pop r8 jmp _next</code> </pre> <br></div></div><br>  Mas as possibilidades ainda s√£o muito primitivas, voc√™ n√£o pode criar uma condi√ß√£o, um ciclo. <br><br>  Como n√£o?  Voc√™ pode, tudo est√° em nossas m√£os!  Vamos fazer essa linha no loop 10 vezes.  Isso exigir√° um comando de ramifica√ß√£o condicional, al√©m de um pouco de aritm√©tica da pilha: um comando que diminua o valor na pilha em 1 (no forte ‚Äú1-‚Äù) e um comando de duplica√ß√£o de v√©rtices (‚Äúdup‚Äù). <br><br>  Com aritm√©tica, tudo √© simples, nem vou comentar: <br><br><pre> <code class="cpp hljs">b_dup = <span class="hljs-number"><span class="hljs-number">0x18</span></span> bcmd_dup: push [rsp] jmp _next b_wm = <span class="hljs-number"><span class="hljs-number">0x20</span></span> bcmd_wm: decq [rsp] jmp _next</code> </pre> <br>  Agora um salto condicional.  Para iniciantes, vamos simplificar a tarefa - uma transi√ß√£o incondicional.  √â claro que voc√™ s√≥ precisa alterar o valor do registro R8.  A primeira coisa que vem √† mente √© um comando byte, seguido por um par√¢metro - o endere√ßo de transi√ß√£o √© de 64 bits.  Novamente nove bytes.  Precisamos desses nove bytes?  As transi√ß√µes geralmente ocorrem em dist√¢ncias curtas, geralmente dentro de algumas centenas de bytes.  Portanto, n√£o usaremos o endere√ßo, mas o deslocamento! <br><br>  Profundidade de bits?  Em muitos casos, 8 bits (127 para frente / tr√°s) ser√£o suficientes, mas √†s vezes isso n√£o ser√° suficiente.  Portanto, faremos o mesmo que com o comando aceso, faremos duas op√ß√µes - 8 e 16 d√≠gitos, os c√≥digos de comando ser√£o 0x10 e 0x11: <br><br><pre> <code class="cpp hljs">b_branch8 = <span class="hljs-number"><span class="hljs-number">0x10</span></span> bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_branch16 = <span class="hljs-number"><span class="hljs-number">0x11</span></span> bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next</code> </pre>  Agora a transi√ß√£o condicional √© f√°cil de implementar.  Se a pilha for 0, v√° para _next e, se n√£o, v√° para o comando branch! <br><pre> <code class="cpp hljs">b_qbranch8 = <span class="hljs-number"><span class="hljs-number">0x12</span></span> bcmd_qbranch8: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch8 inc r8 jmp _next b_qbranch16 = <span class="hljs-number"><span class="hljs-number">0x13</span></span> bcmd_qbranch16: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch16 add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> jmp _next</code> </pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora temos tudo para fazer um loop: </font></font><pre> <code class="cpp hljs">start: .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">10</span></span> #  #  m0: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_wm .byte b_dup .byte b_qbranch8 .byte m0 - . .byte b_bye</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os dois primeiros comandos - colocamos o contador de loops na pilha. </font><font style="vertical-align: inherit;">Em seguida, imprima a sequ√™ncia Ol√°. </font><font style="vertical-align: inherit;">Subtra√≠mos 1 do contador, duplicamos e realizamos (ou n√£o realizamos) a transi√ß√£o. </font><font style="vertical-align: inherit;">O comando de duplica√ß√£o √© necess√°rio porque o comando de ramifica√ß√£o condicional assume o valor da parte superior da pilha. </font><font style="vertical-align: inherit;">A transi√ß√£o aqui √© de oito bits, pois a dist√¢ncia √© de apenas alguns bytes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colocamos os endere√ßos de novos comandos em uma tabela, compilamos e executamos.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vou colocar em um spoiler, caso contr√°rio, nosso programa se tornou detalhado)</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">$ as fort.asm -o fort.o -g -ahlsm &gt;list.txt $ ld forth.o -o forth $ ./forth Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! bye!</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bem, j√° podemos fazer condi√ß√µes e ciclos! </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonte completa</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye msg_hello: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> msg_hello_len = . - msg_hello bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x00</span></span> .quad bcmd_lit8, bcmd_lit16, bcmd_lit32, bcmd_lit64, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_branch8, bcmd_branch16, bcmd_qbranch8, bcmd_qbranch16, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x10</span></span> .quad bcmd_dup, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_wm, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x20</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x30</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x40</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x60</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_type, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x80</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">10</span></span> #  #  m0: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_wm .byte b_dup .byte b_qbranch8 .byte m0 - . .byte b_bye .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start jmp _next _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_num0 = <span class="hljs-number"><span class="hljs-number">0x02</span></span> bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next b_lit8 = <span class="hljs-number"><span class="hljs-number">0x08</span></span> bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> bcmd_lit16: movsx rax, word ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> push rax jmp _next b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> bcmd_lit32: movsx rax, dword ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> push rax jmp _next b_lit64 = <span class="hljs-number"><span class="hljs-number">0x0B</span></span> bcmd_lit64: mov rax, [r8] add r8, <span class="hljs-number"><span class="hljs-number">8</span></span> push rax jmp _next b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rcx push r8 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   pop r8 jmp _next b_dup = <span class="hljs-number"><span class="hljs-number">0x18</span></span> bcmd_dup: push [rsp] jmp _next b_wm = <span class="hljs-number"><span class="hljs-number">0x20</span></span> bcmd_wm: decq [rsp] jmp _next b_branch8 = <span class="hljs-number"><span class="hljs-number">0x10</span></span> bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_branch16 = <span class="hljs-number"><span class="hljs-number">0x11</span></span> bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next b_qbranch8 = <span class="hljs-number"><span class="hljs-number">0x12</span></span> bcmd_qbranch8: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch8 inc r8 jmp _next b_qbranch16 = <span class="hljs-number"><span class="hljs-number">0x13</span></span> bcmd_qbranch16: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch16 add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> jmp _next</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas at√© que a m√°quina de bytes conclu√≠da esteja faltando outra fun√ß√£o muito importante. </font><font style="vertical-align: inherit;">N√£o podemos chamar outro do bytecode. </font><font style="vertical-align: inherit;">N√£o temos o que chamamos de rotinas, procedimentos etc. </font><font style="vertical-align: inherit;">E no forte, sem isso, n√£o podemos usar outras palavras al√©m das palavras do n√∫cleo em algumas palavras. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trazemos o trabalho at√© o fim. </font><font style="vertical-align: inherit;">Aqui, pela primeira vez, precisamos de uma pilha de retornos. </font><font style="vertical-align: inherit;">S√£o necess√°rios dois comandos - o comando de chamada e o comando de retorno (chamar e sair).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O comando call, em princ√≠pio, faz o mesmo que o branch - transfere o controle para outro peda√ßo de bytecode. </font><font style="vertical-align: inherit;">Mas, diferentemente da ramifica√ß√£o, voc√™ ainda precisa salvar o endere√ßo de retorno na pilha de retorno para poder retornar e continuar a execu√ß√£o. </font><font style="vertical-align: inherit;">H√° outra diferen√ßa - essas chamadas podem ocorrer a dist√¢ncias muito maiores. </font><font style="vertical-align: inherit;">Portanto, fazemos o comando call √† semelhan√ßa de branch, mas em tr√™s vers√µes - 8, 16 e 32 bits.</font></font><br><br><pre> <code class="cpp hljs">b_call8 = <span class="hljs-number"><span class="hljs-number">0x0C</span></span> bcmd_call8: movsx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 mov [rbp], r8 add r8, rax jmp _next b_call16 = <span class="hljs-number"><span class="hljs-number">0x0D</span></span> bcmd_call16: movsx rax, word ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> mov [rbp], r8 add r8, rax jmp _next b_call32 = <span class="hljs-number"><span class="hljs-number">0x0E</span></span> bcmd_call32: movsx rax, dword ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> mov [rbp], r8 add r8, rax jmp _next</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como voc√™ pode ver, aqui, diferentemente das transi√ß√µes, tr√™s equipes s√£o adicionadas. Um deles reorganiza R8 para o pr√≥ximo comando de byte e os dois restantes armazenam o valor recebido na pilha de retorno. A prop√≥sito, aqui tentei n√£o colocar as instru√ß√µes do processador dependentes uma da outra lado a lado, para que o transportador do processador pudesse executar os comandos em paralelo. Mas n√£o sei o quanto isso causa algum efeito. Se desejar, voc√™ pode verificar os testes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deve-se ter em mente que a forma√ß√£o de um argumento para o comando de chamada √© um pouco diferente do que para o ramo. Para ramifica√ß√£o, o deslocamento √© calculado como a diferen√ßa entre o endere√ßo da ramifica√ß√£o e o endere√ßo do byte ap√≥s o comando byte. E para o comando de chamada, esta √© a diferen√ßa entre o endere√ßo de salto e o endere√ßo do pr√≥ximo comando.</font></font> Por que isso √© necess√°rio?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso resulta em menos instru√ß√µes do processador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, o comando de retorno. </font><font style="vertical-align: inherit;">Na verdade, seu trabalho √© apenas restaurar o R8 da pilha de retorno e transferir o controle para a m√°quina de bytes:</font></font><br><br><pre> <code class="cpp hljs">b_exit = <span class="hljs-number"><span class="hljs-number">0x1F</span></span> bcmd_exit: mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> jmp _next</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esses comandos ser√£o usados ‚Äã‚Äãcom muita frequ√™ncia e precisam ser otimizados ao m√°ximo. </font><font style="vertical-align: inherit;">O comando exit byte ocupa tr√™s instru√ß√µes da m√°quina. </font><font style="vertical-align: inherit;">√â poss√≠vel reduzir algo aqui? </font><font style="vertical-align: inherit;">Acontece que voc√™ pode! </font><font style="vertical-align: inherit;">Voc√™ pode simplesmente remover o comando de transi√ß√£o :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para fazer isso, coloque-o acima do ponto de entrada da m√°quina _next byte:</font></font><br><br><pre> <code class="cpp hljs">b_exit = <span class="hljs-number"><span class="hljs-number">0x1F</span></span> bcmd_exit: mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A prop√≥sito, os comandos mais importantes e usados ‚Äã‚Äãcom mais freq√º√™ncia (por exemplo, como chamada) precisam ser colocados mais pr√≥ximos √† m√°quina de bytes, para que o compilador possa formar um comando de salto curto. </font><font style="vertical-align: inherit;">Isso √© claramente vis√≠vel na listagem. </font><font style="vertical-align: inherit;">Aqui est√° um exemplo.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-number"><span class="hljs-number">262</span></span> <span class="hljs-number"><span class="hljs-number">0084</span></span> <span class="hljs-number"><span class="hljs-number">490F</span></span>BE00 bcmd_lit8: movsx rax, byte ptr [r8] <span class="hljs-number"><span class="hljs-number">263</span></span> <span class="hljs-number"><span class="hljs-number">0088</span></span> <span class="hljs-number"><span class="hljs-number">49F</span></span>FC0 inc r8 <span class="hljs-number"><span class="hljs-number">264</span></span> <span class="hljs-number"><span class="hljs-number">008b</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> push rax <span class="hljs-number"><span class="hljs-number">265</span></span> <span class="hljs-number"><span class="hljs-number">008</span></span>c EB90 jmp _next <span class="hljs-number"><span class="hljs-number">266</span></span> <span class="hljs-number"><span class="hljs-number">267</span></span> b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> <span class="hljs-number"><span class="hljs-number">268</span></span> <span class="hljs-number"><span class="hljs-number">008</span></span>e <span class="hljs-number"><span class="hljs-number">490F</span></span>BF00 bcmd_lit16: movsx rax, word ptr [r8] <span class="hljs-number"><span class="hljs-number">269</span></span> <span class="hljs-number"><span class="hljs-number">0092</span></span> <span class="hljs-number"><span class="hljs-number">4983</span></span>C002 add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">270</span></span> <span class="hljs-number"><span class="hljs-number">0096</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> push rax <span class="hljs-number"><span class="hljs-number">271</span></span> <span class="hljs-number"><span class="hljs-number">0097</span></span> EB85 jmp _next <span class="hljs-number"><span class="hljs-number">272</span></span> <span class="hljs-number"><span class="hljs-number">273</span></span> b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> <span class="hljs-number"><span class="hljs-number">274</span></span> <span class="hljs-number"><span class="hljs-number">0099</span></span> <span class="hljs-number"><span class="hljs-number">496300</span></span> bcmd_lit32: movsx rax, dword ptr [r8] <span class="hljs-number"><span class="hljs-number">275</span></span> <span class="hljs-number"><span class="hljs-number">009</span></span>c <span class="hljs-number"><span class="hljs-number">4983</span></span>C004 add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">276</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>a0 <span class="hljs-number"><span class="hljs-number">50</span></span> push rax <span class="hljs-number"><span class="hljs-number">277</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>a1 E978FFFF jmp _next <span class="hljs-number"><span class="hljs-number">277</span></span> FF <span class="hljs-number"><span class="hljs-number">278</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui, nas linhas 265 e 271, o comando jmp ocupa 2 bytes cada e na linha 277, o mesmo comando √© compilado em 5 bytes, pois a dist√¢ncia do salto excedeu o comprimento do comando curto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, comandos de byte, como tipo ruim, adeus, s√£o reorganizados ainda mais e, como chamada, ramifica√ß√£o, aceso, est√£o mais pr√≥ximos. Infelizmente, n√£o h√° muito que possa caber em uma transi√ß√£o de 127 bytes. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicionamos novos comandos √† tabela de endere√ßos de acordo com seus c√≥digos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ent√£o, agora temos um desafio e um retorno, vamos test√°-los! Para fazer isso, selecione a impress√£o da linha em um procedimento separado e a chamaremos duas vezes. E o n√∫mero de repeti√ß√µes do ciclo √© reduzido para tr√™s.</font></font><br><br><pre> <code class="cpp hljs">start: .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">3</span></span> #  #  m0: .byte b_call16 .word sub_hello - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word sub_hello - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_wm .byte b_dup .byte b_qbranch8 .byte m0 - . .byte b_bye sub_hello: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_exit</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Call8 pode ser usado aqui, mas decidi usar o call16 como o mais prov√°vel. </font><font style="vertical-align: inherit;">O valor 2 √© subtra√≠do devido √†s peculiaridades do c√°lculo do endere√ßo do comando de chamada de byte que escrevi sobre. </font><font style="vertical-align: inherit;">Para call8, 1 ser√° deduzido aqui, para call32, respectivamente, 4. Compilamos </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e chamamos:</font></font><br><br><pre> <code class="plaintext hljs">$ as forth.asm -o forth.o -g -ahlsm&gt;list.txt $ ld forth.o -o forth $ ./forth Hello, world! Bad byte code!</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opa ... como se costuma dizer, algo deu errado :) Bem, lan√ßamos o GDB e vemos o que acontece l√°. </font><font style="vertical-align: inherit;">Defino um ponto de interrup√ß√£o imediatamente em bcmd_exit, pois fica claro que a chamada sub_hello est√° passando e o corpo da rotina √© executado ... iniciado ... e o programa n√£o atingiu o ponto de interrup√ß√£o. </font><font style="vertical-align: inherit;">Imediatamente houve uma suspeita de um c√≥digo de comando de bytes. </font><font style="vertical-align: inherit;">E, de fato, a raz√£o estava nele. </font><font style="vertical-align: inherit;">b_exit Atribu√≠ o valor 0x1f e o pr√≥prio endere√ßo foi colocado no n√∫mero de c√©lula da tabela 0x17. </font><font style="vertical-align: inherit;">Bem, vou corrigir o valor de b_exit para 0x17 e tentar novamente:</font></font><br><br><pre> <code class="plaintext hljs">$ as forth.asm -o forth.o -g -ahlsm&gt;list.txt $ ld forth.o -o forth $ ./forth Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! bye!</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exatamente seis vezes a sauda√ß√£o e uma vez adeus. </font><font style="vertical-align: inherit;">Como deveria ser :)</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonte completa</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye msg_hello: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> msg_hello_len = . - msg_hello bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x00</span></span> .quad bcmd_lit8, bcmd_lit16, bcmd_lit32, bcmd_lit64, bcmd_call8, bcmd_call16, bcmd_call32, bcmd_bad .quad bcmd_branch8, bcmd_branch16, bcmd_qbranch8, bcmd_qbranch16, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_exit # <span class="hljs-number"><span class="hljs-number">0x10</span></span> .quad bcmd_dup, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_wm, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x20</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x30</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x40</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x60</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_type, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x80</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">3</span></span> #  #  m0: .byte b_call16 .word sub_hello - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word sub_hello - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_wm .byte b_dup .byte b_qbranch8 .byte m0 - . .byte b_bye sub_hello: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_exit .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start jmp _next b_exit = <span class="hljs-number"><span class="hljs-number">0x17</span></span> bcmd_exit: mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] b_num0 = <span class="hljs-number"><span class="hljs-number">0x02</span></span> bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next b_lit8 = <span class="hljs-number"><span class="hljs-number">0x08</span></span> bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> bcmd_lit16: movsx rax, word ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> push rax jmp _next b_call8 = <span class="hljs-number"><span class="hljs-number">0x0C</span></span> bcmd_call8: movsx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 mov [rbp], r8 add r8, rax jmp _next b_call16 = <span class="hljs-number"><span class="hljs-number">0x0D</span></span> bcmd_call16: movsx rax, word ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> mov [rbp], r8 add r8, rax jmp _next b_call32 = <span class="hljs-number"><span class="hljs-number">0x0E</span></span> bcmd_call32: movsx rax, dword ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> mov [rbp], r8 add r8, rax jmp _next b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> bcmd_lit32: movsx rax, dword ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> push rax jmp _next b_lit64 = <span class="hljs-number"><span class="hljs-number">0x0B</span></span> bcmd_lit64: mov rax, [r8] add r8, <span class="hljs-number"><span class="hljs-number">8</span></span> push rax jmp _next b_dup = <span class="hljs-number"><span class="hljs-number">0x18</span></span> bcmd_dup: push [rsp] jmp _next b_wm = <span class="hljs-number"><span class="hljs-number">0x20</span></span> bcmd_wm: decq [rsp] jmp _next b_branch8 = <span class="hljs-number"><span class="hljs-number">0x10</span></span> bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_branch16 = <span class="hljs-number"><span class="hljs-number">0x11</span></span> bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next b_qbranch8 = <span class="hljs-number"><span class="hljs-number">0x12</span></span> bcmd_qbranch8: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch8 inc r8 jmp _next b_qbranch16 = <span class="hljs-number"><span class="hljs-number">0x13</span></span> bcmd_qbranch16: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch16 add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> jmp _next b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rcx push r8 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   pop r8 jmp _next</code> </pre><br></div></div><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qual √© o resultado </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fizemos e testamos uma m√°quina de byte de pilha de 64 bits completa e bastante r√°pida. Em velocidade, talvez essa m√°quina de bytes seja uma das mais r√°pidas da sua classe (uma m√°quina de bytes de pilha sem JIT). Ela sabe como executar comandos sequencialmente, fazer saltos condicionais e incondicionais, chamar procedimentos e retornar a partir deles. Ao mesmo tempo, o bytecode usado √© razoavelmente compacto. Basicamente, os comandos de bytes levam de 1 a 3 bytes, mais √© muito raro (apenas n√∫meros grandes e chamadas de procedimento muito distantes). Tamb√©m √© esbo√ßado um pequeno conjunto de comandos de bytes, que √© f√°cil de expandir. Suponha que todos os comandos b√°sicos para trabalhar com a pilha (drop, swap, over, root, etc. possam ser escritos em 20 minutos, a mesma quantidade ser√° aplicada a comandos inteiros aritm√©ticos).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outro ponto importante. O bytecode, diferentemente do c√≥digo forte cl√°ssico de costura direta, n√£o cont√©m instru√ß√µes da m√°quina, portanto pode ser transferido sem recompila√ß√£o para outra plataforma. √â suficiente reescrever o kernel uma vez no sistema de instru√ß√µes do novo processador, e isso pode ser feito muito rapidamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A vers√£o atual da m√°quina de bytes n√£o √© espec√≠fica para nenhum idioma espec√≠fico. Mas quero fazer a implementa√ß√£o da linguagem Fort, porque tenho experi√™ncia com ela, e o compilador para isso pode ser feito muito rapidamente.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se houver interesse nisso, com base nesta m√°quina, no pr√≥ximo artigo, farei entrada e sa√≠da de strings e n√∫meros, um dicion√°rio forte e um int√©rprete. Voc√™ pode "tocar" a equipe com as m√£os. Bem, no terceiro artigo, criaremos um compilador e obteremos um sistema quase completo de fort. Em seguida, ser√° poss√≠vel escrever e compilar alguns algoritmos padr√£o e comparar o desempenho com outros idiomas e sistemas. Voc√™ pode usar, por exemplo, a peneira de Erat√≥stenes e similares.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â interessante experimentar op√ß√µes. </font><font style="vertical-align: inherit;">Por exemplo, torne a tabela de comandos 16 bits e veja como isso afetar√° o desempenho. </font><font style="vertical-align: inherit;">Voc√™ tamb√©m pode transformar o ponto de entrada _next em uma macro. Nesse caso, o c√≥digo de m√°quina de cada comando de byte aumentar√° de tamanho em dois comandos (menos a transi√ß√£o e mais tr√™s comandos de _next). </font><font style="vertical-align: inherit;">Ou seja, no final, n√£o haver√° transi√ß√£o para _next, mas o conte√∫do do _next aponta em si (14 bytes). </font><font style="vertical-align: inherit;">√â interessante saber como isso afetar√° o desempenho. </font><font style="vertical-align: inherit;">Voc√™ tamb√©m pode tentar otimizar usando registros. </font><font style="vertical-align: inherit;">Por exemplo, um loop padr√£o com um contador no forte armazena o contador na pilha de retorno. </font><font style="vertical-align: inherit;">Voc√™ pode criar uma vers√£o de registro e tamb√©m test√°-la. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ tamb√©m pode criar um compilador de express√µes escritas na forma cl√°ssica (por exemplo, A = 5 + (B + C * 4)).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em geral, h√° espa√ßo para experimenta√ß√£o! </font></font> :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continua√ß√£o: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Byte-machine para o forte (e n√£o apenas) no nativo americano (parte 2)</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt431932/">https://habr.com/ru/post/pt431932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt431920/index.html">Frontend Mix - relat√≥rios sobre Node.js, escalabilidade e Web nativa</a></li>
<li><a href="../pt431922/index.html">O que √© m√©todo manipula em Java</a></li>
<li><a href="../pt431924/index.html">Sistema de gerenciamento de armaz√©m utilizando CQRS e Event Sourcing. Processo de Desenvolvimento</a></li>
<li><a href="../pt431928/index.html">Fadiga de itens descart√°veis. Ou ode A.S. Makarenko</a></li>
<li><a href="../pt431930/index.html">Meetup sobre DevOps em S√£o Petersburgo</a></li>
<li><a href="../pt431934/index.html">Como a intelig√™ncia artificial ajuda a trabalhar com documentos legais? Palestra de Egor Budnikov da ABBYY</a></li>
<li><a href="../pt431936/index.html">Resultados do concurso TechnoText</a></li>
<li><a href="../pt431938/index.html">Raiz de cubo inteiro no Verilog</a></li>
<li><a href="../pt431940/index.html">As pessoas se esgotam se n√£o sentem seu valor. O que fazer sobre isso?</a></li>
<li><a href="../pt431942/index.html">Inje√ß√£o de depend√™ncia hier√°rquica no React e MobX State Tree como um modelo de dom√≠nio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>