<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👶 😘 🤠 Rastreo y monitoreo de Istio: microservicios y el principio de incertidumbre 😸 🧚🏻 🤞🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El principio de incertidumbre de Heisenberg establece que es imposible medir simultáneamente la posición de un objeto y su velocidad. Si un objeto se ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rastreo y monitoreo de Istio: microservicios y el principio de incertidumbre</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/485136/">  El principio de incertidumbre de Heisenberg establece que es imposible medir simultáneamente la posición de un objeto y su velocidad.  Si un objeto se mueve, entonces no tiene ubicación.  Y si la ubicación es, significa que no tiene velocidad. <br><br><img src="https://habrastorage.org/webt/sl/dx/7l/sldx7l5gkazjrjsrzplh02uzfhk.png" width="100%"><br><br>  En cuanto a los microservicios en la plataforma Red Hat OpenShift (y ejecutar Kubernetes), gracias al software de código abierto correspondiente, pueden informar simultáneamente tanto su rendimiento como su estado.  Por supuesto, esto no refuta el viejo Heisenberg, pero elimina la incertidumbre cuando se trabaja con aplicaciones en la nube.  Istio facilita la organización del seguimiento (rastreo) y el monitoreo de dichas aplicaciones para mantener todo bajo control. <br><a name="habracut"></a><br><h3>  Definir terminología </h3><br>  Por <b>rastreo</b> nos referimos a la actividad del sistema de registro.  Suena bastante general, pero de hecho, una de las reglas principales aquí es volcar los datos de rastreo en el almacenamiento adecuado sin preocuparse por formatearlos.  Y todo el trabajo de búsqueda y análisis de datos se confía a sus consumidores.  Istio utiliza el sistema de rastreo Jaeger, que implementa el modelo de datos OpenTracing. <br><br>  <b>Por trazas</b> (Traces, y la palabra "trazas" se usa aquí en el significado de "trazas", como, por ejemplo, en un examen balístico) nos referiremos a datos que describen completamente el paso de una solicitud o unidad de trabajo, como dicen, "desde y hacia".  Por ejemplo, todo lo que sucede desde el momento en que el usuario presiona un botón en una página web hasta el momento en que se devuelven los datos, incluidos todos los microservicios involucrados en esto.  Podemos decir que una traza describe completamente (o simula) el paso de la solicitud de un lado a otro.  En la interfaz de Jaeger, las pistas se descomponen en componentes a lo largo del eje de tiempo, como la forma en que una cadena se puede descomponer en enlaces separados.  Solo en lugar de enlaces, la pista consta de los llamados tramos. <br><br>  El intervalo es el intervalo desde el comienzo de una unidad de trabajo hasta su finalización.  Continuando con la analogía, podemos decir que cada tramo es un eslabón separado en la cadena.  Un lapso puede o no tener uno o más tramos de niños.  Como resultado, el tramo de nivel superior (tramo raíz) tendrá la misma duración total que la traza a la que pertenece. <br><br>  <b>El monitoreo</b> es, de hecho, la simple observación de su sistema: a través de los ojos, a través de una interfaz de usuario o mediante la automatización.  El monitoreo se basa en datos de rastreo.  En Istio, el monitoreo se implementa utilizando las herramientas de Prometheus y tiene una IU correspondiente.  Prometheus admite la supervisión automática mediante alertas y alertas de administradores de alertas. <br><br><h3>  Deja las mellas </h3><br>  Para que el rastreo sea posible, la aplicación debe crear una colección de tramos.  Luego deben exportarse a Jaeger, para que él, a su vez, cree una representación visual de la traza.  Entre otras cosas, estos tramos marcan el nombre de la operación, así como las marcas de tiempo de su inicio y finalización.  Los tramos se envían reenviando encabezados Jaeger para solicitudes HTTP de solicitudes entrantes a solicitudes salientes.  Dependiendo del lenguaje de programación utilizado, esto puede requerir una ligera modificación del código fuente de la aplicación.  El siguiente es un ejemplo de código Java (cuando se usa el marco Spring Boot) que agrega encabezados B3 (estilo Zipkin) a su solicitud en la clase de configuración Spring: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9y/mo/yd/9ymoydbpezhtbvshfg2tgpewnk8.png"></div><br>  Se utilizan las siguientes configuraciones de encabezado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uy/e-/yg/uye-yg-mezone3fs_1o-vquryvu.png"></div><br>  Si usa Java, puede dejar el código intacto, solo agregue algunas líneas al archivo POM de Maven y configure las variables de entorno.  Estas son las líneas que debe agregar al archivo POM.XML para implementar el Resoludor de seguimiento de Jaeger: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kr/np/vj/krnpvjjnx-6r-icjjttenmdaq-4.png"></div><br>  Y las variables de entorno correspondientes se establecen en el Dockerfile: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/b8/2a/lh/b82alhxdifmkgfiv3q3hdq1o05m.png"></div><br>  Eso es todo, ahora está todo configurado y nuestros microservicios comenzarán a generar datos de rastreo. <br><br><h3>  Nos fijamos en términos generales </h3><br>  Istio incluye un panel de control simple basado en Grafana.  Cuando todo está configurado y ejecutándose en la plataforma Red Hat OpenShift PaaS (en nuestro ejemplo, Red Hat OpenShift y Kubernetes se implementan en minishift), este panel se inicia con el siguiente comando: <br><br><pre><code class="plaintext hljs">open "$(minishift openshift service grafana -u)/d/1/istio-dashboard?refresh=5⩝Id=1"</code> </pre> <br>  El panel Grafana le permite evaluar rápidamente el sistema.  Un fragmento de este panel se muestra en la siguiente figura: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zh/jj/lr/zhjjlrilmbtgrdo08lkopbnwh1u.png"></div><br>  Aquí puede ver que el cliente de microservicio llama a la preferencia de microservicio v1, y que a su vez llama a la recomendación de microservicios v1 y v2.  El panel Grafana tiene un bloque Dashboard Row para métricas de alto nivel, como el número total de solicitudes (Volumen de solicitud global), porcentaje de solicitudes exitosas (tasas de éxito), errores 4xx.  Además, hay una vista de malla de servidor con gráficos para cada servicio y un bloque de fila de servicios para ver información detallada de cada contenedor para cada servicio. <br><br><h3>  Ahora cava más profundo </h3><br>  Con un seguimiento configurado correctamente, Istio, como se dice, listo para usar le permite profundizar en el análisis del rendimiento del sistema.  En la interfaz de usuario de Jaeger, puede ver los rastros y ver hasta dónde llegan, así como localizar visualmente los cuellos de botella de rendimiento.  Cuando use Red Hat OpenShift en la plataforma minishift, inicie la interfaz de usuario de Jaeger con el siguiente comando: <br><br><pre> <code class="plaintext hljs">minishift openshift service jaeger-query --in-browser</code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lz/8j/x1/lz8jx118ortdebrs6nlmv8-kwws.png"></div><br>  Lo que se puede decir sobre el rastro en esta pantalla: <br><br><ul><li>  Se divide en 7 tramos. </li><li>  El tiempo total de ejecución es de 6,99 ms. </li><li>  La recomendación de microservicio, que es la última en la cadena, tarda 0,69 ms. </li></ul><br>  Los diagramas de este tipo le permiten descubrir rápidamente una situación en la que el rendimiento de todo el sistema sufre debido a un solo servicio que funciona mal. <br><br>  Ahora, compliquemos la tarea y lancemos dos instancias del microservicio de recomendaciones: v2 con la escala oc --replicas = 2 implementación / recomendación-v2.  Aquí están las vainas que tendremos después de esto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ew/ly/tp/ewlytpvsmyay1m7aai46a5xcono.png"></div><br>  Si ahora volvemos a Jaeger e implementamos el intervalo para el servicio de recomendación, veremos a qué solicitudes de pod se enrutan.  Por lo tanto, podemos localizar fácilmente los frenos en el nivel de pod específico.  Deberías mirar el campo node_id: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/o6/ag/rj/o6agrj_goch7itiy27nxkpckmxy.png"></div><br><h3>  Donde y como va todo </h3><br>  Ahora vamos a la interfaz de Prometheus y, como es de esperar, vemos que las solicitudes entre la segunda y la primera versión del servicio de recomendaciones se dividen en una proporción de 2: 1, estrictamente por el número de unidades de trabajo.  Además, este gráfico cambiará dinámicamente al escalar los pods hacia arriba y hacia abajo, lo que será especialmente útil con Canary Deployment (examinaremos este esquema de implementación con más detalle la próxima vez). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ri/vg/ja/rivgjapmewz2mfhfll7bydezpyo.png"></div><br><h3>  Es solo el comienzo </h3><br>  De hecho, hoy, como dicen, solo tocamos un depósito de información útil sobre Jaeger, Grafana y Prometeo.  En general, este era nuestro objetivo: guiarlo en la dirección correcta y abrir las perspectivas de Istio. <br><br>  Y recuerde, todo esto ya está integrado en Istio.  Cuando se utilizan ciertos lenguajes de programación (por ejemplo, Java) y frameworks (por ejemplo, Spring Boot), todo esto se puede realizar sin tocar completamente el código de la aplicación.  Sí, el código tendrá que modificarse ligeramente si usa otros idiomas, principalmente Nodejs o C #.  Pero dado que la trazabilidad (leer, "rastreo") es uno de los requisitos previos para crear sistemas de nube confiables, en cualquier caso, tendrá que editar el código, ya sea que tenga Istio o no.  Entonces, ¿por qué no gastar el esfuerzo de manera más rentable? <br><br>  Al menos para responder siempre a las preguntas “¿dónde?” Y “¿qué tan rápido?” Con 100% de certeza. <br><br><h3>  Ingeniería del caos en Istio: fue concebido </h3><br><h3>  La capacidad de romper cosas ayuda a garantizar que no se rompan </h3><br>  Las pruebas de software no solo son complicadas, sino también importantes.  Al mismo tiempo, probar la corrección (por ejemplo, si una función devuelve el resultado correcto) es una cosa, y probar en una red poco confiable es una tarea completamente diferente (a menudo se cree que la red siempre funciona sin fallas, y esta es la primera de las ocho ideas erróneas sobre la distribución informática).  Una de las dificultades para resolver este problema es cómo simular fallas en el sistema o introducirlas intencionalmente realizando la llamada inyección de falla.  Esto se puede hacer modificando el código fuente de la aplicación en sí.  Pero entonces no probará su código original, sino su versión, que simula específicamente fallas.  Como resultado, corre el riesgo de caer en un abrazo fatal de la inyección de fallas y colisionar con las bolsas de seguridad, fallas que desaparecen cuando intenta detectarlas. <br><br>  Y ahora mostraremos cómo Istio ayuda a hacer frente a estas dificultades uno-dos. <br><br><h3>  Cómo se ve cuando todo está bien </h3><br>  Considere el siguiente escenario: tenemos dos pods para nuestro microservicio de recomendaciones, que tomamos del tutorial de Istio.  Un pod está marcado como v1 y el otro como v2.  Como puede ver, mientras todo funciona bien: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kn/yp/ku/knypkuxns77xf9hyiqtmmnl2qtm.png"></div><br>  (Por cierto, el número de la derecha es solo un contador de llamadas para cada pod) <br><br>  Pero no necesitamos esto, ¿verdad?  Bueno, intentemos romper todo sin tocar el código fuente. <br><br><h3>  Organizamos interrupciones en el trabajo del microservicio. </h3><br>  A continuación se muestra el archivo yaml para la regla de enrutamiento Istio, que en la mitad de los casos fallará (error del servidor 503): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l7/kw/xm/l7kwxmggkngarcusz4sy00epmcc.png"></div><br>  Tenga en cuenta que prescribimos explícitamente que en la mitad de los casos se debe devolver el error 503. <br><br>  Y aquí hay una captura de pantalla del comando curl lanzado en el bucle después de activar esta regla para simular fallas.  Como puede ver, la mitad de las solicitudes devuelve el error 503, e independientemente de qué pod - v1 o v2 - van a: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t5/-6/62/t5-6620-bhqwlupwj_eevq7ud6s.png"></div><br>  Para restaurar la operación normal, es suficiente eliminar esta regla, en nuestro caso, el comando tutorial istioctl delete routerule Recomendacion-503 -n.  Aquí Tutorial es el nombre del proyecto Red Hat OpenShift que ejecuta nuestro tutorial Istio. <br><br><h3>  Hacer retrasos artificiales </h3><br>  Los errores artificiales 503 ayudan a probar la tolerancia a fallas del sistema, pero la capacidad de predecir y manejar demoras debería impresionarlo aún más.  Y los retrasos en la vida real ocurren con más frecuencia que los fracasos.  Un microservicio de ejecución lenta es el veneno que sufre todo el sistema.  Gracias a Istio, puede probar el código relacionado con el procesamiento diferido sin cambiarlo en absoluto.  Para empezar, mostraremos cómo hacerlo en caso de retrasos en la red introducidos artificialmente. <br><br>  Tenga en cuenta que después de tales pruebas, es posible que necesite (o desee) refinar su código.  La buena noticia es que, en este caso, actuará de manera proactiva, no reactiva.  Así es como se debe construir el ciclo de desarrollo: coding-testing-feedback-coding-testing ... <br><br>  Así es como se ve la regla ... ¿Aunque sabes qué?  Istio es tan simple, y este archivo yaml es tan claro que todo en este ejemplo habla por sí mismo, solo eche un vistazo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/au/2p/92/au2p92jsexrmthvsbjmfkbyh05c.png"></div><br>  En la mitad de los casos, tendremos un retraso de 7 segundos.  Y esto no es lo mismo que si insertáramos el comando de suspensión en el código fuente, ya que Istio realmente retrasa la solicitud durante 7 segundos.  Dado que Istio admite el rastreo de Jaeger, este retraso es excelente en la interfaz de usuario sesgada de Jaeger, como se muestra en la captura de pantalla a continuación.  Preste atención a la solicitud larga en la esquina superior derecha del diagrama; su duración es de 7.02 segundos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1h/xo/4l/1hxo4lzzbyzue3isyckez6ez4fo.png"></div><br>  Este escenario le permite probar el código en condiciones de latencia de red.  Y está claro que al eliminar esta regla, eliminaremos el retraso artificial.  Repetimos, pero nuevamente hicimos todo esto sin tocar el código fuente. <br><br><h3>  No retrocedas y no te rindas </h3><br>  Otra característica de Istio que es útil para la ingeniería del caos son las llamadas repetidas al servicio un número específico de veces.  El punto aquí es no dejar de intentarlo cuando la primera solicitud finaliza con el error 503, y luego, tal vez, por enésima vez, tenemos suerte.  Tal vez el servicio simplemente permanezca por un corto tiempo por una razón u otra.  Sí, esta razón debe desenterrarse y eliminarse.  Pero esto es más tarde, pero por ahora intentemos que el sistema continúe funcionando. <br><br>  Entonces, queremos que el servicio dé un error 503 de vez en cuando, y después de eso, Istio intentará contactarlo nuevamente.  Y aquí claramente necesitamos una forma de generar el error 503, sin tocar el código en sí ... <br><br>  Deja de esperar!  Acabamos de hacerlo. <br><br>  Este archivo hará que el servicio de recomendación-v2 genere un error 503 en la mitad del caso: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ot/6x/s4/ot6xs4clozb273bdfk32ct1gcvy.png"></div><br>  Obviamente, parte de las solicitudes fallarán: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pu/jd/90/pujd90d9qf7tslucey3184dnvik.png"></div><br>  Y ahora usaremos la función Retry Istio: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lq/nh/2y/lqnh2yeuargpzyskjb6o9ptsstu.png"></div><br>  Esta regla de enrutamiento realiza tres reintentos con un intervalo de dos segundos y debería reducir (e idealmente eliminar completamente del radar) los errores 503: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wp/ed/jy/wpedjyfo8jskkadpnonzppc3wgu.png"></div><br>  Resumimos: lo hicimos para que Istio, en primer lugar, generara un error 503 para la mitad de las solicitudes.  Y en segundo lugar, el mismo Istio hace tres intentos de volver a conectarse al servicio si se produce un error 503. Como resultado, todo funciona bien.  Por lo tanto, utilizando la función Reintentar, cumplimos nuestra promesa de no dar marcha atrás y no rendirnos. <br><br>  Y sí, lo volvimos a hacer sin tocar el código.  Todo lo que necesitábamos eran dos reglas de enrutamiento de Istio: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/g2/hu/9a/g2hu9aiyuemt8qq7ugn1x14lekq.png"></div><br><h3>  Cómo no decepcionar a un usuario o siete no esperar </h3><br>  Y ahora damos la vuelta a la situación y consideramos el escenario en el que no tiene que retirarse o renunciar a un tiempo fijo.  Y luego solo debe dejar de intentar procesar la solicitud para no obligar a todos a esperar a ningún servicio de frenado.  En otras palabras, no protegeremos la posición perdida, sino que nos moveremos a la línea de reserva para no decepcionar al usuario del sitio y no forzarlo a languidecer en la ignorancia. <br><br>  En Istio, puede configurar el tiempo de espera de la solicitud.  Si el servicio excede este tiempo de espera, se devuelve el error 504 (Tiempo de espera de la puerta de enlace); nuevamente, todo esto se hace a través de la configuración de Istio.  Pero tendremos que agregar el comando de suspensión al código fuente del servicio (y luego, por supuesto, ejecutar reconstruir y volver a implementar) para simular la operación lenta del servicio.  Por desgracia, no funcionará de otra manera. <br><br>  Entonces, insertamos una suspensión de tres segundos en el código de servicio de la recomendación v2, reconstruimos la imagen correspondiente e hicimos un modo de contenedor, y ahora agregaremos un tiempo de espera usando la siguiente regla de enrutamiento Istio: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6y/5v/z7/6y5vz7wmsbnnvjb-vv5brcsdp5o.png"></div><br>  La captura de pantalla anterior muestra que estamos tratando de contactar al servicio de recomendaciones si no recibimos una respuesta dentro de un segundo, es decir, antes de que ocurra el error 504. Después de aplicar esta regla de enrutamiento (y agregar una suspensión de tres segundos al código de servicio de recomendación) : v2), obtenemos esto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ok/eq/ii/okeqiihvoiw5hbwur5l4c3ggibe.png"></div><br>  Repetimos nuevamente, pero el tiempo de espera se puede configurar sin tocar el código fuente.  Y una ventaja adicional aquí es que ahora puede modificar su código para que responda a un tiempo de espera, y es fácil probar estas mejoras con Istio. <br><br><h3>  Y ahora todos juntos </h3><br>  Hacer un poco de caos con Istio es una excelente manera de probar su código y la confiabilidad de su sistema como un todo.  Los patrones de fallback, mamparo y disyuntor, mecanismos para crear fallas y demoras artificiales, y también llamadas repetidas y tiempos de espera serán muy útiles al crear sistemas de nube tolerantes a fallas.  En combinación con Kubernetes y Red Hat OpenShift, estas herramientas lo ayudan a enfrentar con confianza el futuro. </div></div><p>Source: <a href="https://habr.com/ru/post/485136/">https://habr.com/ru/post/485136/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../485122/index.html">El título "Leer artículos para usted". Octubre - diciembre 2019</a></li>
<li><a href="../485124/index.html">Pruebas puras en PHP y PHPUnit</a></li>
<li><a href="../485126/index.html">Mu-mu, woof-woof, quack-quack: evolución de la comunicación acústica</a></li>
<li><a href="../485128/index.html">Ahorre en licencias Mikrotik CHR</a></li>
<li><a href="../485132/index.html">Únete al Festival de juegos independientes de Google Play</a></li>
<li><a href="../485138/index.html">Localización de aplicaciones: cómo hicimos amigos traducción y desarrollo</a></li>
<li><a href="../485144/index.html">Cómo arreglé una base rota y qué salió de ella</a></li>
<li><a href="../485148/index.html">Este adorable Unicode</a></li>
<li><a href="../485152/index.html">Pasantía de primavera para desarrolladores móviles en Redmadrobot</a></li>
<li><a href="../485154/index.html">Cómo hacer que una marca sea geek de un desarrollador: un sistema de motivación de programador</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>