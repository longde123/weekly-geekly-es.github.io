<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ® ğŸ½ ğŸ¤ğŸ» Menghapus rekursi dengan Python ğŸ‘ŠğŸ» ğŸ––ğŸ¾ ğŸ§šğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya hadir untuk Anda terjemahan artikel "Menghapus rekursi dengan Python, bagian 1" oleh Eric Lippert. 


 Selama 20 tahun terakhir, saya...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menghapus rekursi dengan Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440178/"><p> Halo, Habr!  Saya hadir untuk Anda terjemahan artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Menghapus rekursi dengan Python, bagian 1"</a> oleh Eric Lippert. </p><br><p>  Selama 20 tahun terakhir, saya mengagumi kesederhanaan dan kekuatan Python, meskipun saya tidak pernah benar-benar bekerja dengannya atau belajar secara detail. </p><br><p>  Baru-baru ini, saya telah memperhatikannya dengan seksama - dan itu ternyata menjadi bahasa yang sangat bagus. </p><br><p>  Sebuah pertanyaan baru-baru ini tentang StackOverflow membuat saya bertanya-tanya bagaimana cara mengubah algoritma rekursif ke yang iteratif, dan ternyata Python adalah bahasa yang cukup bagus untuk ini. <br>  Masalah yang ditemui penulis pertanyaan adalah sebagai berikut: </p><a name="habracut"></a><br><ul><li>  Pemain berada di sel sewenang-wenang di bidang bernomor; </li><li>  Tujuannya adalah untuk kembali ke sel nomor 1; </li><li>  Jika pemain berada di kotak yang genap, ia membayar satu koin dan setengah jalan ke sel No. 1; </li><li>  Jika pemain berada di kotak yang aneh, ia dapat membayar 5 koin dan langsung ke kotak pertama atau membayar satu koin dan mengambil satu langkah ke kotak No. 1 - di kotak yang genap. </li></ul><br><p>  Pertanyaannya adalah: berapa jumlah koin terkecil yang harus Anda bayar untuk kembali dari sel saat ini ke yang pertama. </p><br><p>  Tugas ini memiliki solusi rekursif yang jelas: </p><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> + cost(s // <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> min(<span class="hljs-number"><span class="hljs-number">1</span></span> + cost(s - <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">5</span></span>)</code> </pre> <br><p>  Namun, program ini macet, mencapai kedalaman maksimum rekursi, kemungkinan besar karena fakta bahwa penulis pertanyaan bereksperimen dengan jumlah yang sangat besar. <br>  Oleh karena itu, muncul pertanyaan: bagaimana mengubah algoritma rekursif menjadi iteratif dengan Python? </p><br><p>  Sebelum kita mulai, saya ingin mencatat bahwa tentu saja ada solusi yang lebih cepat untuk masalah khusus ini, itu sendiri tidak terlalu menarik. </p><br><p>  Sebaliknya, tugas ini hanya berfungsi sebagai titik awal dalam pertanyaan tentang bagaimana, dalam kasus umum, untuk menyingkirkan panggilan rekursif tunggal dalam program Python. </p><br><p>  Intinya adalah Anda dapat mengonversi metode rekursif sederhana dan menyingkirkan rekursi, dan ini hanyalah contoh yang sudah ada. </p><br><p>  Teknik yang akan saya tunjukkan, tentu saja, tidak sama persis dengan cara Python ditulis, mungkin solusi gaya Python akan menggunakan generator atau fitur lain dari bahasa tersebut. </p><br><p>  Apa yang ingin saya tunjukkan di sini adalah bagaimana menghilangkan rekursi menggunakan serangkaian transformasi kecil dan aman, memimpin fungsi ke bentuk di mana mudah untuk mengganti rekursi dengan iterasi. </p><br><p>  Untuk memulai, mari kita lihat cara membawa program ke formulir ini. </p><br><p>  Pada langkah pertama konversi kami, saya ingin perhitungan dilakukan sebelum panggilan rekursif dikurangi menjadi perhitungan argumen, dan perhitungan, setelah panggilan rekursif, harus dilakukan dalam metode terpisah yang menerima hasil panggilan rekursif. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_one</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_min</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> min(n + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: argument = s // <span class="hljs-number"><span class="hljs-number">2</span></span> result = cost(argument) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> add_one(result) argument = s - <span class="hljs-number"><span class="hljs-number">1</span></span> result = cost(argument) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get_min(result)</code> </pre> <br><p>  Langkah kedua yang ingin saya buat adalah perhitungan argumen dalam fungsi terpisah: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ... def get_argument(s): if s % 2 == 0: return s // 2 return s - 1 def cost(s): if s &lt;= 1: return 0 argument = get_argument(s) result = cost(argument) if s % 2 == 0: return add_one(result) return get_min(result)</span></span></code> </pre> <br><p>  Pada langkah ketiga, saya ingin menambahkan fungsi pembantu yang akan memilih fungsi kelanjutan yang dipanggil setelah kembali dari rekursi. </p><br><p>  Perhatikan bahwa fungsi helper mengembalikan fungsi. </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#... def get_after(s): if s % 2 == 0: return add_one return get_min def cost(s): if s &lt;= 1: return 0 argument = get_argument(s) after = get_after(s) # after  ! result = cost(argument) return after(result)</span></span></code> </pre> <br><p>  Sekarang kita menulisnya dalam bentuk yang lebih umum dan ringkas: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#... def is_base_case(s): return s &lt;= 1 def base_case_value(s): return 0 def cost(s): if is_base_case(s): return base_case_value(s) argument = get_argument(s) after = get_after(s) return after(cost(argument))</span></span></code> </pre> <br><p>  Dapat dilihat bahwa setiap perubahan tetap mempertahankan makna program. </p><br><p>  Sekarang cek untuk paritas nomor dilakukan dua kali, meskipun sebelum perubahan ada satu cek. </p><br><p>  Jika kita mau, kita bisa menyelesaikan masalah ini dengan menggabungkan dua fungsi pembantu menjadi satu yang mengembalikan tuple. </p><br><p>  Tapi jangan khawatir tentang ini sebagai bagian dari tugas ini. </p><br><p>  Kami telah mengurangi metode rekursif kami ke bentuk yang paling umum. </p><br><ul><li>  Dalam kasus dasar: <br><ul><li>  menghitung nilai yang akan dikembalikan; </li><li>  kembalikan. </li></ul></li><li>  Dalam kasus non-dasar: <br><ul><li>  hitung argumen rekursi; </li><li>  melakukan panggilan rekursif; </li><li>  menghitung nilai pengembalian; </li><li>  kembalikan. </li></ul></li></ul><br><p>  Sesuatu yang penting yang perlu Anda perhatikan pada langkah ini adalah bahwa <code>after</code> itu tidak boleh mengandung panggilan <code>cost</code> itu sendiri. </p><br><p>  Metode yang saya perlihatkan di sini menghilangkan satu panggilan rekursif. </p><br><p>  Jika Anda memiliki 2 atau lebih rekursi, maka kami membutuhkan solusi yang berbeda. </p><br><p>  Setelah kami membawa algoritma rekursif kami ke formulir ini, sudah mudah untuk mengubahnya menjadi berulang. </p><br><p>  Kuncinya adalah membayangkan apa yang terjadi dalam program rekursif. </p><br><p>  Bagaimana kami melakukan turunan rekursif: kami memanggil <strong>get_argument</strong> sebelum panggilan rekursif dan memanggil fungsi <strong>after setelah</strong> kembali dari rekursi. </p><br><p>  Artinya, semua panggilan ke <strong>get_argument</strong> terjadi sebelum semua panggilan ke <strong>setelah</strong> . <br>  Oleh karena itu, kita dapat mengonversikannya menjadi 2 siklus: panggilan pertama <strong>get_argument</strong> dan membentuk daftar fungsi <strong>setelah</strong> , dan panggilan kedua semua fungsi <strong>setelah</strong> : </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#... def cost(s): #     "after".    #       # ,    . afters = [ ] while not is_base_case(s): argument = get_argument(s) after = get_after(s) afters.append(after) s = argument #       "after" : result = base_case_value(s) while len(afters) != 0: after = afters.pop() result = after(result) return result</span></span></code> </pre> <br><p>  Tidak ada lagi rekursi! </p><br><p>  Kelihatannya seperti sulap, tetapi semua yang kita lakukan di sini adalah sama dengan versi rekursif dari program itu, dan dalam urutan yang sama. </p><br><p>  Contoh ini mencerminkan pemikiran yang sering saya ulangi tentang tumpukan panggilan: <em>tujuannya adalah untuk mengkomunikasikan apa yang akan terjadi selanjutnya, dan bukan apa yang sudah terjadi!</em> </p><br><p>  Satu-satunya informasi yang berguna pada stack panggilan dalam versi rekursif program adalah apa yang terjadi <strong>setelah</strong> masalah karena fungsi ini dipanggil berikutnya, dan segala sesuatu yang lain pada stack tidak penting. </p><br><p>  Alih-alih menggunakan panggilan stack sebagai cara yang tidak efisien dan rumit untuk menyimpan <strong>after</strong> stack, kita bisa menyimpan fungsi <strong>after</strong> stack. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lain kali</a> kita akan melihat cara yang lebih kompleks untuk menghapus rekursi dengan Python. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id440178/">https://habr.com/ru/post/id440178/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id440168/index.html">Laporan video dari FunTech ML-meetup</a></li>
<li><a href="../id440170/index.html">Analisis insiden yang terkait dengan serangan dunia maya pada proyek-proyek blockchain</a></li>
<li><a href="../id440172/index.html">CQRS: prinsip "divide and conquer" dalam pelayanan seorang programmer</a></li>
<li><a href="../id440174/index.html">Microsoft Q # Coding Contest - Winter 2019</a></li>
<li><a href="../id440176/index.html">Tujuh tren keamanan dunia maya untuk 2019</a></li>
<li><a href="../id440180/index.html">Q # Kontes Pemrograman: Microsoft Q # Kontes Pengkodean</a></li>
<li><a href="../id440182/index.html">IBM Watson Studio - Platform Pengembangan Aplikasi AI Berbasis Cloud</a></li>
<li><a href="../id440184/index.html">Mengapa kami menggunakan GraphQL di 8base</a></li>
<li><a href="../id440188/index.html">Mencapai Bintang: Menguasai Operator yang Mungkin untuk Mengelola Aplikasi di Kubernetes</a></li>
<li><a href="../id440190/index.html">Berkenalan dengan jaringan saraf paling sederhana dan penerapannya selangkah demi selangkah</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>