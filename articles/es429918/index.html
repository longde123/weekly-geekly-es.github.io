<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñêüèø üìö #‚É£ Mundo virtual Intel. Parte 2: SMP üë©üèΩ‚Äçüåæ üßîüèº üìè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En un art√≠culo anterior (enlace), habl√© sobre el concepto b√°sico de un hipervisor basado en la tecnolog√≠a de virtualizaci√≥n de hardware Intel. Ahora p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mundo virtual Intel. Parte 2: SMP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429918/">  En un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo</a> anterior (enlace), habl√© sobre el concepto b√°sico de un hipervisor basado en la tecnolog√≠a de virtualizaci√≥n de hardware Intel.  Ahora propongo ampliar las capacidades del hipervisor agregando soporte para la arquitectura multiprocesador (SMP), y tambi√©n considero un ejemplo de c√≥mo el hipervisor puede realizar cambios en el sistema operativo invitado. <br><br>  Todas las acciones adicionales se llevar√°n a cabo en la PC con la siguiente configuraci√≥n: <br><br>  CPU: Intel Core i7 5820K <br>  Placa base: Asus X99-PRO <br>  Ram: 16 GB <br>  SO invitado: Windows 7 x32 con PAE deshabilitado <br><a name="habracut"></a><br>  Comenzar√© describiendo la ubicaci√≥n de los componentes del hipervisor en el disco duro (todos los valores se especifican en sectores). <br><br><img src="https://habrastorage.org/webt/in/_l/4b/in_l4birv9nzswyy15vouhjywla.jpeg" alt="imagen"><br>  <i>El proceso de cargar un hipervisor difiere de la versi√≥n anterior solo en presencia de un nuevo m√≥dulo <i>hypervisor.ap</i> , cuyo prop√≥sito es la inicializaci√≥n b√°sica del procesador AP.</i> <br><br>  El proceso de cargar m√≥dulos en la memoria: <br><br><img src="https://habrastorage.org/webt/3a/in/ul/3ainulrasx1dmbgbpodesnsg-qy.jpeg"><br><br>  <b>Soporte SMP</b> <br><br>  Implement√© un hipervisor sobre el principio del multiprocesamiento sim√©trico, lo que significa que se lanzar√° la misma copia de VMX en todos los procesadores l√≥gicos presentes.  Adem√°s, las tablas IDT y GDT, as√≠ como las tablas para la memoria de paginaci√≥n, ser√°n comunes a todos los procesadores l√≥gicos.  Hice esto porque el hipervisor inicializar√° inmediatamente la memoria para el espacio de direcciones del sistema operativo invitado y no hay necesidad de reasignar din√°micamente las direcciones f√≠sicas de p√°ginas individuales.  Adem√°s, con este enfoque, no necesita monitorear la correspondencia de los cach√©s TLB del procesador al costado del hipervisor. <br>  El proceso de inicializaci√≥n para BSP y AP ser√° diferente.  Todas las estructuras principales involucradas en el hipervisor se crear√°n durante la inicializaci√≥n del BSP.  Adem√°s, el estado de actividad para los procesadores AP vmx en modo no root se establecer√° en estado HLT.  Por lo tanto, el entorno del SO hu√©sped se emular√° de acuerdo con lo que ser√≠a sin usar la virtualizaci√≥n. <br><br>  Inicializando BSP: <br><br><ol><li>  Inicializaci√≥n de Spinlock </li><li>  Inicializando y cargando tablas GDT e IDT </li><li>  Inicializando tablas de paginaci√≥n </li><li>  Inicializando estructuras VMCS y creando una tabla EPT com√∫n </li><li>  Activaci√≥n de procesadores AP.  Para hacer esto, se env√≠a una secuencia de interrupci√≥n INIT - SIPI a cada AP.  El vector para la interrupci√≥n SIPI es 0x20, que corresponde a la transferencia del control AP a 0x20000 (m√≥dulo hypervisor.ap) </li><li>  Inicio del SO invitado en 0x7C00 (m√≥dulo win7.mbr) </li></ol><br>  Inicializaci√≥n AP: <br><br><ol><li>  Despu√©s de activar el AP, el procesador est√° en modo real.  El m√≥dulo hypervisor.ap inicializa las tablas de memoria y paginaci√≥n para cambiar al modo largo </li><li>  Descargue IDT, GDT, as√≠ como el cat√°logo de tablas de paginaci√≥n creadas durante la fase de inicializaci√≥n de BSP </li><li>  Inicializaci√≥n de estructuras VMCS y carga de tablas EPT creadas en la etapa de inicializaci√≥n de BSP </li><li>  Cambio al modo vmx no root con estado HLT activo </li></ol><br>  Podemos decir que la implementaci√≥n del soporte SMP en el hipervisor es bastante simple, pero hay algunos puntos sobre los que me gustar√≠a llamar la atenci√≥n. <br><br>  1.soporte legacy usb <br><br>  Es posible que los nuevos modelos de placa base no tengan conectores PS / 2, por lo que se utiliza la compatibilidad con USB Legacy para garantizar la compatibilidad con versiones anteriores.  Esto significa que puede trabajar con un teclado o mouse usb utilizando los mismos m√©todos (puertos de entrada / salida) que con el est√°ndar PS / 2.  La implementaci√≥n de la compatibilidad con USB Legacy no solo depende del modelo de la placa base, sino que tambi√©n puede llamarse en diferentes versiones de firmware.  En mi placa base Asus X99-PRO, el soporte USB Legacy se implementa a trav√©s de interrupciones SMI, en cuyo procesador se produce la emulaci√≥n PS / 2.  Escribo sobre esto con tanto detalle, porque en mi caso (versi√≥n de firmware 3801), el soporte USB heredado no es compatible con el modo largo y cuando regresa de SMM, el procesador entra en estado de apagado. <br><br>  La soluci√≥n m√°s f√°cil en esta situaci√≥n es desactivar la compatibilidad con USB Legacy antes de cambiar al modo largo.  Sin embargo, en Windows, el m√©todo de sondeo del teclado PS / 2 se usa en la etapa de selecci√≥n de las opciones de arranque, por lo que la compatibilidad con USB Legacy debe activarse nuevamente antes de que el SO hu√©sped comience a cargarse. <br><br>  2. Interruptor de tareas de hardware <br><br>  En los sistemas operativos modernos, el cambio entre tareas se implementa, por regla general, mediante m√©todos de software.  Sin embargo, en Windows7, los selectores que apuntan a TSS se asignan a la interrupci√≥n 2 - NMI y 8 - Falla doble, lo que significa que tales interrupciones conducir√°n a un cambio de contexto de hardware.  Intel VMX no es compatible con el conmutador de tareas de hardware, y un intento de ejecutarlo lleva a VM Exit.  Para tales casos, escrib√≠ mi controlador de interruptor de tareas (funci√≥n GuestTaskSwitch).  Una interrupci√≥n de doble falla ocurre solo en el caso de un conflicto grave del sistema causado por el manejo inadecuado de otras interrupciones.  En el proceso de depuraci√≥n, no lo encontr√©.  Pero NMI aparece en los procesadores AP al momento de reiniciar Windows.  Esto todav√≠a plantea mis dudas porque no est√° claro si estos NMI son el resultado de un proceso de reinicio regular o si se trata de una operaci√≥n incorrecta del hipervisor en algunas de las etapas anteriores.  Si tiene alguna informaci√≥n sobre este tema, hable en los comentarios o escr√≠bame en un mensaje personal. <br><br>  <b>Cambios en el sistema operativo invitado</b> <br><br>  Honestamente, no pude decidir durante mucho tiempo exactamente qu√© cambios deber√≠a hacer el hipervisor en el trabajo del sistema operativo invitado.  El hecho es que, por un lado, quer√≠a mostrar algo interesante, como la introducci√≥n de nuestros controladores en protocolos b√°sicos de red, pero por otro lado, todo se reducir√≠a a una gran cantidad de c√≥digo, y hab√≠a poco que ver con el tema de un hipervisor.  Adem√°s, no quer√≠a vincular el hipervisor a ning√∫n conjunto espec√≠fico de hierro. <br><br>  Como resultado, se encontr√≥ el siguiente compromiso: en esta versi√≥n del hipervisor, se implementa el control sobre las llamadas del sistema desde el modo de usuario, en otras palabras, ser√° posible controlar el funcionamiento de las aplicaciones que se ejecutan en el sistema operativo invitado.  Este tipo de control es bastante simple de implementar y adem√°s le permite obtener un resultado visual del trabajo. <br><br>  El control sobre el funcionamiento de las aplicaciones se realizar√° a nivel de llamadas del sistema.  Y el objetivo principal ser√° cambiar el resultado de la funci√≥n <i>NtQuerySystemInformation</i> para que cuando llame con el argumento <i>SystemProcessInformation</i> ( <i>0x05</i> ), pueda interceptar la informaci√≥n del proceso. <br><br>  En Windows 7, el programa de aplicaci√≥n para llamar a la funci√≥n del sistema usa el comando del ensamblador de sysenter, despu√©s de lo cual el control se transfiere al procesador <i>KiFastCallEntry</i> al kernel en el nivel r0.  Para volver al nivel de aplicaci√≥n r3, use el comando sysexit. <br>  Para obtener acceso a los resultados de la funci√≥n <i>NtQuerySystemInformation</i> , debe guardar el n√∫mero de la funci√≥n llamada cada vez que se ejecuta el comando sysenter.  Luego, cuando ejecute <i>sysexit,</i> compare el valor almacenado con el n√∫mero de la funci√≥n que se est√° interceptando y, si hay una coincidencia, realice cambios en los datos devueltos por la funci√≥n. <br>  Intel VMX no proporciona medios directos para monitorear la ejecuci√≥n de <i>sysenter / sysexit</i> , sin embargo, si escribe el valor 0 en <i>Guest MSR IA32_SYSENTER_CS</i> , los <i>comandos sysenter / sysexit</i> generar√°n una excepci√≥n de GP que se puede usar para llamar al controlador de salida de VM.  Para que la excepci√≥n GP llame a VM Exit, debe establecer 13 bits en el campo <i>Exception Bitmap</i> de VMCS. <br><br>  La siguiente estructura se utiliza para emular el par sysenter / sysexit. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class">{</span></span> QWORD ServiceNumber; QWORD Guest_Sys_CS; QWORD Guest_Sys_EIP; QWORD Guest_Sys_ESP; } SysEnter_T;</code> </pre> <br>  El campo <i>ServiceNumber</i> contiene el n√∫mero de la funci√≥n que se llama y se actualiza con cada llamada al sysenter. <br><br>  Los campos <i>Guest_Sys_CS, Guest_Sys_EIP, Guest_Sys_ESP</i> se actualizan cuando el SO hu√©sped intenta escribir en el registro MSR correspondiente.  Para hacer esto, <i>se configuran las</i> m√°scaras de escritura en la <i>direcci√≥n de mapa de bits MSR</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 174H 372 IA32_SYSENTER_CS SYSENTER_CS write mask ptrMSR_BMP[0x100 + (0x174 &gt;&gt; 6)] |= (1UL &lt;&lt; (0x174 &amp; 0x3F)); // 175H 373 IA32_SYSENTER_ESP SYSENTER_ESP write mask ptrMSR_BMP[0x100 + (0x175 &gt;&gt; 6)] |= (1UL &lt;&lt; (0x175 &amp; 0x3F)); // 176H 374 IA32_SYSENTER_EIP SYSENTER_EIP write mask ptrMSR_BMP[0x100 + (0x176 &gt;&gt; 6)] |= (1UL &lt;&lt; (0x176 &amp; 0x3F));</span></span></code> </pre><br>  El SO hu√©sped no deber√≠a ver los cambios realizados por el hipervisor en la operaci√≥n de las llamadas a funciones del sistema.  Al configurar la m√°scara de lectura para <i>MSR IA32_SYSENTER_CS,</i> puede devolver el sistema operativo invitado a su valor de registro original al leer. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 174H 372 IA32_SYSENTER_CS SYSENTER_CS read mask ptrMSR_BMP[0x174 &gt;&gt; 6] |= (1UL &lt;&lt; (0x174 &amp; 0x3F));</span></span></code> </pre><br>  El siguiente es un esquema de emulaci√≥n de comando <i>sysenter / sysexit</i> . <br><br><img src="https://habrastorage.org/webt/bl/wx/vo/blwxvocgthxx_0skhnjmm4sbf4i.jpeg"><br><br>  En la <i>etapa de</i> emulaci√≥n <i>sysexit</i> , el n√∫mero almacenado de la funci√≥n llamada se compara con el n√∫mero NtQuerySystemInformation (0x105).  En el caso de una coincidencia, se verifica que se llame a NtQuerySystemInformation con el argumento de informaci√≥n del proceso del sistema y, de ser as√≠, la funci√≥n <i>ChangeProcessNames (DWORD SPI_GVA, DWORD SPI_size)</i> realiza cambios en las estructuras que contienen informaci√≥n sobre los procesos. <br>  <i>SPI_GVA</i> es la direcci√≥n virtual invitada de la estructura <i>SYSTEM_PROCESS_INFORMATION</i> <br>  <i>SPI_size</i> es el tama√±o total de las estructuras en bytes. <br>  La estructura <i>SYSTEM_PROCESS_INFORMATION en s√≠ se</i> ve as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SYSTEM_PROCESS_INFORMATION</span></span></span><span class="hljs-class"> {</span></span> ULONG NextEntryOffset; ULONG NumberOfThreads; BYTE Reserved1[<span class="hljs-number"><span class="hljs-number">48</span></span>]; UNICODE_STRING ImageName; KPRIORITY BasePriority; HANDLE UniqueProcessId; PVOID Reserved2; ULONG HandleCount; ULONG SessionId; PVOID Reserved3; SIZE_T PeakVirtualSize; SIZE_T VirtualSize; ULONG Reserved4; SIZE_T PeakWorkingSetSize; SIZE_T WorkingSetSize; PVOID Reserved5; SIZE_T QuotaPagedPoolUsage; PVOID Reserved6; SIZE_T QuotaNonPagedPoolUsage; SIZE_T PagefileUsage; SIZE_T PeakPagefileUsage; SIZE_T PrivatePageCount; LARGE_INTEGER Reserved7[<span class="hljs-number"><span class="hljs-number">6</span></span>]; } SYSTEM_PROCESS_INFORMATION;</code> </pre><br>  No hay nada complicado en su an√°lisis, lo principal es no olvidar traducir la direcci√≥n virtual del invitado en f√≠sica, para esto se utiliza la funci√≥n <i>GuestLinAddrToPhysAddr ()</i> . <br><br>  Para mayor claridad, reemplac√© los dos primeros caracteres en los nombres de todos los procesos con un signo ' <b>:)</b> '. El resultado de dicho reemplazo es visible en la captura de pantalla. <br><br><img src="https://habrastorage.org/webt/rs/nq/rt/rsnqrtxvkrcoc0r_4xgjnuabk8o.png"><br><br>  <b>Resumen</b> <br><br>  En general, se completaron las tareas establecidas al comienzo del art√≠culo.  El hipervisor garantiza el funcionamiento estable del sistema operativo invitado y tambi√©n controla la llamada de las funciones del sistema desde el nivel de la aplicaci√≥n.  Observo que el principal inconveniente de usar la emulaci√≥n de comandos <i>sysenter / sysexit</i> es un aumento significativo en las llamadas de salida de VM, que afecta el rendimiento y esto es especialmente notable cuando el sistema operativo invitado est√° en modo de procesador √∫nico.  Esta desventaja puede eliminarse si controla las llamadas solo en el contexto de los procesos seleccionados. <br><br>  Y eso es todo por ahora.  Las fuentes del art√≠culo pueden consultarse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠.</a> <br><br>  Gracias por su atencion </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es429918/">https://habr.com/ru/post/es429918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es429908/index.html">C√≥mo usar corutinas en la comida y dormir tranquilo por la noche</a></li>
<li><a href="../es429910/index.html">AppsConf Rises</a></li>
<li><a href="../es429912/index.html">Desarrollo de bibliotecas: de API a lanzamiento p√∫blico</a></li>
<li><a href="../es429914/index.html">OpenSceneGraph: Gr√°fico de escena y punteros inteligentes</a></li>
<li><a href="../es429916/index.html">C√≥mo construir y construir</a></li>
<li><a href="../es429920/index.html">Tragicomedia en actos de NaN: c√≥mo creamos un juego en JS y lo lanzamos en Steam</a></li>
<li><a href="../es429922/index.html">C√≥mo convertir un proyecto simple en una construcci√≥n a largo plazo o cortar todo lo innecesario</a></li>
<li><a href="../es429928/index.html">Todo lo que necesitas saber sobre el estr√©s y las emociones fuertes.</a></li>
<li><a href="../es429930/index.html">Splunk Soluci√≥n f√°cil de problemas de aplicaciones</a></li>
<li><a href="../es429934/index.html">Que hay</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>