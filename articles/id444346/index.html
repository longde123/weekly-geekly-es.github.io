<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•£ ü§Æ üê© GraphQL dan Golang üê¨ üëØ üë®üèΩ‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teknologi GraphQL selama beberapa tahun terakhir, setelah perusahaan Facebook memindahkannya ke kategori open-source, telah menjadi sangat populer. Pe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GraphQL dan Golang</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/444346/">  Teknologi GraphQL selama beberapa tahun terakhir, setelah perusahaan Facebook memindahkannya ke kategori open-source, telah menjadi sangat populer.  Penulis materi, terjemahan yang kami terbitkan hari ini, mengatakan bahwa ia mencoba bekerja dengan GraphQL di Node.js dan, dari pengalamannya sendiri, yakin bahwa teknologi ini, berkat kemampuan dan kesederhanaannya yang luar biasa, tidak sengaja menarik begitu banyak perhatian.  Baru-baru ini, saat terlibat dalam proyek baru, ia beralih dari Node.js ke Golang.  Kemudian dia memutuskan untuk menguji kolaborasi Golang dan GraphQL. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/jp/qa/qv/jpqaqvlt5xh7d7mlhwpxvvwhptq.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Informasi awal</font> </h2><br>  Anda bisa belajar dari definisi GraphQL resmi bahwa ini adalah bahasa permintaan untuk API dan runtime untuk mengeksekusi pertanyaan seperti itu pada data yang ada.  GraphQL memberikan deskripsi data yang lengkap dan dapat dipahami dalam API tertentu, memungkinkan pelanggan untuk meminta informasi yang dibutuhkan secara tepat, dan tidak lebih, menyederhanakan pengembangan API dari waktu ke waktu dan memberi pengembang alat yang kuat. <br><br>  Tidak banyak perpustakaan GraphQL untuk Golang.  Secara khusus, saya mencoba perpustakaan seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Thunder</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">graphql</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">graphql-go</a> , dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gqlgen</a> .  Saya harus mencatat bahwa yang terbaik dari semua yang saya coba adalah perpustakaan gqlgen. <br><br>  Pustaka gqlgen masih dalam versi beta, pada saat penulisan materi ini, versi <a href="">0.7.2</a> .  Perpustakaan berkembang pesat.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini</a> Anda dapat mengetahui tentang rencana pengembangannya.  Sekarang sponsor resmi gqlgen adalah proyek desain 99, yang berarti bahwa perpustakaan ini, sangat mungkin, akan berkembang lebih cepat daripada sebelumnya.  Pengembang utama perpustakaan ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">vektah</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">neelance</a> , sementara neelance, selain itu, berfungsi di perpustakaan graphql-go. <br><br>  Mari kita bicara tentang perpustakaan gqlgen berdasarkan asumsi bahwa Anda sudah memiliki pengetahuan dasar tentang GraphQL. <br><br><h2>  <font color="#3AC1EF">Fitur Gqlgen</font> </h2><br>  Dalam deskripsi gqlgen, Anda dapat mengetahui apa yang kami miliki sebelum kami adalah pustaka untuk membuat server GraphQL yang diketik dengan ketat di Golang.  Frasa ini tampaknya sangat menjanjikan bagi saya, karena itu berarti bahwa ketika bekerja dengan perpustakaan ini saya tidak akan menemukan sesuatu seperti <code>map[string]interface{}</code> , karena pendekatan berdasarkan pengetikan ketat digunakan di sini. <br><br>  Selain itu, perpustakaan ini menggunakan pendekatan yang didasarkan pada skema data.  Ini berarti bahwa API dijelaskan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bahasa Definisi Skema</a> GraphQL.  Bahasa ini memiliki alat pembuat kode sendiri yang kuat yang secara otomatis membuat kode GraphQL.  Dalam hal ini, programmer hanya dapat mengimplementasikan logika dasar dari metode antarmuka yang sesuai. <br><br>  Artikel ini dibagi menjadi dua bagian.  Yang pertama dikhususkan untuk metode kerja dasar, dan yang kedua untuk yang maju. <br><br><h2>  <font color="#3AC1EF">Metode kerja utama: pengaturan, permintaan untuk menerima dan mengubah data, langganan</font> </h2><br>  Kami, sebagai aplikasi eksperimental, akan menggunakan situs tempat pengguna dapat mempublikasikan video, menambahkan tangkapan layar dan ulasan, mencari video dan melihat daftar rekaman yang terkait dengan catatan lain.  Mari kita mulai mengerjakan proyek ini: <br><br><pre> <code class="go hljs">mkdir -p $GOPATH/src/github.com/ridhamtarpara/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-graphql-demo/</code> </pre> <br>  Buat file skema data berikut ( <code>schema.graphql</code> ) di direktori root proyek: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> User {   id: ID!   name: String!   email: String! } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Video {   id: ID!   name: String!   description: String!   user: User!   url: String!   createdAt: Timestamp!   screenshots: [Screenshot]   related(limit: Int = <span class="hljs-number"><span class="hljs-number">25</span></span>, offset: Int = <span class="hljs-number"><span class="hljs-number">0</span></span>): [Video!]! } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Screenshot {   id: ID!   videoId: ID!   url: String! } input NewVideo {   name: String!   description: String!   userId: ID!   url: String! } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Mutation {   createVideo(input: NewVideo!): Video! } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Query {   Videos(limit: Int = <span class="hljs-number"><span class="hljs-number">25</span></span>, offset: Int = <span class="hljs-number"><span class="hljs-number">0</span></span>): [Video!]! } scalar Timestamp</code> </pre> <br>  Berikut ini dijelaskan model data dasar, satu mutasi ( <code>Mutation</code> , deskripsi permintaan untuk perubahan data), yang digunakan untuk mempublikasikan file video baru di situs, dan satu permintaan ( <code>Query</code> ) untuk mendapatkan daftar semua file video.  Baca lebih lanjut tentang skema GraphQL di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Selain itu, di sini kami mendeklarasikan salah satu tipe data skalar kami sendiri.  Kami tidak puas dengan 5 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tipe</a> data skalar standar ( <code>Int</code> , <code>Float</code> , <code>String</code> , <code>Boolean</code> dan <code>ID</code> ) yang ada di GraphQL. <br><br>  Jika Anda perlu menggunakan tipe Anda sendiri, Anda dapat mendeklarasikannya di <code>schema.graphql</code> (dalam kasus kami, tipe ini adalah <code>Timestamp</code> ) dan memberikan definisi mereka dalam kode.  Saat menggunakan pustaka gqlgen, Anda perlu menyediakan metode untuk membuat dan meng-unmarshaling semua jenis skalar Anda sendiri dan mengonfigurasi pemetaan menggunakan <code>gqlgen.yml</code> . <br><br>  Perlu dicatat bahwa dalam versi terbaru perpustakaan ada satu perubahan penting.  Yaitu, ketergantungan pada file biner yang dikompilasi dihapus dari itu.  Oleh karena itu, file <code>scripts/gqlgen.go</code> harus ditambahkan ke proyek <code>scripts/gqlgen.go</code> konten berikut: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// +build ignore package main import "github.com/99designs/gqlgen/cmd" func main() { cmd.Execute() }</span></span></code> </pre> <br>  Setelah itu, Anda perlu menginisialisasi <code>dep</code> : <br><br><pre> <code class="go hljs">dep init</code> </pre> <br>  Sekarang saatnya untuk mengambil keuntungan dari kemampuan pembuatan kode perpustakaan.  Mereka memungkinkan Anda untuk membuat semua kode boilerplate yang membosankan, yang, bagaimanapun, tidak dapat disebut sepenuhnya tidak menarik.  Untuk memulai mekanisme pembuatan kode otomatis, jalankan perintah berikut: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> run scripts/gqlgen.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> init</code> </pre> <br>  Sebagai hasil dari eksekusi, file-file berikut akan dibuat: <br><br><ul><li>  <code>gqlgen.yml</code> : file konfigurasi untuk mengelola pembuatan kode. <br></li><li>  <code>generated.go</code> : kode yang dihasilkan. <br></li><li>  <code>models_gen.go</code> : semua model dan tipe data dari skema yang disediakan. <br></li><li>  <code>resolver.go</code> : ini akan menjadi kode yang dibuat oleh programmer. <br></li><li>  <code>server/server.go</code> : titik masuk dengan <code>http.Handler</code> untuk memulai server GraphQL. <br></li></ul><br>  Lihatlah model yang dibuat untuk jenis <code>Video</code> (file <code>generated_video.go</code> ): <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Video <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID          <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>  <span class="hljs-string"><span class="hljs-string">`json:"id"`</span></span> Name        <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>  <span class="hljs-string"><span class="hljs-string">`json:"name"`</span></span> User        User  <span class="hljs-string"><span class="hljs-string">`json:"user"`</span></span> URL         <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>  <span class="hljs-string"><span class="hljs-string">`json:"url"`</span></span> CreatedAt   <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>  <span class="hljs-string"><span class="hljs-string">`json:"createdAt"`</span></span> Screenshots []*Screenshot <span class="hljs-string"><span class="hljs-string">`json:"screenshots"`</span></span> Related     []Video  <span class="hljs-string"><span class="hljs-string">`json:"related"`</span></span> }</code> </pre> <br>  Di sini Anda dapat melihat bahwa <code>ID</code> adalah sebuah string, <code>CreatedAt</code> juga sebuah string.  Model terkait lainnya dikonfigurasi sesuai.  Namun, dalam aplikasi nyata ini tidak diperlukan.  Jika Anda menggunakan semua jenis data SQL, maka Anda perlu, misalnya, bahwa bidang <code>ID</code> akan, tergantung pada database yang digunakan, tipe <code>int</code> atau <code>int64</code> . <br><br>  Sebagai contoh, saya menggunakan PostgreSQL dalam aplikasi demo ini, jadi tentu saja saya memerlukan bidang <code>ID</code> untuk menjadi tipe <code>int</code> dan <code>CreatedAt</code> jenis <code>time.Time</code> . Waktu.  Ini mengarah pada fakta bahwa kita perlu mendefinisikan model kita sendiri dan memberi tahu gqlgen bahwa kita perlu menggunakan model kita alih-alih menghasilkan yang baru.  Berikut ini isi file <code>models.go</code> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Video <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID          <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"id"`</span></span> Name        <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"name"`</span></span> Description <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>    <span class="hljs-string"><span class="hljs-string">`json:"description"`</span></span> User        User <span class="hljs-string"><span class="hljs-string">`json:"user"`</span></span> URL         <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"url"`</span></span> CreatedAt   time.Time <span class="hljs-string"><span class="hljs-string">`json:"createdAt"`</span></span> Related     []Video } <span class="hljs-comment"><span class="hljs-comment">//    int  ID func MarshalID(id int) graphql.Marshaler { return graphql.WriterFunc(func(w io.Writer) {   io.WriteString(w, strconv.Quote(fmt.Sprintf("%d", id))) }) } //        func UnmarshalID(v interface{}) (int, error) { id, ok := v.(string) if !ok {   return 0, fmt.Errorf("ids must be strings") } i, e := strconv.Atoi(id) return int(i), e } func MarshalTimestamp(t time.Time) graphql.Marshaler { timestamp := t.Unix() * 1000 return graphql.WriterFunc(func(w io.Writer) {   io.WriteString(w, strconv.FormatInt(timestamp, 10)) }) } func UnmarshalTimestamp(v interface{}) (time.Time, error) { if tmpStr, ok := v.(int); ok {   return time.Unix(int64(tmpStr), 0), nil } return time.Time{}, errors.TimeStampError }</span></span></code> </pre> <br>  Kami memberi tahu perpustakaan bahwa itu harus menggunakan model ini (file <code>gqlgen.yml</code> ): <br><br><pre> <code class="go hljs">schema: - schema.graphql exec: filename: generated.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> model: filename: models_gen.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> resolver: filename: resolver.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: Resolver models: Video:   model: github.com/ridhamtarpara/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-graphql-demo/api.Video ID:   model: github.com/ridhamtarpara/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-graphql-demo/api.ID Timestamp:   model: github.com/ridhamtarpara/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-graphql-demo/api.Timestamp</code> </pre> <br>  Maksud dari semua ini adalah bahwa kita sekarang memiliki definisi kita sendiri untuk <code>ID</code> dan <code>Timestamp</code> dengan metode untuk marshaling dan unmarshaling dan memetakannya dalam file <code>gqlgen.yml</code> .  Sekarang pengguna menyediakan string sebagai <code>ID</code> , metode <code>UnmarshalID()</code> mengubah string itu menjadi integer.  Saat mengirim respons, metode <code>MarshalID()</code> mengubah angka menjadi string.  Hal yang sama terjadi dengan <code>Timestamp</code> atau dengan jenis skalar lain yang dideklarasikan oleh programmer. <br><br>  Sekarang saatnya mengimplementasikan logika aplikasi.  Buka file <code>resolver.go</code> dan tambahkan deskripsi mutasi dan kueri ke dalamnya.  Sudah ada kode boilerplate yang dihasilkan secara otomatis yang harus kita isi dengan maknanya.  Ini kode untuk file ini: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *mutationResolver)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateVideo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, input NewVideo)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(api.Video, error)</span></span></span></span> { newVideo := api.Video{   URL:         input.URL,   Name:        input.Name,   CreatedAt:   time.Now().UTC(), } rows, err := dal.LogAndQuery(r.db, <span class="hljs-string"><span class="hljs-string">"INSERT INTO videos (name, url, user_id, created_at) VALUES($1, $2, $3, $4) RETURNING id"</span></span>,   input.Name, input.URL, input.UserID, newVideo.CreatedAt) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> rows.Close() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> || !rows.Next() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> api.Video{}, err } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := rows.Scan(&amp;newVideo.ID); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {   errors.DebugPrintf(err)   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.IsForeignKeyError(err) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> api.Video{}, errors.UserNotExist   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> api.Video{}, errors.InternalServerError } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newVideo, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *queryResolver)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Videos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, limit *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, offset *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]api.Video, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> video api.Video <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> videos []api.Video rows, err := dal.LogAndQuery(r.db, <span class="hljs-string"><span class="hljs-string">"SELECT id, name, url, created_at, user_id FROM videos ORDER BY created_at desc limit $1 offset $2"</span></span>, limit, offset) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> rows.Close();   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {   errors.DebugPrintf(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.InternalServerError } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rows.Next() {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := rows.Scan(&amp;video.ID, &amp;video.Name, &amp;video.URL, &amp;video.CreatedAt, &amp;video.UserID); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {     errors.DebugPrintf(err)     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.InternalServerError   }   videos = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(videos, video) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> videos, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Sekarang mari kita uji mutasi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7b/a2c/01f/f7ba2c01f766ebc31ed90880376136f1.png"></div>  <i><font color="#999999">Mutasi createVideo</font></i> <br><br>  Itu berhasil!  Tetapi mengapa tidak ada informasi <code>user</code> (objek <code>user</code> )?  Saat bekerja dengan GraphQL, konsep yang mirip dengan pemuatan "malas" (lazy) dan "serakah" (bersemangat) dapat diterapkan.  Karena sistem ini dapat dikembangkan, Anda perlu menentukan bidang mana yang harus diisi "dengan rakus" dan mana yang "malas". <br><br>  Saya menyarankan kepada tim di organisasi tempat saya bekerja dengan "aturan emas" berikut yang berlaku ketika bekerja dengan gqlgen: "Jangan memasukkan dalam model bidang yang perlu dimuat hanya jika diminta oleh klien." <br><br>  Dalam kasus kami, saya perlu mengunduh data tentang klip video terkait (dan bahkan informasi pengguna) hanya jika klien meminta bidang ini.  Tetapi karena kami memasukkan bidang ini dalam model, gqlgen mengasumsikan bahwa kami menyediakan data ini dengan menerima informasi tentang video.  Hasilnya, sekarang kita mendapatkan struktur kosong. <br><br>  Kadang-kadang terjadi bahwa jenis data tertentu diperlukan setiap kali, sehingga tidak praktis untuk mengunduhnya menggunakan permintaan terpisah.  Untuk ini, untuk meningkatkan kinerja, Anda dapat menggunakan sesuatu seperti SQL join.  Sekali (ini, bagaimanapun, tidak berlaku untuk contoh yang dipertimbangkan di sini), saya perlu mengunggah metadata bersama dengan video.  Entitas-entitas ini disimpan di tempat yang berbeda.  Akibatnya, jika sistem saya menerima permintaan untuk mengunduh video, saya harus membuat permintaan lain untuk mendapatkan metadata.  Tetapi, karena saya tahu tentang persyaratan ini (yaitu, saya tahu bahwa klien dan video dan metadata-nya selalu diperlukan di sisi klien), saya lebih suka menggunakan teknik pemuatan serakah untuk meningkatkan kinerja. <br><br>  Mari kita menulis ulang model dan menghasilkan kode gqlgen lagi.  Agar tidak menyulitkan cerita, kami hanya menulis metode untuk bidang <code>user</code> (file <code>models.go</code> ): <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Video <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID          <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"id"`</span></span> Name        <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"name"`</span></span> Description <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>    <span class="hljs-string"><span class="hljs-string">`json:"description"`</span></span> UserID      <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"-"`</span></span> URL         <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"url"`</span></span> CreatedAt   time.Time <span class="hljs-string"><span class="hljs-string">`json:"createdAt"`</span></span> }</code> </pre> <br>  Kami menambahkan <code>UserID</code> dan menghapus struktur <code>User</code> .  Sekarang buat ulang kode: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> run scripts/gqlgen.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> -v</code> </pre> <br>  Berkat perintah ini, metode antarmuka berikut akan dibuat untuk menyelesaikan struktur yang tidak ditentukan.  Selain itu, Anda perlu menentukan yang berikut ini di resolver (file <code>generated.go</code> ): <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> VideoResolver <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { User(ctx context.Context, obj *api.Video) (api.User, error) Screenshots(ctx context.Context, obj *api.Video) ([]*api.Screenshot, error) Related(ctx context.Context, obj *api.Video, limit *<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, offset *<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) ([]api.Video, error) }</code> </pre> <br>  Berikut ini definisi (file <code>resolver.go</code> ): <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *videoResolver)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, obj *api.Video)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(api.User, error)</span></span></span></span> { rows, _ := dal.LogAndQuery(r.db,<span class="hljs-string"><span class="hljs-string">"SELECT id, name, email FROM users where id = $1"</span></span>, obj.UserID) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> rows.Close() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !rows.Next() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> api.User{}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user api.User <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := rows.Scan(&amp;user.ID, &amp;user.Name, &amp;user.Email); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {   errors.DebugPrintf(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> api.User{}, errors.InternalServerError } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Sekarang, hasil tes mutasi akan terlihat seperti yang ditunjukkan di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/25a/41d/aaa/25a41daaa86b8db5407bd432312c3028.png"></div><br>  <i><font color="#999999">Mutasi createVideo</font></i> <br><br>  Apa yang baru saja kita bahas adalah dasar-dasar GraphQL, setelah menguasainya, Anda sudah bisa menulis sesuatu sendiri.  Namun, sebelum Anda terjun ke eksperimen dengan GraphQL dan Golang, akan berguna untuk berbicara tentang langganan, yang secara langsung terkait dengan apa yang kami lakukan di sini. <br><br><h3>  <font color="#3AC1EF">‚ñç Berlangganan</font> </h3><br>  GraphQL menyediakan kemampuan untuk berlangganan perubahan data yang terjadi secara real time.  Perpustakaan gqlgen memungkinkan, secara real time, menggunakan soket web, untuk bekerja dengan acara berlangganan. <br><br>  Langganan harus dijelaskan dalam file <code>schema.graphql</code> .  Berikut ini deskripsi berlangganan ke acara penerbitan video: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Subscription {   videoPublished: Video! }</code> </pre> <br>  Sekarang, jalankan pembuatan kode otomatis lagi: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> run scripts/gqlgen.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> -v</code> </pre> <br>  Seperti yang telah disebutkan, selama pembuatan kode secara otomatis dalam file <code>generated.go</code> , sebuah antarmuka dibuat yang harus diimplementasikan dalam pengenal.  Dalam kasus kami, sepertinya ini (file <code>resolver.go</code> ): <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> videoPublishedChannel <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> api.Video <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { videoPublishedChannel = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> api.Video{} } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> subscriptionResolver <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ *Resolver } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *subscriptionResolver)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VideoPublished</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&lt;-</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> api.Video, error)</span></span></span></span> { id := randx.String(<span class="hljs-number"><span class="hljs-number">8</span></span>) videoEvent := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> api.Video, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   &lt;-ctx.Done() }() videoPublishedChannel[id] = videoEvent <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> videoEvent, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *mutationResolver)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateVideo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, input NewVideo)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(api.Video, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ... for _, observer := range videoPublishedChannel {   observer &lt;- newVideo } return newVideo, nil }</span></span></code> </pre> <br>  Sekarang, saat membuat video baru, Anda perlu memicu suatu peristiwa.  Dalam contoh kami, ini dilakukan pada baris <code>for _, observer := range videoPublishedChannel</code> . <br><br>  Sekarang saatnya untuk memeriksa langganan Anda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f71/d7f/42b/f71d7f42b147f59d227a25e577ef57fb.gif"></div><br>  <i><font color="#999999">Verifikasi Berlangganan</font></i> <br><br>  GraphQL, tentu saja, memiliki kemampuan berharga tertentu, tetapi seperti yang mereka katakan, tidak semua yang berkilau itu emas.  Yaitu, kita berbicara tentang fakta bahwa seseorang yang menggunakan GraphQL perlu mengurus otorisasi, kompleksitas permintaan, caching, masalah permintaan N +1, keterbatasan kecepatan eksekusi permintaan, dan beberapa hal lainnya.  Jika tidak, sistem yang dikembangkan menggunakan GraphQL dapat menghadapi penurunan kinerja yang serius. <br><br><h2>  <font color="#3AC1EF">Teknik Lanjut: Otentikasi, Pemuat Data, Kompleksitas Kueri</font> </h2><br>  Setiap kali saya membaca manual seperti ini, saya merasa bahwa, setelah menguasainya, saya mempelajari semua yang perlu saya ketahui tentang teknologi tertentu dan mendapatkan kemampuan untuk menyelesaikan masalah kompleksitas apa pun. <br><br>  Tetapi ketika saya mulai mengerjakan proyek saya sendiri, saya biasanya masuk ke situasi yang tidak terduga yang terlihat seperti kesalahan server atau seperti permintaan yang telah berjalan lama, atau seperti beberapa situasi jalan buntu lainnya.  Sebagai akibatnya, untuk melakukan ini, saya harus mempelajari apa yang baru-baru ini tampak sangat bisa dimengerti.  Dalam manual yang sama ini, saya berharap ini bisa dihindari.  Itulah sebabnya di bagian ini kita akan melihat beberapa teknik canggih untuk bekerja dengan GraphQL. <br><br><h3>  <font color="#3AC1EF">‚ñç Otentikasi</font> </h3><br>  Saat bekerja dengan REST API, kami memiliki sistem otentikasi dan alat otorisasi standar saat bekerja dengan titik akhir tertentu.  Tetapi ketika menggunakan GraphQL, hanya satu titik akhir yang digunakan, oleh karena itu, tugas otentikasi dapat diselesaikan menggunakan arahan skema.  Edit file <code>schema.graphql</code> sebagai berikut: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Mutation {   createVideo(input: NewVideo!): Video! @isAuthenticated } directive @isAuthenticated on FIELD_DEFINITION</code> </pre> <br>  Kami membuat arahan <code>isAuthenticated</code> dan menerapkannya pada langganan <code>createVideo</code> .  Setelah sesi pembuatan kode otomatis berikutnya, Anda perlu menentukan definisi untuk arahan ini.  Sekarang arahan diterapkan dalam bentuk metode struktur, dan bukan dalam bentuk antarmuka, jadi kita perlu menggambarkannya.  Saya mengedit kode yang dibuat secara otomatis yang terletak di file <code>server.go</code> dan membuat metode yang mengembalikan konfigurasi GraphQL untuk file <code>server.go</code> .  Ini adalah file <code>resolver.go</code> : <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewRootResolvers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(db *sql.DB)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Config</span></span></span></span> { c := Config{   Resolvers: &amp;Resolver{     db: db,   }, } <span class="hljs-comment"><span class="hljs-comment">//   c.Directives.IsAuthenticated = func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error) {   ctxUserID := ctx.Value(UserIDCtxKey)   if ctxUserID != nil {     return next(ctx)   } else {     return nil, errors.UnauthorisedError   } } return c }</span></span></code> </pre> <br>  Ini adalah file <code>server.go</code> : <br><br><pre> <code class="go hljs">rootHandler:= dataloaders.DataloaderMiddleware(   db,   handler.GraphQL(     go_graphql_demo.NewExecutableSchema(go_graphql_demo.NewRootResolvers(db)   ) ) http.Handle(<span class="hljs-string"><span class="hljs-string">"/query"</span></span>, auth.AuthMiddleware(rootHandler))</code> </pre> <br>  Kami membaca <code>ID</code> pengguna dari konteksnya.  Apakah Anda tidak menemukan ini aneh?  Bagaimana makna ini masuk ke dalam konteks dan mengapa itu muncul dalam konteks?  Faktanya adalah bahwa gqlgen menyediakan konteks permintaan hanya pada tingkat implementasi, jadi kami tidak memiliki cara untuk membaca data permintaan HTTP apa pun, seperti header atau cookie, dalam pengenal atau arahan.  Akibatnya, Anda perlu menambahkan mekanisme perantara Anda sendiri ke sistem, menerima data ini dan memasukkannya ke dalam konteks. <br><br>  Sekarang kita perlu menggambarkan mekanisme otentikasi perantara kita sendiri untuk mendapatkan data otentikasi dari permintaan dan memverifikasinya. <br><br>  Tidak ada logika yang didefinisikan di sini.  Sebagai gantinya, untuk data otorisasi, untuk tujuan demonstrasi, <code>ID</code> pengguna hanya diteruskan di sini.  Mekanisme ini kemudian digabungkan dalam <code>server.go</code> dengan metode pemuatan konfigurasi baru. <br><br>  Sekarang deskripsi arahan masuk akal.  Kami tidak memproses permintaan pengguna yang tidak sah dalam kode middleware, karena permintaan tersebut akan diproses oleh arahan.  Ini tampilannya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f6/a26/09c/6f6a2609cec8936c024fd68c7ed30096.png"></div><br>  <i><font color="#999999">Bekerja dengan pengguna yang tidak sah</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/267/b92/378/267b923783521a82738973f82600a2a4.png"></div><br>  <i><font color="#999999">Bekerja dengan pengguna yang diotorisasi</font></i> <br><br>  Saat bekerja dengan arahan skema, Anda bahkan dapat menyampaikan argumen: <br><br><pre> <code class="go hljs">directive @hasRole(role: Role!) on FIELD_DEFINITION enum Role { ADMIN USER }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçData loader</font> </h3><br>  Menurut saya semua ini terlihat cukup menarik.  Anda mengunduh data saat Anda membutuhkannya.  Klien memiliki kemampuan untuk mengelola data, persis apa yang dibutuhkan diambil dari penyimpanan.  Tapi semuanya punya harga. <br><br>  Berapa harga yang harus dibayar untuk peluang ini?  Lihatlah log unduhan semua video.  Yaitu, kita berbicara tentang fakta bahwa kita memiliki 8 video dan 5 pengguna. <br><br><pre> <code class="go hljs">query{ Videos(limit: <span class="hljs-number"><span class="hljs-number">10</span></span>){   name   user{     name   } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/562/7c1/b5c/5627c1b5c34f74aec26381f8b0431147.png"></div><br>  <i><font color="#999999">Detail Pengunduhan Video</font></i> <br><br><pre> <code class="go hljs">Query: Videos : SELECT id, name, description, url, created_at, user_id FROM videos ORDER BY created_at desc limit $<span class="hljs-number"><span class="hljs-number">1</span></span> offset $<span class="hljs-number"><span class="hljs-number">2</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Apa yang sedang terjadi di sini?  Mengapa ada 9 permintaan (1 permintaan dikaitkan dengan tabel video dan 8 - dengan tabel pengguna)?  Terlihat mengerikan.  Hati saya hampir berhenti ketika saya berpikir bahwa API kami yang ada harus diganti dengan ini ... Benar, pemuat data dapat sepenuhnya mengatasi masalah ini. <br><br>  Ini dikenal sebagai masalah N + 1. Kita berbicara tentang fakta bahwa ada satu query untuk mendapatkan semua data dan untuk setiap bagian data (N) akan ada query lain ke database. <br><br>  Ini adalah masalah yang sangat serius dalam hal kinerja dan sumber daya: meskipun permintaan ini paralel, mereka menguras sumber daya sistem. <br><br>  Untuk mengatasi masalah ini, kita akan menggunakan pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dataloaden</a> dari penulis pustaka gqlgen.  Perpustakaan ini memungkinkan Anda untuk menghasilkan kode Go.  Pertama, buat pemuat data untuk entitas <code>User</code> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> get github.com/vektah/dataloaden dataloaden github.com/ridhamtarpara/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-graphql-demo/api.User</code> </pre> <br>  Kami siap menggunakan file <code>userloader_gen.go</code> , yang memiliki metode seperti <code>Fetch</code> , <code>LoadAll</code> dan <code>Prime</code> . <br><br>  Sekarang, untuk mendapatkan hasil umum, kita perlu mendefinisikan metode <code>Fetch</code> (file <code>dataloader.go</code> ): <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DataloaderMiddleware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(db *sql.DB, next http.Handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.HandlerFunc(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> {   userloader := UserLoader{     wait : <span class="hljs-number"><span class="hljs-number">1</span></span> * time.Millisecond,     maxBatch: <span class="hljs-number"><span class="hljs-number">100</span></span>,     fetch: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ids []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]*api.User, []error)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sqlQuery <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(ids) == <span class="hljs-number"><span class="hljs-number">1</span></span> {         sqlQuery = <span class="hljs-string"><span class="hljs-string">"SELECT id, name, email from users WHERE id = ?"</span></span>       } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {         sqlQuery = <span class="hljs-string"><span class="hljs-string">"SELECT id, name, email from users WHERE id IN (?)"</span></span>       }       sqlQuery, arguments, err := sqlx.In(sqlQuery, ids)       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {         log.Println(err)       }       sqlQuery = sqlx.Rebind(sqlx.DOLLAR, sqlQuery)       rows, err := dal.LogAndQuery(db, sqlQuery, arguments...)       <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> rows.Close();       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {         log.Println(err)       }       userById := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]*api.User{}       <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rows.Next() {         user:= api.User{}         <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := rows.Scan(&amp;user.ID, &amp;user.Name, &amp;user.Email); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {           errors.DebugPrintf(err)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, []error{errors.InternalServerError}         }         userById[user.ID] = &amp;user       }       users := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]*api.User, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(ids))       <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, id := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ids {         users[i] = userById[id]         i++       }       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> users, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>     },   }   ctx := context.WithValue(r.Context(), CtxKey, &amp;userloader)   r = r.WithContext(ctx)   next.ServeHTTP(w, r) }) }</code> </pre> <br>  Di sini kita tunggu 1 ms.  sebelum menjalankan permintaan dan mengumpulkan permintaan dalam paket hingga 100 permintaan.  Sekarang, alih-alih mengeksekusi permintaan untuk setiap pengguna secara individual, loader akan menunggu waktu yang ditentukan sebelum mengakses database.  Selanjutnya, Anda perlu mengubah logika pengenal dengan mengkonfigurasi ulang menggunakan permintaan untuk menggunakan pemuat data (file <code>resolver.go</code> ): <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *videoResolver)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, obj *api.Video)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(api.User, error)</span></span></span></span> { user, err := ctx.Value(dataloaders.CtxKey).(*dataloaders.UserLoader).Load(obj.UserID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *user, err }</code> </pre> <br>  Begini cara log terlihat setelah itu dalam situasi yang mirip dengan yang dijelaskan di atas: <br><br><pre> <code class="go hljs">Query: Videos : SELECT id, name, description, url, created_at, user_id FROM videos ORDER BY created_at desc limit $<span class="hljs-number"><span class="hljs-number">1</span></span> offset $<span class="hljs-number"><span class="hljs-number">2</span></span> Dataloader: User : SELECT id, name, email from users WHERE id IN ($<span class="hljs-number"><span class="hljs-number">1</span></span>, $<span class="hljs-number"><span class="hljs-number">2</span></span>, $<span class="hljs-number"><span class="hljs-number">3</span></span>, $<span class="hljs-number"><span class="hljs-number">4</span></span>, $<span class="hljs-number"><span class="hljs-number">5</span></span>)</code> </pre> <br>  Hanya dua permintaan basis data yang dieksekusi di sini, sebagai hasilnya, semua orang sekarang senang.  Sangat menarik untuk dicatat bahwa hanya 5 pengidentifikasi pengguna yang dikirim ke permintaan, meskipun data diminta untuk 8 video.  Ini menunjukkan bahwa pemuat data menghapus catatan duplikat. <br><br><h3> <font color="#3AC1EF">‚ñç </font> </h3><br> GraphQL   API  ,    .    ,   API   DOS-. <br><br>     ,     . <br><br>   <code>Video</code>  ,   .      GraphQL  <code>Video</code> .           .   ‚Äî  . <br><br>  ,      ‚Äî   : <br><br><pre> <code class="go hljs">{ Videos(limit: <span class="hljs-number"><span class="hljs-number">10</span></span>, offset: <span class="hljs-number"><span class="hljs-number">0</span></span>){   name   url   related(limit: <span class="hljs-number"><span class="hljs-number">10</span></span>, offset: <span class="hljs-number"><span class="hljs-number">0</span></span>){     name     url     related(limit: <span class="hljs-number"><span class="hljs-number">10</span></span>, offset: <span class="hljs-number"><span class="hljs-number">0</span></span>){       name       url       related(limit: <span class="hljs-number"><span class="hljs-number">100</span></span>, offset: <span class="hljs-number"><span class="hljs-number">0</span></span>){         name         url       }     }   } } }</code> </pre> <br>           100,        .  (, , )    ,         . <br><br>  gqlgen      ,     .     ,       ( <code>handler.ComplexityLimit(300)</code>   )   GraphQL     (300   ).  ,     ( <code>server.go</code> ): <br><br><pre> <code class="go hljs">rootHandler:= dataloaders.DataloaderMiddleware( db, handler.GraphQL(   go_graphql_demo.NewExecutableSchema(go_graphql_demo.NewRootResolvers(db)),   handler.ComplexityLimit(<span class="hljs-number"><span class="hljs-number">300</span></span>) ), )</code> </pre> <br>       ,   ,        .        12.   ,       ,   ,      ( ,  ,  ,   ,     ).    <code>resolver.go</code> : <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewRootResolvers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(db *sql.DB)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Config</span></span></span></span> { c := Config{   Resolvers: &amp;Resolver{     db: db,   }, } <span class="hljs-comment"><span class="hljs-comment">//  countComplexity := func(childComplexity int, limit *int, offset *int) int {   return *limit * childComplexity } c.Complexity.Query.Videos = countComplexity c.Complexity.Video.Related = countComplexity //   c.Directives.IsAuthenticated = func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error) {   ctxUserID := ctx.Value(UserIDCtxKey)   if ctxUserID != nil {     return next(ctx)   } else {     return nil, errors.UnauthorisedError   } } return c }</span></span></code> </pre> <br>     ,     ,       . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/702/045/d0a7020450bf5115f69c6a1ba61beca4.png"></div><br> <i><font color="#999999">    </font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/057/fec/7e3/057fec7e30f98b63aed8bbb6aec5193f.png"></div><br> <i><font color="#999999">      </font></i> <br><br>       ,   ,   <code>related</code>  . , , ,      ,             . <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br> ,        ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> .         .       ,     ,      . <br><br>  <b>Pembaca yang budiman!</b>     GraphQL  ,   Go? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444346/">https://habr.com/ru/post/id444346/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444336/index.html">Daftar tangkapan cepat: apa perbedaan antara tautan yang lemah, kuat dan tidak dimiliki?</a></li>
<li><a href="../id444338/index.html">Enkapsulasi dalam Python 3</a></li>
<li><a href="../id444340/index.html">Fitur menggunakan tipe data Simbol dalam JavaScript</a></li>
<li><a href="../id444342/index.html">Mengembangkan aplikasi JavaScript sederhana dan modern menggunakan Webpack dan teknologi web canggih</a></li>
<li><a href="../id444344/index.html">10 langkah untuk proyek Python yang sukses</a></li>
<li><a href="../id444348/index.html">Bagaimana komponen Bereaksi fungsional berbeda dari komponen berbasis kelas?</a></li>
<li><a href="../id444350/index.html">Untuk beberapa alasan MVP (produk minimum yang layak) tidak dimulai</a></li>
<li><a href="../id444352/index.html">Kontur.Kampus: kami mengundang Anda ke kemah mahasiswa gratis pengembangan industri dekat St. Petersburg</a></li>
<li><a href="../id444356/index.html">React Tutorial Bagian 24: Pelajaran Bentuk Kedua</a></li>
<li><a href="../id444358/index.html">Enumerable: Cara menghasilkan nilai bisnis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>