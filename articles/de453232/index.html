<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕴️ 😊 🤦🏽 Schreiben von Milliarden Songs mit C # und Deep Learning 👨🏿‍🏫 👩🏼‍🎓 💜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werde ich erklären, wie eine ASP.NET Core-Website erstellt wird , die mithilfe von KI eindeutige Songtexte mit einem Klick auf eine ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schreiben von Milliarden Songs mit C # und Deep Learning</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453232/">  In diesem Artikel werde ich erklären, wie eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">ASP.NET Core-Website erstellt wird</a> , die mithilfe von KI eindeutige Songtexte mit einem Klick auf eine Schaltfläche generiert und Benutzer für die besten Songs stimmen lässt. <br><a name="habracut"></a><br><h1>  Das neuronale Netzwerk </h1><br>  Vor ungefähr 2,5 Monaten veröffentlichte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">OpenAI</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">einen Blog-Beitrag</a> , in dem sie nahezu unmöglich demonstrierten: ein Deep-Learning-Modell, das Artikel schreiben kann, die nicht von denen zu unterscheiden sind, die von Menschen geschrieben wurden.  Der generierte Text war so beeindruckend, dass ich den Kalender überprüfen musste, um sicherzustellen, dass es sich nicht um einen Aprilscherz handelt (wohlgemerkt, das war Februar, und Seattle war schneebedeckt). <br><br><p><img src="https://habrastorage.org/webt/df/ok/nc/dfoknc5wbfxrkyvigyygtz9kctw.png" alt="GPT-2-Textbeispiel"></p><br><p> Sie haben nicht das größte neuronale Netzwerk mit über 1 Milliarde Parametern veröffentlicht, das sie bis heute erstellt haben (eine sehr kontroverse Entscheidung), aber sie haben eine kleinere 117M-Parameterversion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">auf GitHub</a> unter MIT-Lizenz als Open-Source-Version bereitgestellt.  Das Modell hat einen sehr unvergesslichen Namen: <b>GPT-2</b> . </p><br><p>  Vor ungefähr einem Monat, als ich überlegte, welches coole Projekt ich mit TensorFlow machen könnte, wurde dieses Netzwerk zum Ausgangspunkt.  Wenn bereits englischer Text generiert werden konnte, sollte es nicht zu schwierig sein, ihn zu <i>optimieren</i> , um Songtexte zu generieren, wenn ein ausreichend großer Datensatz vorhanden ist. </p><br><h2>  Wie funktioniert GPT-2? </h2><br><p>  In der Deep-Learning-Forschung gibt es mehrere wichtige Erfolge, die GPT-2 ermöglicht haben: </p><br><h3>  Selbstüberwachtes Lernen </h3><br><p>  Diese Technik wurde erst einige Tage, nachdem ich die erste Version dieses Artikels geschrieben hatte, von Yan LeCunn endgültig benannt.  Es ist eine sehr leistungsfähige Technik, die auf praktisch jede Art von realen Daten angewendet werden kann.  Um GPT-2 zu trainieren, sammelte OpenAI <i>Dutzende Gigabyte an Artikeln</i> aus verschiedenen Quellen, die auf Reddit hochgestuft wurden. </p><br><p>  Herkömmlicherweise müsste man einen Menschen haben, um all diese Artikel durchzugehen und sie beispielsweise als „positiv“ oder „negativ“ zu markieren.  Dann unterrichteten sie ein neuronales Netzwerk auf überwachte Weise, um diese Artikel genauso zu klassifizieren, wie es ein Mensch tat. </p><br><p><img src="https://habrastorage.org/webt/cn/sl/_2/cnsl_21o1f-vio39rn5auufl_lw.jpeg" alt="RECAPTCHA: Finde Stree-Schilder"></p><br><p>  Die neue Idee hier ist, dass Sie zum Erstellen eines Deep-Learning-Modells, das ein umfassendes Verständnis Ihrer Daten bietet, einfach die Daten beschädigen und das Modell damit beauftragen, das Original wiederherzustellen.  Dadurch versteht das Modell die Zusammenhänge zwischen Daten und ihren umgebenden Kontexten. </p><br><p>  Nehmen wir als Beispiel Text.  GPT-2 nimmt eine Stichprobe des Originaltextes, wählt 15% der zu beschädigenden Token aus, maskiert dann 80% davon (z. B. ersetzt durch ein spezielles Maskentoken, normalerweise ___), ersetzt 10% durch ein anderes zufälliges Token aus dem Wörterbuch. und hält die restlichen 10% intakt.  Nehmen wir, <i>ich warf einen Ball, und er fiel ins Gras</i> .  Nach der Korruption könnte es so aussehen: <i>Ich warf einen Autoball und er ___ ins Gras</i> .  Um das Original des Netzwerks wiederherzustellen, muss Laien lernen, dass etwas, das geworfen wird, wahrscheinlich fallen wird und dass der Autoball im Kontext etwas sehr Ungewöhnliches ist. </p><br><p>  Ein so trainiertes Modell eignet sich gut zum Generieren / Vervollständigen von Teildaten, aber die erlernten Funktionen auf hoher Ebene (als Ausgaben für innere Ebenen) können für andere Zwecke verwendet werden, indem ein oder zwei Ebenen hinzugefügt und eine Feinabstimmung vorgenommen werden <b>nur diese neue letzte Ebene</b> auf einem tatsächlichen, <b>kleineren</b> , vom Menschen markierten Datensatz auf herkömmliche Weise. </p><br><h3>  Spärliche Selbstaufmerksamkeit </h3><br><p>  GPT-2 verwendet etwas, das als spärliche Selbstaufmerksamkeit bezeichnet wird.  Im Wesentlichen handelt es sich um eine Technik, die es einem neuronalen Netzwerk ermöglicht, große Eingaben zu verarbeiten, um sich mehr auf einige Teile davon als auf andere zu konzentrieren.  Und das Netzwerk lernt, wo es während des Trainings „hinschauen“ soll.  Der Aufmerksamkeitsmechanismus wird in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">diesem Blog-Beitrag</a> besser erklärt. </p><br><p>  Der <i>spärliche</i> Teil im Titel dieses Abschnitts bezieht sich auf eine Einschränkung, aus welchen Eingabesegmenten der Aufmerksamkeitsmechanismus auswählen kann.  Die anfängliche Aufmerksamkeit könnte aus der gesamten Eingabe wählen.  Dies führte dazu, dass die Gewichtsmatrix O (input_size ^ 2) war, was mit der Größe der Eingabe sehr schnell wächst.  Eine geringe Aufmerksamkeit schränkt dies normalerweise in irgendeiner Weise ein.  Weitere Informationen hierzu finden Sie in einem anderen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">OpenAI-Blogbeitrag</a> . </p><br><p>  Die Aufmerksamkeit in GPT-2 ist <i>Multi-Head</i> .  Stellen Sie sich vor, Sie könnten ein oder zwei zusätzliche Augen haben, mit denen Sie überprüfen können, was im letzten Absatz enthalten ist, ohne das aktuelle zu lesen. </p><br><h3>  Viele mehr </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Restverbindungen</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Bytepaarkodierung</a> , Vorhersage des nächsten Satzes und vieles mehr. </p><br><h2>  Portieren von GPT-2 (und Konvertieren von Python im Allgemeinen) </h2><br><p>  Der ursprüngliche Modellcode ist in Python, aber ich bin ein C # -Typ.  Glücklicherweise ist der Quellcode gut lesbar und der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Kern</a> liegt in nur 5 Dateien, vielleicht insgesamt 500 Zeilen.  Also habe ich ein neues .NET Standard-Projekt erstellt, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Gradient</a> (eine TensorFlow-Bindung für .NET) installiert und diese Dateien Zeile für Zeile in C # konvertiert.  Das hat mich ungefähr 2 Stunden gekostet.  Die einzige pythonische Sache im Code war die Verwendung des Python-Regex-Moduls von pip (dem am häufigsten verwendeten Paketmanager für Python), da ich keine Zeit damit verschwenden wollte, die Feinheiten der regulären Python-Ausdrücke zu lernen ( <i>als ob es nicht genug wäre bereits mit .NET umgehen</i> ). </p><br><p>  Die Konvertierung bestand hauptsächlich darin, ähnliche Klassen zu definieren, Typen hinzuzufügen und Python- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Listenverständnisse</a> in entsprechende LINQ-Konstrukte umzuschreiben.  Zusätzlich zu LINQ aus der Standardbibliothek habe ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">MoreLinq verwendet</a> , das die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Möglichkeiten von</a> LINQ geringfügig erweitert. Beispiel: </p><br><p></p><pre><code class="python hljs">bs = list(range(ord(<span class="hljs-string"><span class="hljs-string">"!"</span></span>), ord(<span class="hljs-string"><span class="hljs-string">"~"</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span>)) + list(range(ord(<span class="hljs-string"><span class="hljs-string">"¡"</span></span>), ord(<span class="hljs-string"><span class="hljs-string">"¬"</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span>)) + list(range(ord(<span class="hljs-string"><span class="hljs-string">""</span></span>), ord(<span class="hljs-string"><span class="hljs-string">"ÿ"</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span>))</code> </pre> <br><p>  verwandelt in: </p><br><p></p><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bs = Range(<span class="hljs-string"><span class="hljs-string">'!'</span></span>, <span class="hljs-string"><span class="hljs-string">'~'</span></span> - <span class="hljs-string"><span class="hljs-string">'!'</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) .Concat(Range(<span class="hljs-string"><span class="hljs-string">'¡'</span></span>, <span class="hljs-string"><span class="hljs-string">'¬'</span></span> -<span class="hljs-string"><span class="hljs-string">'¡'</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>)) .Concat(Range(<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'ÿ'</span></span> - <span class="hljs-string"><span class="hljs-string">''</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>)) .ToList();</code> </pre> <br><p>  Eine andere Sache, mit der ich zu kämpfen hatte, war eine Diskrepanz zwischen der Art und Weise, wie Python mit Bereichen umgeht, und der neuen Funktion für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Bereiche und Indizes</a> im kommenden C # 8, die ich beim Debuggen meiner ersten Läufe entdeckt habe: In C # 8 ist das Ende des Bereichs <b>inklusive</b> , In Python ist es <b>exklusiv</b> (um das allerletzte Element in Python aufzunehmen, müssen Sie die rechte Seite des Ausdrucks <i>..</i> weglassen). </p><br><blockquote>  In der Informatik gibt es zwei schwierige Dinge: Cache-Ungültigmachung, Benennung und Off-by-One-Fehler. </blockquote><br><p>  Leider enthielt der ursprüngliche Quell-Drop weder Training noch Feinabstimmungscode, aber <b>Neil Shepperd</b> stellte auf seinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">GitHub</a> einen einfachen Feinabstimmer zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Verfügung</a> , den ich ebenfalls portieren musste.  Das Ergebnis dieser Bemühungen ist jedoch, dass ein <b>C # -Code</b> , der <b>zum Spielen mit GPT-2 verwendet werden kann</b> , jetzt Teil des Gradient <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Samples-</a> Repositorys ist. </p><br><p>  Die Portierungsübung hat zwei Gründe: Nach dem Portieren kann man <b>mit dem Modellcode in seiner bevorzugten C # -IDE spielen</b> und zeigen, dass <b>es jetzt möglich ist, hochmoderne Deep-Learning-Modelle benutzerdefiniert zum Laufen zu bringen .NET-Projekte</b> kurz nach der Veröffentlichung (zwischen dem Code-Drop von GPT-2 und der ersten Veröffentlichung von Billion Songs - etwas mehr als einen Monat). </p><br><h2>  Feinabstimmung auf Songtexte </h2><br><p>  Es gibt verschiedene Möglichkeiten, wie man einen großen Korpus an Songtexten erhalten kann.  Sie können eine der Internet-Websites, auf denen sie gehostet wird, mit einem HTML-Parser durchsuchen, aus Ihrer Karaoke-Sammlung oder aus MP3-Dateien entfernen.  Zum Glück hat es jemand für uns getan.  Ich habe einige vorbereitete Lyrics-Datensätze auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Kaggle gefunden</a> .  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Jedes Lied, das Sie gehört haben</a> " schien das größte zu sein.  Beim Versuch, GPT-2 darauf abzustimmen, hatte ich zwei Probleme. </p><br><h3>  CSV-Lesung </h3><br><p>  Ja, Sie haben es richtig gelesen, <i>CSV-Analyse war ein Problem</i> .  Zunächst wollte ich ML.NET, die neue Microsoft-Bibliothek für maschinelles Lernen, zum Lesen der Datei verwenden.  Nachdem ich die Dokumentation durchgesehen und eingerichtet hatte, stellte ich jedoch fest, dass Zeilenumbrüche in den Songs nicht richtig verarbeitet wurden.  Egal was ich tat, es kämpfte nach ein paar hundert Beispielen und begann, Textstücke mit Titeln und Künstlern zu mischen. </p><br><p>  Also musste ich auf eine Bibliothek auf niedrigerer Ebene zurückgreifen, mit der ich zuvor bessere Erfahrungen gemacht hatte: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">CsvHelper</a> .  Es bietet eine <i>DataReader-</i> ähnliche Schnittstelle.  Sie können den Code <a href="" rel="nofollow">hier sehen</a> .  Im Wesentlichen öffnen Sie eine Datei, konfigurieren einen <i>CsvReader</i> und verschachteln dann den Aufruf von <i>.Read ()</i> mit dem Aufruf von <i>.GetField (fieldName)</i> . </p><br><h3>  Kurze Lieder </h3><br><p>  Die meisten Songs sind kurz im Vergleich zu einem durchschnittlichen Artikel im Originaldatensatz, der von OpenAI verwendet wird.  Das GPT-2-Training ist bei großen Textstücken effizienter, daher musste ich mehrere Songs zu fortlaufenden Textblöcken bündeln, um sie dem Trainer zuzuführen.  OpenAI schien diese Technik ebenfalls zu verwenden, daher hatten sie ein spezielles Token <i>&lt;| endoftext |&gt;</i> , das als Trennzeichen zwischen vollständigen Texten innerhalb eines Blocks fungiert und gleichzeitig als Start-Token fungiert.  Ich habe Songs gebündelt, bis eine bestimmte Anzahl von Token erreicht war, und dann den gesamten Teil zurückgegeben, um ihn in die Trainingsdaten aufzunehmen.  Der entsprechende Code ist <a href="" rel="nofollow">hier</a> . </p><br><h3>  Hardwareanforderungen für das Tuning </h3><br><p>  Auch die kleinere Version von GPT-2 ist groß.  Mit <b>12 GB GPU-RAM</b> konnte ich <b>nur die</b> <b>Stapelgröße</b> <b>auf 2 einstellen</b> (z. B. zwei <b>Blöcke gleichzeitig</b> trainieren, größere Stapelgrößen verbessern die GPU-Leistung und die Trainingsergebnisse).  3 würde in CUDA <i>aus dem Speicher</i> werfen.  Und es dauerte einen halben Tag, um die gewünschte Leistung auf meinem V100 einzustellen.  Der Bonus ist, dass Sie den Fortschritt sehen können, da der Trainingscode von Zeit zu Zeit einige generierte Samples ausgibt, die als einfacher Text beginnen und im Verlauf des Trainings immer mehr wie Songtexte aussehen. </p><br><p>  Ich habe es nicht ausprobiert, aber das <b>Training auf der CPU wird wahrscheinlich sehr langsam sein</b> . </p><br><h3>  Vorab abgestimmtes Modell </h3><br><p>  Als ich diesen Blog-Beitrag vorbereitete, wurde mir klar, dass es besser ist, nicht alle zu zwingen, Stunden mit der Feinabstimmung des Textmodells zu verbringen, und so veröffentlichte ich <b>einen</b> <b>vorab abgestimmten</b> im <a href="" rel="nofollow">Billion Songs-Repository</a> .  Wenn Sie nur versuchen, Billion Songs auszuführen, müssen Sie es nicht einmal manuell herunterladen.  Das Projekt erledigt dies standardmäßig für Sie. </p><br><div class="spoiler">  <b class="spoiler_title">halb trainiertes Modell, das HAL9000 auf mir spielt</b> <div class="spoiler_text">  Ich schwöre dir, ich soll dir schreiben <br>  Und ich schwöre dir, ich schwöre <br>  Du hast es jetzt ruiniert, ich hoffe du schaffst es <br>  Und ich hoffe dein Traum, ich hoffe du träumst, ich hoffe du träumst ich hoffe du träumst ich hoffe du träumst davon <br>  Über <br>  was ich gehe  Ich gehe.  Ich gehe.  Ich gehe, ich gehe, ich gehe, ich gehe, ich gehe, ich gehe, ich gehe, ich gehe, <br>  Ich gehe, ich gehe, ich gehe ... </div></div><br><h1>  Eine Website erstellen </h1><br><p>  OK!  Das sieht aus wie ein Lied (irgendwie), jetzt machen wir eine Website! </p><br><p>  Da ich keine APIs bereitstellen möchte, wähle ich im Gegensatz zu MVC die Vorlage "Razor Pages".  Ich habe auch die Autorisierung aktiviert, da wir den Benutzern erlauben werden, für die besten Texte zu stimmen und eine Top-10-Tabelle zu haben. </p><br><p>  Ich beeilte mich mit dem MVP und erstellte eine Song.cshtml-Webseite, deren Ziel es vorerst sein wird, einfach GPT-2 aufzurufen und einen zufälligen Song zu erhalten.  Das Layout der Seite ist trivial und besteht im Wesentlichen aus dem Song und seinem Titel: </p><br><pre> <code class="xml hljs">@page "/song/{id}" @model BillionSongs.Pages.SongModel<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> @{ ViewData["Title"] = @Model.Song.Title ?? "Untitled"; } <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">article</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text-align: center"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h3</span></span></span><span class="hljs-tag">&gt;</span></span>@(Model.Song.Title ?? "Untitled")<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h3</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">pre</span></span></span><span class="hljs-tag">&gt;</span></span>@Model.Song.Lyrics<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">pre</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">article</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br><p>  Da ich meinen Code jetzt wiederverwendbar mag, habe ich eine Schnittstelle erstellt, über die ich später verschiedene Textgeneratoren anschließen kann, die von ASP.NET in SongModel eingefügt werden. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ILyricsGenerator</span></span> { <span class="hljs-function"><span class="hljs-function">Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateLyrics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> song, CancellationToken cancellation</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre><br><p>  Wenn Sie den <i>Songtitel vorerst</i> <i>weglassen</i> , müssen Sie <i>lediglich Gpt2LyricsGenerator</i> im <i>Startup</i> registrieren <i>. Konfigurieren Sie die Dienste</i> und rufen Sie ihn vom <i>SongModel aus auf</i> .  Beginnen wir also mit dem Generator.  Und das erste, was wir sicherstellen müssen, ist, dass wir haben </p><br><h2>  Wiederholbare Textgenerierung </h2><br><p>  Da ich im Titel eine kühne Aussage gemacht habe, dass es sich um über 1 Milliarde Songs handeln wird, denken Sie nicht einmal daran, alle zu generieren und zu speichern.  Erstens würde dies ohne Metadaten allein mehr als 1 TB Speicherplatz beanspruchen.  Zweitens dauert es auf meinem Nettop ~ 3 Minuten, um einen neuen Song zu generieren, so dass es ewig dauern wird, alle zu generieren.  Und ich möchte in der Lage sein, diese Milliarde in eine <i>Billion umzuwandeln,</i> indem <i>ich</i> bei Bedarf auf <i>Int64 umsteige</i> !  Stellen Sie sich vor, wir könnten 1 Cent pro Song auf 1 Billion Songs machen?  Das wäre mehr als das derzeitige jährliche BIP der Welt! </p><br><p>  Stattdessen müssen wir sicherstellen, dass GPT-2 aufgrund seiner <i>ID</i> , die ich in der Route angegeben habe, immer wieder denselben Song generiert.  Zu diesem Zweck bietet TensorFlow die Möglichkeit, den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Startwert</a> seines internen Zahlengenerators jederzeit über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">die</a> Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">tf.set_random_seed</a> wie <i>folgt festzulegen</i> : <i>tf.set_random_seed (songNumber)</i> .  Dann wollte ich einfach <i>Gpt2Sampler.SampleSequence aufrufen</i> , um den codierten Songtext <i>abzurufen</i> , zu dekodieren und das Ergebnis zurückzugeben, wodurch <i>Gpt2LyricsGenerator vervollständigt wurde</i> . </p><br><p>  Leider hat das beim ersten Versuch nicht wie erwartet funktioniert.  Jedes Mal, wenn ich auf die Schaltfläche "Aktualisieren" drückte, wurde ein neuer eindeutiger Text auf der Seite zurückgegeben.  Nach einigem Debuggen stellte ich schließlich fest, dass TensorFlow 1.X erhebliche Probleme mit der Reproduzierbarkeit hat: Viele Vorgänge haben interne Zustände, die nicht von <i>set_random_seed</i> betroffen <i>sind</i> und schwer zurückzusetzen sind. </p><br><p>  Die Neuinitialisierung der Modellvariablen trug zur Behebung dieses Problems bei, bedeutete jedoch auch, dass die Sitzung neu erstellt werden musste und die Modellgewichte bei jedem Aufruf neu geladen werden mussten.  Das erneute Laden einer Sitzung dieser Größe verursachte einen riesigen Speicherverlust.  Um zu vermeiden, dass im TensorFlow C ++ - Quellcode nach der Ursache gesucht wird, habe ich beschlossen, statt <i>Process</i> in Text einen neuen Prozess mit <i>Process.Start</i> zu <i>erstellen</i> , dort Text zu generieren und ihn aus der Standardausgabe zu lesen.  Bis sich eine Möglichkeit zum Zurücksetzen des Modellstatus in TensorFlow stabilisiert hat, ist dies der richtige Weg. </p><br><p>  <a href="" rel="nofollow">Am</a> Ende hatte ich zwei Klassen: <a href="" rel="nofollow">Gpt2LyricsGenerator</a> , der <i>ILyricsGenerator</i> von oben implementiert, indem eine neue Instanz von BillionSongs.exe mit Befehlszeilenparametern erzeugt wird, die die Song-ID enthalten, und schließlich <a href="" rel="nofollow">Gpt2TextGenerator</a> instanziiert, der tatsächlich GPT-2 aufruft, um Texte zu generieren, und druckt es einfach aus. </p><br><p>  Das Aktualisieren der Seite gab mir immer den gleichen Text. </p><br><h2>  Umgang mit 3 Minuten Zeit, um einen Song zu generieren </h2><br><p>  Was für eine schreckliche Benutzererfahrung wäre das!  Sie gehen auf eine Website, klicken auf "Neues Lied erstellen" und <b>3 (!) Minuten lang passiert absolut nichts,</b> während sich mein Nettop die Zeit nimmt, um die von Ihnen angeforderten Songtexte zu generieren. </p><br><p>  Ich habe dieses Problem auf mehreren Ebenen gelöst: </p><br><h3>  Songs vorgenerieren </h3><br><p>  Wie oben erwähnt, können Sie nicht alle Songs vorgenerieren und aus einer Datenbank bereitstellen.  Und Sie können nicht einfach auf Abruf generieren, weil das zu langsam ist.  Was können Sie also tun? </p><br><p>  Einfach!  Da Benutzer ein neues Lied in erster Linie sehen können, indem sie auf die Schaltfläche „Zufällig machen“ klicken, generieren wir viele Songs im Voraus, fügen sie in eine <i>ConcurrentQueue ein</i> und lassen „Songs zufällig“ Pop-Songs daraus erstellen.  Während die Anzahl der Besucher gering ist, benötigt der Server einige Zeit, um einige Songs zu generieren, auf die dann leicht zugegriffen werden kann. </p><br><p>  Ein weiterer Trick, den ich verwendet habe, besteht darin, diese Warteschlange mehrmals zu durchlaufen, sodass viele Benutzer denselben vorgenerierten Song sehen können.  Man muss nur ein Gleichgewicht zwischen der RAM-Nutzung und der Häufigkeit, mit der ein Benutzer auf "Zufällig machen" klicken muss, um etwas zu sehen, das er zuvor gesehen hat.  Ich habe einfach 50.000 Songs als vernünftige Anzahl ausgewählt, was nur 50 MB RAM beanspruchen würde, während ich eine ziemlich große Anzahl von Klicks zum Durchlaufen bereitstellen würde. </p><br><p>  Ich habe diese Funktionalität in der Klasse <a href="" rel="nofollow">PregeneratedSongProvider implementiert</a> : <i>IRandomSongProvider</i> (die Schnittstelle wird in den Code <i>eingefügt</i> , der für die Behandlung der Schaltfläche "Zufällig machen" verantwortlich ist). </p><br><h3>  Caching </h3><br><p>  Vorgenerierte Songs werden im Speicher zwischengespeichert, aber ich habe auch den HTTP- <i>Cache-</i> Header auf <i>public gesetzt</i> , damit der Browser verwendet wird, und CDN (ich verwende CloudFlare) zwischenspeichere ihn, um nicht von einem Benutzereinstrom getroffen zu werden. </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">ResponseCache(VaryByHeader = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"User-Agent"</span></span></span><span class="hljs-meta">, Duration = 3*60*60)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SongModel</span></span>: <span class="hljs-title"><span class="hljs-title">PageModel</span></span> { … }</code> </pre><br><h3>  Rückgabe beliebter Songs </h3><br><p>  Die meisten Songs, die auf diese Weise von fein abgestimmtem GPT-2 erzeugt werden, sind ziemlich langweilig, wenn nicht rudimentär.  Um die Klicks auf "Zufällig machen" ansprechender zu gestalten, habe ich eine Wahrscheinlichkeit von 25% hinzugefügt, dass anstelle eines völlig zufälligen Songs ein Song angezeigt wird, der zuvor von anderen Benutzern positiv bewertet wurde.  Zusätzlich zur Erhöhung des Engagements erhöht sich die Wahrscheinlichkeit, dass Sie einen Titel anfordern, der entweder im CDN oder im Speicher zwischengespeichert ist. </p><br><p>  Alle oben genannten Tricks sind mithilfe der ASP.NET-Abhängigkeitsinjektion in der <a href="" rel="nofollow">Startup-</a> Klasse miteinander verbunden. </p><br><h2>  Abstimmung </h2><br><p>  Die Umsetzung der Abstimmung ist nicht besonders.  Es gibt <a href="" rel="nofollow">SongVoteCache</a> , der die <a href="" rel="nofollow">Anzahl</a> auf dem neuesten Stand hält.  Und ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Iframe, der die Abstimmungsschaltfläche</a> s auf der Song-Seite hostet, ermöglicht das Zwischenspeichern des wesentlichen Teils der Seite - Titel und Texte, während die Stimmenzahl und der Anmeldestatus später geladen werden. </p><br><h1>  Das Endergebnis </h1><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><img src="https://habrastorage.org/webt/aw/c7/wf/awc7wfzablt9gotcrrv8nsihrvu.png" alt="Generiertes Song-Sample"></a> <br></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Eine Demoversion,</a> die auf <s>meinem Nettop ausgeführt wird und von CloudFlare (geben Sie etwas Ruhe, seinen Core i3) unterstützt wird, wurde</s> jetzt eingefroren und in die kostenlose Azure App Service-Stufe verschoben. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Das GitHub-Repository</a> mit Quellcode und Anweisungen zum Ausführen der Website und zum Optimieren des Modells. </p><br><h1>  Pläne für die Zukunft / Übungen </h1><br><h2>  Titel generieren </h2><br><p>  GPT-2 ist sehr einfach zu optimieren.  Man könnte es dazu bringen, Songtitel zu generieren, indem man jedem Textbeispiel aus dem Datensatz ein künstliches Token wie <i>&lt;| startoftitle |&gt;</i> voranstellt oder <i>einfügt</i> , gefolgt vom Titel aus demselben Datensatz. </p><br><p>  Alternativ könnten Benutzer Titel vorschlagen und / oder für sie stimmen. </p><br><h2>  Musik generieren </h2><br><p>  Auf halbem Weg durch die Entwicklung von Billion Songs dachte ich, es wäre cool, eine Reihe von MIDI-Dateien herunterzuladen (das ist ein Musikformat der alten Schule, das dem Text viel näher kommt als MP3s) und GPT-2 darauf zu trainieren, um mehr zu generieren .  In einige dieser Dateien war sogar Text eingebettet, sodass <b>Sie Karaoke generieren konnten</b> . </p><br><p>  Ich weiß, dass die Musikgeneration auf diese Weise sehr gut möglich ist, da <b>OpenAI</b> gestern <b>tatsächlich eine Implementierung dieser Idee</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">in ihrem Blog veröffentlicht hat</a> .  Aber Hurra, <b>sie haben kein Karaoke gemacht!</b>  Ich fand heraus, dass es möglich ist, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">http://www.midi-karaoke.info</a> zu diesem Zweck abzukratzen. </p><br><h2>  Gradient aka TensorFlow für .NET </h2><br>  Updates finden Sie in unserem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Blog</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453232/">https://habr.com/ru/post/de453232/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453216/index.html">Verkehrsüberwachungssysteme in VoIP-Netzen. Zweiter Teil - Organisationsprinzipien</a></li>
<li><a href="../de453218/index.html">Die Hauptsache bei YaC 2019: Hundert Drohnen auf den Straßen, Yandex.Module, Essen, Smart Home</a></li>
<li><a href="../de453220/index.html">13 E-Mail-Marketing-Fehler, die für ein besseres Engagement vermieden werden sollten</a></li>
<li><a href="../de453222/index.html">SphinxSearch-Meetup SuperJob</a></li>
<li><a href="../de453228/index.html">Nixie Uhr an den Anzeigen IN-18</a></li>
<li><a href="../de453234/index.html">Reverse Engineering des Austauschprotokolls in EOS-Geräten</a></li>
<li><a href="../de453236/index.html">Prototyping eines Handyspiels, wo man anfängt und wie man es macht. Teil 2</a></li>
<li><a href="../de453238/index.html">Lauflicht am Relais</a></li>
<li><a href="../de453242/index.html">Spielplatz für Sommerveranstaltungen</a></li>
<li><a href="../de453246/index.html">ERP - Continuous Degradation System</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>