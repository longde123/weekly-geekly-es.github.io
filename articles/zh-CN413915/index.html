<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤾🏿 👂🏻 🛌🏽 使塔防成为统一游戏-第2部分 🚩 🧑 🤟🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="这是教程“在Unity中创建塔防游戏”的第二部分。 我们正在Unity中创建塔防游戏，到第一部分结束时，我们学习了如何放置和升级怪物。 我们也有一个敌人在攻击Cookie。 

 但是，敌人还不知道在哪里看！ 此外，仅凭一次攻击就显得很奇怪。 在本部分的教程中，我们将添加一波敌人和手臂怪物，以便它们...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使塔防成为统一游戏-第2部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413915/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd4/78a/29c/dd478a29c258b63dc809ca16de4ee16a.png" alt="图片"></div><br> 这是教程<i>“在Unity中创建塔防游戏”</i>的第二部分。 我们正在Unity中创建塔防游戏，到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一部分</a>结束时，我们学习了如何放置和升级怪物。 我们也有一个敌人在攻击Cookie。 <br><br> 但是，敌人还不知道在哪里看！ 此外，仅凭一次攻击就显得很奇怪。 在本部分的教程中，我们将添加一波敌人和手臂怪物，以便它们可以防御珍贵的cookie。 <br><a name="habracut"></a><br><h2> 开始工作 </h2><br> 在Unity中打开项目，我们在最后一部分中停止了该项目。 如果您刚刚加入我们，请下载<a href="">项目草案</a>并打开<em>TowerDefense-Part2-Starter</em> 。 <br><br> 从“ <em>场景”</em>文件夹中打开<em>GameScene</em> 。 <br><br><h2> 转敌人 </h2><br> 在上一教程的结尾，敌人学会了沿路行驶，但似乎他不知道在哪里看。 <br><br> 在IDE中打开<em>MoveEnemy.cs</em>脚本，并向其中添加以下方法以解决这种情况。 <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RotateIntoMoveDirection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//1 Vector3 newStartPosition = waypoints [currentWaypoint].transform.position; Vector3 newEndPosition = waypoints [currentWaypoint + 1].transform.position; Vector3 newDirection = (newEndPosition - newStartPosition); //2 float x = newDirection.x; float y = newDirection.y; float rotationAngle = Mathf.Atan2 (y, x) * 180 / Mathf.PI; //3 GameObject sprite = gameObject.transform.Find("Sprite").gameObject; sprite.transform.rotation = Quaternion.AngleAxis(rotationAngle, Vector3.forward); }</span></span></code> </pre> <br>  <code>RotateIntoMoveDirection</code>旋转敌人，使其始终向前看。 他这样做如下： <br><br><ol><li> 计算错误的当前方向，从下一个点的位置减去当前航路点的位置。 </li><li> 使用<code>Mathf.Atan2</code>确定将<code>newDirection</code>定向到的弧度角（零点在右侧）。 将结果乘以<code>180 / Mathf.PI</code> ，将角度转换为度。 </li><li> 最后，它获取<em>Sprite</em>子级并旋转轴<code>rotationAngle</code>度。 请注意，我们旋转<i>子级</i>而不是父级，以便稍后添加的能量条保持水平。 </li></ol><br> 在<code>Update()</code> ，将注释<code>// TODO:    </code>替换为<code>// TODO:    </code>在下一个对<code>RotateIntoMoveDirection</code>调用下<code>// TODO:    </code> <code>RotateIntoMoveDirection</code> ： <br><br><pre> <code class="cs hljs">RotateIntoMoveDirection();</code> </pre> <br> 保存文件并返回到Unity。 运行场景； 现在敌人知道他要移到哪里。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73d/7f4/9e5/73d7f49e5fec3785e2ac3376c3774f27.gif"></div><br> 现在，该错误知道了它的去向。 <br><br> 唯一的敌人看起来并不令人印象深刻。 我们需要成群结队！ 就像任何塔防游戏一样，成群结队！ <br><br><h2> 通知玩家 </h2><br> 在开始移动部落之前，我们需要警告玩家即将发生的战斗。 此外，值得在屏幕顶部显示当前波数。 <br><br>  <em>Wave</em>信息是几个GameObjects所必需的，因此我们将其添加到<em>GameManager的GameManagerBehavior</em>组件中。 <br><br> 在IDE中打开<em>GameManagerBehavior.cs</em>并添加以下两个变量： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text waveLabel; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject[] nextWaveLabels;</code> </pre> <br>  <code>waveLabel</code>将指向波形编号输出标签的链接存储在屏幕的右上角。  <code>nextWaveLabels</code>存储两个<code>nextWaveLabels</code>创建动画的组合，我们将在新一轮浪潮开始时显示它们： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7c/650/8f0/e7c6508f018c4382e490a4f6bee31e1f.gif"></div><br> 保存文件并返回到Unity。 在“ <em>层次结构”中</em>选择<em>GameManager</em> 。 单击“ <em>波形标签</em> ”右侧的圆圈，然后在“ <em>选择文本”</em>对话框中，从“ <em>场景”</em>选项卡中选择“ <em>WaveLabel</em> <em>”</em> 。 <br><br> 现在将<em>“下一波标签</em>的<em>大小</em> ”设置为<em>2</em> 。 现在，将<em>元素0</em>设置为<em>NextWaveBottomLabel</em> ，对于<em>元素1，将</em> <em>NextWaveTopLabel设置</em>为与Wave Label相同。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d19/725/1f8/d197251f821c7262c638df487fb752cd.png"></div><br>  <i>这就是现在的游戏管理员行为</i> <br><br> 如果玩家输了，那么他应该不会看到有关下一波的消息。 要处理这种情况，请返回<em>GameManagerBehavior.cs</em>并添加另一个变量： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> gameOver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br> 在<code>gameOver</code>我们将存储玩家是否输了的价值。 <br><br> 在这里，我们再次使用属性将游戏元素与当前wave同步。 将以下代码添加到<code>GameManagerBehavior</code> ： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> wave; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Wave { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wave; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { wave = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!gameOver) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; nextWaveLabels.Length; i++) { nextWaveLabels[i].GetComponent&lt;Animator&gt;().SetTrigger(<span class="hljs-string"><span class="hljs-string">"nextWave"</span></span>); } } waveLabel.text = <span class="hljs-string"><span class="hljs-string">"WAVE: "</span></span> + (wave + <span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre> <br> 创建私有变量，属性和getter对您来说应该已经很熟悉了。 但是，有了二传手，一切都会变得更加有趣。 <br><br> 我们给<code>wave</code>指定<code>wave</code>新<code>value</code> 。 <br><br> 然后我们检查游戏是否完成。 如果不是，则遍历所有<em>nextWaveLabels</em>标签-这些标签具有<em>Animator</em>组件。 为了启用<em>Animator</em>动画，我们<em>定义</em>了<em>nextWave</em>触发器。 <br><br> 最后，我们将<code>waveLabel</code>的<code>text</code>设置为<code>wave + 1</code> 。 为什么<code>+1</code> ？ 普通人不会从头开始计算（是的，这很奇怪）。 <br><br> 在<code>Start()</code>设置此属性的值： <br><br><pre> <code class="cs hljs">Wave = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br> 我们从数字<em>0</em> <code>Wave</code>开始计数。 <br><br> 保存文件并在Unity中运行场景。  Wave标签将正确显示1。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b0d/edf/546/b0dedf546c1b6ad9b0d0b91c5021212d.png"></div><br>  <i>对于玩家而言，一切都始于第一波。</i> <br><br><h2> 波浪：制造大量敌人 </h2><br> 这看起来似乎很明显，但是要大举进攻，就必须制造更多的敌人-尽管我们不知道该怎么做。 而且，在当前波被摧毁之前，我们不应该创建下一波。 <br><br> 也就是说，游戏应该能够识别场景中敌人的存在，而<em>标签</em>是在此处识别游戏对象的好方法。 <br><br><h3> 敌人标记 </h3><br> 在项目浏览器中选择<em>敌人</em>预制件。 在<em>检查器</em>顶部<em>，</em>单击“ <em>标签”</em>下拉列表，然后选择“ <em>添加标签”</em> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be0/7ea/b29/be07eab29a25c69751add67ce4faa283.png"></div><br> 创建一个名为<em>Enemy</em>的<em>标签</em> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df1/c66/d02/df1c66d02e0c29a7a6ec0b615dbbd2fc.png"></div><br> 选择预制<em>敌人</em> 。 在<em>检查器中，</em>为其设置<em>“</em> <em>敌人”</em> <em>标签</em> 。 <br><br><h3> 定义敌人的浪潮 </h3><br> 现在我们需要设置敌人的浪潮。 在IDE中打开<em>SpawnEnemy.cs</em> ，并在<code>SpawnEnemy</code>之前添加以下类实现： <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Wave</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject enemyPrefab; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> spawnInterval = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxEnemies = <span class="hljs-number"><span class="hljs-number">20</span></span>; }</code> </pre> <br>  <em>Wave</em>包含<code>enemyPrefab</code>创建该波浪中所有敌人的实例的基础， <code>spawnInterval</code>该波浪中的敌人之间的时间（以秒为单位）和<code>maxEnemies</code>此波浪中创建的敌人的数量。 <br><br> 该类是<em>Serializable</em> ，也就是说，我们可以在Inspector中更改其值。 <br><br> 将以下变量添加到<code>SpawnEnemy</code>类： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Wave[] waves; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> timeBetweenWaves = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameManagerBehavior gameManager; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lastSpawnTime; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> enemiesSpawned = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br> 在这里，我们设置了生成敌人的变量，这与在路线上的点之间移动敌人的方式非常相似。 <br><br> 我们将单个敌人的<code>waves</code>设置为wave，并在敌人<code>enemiesSpawned</code>和<code>lastSpawnTime</code>跟踪创建的敌人的数量以及创建它们的时间。 <br><br> 在所有这些杀死之后，玩家需要时间呼吸，因此将<code>timeBetweenWaves</code>设置为5秒。 <br><br> 用以下代码替换<code>Start()</code>内容。 <br><br><pre> <code class="cs hljs">lastSpawnTime = Time.time; gameManager = GameObject.Find(<span class="hljs-string"><span class="hljs-string">"GameManager"</span></span>).GetComponent&lt;GameManagerBehavior&gt;();</code> </pre> <br> 在这里，我们为<code>lastSpawnTime</code>分配当前时间，即场景加载后脚本开始的时间。 然后我们得到了已经熟悉的<code>GameManagerBehavior</code> 。 <br><br> 将以下代码添加到<code>Update()</code> ： <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 int currentWave = gameManager.Wave; if (currentWave &lt; waves.Length) { // 2 float timeInterval = Time.time - lastSpawnTime; float spawnInterval = waves[currentWave].spawnInterval; if (((enemiesSpawned == 0 &amp;&amp; timeInterval &gt; timeBetweenWaves) || timeInterval &gt; spawnInterval) &amp;&amp; enemiesSpawned &lt; waves[currentWave].maxEnemies) { // 3 lastSpawnTime = Time.time; GameObject newEnemy = (GameObject) Instantiate(waves[currentWave].enemyPrefab); newEnemy.GetComponent&lt;MoveEnemy&gt;().waypoints = waypoints; enemiesSpawned++; } // 4 if (enemiesSpawned == waves[currentWave].maxEnemies &amp;&amp; GameObject.FindGameObjectWithTag("Enemy") == null) { gameManager.Wave++; gameManager.Gold = Mathf.RoundToInt(gameManager.Gold * 1.1f); enemiesSpawned = 0; lastSpawnTime = Time.time; } // 5 } else { gameManager.gameOver = true; GameObject gameOverText = GameObject.FindGameObjectWithTag ("GameWon"); gameOverText.GetComponent&lt;Animator&gt;().SetBool("gameOver", true); }</span></span></code> </pre> <br> 让我们逐步分析它： <br><br><ol><li> 我们获取当前波的索引，并检查它是否为最后一个。 </li><li> 如果是这样，那么我们将计算在前一个敌人产生之后经过的时间，并检查是否该创建一个敌人了。 这里我们考虑两种情况。 如果这是波浪中的第一个敌人，则我们检查<code>timeInterval</code>是否<code>timeInterval</code> <code>timeBetweenWaves</code> 。 否则，我们检查<code>timeInterval</code>是否<code>timeInterval</code> <code>spawnInterval</code> wave。 无论如何，我们都要检查是否没有在这一波中制造出所有敌人。 </li><li> 如有必要，生成敌人，并创建敌人的实例。 还可以增加<code>enemiesSpawned</code>的价值。 </li><li> 检查屏幕上的敌人数量。 如果他们不在那，而这是浪潮中的最后一个敌人，那么我们创建下一个浪潮。 同样在浪潮结束时，我们给玩家所有剩余金币的10％。 </li><li> 击败最后一波后，在这里播放游戏胜利的动画。 </li></ol><br><h3> 设置生成间隔 </h3><br> 保存文件并返回到Unity。 在“ <em>层次结构”中</em>选择<em>Road</em>对象。 在<em>检查器中，</em>将<em>Waves</em>对象的<em>Size</em>设置为<em>4</em> 。 <br><br> 现在，为所有四个元素选择一个<em>敌人</em>对象作为<em>Enemy Prefab</em> 。 如下配置<em>Spawn Interval</em>和<em>Max Enemies</em>字段： <br><br><ul><li>  <em>元素0</em> ：生成间隔： <em>2.5</em> ，最大敌人： <em>5</em> </li><li>  <em>元素1</em> ：产生间隔： <em>2</em> ，最大敌人： <em>10</em> </li><li>  <em>元素2</em> ：生成间隔： <em>2</em> ，最大敌人： <em>15</em> </li><li>  <em>元素3</em> ：生成时间间隔： <em>1</em> ，最大敌人： <em>5</em> </li></ul><br> 完成的方案应如下所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff7/0fa/954/ff70fa95476112b51dfb83505f9a785b.png"></div><br> 当然，您可以尝试使用这些值来增加或减少复杂性。 <br><br> 启动游戏。 是的 甲虫已经开始了您的cookie之旅！ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7f/097/4d3/a7f0974d36a188b5575a3e70a8488a4a.gif" alt="虫子"></div><br><h3> 附加任务：添加不同类型的敌人 </h3><br> 没有一种塔防游戏可以被认为只有一种类型的敌人就可以完成。 幸运的是， <em>Prefabs</em>文件夹中还<em>包含</em> <em>Enemy2</em> 。 <br><br> 在<em>检查器中，</em>选择“ <em>Prefabs \ Enemy2”，</em>然后向其添加<em>MoveEnemy</em>脚本。 将<em>Speed</em>设置为<em>3</em>并设置<em>Enemy</em> <em>标签</em> 。 现在您可以使用这个快速的敌人，让玩家不会放松！ <br><br><h2> 玩家生活更新 </h2><br> 即使成群的敌人攻击cookie，玩家也不会受到伤害。 但是很快我们将修复它。 如果玩家允许敌人偷袭，则玩家必须遭受痛苦。 <br><br> 在IDE中打开<em>GameManagerBehavior.cs</em>并添加以下两个变量： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text healthLabel; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject[] healthIndicator;</code> </pre> <br> 我们使用<code>healthLabel</code>来获取玩家的生命价值，并使用<code>healthIndicator</code>来获取五个咀嚼饼干的绿色小怪物-它们只是象征玩家的健康； 它比标准的健康指标更有趣。 <br><br><h3> 健康管理 </h3><br> 现在，在<code>GameManagerBehavior</code>添加一个用于存储玩家健康状况的<code>GameManagerBehavior</code> ： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> health; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Health { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> health; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 if (value &lt; health) { Camera.main.GetComponent&lt;CameraShake&gt;().Shake(); } // 2 health = value; healthLabel.text = "HEALTH: " + health; // 3 if (health &lt;= 0 &amp;&amp; !gameOver) { gameOver = true; GameObject gameOverText = GameObject.FindGameObjectWithTag("GameOver"); gameOverText.GetComponent&lt;Animator&gt;().SetBool("gameOver", true); } // 4 for (int i = 0; i &lt; healthIndicator.Length; i++) { if (i &lt; Health) { healthIndicator[i].SetActive(true); } else { healthIndicator[i].SetActive(false); } } } }</span></span></code> </pre> <br> 这就是我们管理玩家健康的方式。 同样，代码的主要部分位于设置器中： <br><br><ol><li> 如果我们降低了玩家的健康状况，我们会使用<code>CameraShake</code>组件来创造漂亮的震动效果。 该脚本包含在可下载的项目中，在此不再赘述。 </li><li> 我们更新屏幕左上角的私有变量和运行状况标签。 </li><li> 如果运行状况下降到0并且游戏尚未结束，则将<code>gameOver</code>为<code>true</code>并启动<code>gameOver</code>动画。 </li><li> 我们从Cookie中删除其中一个怪物。 如果仅将其关闭，则可以更轻松地编写此部分，但是在此处，如果添加了运行状况，我们将支持重新包含。 </li></ol><br> 我们在<code>Start()</code>初始化<code>Health</code> ： <br><br><pre> <code class="cs hljs">Health = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br> 当场景开始播放时，我们将“ <code>Health</code>设置为<code>5</code> 。 <br><br> 完成所有这些操作后，我们现在可以在错误进入Cookie时更新玩家的健康状况。 保存文件，然后转到IDE的<em>MoveEnemy.cs</em>脚本。 <br><br><h3> 健康改变 </h3><br> 要更改您的健康状况，请在<code>Update()</code>找到带有<code>// TODO:  </code>字样的<code>// TODO:  </code>并将其替换为以下代码： <br><br><pre> <code class="cs hljs">GameManagerBehavior gameManager = GameObject.Find(<span class="hljs-string"><span class="hljs-string">"GameManager"</span></span>).GetComponent&lt;GameManagerBehavior&gt;(); gameManager.Health -= <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br> 因此，我们得到<code>GameManagerBehavior</code>并从其<code>Health</code>减去单位。 <br><br> 保存文件并返回到Unity。 <br><br> 在<em>层次结构中</em>选择一个<em>GameManager</em> ，然后选择<em>HealthLabel</em>作为其<em>Health Label</em> 。 <br><br> 在<em>层次结构中</em>展开<em>Cookie</em>对象，并将其五个子<em>HealthIndicators</em>拖动到<em>GameManager的Health Indicator</em>数组中-健康指标将是吃饼干的绿色小怪物。 <br><br> 运行场景，直到错误到达cookie。 什么都不做，直到输了。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d8/f4a/ea4/8d8f4aea4cec500c3894d233f402b7ba.gif" alt="Cookie攻击"></div><br><h2> 怪物复仇 </h2><br> 怪物到位了吗？ 是的 敌人会进攻吗？ 是的，它们看起来很危险！ 现在该回答这些动物了！ <br><br> 为此，我们需要以下内容： <br><br><ul><li> 健康通道，让玩家知道哪些敌人强而哪些弱 </li><li> 检测怪物范围内的敌人 </li><li> 做出决定-向哪个敌人射击 </li><li> 一堆贝壳 </li></ul><br><h3> 敌人的健康吧 </h3><br> 为了实现健康等级，我们使用两个图像-一个用于深色背景，第二个（绿色条稍小），我们将根据敌人的健康进行缩放。 <br><br> 从<em>项目浏览器</em> <em>拖到Prefabs \ Enemy</em>场景。 <br><br> 然后在<em>层次结构中，</em>将<em>Images \ Objects \ HealthBarBackground拖放</em>到<em>Enemy上，</em>以将其作为子级添加。 <br><br> 在<em>检查器中，</em>将<em>HealthBarBackground</em>的<em>位置</em>设置为<em>（0，1，-4）</em> 。 <br><br> 然后在“ <em>项目浏览器”中，</em>选择“ <em>图像\对象\健康栏”</em> ，并确保其“ <em>透视”</em>为“ <em>左”</em> 。 然后将其添加为<em>层次结构中</em>的<em>敌人</em>的子级，并设置其<em>位置</em>值<em>（-0.63，1，-5）</em> 。 对于<em>X</em> <em>比例，</em>将值设置为<em>125</em> 。 <br><br> 将一个名为<em>HealthBar</em>的新<em>C＃</em>脚本添加<em>到HealthBar</em>游戏对象。 稍后我们将对其进行更改，以使其更改运行状况栏的长度。 <br><br> 在“ <em>层次结构”中</em>选择一个<em>敌人</em>对象后，请确保其位置为<em>（20，0，0）</em> 。 <br><br> 单击<em>检查器</em>顶部的“ <em>应用”</em> ，将所有更改保存为预制件的一部分。 最后，删除<em>Hierarchy中</em>的<em>Enemy</em>对象。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e7/b84/7d2/9e7b847d22d2fda1e146dbf9149f912e.png"></div><br> 现在，重复所有这些步骤，为<em>Prefabs \ Enemy2</em>添加一个健康栏。 <br><br><h3> 更改健康栏的长度 </h3><br> 打开IDE <em>HealthBar.cs</em>并添加以下变量： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> maxHealth = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> currentHealth = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> originalScale;</code> </pre> <br> 在<code>maxHealth</code>中，将存储敌人的最大生命值，而在<code>currentHealth</code> ，将存储剩余的生命值。 最后， <code>originalScale</code>是运行状况栏的初始大小。 <br><br> 将<code>originalScale</code>对象保存在<code>Start()</code> ： <br><br><pre> <code class="cs hljs">originalScale = gameObject.transform.localScale.x;</code> </pre> <br> 我们存储<code>localScale</code>属性的<code>x</code>值。 <br><br> 通过将以下代码添加到<code>Update()</code>来设置运行状况栏的比例： <br><br><pre> <code class="cs hljs">Vector3 tmpScale = gameObject.transform.localScale; tmpScale.x = currentHealth / maxHealth * originalScale; gameObject.transform.localScale = tmpScale;</code> </pre> <br> 我们可以将<code>localScale</code>复制到一个临时变量中，因为我们不能单独更改其<i>x</i>值。 然后，我们根据甲虫的当前健康状况计算新的<i>x</i>比例，并再次将<code>localScale</code>值分配给一个临时变量。 <br><br> 保存文件并在Unity中启动游戏。 在敌人之上，您会看到健康的条纹。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd4/78a/29c/dd478a29c258b63dc809ca16de4ee16a.png"></div><br> 在游戏运行时，展开“ <em>层次结构”</em>中的“ <em>敌人（克隆）”</em>对象之一，然后选择其子项<em>HealthBar</em> 。 更改其<em>当前</em>运行状况值，并查看其运行状况栏如何变化。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ee/af7/22c/5eeaf722c2e6a6ee1d2799380cdcfead.gif"></div><br><h3> 检测范围内的敌人 </h3><br> 现在，我们的怪物需要找出要瞄准的敌人。 但是在意识到这个机会之前，您需要准备《怪物与敌人》。 <br><br> 选择“项目浏览器<em>Prefabs \ Monster”</em> ，然后在“ <em>检查</em>器” <em>中将</em> “ <em>Circle Collider 2D”</em>组件添加到其中。 <br><br> 将对撞机的“ <em>半径”</em>参数设置为<em>2.5-</em>这将指示怪物的攻击半径。 <br><br> 选择“ <em>是触发器”</em>复选框，以使对象穿过该区域而不是与其碰撞。 <br><br> 最后，在<em>检查器</em>的顶部，将“怪物的<em>图层</em> ”设置为“ <em>忽略射线广播”</em> 。 在对话框中，单击“ <em>是，更改子项”</em> 。 如果未选择“忽略射线广播”，则对撞机将响应鼠标单击事件。 这将是一个问题，因为怪物会阻止发往其下的Openspot对象的事件。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3e/302/cf2/e3e302cf21adee1433fe2183120c2ba1.png"></div><br> 为了确保在触发区域中检测到敌人，我们需要向其添加一个对撞机和刚体，因为Unity仅在将刚体附着到其中一个对撞机时才发送触发事件。 <br><br> 在<em>项目浏览器中，</em>选择<em>Prefabs \ Enemy</em> 。 添加<em>Rigidbody 2D</em>组件，然后选择<em>Kinematic</em>作为<em>Body Type</em> 。 这意味着身体将不受物理影响。 <br><br> 添加<em>半径</em>为<em>1的</em> <em>Circle Collider 2D</em> 。 对<em>Prefabs \ Enemy 2</em>重复这些步骤。 <br><br> 触发器已配置，因此怪物将了解敌人在其作用范围内。 <br><br> 我们还需要准备一件事：一个脚本，告诉怪物何时消灭了敌人，以使它们在继续射击时不会引发异常。 <br><br> 创建一个名为<em>EnemyDestructionDelegate</em>的新<em>C＃</em>脚本，并将其添加到<em>Enemy</em>和<em>Enemy2预制件中</em> 。 <br><br> 在IDE中打开<em>EnemyDestructionDelegate.cs</em>并添加以下委托声明： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnemyDelegate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameObject enemy</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> EnemyDelegate enemyDelegate;</code> </pre> <br> 在这里，我们创建一个<code>delegate</code> ，即一个可以作为变量传递的函数的容器。 <br><br><blockquote>  <em>注意</em> ：当一个游戏对象必须主动通知其他游戏对象更改时，将使用委托。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="从Unity文档中">Unity文档中</a>了解有关委托的更多信息。 </blockquote><br> 添加以下方法： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDestroy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (enemyDelegate != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { enemyDelegate(gameObject); } }</code> </pre> <br> 销毁游戏对象后，Unity会自动调用此方法并检查委托是否存在<code>null</code>不等式。 在我们的例子中，我们使用<code>gameObject</code>作为参数来调用它。 这样，所有注册为代表的答卷者都可以知道敌人已被摧毁。 <br><br> 保存文件并返回到Unity。 <br><br><h3> 我们给怪物杀人的许可证 </h3><br> 现在，怪物可以在其行动范围内检测敌人。 将新的<em>C＃</em>脚本添加到<em>Monster</em>预制中，并将其命名为<em>ShootEnemies</em> 。 <br><br> 在IDE中打开<em>ShootEnemies.cs</em> ，并<code>using</code>以下结构将其添加到其中以访问<code>Generics</code> 。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic;</code> </pre> <br> 添加一个变量以跟踪范围内的所有敌人： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;GameObject&gt; enemiesInRange;</code> </pre> <br> 在敌人范围内，我们将存储范围内的所有敌人。 <br><br> 初始化<code>Start()</code>的字段。 <br><br><pre> <code class="cs hljs">enemiesInRange = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;GameObject&gt;();</code> </pre> <br> 一开始，行动范围内没有敌人，因此我们创建了一个空列表。 <br><br> 填写<code>enemiesInRange</code>列表！ 将以下代码添加到脚本中： <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 void OnEnemyDestroy(GameObject enemy) { enemiesInRange.Remove (enemy); } void OnTriggerEnter2D (Collider2D other) { // 2 if (other.gameObject.tag.Equals("Enemy")) { enemiesInRange.Add(other.gameObject); EnemyDestructionDelegate del = other.gameObject.GetComponent&lt;EnemyDestructionDelegate&gt;(); del.enemyDelegate += OnEnemyDestroy; } } // 3 void OnTriggerExit2D (Collider2D other) { if (other.gameObject.tag.Equals("Enemy")) { enemiesInRange.Remove(other.gameObject); EnemyDestructionDelegate del = other.gameObject.GetComponent&lt;EnemyDestructionDelegate&gt;(); del.enemyDelegate -= OnEnemyDestroy; } }</span></span></code> </pre> <br><ol><li> 在<code>OnEnemyDestroy</code>我们将敌人从敌人<code>enemiesInRange</code> 。 当敌人<code>OnTriggerEnter2D</code>在怪物周围的扳机上时，将<code>OnTriggerEnter2D</code> 。 </li><li> 然后，将敌人添加到敌人列表中，并添加<code>EnemyDestructionDelegate</code>事件<code>OnEnemyDestroy</code> 。 因此，我们保证在敌人被摧毁时将<code>OnEnemyDestroy</code> 。 我们不希望怪物为死去的敌人花费弹药，对吗？ </li><li> 在<code>OnTriggerExit2D</code>我们从列表中删除敌人，并取消注册<code>OnTriggerExit2D</code> 。 现在我们知道哪些敌人在射程之内。 </li></ol><br> 保存文件并在Unity中启动游戏。 为了确保一切正常，请<code>enemiesInRange</code>怪物，将其选中，然后按照“ <code>enemiesInRange</code> ”中<code>enemiesInRange</code>列表中的更改进行<code>enemiesInRange</code> 。 <br><br><h3> 目标选择 </h3><br> 怪物现在知道哪个敌人在射程内。 但是，如果方圆内有几个敌人，他们会怎么做？ <br><br> 当然，它们会攻击最靠近肝脏的那一个！ <br><br> 打开<em>MoveEnemy.cs</em> IDE脚本，并添加一个计算该怪物的新方法： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DistanceToGoal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; distance += Vector2.Distance( gameObject.transform.position, waypoints [currentWaypoint + <span class="hljs-number"><span class="hljs-number">1</span></span>].transform.position); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = currentWaypoint + <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; waypoints.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) { Vector3 startPosition = waypoints [i].transform.position; Vector3 endPosition = waypoints [i + <span class="hljs-number"><span class="hljs-number">1</span></span>].transform.position; distance += Vector2.Distance(startPosition, endPosition); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance; }</code> </pre> <br> 该代码计算出敌人尚未走过的路径长度。 为此，它使用<code>Distance</code> ，它被计算为<code>Vector3</code>两个实例之间的距离。 <br><br> 稍后我们将使用此方法找出要攻击的目标。 但是，尽管我们的怪物不是武装无助的，所以首先我们会做到这一点。 <br><br> 保存文件并返回Unity以开始设置外壳。 <br><br><h3> 让我们给怪物壳。 很多贝壳！ </h3><br> 从项目浏览器<em>拖到</em> “ <em>图像/对象/项目符号1”场景</em> 。 将<em>z</em>上的位置设置为<em>-2</em> -x和y上的位置并不重要，因为每次在程序执行过程中每次创建新的射弹实例时都将它们设置。 <br><br> 添加一个名为<em>BulletBehavior</em>的新<em>C＃</em>脚本，然后在IDE中向其添加以下变量： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> damage; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject target; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 startPosition; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 targetPosition; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> startTime; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameManagerBehavior gameManager;</code> </pre> <br>  <code>speed</code>决定了弹丸的速度； 从名称中<code>damage</code>清楚看出<code>damage</code>的<code>damage</code> 。 <br><br>  <code>target</code> ， <code>startPosition</code>和<code>targetPosition</code>确定弹丸的方向。 <br><br>  <code>distance</code>和<code>startTime</code>跟踪弹丸的当前位置。 当玩家杀死敌人时， <code>gameManager</code>奖励玩家。 <br><br> 在<code>Start()</code>分配这些变量的值： <br><br><pre> <code class="cs hljs">startTime = Time.time; distance = Vector2.Distance (startPosition, targetPosition); GameObject gm = GameObject.Find(<span class="hljs-string"><span class="hljs-string">"GameManager"</span></span>); gameManager = gm.GetComponent&lt;GameManagerBehavior&gt;();</code> </pre> <br> <code>startTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们设置当前时间的值并计算起始位置和目标位置之间的距离。</font><font style="vertical-align: inherit;">而且，照常获得</font></font><code>GameManagerBehavior</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要控制弹丸的​​运动，请添加</font></font><code>Update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下代码：</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 float timeInterval = Time.time - startTime; gameObject.transform.position = Vector3.Lerp(startPosition, targetPosition, timeInterval * speed / distance); // 2 if (gameObject.transform.position.Equals(targetPosition)) { if (target != null) { // 3 Transform healthBarTransform = target.transform.Find("HealthBar"); HealthBar healthBar = healthBarTransform.gameObject.GetComponent&lt;HealthBar&gt;(); healthBar.currentHealth -= Mathf.Max(damage, 0); // 4 if (healthBar.currentHealth &lt;= 0) { Destroy(target); AudioSource audioSource = target.GetComponent&lt;AudioSource&gt;(); AudioSource.PlayClipAtPoint(audioSource.clip, transform.position); gameManager.Gold += 50; } } Destroy(gameObject); }</span></span></code> </pre> <br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们使用</font></font><code>Vector3.Lerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">起点和终点之间的插值</font><font style="vertical-align: inherit;">来计算弹丸的新</font><font style="vertical-align: inherit;">位置。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果弹丸到达</font></font><code>targetPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则我们检查</font><font style="vertical-align: inherit;">弹丸</font><font style="vertical-align: inherit;">是否仍然存在</font></font><code>target</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们获得了</font></font><code>HealthBar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目标</font><font style="vertical-align: inherit;">的组成部分，</font><font style="vertical-align: inherit;">并通过</font></font><code>damage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">射弹</font><font style="vertical-align: inherit;">的大小降低了它的生命值</font><font style="vertical-align: inherit;">。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如果敌人的生命值降低到零，我们将摧毁它，重现声音效果，并奖励玩家准确性。 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 保存文件并返回到Unity。 </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们做大贝壳 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果怪物开始以高水平射击更多的炮弹，那不是很好吗？幸运的是，这很容易实现。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet1</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏对象</font><font style="vertical-align: inherit;">从“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">层次结构</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ” </font><em><font style="vertical-align: inherit;">拖到</font></em><font style="vertical-align: inherit;"> “ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选项卡上，</font><font style="vertical-align: inherit;">以创建射弹预制件。从场景中删除原始对象-我们将不再需要它。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet1</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预制件复制</font><em><font style="vertical-align: inherit;">两次</font></em><font style="vertical-align: inherit;">。命名</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet3</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的副本</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检查器中，</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprite </font></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderer”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">组件</font><font style="vertical-align: inherit;">的“ </font><em><font style="vertical-align: inherit;">Sprite”</font></em><font style="vertical-align: inherit;">字段设置</font><font style="vertical-align: inherit;">为“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Images / Objects / Bullet2”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，我们将使Bullet2比Bullet1多一点。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重复此过程，将Bullet3 </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预制</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的精灵更改</font><font style="vertical-align: inherit;">为</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Images / Objects / Bullet3</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">子弹行为”中，</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将</font><font style="vertical-align: inherit;">进一步</font><font style="vertical-align: inherit;">调整由炮弹造成的伤害。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选项卡中选择</font><font style="vertical-align: inherit;">预制的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet1</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检查</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">你看到</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">子弹行为（脚本）</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它可以将</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">伤害</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet1</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文档bullet2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">20</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet3</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -或您喜欢的任何其他值。 </font></font><br><br><blockquote> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：我更改了值，以便在较高级别下损坏的价格会更高。</font><font style="vertical-align: inherit;">这样可以防止升级程序允许玩家在最佳点升级怪物。</font></font></blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0a/e2d/da2/c0ae2dda288d44bc380864dd1e85f3b6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预制壳-尺寸随级别增加</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 改变炮弹水平 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将不同的外壳分配给不同级别的怪物，以便更强的怪物更快地消灭敌人。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在IDE中打开</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MonsterData.cs</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并添加到</font></font><code>MonsterLevel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下变量：</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject bullet; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fireRate;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，我们为每个级别的怪物设置了射弹的预制件和射击频率。</font><font style="vertical-align: inherit;">保存文件并返回Unity以完成怪物设置。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在项目浏览器中选择</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Monster</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预制件</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检查器中，</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">展开</font><font style="vertical-align: inherit;">“ </font><em><font style="vertical-align: inherit;">怪物数据（脚本）”</font></em><font style="vertical-align: inherit;">组件中的</font><em><font style="vertical-align: inherit;">“ </font></em></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关卡</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ” </font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">将</font><font style="vertical-align: inherit;">每个项目</font><font style="vertical-align: inherit;">的</font><em><font style="vertical-align: inherit;">射击率</font></em><font style="vertical-align: inherit;">设置</font><font style="vertical-align: inherit;">为</font><em><font style="vertical-align: inherit;">1</font></em><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">然后将</font><font style="vertical-align: inherit;">元素0、1和2 </font><font style="vertical-align: inherit;">的</font><em><font style="vertical-align: inherit;">Bullet</font></em><font style="vertical-align: inherit;">参数设置</font><font style="vertical-align: inherit;">为</font><em><font style="vertical-align: inherit;">Bullet1</font></em><font style="vertical-align: inherit;">，</font><em><font style="vertical-align: inherit;">Bullet2</font></em><font style="vertical-align: inherit;">和</font><em><font style="vertical-align: inherit;">Bullet3</font></em><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">怪物等级应设置如下：</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8c0/7d0/fd9/8c07d0fd96492f9e0e6c6e1737791c11.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">炮弹杀死敌人？</font><font style="vertical-align: inherit;">是的 </font><font style="vertical-align: inherit;">让我们开火吧！</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 开火 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在IDE中打开</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ShootEnemies.cs</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并添加以下变量：</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lastShotTime; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MonsterData monsterData;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顾名思义，这些变量会跟踪最后一次射击怪物的时间，以及</font></font><code>MonsterData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包含有关怪物壳类型，发射频率等信息</font><font style="vertical-align: inherit;">的结构</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在中设置这些字段的值</font></font><code>Start()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="cs hljs">lastShotTime = Time.time; monsterData = gameObject.GetComponentInChildren&lt;MonsterData&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里，我们分配</font></font><code>lastShotTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当前时间</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">值，并可以访问</font></font><code>MonsterData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该对象</font><font style="vertical-align: inherit;">的组件</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加以下方法来实现射击：</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Collider2D target</span></span></span><span class="hljs-function">)</span></span> { GameObject bulletPrefab = monsterData.CurrentLevel.bullet; <span class="hljs-comment"><span class="hljs-comment">// 1 Vector3 startPosition = gameObject.transform.position; Vector3 targetPosition = target.transform.position; startPosition.z = bulletPrefab.transform.position.z; targetPosition.z = bulletPrefab.transform.position.z; // 2 GameObject newBullet = (GameObject)Instantiate (bulletPrefab); newBullet.transform.position = startPosition; BulletBehavior bulletComp = newBullet.GetComponent&lt;BulletBehavior&gt;(); bulletComp.target = target.gameObject; bulletComp.startPosition = startPosition; bulletComp.targetPosition = targetPosition; // 3 Animator animator = monsterData.CurrentLevel.visualization.GetComponent&lt;Animator&gt;(); animator.SetTrigger("fireShot"); AudioSource audioSource = gameObject.GetComponent&lt;AudioSource&gt;(); audioSource.PlayOneShot(audioSource.clip); }</span></span></code> </pre> <br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们得到了子弹的起始位置和目标位置。</font><font style="vertical-align: inherit;">将位置z设置为z </font></font><code>bulletPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">以前，我们将弹丸的预制位置设置为z，以使弹丸显示在射击怪物下方，但在敌人上方。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们使用</font></font><code>bulletPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">适当的</font><font style="vertical-align: inherit;">shell创建一个新shell的实例</font></font><code>MonsterLevel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">分配</font></font><code>startPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并</font></font><code>targetPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">投射。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们使游戏更有趣：当怪物射击时，开始射击动画并播放激光的声音。 </font></font></li></ol><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 全部放在一起 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在是时候将所有内容放在一起了。</font><font style="vertical-align: inherit;">定义目标并使怪物看着它。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c5/934/9a7/3c59349a719669c9508c38f155bf25dc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ShootEnemies.cs</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">脚本中</font><em><font style="vertical-align: inherit;">，</font></em><font style="vertical-align: inherit;">添加</font></font><code>Update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下代码：</font></font><br><br><pre> <code class="cs hljs">GameObject target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 float minimalEnemyDistance = float.MaxValue; foreach (GameObject enemy in enemiesInRange) { float distanceToGoal = enemy.GetComponent&lt;MoveEnemy&gt;().DistanceToGoal(); if (distanceToGoal &lt; minimalEnemyDistance) { target = enemy; minimalEnemyDistance = distanceToGoal; } } // 2 if (target != null) { if (Time.time - lastShotTime &gt; monsterData.CurrentLevel.fireRate) { Shoot(target.GetComponent&lt;Collider2D&gt;()); lastShotTime = Time.time; } // 3 Vector3 direction = gameObject.transform.position - target.transform.position; gameObject.transform.rotation = Quaternion.AngleAxis( Mathf.Atan2 (direction.y, direction.x) * 180 / Mathf.PI, new Vector3 (0, 0, 1)); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 逐步考虑此代码。 </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确定怪物的目的。</font><font style="vertical-align: inherit;">我们从中的最大可能距离开始</font></font><code>minimalEnemyDistance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果敌人到Cookie的距离小于当前的最小距离，我们将在一个范围内的所有敌人周围循环，并使其成为新的目标。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们调用</font></font><code>Shoot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">经过时间是否大于怪物的射击频率，并设置</font></font><code>lastShotTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当前时间</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">值。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们计算怪物与其目标之间的旋转角度。</font><font style="vertical-align: inherit;">我们将怪物旋转到这个角度。</font><font style="vertical-align: inherit;">现在，他将始终盯着目标。</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保存文件并在Unity中启动游戏。</font><font style="vertical-align: inherit;">怪物将开​​始拼命保护cookie。</font><font style="vertical-align: inherit;">我们终于完成了！</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 接下来要去哪里 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以</font></font><a href="" title="在这里"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载完成的项目</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们在本教程中做得很好，现在我们有了出色的游戏。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下是一些对该项目进行进一步开发的想法：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 更多类型的敌人和怪物 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 敌人的不同路线 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 不同的游戏等级 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些方面中的每一个都将需要最小的更改，并且可以使游戏更加有趣。</font><font style="vertical-align: inherit;">如果您根据本教程创建了一个新游戏，我将很乐于玩该游戏，因此请共享一个链接。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这次</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="制作热门塔防游戏：顶级应用开发采访"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">采访中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以找到有关创建塔防热门游戏的有趣想法</font><font style="vertical-align: inherit;">。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN413915/">https://habr.com/ru/post/zh-CN413915/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN413901/index.html">通过ROS使用PS4 Dualshock 4游戏杆控制EduMip自平衡机器人</a></li>
<li><a href="../zh-CN413903/index.html">Cambridge Analytica如何将点击转化为声音</a></li>
<li><a href="../zh-CN413907/index.html">面向移动开发人员256的有趣材料的摘要（6月4日-6月12日）</a></li>
<li><a href="../zh-CN413909/index.html">那是你儿时的回忆去的地方</a></li>
<li><a href="../zh-CN413913/index.html">熟悉音频和视频设备展览会：简要介绍最大的活动-第一部分</a></li>
<li><a href="../zh-CN413917/index.html">版权持有者认为，Yandex为该国盗版行为的增长做出了贡献</a></li>
<li><a href="../zh-CN413921/index.html">如何节省额外的费用</a></li>
<li><a href="../zh-CN413923/index.html">也许仍然可以清除大气中的二氧化碳</a></li>
<li><a href="../zh-CN413925/index.html">莫斯科无级变速器</a></li>
<li><a href="../zh-CN413927/index.html">Attiny85上的Digispark-在Windows 10下连接</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>