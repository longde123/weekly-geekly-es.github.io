<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äç‚úàÔ∏è üëàüèæ ‚ûï Comment nous avons doubl√© la vitesse de travail avec Float en Mono üßëüèæ ü§µüèø üëó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mon ami Aras a r√©cemment √©crit le m√™me ray tracer dans diff√©rents langages, y compris C ++, C # et le compilateur Unity Burst. Bien s√ªr, il est nature...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment nous avons doubl√© la vitesse de travail avec Float en Mono</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432176/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49a/c69/c73/49ac69c73ac3a6c124f04b468dfb90d5.png"></div><br>  Mon ami Aras a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©cemment √©crit</a> le m√™me ray tracer dans diff√©rents langages, y compris C ++, C # et le compilateur Unity Burst.  Bien s√ªr, il est naturel de s'attendre √† ce que C # soit plus lent que C ++, mais il m'a sembl√© int√©ressant que Mono soit tellement plus lent que .NET Core. <br><br>  Ses <a href="">indicateurs</a> publi√©s √©taient m√©diocres: <br><br><ul><li>  C # (.NET Core): Mac 17,5 Mray / s, </li><li>  C # (Unity, Mono): Mac 4.6 Mray / s, </li><li>  C # (Unity, IL2CPP): Mac 17.1 Mray / s </li></ul><br>  J'ai d√©cid√© de voir ce qui se passait et de documenter les endroits qui pourraient √™tre am√©lior√©s. <br><br>  Gr√¢ce √† cette r√©f√©rence et √† l'√©tude de ce probl√®me, nous avons trouv√© trois domaines dans lesquels une am√©lioration est possible: <br><br><ul><li>  Tout d'abord, vous devez am√©liorer les param√®tres Mono par d√©faut, car les utilisateurs ne configurent g√©n√©ralement pas leurs param√®tres </li><li>  Deuxi√®mement, nous devons introduire activement le monde au backend de l'optimisation de code LLVM en Mono </li><li>  Troisi√®mement, nous avons am√©lior√© le r√©glage de certains param√®tres mono. </li></ul><br>  Le point de r√©f√©rence de ce test √©tait les r√©sultats du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traceur de rayons</a> ex√©cut√© sur ma machine, et puisque j'ai un mat√©riel diff√©rent, nous ne pouvons pas comparer les chiffres. <br><br>  Les r√©sultats sur mon iMac domestique pour Mono et .NET Core √©taient les suivants: <br><br><table><thead><tr><th>  Environnement de travail </th><th>  R√©sultats, MRay / sec </th></tr></thead><tbody><tr><td> .NET Core 2.1.4, <code>dotnet run</code> d√©bogage <code>dotnet run</code> </td><td>  3,6 </td></tr><tr><td>  <code>dotnet run -c Release</code> .NET Core 2.1.4 build build <code>dotnet run -c Release</code> </td><td>  21,7 </td></tr><tr><td>  Vanilla Mono, <code>mono Maths.exe</code> </td><td>  6,6 </td></tr><tr><td>  Vanilla Mono avec LLVM et float32 </td><td>  15,5 </td></tr></tbody></table><a name="habracut"></a><br>  Au cours de l'√©tude de ce probl√®me, nous avons trouv√© quelques probl√®mes, apr√®s la correction desquels les r√©sultats suivants ont √©t√© obtenus: <br><br><table><thead><tr><th>  Environnement de travail </th><th>  R√©sultats, MRay / sec </th></tr></thead><tbody><tr><td>  Mono avec LLVM et float32 </td><td>  15,5 </td></tr><tr><td>  Mono avanc√© avec LLVM, float32 et fixe en ligne </td><td>  29,6 </td></tr></tbody></table><br>  La vue d'ensemble: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/407/ecf/385/407ecf385de6261087b4395928076e02.png"></div><br>  En appliquant simplement LLVM et float32, vous pouvez augmenter les performances du code √† virgule flottante de pr√®s de 2,3 fois.  Et apr√®s le r√©glage, que nous avons ajout√© √† Mono √† la suite de ces exp√©riences, vous pouvez augmenter la productivit√© de 4,4 fois par rapport au Mono standard - ces param√®tres dans les futures versions de Mono deviendront les param√®tres par d√©faut. <br><br>  Dans cet article, je vais expliquer nos r√©sultats. <br><br><h2>  Flottant 32 bits et 64 bits </h2><br>  Aras utilise des nombres √† virgule flottante 32 bits pour la partie principale des calculs (tapez <code>float</code> en C # ou <code>System.Single</code> dans .NET).  Dans Mono, nous avons fait une erreur il y a longtemps - tous les calculs en virgule flottante 32 bits ont √©t√© effectu√©s en 64 bits et les donn√©es √©taient toujours stock√©es dans des zones 32 bits. <br><br>  Aujourd'hui, ma m√©moire n'est pas aussi nette qu'auparavant, et je ne me souviens pas exactement pourquoi nous avons pris une telle d√©cision. <br><br>  Je ne peux que supposer qu'il a √©t√© influenc√© par les tendances et les id√©es de l'√©poque. <br><br>  Puis une aura positive a plan√© autour de l'informatique flottante avec une pr√©cision accrue.  Par exemple, les processeurs Intel x87 ont utilis√© une pr√©cision de 80 bits pour les calculs en virgule flottante, m√™me lorsque les op√©randes √©taient doubles, ce qui a fourni aux utilisateurs des r√©sultats plus pr√©cis. <br><br>  √Ä cette √©poque, l'id√©e √©tait √©galement pertinente que dans l'un de mes projets pr√©c√©dents - Feuilles de calcul Gnumeric - les fonctions statistiques aient √©t√© mises en ≈ìuvre plus efficacement que dans Excel.  Par cons√©quent, de nombreuses communaut√©s sont bien conscientes de l'id√©e que des r√©sultats plus pr√©cis avec une pr√©cision accrue peuvent √™tre utilis√©s. <br><br>  Aux √©tapes initiales du d√©veloppement Mono, la plupart des op√©rations math√©matiques effectu√©es sur toutes les plates-formes ne pouvaient recevoir que le double en entr√©e.  Des versions 32 bits ont √©t√© ajout√©es √† C99, Posix et ISO, mais √† cette √©poque, elles n'√©taient pas largement disponibles pour l'ensemble de l'industrie (par exemple, <code>sinf</code> est la version flottante de <code>sin</code> , <code>fabsf</code> est la version de <code>fabs</code> , etc.). <br><br>  Bref, le d√©but des ann√©es 2000 a √©t√© une p√©riode d'optimisme. <br><br>  Les applications ont pay√© un lourd tribut pour l'augmentation du temps de calcul, mais Mono √©tait principalement utilis√© pour les applications Linux de bureau servant des pages HTTP et certains processus de serveur, donc la vitesse √† virgule flottante n'√©tait pas le probl√®me que nous rencontrions quotidiennement.  Il n'est devenu visible que dans certains r√©f√©rentiels scientifiques, et en 2003, ils ont rarement √©t√© d√©velopp√©s sur .NET. <br><br>  Aujourd'hui, les jeux, les applications 3D, le traitement d'image, la r√©alit√© virtuelle, la r√©alit√© augment√©e et l'apprentissage automatique ont fait des op√©rations en virgule flottante un type de donn√©es plus courant.  Le probl√®me ne vient pas seul et il n'y a pas d'exceptions.  Float n'√©tait plus le type de donn√©es convivial utilis√© dans le code √† quelques endroits.  Ils se sont transform√©s en avalanche, d'o√π il n'y a nulle part o√π se cacher.  Ils sont nombreux et leur propagation ne peut √™tre stopp√©e. <br><br><h2>  Indicateur d'espace de travail float32 </h2><br>  Par cons√©quent, il y a quelques ann√©es, nous avons d√©cid√© d'ajouter la prise en charge de l'ex√©cution d'op√©rations flottantes 32 bits √† l'aide d'op√©rations 32 bits, comme dans tous les autres cas.  Nous avons appel√© cette fonctionnalit√© de l'espace de travail ¬´float32¬ª.  En Mono, il est activ√© en ajoutant l'option <code>--O=float32</code> dans l'environnement de travail, et dans les applications Xamarin, ce param√®tre est modifi√© dans les param√®tres du projet. <br><br>  Ce nouveau drapeau a √©t√© bien re√ßu par nos utilisateurs mobiles, car les appareils mobiles ne sont toujours pas trop puissants et il est pr√©f√©rable de traiter les donn√©es plus rapidement que d'avoir une pr√©cision accrue.  Nous avons recommand√© aux utilisateurs mobiles d'activer le compilateur d'optimisation LLVM et l'indicateur float32 en m√™me temps. <br><br>  Bien que ce drapeau soit impl√©ment√© depuis plusieurs ann√©es, nous ne l'avons pas fait par d√©faut pour √©viter les mauvaises surprises des utilisateurs.  Cependant, nous avons commenc√© √† rencontrer des cas o√π des surprises surviennent en raison d'un comportement 64 bits standard, voir ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapport de bogue soumis par l'utilisateur Unity</a> . <br><br>  Nous allons maintenant utiliser Mono <code>float32</code> , les progr√®s peuvent √™tre suivis ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/mono/mono/issues/6985</a> . <br><br>  En attendant, je suis revenu sur le projet de mon ami Aras.  Il a utilis√© les nouvelles API ajout√©es √† .NET Core.  Bien que .NET Core ait toujours effectu√© des op√©rations flottantes 32 bits en tant que flottants 32 bits, l'API <code>System.Math</code> effectue toujours des conversions de <code>float</code> en <code>double</code> dans le processus.  Par exemple, si vous devez calculer la fonction sinus pour une valeur flottante, alors la seule option est d'appeler <code>Math.Sin (double)</code> , et vous devrez convertir de flottant en double. <br><br>  Pour r√©soudre ce probl√®me, un nouveau type de <code>System.MathF</code> √©t√© ajout√© √† .NET Core qui contient des op√©rations math√©matiques avec virgule flottante simple pr√©cision, et maintenant nous venons de d√©placer ce <code>[System.MathF]</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">en Mono</a> . <br><br>  La transition de 64 bits √† 32 bits float am√©liore consid√©rablement les performances, comme le montre ce tableau: <br><br><table><thead><tr><th>  <strong>Environnement de travail et options</strong> </th><th>  Mrays / seconde </th></tr></thead><tbody><tr><td>  Mono avec System.Math </td><td>  6,6 </td></tr><tr><td>  Mono avec System.Math et <code>-O=float32</code> </td><td>  8.1 </td></tr><tr><td>  Mono avec System.MathF </td><td>  6.5 </td></tr><tr><td>  Mono avec System.MathF et <code>-O=float32</code> </td><td>  8.2 </td></tr></tbody></table><br>  Autrement dit, l'utilisation de <code>float32</code> dans ce test am√©liore vraiment les performances et MathF a peu d'effet. <br><br><h1>  Configuration de LLVM </h1><br>  Au cours de cette recherche, nous avons constat√© que bien que le compilateur Fast JIT Mono ait <code>float32</code> support <code>float32</code> , nous n'avons pas ajout√© ce support au backend LLVM.  Cela signifiait que Mono avec LLVM effectuait toujours des conversions co√ªteuses du flottant au double. <br><br>  Par cons√©quent, Zoltan a ajout√© la <code>float32</code> charge de <code>float32</code> au moteur de g√©n√©ration de code LLVM. <br><br>  Il a ensuite remarqu√© que notre inliner utilise les m√™mes heuristiques pour Fast JIT que celles utilis√©es pour LLVM.  Lorsque vous travaillez avec Fast JIT, il est n√©cessaire de trouver un √©quilibre entre la vitesse JIT et la vitesse d'ex√©cution.Par cons√©quent, nous avons limit√© la quantit√© de code int√©gr√© afin de r√©duire la quantit√© de travail du moteur JIT. <br><br>  Mais si vous d√©cidez d'utiliser LLVM en Mono, vous vous efforcez d'obtenir le code le plus rapidement possible, nous avons donc modifi√© les param√®tres en cons√©quence.  Aujourd'hui, ce param√®tre peut √™tre modifi√© √† l'aide de la <code>MONO_INLINELIMIT</code> environnement <code>MONO_INLINELIMIT</code> , mais en fait, il doit √™tre √©crit aux valeurs par d√©faut. <br><br>  Voici les r√©sultats avec les param√®tres LLVM modifi√©s: <br><br><table><thead><tr><th>  Environnement de travail et options </th><th>  Mrays / secondes </th></tr></thead><tbody><tr><td>  Mono avec System.Math <code>--llvm -O=float32</code> </td><td>  16,0 </td></tr><tr><td>  Mono avec System.Math <code>--llvm -O=float32</code> , heuristique constante </td><td>  29,1 </td></tr><tr><td>  Mono avec System.MathF <code>--llvm -O=float32</code> , heuristique constante </td><td>  29,6 </td></tr></tbody></table><br><h1>  Prochaines √©tapes </h1><br>  Peu d'efforts ont √©t√© n√©cessaires pour apporter toutes ces am√©liorations.  Ces changements ont √©t√© men√©s par des discussions p√©riodiques √† Slack.  J'ai m√™me r√©ussi √† faire quelques heures un soir pour porter <code>System.MathF</code> vers Mono. <br><br>  Le code Aras ray tracer est devenu un sujet d'√©tude id√©al car il √©tait autosuffisant, c'√©tait une vraie application, et non une r√©f√©rence synth√©tique.  Nous voulons trouver d'autres logiciels similaires qui peuvent √™tre utilis√©s pour √©tudier le code binaire que nous g√©n√©rons, et nous assurer que nous transmettons √† LLVM les meilleures donn√©es pour l'ex√©cution optimale de son travail. <br><br>  Nous envisageons √©galement de mettre √† jour notre LLVM et d'utiliser les nouvelles optimisations ajout√©es. <br><br><h1>  Note s√©par√©e </h1><br>  La pr√©cision suppl√©mentaire a de beaux effets secondaires.  Par exemple, en lisant les demandes de pool du moteur Godot, j'ai vu qu'il y avait une discussion active sur l'opportunit√© de rendre la pr√©cision des op√©rations en virgule flottante personnalisable au moment de la compilation ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/godotengine/godot/pull/17134</a> ). <br><br>  J'ai demand√© √† Juan pourquoi cela pouvait √™tre n√©cessaire pour quelqu'un, car je pensais que les op√©rations en virgule flottante 32 bits √©taient assez suffisantes pour les jeux. <br><br>  Juan a expliqu√© que dans le cas g√©n√©ral, les flotteurs fonctionnent tr√®s bien, mais si vous vous √©loignez du centre, disons, √©loignez-vous de 100 kilom√®tres du centre du jeu, une erreur de calcul commence √† s'accumuler, ce qui peut conduire √† des probl√®mes graphiques int√©ressants.  Vous pouvez utiliser diff√©rentes strat√©gies pour r√©duire l'impact de ce probl√®me, et l'une d'entre elles consiste √† travailler avec une pr√©cision accrue, pour laquelle vous devez payer pour les performances. <br><br>  Peu de temps apr√®s notre conversation, dans mon fil Twitter, j'ai vu un post d√©montrant ce probl√®me: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://pharr.org/matt/blog/2018/03/02/rendering-in-camera-space.html</a> <br><br>  <em>Le probl√®me est illustr√© dans les images ci-dessous.</em>  <em>Nous voyons ici un mod√®le de voiture de sport de l'ensemble</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>pbrt-v3-sc√®nes</em></a> ** <em>.</em>  <em>La cam√©ra et la sc√®ne sont proches de l'origine, et tout semble parfait.</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f1/702/725/4f1702725634faa3ba94aa930230fb6d.png"></div><br>  ** <em>(Auteur de</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Yasutoshi Mori</em></a> <em>.)</em> <br><br>  Ensuite, nous d√©pla√ßons la cam√©ra et la sc√®ne de 200 000 unit√©s √† xx, yy et zz depuis l'origine.  On peut voir que le mod√®le de la machine est devenu assez fragment√©;  cela est uniquement d√ª √† un manque de pr√©cision dans les nombres √† virgule flottante. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/842/4b0/658/8424b065878f52bcd83b5d2de19321e5.png"></div><br>  <em>Si l'on avance encore 5 √ó 5 √ó 5 fois, √† 1 million d'unit√©s de l'origine, le mod√®le commence √† se d√©sint√©grer;</em>  <em>la machine se transforme en une approximation de voxel extr√™mement grossi√®re d'elle-m√™me, √† la fois int√©ressante et terrifiante.</em>  <em>(Keanu a pos√© la question: Minecraft est-il si cubique simplement parce que tout est rendu tr√®s loin de l'origine?)</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49a/c69/c73/49ac69c73ac3a6c124f04b468dfb90d5.png"></div><br>  ** <em>(Je m'excuse aupr√®s de</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Yasutoshi Mori</em></a> <em>pour ce que nous avons fait avec son beau mod√®le.)</em> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr432176/">https://habr.com/ru/post/fr432176/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr432166/index.html">Apache NiFi: de quoi s'agit-il et un bref aper√ßu des fonctionnalit√©s</a></li>
<li><a href="../fr432168/index.html">Les autorit√©s chinoises collectent des informations sur les v√©hicules √©lectriques des citoyens du pays</a></li>
<li><a href="../fr432170/index.html">Transportez un centre de donn√©es en 14 400 secondes</a></li>
<li><a href="../fr432172/index.html">Invitation dangereuse ou Fonctionnement de la charge de combat pour un e-mail de phishing</a></li>
<li><a href="../fr432174/index.html">Comment d√©velopper avec comp√©tence et efficacit√© un produit logiciel</a></li>
<li><a href="../fr432178/index.html">... et une garantie pour les projecteurs - augmenter</a></li>
<li><a href="../fr432180/index.html">Comment pomper votre carri√®re via GitHub</a></li>
<li><a href="../fr432182/index.html">Nous r√©cup√©rons le courrier sans sms ni inscription</a></li>
<li><a href="../fr432184/index.html">Identit√©s des probl√®mes chez les testeurs</a></li>
<li><a href="../fr432186/index.html">Utilisation de STP pour cr√©er des canaux P2P</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>