<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëß üëäüèª ü¶ì Introducci√≥n Newton Protocol: lo que puede caber en 4 kilobytes üëì üë®üèø‚Äçüåæ ‚úíÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente compit√≠ en la escena de demostraci√≥n de Revision 2019 en la categor√≠a de introducci√≥n de PC 4k, y mi introducci√≥n gan√≥ el primer lugar. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introducci√≥n Newton Protocol: lo que puede caber en 4 kilobytes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450612/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfa/bba/a35/bfabbaa350d27446b3b058ce41e73228.png" alt="imagen"></div><br>  Recientemente compit√≠ en la escena de demostraci√≥n de Revision 2019 en la categor√≠a de introducci√≥n de PC 4k, y mi introducci√≥n gan√≥ el primer lugar.  Hice codificaci√≥n y gr√°ficos, y dixan compuso m√∫sica.  La regla b√°sica de la competencia es crear un archivo ejecutable o un sitio web que tenga solo 4096 bytes de tama√±o.  Esto significa que todo tiene que ser generado usando matem√°ticas y algoritmos;  de ninguna otra manera puedo comprimir im√°genes, video y audio en una cantidad tan peque√±a de memoria.  En este art√≠culo, hablar√© sobre la canalizaci√≥n de renderizaci√≥n de mi introducci√≥n de Newton.  A continuaci√≥n puede ver el resultado final, o <a href="">haga clic aqu√≠</a> para ver c√≥mo se ve√≠a en vivo en Revision, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">vaya a pouet</a> para comentar y descargar la introducci√≥n que particip√≥ en la competencia.  Puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">leer</a> sobre el trabajo y las correcciones de los competidores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/iIIu7kPCN-8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  La t√©cnica de los campos de distancia de marcha de Ray es muy popular en la disciplina de introducci√≥n 4k porque le permite especificar formas complejas en solo unas pocas l√≠neas de c√≥digo.  Sin embargo, la desventaja de este enfoque es la velocidad de ejecuci√≥n.  Para renderizar la escena, debe encontrar el punto de intersecci√≥n de los rayos con la escena, primero determinar lo que ve, por ejemplo, un rayo de la c√°mara y luego los rayos posteriores del objeto a las fuentes de luz para calcular la iluminaci√≥n.  Cuando se trabaja con la marcha de rayos, estas intersecciones no se pueden encontrar en un solo paso, debe dar muchos pasos peque√±os a lo largo de la viga y evaluar todos los objetos en cada punto.  Por otro lado, cuando se usa el trazado de rayos, puede encontrar la intersecci√≥n exacta marcando cada objeto solo una vez, pero el conjunto de formas que se puede usar es muy limitado: debe tener una f√≥rmula para cada tipo para calcular la intersecci√≥n con el rayo. <br><br>  En esta introducci√≥n, quer√≠a simular una iluminaci√≥n muy precisa.  Como era necesario reflejar millones de rayos en la escena, el trazado de rayos parec√≠a una opci√≥n l√≥gica para lograr este efecto.  Me limit√© a una sola figura: una esfera, porque la intersecci√≥n de un rayo y una esfera se calcula de manera bastante simple.  Incluso las paredes en la introducci√≥n son en realidad esferas muy grandes.  Adem√°s, simplific√≥ la simulaci√≥n de la f√≠sica;  fue suficiente para tener en cuenta solo los conflictos entre las esferas. <br><br>  Para ilustrar la cantidad de c√≥digo que cabe en 4096 bytes, a continuaci√≥n present√© el c√≥digo fuente completo de la introducci√≥n terminada.  Todas las partes, excepto el HTML al final, est√°n codificadas como una imagen PNG para comprimirlas a un tama√±o m√°s peque√±o.  Sin esta compresi√≥n, el c√≥digo habr√≠a tomado casi 8900 bytes.  La parte llamada Synth es una versi√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">simplificada</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SoundBox</a> .  Para empaquetar el c√≥digo en este formato minimizado, utilic√© el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Compilador de cierre de Google</a> y el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Shader Minifier</a> .  Al final, casi todo se comprime en PNG usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JsExe</a> .  La tuber√≠a de compilaci√≥n completa se puede ver en el c√≥digo fuente de mi anterior 4k intro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Core Critical</a> , porque coincide completamente con el presentado aqu√≠. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5b/274/690/e5b27469046c9c34bfb14fc2fbe33fa5.png"></div><br>  <i>La m√∫sica y el sintetizador est√°n completamente implementados en Javascript.</i>  <i>La parte en WebGL se divide en dos partes (resaltada en verde en el c√≥digo);</i>  <i>ella configura la tuber√≠a de renderizado.</i>  <i>La f√≠sica y los elementos trazadores de rayos son sombreadores GLSL.</i>  <i>El resto del c√≥digo se codifica en una imagen PNG y se agrega HTML al final de la imagen resultante sin cambios.</i>  <i>El navegador ignora los datos de la imagen y solo ejecuta el c√≥digo HTML, que a su vez decodifica PNG nuevamente en JavaScript y lo ejecuta.</i> <br><br><h3>  Tuber√≠a de renderizado </h3><br>  La siguiente imagen muestra la canalizaci√≥n de renderizado.  Se compone de dos partes.  La primera parte de la tuber√≠a es un simulador de f√≠sica.  La escena de introducci√≥n contiene 50 esferas que chocan entre s√≠ dentro de la habitaci√≥n.  La habitaci√≥n en s√≠ se compone de seis esferas, algunas de las cuales son m√°s peque√±as que otras para crear paredes m√°s curvas.  Dos fuentes verticales de iluminaci√≥n en las esquinas tambi√©n son esferas, es decir, un total de 58 esferas en la escena.  La segunda parte de la tuber√≠a es el rastreador, que representa la escena.  El siguiente diagrama muestra la representaci√≥n de un cuadro en el tiempo t.  La simulaci√≥n f√≠sica toma el cuadro anterior (t-1) y simula el estado actual.  El rastreador de rayos toma las posiciones actuales y las posiciones del fotograma anterior (para el canal de velocidad) y renderiza la escena.  Luego, el procesamiento posterior combina los 5 cuadros anteriores y el cuadro actual para reducir la distorsi√≥n y el ruido, y luego crea un resultado final. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6a/848/ac0/f6a848ac09343ca15abfd03393a7ceeb.png"></div><br>  <i>Representaci√≥n de un marco en el tiempo t.</i> <br><br>  La parte f√≠sica es bastante simple, en Internet puede encontrar muchos tutoriales sobre la creaci√≥n de simulaciones primitivas para esferas.  La posici√≥n, el radio, la velocidad y la masa se almacenan en dos texturas con una resoluci√≥n de 1 x 58. Utilic√© la funcionalidad Webgl 2, que permite renderizar a m√∫ltiples objetivos de renderizado, por lo que los datos de dos texturas se registran simult√°neamente.  El rastreador de rayos utiliza la misma funcionalidad para crear tres texturas.  Webgl no proporciona ning√∫n acceso a las API de trazado de rayos NVidia RTX o DirectX Raytracing (DXR), por lo que todo se hace desde cero. <br><br><h3>  Rastreador </h3><br>  El trazado de rayos en s√≠ mismo es una t√©cnica bastante primitiva.  Lanzamos un rayo en la escena, se refleja 4 veces y, si entra en la fuente de luz, se acumula el color de los reflejos;  de lo contrario, nos ponemos negros.  En 4096 bytes (que incluye m√∫sica, sintetizador, f√≠sica y renderizado) no hay espacio para crear estructuras complejas de trazado acelerado de rayos.  Por lo tanto, utilizamos el m√©todo de fuerza bruta, es decir, verificamos las 57 esferas (se excluye la pared frontal) para cada rayo, sin hacer ninguna optimizaci√≥n para excluir parte de las esferas.  Esto significa que para proporcionar 60 fotogramas por segundo en una resoluci√≥n de 1080p, puede emitir solo 2-6 rayos o muestras por p√≠xel.  Esto es lo suficientemente cerca como para crear una iluminaci√≥n suave. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b23/2ce/72d/b232ce72d49f57a69b96d402ec0bb148.png"></div><br>  <i>1 muestra por p√≠xel.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e52/77d/19e/e5277d19e5a7b897b8dd9046eaae6f26.png"></div><br>  <i>6 muestras por p√≠xel.</i> <br><br>  ¬øC√≥mo lidiar con esto?  Al principio investigu√© el algoritmo de trazado de rayos, pero ya estaba simplificado.  Logr√© aumentar ligeramente el rendimiento al eliminar los casos cuando el rayo comienza dentro de la esfera, porque tales casos son aplicables solo en presencia de efectos de transparencia, y solo los objetos opacos estaban presentes en nuestra escena.  Despu√©s de eso, combin√© cada condici√≥n if en una declaraci√≥n separada para evitar ramificaciones innecesarias: a pesar de los c√°lculos "redundantes", este enfoque es a√∫n m√°s r√°pido que un conjunto de declaraciones condicionales.  Tambi√©n fue posible mejorar el patr√≥n de muestreo: en lugar de emitir rayos al azar, podr√≠amos distribuirlos por la escena en un patr√≥n m√°s uniforme.  Desafortunadamente, esto no ayud√≥ y condujo a artefactos ondulados en cada algoritmo que prob√©.  Sin embargo, este enfoque cre√≥ buenos resultados para las im√°genes fijas.  Como resultado, volv√≠ a usar una distribuci√≥n completamente aleatoria. <br><br>  Los p√≠xeles vecinos deben tener una iluminaci√≥n muy similar, entonces, ¬øpor qu√© no usarlos al calcular la iluminaci√≥n de un solo p√≠xel?  No queremos difuminar las texturas, solo la iluminaci√≥n, por lo que debemos renderizarlas en canales separados.  Tampoco queremos desenfocar objetos, por lo que debemos tener en cuenta los identificadores de los objetos para saber qu√© p√≠xeles se pueden desenfocar f√°cilmente.  Dado que tenemos objetos que reflejan la luz y necesitamos reflejos claros, no es suficiente averiguar la identificaci√≥n del primer objeto con el que colisiona el haz.  Utilic√© un caso especial para materiales reflectantes puros para incluir tambi√©n las ID del primer y segundo objeto visibles en reflejos en el canal identificador de objeto.  En este caso, el desenfoque puede suavizar la iluminaci√≥n de los objetos en reflejos y al mismo tiempo mantener los l√≠mites de los objetos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f69/a24/a6b/f69a24a6b9094903309af27b5606e923.png"></div><br>  <i>Canal de textura, no necesitamos desenfocarlo.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4f/c4a/7f6/a4fc4a7f6ec4fa0552542edf7204cb58.png"></div><br>  <i>Aqu√≠ en el canal rojo contiene la identificaci√≥n del primer objeto, en verde, el segundo, y en azul, el tercero.</i>  <i>En la pr√°ctica, todos ellos est√°n codificados en un solo valor del formato flotante, en el que la parte entera almacena los identificadores de los objetos, y el fraccionario indica rugosidad: 332211.RR.</i> <br><br>  Como hay objetos con diferentes rugosidades en la escena (algunas √°reas son rugosas, la luz se dispersa sobre otras, en la tercera hay un reflejo del espejo), almaceno la rugosidad para controlar el radio de desenfoque.  No hay peque√±os detalles en la escena, por lo que utilic√© un n√∫cleo grande de 50 x 50 con los pesos en forma de cuadrados inversos para desenfocar.  No tiene en cuenta el espacio mundial (esto podr√≠a realizarse para obtener resultados m√°s precisos), porque en las superficies ubicadas en √°ngulo en algunas direcciones, erosiona un √°rea m√°s grande.  Tal desenfoque crea una imagen bastante suave, pero los artefactos son claramente visibles, especialmente en movimiento. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca6/553/f9d/ca6553f9d61bc8f7dda51ba41c2cbf28.png"></div><br>  <i>Canal de iluminaci√≥n con desenfoque y artefactos a√∫n notables.</i>  <i>En esta imagen, se ven puntos borrosos en la pared posterior, que son causados ‚Äã‚Äãpor un peque√±o error con los identificadores del segundo objeto reflejado (los rayos abandonan la escena).</i>  <i>En la imagen terminada, esto no es muy notable, porque se toman reflejos claros del canal de textura.</i>  <i>Las fuentes de iluminaci√≥n tambi√©n se vuelven borrosas, pero me gust√≥ este efecto y lo dej√©.</i>  <i>Si lo desea, esto puede evitarse cambiando los identificadores de los objetos seg√∫n el material.</i> <br><br>  Cuando hay objetos en la escena y la c√°mara que dispara la escena se mueve lentamente, la iluminaci√≥n en cada cuadro debe permanecer constante.  Por lo tanto, podemos realizar el desenfoque no solo en las coordenadas XY de la pantalla;  Podemos desdibujarnos a tiempo.  Si suponemos que la iluminaci√≥n no cambia demasiado en 100 ms, podemos promediarla para 6 cuadros.  Pero durante esta ventana de tiempo, los objetos y la c√°mara a√∫n recorrer√°n cierta distancia, por lo que un simple c√°lculo del promedio de 6 cuadros crear√° una imagen muy borrosa.  Sin embargo, sabemos d√≥nde estaban todos los objetos y la c√°mara en el mapa anterior, por lo que podemos calcular los vectores de velocidad en el espacio de la pantalla.  Esto se llama reproyecci√≥n temporal.  Si tengo un p√≠xel en el momento t, entonces puedo tomar la velocidad de ese p√≠xel y calcular d√≥nde estaba en el momento t-1, y luego calcular d√≥nde est√° el p√≠xel en el momento t-1 en el momento t-2, y as√≠ sucesivamente. 5 cuadros de nuevo.  A diferencia del desenfoque en el espacio de la pantalla, utilic√© el mismo peso para cada cuadro, es decir  acaba de promediar el color entre todos los cuadros para un "desenfoque" temporal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1fc/a4c/e42/1fca4ce4250f372223862a34472add21.png"></div><br>  <i>Un canal de velocidad de p√≠xeles que informa d√≥nde se encontraba el p√≠xel en el √∫ltimo fotograma en funci√≥n del movimiento del objeto y la c√°mara.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/011/bb5/1f6/011bb51f60e3b3066c87ee4a1d46d403.png"></div><br>  <i>Para evitar el desenfoque conjunto de los objetos, volveremos a utilizar el canal de identificadores de objetos.</i>  <i>En este caso, solo consideramos el primer objeto con el que colision√≥ el rayo.</i>  <i>Esto proporciona anti-aliasing dentro del objeto, es decir</i>  <i>en reflejos</i> <br><br>  Por supuesto, el p√≠xel podr√≠a no haber sido visible en el cuadro anterior;  podr√≠a estar oculto por otro objeto o estar fuera del campo de visi√≥n de la c√°mara.  En tales casos, no podemos usar la informaci√≥n previa.  Esta verificaci√≥n se realiza por separado para cada cuadro, por lo que obtenemos de 1 a 6 muestras o cuadros por p√≠xel y usamos los que son posibles.  La siguiente figura muestra que para objetos lentos este no es un problema muy serio. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c5b/c89/8fc/c5bc898fc8ac6ff9b5a0c8685312604f.png"></div><br>  <i>Cuando los objetos se mueven y abren nuevas partes de la escena, no tenemos 6 cuadros de informaci√≥n para promediar estas partes.</i>  <i>Esta imagen muestra √°reas que tienen 6 cuadros (blanco), as√≠ como aquellas que carecen de ellas (sombras que se oscurecen gradualmente).</i>  <i>La apariencia de los contornos es causada por la aleatorizaci√≥n de las ubicaciones de muestreo para el p√≠xel en cada cuadro y el hecho de que tomamos el identificador del objeto de la primera muestra.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/570/c4c/b4a/570c4cb4a84f008a497678b0b735930e.png"></div><br>  <i>La iluminaci√≥n borrosa se promedia en seis cuadros.</i>  <i>Los artefactos son casi invisibles y el resultado es estable en el tiempo, porque en cada cuadro solo uno de cada seis cambios en los que se tiene en cuenta la iluminaci√≥n.</i> <br><br>  Combinando todo esto, obtenemos una imagen terminada.  La iluminaci√≥n se difumina a los p√≠xeles vecinos, mientras que las texturas y los reflejos permanecen claros.  Luego, todo esto se promedia entre seis cuadros para crear una imagen a√∫n m√°s uniforme y estable a lo largo del tiempo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfa/bba/a35/bfabbaa350d27446b3b058ce41e73228.png"></div><br>  <i>La imagen terminada.</i> <br><br>  Los artefactos de amortiguaci√≥n a√∫n son notables, porque promedi√© varias muestras por p√≠xel, aunque tom√© el canal del identificador de objeto y la velocidad para la primera intersecci√≥n.  Puede intentar solucionar esto y suavizar las reflexiones descartando las muestras si no coinciden con la primera, o al menos si la primera colisi√≥n no coincide en orden.  En la pr√°ctica, los rastros son casi invisibles, as√≠ que no me molest√© en eliminarlos.  Los l√≠mites de los objetos tambi√©n est√°n distorsionados, porque los canales de velocidad y los identificadores de objetos no se pueden suavizar.  Estaba considerando la posibilidad de renderizar toda la imagen a 2160p con una reducci√≥n adicional de escala a 1080p, pero mi NVidia GTX 980ti no es capaz de procesar tales resoluciones a 60 fps, as√≠ que decid√≠ abandonar esta idea. <br><br>  En general, estoy muy satisfecho con la presentaci√≥n.  Me las arregl√© para exprimir todo lo que ten√≠a en mente, y a pesar de errores menores, el resultado final fue de muy alta calidad.  En el futuro, puede intentar corregir errores y mejorar el suavizado.  Tambi√©n vale la pena experimentar con caracter√≠sticas como la transparencia, el desenfoque de movimiento, diversas formas y transformaciones de objetos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba9/f56/e02/ba9f56e02c13d046f73e888540a0d75e.png"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/450612/">https://habr.com/ru/post/450612/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../450602/index.html">‚ÄúC√≥mo construimos IaaS‚Äù: materiales de 1cloud</a></li>
<li><a href="../450604/index.html">Tamizando miles de millones de n√∫meros simples m√°s r√°pido que Wikipedia</a></li>
<li><a href="../450606/index.html">Un d√≠a en la vida de una modelo de restaurante.</a></li>
<li><a href="../450608/index.html">Follando entre nosotros</a></li>
<li><a href="../450610/index.html">Termoac√∫stica. Generando electricidad a partir del sonido usando un altavoz</a></li>
<li><a href="../450614/index.html">Abril 2019 Joomla Digest</a></li>
<li><a href="../450618/index.html">¬øPor qu√©, seg√∫n las estad√≠sticas de Yandex y StackOverfow C #, los programadores son los m√°s baratos?</a></li>
<li><a href="../450620/index.html">Enigma de un neutrino de Supernova 1987A</a></li>
<li><a href="../450624/index.html">Saludo de Hayabusa-2</a></li>
<li><a href="../450626/index.html">Reparar patr√≥n de dise√±o - Singleton en PHP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>