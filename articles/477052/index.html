<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê¢ üåä üíí Reactor, WebFlux, Kotlin Coroutines o Asynchrony con un ejemplo simple üßíüèæ üë©üèΩ‚ÄçüöÄ üåÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Muchos servicios en el mundo moderno, en su mayor parte, "no hacen nada". Sus tareas se reducen a solicitudes de otras bases de datos / servicios / ca...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reactor, WebFlux, Kotlin Coroutines o Asynchrony con un ejemplo simple</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/477052/"><img src="https://habrastorage.org/webt/oc/vm/jy/ocvmjybd42pjwnaqjaxeyz_dxlo.png"><br><br><p>  Muchos servicios en el mundo moderno, en su mayor parte, "no hacen nada".  Sus tareas se reducen a solicitudes de otras bases de datos / servicios / cach√©s y la agregaci√≥n de todos estos datos de acuerdo con varias reglas y diversas l√≥gicas comerciales.  Por lo tanto, no es sorprendente que aparezcan idiomas como Golang, con un conveniente sistema competitivo incorporado que facilita la organizaci√≥n del c√≥digo sin bloqueo. </p><br><p>  En el mundo JVM, las cosas son un poco m√°s complicadas.  Hay una gran cantidad de marcos y bibliotecas que bloquean los hilos cuando se usan.  Entonces, stdlib en s√≠ mismo puede hacer lo mismo a veces.  Y en Java no hay un mecanismo similar al de las gorutinas en Golang. </p><br><p>  Sin embargo, JVM se est√° desarrollando activamente y aparecen nuevas oportunidades interesantes.  Hay Kotlin con corutinas, que en su uso son muy similares a las gorutinas de Golang (aunque se implementan de una manera completamente diferente).  Hay JEP Loom, que traer√° fibras a la JVM en el futuro.  Uno de los marcos web m√°s populares, Spring, recientemente agreg√≥ la capacidad de crear servicios completamente sin bloqueo en Webflux.  Y con el reciente lanzamiento de Spring boot 2.2, la integraci√≥n con Kotlin es a√∫n mejor. </p><br><p>  Propongo, utilizando el ejemplo de un peque√±o servicio para transferir dinero de una tarjeta a otra, escribir una aplicaci√≥n en Spring boot 2.2 y Kotlin para la integraci√≥n con varios servicios externos. </p><a name="habracut"></a><br><p>  Es bueno si ya est√° familiarizado con Java, Kotlin, Gradle, Spring, Spring boot 2, Reactor, Web <s>flux, Tomcat, Netty, Kotlin oroutines, Gradle Kotlin DSL o incluso tiene un Ph.D.</s>  Pero si no, no importa.  El c√≥digo se simplificar√° al m√°ximo, e incluso si no eres del mundo JVM, espero que todo est√© claro para ti. </p><br><p>  Si planea escribir un servicio usted mismo, aseg√∫rese de que todo lo que necesita est√© instalado: </p><br><ul><li>  Java 8+ </li><li>  Docker y Docker Compose; </li><li>  cURL y preferiblemente <a href="https://stedolan.github.io/jq/download/">jq</a> ; </li><li>  Git </li><li>  preferiblemente un IDE para Kotlin (Intellij Idea, Eclipse, VS, <s>vim</s> , etc.).  Pero es posible en un cuaderno. </li></ul><br><p>  Los ejemplos contendr√°n ambos espacios en blanco para la implementaci√≥n en el servicio y una implementaci√≥n ya escrita.  Primero, ejecute la instalaci√≥n y el ensamblaje y observe m√°s de cerca los servicios y sus API. </p><br><blockquote> El ejemplo de los servicios y la API en s√≠ se hace solo con fines ilustrativos; ¬°no transfiera todo <code>AS IS</code> a su producto! </blockquote><p>  Primero, clonamos el repositorio con servicios para nosotros, la integraci√≥n con la que lo haremos, y vamos al directorio: </p><br><pre> <code class="plaintext hljs">git clone https://github.com/evgzakharov/spring-demo-services &amp;&amp; cd spring-demo-services</code> </pre> <br><p>  En una terminal separada, recopilamos todas las aplicaciones usando <code>gradle</code> , donde despu√©s de una compilaci√≥n exitosa, todos los servicios se lanzar√°n usando <code>docker-compose</code> . </p><br><pre> <code class="plaintext hljs">./gradlew build &amp;&amp; docker-compose up</code> </pre> <br><p>  Mientras todo est√° descargado e instalado, considere un proyecto con servicios. </p><br><img src="https://habrastorage.org/webt/go/mp/mb/gompmbrgtjwsuz9pnpbaxbuksg8.png"><br><p>  A la entrada del servicio (servicio de demostraci√≥n) se recibir√° una solicitud con un token, los n√∫meros de tarjeta para la transferencia y el monto a transferir entre tarjetas: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"authToken"</span></span>: <span class="hljs-string"><span class="hljs-string">"auth-token1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"cardFrom"</span></span>: <span class="hljs-string"><span class="hljs-string">"55593478"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"cardTo"</span></span>: <span class="hljs-string"><span class="hljs-string">"55592020"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"amount"</span></span>: <span class="hljs-string"><span class="hljs-string">"10.1"</span></span> }</code> </pre> <br><p>  <code>authToken</code> token <code>authToken</code> , debe ir al servicio <code>AUTH</code> y obtener <code>userId</code> , con el que luego puede hacer una solicitud al <code>USER</code> y extraer toda la informaci√≥n adicional sobre el usuario.  <code>AUTH</code> tambi√©n devolver√° informaci√≥n sobre a cu√°l de los tres servicios podemos acceder.  Ejemplo de respuesta de <code>AUTH</code> : </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"userId"</span></span>: <span class="hljs-number"><span class="hljs-number">158</span></span>, <span class="hljs-attr"><span class="hljs-attr">"cardAccess"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"paymentAccess"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"userAccess"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><p>  Para transferir entre tarjetas, primero vaya con cada n√∫mero de tarjeta en la <code>CARD</code> .  En respuesta a las solicitudes, recibiremos <code>cardId</code> , luego con ellos enviaremos una solicitud a <code>PAYMENT</code> y haremos una transferencia.  Y lo √∫ltimo: una vez m√°s enviamos una solicitud de <code>PAYMENT</code> con <code>fromCardId</code> y descubrimos el saldo actual. </p><br><p>  Para emular un peque√±o retraso en los servicios, el valor de la variable de entorno TIMEOUT se genera en todos los contenedores, en los que el retraso de respuesta se establece en milisegundos.  Y para diversificar las respuestas de <code>AUTH</code> , es posible variar el valor de <code>SUCCESS_RATE</code> , que controla la probabilidad de una respuesta <code>true</code> para el servicio. </p><br><p>  Archivo Docker-compose.yaml: </p><br><pre> <code class="plaintext hljs">version: '3' services: service-auth: build: service-auth image: service-auth:1.0.0 environment: - SUCCESS_RATE=1.0 - TIMEOUT=100 ports: - "8081:8080" service-card: build: service-card image: service-card:1.0.0 environment: - TIMEOUT=100 ports: - "8082:8080" service-payment: build: service-payment image: service-payment:1.0.0 environment: - TIMEOUT=100 ports: - "8083:8080" service-user: build: service-user image: service-user:1.0.0 environment: - TIMEOUT=100 ports: - "8084:8080"</code> </pre> <br><p>  Para todos los servicios, el reenv√≠o de puertos desde 8081 a 8084 se realiza para llegar f√°cilmente a ellos directamente. </p><br><p>  Pasemos a escribir el <code>Demo service</code> .  Primero, intentemos escribir la implementaci√≥n lo m√°s torpe posible, sin asincron√≠a ni concurrencia.  Para hacer esto, tome Spring boot 2.2.1, Kotlin y un espacio en blanco para el servicio.  Clonamos el repositorio y vamos a la rama <code>spring-mvc-start</code> : </p><br><pre> <code class="plaintext hljs">git clone https://github.com/evgzakharov/demo-service &amp;&amp; cd demo-service &amp;&amp; git checkout spring-mvc-start</code> </pre> <br><p>  Vaya al archivo <code>demo.Controller</code> .  Tiene el √∫nico m√©todo <code>processRequest</code> vac√≠o para el que se debe escribir una implementaci√≥n. </p><br><pre> <code class="kotlin hljs"> <span class="hljs-meta"><span class="hljs-meta">@PostMapping</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response { .. }</code> </pre> <br><p>  Se recibir√° una solicitud de transferencia entre tarjetas a la entrada del m√©todo. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceRequest</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> authToken: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFrom: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardTo: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> amount: BigDecimal )</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Para aquellos que no est√°n familiarizados con Spring</b> <div class="spoiler_text"><p>  Spring tiene una DI incorporada que funciona en base a anotaciones.  El DemoController est√° marcado con la anotaci√≥n especial <code>RestController</code> : adem√°s de registrar el bean en el DI, tambi√©n agrega su procesamiento como controlador.  PostProcessor encuentra todos los m√©todos marcados con la anotaci√≥n <code>PostMapping</code> y los agrega como punto final para el servicio con el m√©todo <code>POST</code> . </p><br><p>  El controlador tambi√©n crea una clase proxy para DemoController, en la que todos los argumentos necesarios se pasan al m√©todo <code>processRequest</code> .  En nuestro caso, este es solo un argumento, marcado con la anotaci√≥n <code>@RequestBody</code> .  Por lo tanto, en proxy, este m√©todo se llamar√° con el contenido JSON deserializado en la clase <code>ServiceRequest</code> . </p></div></div><br><p>  Para facilitarlo, todos los m√©todos para la integraci√≥n con otros servicios ya se han realizado, solo necesita conectarlos correctamente.  Solo hay cinco m√©todos, uno para cada acci√≥n.  Las llamadas a otros servicios se implementan en la llamada de <strong>bloqueo</strong> Spring <code>RestTemplate</code> . </p><br><p>  M√©todo de ejemplo para llamar a <code>AUTH</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAuthInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(token: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: AuthInfo { log.info(<span class="hljs-string"><span class="hljs-string">"getAuthInfo"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restTemplate.getForEntity(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${demoConfig.auth}</span></span></span><span class="hljs-string">/{token}"</span></span>, AuthInfo::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">token) .body ?: throw RuntimeException</span></span></span></span>(<span class="hljs-string"><span class="hljs-string">"couldn't find user by token='</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$token</span></span></span><span class="hljs-string">'"</span></span>) }</code> </pre> <br><p>  Pasemos a la implementaci√≥n del m√©todo.  Los comentarios indican el procedimiento y qu√© respuesta se espera en la salida: </p><br><pre> <code class="kotlin hljs"> <span class="hljs-meta"><span class="hljs-meta">@PostMapping</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response { <span class="hljs-comment"><span class="hljs-comment">//1) get auth info from service by token -&gt; userId //2) find user info by userId from 1. //3) 4) find cards info for each card in serviceRequest // 5) make transaction for known cards by calling sendMoney(id1, id2, amount) // 6) after payment get payment info by fromCardId TODO("return SuccessResponse") // SuccessResponse( // amount = , // userName = , // userSurname = , // userAge = // ) }</span></span></code> </pre> <br><p>  Primero, implementamos el m√©todo lo m√°s simple posible, sin tener en cuenta que <code>AUTH</code> puede negarnos el acceso a otros servicios.  Intenta hacerlo t√∫ mismo.  Cuando resulta (o despu√©s de cambiar a la rama <code>spring-mvc</code> ), puede verificar el funcionamiento del servicio de la siguiente manera: </p><br><div class="spoiler">  <b class="spoiler_title">implementaci√≥n desde la sucursal spring-mvc</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> authInfo = getAuthInfo(serviceRequest.authToken) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfo = findUser(authInfo.userId) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfo = findCardInfo(serviceRequest.cardFrom) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardToInfo = findCardInfo(serviceRequest.cardTo) sendMoney(cardFromInfo.cardId, cardToInfo.cardId, serviceRequest.amount) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfo = getPaymentInfo(cardFromInfo.cardId) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SuccessResponse( amount = paymentInfo.currentAmount, userName = userInfo.name, userSurname = userInfo.surname, userAge = userInfo.age ) }</code> </pre> </div></div><br><p>  Inicie el servicio (desde la carpeta de servicio de demostraci√≥n): </p><br><pre> <code class="plaintext hljs">./gradlew bootRun</code> </pre> <br><p>  Enviamos una solicitud al punto final: </p><br><pre> <code class="plaintext hljs">./demo-request.sh</code> </pre> <br><p>  En respuesta, obtenemos algo como esto: </p><br><pre> <code class="plaintext hljs">‚ûú demo-service git:(spring-mvc) ‚úó ./demo-request.sh + curl -XPOST http://localhost:8080/ -d @demo-payment-request.json -H 'Content-Type: application/json; charset=UTF-8' + jq . % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 182 0 85 100 97 20 23 0:00:04 0:00:04 --:--:-- 23 { "amount": 989.9, "userName": "Vasia", "userSurname": "Pupkin", "userAge": 18, "status": true }</code> </pre> <br><p>  En total, debe realizar 6 solicitudes para implementar el servicio.  Y dado que cada uno de ellos responde con un retraso de 100 ms, el tiempo total no puede ser inferior a 600 ms.  En realidad, resulta unos 700 ms, teniendo en cuenta todos los gastos generales.  Hasta ahora, el c√≥digo es bastante simple, y si ahora queremos agregar una verificaci√≥n de respuesta <code>AUTH</code> para acceder a otros servicios, esto no ser√° dif√≠cil de hacer (como cualquier otra refactorizaci√≥n). </p><br><p>  Pero pensemos en c√≥mo puede acelerar la ejecuci√≥n de consultas.  Si no tiene en cuenta la verificaci√≥n de la respuesta de <code>AUTH</code> , tenemos 2 tareas independientes: </p><br><ul><li>  obtener <code>userId</code> y solicitar datos del <code>USER</code> ; </li><li>  recibiendo <code>cardId</code> para cada tarjeta, haciendo un pago y recibiendo el monto total. </li></ul><br><p>  Estas tareas se pueden realizar independientemente una de la otra.  Entonces, el tiempo total de ejecuci√≥n depender√° de la cadena de llamadas m√°s larga (en este caso, la segunda) y se ejecutar√° en total durante 300 ms + X ms de sobrecarga. </p><br><p>  Dado que las llamadas mismas est√°n bloqueando, la √∫nica forma de ejecutar solicitudes paralelas es ejecutarlas en subprocesos separados.  Puede crear un hilo separado para cada llamada, pero ser√° muy costoso.  Otra forma es ejecutar tareas en ThreadPool.  A primera vista, dicha soluci√≥n parece apropiada y el tiempo realmente disminuir√°.  Por ejemplo, podemos ejecutar consultas en CompletableFuture.  Le permite ejecutar tareas en segundo plano llamando a m√©todos con el postfix <code>async</code> .  Y si no especifica un ThreadPool espec√≠fico al llamar a los m√©todos, las tareas se iniciar√°n en <code>ForkJoinPool.commonPool()</code> .  Intente escribir una implementaci√≥n usted mismo o vaya a la rama <code>spring-mvc-async</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Implementaci√≥n desde la rama spring-mvc-async</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> authInfoFuture = CompletableFuture.supplyAsync { getAuthInfo(serviceRequest.authToken) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfoFuture = authInfoFuture.thenApplyAsync { findUser(it.userId) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfo = CompletableFuture.supplyAsync { findCardInfo(serviceRequest.cardFrom) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardToInfo = CompletableFuture.supplyAsync { findCardInfo(serviceRequest.cardTo) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> waitAll = CompletableFuture.allOf(cardFromInfo, cardToInfo) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfoFuture = waitAll .thenApplyAsync { sendMoney(cardFromInfo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>().cardId, cardToInfo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>().cardId, serviceRequest.amount) } .thenApplyAsync { getPaymentInfo(cardFromInfo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>().cardId) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfo = paymentInfoFuture.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfo = userInfoFuture.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() log.info(<span class="hljs-string"><span class="hljs-string">"result"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SuccessResponse( amount = paymentInfo.currentAmount, userName = userInfo.name, userSurname = userInfo.surname, userAge = userInfo.age ) }</code> </pre> </div></div><br><p>  Si ahora medimos el tiempo de solicitud, ser√° en la regi√≥n de 360 ‚Äã‚Äãms.  En comparaci√≥n con la versi√≥n original, el tiempo total disminuy√≥ en casi 2 veces.  El c√≥digo en s√≠ se ha vuelto un poco m√°s complicado, pero hasta ahora no es dif√≠cil modificarlo.  Y si aqu√≠ queremos agregar una verificaci√≥n de respuesta de <code>AUTH</code> , entonces esto no es dif√≠cil. </p><br><p>  Pero, ¬øqu√© pasa si tenemos una gran cantidad de solicitudes entrantes para el servicio en s√≠?  ¬øDecir unas 1000 solicitudes simult√°neas?  Con este enfoque, resulta bastante r√°pido que todos los hilos de ThreadPool est√°n ocupados haciendo llamadas de bloqueo.  Y llegamos a la conclusi√≥n de que la versi√≥n actual tampoco es adecuada. </p><br><p>  Solo queda hacer algo con el servicio que se hace llamar.  Puede modificar consultas y hacerlas sin bloqueo.  Luego, los m√©todos para llamar a los servicios devolver√°n CompletableFuture, Flux, Observable, Deferred, Promise o un objeto similar sobre el cual construir una cadena de expectativas.  Con este enfoque, no necesitamos hacer llamadas en flujos separados: ser√° suficiente tener uno (o al menos un peque√±o grupo separado de flujos) que ya hayamos tomado prestados para procesar las solicitudes. </p><br><p>  ¬øPodemos ahora soportar la pesada carga del servicio?  Para responder a esta pregunta, eche un vistazo a Tomcat, que se utiliza en Spring boot 2.2.1 en el arranque <code>org.springframework.boot:spring-boot-starter-web</code> .  Est√° construido de manera que se asigna un subproceso de ThreadPool para cada solicitud entrante para su procesamiento.  Y en ausencia de flujos libres, las nuevas solicitudes se convertir√°n en una "cola" de espera.  Pero nuestro servicio en s√≠ solo env√≠a solicitudes a otros servicios.  Asignar una secuencia completa debajo de ella y bloquearla hasta que lleguen respuestas de todos, mira, por decirlo suavemente, superfluo. </p><br><p>  Afortunadamente, Spring recientemente hizo posible usar un servidor web sin bloqueo basado en Netty o Undertow.  Para hacer esto, solo necesita cambiar <code>spring-boot-starter-web</code> a <code>spring-boot-starter-webflux</code> y cambiar ligeramente el m√©todo para procesar solicitudes en el que la solicitud y la respuesta se "envolver√°n" en Mono.  Esto se debe al hecho de que Webflux se basa en Reactor y, por lo tanto, ahora en el m√©todo que necesita para construir una cadena de transformaciones Mono. <br></p><p>  Intente escribir su propia implementaci√≥n sin bloqueo del m√©todo.  Para hacer esto, vaya a la rama <code>spring-webflux-start</code> .  Tenga en cuenta que el iniciador de Spring Boot ha cambiado, donde ahora se usa la versi√≥n con Webflux, y la implementaci√≥n de solicitudes a otros servicios que se han reescrito para usar <code>WebClient</code> sin bloqueo tambi√©n ha cambiado. </p><br><p>  M√©todo de ejemplo para llamar a AUTH: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAuthInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(token: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Mono&lt;AuthInfo&gt; { log.info(<span class="hljs-string"><span class="hljs-string">"getAuthInfo"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WebClient.create().<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() .uri(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${demoConfig.auth}</span></span></span><span class="hljs-string">/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$token</span></span></span><span class="hljs-string">"</span></span>) .retrieve() .bodyToMono(AuthInfo::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) }</span></span></code> </pre> <br><p>  La implementaci√≥n del primer ejemplo se inserta en el contenido del m√©todo <code>processRequest</code> en un comentario.  Intenta reescribirlo t√∫ mismo en Reactor.  Como la √∫ltima vez, primero haga la versi√≥n sin tener en cuenta los controles de <code>AUTH</code> , y luego vea lo dif√≠cil que es agregarlos: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Mono</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: Mono&lt;Response&gt; { <span class="hljs-comment"><span class="hljs-comment">// val authInfo = getAuthInfo(serviceRequest.authToken) // // val userInfo = findUser(authInfo.userId) // // val cardFromInfo = findCardInfo(serviceRequest.cardFrom) // val cardToInfo = findCardInfo(serviceRequest.cardTo) // // sendMoney(cardFromInfo.cardId, cardToInfo.cardId, serviceRequest.amount) // // val paymentInfo = getPaymentInfo(cardFromInfo.cardId) // // log.info("result") // // return SuccessResponse( // amount = paymentInfo.currentAmount, // userName = userInfo.name, // userSurname = userInfo.surname, // userAge = userInfo.age // ) TODO() }</span></span></code> </pre> <br><p>  Despu√©s de lidiar con esto, puede compararlo con mi implementaci√≥n desde la <code>spring-webflux</code> : </p><br><div class="spoiler">  <b class="spoiler_title">Implementaci√≥n desde la rama spring-webflux</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Mono</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: Mono&lt;Response&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cacheRequest = serviceRequest.cache() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfoMono = cacheRequest.flatMap { getAuthInfo(it.authToken) }.flatMap { findUser(it.userId) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfoMono = cacheRequest.flatMap { findCardInfo(it.cardFrom) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardToInfoMono = cacheRequest.flatMap { findCardInfo(it.cardTo) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfoMono = cardFromInfoMono.zipWith(cardToInfoMono) .flatMap { (cardFromInfo, cardToInfo) -&gt; cacheRequest.flatMap { request -&gt; sendMoney(cardFromInfo.cardId, cardToInfo.cardId, request.amount).map { cardFromInfo } } }.flatMap { getPaymentInfo(it.cardId) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> userInfoMono.zipWith(paymentInfoMono) .map { (userInfo, paymentInfo) -&gt; log.info(<span class="hljs-string"><span class="hljs-string">"result"</span></span>) SuccessResponse( amount = paymentInfo.currentAmount, userName = userInfo.name, userSurname = userInfo.surname, userAge = userInfo.age ) } }</code> </pre> </div></div><br><p>  Acuerde que ahora escribir una implementaci√≥n (en comparaci√≥n con el enfoque de bloqueo anterior) se ha vuelto m√°s dif√≠cil.  Y si queremos agregar cheques "olvidados" de <code>AUTH</code> , entonces esto no ser√° tan f√°cil de hacer. </p><br><p>  Esta es la esencia del enfoque reactivo.  Es ideal para construir cadenas de procesamiento no ramificadas.  Pero si aparece la ramificaci√≥n, entonces el c√≥digo ya no es tan simple. </p><br><p>  Las corutinas de Kotlin, que son muy amigables con cualquier c√≥digo as√≠ncrono / reactivo, pueden ayudar aqu√≠.  Adem√°s, hay una gran cantidad de envoltorios escritos para <a href="">Reactor</a> , <a href="https://github.com/Kotlin/kotlinx.coroutines/tree/master/integration/kotlinx-coroutines-jdk8">CompletableFuture</a> , etc.  Pero incluso si no encuentra el correcto, siempre puede escribirlo usted mismo, utilizando <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/suspend-cancellable-coroutine.html">constructores</a> especiales. </p><br><p>  Reescribamos la implementaci√≥n en corutinas por nuestra cuenta.  Para hacer esto, vaya a la <code>spring-webflux-coroutines-start</code> .  Se le agregan las dependencias necesarias en build.gradle.kts: </p><br><pre> <code class="kotlin hljs">implementation(<span class="hljs-string"><span class="hljs-string">"org.jetbrains.kotlinx:kotlinx-coroutines-core:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$kotlinCoroutinesVersion</span></span></span><span class="hljs-string">"</span></span>) implementation(<span class="hljs-string"><span class="hljs-string">"org.jetbrains.kotlinx:kotlinx-coroutines-reactive:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$kotlinCoroutinesVersion</span></span></span><span class="hljs-string">"</span></span>) implementation(<span class="hljs-string"><span class="hljs-string">"org.jetbrains.kotlinx:kotlinx-coroutines-reactor:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$kotlinCoroutinesVersion</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br><p>  Y el m√©todo <code>processRequest</code> cambia un <code>processRequest</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response = coroutineScope { <span class="hljs-comment"><span class="hljs-comment">//TODO() }</span></span></code> </pre> <br><p>  Ya no necesita Mono y se traduce simplemente en una funci√≥n de suspensi√≥n (gracias a la integraci√≥n de Spring y Kotlin).  Teniendo en cuenta que crearemos corutinas adicionales en el m√©todo, necesitaremos crear un <code>coroutineScope</code> exploraci√≥n <code>coroutineScope</code> (para comprender las razones para crear un alcance adicional, consulte la publicaci√≥n de Roman Elizarov sobre <a href="https://medium.com/%40elizarov/structured-concurrency-722d765aa952">concurrencia estructurada</a> ).  Tenga en cuenta que otras llamadas de servicio no han cambiado en absoluto.  Devuelven el mismo Mono en el que se puede llamar al m√©todo de <code>suspend</code> awaitFirst para "esperar" el resultado de la consulta. </p><br><p>  Si las corutinas siguen siendo un concepto nuevo para usted, entonces hay una <a href="">gu√≠a</a> maravillosa con una descripci√≥n detallada.  Intente escribir su propia implementaci√≥n del m√©todo <code>processRequest</code> o vaya a la rama <code>spring-webflux-coroutines</code> : </p><br><div class="spoiler">  <b class="spoiler_title">implementaci√≥n desde la rama spring-webflux-coroutines</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response = coroutineScope { log.info(<span class="hljs-string"><span class="hljs-string">"start"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfoDeferred = async { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> authInfo = getAuthInfo(serviceRequest.authToken).awaitFirst() findUser(authInfo.userId).awaitFirst() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfoDeferred = async { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfoDeferred = async { findCardInfo(serviceRequest.cardFrom).awaitFirst() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardToInfoDeferred = async { findCardInfo(serviceRequest.cardTo).awaitFirst() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfo = cardFromInfoDeferred.await() sendMoney(cardFromInfo.cardId, cardToInfoDeferred.await().cardId, serviceRequest.amount).awaitFirst() getPaymentInfo(cardFromInfo.cardId).awaitFirst() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfo = userInfoDeferred.await() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfo = paymentInfoDeferred.await() log.info(<span class="hljs-string"><span class="hljs-string">"result"</span></span>) SuccessResponse( amount = paymentInfo.currentAmount, userName = userInfo.name, userSurname = userInfo.surname, userAge = userInfo.age ) }</code> </pre> </div></div><br><p>  Puede comparar el c√≥digo con el enfoque reactivo.  Con las rutinas, no tiene que pensar en todos los puntos de ramificaci√≥n por adelantado.  Podemos llamar a los m√©todos de <code>await</code> y ramificar las tareas asincr√≥nicas en <code>async</code> en los lugares correctos.  El c√≥digo sigue siendo lo m√°s similar posible a la versi√≥n sencilla original, que no es nada dif√≠cil de cambiar.  Y un factor importante es que las corutinas simplemente est√°n incrustadas en el c√≥digo reactivo. </p><br><p>  Puede que incluso le guste m√°s el enfoque reactivo para esta tarea, pero a muchas de las personas encuestadas les resulta m√°s dif√≠cil.  En general, ambos enfoques resuelven su problema y puede usar el que m√°s le guste.  Por cierto, recientemente en Kotlin tambi√©n existe la oportunidad de crear corutinas "fr√≠as" con Flow, que son muy similares a Reactor.  Es cierto que todav√≠a est√°n en la etapa experimental, pero ahora puede ver la implementaci√≥n actual y probarla en su c√≥digo. </p><br><p>  Quiero terminar aqu√≠ y finalmente dejar enlaces √∫tiles: </p><br><ul><li>  <a href="">Gu√≠a de rutina</a> </li><li>  <a href="">Reactor de Coroutines</a> </li><li>  <a href="https://github.com/Kotlin/kotlinx.coroutines/tree/master/integration/kotlinx-coroutines-jdk8">Corutinas CompletablesFuturo</a> </li><li>  <a href="https://www.youtube.com/results%3Fsearch_query%3D%25D0%25B5%25D0%25BB%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2580%25D0%25BE%25D0%25B2%2B%25D1%2580%25D0%25BE%25D0%25BC%25D0%25B0%25D0%25BD%2B%25D0%25BA%25D0%25BE%25D1%2580%25D1%2583%25D1%2582%25D0%25B8%25D0%25BD%25D1%258B">Roman Elizarov sobre las corutinas</a> </li><li>  <a href="https://medium.com/%40elizarov/kotlin-flows-and-coroutines-256260fb3bdb">Kotlin Flows and Coroutines</a> </li><li>  <a href="https://medium.com/%40elizarov/structured-concurrency-722d765aa952">Concurrencia estructurada</a> </li><li>  <a href="https://blog.karumi.com/spring-boot-loves-kotlin/">La bota de primavera ama a Kotlin</a> </li></ul><br><p>  Espero que haya estado interesado y haya logrado escribir una implementaci√≥n del m√©todo para todos los m√©todos usted mismo.  Y, por supuesto, quiero creer que te gusta la opci√≥n con corutinas m√°s =) </p><br><p>  ¬°Gracias a todos los que leyeron hasta el final! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/477052/">https://habr.com/ru/post/477052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../477042/index.html">Optimizaci√≥n de estrategia de blackjack de Monte Carlo</a></li>
<li><a href="../477044/index.html">Automatizaci√≥n de pruebas End-2-End de un sistema de informaci√≥n integrado. Parte 2. T√©cnica</a></li>
<li><a href="../477046/index.html">.Net Meetup en Raiffeisenbank 28/11 + Broadcast</a></li>
<li><a href="../477048/index.html">¬øPor qu√© una empresa con una capitalizaci√≥n de $ 55 mil millones pens√≥ en abandonar el intercambio?</a></li>
<li><a href="../477050/index.html">Black Friday 2019 para video vigilancia y nubes.</a></li>
<li><a href="../477054/index.html">Webasto anuncia sistema modular de bater√≠as automotrices</a></li>
<li><a href="../477058/index.html">Enterprise Agile Russia en Raiffeisenbank 26/11 + Broadcast</a></li>
<li><a href="../477060/index.html">DataArt organizar√° una conferencia abierta de Andrei Terekhov, Jefe del Departamento de Programaci√≥n del Sistema, Matmekh, Universidad Estatal de San Petersburgo</a></li>
<li><a href="../477062/index.html">C√≥mo funciona el compilador de optimizaci√≥n</a></li>
<li><a href="../477072/index.html">¬øDesarrollo de clientes o c√≥mo lanzar un producto sin fallas?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>