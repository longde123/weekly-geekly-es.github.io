<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛤️ 🚃 🚵 Scala + MXNet =产品中带有神经元的微服务 🤸🏽 💕 🤲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="互联网上有大量的手册和示例，亲爱的读者们，在这些手册和示例的基础上，您将能够“毫无困难”地，以“最少的”时间成本编写代码，以区分照片中的猫和狗。 那为什么还要在本文上浪费时间呢？ 

 我认为所有这些示例的主要缺点是可能性有限。 您举了一个例子-甚至使用了作者提供的基本神经网络-都启动了它，也许它甚...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Scala + MXNet =产品中带有神经元的微服务</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/439226/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/jw/cg/y4/jwcgy4upeqzycu6p2kxth9ok9iy.jpeg" width="500"></div><br> 互联网上有大量的手册和示例，亲爱的读者们，在这些手册和示例的基础上，您将能够“毫无困难”地，以“最少的”时间成本编写代码，以区分照片中的猫和狗。 那为什么还要在本文上浪费时间呢？ <br><br> 我认为所有这些示例的主要缺点是可能性有限。 您举了一个例子-甚至使用了作者提供的基本神经网络-都启动了它，也许它甚至起作用了，接下来该怎么办？ 如何使这个简单的代码开始在生产服务器上工作？ 如何更新和维护它？ 这就是乐趣的开始。 从“好吧，ML工程师训练了神经网络”到“最终我们将其推广到生产中”那一刻，我找不到该过程的完整描述。 我决定缩小这一差距。 <br><a name="habracut"></a><br> 我不会谈论如何教神经网络一些有趣的新事物，这些事物会取悦您并帮助您赚取一堆香脆的钞票。 这是单独撰写文章的重要话题。 例如，我将使用可以免费下载的神经网络。 我设定的主要任务是全面介绍将神经网络引入运营的过程。 <br><br> 我立即回答“为什么不使用Python？”这个问题：我们将Scala用于生产解决方案，因为它更加方便，稳定地编写了多线程代码。 <br><br><h1> 目录内容 </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.问题陈述</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.使用的技术</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.准备一个基本的Docker容器</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.项目结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">5.神经网络加载</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">6. REST API实施</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">7.测试</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">8.基于基本映像组装微服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">9.在带有GPU的生产服务器上启动微服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">结论</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">参考文献</a> <br><br><a name="1"></a><h1>  1.问题陈述 </h1><br> 假设我们有一个包含不同对象的大型照片数据库，我们需要制作一个微服务，该服务将以HTTP POST请求接收图片并以JSON格式响应。 答案应包含找到的对象及其类的数量，该对象恰好是所声明类的对象的概率以及覆盖每个对象边界的矩形的坐标。 <br><br><a name="2"></a><h1>  2.使用的技术 </h1><br><ul><li>  Scala 2.12.7 +最少的附加库集，带有Sbt-pack 0.12插件的Sbt 1.2.6，用于构建源代码。 </li><li>  MXNet 1.3.1（在撰写本文时为最新的稳定版本），针对Scala 2.12进行了编译。 </li><li> 装有Nvidia显卡的服务器。 </li><li> 服务器上安装了Cuda 9.0和Cudnn 7。 </li><li>  Java 8运行已编译的代码。 </li><li>  Docker简化了服务器上微服务的组装，交付和启动。 </li></ul><br><a name="3"></a><h1>  3.准备一个基本的Docker容器 </h1><br> 对于我们的微服务，您将需要一个基本的Docker映像，其中将安装运行所需的最小数量的依赖项。 对于组装，我们将使用带有附加安装的Sbt的映像。 是的，我们不会在本地环境中而是在Docker容器中构建源代码本身。 这将有助于通过CI（例如，通过gitlab CI）进一步过渡到程序集。 <br><br> 资料夹结构： <br><br><pre><code class="plaintext hljs">\ | ----- install | | ----- java8.sh | | ----- mxnet_2_12.sh | | ----- opencv.sh | | ----- sbt.sh | | ----- scala.sh | | ----- timeZone.sh | ----- scala-mxnet-cuda-cudnn | ----- Dockerfile.2.12-1.3.1-9-7-builder | ----- Dockerfile.2.12-1.3.1-9-7-runtime</code> </pre> <br><h4>  Dockerfile.2.12-1.3.1-9-7-运行时 </h4><br> 该图像将用于微服务的最终启动。 它基于Nvidia的官方映像，其中预装了CUDA 9.0和CUDNN7。MXNet1.3.1的文档声称可以与CUDA 8.0一起使用，但是，正如实践所示，一切都可以在9.0版上正常运行，甚至更快。 <br><br> 此外，我们将安装Java 8，MXNet 1.3.1（将在Scala 2.12下构建它），OpenCV 3.4.3和用于在此映像中设置时区的Linux实用程序。 <br><br><pre> <code class="plaintext hljs">#        Nvidia  cuda 9.0  cudnn 7 FROM nvidia/cuda:9.0-cudnn7-devel AS builder #    ENV MXNET_VERSION 1.3.1 ENV MXNET_BUILD_OPT "USE_OPENCV=1 USE_BLAS=openblas USE_CUDA=1 USE_CUDA_PATH=/usr/local/cuda USE_CUDNN=1" ENV CUDA_STUBS_DIR "/usr/local/cuda-9.0/targets/x86_64-linux/lib/stubs" ENV OPEN_CV_VERSION 3.4.3 ENV OPEN_CV_INSTALL_PREFIX /usr/local ENV JAVA_HOME /usr/lib/jvm/java-8-oracle/ ENV TIME_ZONE Europe/Moscow #     COPY install /install RUN chmod +x -R /install/* #   RUN apt-get update WORKDIR /install RUN ./timeZone.sh ${TIME_ZONE} RUN ./java8.sh RUN ./mxnet_2_12.sh ${MXNET_VERSION} "${MXNET_BUILD_OPT}" ${CUDA_STUBS_DIR} RUN ./opencv.sh ${OPEN_CV_VERSION} ${OPEN_CV_INSTALL_PREFIX} #     RUN apt-get autoclean -y &amp;&amp; \ rm -rf /var/cache/* /install #       FROM nvidia/cuda:9.0-cudnn7-devel COPY --from=builder --chown=root:root / /</code> </pre> <br> 脚本timeZone.sh java8.sh和opencv.sh非常琐碎，因此我将不对其进行详细介绍，它们在下面介绍。 <br><br><h4>  timeZone.sh </h4><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh #         TIME_ZONE=${1} #       apt-get install -y tzdata &amp;&amp; \ ln -sf /usr/share/zoneinfo/$TIME_ZONE /etc/localtime &amp;&amp; \ dpkg-reconfigure -f noninteractive tzdata</span></span></code> </pre> <br><h4>  java8.sh </h4><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh #  Java 8 apt-get install -y software-properties-common &amp;&amp; \ add-apt-repository ppa:webupd8team/java -y &amp;&amp; \ apt-get update &amp;&amp; \ echo "oracle-java8-installer shared/accepted-oracle-license-v1-1 select true" | debconf-set-selections &amp;&amp; \ apt-get install -y oracle-java8-installer</span></span></code> </pre> <br><h4>  opencv.sh </h4><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh #   OpenCV     OPEN_CV_VERSION=${1} #        OPEN_CV_INSTALL_PREFIX=${2} OPEN_CV_TAR="http://github.com/opencv/opencv/archive/${OPEN_CV_VERSION}.tar.gz" #  OpenCV apt-get install -y wget build-essential cmake &amp;&amp; \ wget -qO- ${OPEN_CV_TAR} | tar xzv -C /tmp &amp;&amp; \ mkdir /tmp/opencv-${OPEN_CV_VERSION}/build &amp;&amp; \ cd /tmp/opencv-${OPEN_CV_VERSION}/build &amp;&amp; \ cmake -DBUILD_JAVA=ON -DCMAKE_INSTALL_PREFIX:PATH=${OPEN_CV_INSTALL_PREFIX} .. &amp;&amp; \ make -j$((`nproc`+1)) &amp;&amp; \ make install &amp;&amp; \ rm -rf /tmp/opencv-${OPEN_CV_VERSION}</span></span></code> </pre> <br> 安装MXNet并非那么简单。 事实是，此Scala库的所有程序集都是在编译器版本2.11的基础上进行的，这是有道理的，因为该库包括一个用于Spark的模块，而该模块又由Scala 2.11编写。 考虑到我们在开发中使用Scala 2.12.7，因此编译后的库不适合我们，因此我们无法使用2.11版本。*由于新版本的Scala已经编写了大量代码，因此我们不能。 怎么办 从我们的Scala版本中获得从源代码收集MXNet的乐趣。 下面，我将给出一个脚本，用于为Scala 2.12构建和安装MXNet 1.3.1。*并对要点进行评论。 <br><br><h4>  mxnet_2_12.sh </h4><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh #   MXNet     MXNET_VERSION=${1} #     ++  MXNet     MXNET_BUILD_OPT=${2} #       CUDA     CUDA_STUBS_DIR=${3} LD_LIBRARY_PATH="${LD_LIBRARY_PATH}:${CUDA_STUBS_DIR}" #       MXNet   apt-get install -y git build-essential libopenblas-dev libopencv-dev maven cmake &amp;&amp; \ git clone -b ${MXNET_VERSION} --recursive https://github.com/dmlc/mxnet /tmp/mxnet &amp;&amp; \ cd /tmp/mxnet &amp;&amp; \ make -j $(nproc) ${MXNET_BUILD_OPT} &amp;&amp; \ ln -s ${CUDA_STUBS_DIR}/libcuda.so ${CUDA_STUBS_DIR}/libcuda.so.1 &amp;&amp; \ sed -rim 's/([a-zA-Z])_2.11/\1_2.12/g' $(find scala-package -name pom.xml) &amp;&amp; \ sed -im 's/SCALA_VERSION_PROFILE := scala-2.11/SCALA_VERSION_PROFILE := scala-2.12/g' Makefile &amp;&amp; \ sed -im 's/&lt;module&gt;spark&lt;\/module&gt;/&lt;\!--&lt;module&gt;spark&lt;\/module&gt;--&gt;/g' scala-package/pom.xml &amp;&amp; \ make scalapkg ${MXNET_BUILD_OPT} &amp;&amp; \ mkdir -p /usr/local/share/mxnet/scala/linux-x86_64-gpu &amp;&amp; \ mv /tmp/mxnet/scala-package/assembly/linux-x86_64-gpu/target/mxnet-full_2.12-linux-x86_64-gpu-${MXNET_VERSION}-SNAPSHOT.jar /usr/local/share/mxnet/scala/linux-x86_64-gpu/mxnet-full_2.12-linux-x86_64-gpu-${MXNET_VERSION}-SNAPSHOT.jar &amp;&amp; \ rm -rf /tmp/mxnet &amp;&amp; rm -rf /root/.m2</span></span></code> </pre> <br> 最有趣的部分从这一行开始： <br><br><pre> <code class="bash hljs">ln -s <span class="hljs-variable"><span class="hljs-variable">${CUDA_STUBS_DIR}</span></span>/libcuda.so <span class="hljs-variable"><span class="hljs-variable">${CUDA_STUBS_DIR}</span></span>/libcuda.so.1 &amp;&amp; \</code> </pre> <br> 如果按照说明运行MXNet程序集，我们将收到错误消息。 编译器找不到libcuda.so.1库，因此我们将从libcuda.so库链接到libcuda.so.1。 这可能不会打扰您，当您在生产服务器上启动它时，我们将用本地库替换该库。 还要注意，从<code>CUDA_STUBS_DIR</code>环境变量到CUDA库的路径已添加到<code>LD_LIBRARY_PATH</code> 。 如果不这样做，则组装也将失败。 <br><br> 在这些行中，我们使用实验性选择的正则表达式在所有必需的文件中用2.12替换了Scala 2.11的版本，这是因为它不足以简单地将2.11替换为2.12： <br><br><pre> <code class="bash hljs">sed -rim <span class="hljs-string"><span class="hljs-string">'s/([a-zA-Z])_2.11/\1_2.12/g'</span></span> $(find scala-package -name pom.xml) &amp;&amp; \ sed -im <span class="hljs-string"><span class="hljs-string">'s/SCALA_VERSION_PROFILE := scala-2.11/SCALA_VERSION_PROFILE := scala-2.12/g'</span></span> Makefile &amp;&amp; \ sed -im <span class="hljs-string"><span class="hljs-string">'s/&lt;module&gt;spark&lt;\/module&gt;/&lt;\!--&lt;module&gt;spark&lt;\/module&gt;--&gt;/g'</span></span> scala-package/pom.xml &amp;&amp; \ make scalapkg <span class="hljs-variable"><span class="hljs-variable">${MXNET_BUILD_OPT}</span></span> &amp;&amp; \</code> </pre> <br> 然后，说明对与Spark配合使用的模块的依赖性。 如果不这样做，库将不会被汇编。 <br><br> 接下来，按照说明中的说明运行程序集，将程序集库复制到共享文件夹中，并删除在构建过程中Maven抽出的所有垃圾（如果不这样做，最终映像将增加约3-4 GB，这可能会导致DevOps紧张）。 <br><br> 我们收集图像，该图像位于项目的根目录中（请参阅文件夹结构）： <br><br><pre> <code class="bash hljs">your@pc$ docker build -f Dockerfile.2.12-1.3.1-9-7-runtime -t entony/scala-mxnet-cuda-cudnn:2.12-1.3.1-9-7-runtime .</code> </pre> <br> 让我提醒您，以防万一末尾的点表示我们正在当前目录的上下文中进行汇编。 <br><br> 现在是时候讨论构建映像了。 <br><br><h4>  Dockerfile.2.12-1.3.1-9-7-builder </h4><br><pre> <code class="plaintext hljs">#         runtime-,    FROM entony/scala-mxnet-cuda-cudnn:2.12-1.3.1-9-7-runtime #    ENV SCALA_VERSION 2.12.7 ENV SBT_VERSION 1.2.6 #     COPY install /install RUN chmod +x -R /install/* #       RUN apt-get update &amp;&amp; \ cd /install &amp;&amp; \ ./scala.sh ${SCALA_VERSION} &amp;&amp; \ ./sbt.sh ${SBT_VERSION} #   RUN rm -rf /install</code> </pre> <br> 很简单，我们不需要Scala和Sbt来启动我们的微服务，因此将它们拖到启动的基本映像中没有任何意义。 因此，我们将创建一个单独的映像，该映像仅用于组装。  scala.sh和sbt.sh脚本非常简单，我将不对其进行详细介绍。 <br><br><h4>  scala.sh </h4><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh #   Scala     SCALA_VERSION=${1} SCALA_DEB="http://www.scala-lang.org/files/archive/scala-${SCALA_VERSION}.deb" #  Scala apt-get install -y wget &amp;&amp; \ wget -q ${SCALA_DEB} -O /tmp/scala.deb &amp;&amp; dpkg -i /tmp/scala.deb &amp;&amp; \ scala -version &amp;&amp; \ rm /tmp/scala.deb</span></span></code> </pre> <br><h4>  sbt.sh </h4><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh #   Sbt     SBT_VERSION=${1} SBT_DEB="http://dl.bintray.com/sbt/debian/sbt-${SBT_VERSION}.deb" #  Sbt apt-get install -y wget &amp;&amp; \ wget -q ${SBT_DEB} -O /tmp/sbt.deb &amp;&amp; dpkg -i /tmp/sbt.deb &amp;&amp; \ sbt sbtVersion &amp;&amp; \ rm /tmp/sbt.deb</span></span></code> </pre> <br> 我们收集图像，该图像位于项目的根目录中（请参阅文件夹结构）： <br><br><pre> <code class="bash hljs">your@pc$ docker build -f Dockerfile.2.12-1.3.1-9-7-builder -t entony/scala-mxnet-cuda-cudnn:2.12-1.3.1-9-7-builder .</code> </pre> <br> 在文章的结尾，有指向所有这些文件的存储库的链接。 <br><br><a name="4"></a><h1>  4.项目结构 </h1><br> 完成项目组装的准备工作后，让我们做您决定花些时间在本文上的事情。 <br><br> 我们的微服务项目将具有以下结构： <br><br><pre> <code class="plaintext hljs">\ | ----- dependencies | | ----- mxnet-full_2.12-linux-x86_64-gpu-1.3.1-SNAPSHOT.jar | ----- models | | ----- resnet50_ssd_model-0000.params | | ----- resnet50_ssd_model-symbol.json | | ----- synset.txt | ----- project | | ----- build.properties | | ----- plugins.sbt | ----- src | | ----- main | | | ----- resources | | | | ----- cat_and_dog.jpg | | | ----- scala | | | | ----- simple.predictor | | | | ----- Config | | | | ----- Model | | | | ----- Server | | | | ----- Run | | ----- test | | | ----- scala | | | | ----- simple.predictor | | | | ----- ServerTest | ----- build.sbt | ----- Dockerfile</code> </pre> <br> 这是标准的Scala项目结构，但依赖项和模型目录除外。 <br> 依赖关系目录包含Scala的MXNet库。 它可以通过两种方式获得： <br><br><ul><li> 在您要开发的机器上构建MXNet（请注意，该库不是跨平台的；如果您在Linux上构建它，那么它将无法在Mac OS上运行）， </li><li> 或将其从我们之前构建的Docker映像中拉出。 如果您决定在本地环境中构建MXNet，则mxnet_2.12.sh脚本将为您提供帮助。 </li></ul><br> 您可以像这样从Docker镜像中提取库： <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   your@pc$ mkdir dependencies #  Docker-    your@pc$ docker run -it --rm -v $(pwd)/dependencies:/tmp/dependencies entony/scala-mxnet-cuda-cudnn:2.12-1.3.1-9-7-runtime #          ab38e73d93@root$ cp /usr/local/share/mxnet/scala/linux-x86_64-gpu/mxnet-full_2.12-linux-x86_64-gpu-1.3.1-SNAPSHOT.jar /tmp/dependencies/mxnet-full_2.12-linux-x86_64-gpu-1.3.1-SNAPSHOT.jar ab38e73d93@root$ exit #  , ! your@pc$ ls dependencies/ mxnet-full_2.12-linux-x86_64-gpu-1.3.1-SNAPSHOT.jar</span></span></code> </pre> <br>  models目录包含受过训练的神经网络的文件，您可以按以下方式免费下载它们： <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   your@pc$ mkdir models #     your@pc$ wget https://s3.amazonaws.com/model-server/models/resnet50_ssd/resnet50_ssd_model-symbol.json -P models your@pc$ wget https://s3.amazonaws.com/model-server/models/resnet50_ssd/resnet50_ssd_model-0000.params -P models your@pc$ wget https://s3.amazonaws.com/model-server/models/resnet50_ssd/synset.txt -P models</span></span></code> </pre> <br> 进一步简要介绍不特别感兴趣但在项目中起作用的文件。 <br><br><h4> 项目/ build.properties </h4><br><pre> <code class="scala hljs">#   <span class="hljs-type"><span class="hljs-type">Sbt</span></span>,   sbt.version = <span class="hljs-number"><span class="hljs-number">1.2</span></span><span class="hljs-number"><span class="hljs-number">.6</span></span></code> </pre> <br><h4> 项目/ plugins.sbt </h4><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//    sbt-pack addSbtPlugin("org.xerial.sbt" % "sbt-pack" % "0.12")</span></span></code> </pre> <br><h4>  src /主/资源/ cat_and_dog.jpg </h4><br> 如此美妙的图画，其中我们的神经网络将寻找猫和狗。 <br><img src="https://habrastorage.org/getpro/habr/post_images/b6b/8ed/425/b6b8ed425ab6affb5cce1e83731b35a9.png"><br><br><h4>  build.sbt </h4><br><pre> <code class="scala hljs">enablePlugins(<span class="hljs-type"><span class="hljs-type">PackPlugin</span></span>) name := <span class="hljs-string"><span class="hljs-string">"simple-predictor"</span></span> version := <span class="hljs-string"><span class="hljs-string">"0.1"</span></span> scalaVersion := <span class="hljs-string"><span class="hljs-string">"2.12.7"</span></span> unmanagedBase := baseDirectory.value / <span class="hljs-string"><span class="hljs-string">"dependencies"</span></span> <span class="hljs-comment"><span class="hljs-comment">//  (   ) libraryDependencies ++= Seq( "org.json4s" %% "json4s-native" % "3.6.1", "org.scalatest" %% "scalatest" % "3.0.5" % Test, "org.scalaj" %% "scalaj-http" % "2.4.1" % Test ) //       packMain := Map("simple-predictor" -&gt; "simple.predictor.Runs") //    bat-,      ,   Linux packGenerateWindowsBatFile := false //    JVM packJvmOpts := Map("simple-predictor" -&gt; Seq( "-Xms3g", "-Xmx5g"))</span></span></code> </pre> <br><h4>  simple.predictor.Config </h4><br> 此对象存储全局变量，其值是从环境变量中读取的或默认设置的。 <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> simple.predictor <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.mxnet.<span class="hljs-type"><span class="hljs-type">Context</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.util.<span class="hljs-type"><span class="hljs-type">Try</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    REST API val host: String = env("REST_HOST") getOrElse "0.0.0.0" //    REST API val port: Int = env("REST_PORT") flatMap (p =&gt; Try(p.toInt).toOption) getOrElse 8080 // URL,     POST-   val entryPoint: String = env("REST_ENTRY_POINT") getOrElse "/predict" //  ,       val threshold: Float = env("PROBABILITY_MORE") flatMap (p =&gt; Try(p.toFloat).toOption) getOrElse 0.5f //        val modelPrefix: String = env("MODEL_PREFIX") getOrElse "models/resnet50_ssd_model" //    (    ...-0000.params) val modemEpoch: Int = env("MODEL_EPOCH") flatMap (p =&gt; Try(p.toInt).toOption) getOrElse 0 //   ,     ,    512 val modemEdge: Int = env("MODEL_EDGE") flatMap (p =&gt; Try(p.toInt).toOption) getOrElse 512 //  ,   CPU ( ).  production  GPU val context: Context = env("MODEL_CONTEXT_GPU") flatMap { isGpu =&gt; Try(if (isGpu.toBoolean) Context.gpu() else Context.cpu()).toOption } getOrElse Context.cpu() private def env(name: String) = Option(System.getenv(name)) }</span></span></code> </pre> <br><h4>  simple.predictor.Run </h4><br> 运行对象是应用程序的入口点。 <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> simple.predictor <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.<span class="hljs-type"><span class="hljs-type">InetSocketAddress</span></span> <span class="hljs-comment"><span class="hljs-comment">//     import simple.predictor.Config._ object Run extends App { //     REST- val model = new Model(modelPrefix, modemEpoch, modemEdge, threshold, context) val server = new Server(new InetSocketAddress(host, port), entryPoint, model) //   Ctrl + C    Runtime.getRuntime.addShutdownHook(new Thread(() =&gt; server.stop())) //      try server.start() catch { case ex: Exception =&gt; ex.printStackTrace() } }</span></span></code> </pre> <br><a name="5"></a><h1>  5.神经网络加载 </h1><br> 神经网络被加载到<code>simple.predictor.Model</code>类的构造函数中。 <br><br><h4>  simple.predictor.Model </h4><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> simple.predictor <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.awt.image.<span class="hljs-type"><span class="hljs-type">BufferedImage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.mxnet._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.mxnet.infer.<span class="hljs-type"><span class="hljs-type">ObjectDetector</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> simple.predictor.<span class="hljs-type"><span class="hljs-type">Model</span></span>.<span class="hljs-type"><span class="hljs-type">Prediction</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">prefix: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, epoch: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, imageEdge: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, threshold: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-class"><span class="hljs-params">, context: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Context</span></span></span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       val initShape = Shape(1, 3, imageEdge, imageEdge) val initData = DataDesc(name = "data", initShape, DType.Float32, Layout.NCHW) //           val model = new ObjectDetector(prefix, IndexedSeq(initData), context, Option(epoch)) //         ,       JSON private def toPrediction(originWidth: Int, originHeight: Int)(predict: (String, Array[Float])): Prediction = { val (objectClass, Array(probability, kx, ky, kw, kh)) = predict //        val x = (originWidth * kx).toInt val y = (originHeight * ky).toInt val w = (originWidth * kw).toInt val h = (originHeight * kh).toInt val width = if ((x + w) &lt; originWidth) w else originWidth - x val height = if (y + h &lt; originHeight) h else originHeight - y Prediction(objectClass, probability, x, y, width, height) } //     ,         ,     threshold def predict(image: BufferedImage): Seq[Prediction] = model.imageObjectDetect(image).head map toPrediction(image.getWidth, image.getHeight) filter (_.probability &gt; threshold) } object Model { //   case class Prediction(objectClass: String, probability: Float, x: Int, y: Int, width: Int, height: Int) }</span></span></code> </pre> <br> 在<code>     </code>部分中<code>     </code>您说在神经网络中它将与尺寸为1 x 3 x 512 x 512的<code>NDArray</code>一起使用，其中1是NDArray中包含的图像数，3是颜色数，而512 x 512 -图像大小（在<code>simple.predict.Config</code>对象中设置了<code>imageEdge = 12</code>的值，这是用于训练神经网络的图像的侧面大小）。 所有这些数据描述都传递给<code>ObjectDetector</code> 。 <br><br> 另一个有趣的部分是<code>      </code> 。 <br><br> 通过神经网络运行图像后，结果为<code>Seq[Seq[(String, Array[Float])]]</code> 。 第一个集合仅包含一个结果（数据格式由特定的神经网络确定），然后下一个集合的每个元素都是两个元素的元组： <br><br><ol><li> 类别名称（“猫”，“狗”，...）， </li><li> 一个由五个浮点数组成的数组：第一个是概率，第二个是用于计算<code>x</code>坐标的系数，第三个是用于计算<code>y</code>坐标的系数，第四个是用于计算矩形宽度的系数，第五个是用于计算矩形高度的系数。 </li></ol><br> 要获得矩形坐标和尺寸的实际值，您需要将图像的原始宽度和高度乘以相应的系数。 <br> 我对<code>NDArray</code>的话题<code>NDArray</code> 。 这是MXNet在给定上下文（CPU或GPU）中创建的多维数组。 创建NDArray时，会形成一个C ++对象，该对象可以非常快速地执行操作（如果在GPU上下文中创建，则几乎是瞬时的），但是您必须为此付出代价。 结果（至少在MXNet 1.3.1版本中），您需要独立管理为<code>NDArray</code>分配的内存，并且不要忘记在使用完这些对象后从内存中卸载这些对象。 否则，将会有相当大且相当快的内存泄漏，这非常不便于监视，因为用于JVM性能分析的程序看不到它。 如果您在GPU上下文中工作，则内存问题会更加严重，因为视频卡没有大量内存，并且应用程序很快崩溃而导致内存不足。 <br><br> 如何解决内存泄漏问题？ <br><br> 在上面的示例中，在将<code>model.imageObjectDetect(image).head map toPrediction(image.getWidth, image.getHeight) filter (_.probability &gt; threshold)</code> ， <code>imageObjectDetect</code>方法用于通过神经网络运行图像，该神经网络接收<code>BufferedImage</code>输入。  <code>NDArray</code>所有<code>NDArray</code>转换均在方法内部完成，您无需考虑内存释放问题。 另一方面，在将<code>BufferedImage</code>转换为<code>NDArray</code>之前， <code>NDArray</code> 512 x 512的大小进行<code>NDArray</code> ，并使用<code>BufferedImage</code>类型的对象的方法对图像进行规范化。 例如，这种情况比使用OpenCV发生的时间更长，但是它解决了在使用<code>NDArray</code>之后释放内存的问题。 <br><br> 当然，您可以使用OpenCV并自己控制内存，为此，您只需要调用<code>dispose</code>的<code>NDArray</code>方法<code>dispose</code> ，但是由于某种原因，您忘记了在Scala的官方MXNet文档中提及此问题。 <br><br>  MXNet还有一种不太方便的方法来控制由于<code>NDArray</code>发生的内存泄漏。 为此，请使用JVM参数<code>Dmxnet.traceLeakedObjects=true</code>运行应用程序。 如果MXNet注意到一个未使用但挂在内存中的<code>NDArray</code> ，您将得到一个异常，指示命运多的<code>NDArray</code>哪一行代码<code>NDArray</code> 。 <br><br> 我的建议是：直接与NDArray一起使用，仔细监视内存并自行编写规范化，并且事先指定了ML工程师在训练神经网络时采用的算法，否则结果将完全不同。  <code>ObjectDetector</code>有一个<code>objectDetectWithNDArray</code>方法，您可以将<code>NDArray</code>传递给该方法。 为了实现更通用的加载神经网络的方法，我建议使用<code>org.apache.mxnet.module.Module</code>对象。 以下是使用示例。 <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.mxnet._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.mxnet.io.<span class="hljs-type"><span class="hljs-type">NDArrayIter</span></span> <span class="hljs-comment"><span class="hljs-comment">//      val model: Module = { val model = Module.loadCheckpoint(modelPrefix, modelEpoch, contexts = contexts) model.bind( forTraining = false, inputsNeedGrad = false, forceRebind = false, dataShape = DataDesc(name = "data", Shape(1, 3, 512, 512), DType.Float32, Layout.NCHW)) model.initParams() model } // NDArray  1  3  512  512 val image: NDArray = ??? //  dataBatch      val iterator = new NDArrayIter(IndexedSeq(image)) val dataBatch = iterator.next() image.dispose() //   val result: Seq[Array[Float]] = model.predict(dataBatch) map { ndArray =&gt; val array = ndArray.toArray ndArray.dispose() array } dataBatch.dispose()</span></span></code> </pre> <br><a name="6"></a><h1>  6. REST API实施 </h1><br>  <code>simple.predictor.Server</code>类负责实现REST API。 该服务器基于Java中包含的Java服务器。 <br><br><h4>  simple.predictor.Server </h4><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> simple.predictor <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.<span class="hljs-type"><span class="hljs-type">InetSocketAddress</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.sun.net.httpserver.{<span class="hljs-type"><span class="hljs-type">HttpExchange</span></span>, <span class="hljs-type"><span class="hljs-type">HttpServer</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.imageio.<span class="hljs-type"><span class="hljs-type">ImageIO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.json4s.<span class="hljs-type"><span class="hljs-type">DefaultFormats</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.json4s.native.<span class="hljs-type"><span class="hljs-type">Serialization</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Server</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">address: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">InetSocketAddress</span></span></span></span><span class="hljs-class"><span class="hljs-params">, entryPoint: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, model: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Model</span></span></span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   HTTP-,     java private val server = HttpServer.create(address, 0) //      URL server.createContext(entryPoint, (http: HttpExchange) =&gt; { //   HTTP-     val header = http.getRequestHeaders val (httpCode, json) = if (header.containsKey("Content-Type") &amp;&amp; header.getFirst("Content-Type") == "image/jpeg") { //          ,      200 val image = ImageIO.read(http.getRequestBody) val predictionSeq = model.predict(image) (200, Map("prediction" -&gt; predictionSeq)) } else (400, Map("error" -&gt; "Invalid content")) //       400 //    JSON    val responseJson = Serialization.write(json)(DefaultFormats) val httpOs = http.getResponseBody http.getResponseHeaders.set("Content-Type", "application/json") http.sendResponseHeaders(httpCode, responseJson.length) httpOs.write(responseJson.getBytes) httpOs.close() }) def start(): Unit = server.start() def stop(): Unit = server.stop(0) }</span></span></code> </pre> <br><a name="7"></a><h1>  7.测试 </h1><br> 要进行检查，请启动服务器并发送测试图片src / main / resources / cat_and_dog.jpg。 我们将解析从服务器接收到的JSON，检查神经网络在图片中找到了多少个对象，并在图片中圈出了对象。 <br><br><h4>  simple.predictor.ServerTest </h4><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> simple.predictor <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.awt.{<span class="hljs-type"><span class="hljs-type">BasicStroke</span></span>, <span class="hljs-type"><span class="hljs-type">Color</span></span>, <span class="hljs-type"><span class="hljs-type">Font</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.awt.image.<span class="hljs-type"><span class="hljs-type">BufferedImage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.{<span class="hljs-type"><span class="hljs-type">ByteArrayOutputStream</span></span>, <span class="hljs-type"><span class="hljs-type">File</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.<span class="hljs-type"><span class="hljs-type">InetSocketAddress</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.imageio.<span class="hljs-type"><span class="hljs-type">ImageIO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.scalatest.{<span class="hljs-type"><span class="hljs-type">FlatSpec</span></span>, <span class="hljs-type"><span class="hljs-type">Matchers</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scalaj.http.<span class="hljs-type"><span class="hljs-type">Http</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.json4s.{<span class="hljs-type"><span class="hljs-type">DefaultFormats</span></span>, <span class="hljs-type"><span class="hljs-type">Formats</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.json4s.native.<span class="hljs-type"><span class="hljs-type">JsonMethods</span></span>.parse <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> simple.predictor.<span class="hljs-type"><span class="hljs-type">Config</span></span>._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> simple.predictor.<span class="hljs-type"><span class="hljs-type">Model</span></span>.<span class="hljs-type"><span class="hljs-type">Prediction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.concurrent.<span class="hljs-type"><span class="hljs-type">Future</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.concurrent.<span class="hljs-type"><span class="hljs-type">ExecutionContext</span></span>.<span class="hljs-type"><span class="hljs-type">Implicits</span></span>.global <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServerTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FlatSpec</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Matchers</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> formats: <span class="hljs-type"><span class="hljs-type">Formats</span></span> = <span class="hljs-type"><span class="hljs-type">DefaultFormats</span></span> <span class="hljs-string"><span class="hljs-string">"Service"</span></span> should <span class="hljs-string"><span class="hljs-string">"find a cat and a dog on photo"</span></span> in { <span class="hljs-comment"><span class="hljs-comment">//      val model = new Model(modelPrefix, modemEpoch, modemEdge, threshold, context) val server = new Server(new InetSocketAddress(host, port), entryPoint, model) //      Future(server.start()) Thread.sleep(5000) //         val image = ImageIO.read(getClass.getResourceAsStream("/cat_and_dog.jpg")) val byteOS = new ByteArrayOutputStream() ImageIO.write(image, "jpg", byteOS) val data = byteOS.toByteArray //      ,     200 val response = Http(s"http://$host:$port$entryPoint").header("Content-Type", "image/jpeg").postData(data).asString response.code shouldEqual 200 //  JSON-, ,       val prediction = parse(response.body) \\ "prediction" prediction.children.size shouldEqual 2 //     , ,     ,    val objectClassList = (prediction \\ "objectClass").children map (_.extract[String]) objectClassList.head shouldEqual "cat" objectClassList.tail.head shouldEqual "dog" //   ,   val bBoxCoordinates = prediction.children.map(_.extract[Prediction]) //   ,     val imageWithBoundaryBoxes = new BufferedImage(image.getWidth, image.getHeight, image.getType) val graph = imageWithBoundaryBoxes.createGraphics() graph.drawImage(image, 0, 0, null) graph.setColor(Color.RED) graph.setStroke(new BasicStroke(5)) graph.setFont(new Font(Font.SANS_SERIF, Font.TRUETYPE_FONT, 30)) bBoxCoordinates foreach { case Prediction(obj, prob, x, y, width, height) =&gt; graph.drawRect(x, y, width, height) graph.drawString(s"$obj, prob: $prob", x + 15, y + 30) } graph.dispose() //         ImageIO.write(imageWithBoundaryBoxes, "jpg", new File("./test.jpg")) } }</span></span></code> </pre> <br>     ,       . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea2/454/57d/ea245457d175d072a8eb8c98ef4551ce.png"><br><br><a name="8"></a><h1> 8.       </h1><br>  ,      .     Docker   ,    . <br><br><h4> Dockerfile </h4><br><pre> <code class="plaintext hljs">#       Sbt FROM entony/scala-mxnet-cuda-cudnn:2.12-1.3.1-9-7-builder AS builder #       RUN mkdir /tmp/source /tmp/source/dependencies COPY project /tmp/source/project COPY src /tmp/source/src COPY build.sbt /tmp/source/build.sbt #     MXNet,       RUN ln -s /usr/local/share/mxnet/scala/linux-x86_64-gpu/mxnet-full_2.12-linux-x86_64-gpu-1.3.1-SNAPSHOT.jar /tmp/source/dependencies/mxnet-full_2.12-linux-x86_64-gpu-1.3.1-SNAPSHOT.jar &amp;&amp; \ cd /tmp/source/ &amp;&amp; sbt pack #      FROM entony/scala-mxnet-cuda-cudnn:2.12-1.3.1-9-7-runtime #   LD   Cuda   Java ENV LD_LIBRARY_PATH /usr/local/cuda-9.0/targets/x86_64-linux/lib/stubs:/usr/local/share/OpenCV/java #            /opt/app/models ENV MODEL_PREFIX "/opt/app/models/resnet50_ssd_model" #            RUN mkdir -p /opt/app COPY --from=builder --chown=root:root /tmp/source/target/pack /opt/app COPY models /opt/app/models #      ENTRYPOINT /opt/app/bin/simple-predictor</code> </pre> <br>         <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ,    ,   Dockerfile your@pc$ docker build -f Dockerfile -t entony/simple-predictor:1.0.0 . #   docker hub your@pc$ docker push entony/simple-predictor:1.0.0</span></span></code> </pre> <br><a name="9"></a><h1> 9.    production-  GPU </h1><br> ,      docker hub,      Nvidia,  8080    Docker, Cuda 9.0  Cudnn 7. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#     Docker hub your@server-with-gpu$ docker pull entony/simple-predictor:1.0.0 #     your@server-with-gpu$ docker run -d \ -p 8080:8080 \ -e MODEL_CONTEXT_GPU=true \ -e MXNET_CUDNN_AUTOTUNE_DEFAULT=0 \ --name 'simple_predictor' \ --device /dev/nvidia0:/dev/nvidia0 \ --device /dev/nvidiactl:/dev/nvidiactl \ --device /dev/nvidia-uvm:/dev/nvidia-uvm \ -v /usr/lib/x86_64-linux-gnu/libcuda.so.1:/usr/local/cuda-9.0/targets/x86_64-linux/lib/stubs/libcuda.so.1:ro \ -v /usr/lib/nvidia-396/libnvidia-fatbinaryloader.so.396.54:/usr/local/cuda-9.0/targets/x86_64-linux/lib/stubs/libnvidia-fatbinaryloader.so.396.54:ro \ entony/simple-predictor:1.0.0</span></span></code> </pre> <br>         Docker-   <code>--device</code>   Cuda-   <code>-v</code> . <br><br>   <code>MODEL_CONTEXT_GPU</code>     GPU-,  <code>MXNET_CUDNN_AUTOTUNE_DEFAULT</code>          (  ,      ,     ,  ). <br><br>      : <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  your@server-with-gpu$ curl -X POST -H 'Content-Type: image/jpeg' --data-binary '@src/main/resources/cat_and_dog.jpg' http://0.0.0.0:8080/predict #  { "prediction":[ { "objectClass":"cat", "probability":0.9959417, "x":72,"y":439, "width":950, "height":987 }, { "objectClass":"dog", "probability":0.81277525, "x":966, "y":100, "width":870, "height":1326 } ] }</span></span></code> </pre> <br><a name="10"></a><h1> 结论 </h1><br> MXNet   ,    -    .  ,    ,   ,     production. <br><br>   , ,   MXNet    ,      Python      production  Scala, Java  ++. <br><br>        ,                   . <br><br> ,        .          . 谢谢您的关注。 <br><br><a name="11"></a><h1> 参考文献 </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Git   Docker-</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Git    </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">     MXNet</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN439226/">https://habr.com/ru/post/zh-CN439226/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN439216/index.html">在golang上pudge 500行可嵌入数据库</a></li>
<li><a href="../zh-CN439218/index.html">VK机器人跪在地上，或如何在2月14日取悦人们</a></li>
<li><a href="../zh-CN439220/index.html">Unity上移动设备的大城市。 开发和优化经验</a></li>
<li><a href="../zh-CN439222/index.html">什么是API管理？</a></li>
<li><a href="../zh-CN439224/index.html">关于Voronoi图</a></li>
<li><a href="../zh-CN439232/index.html">JAMstack：如何使用Gatsby + Contentful + Netlify创建自己的博客</a></li>
<li><a href="../zh-CN439234/index.html">开源开发人员在GIF中的生活</a></li>
<li><a href="../zh-CN439236/index.html">xenvman：灵活的微服务测试环境（以及更多）</a></li>
<li><a href="../zh-CN439238/index.html">Play商店现在接受渐进式Web应用程序（PWA）</a></li>
<li><a href="../zh-CN439240/index.html">2019年1月的Joomla摘要</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>