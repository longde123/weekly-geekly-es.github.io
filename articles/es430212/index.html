<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§± üö† üë©üèº‚Äçüíª OpenSceneGraph: conceptos b√°sicos de la geometr√≠a de la escena ü¶Ü üßëüèæ‚Äçü§ù‚Äçüßëüèª üõ†Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 
 OpenGL, que es el backend para OpenSceneGraph, utiliza primitivas geom√©tricas (como puntos, l√≠neas, tri√°ngulos y caras poligonales) par...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: conceptos b√°sicos de la geometr√≠a de la escena</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430212/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="imagen"><br><br><h1>  Introduccion </h1><br>  OpenGL, que es el backend para OpenSceneGraph, utiliza primitivas geom√©tricas (como puntos, l√≠neas, tri√°ngulos y caras poligonales) para construir todos los objetos en el mundo tridimensional. <br><br>  Estas primitivas est√°n definidas por datos sobre sus v√©rtices, que incluyen las coordenadas de los v√©rtices, componentes normales, datos de color y coordenadas de textura.  Estos datos se almacenan en matrices especiales.  Las primitivas se pueden formar, por ejemplo, especificando para los objetos que los describen una lista de √≠ndices de v√©rtices.  Este m√©todo se llama m√©todo de matriz de v√©rtices, elimina el almacenamiento de v√©rtices redundantes en la memoria y tiene un buen rendimiento. <br><br>  Adem√°s, OpenGL puede usar el mecanismo de las llamadas <i>listas de visualizaci√≥n</i> , cuando las primitivas preparadas en la memoria de video pueden reutilizarse, lo que acelera significativamente la visualizaci√≥n de objetos est√°ticos. <br><br>  De forma predeterminada, OSG utiliza el m√©todo de matriz de v√©rtices y el m√©todo de lista de visualizaci√≥n para representar la geometr√≠a.  Sin embargo, la estrategia de representaci√≥n puede cambiar, dependiendo de c√≥mo se presenten los datos de geometr√≠a.  En este art√≠culo, cubriremos las t√©cnicas b√°sicas para trabajar con geometr√≠a en OSG. <br><a name="habracut"></a><br><h1>  1. Clases Geode y Drawable </h1><br>  La clase osg :: Geode es un terminal, el llamado nodo "hoja" del √°rbol de escenas.  No puede tener nodos secundarios, pero contiene toda la informaci√≥n necesaria para representar la geometr√≠a.  Su nombre, Geode, es la abreviatura de nodo de geometr√≠a. <br><br>  Los datos geom√©tricos que procesar√° el motor se almacenan en el conjunto de objetos de la clase osg :: Drawable, administrada por la clase osg :: Geode.  La clase osg :: Drawable es una clase puramente virtual.  Se heredan una serie de subclases, que son modelos tridimensionales, im√°genes y texto procesados ‚Äã‚Äãpor la canalizaci√≥n de OpenGL.  OSG se refiere a dibujable como todos los elementos que puede dibujar el motor. <br><br>  La clase osg :: Geode proporciona varios m√©todos para unir y separar elementos dibujables: <br><br><ul><li>  M√©todo p√∫blico addDrawable (): pasa un puntero a un elemento dibujable en una instancia de la clase osg :: Geode.  Todos estos elementos est√°n controlados por osg :: ref_ptr &lt;&gt; punteros inteligentes. <br></li><li>  El m√©todo p√∫blico removeDrawable () y removeDrawables () elimina el objeto de osg :: Geode y disminuye el recuento de referencias para √©l.  El m√©todo removeDrawable () toma como par√°metro √∫nico un puntero a un elemento de inter√©s, y el m√©todo removeDrawables () toma dos par√°metros: el √≠ndice inicial y el n√∫mero de elementos que se eliminar√°n de la matriz de objetos osg :: Geode. <br></li><li>  El m√©todo getDrawable () devuelve un puntero a un elemento en el √≠ndice pasado como par√°metro. <br></li><li>  El m√©todo getNumDrawables () devuelve el n√∫mero total de elementos adjuntos a osg :: Geode.  Por ejemplo, para eliminar todos los elementos de osg :: Geode, puede usar dicho c√≥digo <br></li></ul><br><pre><code class="cpp hljs">geode-&gt;removeDrawables(<span class="hljs-number"><span class="hljs-number">0</span></span>, geode-&gt;getNumDrawables());</code> </pre> <br><h1>  2. Dibujando formas simples </h1><br>  OSG proporciona la clase osg :: ShapeDrawable, que es descendiente de la clase osg :: Drawable y est√° dise√±ada para crear primitivas tridimensionales simples.  Esta clase incluye un objeto osg :: Shape que almacena informaci√≥n sobre geometr√≠a espec√≠fica y otros par√°metros.  Las primitivas se generan utilizando el m√©todo setShape (), por ejemplo <br><br><pre> <code class="cpp hljs">shapeDrawable-&gt;setShape(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Box(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), <span class="hljs-number"><span class="hljs-number">10.0f</span></span>, <span class="hljs-number"><span class="hljs-number">10.0f</span></span>, <span class="hljs-number"><span class="hljs-number">5.0f</span></span>));</code> </pre><br>  crea una caja rectangular con un centro geom√©trico en el punto (1.0, 0.0, 0.0) con un ancho y una altura de 10 y una profundidad de 5 unidades.  La clase osg :: Vec3 define un vector en el espacio tridimensional (adem√°s, tambi√©n se presentan las clases osg :: Vec2 y osg :: Vec4 que describen vectores de la dimensi√≥n correspondiente). <br><br>  Las primitivas m√°s populares est√°n representadas en OSG por las clases osg :: Box, osg :: Capsule, osg :: Cone, osg :: Cylinder y osg :: Sphere. <br><br>  Considere un ejemplo de la aplicaci√≥n de este mecanismo. <br><br>  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/ShapeDrawable&gt; #include &lt;osg/Geode&gt; #include &lt;osgViewer/Viewer&gt; #endif // MAIN_H</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::ShapeDrawable&gt; shape1 = new osg::ShapeDrawable; shape1-&gt;setShape(new osg::Box(osg::Vec3(-3.0f, 0.0f, 0.0f), 2.0f, 2.0f, 1.0f)); osg::ref_ptr&lt;osg::ShapeDrawable&gt; shape2 = new osg::ShapeDrawable; shape2-&gt;setShape(new osg::Cone(osg::Vec3(0.0f, 0.0f, 0.0f), 1.0f, 1.0f)); shape2-&gt;setColor(osg::Vec4(0.0f, 1.0f, 0.0f, 1.0f)); osg::ref_ptr&lt;osg::ShapeDrawable&gt; shape3 = new osg::ShapeDrawable; shape3-&gt;setShape(new osg::Sphere(osg::Vec3(3.0f, 0.0f, 0.0f), 1.0f)); shape3-&gt;setColor(osg::Vec4(0.0f, 0.0f, 1.0f, 1.0f)); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(shape1.get()); root-&gt;addDrawable(shape2.get()); root-&gt;addDrawable(shape3.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br>  Este ejemplo especialmente no necesita comentarios: en el programa se crean tres formas simples, despu√©s de la compilaci√≥n y el lanzamiento veremos tal resultado <br><br><img src="https://habrastorage.org/webt/mu/kl/cq/muklcqrapar1quikfyshzkang-4.png"><br><br>  El mecanismo que se muestra en el ejemplo es simple y directo, pero no es la forma m√°s efectiva de crear geometr√≠a y puede usarse exclusivamente para pruebas.  La clase osg :: Geometry se usa para crear geometr√≠a en aplicaciones basadas en OSG de alto rendimiento. <br><br><h1>  3. Almacenamiento de datos de geometr√≠a: clases osg :: Array y osg :: Geometry </h1><br>  La clase osg :: Array es una clase abstracta b√°sica, de la que se heredan varios descendientes, dise√±ada para almacenar datos que se pasan a las funciones de OpenGL.  Trabajar con esta clase es similar a trabajar con std :: vector de la biblioteca est√°ndar de C ++.  El siguiente c√≥digo ilustra la adici√≥n de un vector a una matriz de v√©rtices utilizando el m√©todo push_back () <br><br><pre> <code class="cpp hljs">vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>));</code> </pre><br>  Las matrices OSG se asignan en el mont√≥n y se gestionan mediante punteros inteligentes.  Sin embargo, esto no se aplica a los elementos de la matriz, como osg :: Vec3 u osg :: Vec2, que tambi√©n se pueden crear en la pila. <br><br>  La clase osg :: Geometry es un contenedor sobre las funciones de OpenGL que funcionan con matrices de v√©rtices.  Se deriva de la clase osg :: Drawable y se puede agregar f√°cilmente a la lista de objetos osg :: Geode.  Esta clase toma las matrices descritas anteriormente como entrada y las usa para generar geometr√≠a usando OpenGL. <br><br><h1>  4. V√©rtices y sus atributos. </h1><br>  Un v√©rtice es una unidad at√≥mica de primitivas de geometr√≠a.  Tiene una serie de atributos que describen un punto en un espacio de dos o tres dimensiones.  Los atributos incluyen: posici√≥n, color, vector normal, coordenadas de textura, coordenadas de niebla, etc.  La parte superior siempre debe tener una posici√≥n en el espacio, ya que para otros atributos, pueden estar presentes opcionalmente.  OpenGL admite 16 atributos de v√©rtice b√°sicos y puede usar diferentes matrices para almacenarlos.  Todas las matrices de atributos son compatibles con la clase osg :: Geometry y se pueden establecer utilizando los m√©todos del conjunto de formularios * Array (). <br><br>  <b>Atributos de v√©rtices en OpenSceneGraph</b> <br><table><tbody><tr><th>  Atributo </th><th>  Tipo de datos </th><th>  Osg :: M√©todo de Geometr√≠a </th><th>  Llamada equivalente a OpenGL </th></tr><tr><td>  Posici√≥n </td><td>  3 vectores </td><td>  setVertexArray () </td><td>  glVertexPointer () </td></tr><tr><td>  Normal </td><td>  3 vectores </td><td>  setNormalArray () </td><td>  glNormalPointer () </td></tr><tr><td>  Color </td><td>  4-vector </td><td>  setColorArray () </td><td>  glColorPointer () </td></tr><tr><td>  Color secundario </td><td>  4-vector </td><td>  setSecondaryColorArray () </td><td>  glSecondaryColorPointerEXT () </td></tr><tr><td>  Coordenadas de niebla </td><td>  flotar </td><td>  setFogCoordArray () </td><td>  glFogCoordPointerEXT () </td></tr><tr><td>  Coordenadas de textura </td><td>  2 o 3 vectores </td><td>  setTexCoordArray () </td><td>  glTexCoordPointer () </td></tr><tr><td>  Otros atributos </td><td>  Definido por el usuario </td><td>  setVertexArribArray () </td><td>  glVertexAttribPointerARB () </td></tr></tbody></table><br>  En principio, es necesario establecer sus propios atributos para cada uno de los v√©rtices, lo que conduce a la formaci√≥n de varias matrices de atributos del mismo tama√±o; de lo contrario, una falta de coincidencia en los tama√±os de las matrices puede conducir a un comportamiento indefinido del motor.  OSG admite varios m√©todos para vincular atributos de v√©rtices, por ejemplo <br><br><pre> <code class="cpp hljs">geom-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX);</code> </pre><br>  significa que cada v√©rtice y cada color del v√©rtice est√°n correlacionados uno a uno entre s√≠.  Sin embargo, si nos fijamos en dicho c√≥digo <br><br><pre> <code class="cpp hljs">geom-&gt;setColorBinding(osg::Geometry::BIND_OVERALL);</code> </pre><br>  luego aplica un color a toda la geometr√≠a.  Del mismo modo, las relaciones entre otros atributos se pueden configurar llamando a los m√©todos setNormalBinding (), setSecondaryColorBinding (), setFogCoordBinding () y setVertexAttribBinding (). <br><br><h1>  5. Conjuntos de primitivas de geometr√≠a </h1><br>  El siguiente paso despu√©s de definir las matrices de atributos de v√©rtice es describir c√≥mo se representar√°n los datos de v√©rtice.  La clase virtual osg :: PrimitiveSet se usa para controlar las primitivas geom√©tricas generadas por el renderizador a partir de un conjunto de v√©rtices.  La clase osg :: Geometry proporciona varios m√©todos para trabajar con conjuntos de primitivas de geometr√≠a: <br><br><ul><li>  addPrimitiveSet (): pasa un puntero a un conjunto de primitivas en un objeto osg :: Geometry. <br></li><li>  removePrimitiveSet (): elimina un conjunto de primitivas.  Como par√°metros, toma el √≠ndice inicial de conjuntos y el n√∫mero de conjuntos que se eliminar√°n. <br></li><li>  getPrimitiveSet (): devuelve un conjunto de primitivas en el √≠ndice pasado como par√°metro. <br></li><li>  getNumPrimitiveSets (): devuelve el n√∫mero total de conjuntos de primitivas asociadas con esta geometr√≠a. <br></li></ul><br>  La clase osg :: PrimitiveSet es abstracta y no se puede instanciar, pero varias clases derivadas que encapsulan conjuntos de primitivas con las que opera OpenGL, como osg :: DrawArrays y osg :: DrawElementsUInt, heredan de ella. <br><br>  La clase osg :: DrawArrays usa varios elementos consecutivos de una matriz de v√©rtices para construir una primitiva geom√©trica.  Se puede crear y adjuntar a la geometr√≠a llamando a un m√©todo. <br><br><pre> <code class="cpp hljs">geom-&gt;addPrimitiveSet(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawArrays(mode, first, count));</code> </pre><br>  El primer modo de par√°metro establece el tipo primitivo en los tipos primitivos OpenGL correspondientes: GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS y GL_POLY. <br><br>  El primer y segundo par√°metro especifican el primer √≠ndice en la matriz de v√©rtices y el n√∫mero de v√©rtices a partir del cual se debe generar la geometr√≠a.  <strong>Adem√°s, OSG no comprueba si el n√∫mero especificado de v√©rtices es suficiente para construir la geometr√≠a especificada por el modo, ¬°lo que puede provocar el bloqueo de la aplicaci√≥n!</strong> <br><br><h1>  6. Ejemplo: dibuja un cuadrado pintado </h1><br>  Implementamos todo lo anterior como un ejemplo simple <br><br><div class="spoiler">  <b class="spoiler_title">El c√≥digo fuente completo para el ejemplo quad</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgViewer/Viewer&gt; #endif // MAIN_H</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back(osg::Vec3(0.0f, 0.0f, 0.0f)); vertices-&gt;push_back(osg::Vec3(1.0f, 0.0f, 0.0f)); vertices-&gt;push_back(osg::Vec3(1.0f, 0.0f, 1.0f)); vertices-&gt;push_back(osg::Vec3(0.0f, 0.0f, 1.0f)); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back(osg::Vec3(0.0f, -1.0f, 0.0f)); osg::ref_ptr&lt;osg::Vec4Array&gt; colors = new osg::Vec4Array; colors-&gt;push_back(osg::Vec4(1.0f, 0.0f, 0.0f, 1.0f)); colors-&gt;push_back(osg::Vec4(0.0f, 1.0f, 0.0f, 1.0f)); colors-&gt;push_back(osg::Vec4(0.0f, 0.0f, 1.0f, 1.0f)); colors-&gt;push_back(osg::Vec4(1.0f, 1.0f, 1.0f, 1.0f)); osg::ref_ptr&lt;osg::Geometry&gt; quad = new osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setColorArray(colors.get()); quad-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX); quad-&gt;addPrimitiveSet(new osg::DrawArrays(GL_QUADS, 0, 4)); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(quad.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Despu√©s de la compilaci√≥n y ejecuci√≥n, obtenemos un resultado similar a este <br><br><img src="https://habrastorage.org/webt/pz/1p/e4/pz1pe4inopylxd1vikvi4kzm8m0.png"><br><br>  Este ejemplo necesita aclaraci√≥n.  Entonces, en primer lugar, creamos una matriz de v√©rtices del cuadrado, en el que se almacenan sus coordenadas <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>));</code> </pre><br>  A continuaci√≥n establecemos la matriz de normales.  En nuestro caso simple, no necesitamos crear una normal para cada v√©rtice, solo describa un vector unitario dirigido perpendicularmente al plano del cuadrado <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec3Array&gt; normals = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; normals-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>));</code> </pre><br>  Establecer un color para cada v√©rtice <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec4Array&gt; colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec4Array; colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>));</code> </pre><br>  Ahora cree un objeto de geometr√≠a donde se almacenar√° la descripci√≥n de nuestro cuadrado, que ser√° procesada por el render.  Pasamos una matriz de v√©rtices a esta geometr√≠a. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Geometry&gt; quad = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geometry; quad-&gt;setVertexArray(vertices.get());</code> </pre><br>  Al pasar una serie de normales, informamos al motor que se usar√° una sola normal para todos los v√©rtices, especificando el m√©todo de enlace ("enlace") de los normales BIND_OVAERALL <br><br><pre> <code class="cpp hljs">quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL);</code> </pre><br>  Al pasar los colores de los v√©rtices, por el contrario, indicamos que cada v√©rtice tendr√° su propio color. <br><br><pre> <code class="cpp hljs">quad-&gt;setColorArray(colors.get()); quad-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX);</code> </pre><br>  Ahora cree un conjunto de primitivas para la geometr√≠a.  Indicamos que las caras cuadradas (GL_QUADS) deben generarse a partir de la matriz de v√©rtices, tomando el v√©rtice con √≠ndice 0 como primer v√©rtice, y el n√∫mero total de v√©rtices ser√° 4 <br><br><pre> <code class="cpp hljs">quad-&gt;addPrimitiveSet(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawArrays(GL_QUADS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>));</code> </pre><br>  Bueno, creo que no vale la pena explicar la transferencia de geometr√≠a y el lanzamiento del render <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Geode&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geode; root-&gt;addDrawable(quad.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>  El c√≥digo anterior es equivalente al siguiente dise√±o en OpenGL puro <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLfloat vertices[][<span class="hljs-number"><span class="hljs-number">3</span></span>] = { ‚Ä¶ }; glEnableClientState( GL_VERTEX_ARRAY ); glVertexPointer( <span class="hljs-number"><span class="hljs-number">4</span></span>, GL_FLOAT, <span class="hljs-number"><span class="hljs-number">0</span></span>, vertices ); glDrawArrays( GL_QUADS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> );</code> </pre><br><h1>  7. Indizaci√≥n de v√©rtices en primitivas </h1><br>  La clase osg :: DrawArrays funciona bien cuando se leen datos de v√©rtices directamente desde matrices, sin espacios.  Sin embargo, esto no es tan efectivo cuando el mismo v√©rtice puede pertenecer a varias caras de un objeto.  Veamos un ejemplo. <br><br><img src="https://habrastorage.org/webt/yp/is/wm/ypiswmcxzm2uokv9xdreonovmf4.png"><br><br>  El cubo tiene ocho v√©rtices.  Sin embargo, como se puede ver en la figura (observamos el despliegue del cubo en el plano), algunos v√©rtices pertenecen a m√°s de una cara.  Si construyes un cubo de 12 caras triangulares, estos v√©rtices se repetir√°n, y en lugar de una matriz de 8 v√©rtices, obtendremos una matriz de 36 v√©rtices, ¬°la mayor√≠a de los cuales son en realidad el mismo v√©rtice! <br><br>  Las clases OSG osg :: DrawElementsUInt, osg :: DrawElementsUByte y osg :: DrawElementsUShort, que utilizan matrices de √≠ndice de v√©rtices como datos, est√°n dise√±adas para resolver el problema descrito.  Las matrices de √≠ndices almacenan √≠ndices de v√©rtices de primitivas que describen caras y otros elementos de geometr√≠a.  Al aplicar estas clases para un cubo, es suficiente almacenar una matriz de ocho v√©rtices que est√°n asociados con caras a trav√©s de matrices de √≠ndices. <br><br>  Las clases de tipo osg :: DrawElements * se construyen de la misma manera que la clase est√°ndar std :: vector.  Dicho c√≥digo se puede usar para agregar √≠ndices. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::DrawElementsUInt&gt; de = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawElementsUInt(GL_TRIANGLES); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">0</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">1</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">2</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">3</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">0</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  Este c√≥digo define la cara frontal del cubo que se muestra en la figura. <br><br>  Consideremos un ejemplo ilustrativo m√°s: un octaedro <br><br><img src="https://habrastorage.org/webt/is/cg/3r/iscg3rdq59wftnoy7h1iulgoczk.png"><br><br>  Es interesante porque contiene solo seis v√©rtices, ¬°pero cada v√©rtice ingresa hasta cuatro caras triangulares!  Podemos crear una matriz de 24 v√©rtices para mostrar las ocho caras usando osg :: DrawArrays.  Sin embargo, haremos lo contrario: almacenaremos los v√©rtices en una matriz de seis elementos y generaremos caras usando la clase osg :: DrawElementsUInt. <br><br><div class="spoiler">  <b class="spoiler_title">Fuente completa para el ejemplo de octaedro</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgUtil/SmoothingVisitor&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array(6); (*vertices)[0].set( 0.0f, 0.0f, 1.0f); (*vertices)[1].set(-0.5f, -0.5f, 0.0f); (*vertices)[2].set( 0.5f, -0.5f, 0.0f); (*vertices)[3].set( 0.5f, 0.5f, 0.0f); (*vertices)[4].set(-0.5f, 0.5f, 0.0f); (*vertices)[5].set( 0.0f, 0.0f, -1.0f); osg::ref_ptr&lt;osg::DrawElementsUInt&gt; indices = new osg::DrawElementsUInt(GL_TRIANGLES, 24); (*indices)[ 0] = 0; (*indices)[ 1] = 1; (*indices)[ 2] = 2; (*indices)[ 3] = 0; (*indices)[ 4] = 4; (*indices)[ 5] = 1; (*indices)[ 6] = 4; (*indices)[ 7] = 5; (*indices)[ 8] = 1; (*indices)[ 9] = 4; (*indices)[10] = 3; (*indices)[11] = 5; (*indices)[12] = 3; (*indices)[13] = 2; (*indices)[14] = 5; (*indices)[15] = 1; (*indices)[16] = 5; (*indices)[17] = 2; (*indices)[18] = 3; (*indices)[19] = 0; (*indices)[20] = 2; (*indices)[21] = 0; (*indices)[22] = 3; (*indices)[23] = 4; osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; geom-&gt;setVertexArray(vertices.get()); geom-&gt;addPrimitiveSet(indices.get()); osgUtil::SmoothingVisitor::smooth(*geom); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(geom.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Analicemos este c√≥digo con m√°s detalle.  Por supuesto, lo primero que hacemos es crear una matriz de seis v√©rtices <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array(<span class="hljs-number"><span class="hljs-number">6</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">0</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">1</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">2</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">3</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">4</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">5</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>);</code> </pre><br>  Inicializamos cada v√©rtice directamente accediendo al vector de sus coordenadas usando la operaci√≥n de desreferenciaci√≥n del puntero y el operador [] (recordamos que osg :: Array es similar en su dispositivo a std :: vector). <br><br>  Ahora cree caras como una lista de √≠ndices de v√©rtices <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::DrawElementsUInt&gt; indices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawElementsUInt(GL_TRIANGLES, <span class="hljs-number"><span class="hljs-number">24</span></span>); (*indices)[ <span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; (*indices)[ <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; (*indices)[ <span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  0 (*indices)[ 3] = 0; (*indices)[ 4] = 4; (*indices)[ 5] = 1; //  1 (*indices)[ 6] = 4; (*indices)[ 7] = 5; (*indices)[ 8] = 1; //  2 (*indices)[ 9] = 4; (*indices)[10] = 3; (*indices)[11] = 5; //  3 (*indices)[12] = 3; (*indices)[13] = 2; (*indices)[14] = 5; //  4 (*indices)[15] = 1; (*indices)[16] = 5; (*indices)[17] = 2; //  5 (*indices)[18] = 3; (*indices)[19] = 0; (*indices)[20] = 2; //  6 (*indices)[21] = 0; (*indices)[22] = 3; (*indices)[23] = 4; //  7</span></span></code> </pre><br>  Las caras ser√°n triangulares, habr√° 8, lo que significa que la lista de √≠ndices debe contener 24 elementos.  Los √≠ndices de caras van secuencialmente en esta matriz: por ejemplo, la cara 0 est√° formada por los v√©rtices 0, 1 y 2;  cara 1 - v√©rtices 0, 4 y 1;  cara 2 - v√©rtices 4, 5 y 1 y as√≠ sucesivamente.  Los v√©rtices se enumeran en el sentido contrario a las agujas del reloj si observa la cara de la cara (consulte la figura anterior). <br><br>  Pasos adicionales para crear la geometr√≠a que realizamos en los ejemplos anteriores.  Lo √∫nico que no hicimos fue la generaci√≥n autom√°tica de normales suavizados (promediados), que realizamos en este ejemplo llamando <br><br><pre> <code class="cpp hljs">osgUtil::SmoothingVisitor::smooth(*geom);</code> </pre><br>  De hecho, si se dan los v√©rtices de una cara, entonces es f√°cil calcular lo normal.  En los v√©rtices en los que convergen varias caras, se calcula un cierto promedio normal: se suman las normales de las caras convergentes y la suma resultante se normaliza nuevamente.  Estas operaciones (¬°y muchas m√°s!) Pueden ser realizadas por el propio motor utilizando clases de la biblioteca osgUtil.  Por lo tanto, en nuestro ejemplo, agregaremos una instrucci√≥n al enlazador para construir nuestro programa con esta biblioteca en el archivo * .pro <br><br>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">octahedron.pro</a></strong> <br><br><pre> <code class="cmake hljs">CONFIG(debug, debug|release) { <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,,_d) . . . LIBS += -L$$OSG_LIB_DIRECTORY -losgUtild } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { . . . LIBS += -L$$OSG_LIB_DIRECTORY -losgUtil }</code> </pre><br>  Como resultado, obtenemos el siguiente resultado <br><br><img src="https://habrastorage.org/webt/sf/ia/yg/sfiayg-o7wqijwskwuw6276xx0y.png"><br><br>  Para entender c√≥mo funciona esto, considere la canalizaci√≥n de OpenGL <br><br><img src="https://habrastorage.org/webt/7w/f0/mq/7wf0mqmabsa1ltwbzsgt189jsmy.png"><br><br>  El mecanismo de matriz de v√©rtices reduce la cantidad de llamadas OpenGL.  Almacena datos de v√©rtices en la memoria de la aplicaci√≥n, que se usa en el lado del cliente.  La canalizaci√≥n de OpenGL en el lado del servidor obtiene acceso a varias matrices de v√©rtices.  Como se muestra en el diagrama, OpenGL recibe datos del b√∫fer de v√©rtices en el lado del cliente y, de manera ordenada, realiza el ensamblaje de primitivas.  As√≠ es como se procesan los datos utilizando los m√©todos set * Array () de la clase osg :: Geometry.  La clase osg :: DrawArrays revisa estas matrices directamente y las muestra. <br><br>  Cuando se usa osg :: DrawElements *, se reduce la dimensi√≥n de las matrices de v√©rtices y se reduce el n√∫mero de v√©rtices transferidos a la tuber√≠a.  Una matriz de √≠ndices le permite crear un cach√© de v√©rtices en el lado del servidor.  OpenGL lee datos de v√©rtices de la memoria cach√©, en lugar de leer desde el b√∫fer de v√©rtices en el lado del cliente.  Esto aumenta significativamente el rendimiento general de renderizado. <br><br><h1>  8. T√©cnicas de procesamiento de mallas poligonales. </h1><br>  OpenSceneGraph admite varias t√©cnicas para procesar la malla poligonal de los objetos de geometr√≠a de escena.  Estos m√©todos de preprocesamiento, como la reducci√≥n de pol√≠gonos y la teselaci√≥n, a menudo se utilizan para crear y optimizar modelos poligonales.  Tienen una interfaz simple, pero en el proceso realizan muchos c√°lculos complejos y no son muy adecuados para la ejecuci√≥n sobre la marcha. <br><br>  Las t√©cnicas descritas incluyen: <br><br><ol><li>  osgUtil :: Simplifier - reduciendo el n√∫mero de tri√°ngulos en geometr√≠a.  El m√©todo p√∫blico simplify () se usa para simplificar la geometr√≠a del modelo. <br></li><li>  osgUtil :: SmootingVisitor - c√°lculo de normales.  El m√©todo smooth () se puede usar para generar normales suavizadas para el modelo, en lugar de calcularlas independientemente y establecerlas expl√≠citamente a trav√©s de una matriz de normales. <br></li><li>  osgUtil :: TangentSpaceGenerator - generaci√≥n de vectores de base tangente para v√©rtices modelo.  Se inicia llamando al m√©todo generate () y guarda el resultado devuelto por los m√©todos getTangentArray (), getNormalArray () y getBinormalArray ().  Estos resultados se pueden usar para varios atributos de v√©rtice al escribir sombreadores en GLSL. <br></li><li>  osgUtil :: Tesselator - realiza la teselaci√≥n de una malla poligonal - divide primitivas complejas en una secuencia de simples (m√©todo retesselatePolygons ()) <br></li><li>  osgUtil :: TriStripVisitor - convierte una superficie geom√©trica en un conjunto de tiras de caras triangulares, lo que permite renderizar con un consumo eficiente de memoria.  El m√©todo stripify () convierte un conjunto de primitivas del modelo en geometr√≠a basada en el conjunto GL_TRIANGLE_STRIP. <br></li></ol><br>  Todos los m√©todos aceptan la geometr√≠a del objeto como un par√°metro pasado por osg :: Geometry &amp; link, por ejemplo as√≠ <br><br><pre> <code class="cpp hljs">osgUtil::TriStripVisitor tsv; tsv.stripify(*geom);</code> </pre><br>  donde geom se refiere a una instancia de geometr√≠a descrita por un puntero inteligente. <br><br>  Las clases osg :: Simplifier, osg :: SmoothingVisitor y osg :: TriStripVisitor pueden trabajar directamente con nodos en el gr√°fico de escena, por ejemplo <br><br><pre> <code class="cpp hljs">osgUtil::TriStripVisitor tsv; node-&gt;accept(tsv);</code> </pre><br>  El m√©todo accept () procesa todos los nodos secundarios hasta que la operaci√≥n especificada se aplica a todos los nodos terminales de esta parte del √°rbol de escenas almacenadas en nodos del tipo osg :: Geode. <br><br>  Probemos la t√©cnica de teselaci√≥n en la pr√°ctica. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo de ejemplo de tesselator completo</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgUtil/Tessellator&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*    ----- | _| | |_ | | ----- */</span></span></span><span class="hljs-meta"> osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 0.0f) ); // 0 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 0.0f) ); // 1 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 1.0f) ); // 2 vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 1.0f) ); // 3 vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 2.0f) ); // 4 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 2.0f) ); // 5 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 3.0f) ); // 6 vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 3.0f) ); // 7 osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back( osg::Vec3(0.0f, -1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; geom-&gt;setVertexArray(vertices.get()); geom-&gt;setNormalArray(normals.get()); geom-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); geom-&gt;addPrimitiveSet(new osg::DrawArrays(GL_POLYGON, 0, 8)); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(geom.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  En base a la posici√≥n espacial de los v√©rtices en este ejemplo, vemos que estamos tratando de crear un pol√≠gono no convexo de ocho v√©rtices, utilizando la generaci√≥n de una cara del tipo GL_POLYGON.  El ensamblaje y la ejecuci√≥n de este ejemplo muestra que el resultado que esperamos no funciona: el ejemplo se muestra incorrectamente <br><br><img src="https://habrastorage.org/webt/yb/d3/0f/ybd30fn9fa9duvxedfyb6igt3ui.png"><br><br>  Para solucionar este problema, la geometr√≠a construida debe estar teselada antes de pasarla al espectador. <br><br><pre> <code class="cpp hljs">osgUtil::Tessellator ts; ts.retessellatePolygons(*geom);</code> </pre><br>  despu√©s de lo cual obtenemos el resultado correcto <br><br><img src="https://habrastorage.org/webt/p7/wj/fa/p7wjfanogrvkbdxksemk5li_vdi.png"><br><br>  Como funciona  Un pol√≠gono no convexo, sin el uso de la teselaci√≥n correcta, no se mostrar√° como esperamos, ya que OpenGL, que busca optimizar el rendimiento, lo considerar√° como un pol√≠gono convexo simple o simplemente lo ignorar√°, lo que puede dar resultados completamente inesperados. <br><br>  La clase osgUtil :: Tessellator utiliza algoritmos para transformar un pol√≠gono convexo en una serie de no convexos; en nuestro caso, transforma la geometr√≠a en GL_TRIANGLE_STRIP. <br><br><img src="https://habrastorage.org/webt/05/ho/do/05hodotfc4iltbsnlyevejuhvfw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta clase puede manejar pol√≠gonos de agujeros y pol√≠gonos de auto-intersecci√≥n. Usando el m√©todo public setWindingType (), puede definir varias reglas de procesamiento, como GLU_TESS_WINDING_ODD o GLU_TESS_WINDING_NONZERO, que especifican las regiones internas y externas de un pol√≠gono complejo.</font></font><br><br><h1>  Conclusi√≥n </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este art√≠culo, obtuvimos una comprensi√≥n b√°sica de c√≥mo la geometr√≠a de los objetos tridimensionales se almacena y procesa en el motor OSG. </font><font style="vertical-align: inherit;">No piense que esos ejemplos simples y no demasiado impresionantes que se consideran en el art√≠culo son el l√≠mite de las capacidades del motor. </font><font style="vertical-align: inherit;">Solo estos ejemplos pueden ayudar al desarrollador a comprender la mec√°nica de OpenSceneGraph, y sin esta comprensi√≥n es dif√≠cil imaginar el trabajo de cosas m√°s complejas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este art√≠culo se basa en la traducci√≥n y el procesamiento del texto de los cap√≠tulos correspondientes del libro </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenSceneGraph 3.0. </font><font style="vertical-align: inherit;">Gu√≠a para principiantes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Todos los ejemplos los compruebo personalmente y su c√≥digo fuente est√° </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">disponible aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continuar√° ...</font></font></a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430212/">https://habr.com/ru/post/es430212/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430202/index.html">Escribir un sistema de part√≠culas que interact√∫an en pares en C ++ usando DirectX 11</a></li>
<li><a href="../es430204/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 18: "Navegaci√≥n privada en Internet", Parte 1</a></li>
<li><a href="../es430206/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 18: Navegaci√≥n privada en Internet, Parte 2</a></li>
<li><a href="../es430208/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 18: "Navegaci√≥n privada en Internet", parte 3</a></li>
<li><a href="../es430210/index.html">Pon a prueba mi paciencia por Check Point Security Academy</a></li>
<li><a href="../es430216/index.html">Seg√∫n tengo entendido, como muchos dulces, o la clasificaci√≥n de los productos por cheque en la solicitud</a></li>
<li><a href="../es430218/index.html">Optimizaci√≥n de energ√≠a STM32: una gu√≠a pr√°ctica</a></li>
<li><a href="../es430220/index.html">C√≥mo convertir un hub usb "centenario" en un dispositivo inteligente administrado y ahorrar $ 300</a></li>
<li><a href="../es430222/index.html">Ingeniero Senior en busca de trabajo. C√≥mo pas√© por 20 entrevistas con RRHH y lo que pienso al respecto</a></li>
<li><a href="../es430224/index.html">Trastorno esquizot√≠pico: una mirada al interior</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>