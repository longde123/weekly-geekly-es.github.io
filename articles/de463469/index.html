<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÖüèΩ ‚úãüèΩ üßìüèª Schr√∂dinger Katze ohne Box: das Problem des Konsenses in verteilten Systemen üíΩ üê® üóûÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Stellen Sie sich vor. 5 Katzen sind im Raum eingesperrt, und um den Besitzer aufzuwecken, m√ºssen sich alle einig sein, da sie die T√ºr nur √∂ffnen k√∂nne...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schr√∂dinger Katze ohne Box: das Problem des Konsenses in verteilten Systemen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dodopizzadev/blog/463469/">  Stellen Sie sich vor.  5 Katzen sind im Raum eingesperrt, und um den Besitzer aufzuwecken, m√ºssen sich alle einig sein, da sie die T√ºr nur √∂ffnen k√∂nnen, indem sie sich auf f√ºnf von ihnen st√ºtzen.  Wenn eine der Katzen eine Schr√∂dinger-Katze ist und die anderen Katzen nichts √ºber ihre L√∂sung wissen, stellt sich die Frage: "Wie k√∂nnen sie das tun?" <br><br>  In diesem Artikel werde ich Ihnen in einer einfachen Sprache die theoretische Komponente der Welt der verteilten Systeme und die Prinzipien ihrer Funktionsweise erl√§utern.  Und auch oberfl√§chlich die Hauptidee betrachten, die Paxos'a zugrunde liegt. <br><br><img src="https://habrastorage.org/webt/rd/38/j0/rd38j0ycrlghtsm-ahtyuh4dj9e.png"><br><a name="habracut"></a><br>  Wenn Entwickler Cloud-Infrastrukturen verwenden, arbeiten verschiedene Datenbanken in Clustern von einer gro√üen Anzahl von Knoten aus, sind sie sicher, dass die Daten vollst√§ndig, sicher und immer zug√§nglich sind.  Aber wo sind die Garantien? <br><br>  In der Tat sind die Garantien, die wir haben, die Garantien des Lieferanten.  Sie werden in der Dokumentation ungef√§hr folgenderma√üen beschrieben: "Dieser Dienst ist ziemlich zuverl√§ssig, er hat eine vordefinierte SLA, keine Sorge, alles wird wie erwartet auf verteilte Weise funktionieren." <br><br>  Wir neigen dazu, an das Beste zu glauben, weil kluge Onkel gro√üer Unternehmen uns versichert haben, dass alles gut wird.  Wir fragen uns nicht: Warum kann es √ºberhaupt funktionieren?  Gibt es eine formale Rechtfertigung f√ºr den ordnungsgem√§√üen Betrieb solcher Systeme? <br><br>  Ich habe k√ºrzlich eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schule f√ºr verteilte Computer besucht</a> und war von diesem Thema sehr inspiriert.  Die Vorlesungen an der Schule √§hnelten eher Klassen in mathematischer Analyse als etwas, das mit Computersystemen zu tun hatte.  Aber genau so wurden die wichtigsten Algorithmen, die wir jeden Tag verwenden, ohne es zu wissen, auf einmal bewiesen. <br><br>  Die meisten modernen verteilten Systeme verwenden den Paxos-Konsensalgorithmus und seine verschiedenen Modifikationen.  Das Coolste ist, dass die G√ºltigkeit und im Prinzip die M√∂glichkeit der Existenz dieses Algorithmus einfach mit Stift und Papier bewiesen werden kann.  In der Praxis wird der Algorithmus jedoch in gro√üen Systemen verwendet, die auf einer gro√üen Anzahl von Knoten in den Clouds arbeiten. <br><br><div class="spoiler">  <b class="spoiler_title">Leichte Illustration dessen, was weiter diskutiert wird: die Aufgabe zweier Gener√§le</b> <div class="spoiler_text"> Werfen wir einen Blick <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf die Aufgabe der beiden Gener√§le</a> , sich aufzuw√§rmen. <br><br>  Wir haben zwei Armeen - rot und wei√ü.  Wei√üe Truppen sind in der belagerten Stadt stationiert.  Rote Truppen, angef√ºhrt von den Gener√§len A1 und A2, befinden sich auf zwei Seiten der Stadt.  Die Aufgabe der Rothaarigen ist es, die wei√üe Stadt anzugreifen und zu gewinnen.  Die Armee jedes rothaarigen Generals ist jedoch kleiner als die Truppen der Wei√üen. <br><br><img src="https://habrastorage.org/webt/5i/ij/lu/5iijluannrbav-ljyfbmmi1n6fo.png"><br><br>  Siegbedingungen f√ºr Rothaarige: Beide Gener√§le m√ºssen gleichzeitig angreifen, um einen numerischen Vorteil gegen√ºber Wei√üen zu erzielen.  Dazu m√ºssen sich die Gener√§le A1 und A2 einig sein.  Wenn jeder einzeln angreift, verlieren die Rothaarigen. <br><br>  Um zuzustimmen, k√∂nnen die Gener√§le A1 und A2 sich gegenseitig Boten durch das Gebiet der wei√üen Stadt schicken.  Ein Bote kann erfolgreich zu einem verb√ºndeten General gelangen oder von einem Gegner abgefangen werden.  Frage: Gibt es eine solche Kommunikationssequenz zwischen den roten Gener√§len (die Sequenz des Sendens von Boten von A1 nach A2 und umgekehrt von A2 nach A1), in der sie sich garantiert auf einen Angriff zur Stunde X einigen. Hier wird unter den Garantien verstanden, dass beide Gener√§le eine eindeutige Best√§tigung haben werden dass ein Verb√ºndeter (ein anderer General) zum festgelegten Zeitpunkt X genau angreift. <br><br>  Angenommen, A1 sendet einen Boten an A2 mit der Nachricht: "Lass uns heute um Mitternacht angreifen!"  General A1 kann nicht ohne Best√§tigung von General A2 angreifen.  Wenn der Messenger A1 erreicht hat, sendet General A2 eine Best√§tigung mit der Nachricht: "Ja, lassen Sie uns heute die Wei√üen f√ºllen."  Aber jetzt wei√ü General A2 nicht, ob sein Bote angekommen ist oder nicht, er hat keine Garantie, ob der Angriff gleichzeitig stattfinden wird.  Jetzt muss General A2 erneut best√§tigt werden. <br><br>  Wenn wir ihre Kommunikation weiter planen, stellt sich Folgendes heraus: Unabh√§ngig von der Anzahl der Nachrichtenzyklen kann nicht garantiert werden, dass beide Gener√§le √ºber den Empfang ihrer Nachrichten informiert werden (vorausgesetzt, jeder der Messenger kann abgefangen werden). <br><br>  Die Aufgabe von zwei Gener√§len ist ein hervorragendes Beispiel f√ºr ein sehr einfaches verteiltes System, bei dem es zwei Knoten mit unzuverl√§ssiger Kommunikation gibt.  Wir haben also keine 100% ige Garantie daf√ºr, dass sie synchronisiert sind.  √úber √§hnliche Probleme erst sp√§ter in gr√∂√üerem Umfang im Artikel. <br></div></div><br><h2>  Wir f√ºhren das Konzept verteilter Systeme ein </h2><br>  Ein verteiltes System ist eine Gruppe von Computern (im Folgenden als Knoten bezeichnet), die Nachrichten austauschen k√∂nnen.  Jeder einzelne Knoten ist eine autonome Einheit.  Ein Knoten kann Aufgaben unabh√§ngig verarbeiten. Um jedoch mit anderen Knoten interagieren zu k√∂nnen, muss er Nachrichten senden und empfangen. <br><br>  Wie spezifisch Nachrichten implementiert werden, welche Protokolle verwendet werden - das interessiert uns in diesem Zusammenhang nicht.  Es ist wichtig, dass die Knoten eines verteilten Systems durch Senden von Nachrichten Daten miteinander austauschen k√∂nnen. <br><br>  Die Definition selbst sieht nicht sehr kompliziert aus, aber Sie m√ºssen ber√ºcksichtigen, dass ein verteiltes System eine Reihe von Attributen aufweist, die f√ºr uns wichtig sind. <br><br><h4>  Verteilte Systemattribute </h4><br><ol><li>  <b>Parallelit√§t</b> - die M√∂glichkeit gleichzeitiger oder konkurrierender Ereignisse im System.  Dar√ºber hinaus werden wir ber√ºcksichtigen, dass die Ereignisse, die auf zwei verschiedenen Knoten aufgetreten sind, potenziell wettbewerbsf√§hig sind, solange wir keine klare Reihenfolge f√ºr das Auftreten dieser Ereignisse haben.  Und in der Regel haben wir es nicht. </li><li>  <b>Das Fehlen einer globalen Uhr</b> .  Wir haben keine klare Reihenfolge der Ereignisse, da es keine globale Uhr gibt.  In der gew√∂hnlichen Welt der Menschen sind wir daran gew√∂hnt, dass wir absolut Stunden und Zeit haben.  Bei verteilten Systemen √§ndert sich alles.  Selbst ultrapr√§zise Atomuhren haben eine Drift, und es kann Situationen geben, in denen wir nicht sagen k√∂nnen, welches der beiden Ereignisse fr√ºher passiert ist.  Deshalb k√∂nnen wir uns auch nicht auf die Zeit verlassen. </li><li>  <b>Unabh√§ngiger Ausfall von Systemknoten</b> .  Es gibt noch ein anderes Problem: Etwas ist m√∂glicherweise nicht so einfach, weil unsere Knoten nicht ewig sind.  Die Festplatte f√§llt m√∂glicherweise aus, die virtuelle Maschine in der Cloud wird neu gestartet, das Netzwerk blinkt m√∂glicherweise und Nachrichten gehen verloren.  Dar√ºber hinaus sind Situationen m√∂glich, in denen die Knoten arbeiten, aber gleichzeitig gegen das System arbeiten.  Die letztere Klasse von Problemen erhielt sogar einen eigenen Namen: das Problem der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">byzantinischen Gener√§le</a> .  Das beliebteste Beispiel f√ºr ein verteiltes System mit einem solchen Problem ist Blockchain.  Aber heute werden wir diese spezielle Klasse von Problemen nicht ber√ºcksichtigen.  Wir werden an Situationen interessiert sein, in denen nur ein oder mehrere Knoten ausfallen k√∂nnen. </li><li>  <b>Kommunikationsmodelle (Messaging-Modelle) zwischen Knoten</b> .  Wir haben bereits herausgefunden, dass Knoten √ºber Messaging kommunizieren.  Es gibt zwei bekannte Messaging-Modelle: synchron und asynchron. </li></ol><br><h4>  Kommunikationsmodelle zwischen Knoten in verteilten Systemen </h4><br>  <b>Synchrones Modell</b> - Wir wissen mit Sicherheit, dass es ein endliches bekanntes Zeitdelta gibt, f√ºr das eine Nachricht garantiert von einem Knoten zum anderen gelangt.  Wenn diese Zeit vergangen ist, die Nachricht jedoch nicht eingetroffen ist, k√∂nnen wir mit Sicherheit sagen, dass der Knoten ausgefallen ist.  In einem solchen Modell haben wir eine vorhersehbare Wartezeit. <br><br>  <b>Asynchrones Modell</b> - In asynchronen Modellen glauben wir, dass die Wartezeit endlich ist, aber es gibt keine solche Deltazeit, nach der garantiert werden kann, dass der Knoten nicht in Ordnung ist.  Das hei√üt,  Die Wartezeit f√ºr eine Nachricht vom Knoten kann beliebig lang sein.  Dies ist eine wichtige Definition, √ºber die wir weiter sprechen werden. <br><br><h2>  Das Konzept des Konsenses in verteilten Systemen </h2><br>  Bevor wir das Konzept des Konsenses formell definieren, betrachten wir ein Beispiel f√ºr die Situation, in der wir es ben√∂tigen, n√§mlich die <b>Replikation von Zustandsmaschinen</b> . <br><br>  Wir haben ein verteiltes Protokoll.  Wir m√∂chten, dass es konsistent ist und identische Daten auf allen Knoten eines verteilten Systems enth√§lt.  Wenn einer der Knoten einen neuen Wert findet, den er in das Protokoll schreiben wird, besteht seine Aufgabe darin, diesen Wert allen anderen Knoten anzubieten, damit das Protokoll auf allen Knoten aktualisiert wird und das System in einen neuen konsistenten Zustand wechselt.  Es ist wichtig, dass die Knoten untereinander √ºbereinstimmen: Alle Knoten stimmen darin √ºberein, dass der vorgeschlagene neue Wert korrekt ist, alle Knoten akzeptieren diesen Wert, und nur in diesem Fall kann jeder einen neuen Wert in das Protokoll schreiben. <br><br>  Mit anderen Worten: Keiner der Knoten hat Einw√§nde gegen relevantere Informationen erhoben, und der vorgeschlagene Wert ist falsch.  Die √úbereinstimmung zwischen den Knoten und die Vereinbarung √ºber einen einzelnen korrekten akzeptierten Wert ist Konsens in einem verteilten System.  Weiter werden wir √ºber Algorithmen sprechen, die es einem verteilten System erm√∂glichen, einen Konsens mit Garantie zu erzielen. <br><img src="https://habrastorage.org/webt/0j/ph/1q/0jph1qr2_nur1-s1cyabhttzpy4.png"><br>  Formal k√∂nnen wir einen Konsensalgorithmus (oder nur einen Konsensalgorithmus) als eine Funktion definieren, die ein verteiltes System von Zustand A in Zustand B √ºbertr√§gt. Dar√ºber hinaus wird dieser Zustand von allen Knoten akzeptiert und alle Knoten k√∂nnen ihn best√§tigen.  Wie sich herausstellt, ist diese Aufgabe keineswegs so trivial, wie es auf den ersten Blick scheint. <br><br><h4>  Eigenschaften des Konsensalgorithmus </h4><br>  Der Konsensalgorithmus muss drei Eigenschaften haben, damit das System weiterhin existiert und beim √úbergang von Zustand zu Zustand Fortschritte erzielt werden: <br><br><ol><li>  <b>√úbereinstimmung</b> - Alle korrekt funktionierenden Knoten m√ºssen denselben Wert annehmen (in Artikeln wird diese Eigenschaft auch als Sicherheitseigenschaft gefunden).  Alle Knoten, die jetzt funktionieren (nicht au√üer Betrieb und haben den Kontakt zum Rest nicht verloren), sollten eine Einigung erzielen und eine endg√ºltige allgemeine Bedeutung annehmen. <br><br>  Es ist wichtig zu verstehen, dass die Knoten in dem verteilten System, die wir in Betracht ziehen, zustimmen m√∂chten.  Das hei√üt, wir sprechen jetzt √ºber Systeme, die m√∂glicherweise ausfallen (z. B. um einen Knoten auszufallen), aber dieses System hat definitiv keine Knoten, die absichtlich gegen andere arbeiten (die Aufgabe der byzantinischen Gener√§le).  Aufgrund dieser Eigenschaft bleibt das System konsistent. </li><li>  <b>Integrit√§t</b> - Wenn alle korrekt funktionierenden Knoten den gleichen Wert von <b>v</b> bieten, muss jeder korrekt funktionierende Knoten diesen Wert von <b>v</b> akzeptieren. </li><li>  <b>Beendigung</b> - Alle korrekt funktionierenden Knoten nehmen irgendwann einen Wert an (Liveness-Eigenschaft), wodurch der Algorithmus Fortschritte im System erzielen kann.  Jeder einzelne Knoten, der korrekt funktioniert, muss fr√ºher oder sp√§ter den endg√ºltigen Wert akzeptieren und dies best√§tigen: "F√ºr mich ist dieser Wert wahr, ich stimme dem gesamten System zu." </li></ol><br><h4>  Beispiel f√ºr einen Konsensalgorithmus </h4><br>  Bisher sind die Eigenschaften des Algorithmus m√∂glicherweise nicht ganz klar.  Daher veranschaulichen wir anhand eines Beispiels, welche Phasen der einfachste Konsensalgorithmus in einem System mit einem synchronen Messaging-Modell durchl√§uft, in dem alle Knoten wie erwartet funktionieren, Nachrichten nicht verloren gehen und nichts kaputt geht (passiert das wirklich?). <br><br><ol><li>  Alles beginnt mit einem Heiratsantrag (Propose).  Angenommen, ein Client hat eine Verbindung zu einem Knoten namens "Knoten 1" hergestellt und eine Transaktion gestartet, wobei ein neuer Wert an den Knoten O √ºbergeben wurde. Von nun an werden wir "Knoten 1" als <b>Antragsteller bezeichnen</b> .  Als Antragsteller sollte "Knoten 1" nun das gesamte System √ºber neue Daten informieren und Nachrichten an alle anderen Knoten senden: "Look!  Ich habe den Wert "O" und m√∂chte ihn aufschreiben!  Bitte best√§tigen Sie, dass Sie auch "O" in Ihr Protokoll schreiben. " <br><br><img src="https://habrastorage.org/webt/62/tt/i4/62tti4d8onrzc_0npw14yxzttba.png"></li><li>  In der n√§chsten Phase wird √ºber den vorgeschlagenen Wert abgestimmt (Abstimmung).  Wof√ºr ist es?  Es kann vorkommen, dass andere Knoten neuere Informationen erhalten haben und Daten zu derselben Transaktion haben. <br><br><img src="https://habrastorage.org/webt/4f/a8/ii/4fa8iiknak8jtumfh-kq3--yljs.png"><br><br>  Wenn der Knoten ‚ÄûKnoten 1‚Äú eine eigene Nachricht sendet, √ºberpr√ºfen die verbleibenden Knoten die Daten f√ºr dieses Ereignis in ihren Protokollen.  Wenn es keine Widerspr√ºche gibt, melden die Knoten: ‚ÄûJa, ich habe keine weiteren Daten zu diesem Ereignis.  Der Wert "O" ist die neueste Information, die wir verdienen. " <br><br>  In jedem anderen Fall k√∂nnen die Knoten mit ‚ÄûKnoten 1‚Äú antworten: ‚ÄûH√∂ren!  Ich habe neuere Daten zu dieser Transaktion.  Nicht "Oh", sondern etwas Besseres. " <br><br>  In der Phase der Abstimmung treffen die Knoten eine Entscheidung: Entweder nimmt jeder den gleichen Wert an oder einer von ihnen stimmt dagegen, was darauf hinweist, dass er √ºber neuere Daten verf√ºgt. </li><li>  Wenn die Abstimmungsrunde erfolgreich war und alle daf√ºr waren, bewegt sich das System in eine neue Phase - die Akzeptanz des Wertes (Akzeptieren).  "Knoten 1" sammelt alle Antworten anderer Knoten und meldet: "Alle stimmten dem Wert" O "zu!  Jetzt erkl√§re ich offiziell, dass "O" unsere neue Bedeutung ist, die f√ºr alle gleich ist!  Schreiben Sie sich in eine Brosch√ºre, vergessen Sie nicht.  Schreiben Sie in Ihr Protokoll! " <br><br><img src="https://habrastorage.org/webt/q4/q3/dj/q4q3djt3usbjuxz5jktov7tki9u.png"></li><li>  Die verbleibenden Knoten senden eine Best√§tigung (Akzeptiert), dass sie den Wert "O" notiert haben und in dieser Zeit nichts Neues tun konnten (eine Art zweiphasiges Festschreiben).  Nach diesem bedeutsamen Ereignis glauben wir, dass die verteilte Transaktion abgeschlossen ist. <br><img src="https://habrastorage.org/webt/ip/mi/hx/ipmihxdgotdz6dkggfeubcothkc.png"></li></ol><br>  Somit besteht der Konsensalgorithmus im einfachen Fall aus vier Schritten: Vorschlagen, Abstimmen, Akzeptieren, Best√§tigen der Akzeptanz. <br><br>  Wenn wir irgendwann keine Einigung erzielen konnten, wird der Algorithmus neu gestartet, wobei die Informationen der Knoten ber√ºcksichtigt werden, die sich geweigert haben, den vorgeschlagenen Wert zu best√§tigen. <br><br><h2>  Konsensalgorithmus in einem asynchronen System </h2><br>  Vorher war alles reibungslos, da es sich um ein synchrones Messaging-Modell handelte.  Aber wir wissen, dass wir in der modernen Welt daran gew√∂hnt sind, alles asynchron zu machen.  Wie funktioniert ein √§hnlicher Algorithmus in einem System mit einem asynchronen Messaging-Modell, in dem wir glauben, dass die Wartezeit auf eine Antwort von einem Knoten beliebig lang sein kann (der Ausfall eines Knotens kann √ºbrigens auch als Beispiel angesehen werden, wenn ein Knoten beliebig lange antworten kann). ) <br><br><blockquote>  Nachdem wir nun wissen, wie der Konsensalgorithmus im Grunde funktioniert, stellt sich die Frage f√ºr diejenigen neugierigen Leser, die diesen Punkt erreicht haben: Wie viele Knoten in einem System von N Knoten mit einem asynchronen Nachrichtenmodell k√∂nnen ausfallen, damit das System immer noch einen Konsens erreichen kann? </blockquote><br><div class="spoiler">  <b class="spoiler_title">Die richtige Antwort und Begr√ºndung hinter dem Spoiler.</b> <div class="spoiler_text">  Die richtige Antwort ist <b>0</b> .  Wenn mindestens ein Knoten im asynchronen System ausf√§llt, kann das System keinen Konsens erzielen.  Diese Behauptung wird in dem in bestimmten Kreisen bekannten FLP-Theorem bewiesen (1985, Fischer, Lynch, Paterson, Link zum Original am Ende des Artikels): ‚ÄûDie Unf√§higkeit, einen verteilten Konsens zu erzielen, wenn mindestens ein Knoten ausf√§llt‚Äú. <br><img src="https://habrastorage.org/webt/bo/hm/1x/bohm1xpvycsoq2xbobtaje8xpfc.png"><br>  Leute, dann haben wir ein Problem, wir sind daran gew√∂hnt, dass alles mit uns asynchron ist.  Und hier ist es.  Wie kann man weiter leben? <br></div></div><br>  Wir sprechen jetzt √ºber Theorie, √ºber Mathematik.  Was bedeutet es, dass "kein Konsens erzielt werden kann", wenn man von einer mathematischen Sprache in unsere √ºbersetzt - Ingenieurwesen?  Dies bedeutet, dass "nicht immer erreicht werden kann", d.h.  Es gibt einen Fall, in dem kein Konsens erzielt werden kann.  Und was ist das? <br><br>  Dies ist nur eine Verletzung der oben beschriebenen Lebendigkeitseigenschaft.  Wir haben keine allgemeine Vereinbarung, und das System kann nicht fortschreiten (kann nicht in einer begrenzten Zeit abgeschlossen werden), wenn wir nicht von allen Knoten eine Antwort haben.  Da wir in einem asynchronen System keine vorhersehbare Antwortzeit haben und nicht wissen k√∂nnen, ob der Knoten ausgefallen ist oder nur eine lange Antwortzeit ben√∂tigt. <br><br>  In der Praxis k√∂nnen wir jedoch eine L√∂sung finden.  Lassen Sie unseren Algorithmus bei Fehlern lange arbeiten (er kann m√∂glicherweise endlos funktionieren).  In den meisten Situationen, in denen die meisten Knoten ordnungsgem√§√ü funktionieren, haben wir Fortschritte im System. <br><br>  In der Praxis handelt es sich um teilweise synchrone Kommunikationsmodelle.  Partielle Synchronit√§t wird wie folgt verstanden: Im allgemeinen Fall haben wir ein asynchrones Modell, aber formal f√ºhren wir ein bestimmtes Konzept der ‚Äûglobalen Stabilisierungszeit‚Äú eines bestimmten Zeitpunkts ein. <br><br>  Dieser Zeitpunkt kann nicht so lange kommen, wie Sie m√∂chten, aber eines Tages muss er kommen.  Ein virtueller Alarm ert√∂nt und von nun an k√∂nnen wir das Zeitdelta vorhersagen, f√ºr das Nachrichten erreicht werden.  Ab diesem Moment wechselt das System von asynchron zu synchron.  In der Praxis haben wir es mit genau solchen Systemen zu tun. <br><br><h2>  Der Paxos-Algorithmus l√∂st Konsensprobleme </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Paxos</a> ist eine Familie von Algorithmen, die das Konsensproblem f√ºr teilweise synchrone Systeme l√∂sen, vorausgesetzt, einige Knoten k√∂nnen ausfallen.  Der Autor von Paxos ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Leslie Lamport</a> .  Er schlug 1989 einen formalen Beweis f√ºr die Existenz und Richtigkeit des Algorithmus vor. <br><br>  Aber der Beweis war keineswegs trivial.  Die erste Ver√∂ffentlichung wurde erst 1998 (33 Seiten) mit einer Beschreibung des Algorithmus ver√∂ffentlicht.  Wie sich herausstellte, war es √§u√üerst schwer zu verstehen, und 2001 wurde eine Erkl√§rung f√ºr den Artikel ver√∂ffentlicht, der 14 Seiten umfasste.  Die B√§nde der Ver√∂ffentlichungen sollen zeigen, dass das Problem des Konsenses in der Tat √ºberhaupt nicht einfach ist und solche Algorithmen der enormen Arbeit der kl√ºgsten Leute unterliegen. <br><blockquote>  Es ist interessant, dass Leslie Lamport selbst in seinem Vortrag feststellte, dass es in der zweiten Artikelerkl√§rung eine Aussage gibt, eine Zeile (nicht angegeben, welche), die unterschiedlich interpretiert werden kann.  Aus diesem Grund funktionieren viele moderne Paxos-Implementierungen nicht richtig. </blockquote><br>  Eine detaillierte Analyse der Arbeit von Paxos wird mehr als einen Artikel enthalten, daher werde ich versuchen, die Hauptidee des Algorithmus sehr kurz zu vermitteln.  In den Links am Ende meines Artikels finden Sie Materialien zum weiteren Eintauchen in dieses Thema. <br><br><h4>  Rollen in Paxos </h4><br>  Paxos hat ein Rollenkonzept.  Betrachten wir drei Hauptmerkmale (es gibt √Ñnderungen mit zus√§tzlichen Rollen): <br><br><ol><li>  <b>Antragsteller (Begriffe k√∂nnen auch verwendet werden: Leiter oder Koordinatoren)</b> .  Dies sind die Leute, die vom Benutzer etwas √ºber neue Bedeutungen lernen und die Rolle des Leiters √ºbernehmen.  Ihre Aufgabe ist es, eine Runde von Vorschl√§gen von neuer Bedeutung zu starten und weitere Aktionen der Knoten zu koordinieren.  Dar√ºber hinaus erm√∂glicht Paxos die Anwesenheit mehrerer F√ºhrungskr√§fte in bestimmten Situationen. </li><li>  <b>Akzeptoren (W√§hler)</b> .  Dies sind die Knoten, die f√ºr die Annahme oder Ablehnung eines bestimmten Werts stimmen.  Ihre Rolle ist sehr wichtig, da die Entscheidung von ihnen abh√§ngt: In welchem ‚Äã‚ÄãZustand wird das System nach der n√§chsten Stufe des Konsensalgorithmus gehen (oder nicht). </li><li>  <b>Lernende</b> .  Knoten, die den neuen akzeptierten Wert einfach akzeptieren und aufzeichnen, wenn sich der Status des Systems ge√§ndert hat.  Sie treffen keine Entscheidungen, sie empfangen einfach Daten und k√∂nnen diese dem Endbenutzer geben. </li></ol><br>  Ein Knoten kann mehrere Rollen in verschiedenen Situationen kombinieren. <br><br><h4>  Quorum-Konzept </h4><br>  Wir nehmen an, dass wir ein System von <b>N</b> Knoten haben.  Und von ihnen k√∂nnen maximal <b>F</b> Knoten ausfallen.  Wenn F-Knoten ausfallen, m√ºssen mindestens <b>2F + 1-</b> Akzeptorknoten im Cluster vorhanden sein. <br><br>  Dies ist notwendig, damit wir auch in der schlimmsten Situation immer eine ‚Äûgute‚Äú, korrekt funktionierende Knotenmehrheit haben.  Das hei√üt, <b>F + 1</b> "gute" Knoten, die vereinbart wurden, und der endg√ºltige Wert wird akzeptiert.  Andernfalls kann es vorkommen, dass verschiedene lokale Gruppen unterschiedliche Bedeutungen annehmen und sich nicht einigen k√∂nnen.  Deshalb brauchen wir eine absolute Mehrheit, um die Abstimmung zu gewinnen. <br><br><h4>  Die allgemeine Idee des Paxos-Konsensalgorithmus </h4><br>  Der Paxos-Algorithmus umfasst zwei gro√üe Phasen, die wiederum in zwei Schritte unterteilt sind: <br><br><ol><li>  <b>Phase 1a: Vorbereiten</b> .  In der Vorbereitungsphase informiert der Leiter (Antragsteller) alle Knoten: ‚ÄûWir beginnen eine neue Abstimmungsphase.  Wir haben eine neue Runde.  Die Nummer dieser Runde ist n.  Jetzt werden wir anfangen zu w√§hlen. ‚Äú  Derzeit wird lediglich der Beginn eines neuen Zyklus gemeldet, jedoch kein neuer Wert.  Die Aufgabe dieser Phase ist es, eine neue Runde einzuleiten und jedem seine eindeutige Nummer mitzuteilen.  Die runde Zahl ist wichtig, sie muss gr√∂√üer sein als alle vorherigen Abstimmungszahlen aller vorherigen F√ºhrer.  Da es genau der runden Zahl zu verdanken ist, werden andere Knoten im System verstehen, wie frisch der Leiter Daten hat.  Andere Knoten haben wahrscheinlich bereits Abstimmungsergebnisse aus viel sp√§teren Runden und sie werden dem Anf√ºhrer einfach sagen, dass er hinter der Zeit ist. </li><li>  <b>Phase 1b: Versprechen</b> .  Wenn die Akzeptorknoten die Nummer der neuen Abstimmungsstufe erhalten haben, sind zwei Ergebnisse m√∂glich: <br><ul><li>  n   ,      ,    acceptor.  acceptor   ,            ,  n.  acceptor    -  (..       - ),           ,    . </li><li>   ,  acceptor       ,          . </li></ul></li><li> <b>Phase 2a: Accept</b> .       (   ) ,     ,        : <br><ul><li>   acceptor'  ,     .          c .    x,      : ¬´Accept (n, x)¬ª,    ‚Äì       Propose,    ‚Äì     , ..   , , . </li><li>    acceptor'    ,        ,        ,  ,      .   y.      : ¬´Accept (n, y)¬ª,     . </li></ul></li><li> <b>Phase 2b: Accepted</b> . , -acceptor',    ¬´Accept(...)¬ª,      (   ,      )    ,     - ()        <b>n' &gt; n</b> ,        . <br><br>     ,      ,     .  Hurra!        ,     ,    . </li></ol><br>     Paxos.        ,       ,      ,               . <br><br>   ,  Paxos ‚Äî     ,    , , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Raft</a> ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . <br><br><h2>       </h2><br>  ¬´¬ª: <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">How Does Distributed Consensus Works?</a> , Preethi Kasireddy, blog article on Medium </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Paxos made simple. For real</a> , Adi Kancherla, blog article on Medium </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Decentralized Thoughts</a> , Ittai Abraham, blog </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Synchrony, Asynchrony and Partial synchrony</a> , Ittai Abraham, blog article </li></ul><br>  ¬´ ¬ª: <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Impossibility of Distributed Consensus with One Faulty Process (FLP impossibility)</a> , Fischer, Lynch and Paterson, research paper, 1985 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The Part-Time Parliament</a> , Leslie Lamport, research paper, 1998 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Paxos made simple</a> , Leslie Lamport, research paper, 2001 </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463469/">https://habr.com/ru/post/de463469/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463455/index.html">Tausende Dinge, die in Java ab Version 1 behoben werden m√ºssen: ein gro√üartiges Interview mit Sergey Kuksenko von Oracle</a></li>
<li><a href="../de463459/index.html">Versteckte Fehler bei Shared Element Transitions</a></li>
<li><a href="../de463461/index.html">Was ist und was nicht in Go. Teil 1</a></li>
<li><a href="../de463463/index.html">Methode zum Erstellen eines DRAG- und DROP-Effekts</a></li>
<li><a href="../de463465/index.html">Das Buch ‚ÄûExpressive JavaScript. Moderne Webprogrammierung. 3. Auflage</a></li>
<li><a href="../de463471/index.html">Funktionsumschaltung: Ansichten, Vorteile und Arbeiten mit ihnen in .NET</a></li>
<li><a href="../de463473/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 16. Networking in einem kleinen B√ºro</a></li>
<li><a href="../de463477/index.html">Ruhe: dBud-Ohrst√∂psel mit zwei Ger√§uschreduzierungsstufen</a></li>
<li><a href="../de463481/index.html">Diskrete Mathematik f√ºr WMS: Algorithmus zum Komprimieren von Waren in Zellen (Teil 1)</a></li>
<li><a href="../de463483/index.html">Dokumentenkollaboration, aktualisierter Unternehmenschat und mobile App: Was ist neu in Zextras Suite 3.0?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>