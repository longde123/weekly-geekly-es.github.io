<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎅🏽 ✋🏽 🧓🏻 Schrödinger Katze ohne Box: das Problem des Konsenses in verteilten Systemen 💽 🐨 🗞️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Stellen Sie sich vor. 5 Katzen sind im Raum eingesperrt, und um den Besitzer aufzuwecken, müssen sich alle einig sein, da sie die Tür nur öffnen könne...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schrödinger Katze ohne Box: das Problem des Konsenses in verteilten Systemen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dodopizzadev/blog/463469/">  Stellen Sie sich vor.  5 Katzen sind im Raum eingesperrt, und um den Besitzer aufzuwecken, müssen sich alle einig sein, da sie die Tür nur öffnen können, indem sie sich auf fünf von ihnen stützen.  Wenn eine der Katzen eine Schrödinger-Katze ist und die anderen Katzen nichts über ihre Lösung wissen, stellt sich die Frage: "Wie können sie das tun?" <br><br>  In diesem Artikel werde ich Ihnen in einer einfachen Sprache die theoretische Komponente der Welt der verteilten Systeme und die Prinzipien ihrer Funktionsweise erläutern.  Und auch oberflächlich die Hauptidee betrachten, die Paxos'a zugrunde liegt. <br><br><img src="https://habrastorage.org/webt/rd/38/j0/rd38j0ycrlghtsm-ahtyuh4dj9e.png"><br><a name="habracut"></a><br>  Wenn Entwickler Cloud-Infrastrukturen verwenden, arbeiten verschiedene Datenbanken in Clustern von einer großen Anzahl von Knoten aus, sind sie sicher, dass die Daten vollständig, sicher und immer zugänglich sind.  Aber wo sind die Garantien? <br><br>  In der Tat sind die Garantien, die wir haben, die Garantien des Lieferanten.  Sie werden in der Dokumentation ungefähr folgendermaßen beschrieben: "Dieser Dienst ist ziemlich zuverlässig, er hat eine vordefinierte SLA, keine Sorge, alles wird wie erwartet auf verteilte Weise funktionieren." <br><br>  Wir neigen dazu, an das Beste zu glauben, weil kluge Onkel großer Unternehmen uns versichert haben, dass alles gut wird.  Wir fragen uns nicht: Warum kann es überhaupt funktionieren?  Gibt es eine formale Rechtfertigung für den ordnungsgemäßen Betrieb solcher Systeme? <br><br>  Ich habe kürzlich eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schule für verteilte Computer besucht</a> und war von diesem Thema sehr inspiriert.  Die Vorlesungen an der Schule ähnelten eher Klassen in mathematischer Analyse als etwas, das mit Computersystemen zu tun hatte.  Aber genau so wurden die wichtigsten Algorithmen, die wir jeden Tag verwenden, ohne es zu wissen, auf einmal bewiesen. <br><br>  Die meisten modernen verteilten Systeme verwenden den Paxos-Konsensalgorithmus und seine verschiedenen Modifikationen.  Das Coolste ist, dass die Gültigkeit und im Prinzip die Möglichkeit der Existenz dieses Algorithmus einfach mit Stift und Papier bewiesen werden kann.  In der Praxis wird der Algorithmus jedoch in großen Systemen verwendet, die auf einer großen Anzahl von Knoten in den Clouds arbeiten. <br><br><div class="spoiler">  <b class="spoiler_title">Leichte Illustration dessen, was weiter diskutiert wird: die Aufgabe zweier Generäle</b> <div class="spoiler_text"> Werfen wir einen Blick <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf die Aufgabe der beiden Generäle</a> , sich aufzuwärmen. <br><br>  Wir haben zwei Armeen - rot und weiß.  Weiße Truppen sind in der belagerten Stadt stationiert.  Rote Truppen, angeführt von den Generälen A1 und A2, befinden sich auf zwei Seiten der Stadt.  Die Aufgabe der Rothaarigen ist es, die weiße Stadt anzugreifen und zu gewinnen.  Die Armee jedes rothaarigen Generals ist jedoch kleiner als die Truppen der Weißen. <br><br><img src="https://habrastorage.org/webt/5i/ij/lu/5iijluannrbav-ljyfbmmi1n6fo.png"><br><br>  Siegbedingungen für Rothaarige: Beide Generäle müssen gleichzeitig angreifen, um einen numerischen Vorteil gegenüber Weißen zu erzielen.  Dazu müssen sich die Generäle A1 und A2 einig sein.  Wenn jeder einzeln angreift, verlieren die Rothaarigen. <br><br>  Um zuzustimmen, können die Generäle A1 und A2 sich gegenseitig Boten durch das Gebiet der weißen Stadt schicken.  Ein Bote kann erfolgreich zu einem verbündeten General gelangen oder von einem Gegner abgefangen werden.  Frage: Gibt es eine solche Kommunikationssequenz zwischen den roten Generälen (die Sequenz des Sendens von Boten von A1 nach A2 und umgekehrt von A2 nach A1), in der sie sich garantiert auf einen Angriff zur Stunde X einigen. Hier wird unter den Garantien verstanden, dass beide Generäle eine eindeutige Bestätigung haben werden dass ein Verbündeter (ein anderer General) zum festgelegten Zeitpunkt X genau angreift. <br><br>  Angenommen, A1 sendet einen Boten an A2 mit der Nachricht: "Lass uns heute um Mitternacht angreifen!"  General A1 kann nicht ohne Bestätigung von General A2 angreifen.  Wenn der Messenger A1 erreicht hat, sendet General A2 eine Bestätigung mit der Nachricht: "Ja, lassen Sie uns heute die Weißen füllen."  Aber jetzt weiß General A2 nicht, ob sein Bote angekommen ist oder nicht, er hat keine Garantie, ob der Angriff gleichzeitig stattfinden wird.  Jetzt muss General A2 erneut bestätigt werden. <br><br>  Wenn wir ihre Kommunikation weiter planen, stellt sich Folgendes heraus: Unabhängig von der Anzahl der Nachrichtenzyklen kann nicht garantiert werden, dass beide Generäle über den Empfang ihrer Nachrichten informiert werden (vorausgesetzt, jeder der Messenger kann abgefangen werden). <br><br>  Die Aufgabe von zwei Generälen ist ein hervorragendes Beispiel für ein sehr einfaches verteiltes System, bei dem es zwei Knoten mit unzuverlässiger Kommunikation gibt.  Wir haben also keine 100% ige Garantie dafür, dass sie synchronisiert sind.  Über ähnliche Probleme erst später in größerem Umfang im Artikel. <br></div></div><br><h2>  Wir führen das Konzept verteilter Systeme ein </h2><br>  Ein verteiltes System ist eine Gruppe von Computern (im Folgenden als Knoten bezeichnet), die Nachrichten austauschen können.  Jeder einzelne Knoten ist eine autonome Einheit.  Ein Knoten kann Aufgaben unabhängig verarbeiten. Um jedoch mit anderen Knoten interagieren zu können, muss er Nachrichten senden und empfangen. <br><br>  Wie spezifisch Nachrichten implementiert werden, welche Protokolle verwendet werden - das interessiert uns in diesem Zusammenhang nicht.  Es ist wichtig, dass die Knoten eines verteilten Systems durch Senden von Nachrichten Daten miteinander austauschen können. <br><br>  Die Definition selbst sieht nicht sehr kompliziert aus, aber Sie müssen berücksichtigen, dass ein verteiltes System eine Reihe von Attributen aufweist, die für uns wichtig sind. <br><br><h4>  Verteilte Systemattribute </h4><br><ol><li>  <b>Parallelität</b> - die Möglichkeit gleichzeitiger oder konkurrierender Ereignisse im System.  Darüber hinaus werden wir berücksichtigen, dass die Ereignisse, die auf zwei verschiedenen Knoten aufgetreten sind, potenziell wettbewerbsfähig sind, solange wir keine klare Reihenfolge für das Auftreten dieser Ereignisse haben.  Und in der Regel haben wir es nicht. </li><li>  <b>Das Fehlen einer globalen Uhr</b> .  Wir haben keine klare Reihenfolge der Ereignisse, da es keine globale Uhr gibt.  In der gewöhnlichen Welt der Menschen sind wir daran gewöhnt, dass wir absolut Stunden und Zeit haben.  Bei verteilten Systemen ändert sich alles.  Selbst ultrapräzise Atomuhren haben eine Drift, und es kann Situationen geben, in denen wir nicht sagen können, welches der beiden Ereignisse früher passiert ist.  Deshalb können wir uns auch nicht auf die Zeit verlassen. </li><li>  <b>Unabhängiger Ausfall von Systemknoten</b> .  Es gibt noch ein anderes Problem: Etwas ist möglicherweise nicht so einfach, weil unsere Knoten nicht ewig sind.  Die Festplatte fällt möglicherweise aus, die virtuelle Maschine in der Cloud wird neu gestartet, das Netzwerk blinkt möglicherweise und Nachrichten gehen verloren.  Darüber hinaus sind Situationen möglich, in denen die Knoten arbeiten, aber gleichzeitig gegen das System arbeiten.  Die letztere Klasse von Problemen erhielt sogar einen eigenen Namen: das Problem der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">byzantinischen Generäle</a> .  Das beliebteste Beispiel für ein verteiltes System mit einem solchen Problem ist Blockchain.  Aber heute werden wir diese spezielle Klasse von Problemen nicht berücksichtigen.  Wir werden an Situationen interessiert sein, in denen nur ein oder mehrere Knoten ausfallen können. </li><li>  <b>Kommunikationsmodelle (Messaging-Modelle) zwischen Knoten</b> .  Wir haben bereits herausgefunden, dass Knoten über Messaging kommunizieren.  Es gibt zwei bekannte Messaging-Modelle: synchron und asynchron. </li></ol><br><h4>  Kommunikationsmodelle zwischen Knoten in verteilten Systemen </h4><br>  <b>Synchrones Modell</b> - Wir wissen mit Sicherheit, dass es ein endliches bekanntes Zeitdelta gibt, für das eine Nachricht garantiert von einem Knoten zum anderen gelangt.  Wenn diese Zeit vergangen ist, die Nachricht jedoch nicht eingetroffen ist, können wir mit Sicherheit sagen, dass der Knoten ausgefallen ist.  In einem solchen Modell haben wir eine vorhersehbare Wartezeit. <br><br>  <b>Asynchrones Modell</b> - In asynchronen Modellen glauben wir, dass die Wartezeit endlich ist, aber es gibt keine solche Deltazeit, nach der garantiert werden kann, dass der Knoten nicht in Ordnung ist.  Das heißt,  Die Wartezeit für eine Nachricht vom Knoten kann beliebig lang sein.  Dies ist eine wichtige Definition, über die wir weiter sprechen werden. <br><br><h2>  Das Konzept des Konsenses in verteilten Systemen </h2><br>  Bevor wir das Konzept des Konsenses formell definieren, betrachten wir ein Beispiel für die Situation, in der wir es benötigen, nämlich die <b>Replikation von Zustandsmaschinen</b> . <br><br>  Wir haben ein verteiltes Protokoll.  Wir möchten, dass es konsistent ist und identische Daten auf allen Knoten eines verteilten Systems enthält.  Wenn einer der Knoten einen neuen Wert findet, den er in das Protokoll schreiben wird, besteht seine Aufgabe darin, diesen Wert allen anderen Knoten anzubieten, damit das Protokoll auf allen Knoten aktualisiert wird und das System in einen neuen konsistenten Zustand wechselt.  Es ist wichtig, dass die Knoten untereinander übereinstimmen: Alle Knoten stimmen darin überein, dass der vorgeschlagene neue Wert korrekt ist, alle Knoten akzeptieren diesen Wert, und nur in diesem Fall kann jeder einen neuen Wert in das Protokoll schreiben. <br><br>  Mit anderen Worten: Keiner der Knoten hat Einwände gegen relevantere Informationen erhoben, und der vorgeschlagene Wert ist falsch.  Die Übereinstimmung zwischen den Knoten und die Vereinbarung über einen einzelnen korrekten akzeptierten Wert ist Konsens in einem verteilten System.  Weiter werden wir über Algorithmen sprechen, die es einem verteilten System ermöglichen, einen Konsens mit Garantie zu erzielen. <br><img src="https://habrastorage.org/webt/0j/ph/1q/0jph1qr2_nur1-s1cyabhttzpy4.png"><br>  Formal können wir einen Konsensalgorithmus (oder nur einen Konsensalgorithmus) als eine Funktion definieren, die ein verteiltes System von Zustand A in Zustand B überträgt. Darüber hinaus wird dieser Zustand von allen Knoten akzeptiert und alle Knoten können ihn bestätigen.  Wie sich herausstellt, ist diese Aufgabe keineswegs so trivial, wie es auf den ersten Blick scheint. <br><br><h4>  Eigenschaften des Konsensalgorithmus </h4><br>  Der Konsensalgorithmus muss drei Eigenschaften haben, damit das System weiterhin existiert und beim Übergang von Zustand zu Zustand Fortschritte erzielt werden: <br><br><ol><li>  <b>Übereinstimmung</b> - Alle korrekt funktionierenden Knoten müssen denselben Wert annehmen (in Artikeln wird diese Eigenschaft auch als Sicherheitseigenschaft gefunden).  Alle Knoten, die jetzt funktionieren (nicht außer Betrieb und haben den Kontakt zum Rest nicht verloren), sollten eine Einigung erzielen und eine endgültige allgemeine Bedeutung annehmen. <br><br>  Es ist wichtig zu verstehen, dass die Knoten in dem verteilten System, die wir in Betracht ziehen, zustimmen möchten.  Das heißt, wir sprechen jetzt über Systeme, die möglicherweise ausfallen (z. B. um einen Knoten auszufallen), aber dieses System hat definitiv keine Knoten, die absichtlich gegen andere arbeiten (die Aufgabe der byzantinischen Generäle).  Aufgrund dieser Eigenschaft bleibt das System konsistent. </li><li>  <b>Integrität</b> - Wenn alle korrekt funktionierenden Knoten den gleichen Wert von <b>v</b> bieten, muss jeder korrekt funktionierende Knoten diesen Wert von <b>v</b> akzeptieren. </li><li>  <b>Beendigung</b> - Alle korrekt funktionierenden Knoten nehmen irgendwann einen Wert an (Liveness-Eigenschaft), wodurch der Algorithmus Fortschritte im System erzielen kann.  Jeder einzelne Knoten, der korrekt funktioniert, muss früher oder später den endgültigen Wert akzeptieren und dies bestätigen: "Für mich ist dieser Wert wahr, ich stimme dem gesamten System zu." </li></ol><br><h4>  Beispiel für einen Konsensalgorithmus </h4><br>  Bisher sind die Eigenschaften des Algorithmus möglicherweise nicht ganz klar.  Daher veranschaulichen wir anhand eines Beispiels, welche Phasen der einfachste Konsensalgorithmus in einem System mit einem synchronen Messaging-Modell durchläuft, in dem alle Knoten wie erwartet funktionieren, Nachrichten nicht verloren gehen und nichts kaputt geht (passiert das wirklich?). <br><br><ol><li>  Alles beginnt mit einem Heiratsantrag (Propose).  Angenommen, ein Client hat eine Verbindung zu einem Knoten namens "Knoten 1" hergestellt und eine Transaktion gestartet, wobei ein neuer Wert an den Knoten O übergeben wurde. Von nun an werden wir "Knoten 1" als <b>Antragsteller bezeichnen</b> .  Als Antragsteller sollte "Knoten 1" nun das gesamte System über neue Daten informieren und Nachrichten an alle anderen Knoten senden: "Look!  Ich habe den Wert "O" und möchte ihn aufschreiben!  Bitte bestätigen Sie, dass Sie auch "O" in Ihr Protokoll schreiben. " <br><br><img src="https://habrastorage.org/webt/62/tt/i4/62tti4d8onrzc_0npw14yxzttba.png"></li><li>  In der nächsten Phase wird über den vorgeschlagenen Wert abgestimmt (Abstimmung).  Wofür ist es?  Es kann vorkommen, dass andere Knoten neuere Informationen erhalten haben und Daten zu derselben Transaktion haben. <br><br><img src="https://habrastorage.org/webt/4f/a8/ii/4fa8iiknak8jtumfh-kq3--yljs.png"><br><br>  Wenn der Knoten „Knoten 1“ eine eigene Nachricht sendet, überprüfen die verbleibenden Knoten die Daten für dieses Ereignis in ihren Protokollen.  Wenn es keine Widersprüche gibt, melden die Knoten: „Ja, ich habe keine weiteren Daten zu diesem Ereignis.  Der Wert "O" ist die neueste Information, die wir verdienen. " <br><br>  In jedem anderen Fall können die Knoten mit „Knoten 1“ antworten: „Hören!  Ich habe neuere Daten zu dieser Transaktion.  Nicht "Oh", sondern etwas Besseres. " <br><br>  In der Phase der Abstimmung treffen die Knoten eine Entscheidung: Entweder nimmt jeder den gleichen Wert an oder einer von ihnen stimmt dagegen, was darauf hinweist, dass er über neuere Daten verfügt. </li><li>  Wenn die Abstimmungsrunde erfolgreich war und alle dafür waren, bewegt sich das System in eine neue Phase - die Akzeptanz des Wertes (Akzeptieren).  "Knoten 1" sammelt alle Antworten anderer Knoten und meldet: "Alle stimmten dem Wert" O "zu!  Jetzt erkläre ich offiziell, dass "O" unsere neue Bedeutung ist, die für alle gleich ist!  Schreiben Sie sich in eine Broschüre, vergessen Sie nicht.  Schreiben Sie in Ihr Protokoll! " <br><br><img src="https://habrastorage.org/webt/q4/q3/dj/q4q3djt3usbjuxz5jktov7tki9u.png"></li><li>  Die verbleibenden Knoten senden eine Bestätigung (Akzeptiert), dass sie den Wert "O" notiert haben und in dieser Zeit nichts Neues tun konnten (eine Art zweiphasiges Festschreiben).  Nach diesem bedeutsamen Ereignis glauben wir, dass die verteilte Transaktion abgeschlossen ist. <br><img src="https://habrastorage.org/webt/ip/mi/hx/ipmihxdgotdz6dkggfeubcothkc.png"></li></ol><br>  Somit besteht der Konsensalgorithmus im einfachen Fall aus vier Schritten: Vorschlagen, Abstimmen, Akzeptieren, Bestätigen der Akzeptanz. <br><br>  Wenn wir irgendwann keine Einigung erzielen konnten, wird der Algorithmus neu gestartet, wobei die Informationen der Knoten berücksichtigt werden, die sich geweigert haben, den vorgeschlagenen Wert zu bestätigen. <br><br><h2>  Konsensalgorithmus in einem asynchronen System </h2><br>  Vorher war alles reibungslos, da es sich um ein synchrones Messaging-Modell handelte.  Aber wir wissen, dass wir in der modernen Welt daran gewöhnt sind, alles asynchron zu machen.  Wie funktioniert ein ähnlicher Algorithmus in einem System mit einem asynchronen Messaging-Modell, in dem wir glauben, dass die Wartezeit auf eine Antwort von einem Knoten beliebig lang sein kann (der Ausfall eines Knotens kann übrigens auch als Beispiel angesehen werden, wenn ein Knoten beliebig lange antworten kann). ) <br><br><blockquote>  Nachdem wir nun wissen, wie der Konsensalgorithmus im Grunde funktioniert, stellt sich die Frage für diejenigen neugierigen Leser, die diesen Punkt erreicht haben: Wie viele Knoten in einem System von N Knoten mit einem asynchronen Nachrichtenmodell können ausfallen, damit das System immer noch einen Konsens erreichen kann? </blockquote><br><div class="spoiler">  <b class="spoiler_title">Die richtige Antwort und Begründung hinter dem Spoiler.</b> <div class="spoiler_text">  Die richtige Antwort ist <b>0</b> .  Wenn mindestens ein Knoten im asynchronen System ausfällt, kann das System keinen Konsens erzielen.  Diese Behauptung wird in dem in bestimmten Kreisen bekannten FLP-Theorem bewiesen (1985, Fischer, Lynch, Paterson, Link zum Original am Ende des Artikels): „Die Unfähigkeit, einen verteilten Konsens zu erzielen, wenn mindestens ein Knoten ausfällt“. <br><img src="https://habrastorage.org/webt/bo/hm/1x/bohm1xpvycsoq2xbobtaje8xpfc.png"><br>  Leute, dann haben wir ein Problem, wir sind daran gewöhnt, dass alles mit uns asynchron ist.  Und hier ist es.  Wie kann man weiter leben? <br></div></div><br>  Wir sprechen jetzt über Theorie, über Mathematik.  Was bedeutet es, dass "kein Konsens erzielt werden kann", wenn man von einer mathematischen Sprache in unsere übersetzt - Ingenieurwesen?  Dies bedeutet, dass "nicht immer erreicht werden kann", d.h.  Es gibt einen Fall, in dem kein Konsens erzielt werden kann.  Und was ist das? <br><br>  Dies ist nur eine Verletzung der oben beschriebenen Lebendigkeitseigenschaft.  Wir haben keine allgemeine Vereinbarung, und das System kann nicht fortschreiten (kann nicht in einer begrenzten Zeit abgeschlossen werden), wenn wir nicht von allen Knoten eine Antwort haben.  Da wir in einem asynchronen System keine vorhersehbare Antwortzeit haben und nicht wissen können, ob der Knoten ausgefallen ist oder nur eine lange Antwortzeit benötigt. <br><br>  In der Praxis können wir jedoch eine Lösung finden.  Lassen Sie unseren Algorithmus bei Fehlern lange arbeiten (er kann möglicherweise endlos funktionieren).  In den meisten Situationen, in denen die meisten Knoten ordnungsgemäß funktionieren, haben wir Fortschritte im System. <br><br>  In der Praxis handelt es sich um teilweise synchrone Kommunikationsmodelle.  Partielle Synchronität wird wie folgt verstanden: Im allgemeinen Fall haben wir ein asynchrones Modell, aber formal führen wir ein bestimmtes Konzept der „globalen Stabilisierungszeit“ eines bestimmten Zeitpunkts ein. <br><br>  Dieser Zeitpunkt kann nicht so lange kommen, wie Sie möchten, aber eines Tages muss er kommen.  Ein virtueller Alarm ertönt und von nun an können wir das Zeitdelta vorhersagen, für das Nachrichten erreicht werden.  Ab diesem Moment wechselt das System von asynchron zu synchron.  In der Praxis haben wir es mit genau solchen Systemen zu tun. <br><br><h2>  Der Paxos-Algorithmus löst Konsensprobleme </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Paxos</a> ist eine Familie von Algorithmen, die das Konsensproblem für teilweise synchrone Systeme lösen, vorausgesetzt, einige Knoten können ausfallen.  Der Autor von Paxos ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Leslie Lamport</a> .  Er schlug 1989 einen formalen Beweis für die Existenz und Richtigkeit des Algorithmus vor. <br><br>  Aber der Beweis war keineswegs trivial.  Die erste Veröffentlichung wurde erst 1998 (33 Seiten) mit einer Beschreibung des Algorithmus veröffentlicht.  Wie sich herausstellte, war es äußerst schwer zu verstehen, und 2001 wurde eine Erklärung für den Artikel veröffentlicht, der 14 Seiten umfasste.  Die Bände der Veröffentlichungen sollen zeigen, dass das Problem des Konsenses in der Tat überhaupt nicht einfach ist und solche Algorithmen der enormen Arbeit der klügsten Leute unterliegen. <br><blockquote>  Es ist interessant, dass Leslie Lamport selbst in seinem Vortrag feststellte, dass es in der zweiten Artikelerklärung eine Aussage gibt, eine Zeile (nicht angegeben, welche), die unterschiedlich interpretiert werden kann.  Aus diesem Grund funktionieren viele moderne Paxos-Implementierungen nicht richtig. </blockquote><br>  Eine detaillierte Analyse der Arbeit von Paxos wird mehr als einen Artikel enthalten, daher werde ich versuchen, die Hauptidee des Algorithmus sehr kurz zu vermitteln.  In den Links am Ende meines Artikels finden Sie Materialien zum weiteren Eintauchen in dieses Thema. <br><br><h4>  Rollen in Paxos </h4><br>  Paxos hat ein Rollenkonzept.  Betrachten wir drei Hauptmerkmale (es gibt Änderungen mit zusätzlichen Rollen): <br><br><ol><li>  <b>Antragsteller (Begriffe können auch verwendet werden: Leiter oder Koordinatoren)</b> .  Dies sind die Leute, die vom Benutzer etwas über neue Bedeutungen lernen und die Rolle des Leiters übernehmen.  Ihre Aufgabe ist es, eine Runde von Vorschlägen von neuer Bedeutung zu starten und weitere Aktionen der Knoten zu koordinieren.  Darüber hinaus ermöglicht Paxos die Anwesenheit mehrerer Führungskräfte in bestimmten Situationen. </li><li>  <b>Akzeptoren (Wähler)</b> .  Dies sind die Knoten, die für die Annahme oder Ablehnung eines bestimmten Werts stimmen.  Ihre Rolle ist sehr wichtig, da die Entscheidung von ihnen abhängt: In welchem ​​Zustand wird das System nach der nächsten Stufe des Konsensalgorithmus gehen (oder nicht). </li><li>  <b>Lernende</b> .  Knoten, die den neuen akzeptierten Wert einfach akzeptieren und aufzeichnen, wenn sich der Status des Systems geändert hat.  Sie treffen keine Entscheidungen, sie empfangen einfach Daten und können diese dem Endbenutzer geben. </li></ol><br>  Ein Knoten kann mehrere Rollen in verschiedenen Situationen kombinieren. <br><br><h4>  Quorum-Konzept </h4><br>  Wir nehmen an, dass wir ein System von <b>N</b> Knoten haben.  Und von ihnen können maximal <b>F</b> Knoten ausfallen.  Wenn F-Knoten ausfallen, müssen mindestens <b>2F + 1-</b> Akzeptorknoten im Cluster vorhanden sein. <br><br>  Dies ist notwendig, damit wir auch in der schlimmsten Situation immer eine „gute“, korrekt funktionierende Knotenmehrheit haben.  Das heißt, <b>F + 1</b> "gute" Knoten, die vereinbart wurden, und der endgültige Wert wird akzeptiert.  Andernfalls kann es vorkommen, dass verschiedene lokale Gruppen unterschiedliche Bedeutungen annehmen und sich nicht einigen können.  Deshalb brauchen wir eine absolute Mehrheit, um die Abstimmung zu gewinnen. <br><br><h4>  Die allgemeine Idee des Paxos-Konsensalgorithmus </h4><br>  Der Paxos-Algorithmus umfasst zwei große Phasen, die wiederum in zwei Schritte unterteilt sind: <br><br><ol><li>  <b>Phase 1a: Vorbereiten</b> .  In der Vorbereitungsphase informiert der Leiter (Antragsteller) alle Knoten: „Wir beginnen eine neue Abstimmungsphase.  Wir haben eine neue Runde.  Die Nummer dieser Runde ist n.  Jetzt werden wir anfangen zu wählen. “  Derzeit wird lediglich der Beginn eines neuen Zyklus gemeldet, jedoch kein neuer Wert.  Die Aufgabe dieser Phase ist es, eine neue Runde einzuleiten und jedem seine eindeutige Nummer mitzuteilen.  Die runde Zahl ist wichtig, sie muss größer sein als alle vorherigen Abstimmungszahlen aller vorherigen Führer.  Da es genau der runden Zahl zu verdanken ist, werden andere Knoten im System verstehen, wie frisch der Leiter Daten hat.  Andere Knoten haben wahrscheinlich bereits Abstimmungsergebnisse aus viel späteren Runden und sie werden dem Anführer einfach sagen, dass er hinter der Zeit ist. </li><li>  <b>Phase 1b: Versprechen</b> .  Wenn die Akzeptorknoten die Nummer der neuen Abstimmungsstufe erhalten haben, sind zwei Ergebnisse möglich: <br><ul><li>  n   ,      ,    acceptor.  acceptor   ,            ,  n.  acceptor    -  (..       - ),           ,    . </li><li>   ,  acceptor       ,          . </li></ul></li><li> <b>Phase 2a: Accept</b> .       (   ) ,     ,        : <br><ul><li>   acceptor'  ,     .          c .    x,      : «Accept (n, x)»,    –       Propose,    –     , ..   , , . </li><li>    acceptor'    ,        ,        ,  ,      .   y.      : «Accept (n, y)»,     . </li></ul></li><li> <b>Phase 2b: Accepted</b> . , -acceptor',    «Accept(...)»,      (   ,      )    ,     - ()        <b>n' &gt; n</b> ,        . <br><br>     ,      ,     .  Hurra!        ,     ,    . </li></ol><br>     Paxos.        ,       ,      ,               . <br><br>   ,  Paxos —     ,    , , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Raft</a> ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . <br><br><h2>       </h2><br>  «»: <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">How Does Distributed Consensus Works?</a> , Preethi Kasireddy, blog article on Medium </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Paxos made simple. For real</a> , Adi Kancherla, blog article on Medium </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Decentralized Thoughts</a> , Ittai Abraham, blog </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Synchrony, Asynchrony and Partial synchrony</a> , Ittai Abraham, blog article </li></ul><br>  « »: <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Impossibility of Distributed Consensus with One Faulty Process (FLP impossibility)</a> , Fischer, Lynch and Paterson, research paper, 1985 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The Part-Time Parliament</a> , Leslie Lamport, research paper, 1998 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Paxos made simple</a> , Leslie Lamport, research paper, 2001 </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463469/">https://habr.com/ru/post/de463469/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463455/index.html">Tausende Dinge, die in Java ab Version 1 behoben werden müssen: ein großartiges Interview mit Sergey Kuksenko von Oracle</a></li>
<li><a href="../de463459/index.html">Versteckte Fehler bei Shared Element Transitions</a></li>
<li><a href="../de463461/index.html">Was ist und was nicht in Go. Teil 1</a></li>
<li><a href="../de463463/index.html">Methode zum Erstellen eines DRAG- und DROP-Effekts</a></li>
<li><a href="../de463465/index.html">Das Buch „Expressive JavaScript. Moderne Webprogrammierung. 3. Auflage</a></li>
<li><a href="../de463471/index.html">Funktionsumschaltung: Ansichten, Vorteile und Arbeiten mit ihnen in .NET</a></li>
<li><a href="../de463473/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 16. Networking in einem kleinen Büro</a></li>
<li><a href="../de463477/index.html">Ruhe: dBud-Ohrstöpsel mit zwei Geräuschreduzierungsstufen</a></li>
<li><a href="../de463481/index.html">Diskrete Mathematik für WMS: Algorithmus zum Komprimieren von Waren in Zellen (Teil 1)</a></li>
<li><a href="../de463483/index.html">Dokumentenkollaboration, aktualisierter Unternehmenschat und mobile App: Was ist neu in Zextras Suite 3.0?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>