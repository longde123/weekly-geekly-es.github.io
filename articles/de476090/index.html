<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚵🏻 👱 👇🏾 Gehen Sie, um 2FA in der Blockchain zu sichern 🕺🏻 👨🏻‍🔬 🤳🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="SMS-Nachrichten sind die beliebteste Methode zur Zwei-Faktor-Authentifizierung (2FA). Es wird von Banken, elektronischen und Krypto-Geldbörsen, Postfä...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gehen Sie, um 2FA in der Blockchain zu sichern</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476090/">  SMS-Nachrichten sind die beliebteste Methode zur Zwei-Faktor-Authentifizierung (2FA).  Es wird von Banken, elektronischen und Krypto-Geldbörsen, Postfächern und allen Arten von Diensten verwendet.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Anzahl der Benutzer der Methode nähert sich 100%</a> . <br><br>  Ich habe so einen Ausbruch von Ereignissen ist empörend, weil diese Methode unsicher ist.  Die Neuzuweisung der Nummer von einer SIM-Karte zu einer anderen begann zu Beginn des mobilen Zeitalters - auf diese Weise wird die Nummer wiederhergestellt, wenn die SIM-Karte verloren geht.  "Digital Money Weaning Specialists" realisiert: Die Option "SIM-Karten überschreiben" kann in betrügerischen Schemata eingesetzt werden.  Schließlich kann derjenige, der die SIM-Karte kontrolliert, das Online-Banking, die E-Wallets und sogar die Kryptowährung anderer verwalten.  Und Sie können die Nummer einer anderen Person übernehmen, indem Sie einen Telekommunikationsmitarbeiter mit Betrug oder gefälschten Dokumenten bestechen. <br><br><img src="https://habrastorage.org/webt/sm/lg/oh/smlgohi_vtrtginwsqvp3t2jqy8.png"><br><br>  Tausende von SIM-Tausch-Episoden wurden aufgedeckt - so wurde dieses Betrugsschema bezeichnet.  Das Ausmaß der Katastrophe lässt darauf schließen, dass die Welt die 2FA bald per SMS aufgeben wird.  Dies ist jedoch nicht der Fall - der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Studie</a> zufolge entscheiden sich nicht die Benutzer für die 2FA-Methode, sondern die Dienstleister. <br><br>  Wir empfehlen die Verwendung der sicheren 2FA-Methode mit der Übermittlung von Einmalcodes über die Blockchain. Anschließend erfahren Sie, wie Sie die Verbindung zum Service-Eigentümer herstellen können. <br><a name="habracut"></a><br><h2>  Die Rechnung geht an Millionen </h2><br>  Im Jahr 2019 stieg der SIM-Tauschbetrug nach Angaben der Londoner Polizei um 63%, und der „durchschnittliche Scheck“ des Angreifers betrug 4.000 GBP.  Ich habe in Russland keine Statistiken gefunden, aber ich gehe davon aus, dass es noch schlimmer ist. <br><br>  SIM-Tausch wird verwendet, um beliebte Twitter-, Instagram-, Facebook-, VK- und Bankkonten zu stehlen, und hat kürzlich Kryptowährungen erhalten, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">berichtet</a> die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeitung Times</a> vom Bitcoin-Unternehmer Joby Weeks.  Seit 2016 tauchen in der Presse bekannte Fälle von Diebstahl von Kryptowährungen mit Hilfe von SIM-Tausch auf.  2019 kam ein echter Höhepunkt. <br><br>  Im Mai verurteilten US-Staatsanwälte im Osten von Michigan neun Jugendliche im Alter von 19 bis 26 Jahren, die angeblich Teil einer Hacker-Bande namens „The Community“ waren.  Die Bande wird wegen sieben Swap-Angriffen angeklagt, wodurch Hacker Kryptowährung im Wert von mehr als 2,4 Millionen US-Dollar aneigneten.  Und im April wurde ein Student aus Kalifornien, Joel Ortiz, wegen SIM-Wechsels zu 10 Jahren Haft verurteilt.  Kryptowährungen in Höhe von 7,5 Millionen Dollar wurden zu seiner Beute. <br><br><img src="https://habrastorage.org/webt/xy/b4/61/xyb4614ligd5ao0hslycslmxq3u.jpeg"><br>  <i>Foto von Joel Ortiz auf einer Pressekonferenz der Universität.</i>  <i>Zwei Jahre später wird er wegen Cyberbetrugs inhaftiert.</i> <br><br><h2>  Das Prinzip des SIM-Wechsels </h2><br>  Swap bedeutet Austausch.  In all diesen Fällen weisen Kriminelle die Telefonnummer eines Opfers zu, in der Regel durch erneute Ausgabe einer SIM-Karte, und setzen damit ein Passwort zurück.  Ein typischer SIM-Tausch sieht theoretisch so aus: <br><br><ol><li>  Intelligenz.  Betrüger erfahren die persönlichen Daten des Opfers: Name und Telefon.  Sie können in offenen Quellen (sozialen Netzwerken, Freunden) gefunden oder von einem Komplizen - einem Mitarbeiter eines Mobilfunkbetreibers - bezogen werden. </li><li>  Blockieren.  Die SIM-Karte des Opfers ist deaktiviert.  Rufen Sie dazu einfach den technischen Support des Anbieters an, geben Sie die Nummer an und sagen Sie, dass das Telefon verloren gegangen ist. </li><li>  Erfassen, Übertragen von Nummern auf Ihre SIM-Karte.  In der Regel geschieht dies auch durch einen Komplizen in einem Telekommunikationsunternehmen oder durch Fälschen von Dokumenten. </li></ol><br>  Im wirklichen Leben ist es noch schlimmer.  Angreifer wählen ein Opfer aus und überwachen dann täglich den Standort des Telefons. Eine Informationsanfrage, die der Abonnent auf Roaming umgestellt hat, kostet 1-2 Cent.  Sobald der Inhaber der SIM-Karte ins Ausland gegangen ist, stimmt er mit dem Vorgesetzten im Kommunikationssalon der Herausgabe einer neuen SIM-Karte zu.  Es kostet ungefähr 50 US-Dollar (ich habe Informationen gefunden - in verschiedenen Ländern und von verschiedenen Betreibern von 20 bis 100 US-Dollar), während der Manager im schlimmsten Fall entlassen wird - es besteht keine Verantwortung. <br><br>  Jetzt erhalten alle Eindringlinge alle SMS, und der Besitzer des Telefons kann nichts dagegen tun - er ist im Ausland.  Und dann erhalten die Bösewichte Zugriff auf alle Konten des Opfers und ändern auf Wunsch die Passwörter. <br><br><h2>  Die Chancen, gestohlene Waren zurückzugeben </h2><br>  Banken gehen manchmal auf die Opfer zu und ziehen Überweisungen von ihren Konten ab.  Daher ist es möglich, fiat Geld zurückzugeben, auch wenn der Täter nicht gefunden wird.  Bei Cryptocurrency Wallets ist jedoch alles komplizierter - sowohl <i>technisch</i> als auch rechtlich.  Bisher hat kein Geldbeutel eine Entschädigung für Swap-Opfer gezahlt. <br><br>  Wenn die Opfer ihr Geld vor Gericht verteidigen wollen, beschuldigen sie den Betreiber: Er hat die Bedingungen für den Diebstahl von Geld vom Konto geschaffen.  Genau das hat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Michael Turpin getan</a> , der durch den Tausch 224 Millionen US-Dollar verloren hat. Jetzt verklagt er das Telekommunikationsunternehmen AT &amp; T. <br><br><img src="https://habrastorage.org/webt/1d/bx/cp/1dbxcp8cbskbzhc8dlpwm3rqggm.png"><br><br>  Bisher gibt es in keinem Staat Arbeitsschemata zum rechtlichen Schutz von Inhabern von Kryptowährungen.  Es ist unmöglich, Ihr Kapital zu versichern oder eine Entschädigung für dessen Verlust zu erhalten.  Daher ist es einfacher, einen Tauschangriff zu verhindern, als seine Folgen zu bekämpfen.  Der naheliegendste Weg ist die Verwendung eines zuverlässigeren „zweiten Faktors“ für 2FA. <br><br><h2>  Der SIM-Tausch ist nicht das einzige 2FA-Problem per SMS </h2><br>  Bestätigungscodes in SMS sind auch aus technischer Sicht unsicher.  Nachrichten können aufgrund schwerwiegender Sicherheitslücken in Signaling System 7 (SS7) abgefangen werden.  2FA by SMS ist offiziell als unsicher anerkannt (das US National Institute of Standards and Technology spricht darüber in seinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Digital Authentication Guide</a> ). <br><br>  Darüber hinaus wird der Benutzer durch das Vorhandensein von 2FA häufig mit einem Gefühl falscher Sicherheit angeregt, und er wählt ein einfacheres Kennwort.  Eine solche Authentifizierung erschwert daher nicht, erleichtert jedoch den Zugriff eines Angreifers auf das Konto. <br><br>  Und oftmals kommen SMS mit großer Verspätung oder gar nicht. <br><br><h2>  Andere 2FA-Methoden </h2><br>  Auf Smartphones und SMS konvergierte das Licht natürlich nicht.  Es gibt andere 2FA-Methoden.  Zum Beispiel einmalige TAN-Codes: Die Methode ist primitiv, funktioniert aber - sie wird in einigen Banken immer noch verwendet.  Es gibt Systeme, die biometrische Daten verwenden: Fingerabdrücke, Netzhaut-Scans.  Eine weitere Option, die hinsichtlich Komfort, Zuverlässigkeit und Preis als angemessener Kompromiss erscheint, sind spezielle Anwendungen für 2FA: RSA Token, Google Authenticator.  Und es gibt physikalische Schlüssel und andere Methoden. <br><br>  Theoretisch sieht alles logisch und zuverlässig aus.  In der Praxis haben moderne 2FA-Lösungen jedoch Probleme, und aufgrund dieser Probleme weicht die Realität von den Erwartungen ab. <br><br>  Laut der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Studie</a> ist die Verwendung von 2FA im Prinzip eine Unannehmlichkeit, und die Beliebtheit von 2FA per SMS erklärt sich aus „weniger Unannehmlichkeit im Vergleich zu anderen Methoden“ - das Empfangen von Einmalcodes ist für den Benutzer verständlich. <br><br>  Viele Benutzer von 2FA-Methoden gehen mit der Befürchtung einher, dass der Zugriff verloren geht.  Ein physischer Schlüssel oder eine Liste von TAN-Passwörtern kann verloren gehen oder gestohlen werden.  Ich persönlich habe eine negative Erfahrung mit Google Authenticator.  Mein erstes Smartphone mit dieser Anwendung ist kaputt gegangen - bewerten Sie meine Bemühungen, den Zugriff auf Konten wiederherzustellen.  Ein weiteres Problem ist der Übergang zu einem neuen Gerät.  Google Authenticator kann aufgrund von Sicherheitsbedenken nicht exportieren. (Welche Sicherheitsmaßnahmen gibt es, wenn die Schlüssel exportiert werden können?)  Einmal habe ich die Schlüssel manuell übertragen und dann entschieden, dass es einfacher ist, das alte Smartphone in einer Schachtel in einem Regal zu lassen. <br><br>  Die 2FA-Methode sollte sein: <br><br><ul><li>  Sicher - nur Sie sollten Zugriff auf Ihr Konto erhalten, nicht auf Angreifer </li><li>  Zuverlässig - Sie erhalten Zugriff auf Ihr Konto, wann immer Sie es benötigen </li><li>  Bequem und erschwinglich - die Verwendung von 2FA ist klar und erfordert nur ein Minimum an Zeit </li><li>  Günstig </li></ul><br>  Wir glauben, dass Blockchain die richtige Lösung ist. <br><br><h2>  Verwenden Sie 2FA für die Blockchain </h2><br>  Für einen Benutzer entspricht 2FA in der Blockchain dem Empfangen von Einmalcodes per SMS.  Der einzige Unterschied besteht im Lieferkanal.  Wie Sie einen 2FA-Code erhalten, hängt davon ab, was die Blockchain bietet.  In unserem Projekt (die Informationen befinden sich in meinem Profil) ist dies eine Webanwendung, Tor, iOS, Android, Linux, Windows, MacOS. <br><br>  Der Dienst generiert einen einmaligen Code und sendet ihn an den Messenger in der Blockchain.  Weiter nach den Klassikern: Der Benutzer gibt den empfangenen Code in die Serviceschnittstelle ein und meldet sich an. <br><br><img src="https://habrastorage.org/webt/4a/yq/ph/4ayqphaul5iozz1f_v2g0q4ziqw.png"><br><br>  In dem Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie ein dezentraler Messenger in der Blockchain funktioniert, habe</a> ich geschrieben, dass die Blockchain die Sicherheit und den Datenschutz von Nachrichten gewährleistet.  Zum Thema Versenden von 2FA-Codes möchte ich Folgendes hervorheben: <br><br><ul><li>  Ein Klick, um ein Konto zu erstellen - keine Telefone oder E-Mails. </li><li>  Alle Nachrichten mit 2FA-Codes werden durchgängig verschlüsselt. Curve25519xsalsa20poly1305. </li><li>  MITM-Angriff ist ausgeschlossen - jede Nachricht mit einem 2FA-Code ist eine Transaktion in der Blockchain und wird von Ed25519 EdDSA signiert. </li><li>  Eine Nachricht mit einem 2FA-Code fällt in ihren Block.  Die Reihenfolge und der Zeitstempel der Blöcke und damit die Reihenfolge der Nachrichten können nicht festgelegt werden. </li><li>  Es gibt keine zentrale Struktur, die die „Authentizität“ einer Nachricht überprüft.  Dies geschieht durch ein konsensbasiertes verteiltes Knotensystem, das den Benutzern gehört. </li><li>  Unfähigkeit zu deaktivieren - Konten können nicht gesperrt werden und Nachrichten können gelöscht werden. </li><li>  Greifen Sie jederzeit von jedem Gerät auf 2FA-Codes zu. </li><li>  Zustellbestätigungsnachricht mit 2FA-Code.  Ein Dienst, der ein Einmalkennwort sendet, weiß, dass es übermittelt wurde.  Keine Schaltfläche "Erneut senden". </li></ul><br>  Zum Vergleich mit anderen 2FA-Methoden habe ich eine Tabelle zusammengestellt: <br><br><img src="https://habrastorage.org/webt/pl/am/tm/plamtmeiv5xnjmupd5bevfrpftu.png"><br><br>  Der Benutzer erhält ein Konto im Blockchain-Messenger, um Codes in einer zweiten Passphrase zu erhalten, die nur zur Eingabe verwendet wird.  Daher können die Anwendungsmethoden unterschiedlich sein: Sie können ein Konto verwenden, um Codes für alle Dienste abzurufen, oder Sie können für jeden Dienst ein separates Konto erstellen. <br><br>  Es gibt auch einen Nachteil - ein Konto muss mindestens eine Transaktion haben.  Damit der Benutzer eine verschlüsselte Nachricht mit einem Code erhalten kann, muss er seinen öffentlichen Schlüssel kennen und wird erst bei der ersten Transaktion in der Blockchain angezeigt.  Wir sind auf diese Weise rausgekommen: Sie gaben uns die Möglichkeit, kostenlose Jetons in unserer Brieftasche zu bekommen.  Eine korrektere Lösung besteht jedoch darin, dem Konto einen öffentlichen Schlüssel zu geben.  (Unsere Kontonummer <i>U1467838112172792705</i> ist zum Vergleich eine Ableitung des öffentlichen Schlüssels <i>cc1ca549413b942029c4742a6e6ed69767c325f8d989f7e4b71ad82a164c2ada</i> . Für den Messenger ist dies praktischer und lesbarer, für das sendende System jedoch 2FA-Codes.)  Ich denke, in Zukunft wird jemand eine solche Entscheidung treffen und "Bequemlichkeit und Zugänglichkeit" in die grüne Zone transferieren. <br><br>  Die Kosten für den Versand eines 2FA-Codes sind sehr niedrig - 0,001 ADM, jetzt sind es 0,00001 USD.  Auch hier können Sie Ihre Blockchain erhöhen und den Preis auf Null setzen. <br><br><h2>  So verbinden Sie 2FA in der Blockchain mit Ihrem Dienst </h2><br>  Ich hoffe, ich konnte einige Leser dafür interessieren, ihren Diensten eine Blockchain-Autorisierung hinzuzufügen. <br><br>  Ich werde Ihnen am Beispiel unseres Boten erklären, wie das geht, und analog dazu können Sie eine andere Blockchain verwenden.  In der 2FA-Demo-Anwendung verwenden wir postgresql10, um Kontoinformationen zu speichern. <br><br>  Verbindungsschritte: <br><br><ol><li>  Erstellen Sie ein Konto in der Blockchain, von der aus Sie 2FA-Codes senden.  Sie erhalten ein Passwort, das als privater Schlüssel zum Verschlüsseln von Nachrichten mit Codes und zum Signieren von Transaktionen verwendet wird. </li><li>  Fügen Sie Ihrem Server ein Skript hinzu, um 2FA-Codes zu generieren.  Wenn Sie bereits eine andere 2FA-Methode mit der Übermittlung von Einmalkennwörtern verwenden, wurde dieser Schritt bereits abgeschlossen. </li><li>  Fügen Sie Ihrem Server ein Skript hinzu, um Codes im Blockchain Messenger an den Benutzer zu senden. </li><li>  Erstellen Sie eine Benutzeroberfläche zum Senden und Eingeben von 2FA-Code.  Wenn Sie bereits eine andere 2FA-Methode mit der Übermittlung von Einmalkennwörtern verwenden, wurde dieser Schritt bereits abgeschlossen. </li></ol><br>  <b>1 Erstellen Sie ein Konto</b> <br><br>  Das Erstellen eines Kontos in der Blockchain besteht aus der Generierung eines privaten Schlüssels, eines öffentlichen Schlüssels und einer daraus abgeleiteten Kontoadresse. <br><br><img src="https://habrastorage.org/webt/7o/at/vs/7oatvsalils_l9wsl8av5cjqtkc.png"><br><br>  Zunächst wird die Passphrase BIP39 generiert, aus der der SHA-256-Hash berechnet wird.  Der Hash wird verwendet, um den privaten ks-Schlüssel und den öffentlichen kp-Schlüssel zu generieren.  Vom öffentlichen Schlüssel mit demselben SHA-256 mit Inversion erhalten wir die Adresse in der Blockchain. <br><br>  Wenn Sie jedes Mal 2FA-Codes von einem neuen Konto senden möchten, muss der Code zum Erstellen eines Kontos zum Server hinzugefügt werden: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Mnemonic <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'bitcore-mnemonic'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.passphrase = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mnemonic(Mnemonic.Words.ENGLISH).toString() … <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> bip39 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'bip39'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> crypto <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'crypto'</span></span> adamant.createPassphraseHash = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">passphrase</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> seedHex = bip39.mnemonicToSeedSync(passphrase).toString(<span class="hljs-string"><span class="hljs-string">'hex'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> crypto.createHash(<span class="hljs-string"><span class="hljs-string">'sha256'</span></span>).update(seedHex, <span class="hljs-string"><span class="hljs-string">'hex'</span></span>).digest() } … <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sodium <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'sodium-browserify-tweetnacl'</span></span> adamant.makeKeypair = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">hash</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keypair = sodium.crypto_sign_seed_keypair(hash) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">publicKey</span></span>: keypair.publicKey, <span class="hljs-attr"><span class="hljs-attr">privateKey</span></span>: keypair.secretKey } } … <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> crypto <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'crypto'</span></span> adamant.getAddressFromPublicKey = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">publicKey</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> publicKeyHash = crypto.createHash(<span class="hljs-string"><span class="hljs-string">'sha256'</span></span>).update(publicKey, <span class="hljs-string"><span class="hljs-string">'hex'</span></span>).digest() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> temp = Buffer.alloc(<span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++) { temp[i] = publicKeyHash[<span class="hljs-number"><span class="hljs-number">7</span></span> - i] } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'U'</span></span> + bignum.fromBuffer(temp).toString() }</code> </pre> <br>  In der Demo-Anwendung haben wir es vereinfacht - ein Konto in der Webanwendung erstellt und die Codes von dort gesendet.  In den meisten Fällen ist dies für den Benutzer bequemer: Er weiß, dass der Dienst 2FA-Codes von einem bestimmten Konto sendet und diesen benennen kann. <br><br><img src="https://habrastorage.org/webt/j6/0p/pi/j60ppi_a1zvkc-ifcrdxkaz8ow8.png"><br><br>  <b>2 Erzeugung von 2FA-Codes</b> <br><br>  Der 2FA-Code muss für jede Benutzeranmeldung generiert werden.  Wir benutzen die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speakeasy-</a> Bibliothek, aber Sie können auch eine andere auswählen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hotp = speakeasy.hotp({ counter, <span class="hljs-attr"><span class="hljs-attr">secret</span></span>: account.seSecretAscii, });</code> </pre><br>  Validierung des vom Benutzer eingegebenen 2FA-Codes: <br><br><pre> <code class="javascript hljs">se2faVerified = speakeasy.hotp.verify({ <span class="hljs-attr"><span class="hljs-attr">counter</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.seCounter, <span class="hljs-attr"><span class="hljs-attr">secret</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.seSecretAscii, <span class="hljs-attr"><span class="hljs-attr">token</span></span>: hotp, });</code> </pre><br>  <b>3 Reichen Sie den 2FA-Code ein</b> <br><br>  Sie können die Blockchain-Knoten-API, die JS-API-Bibliothek oder die Konsole zum Senden von 2FA-Code verwenden.  In diesem Beispiel verwenden wir die Konsole - dies ist die Befehlszeilenschnittstelle, ein Dienstprogramm, das die Interaktion mit der Blockchain vereinfacht.  Um eine Nachricht mit einem 2FA-Code zu senden, müssen Sie den Befehl <code>send message</code> der Konsole verwenden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> util = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'util'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> exec = util.promisify(<span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'child_process'</span></span>).exec); … <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> command = <span class="hljs-string"><span class="hljs-string">`adm send message </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${adamantAddress}</span></span></span><span class="hljs-string"> "2FA code: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${hotp}</span></span></span><span class="hljs-string">"`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> { error, stdout, stderr } = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> exec(command);</code> </pre><br>  Eine alternative Methode zum Senden von Nachrichten ist die Verwendung der <code>send</code> Methode in der JS-API-Bibliothek. <br><br>  <b>4 Benutzeroberfläche</b> <br><br>  Dem Benutzer muss die Möglichkeit gegeben werden, den 2FA-Code einzugeben. Dies kann abhängig von der Plattform Ihrer Anwendung auf verschiedene Arten erfolgen.  In unserem Beispiel ist dies Vue. <br><br><img src="https://habrastorage.org/webt/1g/yb/yv/1gybyvcmjucrqilrcpo74k8onoy.png"><br><br>  Der Quellcode der Demo-Anwendung der Zwei-Faktor-Autorisierung in der Blockchain kann auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> eingesehen werden.  In der Readme-Datei finden Sie einen Link zur Live-Demo, über den Sie es ausprobieren können. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de476090/">https://habr.com/ru/post/de476090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de476060/index.html">Neuigkeiten aus der Welt von OpenStreetMap Nr. 485 (29.10.2019 - 11.04.2019)</a></li>
<li><a href="../de476074/index.html">Selbstgemachtes Elektroauto - Teil 1</a></li>
<li><a href="../de476076/index.html">Zu sauber</a></li>
<li><a href="../de476082/index.html">Array.splice und Array.slice in JavaScript</a></li>
<li><a href="../de476088/index.html">BLACK HAT USA Konferenz. Reich werden oder sterben: Mit Black Hat Geld im Internet verdienen. Teil 1</a></li>
<li><a href="../de476092/index.html">Über die Richtungen "Photonics", "Programming and IT" und "Information and Cybersecurity" der Olympiade "I am a Professional"</a></li>
<li><a href="../de476094/index.html">Die Rückkehr des Zeitalters der Imperien: Alles über das Zeitalter der Imperien IV</a></li>
<li><a href="../de476096/index.html">Inventar von I bis Z. Wir betrachten IT-Assets</a></li>
<li><a href="../de476098/index.html">Datenstrukturen in Java. Nützliche Hilfsklassenmethoden</a></li>
<li><a href="../de476100/index.html">Architektur von Computersystemen 1 Teil. Logikgatter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>