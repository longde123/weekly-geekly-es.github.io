<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏠 💱 🧔🏻 Primeros pasos con Unicorn Engine 👍🏾 🍚 🏇🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Al buscar "Unicorn Engine" en Habr, me sorprendió descubrir que esta herramienta nunca ha aparecido en los artículos. Intentaré llenar este vacío. Com...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Primeros pasos con Unicorn Engine</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431058/"><p>  Al buscar "Unicorn Engine" en Habr, me sorprendió descubrir que esta herramienta nunca ha aparecido en los artículos.  Intentaré llenar este vacío.  Comencemos con lo básico y veamos un ejemplo del uso del emulador en la vida real.  Para no reinventar la rueda, decidí simplemente traducir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> manual.  <em>Antes de comenzar, diré que todos mis comentarios o comentarios se verán así</em> . </p><a name="habracut"></a><br><h1 id="chto-takoe-unicorn-engine">  ¿Qué es un motor de unicornio? </h1><br><p>  <em>Los propios desarrolladores escriben sobre</em> <del>  <em>Motor de unicornio</em> </del>  <em>Unicorn Engine como este:</em> </p><br><blockquote>  Unicorn es un emulador de procesador ligero, multiplataforma y de arquitectura múltiple. </blockquote><p>  Este no es un emulador estándar.  No emula la operación de todo el programa o el sistema operativo completo.  No admite comandos del sistema (como abrir un archivo, generar un carácter en la consola, etc.).  Tendrá que hacer el marcado de la memoria y cargar los datos usted mismo, y luego simplemente comenzará la ejecución desde alguna dirección específica. </p><br><p>  Entonces, ¿cómo es útil? </p><br><ul><li>  Al analizar virus, puede llamar a funciones individuales sin crear un proceso malicioso. </li><li>  Para resolver CTF. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Por fuzzing</a> . </li><li>  <a href="">Un complemento para gdb</a> para predecir el estado futuro, por ejemplo, saltos futuros o valores de registro. </li><li>  Emulación de un código rico en funciones. </li></ul><br><p>  Que necesitas </p><br><ul><li>  Motor Unicornio instalado con enlace Python. </li><li>  Desensamblador </li></ul><br><h1 id="primer">  Ejemplo </h1><br><p>  Como ejemplo, realice una tarea con hxp CTF 2017 bajo el nombre de <strong><em>Fibonacci</em></strong> .  El binario se puede descargar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . </p><br><p>  Cuando inicia el programa, comienza a mostrar nuestra bandera en la consola, pero muy lentamente.  Cada byte de bandera posterior se considera cada vez más lento. </p><br><pre><code class="bash hljs">The flag is: hxp{F</code> </pre> <br><p>  Esto significa que para obtener la bandera en un período de tiempo razonable, necesitamos optimizar el funcionamiento de esta aplicación. </p><br><p>  Usando IDA Pro ( <em>yo personalmente usé radare2 + Cutter</em> ) descompilamos el código en un pseudocódigo tipo C.  A pesar de que el código no se descompiló correctamente, aún podemos obtener información sobre lo que está sucediendo en su interior. </p><br><div class="spoiler">  <b class="spoiler_title">Código descompilado</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__int64 __<span class="hljs-function"><span class="hljs-function">fastcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__int64 a1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **a2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **a3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *v3; <span class="hljs-comment"><span class="hljs-comment">// rbp@1 int v4; // ebx@1 signed __int64 v5; // r8@2 char v6; // r9@3 __int64 v7; // r8@3 char v8; // cl@3 __int64 v9; // r9@5 int a2a; // [sp+Ch] [bp-1Ch]@3 v3 = &amp;encrypted_flag; v4 = 0; setbuf(stdout, 0LL); printf("The flag is: ", 0LL); while ( 1 ) { LODWORD(v5) = 0; do { a2a = 0; fibonacci(v4 + v5, &amp;a2a); v8 = v7; v5 = v7 + 1; } while ( v5 != 8 ); v4 += 8; if ( (unsigned __int8)(a2a &lt;&lt; v8) == v6 ) break; v3 = (char *)v3 + 1; _IO_putc((char)(v6 ^ ((_BYTE)a2a &lt;&lt; v8)), stdout); v9 = *((char *)v3 - 1); } _IO_putc(10, stdout); return 0LL; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">fastcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fibonacci</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, _DWORD *a2)</span></span></span><span class="hljs-function"> </span></span>{ _DWORD *v2; <span class="hljs-comment"><span class="hljs-comment">// rbp@1 unsigned int v3; // er12@3 unsigned int result; // eax@3 unsigned int v5; // edx@3 unsigned int v6; // esi@3 unsigned int v7; // edx@4 v2 = a2; if ( i ) { if ( i == 1 ) { result = fibonacci(0, a2); v5 = result - ((result &gt;&gt; 1) &amp; 0x55555555); v6 = ((result - ((result &gt;&gt; 1) &amp; 0x55555555)) &gt;&gt; 2) &amp; 0x33333333; } else { v3 = fibonacci(i - 2, a2); result = v3 + fibonacci(i - 1, a2); v5 = result - ((result &gt;&gt; 1) &amp; 0x55555555); v6 = ((result - ((result &gt;&gt; 1) &amp; 0x55555555)) &gt;&gt; 2) &amp; 0x33333333; } v7 = v6 + (v5 &amp; 0x33333333) + ((v6 + (v5 &amp; 0x33333333)) &gt;&gt; 4); *v2 ^= ((BYTE1(v7) &amp; 0xF) + (v7 &amp; 0xF) + (unsigned __int8)((((v7 &gt;&gt; 8) &amp; 0xF0F0F) + (v7 &amp; 0xF0F0F0F)) &gt;&gt; 16)) &amp; 1; } else { *a2 ^= 1u; result = 1; } return result; }</span></span></code> </pre> </div></div><br><p>  Aquí está el código de ensamblador de las funciones <em>principales</em> y de <em>Fibonacci</em> : </p><br><div class="spoiler">  <b class="spoiler_title">principal</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">.text:0x4004E0 main proc near ; DATA XREF: start+1Do .text:0x4004E0 .text:0x4004E0 var_1C = dword ptr -1Ch .text:0x4004E0 .text:0x4004E0 push rbp .text:0x4004E1 push rbx .text:0x4004E2 xor esi, esi ; buf .text:0x4004E4 mov ebp, offset unk_4007E1 .text:0x4004E9 xor ebx, ebx .text:0x4004EB sub rsp, 18h .text:0x4004EF mov rdi, cs:stdout ; stream .text:0x4004F6 call _setbuf .text:0x4004FB mov edi, offset format ; "The flag is: " .text:0x400500 xor eax, eax .text:0x400502 call _printf .text:0x400507 mov r9d, 49h .text:0x40050D nop dword ptr [rax] .text:0x400510 .text:0x400510 loc_400510: ; CODE XREF: main+8Aj .text:0x400510 xor r8d, r8d .text:0x400513 jmp short loc_40051B .text:0x400513 ; --------------------------------------------------------------------------- .text:0x400515 align 8 .text:0x400518 .text:0x400518 loc_400518: ; CODE XREF: main+67j .text:0x400518 mov r9d, edi .text:0x40051B .text:0x40051B loc_40051B: ; CODE XREF: main+33j .text:0x40051B lea edi, [rbx+r8] .text:0x40051F lea rsi, [rsp+28h+var_1C] .text:0x400524 mov [rsp+28h+var_1C], 0 .text:0x40052C call fibonacci .text:0x400531 mov edi, [rsp+28h+var_1C] .text:0x400535 mov ecx, r8d .text:0x400538 add r8, 1 .text:0x40053C shl edi, cl .text:0x40053E mov eax, edi .text:0x400540 xor edi, r9d .text:0x400543 cmp r8, 8 .text:0x400547 jnz short loc_400518 .text:0x400549 add ebx, 8 .text:0x40054C cmp al, r9b .text:0x40054F mov rsi, cs:stdout ; fp .text:0x400556 jz short loc_400570 .text:0x400558 movsx edi, dil ; c .text:0x40055C add rbp, 1 .text:0x400560 call __IO_putc .text:0x400565 movzx r9d, byte ptr [rbp-1] .text:0x40056A jmp short loc_400510 .text:0x40056A ; --------------------------------------------------------------------------- .text:0x40056C align 10h .text:0x400570 .text:0x400570 loc_400570: ; CODE XREF: main+76j .text:0x400570 mov edi, 0Ah ; c .text:0x400575 call __IO_putc .text:0x40057A add rsp, 18h .text:0x40057E xor eax, eax .text:0x400580 pop rbx .text:0x400581 pop rbp .text:0x400582 retn .text:0x400582 main endp</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">fibonacci</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">.text:0x400670 fibonacci proc near ; CODE XREF: main+4Cp .text:0x400670 ; fibonacci+19p ... .text:0x400670 test edi, edi .text:0x400672 push r12 .text:0x400674 push rbp .text:0x400675 mov rbp, rsi .text:0x400678 push rbx .text:0x400679 jz short loc_4006F8 .text:0x40067B cmp edi, 1 .text:0x40067E mov ebx, edi .text:0x400680 jz loc_400710 .text:0x400686 lea edi, [rdi-2] .text:0x400689 call fibonacci .text:0x40068E lea edi, [rbx-1] .text:0x400691 mov r12d, eax .text:0x400694 mov rsi, rbp .text:0x400697 call fibonacci .text:0x40069C add eax, r12d .text:0x40069F mov edx, eax .text:0x4006A1 mov ebx, eax .text:0x4006A3 shr edx, 1 .text:0x4006A5 and edx, 55555555h .text:0x4006AB sub ebx, edx .text:0x4006AD mov ecx, ebx .text:0x4006AF mov edx, ebx .text:0x4006B1 shr ecx, 2 .text:0x4006B4 and ecx, 33333333h .text:0x4006BA mov esi, ecx .text:0x4006BC .text:0x4006BC loc_4006BC: ; CODE XREF: fibonacci+C2j .text:0x4006BC and edx, 33333333h .text:0x4006C2 lea ecx, [rsi+rdx] .text:0x4006C5 mov edx, ecx .text:0x4006C7 shr edx, 4 .text:0x4006CA add edx, ecx .text:0x4006CC mov esi, edx .text:0x4006CE and edx, 0F0F0F0Fh .text:0x4006D4 shr esi, 8 .text:0x4006D7 and esi, 0F0F0Fh .text:0x4006DD lea ecx, [rsi+rdx] .text:0x4006E0 mov edx, ecx .text:0x4006E2 shr edx, 10h .text:0x4006E5 add edx, ecx .text:0x4006E7 and edx, 1 .text:0x4006EA xor [rbp+0], edx .text:0x4006ED pop rbx .text:0x4006EE pop rbp .text:0x4006EF pop r12 .text:0x4006F1 retn .text:0x4006F1 ; --------------------------------------------------------------------------- .text:0x4006F2 align 8 .text:0x4006F8 .text:0x4006F8 loc_4006F8: ; CODE XREF: fibonacci+9j .text:0x4006F8 mov edx, 1 .text:0x4006FD xor [rbp+0], edx .text:0x400700 mov eax, 1 .text:0x400705 pop rbx .text:0x400706 pop rbp .text:0x400707 pop r12 .text:0x400709 retn .text:0x400709 ; --------------------------------------------------------------------------- .text:0x40070A align 10h .text:0x400710 .text:0x400710 loc_400710: ; CODE XREF: fibonacci+10j .text:0x400710 xor edi, edi .text:0x400712 call fibonacci .text:0x400717 mov edx, eax .text:0x400719 mov edi, eax .text:0x40071B shr edx, 1 .text:0x40071D and edx, 55555555h .text:0x400723 sub edi, edx .text:0x400725 mov esi, edi .text:0x400727 mov edx, edi .text:0x400729 shr esi, 2 .text:0x40072C and esi, 33333333h .text:0x400732 jmp short loc_4006BC .text:0x400732 fibonacci endp</code> </pre> </div></div><br><p>  En esta etapa, tenemos muchas oportunidades para resolver este problema.  Por ejemplo, podemos restaurar el código usando uno de los lenguajes de programación y aplicar la optimización allí, pero el proceso de recuperación del código es una tarea muy difícil, durante la cual podemos cometer errores.  Bueno, entonces comparar el código para encontrar el error generalmente no tiene valor.  Pero, si usamos el Unicorn Engine, podemos omitir la etapa de reconstrucción del código y evitar el problema descrito anteriormente.  Por supuesto, podemos evitar estos problemas usando frida o escribiendo scripts para gdb, pero no se trata de eso. </p><br><p>  Antes de comenzar la optimización, ejecutaremos la emulación en Unicorn Engine sin cambiar el programa.  Y solo después de un lanzamiento exitoso, pasemos a la optimización. </p><br><h2 id="shag-1-da-priydet-virtualizaciya">  Paso 1: deje que venga la virtualización </h2><br><p>  Creemos el archivo fibonacci.py y guárdelo junto al binario. </p><br><p>  Comencemos importando las bibliotecas requeridas: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unicorn <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unicorn.x86_const <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> struct</code> </pre> <br><p>  La primera línea carga las constantes Unicornio binarias y básicas principales.  La segunda línea carga las constantes para las dos arquitecturas x86 y x86_64. </p><br><p>  A continuación, agregue algunas funciones necesarias: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(name) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f.read() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">u32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> struct.unpack(<span class="hljs-string"><span class="hljs-string">"I"</span></span>, data)[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> struct.pack(<span class="hljs-string"><span class="hljs-string">"I"</span></span>, num)</code> </pre> <br><p>  Aquí anunciamos las funciones que necesitaremos más adelante: </p><br><ul><li>  <strong>leer</strong> simplemente devuelve el contenido del archivo, </li><li>  <strong>u32</strong> toma una cadena de 4 bytes en la codificación LE y la convierte a int, </li><li>  <strong>p32</strong> hace lo contrario: toma un número y lo convierte en una cadena de 4 bytes en la codificación LE. </li></ul><br><p>  Nota: Si ha instalado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pwntools</a> , entonces no necesita crear estas funciones, solo necesita importarlas: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pwn <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> *</code> </pre> <br><p>  Y así, finalmente, comencemos a inicializar nuestra clase Unicorn Engine para la arquitectura x86_64: </p><br><pre> <code class="python hljs">mu = Uc (UC_ARCH_X86, UC_MODE_64)</code> </pre> <br><p>  Aquí llamamos a las funciones <strong>Uc</strong> con los siguientes parámetros: </p><br><ul><li>  El primer parámetro es la arquitectura principal.  Las constantes comienzan con <strong>UC_ARCH_</strong> ; </li><li>  El segundo parámetro es la especificación de la arquitectura.  Las constantes comienzan con <strong>UC_MODE_</strong> . </li></ul><br><p>  Puedes encontrar todas las constantes en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hoja de trucos</a> . </p><br><p>  Como escribí anteriormente, para usar el motor Unicorn, necesitamos inicializar la memoria virtual manualmente.  Para este ejemplo, necesitamos colocar el código y la pila en algún lugar de la memoria. </p><br><p>  La dirección base (Base addr) del binario comienza en 0x400000.  Pongamos nuestra pila en 0x0 y asignemos 1024 * 1024 memoria para ello.  Lo más probable es que no necesitemos tanto espacio, pero aún así no duele. </p><br><p>  Podemos marcar la memoria llamando al método <strong>mem_map</strong> . </p><br><p>  Agregue estas líneas: </p><br><pre> <code class="python hljs">BASE = <span class="hljs-number"><span class="hljs-number">0x400000</span></span> STACK_ADDR = <span class="hljs-number"><span class="hljs-number">0x0</span></span> STACK_SIZE = <span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span> mu.mem_map(BASE, <span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>) mu.mem_map(STACK_ADDR, STACK_SIZE)</code> </pre> <br><p>  Ahora necesitamos cargar el binario en su dirección principal de la misma manera que lo hace el gestor de arranque.  Después de eso, necesitamos establecer <strong>RSP</strong> al final de la pila. </p><br><pre> <code class="python hljs">mu.mem_write(BASE, read(<span class="hljs-string"><span class="hljs-string">"./fibonacci"</span></span>)) mu.reg_write(UC_X86_REG_RSP, STACK_ADDR + STACK_SIZE - <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  Ahora podemos comenzar la emulación y ejecutar el código, pero necesitamos averiguar con qué dirección comenzar a trabajar y cuándo debe detenerse el emulador. </p><br><p>  Tome la dirección del primer comando de <strong>main ()</strong> , podemos comenzar la emulación desde 0x004004e0.  El final se considerará una llamada a <strong>putc ("\ n")</strong> , que se encuentra en 0x00400575, después de mostrar la bandera completa. </p><br><pre> <code class="plaintext hljs">.text:0x400570 mov edi, 0Ah ; c .text:0x400575 call __IO_putc</code> </pre> <br><p>  Podemos comenzar a emular: </p><br><pre> <code class="python hljs">mu.emu_start(<span class="hljs-number"><span class="hljs-number">0x004004e0</span></span>,<span class="hljs-number"><span class="hljs-number">0x00400575</span></span>)</code> </pre> <br><p>  Ahora ejecuta el script: </p><br><pre> <code class="bash hljs">a@x:~/Desktop/unicorn_engine_lessons$ python solve.py Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"solve.py"</span></span>, line 32, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; mu.emu_start(0x00000000004004E0, 0x0000000000400575) File <span class="hljs-string"><span class="hljs-string">"/usr/local/lib/python2.7/dist-packages/unicorn/unicorn.py"</span></span>, line 288, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> emu_start raise UcError(status) unicorn.unicorn.UcError: Invalid memory <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> (UC_ERR_READ_UNMAPPED)</code> </pre> <br><p>  Vaya, algo salió mal, pero ni siquiera sabemos qué.  Justo antes de llamar a <strong>mu.emu_start,</strong> podemos agregar: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hook_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mu, address, size, user_data)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">'&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x'</span></span> %(address, size)) mu.hook_add(UC_HOOK_CODE, hook_code)</code> </pre> <br><p>  Este código agrega un gancho.  Declaramos nuestra propia función <strong>hook_code</strong> , que el emulador llama antes de cada comando.  Toma los siguientes parámetros: </p><br><ul><li>  nuestra copia de <strong>Uc</strong> , </li><li>  dirección de instrucciones </li><li>  instrucciones de tamaño </li><li>  datos de usuario (podemos pasar este valor con un argumento opcional a <strong>hook_add ()</strong> ). <br>  Ahora, si ejecutamos el script, deberíamos ver el siguiente resultado: <br><pre> <code class="bash hljs">a@x:~/Desktop/unicorn_engine_lessons$ python solve.py &gt;&gt;&gt; Tracing instruction at 0x4004e0, instruction size = 0x1 &gt;&gt;&gt; Tracing instruction at 0x4004e1, instruction size = 0x1 &gt;&gt;&gt; Tracing instruction at 0x4004e2, instruction size = 0x2 &gt;&gt;&gt; Tracing instruction at 0x4004e4, instruction size = 0x5 &gt;&gt;&gt; Tracing instruction at 0x4004e9, instruction size = 0x2 &gt;&gt;&gt; Tracing instruction at 0x4004eb, instruction size = 0x4 &gt;&gt;&gt; Tracing instruction at 0x4004ef, instruction size = 0x7 Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"solve.py"</span></span>, line 41, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; mu.emu_start(0x00000000004004E0, 0x0000000000400575) File <span class="hljs-string"><span class="hljs-string">"/usr/local/lib/python2.7/dist-packages/unicorn/unicorn.py"</span></span>, line 288, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> emu_start raise UcError(status) unicorn.unicorn.UcError: Invalid memory <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> (UC_ERR_READ_UNMAPPED)</code> </pre> <br><p>  En la dirección donde ocurrió el error, podemos entender que nuestro script no puede procesar este comando: <br></p><pre> <code class="plaintext hljs">.text:0x4004EF mov rdi, cs:stdout ; stream</code> </pre> <br><p>  Esta instrucción lee datos de la dirección 0x601038 (puede verlos en IDA Pro).  Esta es la sección <strong>.bss</strong> que no marcamos.  Mi solución sería simplemente omitir todas las instrucciones problemáticas si esto no afecta la lógica del programa. <br>  A continuación hay otra instrucción problemática: <br></p><pre> <code class="plaintext hljs">.text:0x4004F6 call _setbuf</code> </pre> <br><p>  No podemos llamar a ninguna función con glibc, ya que no tenemos glibc cargado en la memoria.  En cualquier caso, no necesitamos este comando, por lo que también podemos omitirlo. <br>  Aquí está la lista completa de comandos para omitir: <br></p><pre> <code class="plaintext hljs">.text:0x4004EF mov rdi, cs:stdout ; stream .text:0x4004F6 call _setbuf .text:0x400502 call _printf .text:0x40054F mov rsi, cs:stdout ; fp</code> </pre> <br><p>  Para omitir comandos, necesitamos reescribir <strong>RIP</strong> con las siguientes instrucciones: <br></p><pre> <code class="python hljs">mu.reg_write(UC_X86_REG_RIP, address+size)</code> </pre> <br><p>  Ahora <strong>hook_code</strong> debería verse así: </p><br><p></p><br><pre> <code class="python hljs">instructions_skip_list = [<span class="hljs-number"><span class="hljs-number">0x004004ef</span></span>,<span class="hljs-number"><span class="hljs-number">0x004004f6</span></span>,<span class="hljs-number"><span class="hljs-number">0x00400502</span></span>,<span class="hljs-number"><span class="hljs-number">0x0040054f</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hook_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mu, address, size, user_data)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">'&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x'</span></span> %(address, size)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> address <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> instructions_skip_list: mu.reg_write(UC_X86_REG_RIP, address+size)</code> </pre> <br><p>  También debemos hacer algo con instrucciones que muestren la bandera en la consola byte por byte. </p><br><pre> <code class="plaintext hljs">.text:0x400558 movsx edi, dil ; c .text:0x40055C add rbp, 1 .text:0x400560 call __IO_putc</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">__IO_putc</a> toma bytes para la salida como <strong>primer argumento</strong> (este es el registro <strong>RDI</strong> ). </p><br><p>  Podemos leer datos directamente desde el registro, enviar datos a la consola y omitir este conjunto de instrucciones.  El <strong>hook_code</strong> actualizado se presenta a continuación: </p><br><pre> <code class="python hljs">instructions_skip_list = [<span class="hljs-number"><span class="hljs-number">0x004004ef</span></span>,<span class="hljs-number"><span class="hljs-number">0x004004f6</span></span>,<span class="hljs-number"><span class="hljs-number">0x00400502</span></span>,<span class="hljs-number"><span class="hljs-number">0x0040054f</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hook_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mu, address, size, user_data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#print('&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x' %(address, size)) if address in instructions_skip_list: mu.reg_write(UC_X86_REG_RIP, address+size) elif address == 0x400560: # c = mu.reg_read(UC_X86_REG_RDI) print(chr(c),end="") mu.reg_write(UC_X86_REG_RIP, address+size)</span></span></code> </pre> <br><p>  Podemos correr y todo funcionará, pero aún así lentamente. </p><br><h1 id="shag-2-uvelichim-skorost">  Paso 2: ¡Aumenta la velocidad! </h1><br><p>  Pensemos en aumentar la velocidad del trabajo.  ¿Por qué es este programa tan lento? </p><br><p>  Si miramos el código descompilado, veremos que <strong>main ()</strong> llama a <strong>fibonacci ()</strong> varias veces y <strong>fibonacci ()</strong> es una función recursiva.  Echemos un vistazo más de cerca a esta función; toma y devuelve dos argumentos.  El primer valor de retorno se pasa a través del registro <strong>RAX</strong> , el segundo se devuelve a través del enlace que se pasó a través del segundo argumento a la función.  Si observamos más a fondo la relación entre <strong>main ()</strong> y <strong>fibonacci ()</strong> , veremos que el segundo argumento solo toma dos valores posibles: 0 o 1. Si aún no ve esto, ejecute <strong>gdb</strong> y ponga un punto de interrupción al comienzo de la función <strong>Fibonacci ()</strong> . </p><br><p>  Para optimizar el funcionamiento del algoritmo, podemos utilizar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la programación dinámica</a> para recordar el valor de retorno de los parámetros entrantes.  Piensa por ti mismo, el segundo argumento solo puede tomar dos valores posibles, por lo que todo lo que tenemos que hacer es recordar <math> </math> $ en línea $ 2 * MAX \ _OF \ _FIRST \ _ARGUMENT $ en línea $   vapor </p><br><div class="spoiler">  <b class="spoiler_title">Para los que no entienden</b> <div class="spoiler_text"><p>  <strong>Fibonacci</strong> es una función recursiva que calcula el siguiente valor como la suma de los dos anteriores.  A cada paso ella va más profundo.  Cada vez que comienza de nuevo, sigue el mismo camino que antes, más un nuevo significado. </p><br><p>  Un ejemplo: <br>  Suponga que la profundidad = 6, luego: <strong>1 1 2 3 5 8</strong> . <br>  Y ahora profundidad = 8, entonces: <strong>1 1 2 3 5 8</strong> 13 21. </p><br><p>  Podríamos recordar que los primeros 6 miembros son <strong>1 1 2 3 5 8</strong> , y cuando nos piden contar más de lo que recordamos, tomamos lo que recordamos y contamos solo lo que falta. </p></div></div><br><p>  Una vez que <strong>RIP</strong> está al comienzo de <strong>fibonacci ()</strong> , podemos obtener los argumentos de la función.  Sabemos que una función devuelve un resultado cuando sale de una función.  Como no podemos operar con dos parámetros a la vez, necesitamos una pila para devolver los parámetros.  Cuando ingresamos <strong>fibonacci (),</strong> necesitamos poner los argumentos en la pila y recogerlos cuando salimos.  Para almacenar los pares contados, podemos usar un diccionario. </p><br><p>  ¿Cómo procesar un par de valores? </p><br><ul><li>  Al comienzo de la función, podemos verificar si este par está en los resultados que ya conocemos: <br><ul><li>  si lo hay, entonces podemos devolver este par.  Solo necesitamos escribir los valores de retorno en <strong>RAX</strong> y en la dirección del enlace, que se encuentra en el segundo argumento.  También asignamos una dirección <strong>RIP</strong> para salir de la función.  No podemos usar <strong>RET</strong> en <strong>fibonacci ()</strong> , ya que estas llamadas están enganchadas, por lo que tomaremos algo de <strong>RET</strong> de <strong>main ()</strong> ; </li><li>  Si estos valores no lo son, simplemente los agregamos a la pila. </li></ul></li><li>  Antes de salir de la función, podemos guardar el par devuelto.  Conocemos los argumentos de entrada, ya que podemos leerlos desde nuestra pila. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Este código se presenta aquí.</b> <div class="spoiler_text"><pre> <code class="python hljs">FIBONACCI_ENTRY = <span class="hljs-number"><span class="hljs-number">0x00400670</span></span> FIBONACCI_END = [ <span class="hljs-number"><span class="hljs-number">0x004006f1</span></span>, <span class="hljs-number"><span class="hljs-number">0x00400709</span></span>] instructions_skip_list = [<span class="hljs-number"><span class="hljs-number">0x004004ef</span></span>,<span class="hljs-number"><span class="hljs-number">0x004004f6</span></span>,<span class="hljs-number"><span class="hljs-number">0x00400502</span></span>,<span class="hljs-number"><span class="hljs-number">0x0040054f</span></span>] <span class="hljs-comment"><span class="hljs-comment">#     stack = [] # ,       d = {} def hook_code(mu, address, size, user_data): if address in instructions_skip_list: mu.reg_write(UC_X86_REG_RIP, address+size) #      elif address == 0x400560: c = mu.reg_read(UC_X86_REG_RDI) print(chr(c),end="") mu.reg_write(UC_X86_REG_RIP, address+size) #     ? elif address == FIBONACCI_ENTRY: #     RDI arg0 = mu.reg_read(UC_X86_REG_RDI) #    () r_rsi = mu.reg_read(UC_X86_REG_RSI) #   ,    arg1 = u32(mu.mem_read(r_rsi, 4)) # ,    ? if (arg0,arg1) in d: (ret_rax, ret_ref) = d[(arg0,arg1)] #     RAX mu.reg_write(UC_X86_REG_RAX, ret_rax) #     mu.mem_write(r_rsi, p32(ret_ref)) #  RIP  RET ,       fibonacci mu.reg_write(UC_X86_REG_RIP, 0x400582) else: #      ,      stack.append((arg0,arg1,r_rsi)) elif address in FIBONACCI_END: #     (arg0, arg1, r_rsi) = stack.pop() #     RAX ret_rax = mu.reg_read(UC_X86_REG_RAX) #  ,      ret_ref = u32(mu.mem_read(r_rsi,4)) #      d[(arg0, arg1)]=(ret_rax, ret_ref)</span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Aquí está el guión completo</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python # -*- coding: utf-8 -*- from __future__ import print_function from unicorn import * from unicorn.x86_const import * import struct def read(name): with open(name) as f: return f.read() def u32(data): return struct.unpack("I", data)[0] def p32(num): return struct.pack("I", num) FIBONACCI_ENTRY = 0x00400670 FIBONACCI_END = [ 0x004006f1, 0x00400709] instructions_skip_list = [0x004004ef,0x004004f6,0x00400502,0x0040054f] #     stack = [] # ,       d = {} def hook_code(mu, address, size, user_data): if address in instructions_skip_list: mu.reg_write(UC_X86_REG_RIP, address+size) #      elif address == 0x400560: c = mu.reg_read(UC_X86_REG_RDI) print(chr(c),end="") mu.reg_write(UC_X86_REG_RIP, address+size) #     ? elif address == FIBONACCI_ENTRY: #     RDI arg0 = mu.reg_read(UC_X86_REG_RDI) #    () r_rsi = mu.reg_read(UC_X86_REG_RSI) #   ,    arg1 = u32(mu.mem_read(r_rsi, 4)) # ,    ? if (arg0,arg1) in d: (ret_rax, ret_ref) = d[(arg0,arg1)] #     RAX mu.reg_write(UC_X86_REG_RAX, ret_rax) #     mu.mem_write(r_rsi, p32(ret_ref)) #  RIP  RET .     fibonacci mu.reg_write(UC_X86_REG_RIP, 0x400582) else: #      ,      stack.append((arg0,arg1,r_rsi)) elif address in FIBONACCI_END: #     (arg0, arg1, r_rsi) = stack.pop() #     RAX ret_rax = mu.reg_read(UC_X86_REG_RAX) #  ,      ret_ref = u32(mu.mem_read(r_rsi,4)) #      d[(arg0, arg1)]=(ret_rax, ret_ref) mu = Uc (UC_ARCH_X86, UC_MODE_64) BASE = 0x400000 STACK_ADDR = 0x0 STACK_SIZE = 1024*1024 mu.mem_map(BASE, 1024*1024) mu.mem_map(STACK_ADDR, STACK_SIZE) mu.mem_write(BASE, read("./fibonacci")) mu.reg_write(UC_X86_REG_RSP, STACK_ADDR + STACK_SIZE - 1) mu.hook_add(UC_HOOK_CODE, hook_code) mu.emu_start(0x004004e0, 0x00400575) print()</span></span></code> </pre></div></div><br><p>  Hurra, finalmente pudimos optimizar la aplicación usando el motor Unicorn.  Buen trabajo! </p><br><h1 id="zametka">  Una nota </h1><br><p>  Ahora decidí darte un poco de tarea. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aquí puede encontrar</a> tres tareas más, cada una de las cuales tiene una pista y una solución completa.  Puedes echar un vistazo a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hoja de trucos</a> mientras resuelves problemas. </p><br><p>  Uno de los problemas más molestos es recordar el nombre de la constante deseada.  Esto es fácil de manejar si usa complementos de Tab en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IPython</a> .  Cuando tenga instalado IPython, puede escribir <strong>desde unicornio import UC_ARCH_</strong> presione Tab y se le <strong>mostrarán</strong> todas las constantes que comienzan de la misma manera. </p><p></p><p></p><p></p></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es431058/">https://habr.com/ru/post/es431058/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es431046/index.html">Cómo funciona realmente el índice z</a></li>
<li><a href="../es431048/index.html">La máquina de eventos protege el ciclo de vida</a></li>
<li><a href="../es431050/index.html">La ilusión de la pureza: ¿la mineralización del agua afecta su calidad y cómo nos ayudará el medidor TDS?</a></li>
<li><a href="../es431052/index.html">Frontend DevDay: mapas, equipos, dos consultas</a></li>
<li><a href="../es431056/index.html">USPACE: Drones Time</a></li>
<li><a href="../es431060/index.html">Suplantación de identidad alemana con autenticación en línea y financiación de refugiados en Alemania</a></li>
<li><a href="../es431064/index.html">Manifiesto de programador rígido</a></li>
<li><a href="../es431066/index.html">DEFCON 16. ¿Cómo puedo contactarte? Déjame enumerar las formas. Parte 2</a></li>
<li><a href="../es431068/index.html">El arte de la educación: la ideología de las máquinas tragamonedas</a></li>
<li><a href="../es431070/index.html">Hara comer? Estamos hablando de los hábitos alimenticios de un especialista en TI moderno.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>