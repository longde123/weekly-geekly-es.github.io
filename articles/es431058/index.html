<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游 游눰 游븺游낕 Primeros pasos con Unicorn Engine 游녨游 游꼨 游끦游낗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Al buscar "Unicorn Engine" en Habr, me sorprendi칩 descubrir que esta herramienta nunca ha aparecido en los art칤culos. Intentar칠 llenar este vac칤o. Com...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Primeros pasos con Unicorn Engine</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431058/"><p>  Al buscar "Unicorn Engine" en Habr, me sorprendi칩 descubrir que esta herramienta nunca ha aparecido en los art칤culos.  Intentar칠 llenar este vac칤o.  Comencemos con lo b치sico y veamos un ejemplo del uso del emulador en la vida real.  Para no reinventar la rueda, decid칤 simplemente traducir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> manual.  <em>Antes de comenzar, dir칠 que todos mis comentarios o comentarios se ver치n as칤</em> . </p><a name="habracut"></a><br><h1 id="chto-takoe-unicorn-engine">  쯈u칠 es un motor de unicornio? </h1><br><p>  <em>Los propios desarrolladores escriben sobre</em> <del>  <em>Motor de unicornio</em> </del>  <em>Unicorn Engine como este:</em> </p><br><blockquote>  Unicorn es un emulador de procesador ligero, multiplataforma y de arquitectura m칰ltiple. </blockquote><p>  Este no es un emulador est치ndar.  No emula la operaci칩n de todo el programa o el sistema operativo completo.  No admite comandos del sistema (como abrir un archivo, generar un car치cter en la consola, etc.).  Tendr치 que hacer el marcado de la memoria y cargar los datos usted mismo, y luego simplemente comenzar치 la ejecuci칩n desde alguna direcci칩n espec칤fica. </p><br><p>  Entonces, 쯖칩mo es 칰til? </p><br><ul><li>  Al analizar virus, puede llamar a funciones individuales sin crear un proceso malicioso. </li><li>  Para resolver CTF. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Por fuzzing</a> . </li><li>  <a href="">Un complemento para gdb</a> para predecir el estado futuro, por ejemplo, saltos futuros o valores de registro. </li><li>  Emulaci칩n de un c칩digo rico en funciones. </li></ul><br><p>  Que necesitas </p><br><ul><li>  Motor Unicornio instalado con enlace Python. </li><li>  Desensamblador </li></ul><br><h1 id="primer">  Ejemplo </h1><br><p>  Como ejemplo, realice una tarea con hxp CTF 2017 bajo el nombre de <strong><em>Fibonacci</em></strong> .  El binario se puede descargar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu칤</a> . </p><br><p>  Cuando inicia el programa, comienza a mostrar nuestra bandera en la consola, pero muy lentamente.  Cada byte de bandera posterior se considera cada vez m치s lento. </p><br><pre><code class="bash hljs">The flag is: hxp{F</code> </pre> <br><p>  Esto significa que para obtener la bandera en un per칤odo de tiempo razonable, necesitamos optimizar el funcionamiento de esta aplicaci칩n. </p><br><p>  Usando IDA Pro ( <em>yo personalmente us칠 radare2 + Cutter</em> ) descompilamos el c칩digo en un pseudoc칩digo tipo C.  A pesar de que el c칩digo no se descompil칩 correctamente, a칰n podemos obtener informaci칩n sobre lo que est치 sucediendo en su interior. </p><br><div class="spoiler">  <b class="spoiler_title">C칩digo descompilado</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__int64 __<span class="hljs-function"><span class="hljs-function">fastcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__int64 a1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **a2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **a3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *v3; <span class="hljs-comment"><span class="hljs-comment">// rbp@1 int v4; // ebx@1 signed __int64 v5; // r8@2 char v6; // r9@3 __int64 v7; // r8@3 char v8; // cl@3 __int64 v9; // r9@5 int a2a; // [sp+Ch] [bp-1Ch]@3 v3 = &amp;encrypted_flag; v4 = 0; setbuf(stdout, 0LL); printf("The flag is: ", 0LL); while ( 1 ) { LODWORD(v5) = 0; do { a2a = 0; fibonacci(v4 + v5, &amp;a2a); v8 = v7; v5 = v7 + 1; } while ( v5 != 8 ); v4 += 8; if ( (unsigned __int8)(a2a &lt;&lt; v8) == v6 ) break; v3 = (char *)v3 + 1; _IO_putc((char)(v6 ^ ((_BYTE)a2a &lt;&lt; v8)), stdout); v9 = *((char *)v3 - 1); } _IO_putc(10, stdout); return 0LL; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">fastcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fibonacci</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, _DWORD *a2)</span></span></span><span class="hljs-function"> </span></span>{ _DWORD *v2; <span class="hljs-comment"><span class="hljs-comment">// rbp@1 unsigned int v3; // er12@3 unsigned int result; // eax@3 unsigned int v5; // edx@3 unsigned int v6; // esi@3 unsigned int v7; // edx@4 v2 = a2; if ( i ) { if ( i == 1 ) { result = fibonacci(0, a2); v5 = result - ((result &gt;&gt; 1) &amp; 0x55555555); v6 = ((result - ((result &gt;&gt; 1) &amp; 0x55555555)) &gt;&gt; 2) &amp; 0x33333333; } else { v3 = fibonacci(i - 2, a2); result = v3 + fibonacci(i - 1, a2); v5 = result - ((result &gt;&gt; 1) &amp; 0x55555555); v6 = ((result - ((result &gt;&gt; 1) &amp; 0x55555555)) &gt;&gt; 2) &amp; 0x33333333; } v7 = v6 + (v5 &amp; 0x33333333) + ((v6 + (v5 &amp; 0x33333333)) &gt;&gt; 4); *v2 ^= ((BYTE1(v7) &amp; 0xF) + (v7 &amp; 0xF) + (unsigned __int8)((((v7 &gt;&gt; 8) &amp; 0xF0F0F) + (v7 &amp; 0xF0F0F0F)) &gt;&gt; 16)) &amp; 1; } else { *a2 ^= 1u; result = 1; } return result; }</span></span></code> </pre> </div></div><br><p>  Aqu칤 est치 el c칩digo de ensamblador de las funciones <em>principales</em> y de <em>Fibonacci</em> : </p><br><div class="spoiler">  <b class="spoiler_title">principal</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">.text:0x4004E0 main proc near ; DATA XREF: start+1Do .text:0x4004E0 .text:0x4004E0 var_1C = dword ptr -1Ch .text:0x4004E0 .text:0x4004E0 push rbp .text:0x4004E1 push rbx .text:0x4004E2 xor esi, esi ; buf .text:0x4004E4 mov ebp, offset unk_4007E1 .text:0x4004E9 xor ebx, ebx .text:0x4004EB sub rsp, 18h .text:0x4004EF mov rdi, cs:stdout ; stream .text:0x4004F6 call _setbuf .text:0x4004FB mov edi, offset format ; "The flag is: " .text:0x400500 xor eax, eax .text:0x400502 call _printf .text:0x400507 mov r9d, 49h .text:0x40050D nop dword ptr [rax] .text:0x400510 .text:0x400510 loc_400510: ; CODE XREF: main+8Aj .text:0x400510 xor r8d, r8d .text:0x400513 jmp short loc_40051B .text:0x400513 ; --------------------------------------------------------------------------- .text:0x400515 align 8 .text:0x400518 .text:0x400518 loc_400518: ; CODE XREF: main+67j .text:0x400518 mov r9d, edi .text:0x40051B .text:0x40051B loc_40051B: ; CODE XREF: main+33j .text:0x40051B lea edi, [rbx+r8] .text:0x40051F lea rsi, [rsp+28h+var_1C] .text:0x400524 mov [rsp+28h+var_1C], 0 .text:0x40052C call fibonacci .text:0x400531 mov edi, [rsp+28h+var_1C] .text:0x400535 mov ecx, r8d .text:0x400538 add r8, 1 .text:0x40053C shl edi, cl .text:0x40053E mov eax, edi .text:0x400540 xor edi, r9d .text:0x400543 cmp r8, 8 .text:0x400547 jnz short loc_400518 .text:0x400549 add ebx, 8 .text:0x40054C cmp al, r9b .text:0x40054F mov rsi, cs:stdout ; fp .text:0x400556 jz short loc_400570 .text:0x400558 movsx edi, dil ; c .text:0x40055C add rbp, 1 .text:0x400560 call __IO_putc .text:0x400565 movzx r9d, byte ptr [rbp-1] .text:0x40056A jmp short loc_400510 .text:0x40056A ; --------------------------------------------------------------------------- .text:0x40056C align 10h .text:0x400570 .text:0x400570 loc_400570: ; CODE XREF: main+76j .text:0x400570 mov edi, 0Ah ; c .text:0x400575 call __IO_putc .text:0x40057A add rsp, 18h .text:0x40057E xor eax, eax .text:0x400580 pop rbx .text:0x400581 pop rbp .text:0x400582 retn .text:0x400582 main endp</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">fibonacci</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">.text:0x400670 fibonacci proc near ; CODE XREF: main+4Cp .text:0x400670 ; fibonacci+19p ... .text:0x400670 test edi, edi .text:0x400672 push r12 .text:0x400674 push rbp .text:0x400675 mov rbp, rsi .text:0x400678 push rbx .text:0x400679 jz short loc_4006F8 .text:0x40067B cmp edi, 1 .text:0x40067E mov ebx, edi .text:0x400680 jz loc_400710 .text:0x400686 lea edi, [rdi-2] .text:0x400689 call fibonacci .text:0x40068E lea edi, [rbx-1] .text:0x400691 mov r12d, eax .text:0x400694 mov rsi, rbp .text:0x400697 call fibonacci .text:0x40069C add eax, r12d .text:0x40069F mov edx, eax .text:0x4006A1 mov ebx, eax .text:0x4006A3 shr edx, 1 .text:0x4006A5 and edx, 55555555h .text:0x4006AB sub ebx, edx .text:0x4006AD mov ecx, ebx .text:0x4006AF mov edx, ebx .text:0x4006B1 shr ecx, 2 .text:0x4006B4 and ecx, 33333333h .text:0x4006BA mov esi, ecx .text:0x4006BC .text:0x4006BC loc_4006BC: ; CODE XREF: fibonacci+C2j .text:0x4006BC and edx, 33333333h .text:0x4006C2 lea ecx, [rsi+rdx] .text:0x4006C5 mov edx, ecx .text:0x4006C7 shr edx, 4 .text:0x4006CA add edx, ecx .text:0x4006CC mov esi, edx .text:0x4006CE and edx, 0F0F0F0Fh .text:0x4006D4 shr esi, 8 .text:0x4006D7 and esi, 0F0F0Fh .text:0x4006DD lea ecx, [rsi+rdx] .text:0x4006E0 mov edx, ecx .text:0x4006E2 shr edx, 10h .text:0x4006E5 add edx, ecx .text:0x4006E7 and edx, 1 .text:0x4006EA xor [rbp+0], edx .text:0x4006ED pop rbx .text:0x4006EE pop rbp .text:0x4006EF pop r12 .text:0x4006F1 retn .text:0x4006F1 ; --------------------------------------------------------------------------- .text:0x4006F2 align 8 .text:0x4006F8 .text:0x4006F8 loc_4006F8: ; CODE XREF: fibonacci+9j .text:0x4006F8 mov edx, 1 .text:0x4006FD xor [rbp+0], edx .text:0x400700 mov eax, 1 .text:0x400705 pop rbx .text:0x400706 pop rbp .text:0x400707 pop r12 .text:0x400709 retn .text:0x400709 ; --------------------------------------------------------------------------- .text:0x40070A align 10h .text:0x400710 .text:0x400710 loc_400710: ; CODE XREF: fibonacci+10j .text:0x400710 xor edi, edi .text:0x400712 call fibonacci .text:0x400717 mov edx, eax .text:0x400719 mov edi, eax .text:0x40071B shr edx, 1 .text:0x40071D and edx, 55555555h .text:0x400723 sub edi, edx .text:0x400725 mov esi, edi .text:0x400727 mov edx, edi .text:0x400729 shr esi, 2 .text:0x40072C and esi, 33333333h .text:0x400732 jmp short loc_4006BC .text:0x400732 fibonacci endp</code> </pre> </div></div><br><p>  En esta etapa, tenemos muchas oportunidades para resolver este problema.  Por ejemplo, podemos restaurar el c칩digo usando uno de los lenguajes de programaci칩n y aplicar la optimizaci칩n all칤, pero el proceso de recuperaci칩n del c칩digo es una tarea muy dif칤cil, durante la cual podemos cometer errores.  Bueno, entonces comparar el c칩digo para encontrar el error generalmente no tiene valor.  Pero, si usamos el Unicorn Engine, podemos omitir la etapa de reconstrucci칩n del c칩digo y evitar el problema descrito anteriormente.  Por supuesto, podemos evitar estos problemas usando frida o escribiendo scripts para gdb, pero no se trata de eso. </p><br><p>  Antes de comenzar la optimizaci칩n, ejecutaremos la emulaci칩n en Unicorn Engine sin cambiar el programa.  Y solo despu칠s de un lanzamiento exitoso, pasemos a la optimizaci칩n. </p><br><h2 id="shag-1-da-priydet-virtualizaciya">  Paso 1: deje que venga la virtualizaci칩n </h2><br><p>  Creemos el archivo fibonacci.py y gu치rdelo junto al binario. </p><br><p>  Comencemos importando las bibliotecas requeridas: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unicorn <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unicorn.x86_const <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> struct</code> </pre> <br><p>  La primera l칤nea carga las constantes Unicornio binarias y b치sicas principales.  La segunda l칤nea carga las constantes para las dos arquitecturas x86 y x86_64. </p><br><p>  A continuaci칩n, agregue algunas funciones necesarias: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(name) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f.read() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">u32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> struct.unpack(<span class="hljs-string"><span class="hljs-string">"I"</span></span>, data)[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> struct.pack(<span class="hljs-string"><span class="hljs-string">"I"</span></span>, num)</code> </pre> <br><p>  Aqu칤 anunciamos las funciones que necesitaremos m치s adelante: </p><br><ul><li>  <strong>leer</strong> simplemente devuelve el contenido del archivo, </li><li>  <strong>u32</strong> toma una cadena de 4 bytes en la codificaci칩n LE y la convierte a int, </li><li>  <strong>p32</strong> hace lo contrario: toma un n칰mero y lo convierte en una cadena de 4 bytes en la codificaci칩n LE. </li></ul><br><p>  Nota: Si ha instalado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pwntools</a> , entonces no necesita crear estas funciones, solo necesita importarlas: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pwn <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> *</code> </pre> <br><p>  Y as칤, finalmente, comencemos a inicializar nuestra clase Unicorn Engine para la arquitectura x86_64: </p><br><pre> <code class="python hljs">mu = Uc (UC_ARCH_X86, UC_MODE_64)</code> </pre> <br><p>  Aqu칤 llamamos a las funciones <strong>Uc</strong> con los siguientes par치metros: </p><br><ul><li>  El primer par치metro es la arquitectura principal.  Las constantes comienzan con <strong>UC_ARCH_</strong> ; </li><li>  El segundo par치metro es la especificaci칩n de la arquitectura.  Las constantes comienzan con <strong>UC_MODE_</strong> . </li></ul><br><p>  Puedes encontrar todas las constantes en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hoja de trucos</a> . </p><br><p>  Como escrib칤 anteriormente, para usar el motor Unicorn, necesitamos inicializar la memoria virtual manualmente.  Para este ejemplo, necesitamos colocar el c칩digo y la pila en alg칰n lugar de la memoria. </p><br><p>  La direcci칩n base (Base addr) del binario comienza en 0x400000.  Pongamos nuestra pila en 0x0 y asignemos 1024 * 1024 memoria para ello.  Lo m치s probable es que no necesitemos tanto espacio, pero a칰n as칤 no duele. </p><br><p>  Podemos marcar la memoria llamando al m칠todo <strong>mem_map</strong> . </p><br><p>  Agregue estas l칤neas: </p><br><pre> <code class="python hljs">BASE = <span class="hljs-number"><span class="hljs-number">0x400000</span></span> STACK_ADDR = <span class="hljs-number"><span class="hljs-number">0x0</span></span> STACK_SIZE = <span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span> mu.mem_map(BASE, <span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>) mu.mem_map(STACK_ADDR, STACK_SIZE)</code> </pre> <br><p>  Ahora necesitamos cargar el binario en su direcci칩n principal de la misma manera que lo hace el gestor de arranque.  Despu칠s de eso, necesitamos establecer <strong>RSP</strong> al final de la pila. </p><br><pre> <code class="python hljs">mu.mem_write(BASE, read(<span class="hljs-string"><span class="hljs-string">"./fibonacci"</span></span>)) mu.reg_write(UC_X86_REG_RSP, STACK_ADDR + STACK_SIZE - <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  Ahora podemos comenzar la emulaci칩n y ejecutar el c칩digo, pero necesitamos averiguar con qu칠 direcci칩n comenzar a trabajar y cu치ndo debe detenerse el emulador. </p><br><p>  Tome la direcci칩n del primer comando de <strong>main ()</strong> , podemos comenzar la emulaci칩n desde 0x004004e0.  El final se considerar치 una llamada a <strong>putc ("\ n")</strong> , que se encuentra en 0x00400575, despu칠s de mostrar la bandera completa. </p><br><pre> <code class="plaintext hljs">.text:0x400570 mov edi, 0Ah ; c .text:0x400575 call __IO_putc</code> </pre> <br><p>  Podemos comenzar a emular: </p><br><pre> <code class="python hljs">mu.emu_start(<span class="hljs-number"><span class="hljs-number">0x004004e0</span></span>,<span class="hljs-number"><span class="hljs-number">0x00400575</span></span>)</code> </pre> <br><p>  Ahora ejecuta el script: </p><br><pre> <code class="bash hljs">a@x:~/Desktop/unicorn_engine_lessons$ python solve.py Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"solve.py"</span></span>, line 32, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; mu.emu_start(0x00000000004004E0, 0x0000000000400575) File <span class="hljs-string"><span class="hljs-string">"/usr/local/lib/python2.7/dist-packages/unicorn/unicorn.py"</span></span>, line 288, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> emu_start raise UcError(status) unicorn.unicorn.UcError: Invalid memory <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> (UC_ERR_READ_UNMAPPED)</code> </pre> <br><p>  Vaya, algo sali칩 mal, pero ni siquiera sabemos qu칠.  Justo antes de llamar a <strong>mu.emu_start,</strong> podemos agregar: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hook_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mu, address, size, user_data)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">'&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x'</span></span> %(address, size)) mu.hook_add(UC_HOOK_CODE, hook_code)</code> </pre> <br><p>  Este c칩digo agrega un gancho.  Declaramos nuestra propia funci칩n <strong>hook_code</strong> , que el emulador llama antes de cada comando.  Toma los siguientes par치metros: </p><br><ul><li>  nuestra copia de <strong>Uc</strong> , </li><li>  direcci칩n de instrucciones </li><li>  instrucciones de tama침o </li><li>  datos de usuario (podemos pasar este valor con un argumento opcional a <strong>hook_add ()</strong> ). <br>  Ahora, si ejecutamos el script, deber칤amos ver el siguiente resultado: <br><pre> <code class="bash hljs">a@x:~/Desktop/unicorn_engine_lessons$ python solve.py &gt;&gt;&gt; Tracing instruction at 0x4004e0, instruction size = 0x1 &gt;&gt;&gt; Tracing instruction at 0x4004e1, instruction size = 0x1 &gt;&gt;&gt; Tracing instruction at 0x4004e2, instruction size = 0x2 &gt;&gt;&gt; Tracing instruction at 0x4004e4, instruction size = 0x5 &gt;&gt;&gt; Tracing instruction at 0x4004e9, instruction size = 0x2 &gt;&gt;&gt; Tracing instruction at 0x4004eb, instruction size = 0x4 &gt;&gt;&gt; Tracing instruction at 0x4004ef, instruction size = 0x7 Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"solve.py"</span></span>, line 41, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; mu.emu_start(0x00000000004004E0, 0x0000000000400575) File <span class="hljs-string"><span class="hljs-string">"/usr/local/lib/python2.7/dist-packages/unicorn/unicorn.py"</span></span>, line 288, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> emu_start raise UcError(status) unicorn.unicorn.UcError: Invalid memory <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> (UC_ERR_READ_UNMAPPED)</code> </pre> <br><p>  En la direcci칩n donde ocurri칩 el error, podemos entender que nuestro script no puede procesar este comando: <br></p><pre> <code class="plaintext hljs">.text:0x4004EF mov rdi, cs:stdout ; stream</code> </pre> <br><p>  Esta instrucci칩n lee datos de la direcci칩n 0x601038 (puede verlos en IDA Pro).  Esta es la secci칩n <strong>.bss</strong> que no marcamos.  Mi soluci칩n ser칤a simplemente omitir todas las instrucciones problem치ticas si esto no afecta la l칩gica del programa. <br>  A continuaci칩n hay otra instrucci칩n problem치tica: <br></p><pre> <code class="plaintext hljs">.text:0x4004F6 call _setbuf</code> </pre> <br><p>  No podemos llamar a ninguna funci칩n con glibc, ya que no tenemos glibc cargado en la memoria.  En cualquier caso, no necesitamos este comando, por lo que tambi칠n podemos omitirlo. <br>  Aqu칤 est치 la lista completa de comandos para omitir: <br></p><pre> <code class="plaintext hljs">.text:0x4004EF mov rdi, cs:stdout ; stream .text:0x4004F6 call _setbuf .text:0x400502 call _printf .text:0x40054F mov rsi, cs:stdout ; fp</code> </pre> <br><p>  Para omitir comandos, necesitamos reescribir <strong>RIP</strong> con las siguientes instrucciones: <br></p><pre> <code class="python hljs">mu.reg_write(UC_X86_REG_RIP, address+size)</code> </pre> <br><p>  Ahora <strong>hook_code</strong> deber칤a verse as칤: </p><br><p></p><br><pre> <code class="python hljs">instructions_skip_list = [<span class="hljs-number"><span class="hljs-number">0x004004ef</span></span>,<span class="hljs-number"><span class="hljs-number">0x004004f6</span></span>,<span class="hljs-number"><span class="hljs-number">0x00400502</span></span>,<span class="hljs-number"><span class="hljs-number">0x0040054f</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hook_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mu, address, size, user_data)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">'&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x'</span></span> %(address, size)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> address <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> instructions_skip_list: mu.reg_write(UC_X86_REG_RIP, address+size)</code> </pre> <br><p>  Tambi칠n debemos hacer algo con instrucciones que muestren la bandera en la consola byte por byte. </p><br><pre> <code class="plaintext hljs">.text:0x400558 movsx edi, dil ; c .text:0x40055C add rbp, 1 .text:0x400560 call __IO_putc</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">__IO_putc</a> toma bytes para la salida como <strong>primer argumento</strong> (este es el registro <strong>RDI</strong> ). </p><br><p>  Podemos leer datos directamente desde el registro, enviar datos a la consola y omitir este conjunto de instrucciones.  El <strong>hook_code</strong> actualizado se presenta a continuaci칩n: </p><br><pre> <code class="python hljs">instructions_skip_list = [<span class="hljs-number"><span class="hljs-number">0x004004ef</span></span>,<span class="hljs-number"><span class="hljs-number">0x004004f6</span></span>,<span class="hljs-number"><span class="hljs-number">0x00400502</span></span>,<span class="hljs-number"><span class="hljs-number">0x0040054f</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hook_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mu, address, size, user_data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#print('&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x' %(address, size)) if address in instructions_skip_list: mu.reg_write(UC_X86_REG_RIP, address+size) elif address == 0x400560: # c = mu.reg_read(UC_X86_REG_RDI) print(chr(c),end="") mu.reg_write(UC_X86_REG_RIP, address+size)</span></span></code> </pre> <br><p>  Podemos correr y todo funcionar치, pero a칰n as칤 lentamente. </p><br><h1 id="shag-2-uvelichim-skorost">  Paso 2: 춰Aumenta la velocidad! </h1><br><p>  Pensemos en aumentar la velocidad del trabajo.  쯇or qu칠 es este programa tan lento? </p><br><p>  Si miramos el c칩digo descompilado, veremos que <strong>main ()</strong> llama a <strong>fibonacci ()</strong> varias veces y <strong>fibonacci ()</strong> es una funci칩n recursiva.  Echemos un vistazo m치s de cerca a esta funci칩n; toma y devuelve dos argumentos.  El primer valor de retorno se pasa a trav칠s del registro <strong>RAX</strong> , el segundo se devuelve a trav칠s del enlace que se pas칩 a trav칠s del segundo argumento a la funci칩n.  Si observamos m치s a fondo la relaci칩n entre <strong>main ()</strong> y <strong>fibonacci ()</strong> , veremos que el segundo argumento solo toma dos valores posibles: 0 o 1. Si a칰n no ve esto, ejecute <strong>gdb</strong> y ponga un punto de interrupci칩n al comienzo de la funci칩n <strong>Fibonacci ()</strong> . </p><br><p>  Para optimizar el funcionamiento del algoritmo, podemos utilizar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la programaci칩n din치mica</a> para recordar el valor de retorno de los par치metros entrantes.  Piensa por ti mismo, el segundo argumento solo puede tomar dos valores posibles, por lo que todo lo que tenemos que hacer es recordar <math> </math> $ en l칤nea $ 2 * MAX \ _OF \ _FIRST \ _ARGUMENT $ en l칤nea $   vapor </p><br><div class="spoiler">  <b class="spoiler_title">Para los que no entienden</b> <div class="spoiler_text"><p>  <strong>Fibonacci</strong> es una funci칩n recursiva que calcula el siguiente valor como la suma de los dos anteriores.  A cada paso ella va m치s profundo.  Cada vez que comienza de nuevo, sigue el mismo camino que antes, m치s un nuevo significado. </p><br><p>  Un ejemplo: <br>  Suponga que la profundidad = 6, luego: <strong>1 1 2 3 5 8</strong> . <br>  Y ahora profundidad = 8, entonces: <strong>1 1 2 3 5 8</strong> 13 21. </p><br><p>  Podr칤amos recordar que los primeros 6 miembros son <strong>1 1 2 3 5 8</strong> , y cuando nos piden contar m치s de lo que recordamos, tomamos lo que recordamos y contamos solo lo que falta. </p></div></div><br><p>  Una vez que <strong>RIP</strong> est치 al comienzo de <strong>fibonacci ()</strong> , podemos obtener los argumentos de la funci칩n.  Sabemos que una funci칩n devuelve un resultado cuando sale de una funci칩n.  Como no podemos operar con dos par치metros a la vez, necesitamos una pila para devolver los par치metros.  Cuando ingresamos <strong>fibonacci (),</strong> necesitamos poner los argumentos en la pila y recogerlos cuando salimos.  Para almacenar los pares contados, podemos usar un diccionario. </p><br><p>  쮺칩mo procesar un par de valores? </p><br><ul><li>  Al comienzo de la funci칩n, podemos verificar si este par est치 en los resultados que ya conocemos: <br><ul><li>  si lo hay, entonces podemos devolver este par.  Solo necesitamos escribir los valores de retorno en <strong>RAX</strong> y en la direcci칩n del enlace, que se encuentra en el segundo argumento.  Tambi칠n asignamos una direcci칩n <strong>RIP</strong> para salir de la funci칩n.  No podemos usar <strong>RET</strong> en <strong>fibonacci ()</strong> , ya que estas llamadas est치n enganchadas, por lo que tomaremos algo de <strong>RET</strong> de <strong>main ()</strong> ; </li><li>  Si estos valores no lo son, simplemente los agregamos a la pila. </li></ul></li><li>  Antes de salir de la funci칩n, podemos guardar el par devuelto.  Conocemos los argumentos de entrada, ya que podemos leerlos desde nuestra pila. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Este c칩digo se presenta aqu칤.</b> <div class="spoiler_text"><pre> <code class="python hljs">FIBONACCI_ENTRY = <span class="hljs-number"><span class="hljs-number">0x00400670</span></span> FIBONACCI_END = [ <span class="hljs-number"><span class="hljs-number">0x004006f1</span></span>, <span class="hljs-number"><span class="hljs-number">0x00400709</span></span>] instructions_skip_list = [<span class="hljs-number"><span class="hljs-number">0x004004ef</span></span>,<span class="hljs-number"><span class="hljs-number">0x004004f6</span></span>,<span class="hljs-number"><span class="hljs-number">0x00400502</span></span>,<span class="hljs-number"><span class="hljs-number">0x0040054f</span></span>] <span class="hljs-comment"><span class="hljs-comment">#     stack = [] # ,       d = {} def hook_code(mu, address, size, user_data): if address in instructions_skip_list: mu.reg_write(UC_X86_REG_RIP, address+size) #      elif address == 0x400560: c = mu.reg_read(UC_X86_REG_RDI) print(chr(c),end="") mu.reg_write(UC_X86_REG_RIP, address+size) #     ? elif address == FIBONACCI_ENTRY: #     RDI arg0 = mu.reg_read(UC_X86_REG_RDI) #    () r_rsi = mu.reg_read(UC_X86_REG_RSI) #   ,    arg1 = u32(mu.mem_read(r_rsi, 4)) # ,    ? if (arg0,arg1) in d: (ret_rax, ret_ref) = d[(arg0,arg1)] #     RAX mu.reg_write(UC_X86_REG_RAX, ret_rax) #     mu.mem_write(r_rsi, p32(ret_ref)) #  RIP  RET ,       fibonacci mu.reg_write(UC_X86_REG_RIP, 0x400582) else: #      ,      stack.append((arg0,arg1,r_rsi)) elif address in FIBONACCI_END: #     (arg0, arg1, r_rsi) = stack.pop() #     RAX ret_rax = mu.reg_read(UC_X86_REG_RAX) #  ,      ret_ref = u32(mu.mem_read(r_rsi,4)) #      d[(arg0, arg1)]=(ret_rax, ret_ref)</span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Aqu칤 est치 el gui칩n completo</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python # -*- coding: utf-8 -*- from __future__ import print_function from unicorn import * from unicorn.x86_const import * import struct def read(name): with open(name) as f: return f.read() def u32(data): return struct.unpack("I", data)[0] def p32(num): return struct.pack("I", num) FIBONACCI_ENTRY = 0x00400670 FIBONACCI_END = [ 0x004006f1, 0x00400709] instructions_skip_list = [0x004004ef,0x004004f6,0x00400502,0x0040054f] #     stack = [] # ,       d = {} def hook_code(mu, address, size, user_data): if address in instructions_skip_list: mu.reg_write(UC_X86_REG_RIP, address+size) #      elif address == 0x400560: c = mu.reg_read(UC_X86_REG_RDI) print(chr(c),end="") mu.reg_write(UC_X86_REG_RIP, address+size) #     ? elif address == FIBONACCI_ENTRY: #     RDI arg0 = mu.reg_read(UC_X86_REG_RDI) #    () r_rsi = mu.reg_read(UC_X86_REG_RSI) #   ,    arg1 = u32(mu.mem_read(r_rsi, 4)) # ,    ? if (arg0,arg1) in d: (ret_rax, ret_ref) = d[(arg0,arg1)] #     RAX mu.reg_write(UC_X86_REG_RAX, ret_rax) #     mu.mem_write(r_rsi, p32(ret_ref)) #  RIP  RET .     fibonacci mu.reg_write(UC_X86_REG_RIP, 0x400582) else: #      ,      stack.append((arg0,arg1,r_rsi)) elif address in FIBONACCI_END: #     (arg0, arg1, r_rsi) = stack.pop() #     RAX ret_rax = mu.reg_read(UC_X86_REG_RAX) #  ,      ret_ref = u32(mu.mem_read(r_rsi,4)) #      d[(arg0, arg1)]=(ret_rax, ret_ref) mu = Uc (UC_ARCH_X86, UC_MODE_64) BASE = 0x400000 STACK_ADDR = 0x0 STACK_SIZE = 1024*1024 mu.mem_map(BASE, 1024*1024) mu.mem_map(STACK_ADDR, STACK_SIZE) mu.mem_write(BASE, read("./fibonacci")) mu.reg_write(UC_X86_REG_RSP, STACK_ADDR + STACK_SIZE - 1) mu.hook_add(UC_HOOK_CODE, hook_code) mu.emu_start(0x004004e0, 0x00400575) print()</span></span></code> </pre></div></div><br><p>  Hurra, finalmente pudimos optimizar la aplicaci칩n usando el motor Unicorn.  Buen trabajo! </p><br><h1 id="zametka">  Una nota </h1><br><p>  Ahora decid칤 darte un poco de tarea. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aqu칤 puede encontrar</a> tres tareas m치s, cada una de las cuales tiene una pista y una soluci칩n completa.  Puedes echar un vistazo a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hoja de trucos</a> mientras resuelves problemas. </p><br><p>  Uno de los problemas m치s molestos es recordar el nombre de la constante deseada.  Esto es f치cil de manejar si usa complementos de Tab en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IPython</a> .  Cuando tenga instalado IPython, puede escribir <strong>desde unicornio import UC_ARCH_</strong> presione Tab y se le <strong>mostrar치n</strong> todas las constantes que comienzan de la misma manera. </p><p></p><p></p><p></p></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es431058/">https://habr.com/ru/post/es431058/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es431046/index.html">C칩mo funciona realmente el 칤ndice z</a></li>
<li><a href="../es431048/index.html">La m치quina de eventos protege el ciclo de vida</a></li>
<li><a href="../es431050/index.html">La ilusi칩n de la pureza: 쯟a mineralizaci칩n del agua afecta su calidad y c칩mo nos ayudar치 el medidor TDS?</a></li>
<li><a href="../es431052/index.html">Frontend DevDay: mapas, equipos, dos consultas</a></li>
<li><a href="../es431056/index.html">USPACE: Drones Time</a></li>
<li><a href="../es431060/index.html">Suplantaci칩n de identidad alemana con autenticaci칩n en l칤nea y financiaci칩n de refugiados en Alemania</a></li>
<li><a href="../es431064/index.html">Manifiesto de programador r칤gido</a></li>
<li><a href="../es431066/index.html">DEFCON 16. 쮺칩mo puedo contactarte? D칠jame enumerar las formas. Parte 2</a></li>
<li><a href="../es431068/index.html">El arte de la educaci칩n: la ideolog칤a de las m치quinas tragamonedas</a></li>
<li><a href="../es431070/index.html">Hara comer? Estamos hablando de los h치bitos alimenticios de un especialista en TI moderno.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>