<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∑üèº üë®üèª‚Äçüíº üë©üèΩ‚Äçü§ù‚Äçüë©üèº Parsing Async / Menunggu dalam JavaScript dengan Contoh üë®üèΩ‚Äçüöí üëÇüèæ üï∑Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Penulis artikel mem-parsing Async / Menunggu dalam JavaScript menggunakan contoh-contoh. Secara umum, Async / Menunggu adalah cara yang nyaman untuk m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Parsing Async / Menunggu dalam JavaScript dengan Contoh</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skillbox/blog/458950/"><img src="https://habrastorage.org/getpro/habr/post_images/2c8/f4a/252/2c8f4a252d33ee663665fd7df02b45ed.jpg"><br><br>  Penulis artikel mem-parsing Async / Menunggu dalam JavaScript menggunakan contoh-contoh.  Secara umum, Async / Menunggu adalah cara yang nyaman untuk menulis kode asinkron.  Sebelum kesempatan ini, kode serupa ditulis menggunakan callback dan janji.  Penulis artikel asli mengungkapkan manfaat Async / Menunggu dengan memeriksa berbagai contoh. <br><a name="habracut"></a><br><blockquote>  <b>Kami mengingatkan Anda:</b> <i>untuk semua pembaca "Habr" - diskon 10.000 rubel saat mendaftar untuk kursus Skillbox menggunakan kode promo "Habr".</i> <br><br>  <b>Rekomendasi Skillbox:</b> Kursus Pendidikan Online <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembang Java</a> . </blockquote><br><h3>  Telepon balik </h3><br>  Callback adalah fungsi yang panggilannya tertunda tanpa batas waktu.  Sebelumnya, callback digunakan di bagian-bagian kode yang hasilnya tidak dapat diperoleh dengan segera. <br><br>  Berikut adalah contoh membaca file di Node.js secara tidak sinkron: <br><br><pre><code class="javascript hljs">fs.readFile(__filename, <span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>, (err, data) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); });</code> </pre> <br>  Masalah muncul ketika Anda perlu melakukan beberapa operasi asinkron sekaligus.  Mari kita bayangkan skenario ini: permintaan dibuat ke database pengguna Arfat, Anda perlu membaca bidang profile_img_url dan mengunduh gambar dari server someserver.com. <br>  Setelah mengunduh, konversikan gambar ke format lain, misalnya, dari PNG ke JPEG.  Jika konversi berhasil, email dikirim ke email pengguna.  Selanjutnya, informasi tentang acara dimasukkan dalam file transformations.log dengan tanggal. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad5/c3f/e3b/ad5c3fe3bf0f7a68a4d3444614c3133e.png"><br><br>  Layak untuk memperhatikan pengenaan panggilan balik dan sejumlah besar}) di bagian akhir kode.  Ini disebut Callback Hell atau Pyramid of Doom. <br><br>  Kerugian dari metode ini jelas: <br><br><ul><li>  Kode ini sulit dibaca. </li><li>  Juga sulit untuk menangani kesalahan di dalamnya, yang sering mengarah pada penurunan kualitas kode. </li></ul><br>  Untuk mengatasi masalah ini, janji ditambahkan ke JavaScript.  Mereka memungkinkan Anda untuk mengganti sarang panggilan balik yang dalam dengan kata .then. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e1/503/0ad/9e15030ad0dbb431a63d9f98ec228111.png"><br><br>  Poin positif dari janji-janji itu adalah bahwa dengan mereka kode dibaca jauh lebih baik, dari atas ke bawah, dan bukan dari kiri ke kanan.  Namun demikian, janji juga memiliki masalah: <br><br><ul><li>  Perlu menambahkan sejumlah besar. Maka </li><li>  Alih-alih mencoba / menangkap, .catch digunakan untuk menangani semua kesalahan. </li><li>  Bekerja dengan beberapa janji dalam satu siklus masih jauh dari nyaman, dalam beberapa kasus, mereka memperumit kode. </li></ul><br>  Berikut adalah tugas yang akan menunjukkan arti paragraf terakhir. <br><br>  Misalkan ada loop for yang mencetak urutan angka dari 0 hingga 10 dengan interval acak (0 - n detik).  Dengan menggunakan janji, Anda harus mengubah siklus ini sehingga angka ditampilkan dalam urutan dari 0 hingga 10. Jadi, jika output nol membutuhkan waktu 6 detik dan unit membutuhkan waktu 2 detik, nol harus menjadi output pertama, dan kemudian hitung mundur output unit akan dimulai. <br><br>  Dan tentu saja, untuk mengatasi masalah ini, kami tidak menggunakan Async / Menunggu atau .sort.  Contoh solusi ada di bagian akhir. <br><br><h3>  Fungsi Async </h3><br>  Menambahkan fungsi async ke ES2017 (ES8) telah menyederhanakan tugas bekerja dengan janji-janji.  Saya perhatikan bahwa fungsi async bekerja di atas semua janji.  Fungsi-fungsi ini tidak mewakili konsep yang berbeda secara kualitatif.  Fungsi Async disusun sebagai alternatif untuk kode yang menggunakan janji. <br><br>  Async / Await memungkinkan untuk mengatur kerja dengan kode asinkron dalam gaya sinkron. <br><br>  Dengan demikian, pengetahuan tentang janji memudahkan untuk memahami prinsip-prinsip Async / Menunggu. <br><br>  <b>Sintaks</b> <br><br>  Dalam situasi tertentu, ini terdiri dari dua kata kunci: async dan menunggu.  Kata pertama membuat fungsi tidak sinkron.  Fungsi-fungsi ini memungkinkan menunggu.  Dalam kasus lain, menggunakan fungsi ini akan menyebabkan kesalahan. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// With function declaration async function myFn() { // await ... } // With arrow function const myFn = async () =&gt; { // await ... } function myFn() { // await fn(); (Syntax Error since no async) }</span></span></code> </pre><br>  Async dimasukkan di bagian paling awal deklarasi fungsi, dan dalam kasus fungsi panah, antara tanda "=" dan tanda kurung. <br><br>  Fungsi-fungsi ini dapat ditempatkan di objek sebagai metode atau digunakan dalam deklarasi kelas. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// As an object's method const obj = { async getName() { return fetch('https://www.example.com'); } } // In a class class Obj { async getResource() { return fetch('https://www.example.com'); } }</span></span></code> </pre> <br>  NB!  Perlu diingat bahwa konstruktor dan getter / setter kelas tidak dapat tidak sinkron. <br><br>  <b>Semantik dan aturan eksekusi</b> <br><br>  Fungsi Async pada dasarnya mirip dengan fungsi JS standar, tetapi ada pengecualian. <br><br>  Jadi, fungsi async selalu mengembalikan janji: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'hello'</span></span>; } fn().then(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log) <span class="hljs-comment"><span class="hljs-comment">// hello</span></span></code> </pre> <br>  Secara khusus, fn mengembalikan string halo.  Nah, karena ini adalah fungsi asinkron, nilai string dibungkus dalam janji menggunakan konstruktor. <br><br>  Berikut ini adalah desain alternatif tanpa Async: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>); } fn().then(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log); <span class="hljs-comment"><span class="hljs-comment">// hello</span></span></code> </pre> <br>  Dalam hal ini, pengembalian janji dibuat "secara manual".  Fungsi asinkron selalu membungkus dirinya dalam janji baru. <br><br>  Jika nilai pengembaliannya primitif, fungsi async mengembalikan nilai, membungkusnya dengan janji.  Jika nilai pengembalian adalah objek janji, solusinya dikembalikan dalam janji baru. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>) p <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>; <span class="hljs-comment"><span class="hljs-comment">// true Promise.resolve(p) === p; // true</span></span></code> </pre><br>  Tetapi apa yang terjadi jika kesalahan terjadi di dalam fungsi asinkron? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>); } foo().catch(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log);</code> </pre> <br>  Jika tidak diproses, foo () akan mengembalikan janji dengan reduksi.  Dalam situasi ini, alih-alih Promise.resolve, Promise.reject akan kembali berisi kesalahan. <br><br>  Fungsi Async pada output selalu memberikan janji, terlepas dari apa yang dikembalikan. <br><br>  Fungsi asinkron dijeda pada setiap menunggu. <br><br>  Menunggu memengaruhi ekspresi.  Jadi, jika ekspresi adalah janji, fungsi async ditangguhkan hingga janji dijalankan.  Dalam hal ungkapan itu bukan janji, itu dikonversi menjadi janji melalui Janji. Selesaikan dan kemudian diakhiri. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// utility function to cause delay // and get random value const delayAndGetRandom = (ms) =&gt; { return new Promise(resolve =&gt; setTimeout( () =&gt; { const val = Math.trunc(Math.random() * 100); resolve(val); }, ms )); }; async function fn() { const a = await 9; const b = await delayAndGetRandom(1000); const c = await 5; await delayAndGetRandom(1000); return a + b * c; } // Execute fn fn().then(console.log);</span></span></code> </pre> <br>  Berikut ini deskripsi cara kerja fungsi fn. <br><br><ul><li>  Setelah memanggilnya, baris pertama dikonversi dari const a = wait 9;  dalam const a = wait Promise.resolve (9); </li><li>  Setelah menggunakan Tunggu, eksekusi fungsi ditangguhkan hingga menerima nilainya (dalam situasi saat ini, adalah 9). </li><li>  delayAndGetRandom (1000) menjeda eksekusi fungsi fn sampai selesai sendiri (setelah 1 detik).  Ini sebenarnya menghentikan fungsi fn selama 1 detik. </li><li>  delayAndGetRandom (1000) melalui resolus mengembalikan nilai acak, yang kemudian ditugaskan ke variabel b. </li><li>  Nah, kasus variabel c mirip dengan kasus variabel a.  Setelah itu, semuanya berhenti sebentar, tetapi sekarang delayAndGetRandom (1000) tidak mengembalikan apa-apa, karena ini tidak diperlukan. </li><li>  Akibatnya, nilai-nilai dihitung dengan rumus a + b * c.  Hasilnya dibungkus dengan janji menggunakan Promise.resolve dan dikembalikan oleh fungsi. </li></ul><br>  Jeda ini mungkin menyerupai generator di ES6, tetapi ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alasan untuk ini</a> . <br><br><h3>  Kami memecahkan masalah </h3><br>  Nah, sekarang mari kita lihat solusi untuk masalah yang disebutkan di atas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/40b/ec5/c45/40bec5c4564dfabbe1810db3d4a60c2d.png"><br><br>  Fungsi finishMyTask menggunakan Menunggu untuk menunggu hasil operasi seperti queryDatabase, sendEmail, logTaskInFile, dan lainnya.  Jika kita membandingkan keputusan ini dengan di mana janji-janji itu digunakan, persamaannya akan menjadi jelas.  Namun demikian, versi dengan Async / Await sangat menyederhanakan semua kesulitan sintaksis.  Dalam hal ini, tidak ada banyak panggilan balik dan rantai seperti .then / .catch. <br><br>  Berikut ini adalah solusi dengan output angka, ada dua opsi. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wait = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i, ms</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(i), ms)); <span class="hljs-comment"><span class="hljs-comment">// Implementation One (Using for-loop) const printNumbers = () =&gt; new Promise((resolve) =&gt; { let pr = Promise.resolve(0); for (let i = 1; i &lt;= 10; i += 1) { pr = pr.then((val) =&gt; { console.log(val); return wait(i, Math.random() * 1000); }); } resolve(pr); }); // Implementation Two (Using Recursion) const printNumbersRecursive = () =&gt; { return Promise.resolve(0).then(function processNextPromise(i) { if (i === 10) { return undefined; } return wait(i, Math.random() * 1000).then((val) =&gt; { console.log(val); return processNextPromise(i + 1); }); }); };</span></span></code> </pre> <br>  Dan di sini ada solusi menggunakan fungsi async. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printNumbersUsingAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> wait(i, <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); } }</code> </pre> <br>  <b>Menangani kesalahan</b> <br><br>  Kesalahan yang belum diproses dibungkus dengan janji yang ditolak.  Namun, dalam fungsi async, Anda dapat menggunakan konstruksi coba / tangkap untuk melakukan penanganan kesalahan sinkron. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canRejectOrReturn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// wait one second await new Promise(res =&gt; setTimeout(res, 1000)); // Reject with ~50% probability if (Math.random() &gt; 0.5) { throw new Error('Sorry, number too big.') } return 'perfect number'; }</span></span></code> </pre> <br>  canRejectOrReturn () adalah fungsi asinkron yang berhasil ("angka sempurna") atau gagal dengan kesalahan ("Maaf, angka terlalu besar"). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> canRejectOrReturn(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'error caught'</span></span>; } }</code> </pre> <br>  Karena canRejectOrReturn diharapkan dieksekusi dalam contoh di atas, penghentiannya yang tidak berhasil akan memerlukan eksekusi blok tangkap.  Akibatnya, fungsi foo akan berakhir dengan tidak terdefinisi (ketika tidak ada yang dikembalikan di blok coba) atau dengan kesalahan tertangkap.  Akibatnya, fungsi ini tidak akan gagal, karena try / catch akan menangani fungsi foo itu sendiri. <br><br>  Ini adalah contoh lain: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> canRejectOrReturn(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'error caught'</span></span>; } }</code> </pre> <br>  Perlu memperhatikan fakta bahwa dalam contoh dari foo canRejectOrReturn dikembalikan.  Foo dalam hal ini dilengkapi dengan angka sempurna atau mengembalikan kesalahan Kesalahan ("Maaf, angka terlalu besar").  Blok tangkapan tidak akan pernah dieksekusi. <br><br>  Masalahnya adalah bahwa foo mengembalikan janji yang diteruskan dari canRejectOrReturn.  Oleh karena itu, solusi untuk fungsi foo menjadi solusi untuk canRejectOrReturn.  Dalam hal ini, kode hanya terdiri dari dua baris: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = canRejectOrReturn(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> promise; }</code> </pre> <br>  Tetapi apa yang terjadi jika Anda menggunakan menunggu dan kembali bersama: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> canRejectOrReturn(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'error caught'</span></span>; } }</code> </pre> <br>  Dalam kode di atas, foo berhasil dengan angka sempurna dan kesalahan ditangkap.  Tidak akan ada kegagalan.  Tapi foo akan diakhiri dengan canRejectOrReturn, dan bukan dengan undefined.  Mari kita pastikan ini dengan menghapus kembali menunggu canRejectOrReturn () baris: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> canRejectOrReturn(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶</span></span></code> </pre> <br><h3>  Kesalahan dan Kesalahan Umum </h3><br>  Dalam beberapa kasus, menggunakan Async / Await dapat menyebabkan kesalahan. <br><br>  <b>Lupa menunggu</b> <br><br>  Ini cukup sering terjadi - sebelum janji, kata kunci tunggu dilupakan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { canRejectOrReturn(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'caught'</span></span>; } }</code> </pre> <br>  Dalam kode, seperti yang Anda lihat, tidak ada menunggu atau kembali.  Karena itu, foo selalu keluar dengan tidak terdefinisi tanpa penundaan selama 1 detik.  Tapi janji itu akan dipenuhi.  Jika memberikan kesalahan atau reduksi, maka UnhandledPromiseRejectionWarning akan dipanggil. <br><br>  <b>Fungsi Async di Callback</b> <br><br>  Fungsi async sering digunakan dalam .map atau .filter sebagai panggilan balik.  Contohnya adalah fungsi fetchPublicReposCount (nama pengguna), yang mengembalikan jumlah repositori yang terbuka di GitHub.  Katakanlah ada tiga pengguna yang metriknya kita butuhkan.  Berikut adalah kode untuk tugas ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">'https://api.github.com/users'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Utility fn to fetch repo counts const fetchPublicReposCount = async (username) =&gt; { const response = await fetch(`${url}/${username}`); const json = await response.json(); return json['public_repos']; }</span></span></code> </pre> <br>  Kami membutuhkan akun ArfatSalman, octocat, norvig.  Dalam hal ini, jalankan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = [ <span class="hljs-string"><span class="hljs-string">'ArfatSalman'</span></span>, <span class="hljs-string"><span class="hljs-string">'octocat'</span></span>, <span class="hljs-string"><span class="hljs-string">'norvig'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counts = users.map(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> username =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchPublicReposCount(username); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; });</code> </pre> <br>  Anda harus memperhatikan Menunggu dalam panggilan balik .map.  Di sini jumlah adalah serangkaian janji, well .map adalah panggilan balik anonim untuk setiap pengguna yang ditentukan. <br><br>  <b>Penggunaan menunggu yang sangat konsisten</b> <br><br>  Ambil kode berikut sebagai contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchAllCounts</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counts = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; users.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> username = users[i]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchPublicReposCount(username); counts.push(count); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counts; }</code> </pre> <br>  Di sini, nomor repo ditempatkan dalam variabel jumlah, kemudian nomor ini ditambahkan ke array jumlah.  Masalah dengan kode adalah bahwa sampai data pengguna pertama tiba dari server, semua pengguna berikutnya akan berada dalam mode siaga.  Dengan demikian, dalam satu saat, hanya satu pengguna yang diproses. <br><br>  Jika, misalnya, dibutuhkan sekitar 300 ms untuk memproses satu pengguna, maka untuk semua pengguna ini sudah satu detik, waktu yang dihabiskan secara linear tergantung pada jumlah pengguna.  Tetapi karena mendapatkan jumlah repo tidak bergantung satu sama lain, prosesnya dapat diparalelkan.  Ini membutuhkan kerja dengan .map dan Promise.all: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchAllCounts</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promises = users.map(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> username =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchPublicReposCount(username); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(promises); }</code> </pre> <br>  Promise.all pada input menerima berbagai janji dengan kembalinya janji.  Yang terakhir setelah menyelesaikan semua janji dalam array atau pada reduksi pertama selesai.  Mungkin saja mereka semua tidak memulai pada saat yang sama - untuk memastikan peluncuran secara bersamaan, Anda dapat menggunakan p-peta. <br><br><h3>  Kesimpulan </h3><br>  Fitur Async menjadi semakin penting untuk pengembangan.  Nah, untuk penggunaan fungsi-fungsi async yang adaptif, ada baiknya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow noopener noreferrer">Async Iterators</a> .  Pengembang JavaScript harus berpengalaman dalam hal ini. <br><br><blockquote>  <b>Skillbox merekomendasikan:</b> <br><br><ul><li>  Kursus praktis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"PRO Pengembang Seluler"</a> . </li><li>  Kursus online yang diterapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Analis Data dengan Python"</a> . </li><li>  Kursus praktis dua tahun <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Saya seorang Pengembang Web PRO"</a> . </li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458950/">https://habr.com/ru/post/id458950/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458936/index.html">"Lebih mudah untuk menjawab daripada diam" - sebuah wawancara besar dengan ayah dari memori transaksional, Maurice Herlichi</a></li>
<li><a href="../id458938/index.html">C ++ 20 dibundel, C ++ 23 dimulai. Hasil pertemuan di Cologne</a></li>
<li><a href="../id458940/index.html">Bagaimana kami menerapkan pengujian tangkas</a></li>
<li><a href="../id458944/index.html">Mempekerjakan seorang karyawan dimulai dengan ... rasa hormat. Kami akan mewawancarai insinyur</a></li>
<li><a href="../id458948/index.html">Habr Weekly # 8 / Yandex Sorcerers, sebuah buku tentang Prince of Persia, YouTube melawan peretas, laser "jantung" Pentagon</a></li>
<li><a href="../id458952/index.html">Tuning pengaturan PostgreSQL untuk mengoptimalkan kinerja</a></li>
<li><a href="../id458954/index.html">Jenis deteksi apa yang berguna dalam pengawasan video. Mekanisme dan fungsi</a></li>
<li><a href="../id458956/index.html">Pembelajaran Mesin vs. pendekatan analitis</a></li>
<li><a href="../id458960/index.html">Pencarian perusahaan</a></li>
<li><a href="../id458962/index.html">Konversi gambar menjadi suara - apa yang bisa Anda dengar?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>