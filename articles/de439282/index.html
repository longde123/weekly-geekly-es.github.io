<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👐🏽 💳 🌍 SVG-Filtereffekte. Teil 1. SVG-Filter 101 🍕 👩🏿‍⚖️ 🌔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die vorgeschlagene Artikelserie " SVG Filtering Effects " von Sara Soueidan, freiberufliche UI / UX-Schnittstellenentwicklerin und Autorin vieler im L...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SVG-Filtereffekte. Teil 1. SVG-Filter 101</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439282/"><p>  Die vorgeschlagene Artikelserie " <strong>SVG Filtering Effects</strong> " von Sara Soueidan, freiberufliche UI / UX-Schnittstellenentwicklerin und Autorin vieler im Libanon ansässiger technischer Artikel, konzentriert sich auf die Arbeit von SVG-Filtern und besteht aus folgenden Artikeln: </p><br><h1 id="effekty-filtracii-svg">  SVG-Filtereffekte </h1><br><ol><li>  Auswirkungen von SVG-Filtern.  Teil 1. SVG-Filter 101. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auswirkungen von SVG-Filtern.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2. Konturtext mit feMorphology</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SVG-Filtereffekte.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3. Der Effekt der Bildposterisierung mit feComponentTransfer</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SVG-Filtereffekte.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 4. Zweifarbige Bilder mit <strong>feComponentTransfer</strong></a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SVG-Filtereffekte.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 5. Text mit <strong>feDisplacementMap</strong> an die Oberflächentextur <strong>anpassen</strong></a> </li></ol><br><hr><br><p>  Dies ist der erste Artikel in einer Reihe über SVG-Filter.  Diese Anleitung hilft Ihnen zu verstehen, was es ist, und zeigt Ihnen, wie Sie sie verwenden können, um Ihre eigenen visuellen Effekte zu erstellen. </p><br><p><img src="https://habrastorage.org/webt/_8/ka/is/_8kaisnavnh_qmr3tvdsxofq0ii.png"></p><a name="habracut"></a><br><p>  <strong>CSS</strong> bietet uns derzeit die Möglichkeit, Farbeffekte unter anderem auf Bilder wie Sättigung, Helligkeit und Kontrast anzuwenden, indem wir die <strong>Filtereigenschaft</strong> und die damit verbundenen Funktionen verwenden. </p><br><p>  Jetzt haben wir 11 Filterfunktionen in CSS, die eine Reihe von Effekten ausführen, von Unschärfe über Änderung des Farbkontrasts und der Sättigung bis hin zu vielem mehr.  Weitere Informationen hierzu finden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie in der CSS-Referenz</a> . </p><br><p>  Obwohl leistungsstark und sehr praktisch, sind CSS-Filter auch sehr begrenzt.  Die Effekte, die wir mit ihnen erzielen können, sind häufig auf Bilder anwendbar und beschränken sich auf Farbmanipulation und einfache Unschärfe.  Um leistungsstärkere Effekte zu erzielen, die wir auf einen größeren Bereich von Elementen anwenden können, benötigen wir einen größeren Bereich von Funktionen.  Diese Funktionen sind heute verfügbar und seit über zehn Jahren in SVG verfügbar.  In diesem Artikel, dem ersten einer Reihe von SVG-Filtern, erfahren Sie mehr über die Funktionen von SVG-Filtern, die als „Grundelemente“ bezeichnet werden, und deren Verwendung. </p><br><p>  CSS-Filter werden aus SVG importiert.  Sie sind ziemlich gut optimierte Versionen einer Teilmenge der in SVG eingeführten und seit vielen Jahren in der SVG-Spezifikation vorhandenen Filtereffekte. </p><br><p>  SVG hat mehr Filtereffekte als CSS, und SVG-Versionen sind leistungsfähiger und führen viel komplexere Effekte aus als ihre CSS-Verknüpfungen.  Beispielsweise können Sie derzeit ein Element mit der CSS-Filterfunktion <strong>blur () verwischen</strong> .  Durch Anwenden des Unschärfeeffekts mit dieser Funktion wird eine gleichmäßige Gaußsche Unschärfe des Elements erzeugt, auf das es angewendet wird.  Die folgende Abbildung zeigt das Ergebnis der Anwendung von 6px-Unschärfe auf ein Bild in CSS: </p><br><p><img src="https://habrastorage.org/webt/b0/qa/fy/b0qafyst_uc08euvuxzilp13-wi.png" alt="Effekt der Anwendung der Funktion ** blur () ** - Gaußsche Unschärfe"><br>  <em>Abb_1.</em>  <em>Die Anwendung der CSS-Funktion <strong>blur ()</strong> bewirkt eine Gaußsche Unschärfe.</em> </p><br><p>  Die Funktion <strong>blur ()</strong> erzeugt einen Unschärfeeffekt, der im Bild gleichmäßig in beide Richtungen (X und Y) angewendet wird.  Diese Funktion ist jedoch lediglich eine vereinfachte und begrenzte Reduzierung des in SVG verfügbaren Unschärfefilterprimitivs, wodurch wir das Bild entweder gleichmäßig verwischen oder einen unidirektionalen Unschärfeeffekt entlang der X- oder Y-Achse anwenden können. </p><br><p><img src="https://habrastorage.org/webt/e5/gp/rr/e5gprr6riymt0ede8sxusumcyfk.png" alt="Der Effekt der Anwendung der SVG-Funktion ** blur () ** separat entlang der Achsen"><br>  <em>Abb_2.</em>  <em>Der Effekt der Anwendung der SVG-Funktion <strong>blur ()</strong> separat entlang der Achsen.</em> </p><br><p>  SVG-Filter können sowohl auf HTML-Elemente als auch auf SVG-Elemente angewendet werden.  Der SVG-Filtereffekt kann mithilfe der Filterfunktion url () auf ein HTML-Element in CSS angewendet werden.  Wenn Sie beispielsweise einen Filtereffekt mit dem in SVG definierten Bezeichner <strong>myAwesomeEffect haben</strong> (wir werden bald über das Definieren von Filtereffekten in SVG sprechen), können Sie diesen Effekt auf ein HTML-Element oder Bild wie das folgende anwenden: </p><br><pre><code class="plaintext hljs">.el { filter: url(#myAwesomeEffect); }</code> </pre> <br><p>  Wie Sie in dieser Artikelserie sehen werden, können SVG-Filter mithilfe einiger Codezeilen Effekte auf Photoshop-Ebene in einem Browser erstellen.  Ich hoffe, dass diese Serie dazu beiträgt, die Geheimhaltung zu zerstreuen und einen Teil des Potenzials von SVG-Filtern freizusetzen, was Sie dazu inspirieren wird, sie in Ihren eigenen Projekten zu verwenden. </p><br><p>  Aber was ist mit der Browserunterstützung? </p><br><h2 id="podderzhka-brauzerami">  Browser-Unterstützung </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Browserunterstützung für die</a> meisten SVG-Filter ist beeindruckend.  Die Methode zum Anwenden des Effekts kann jedoch in einigen Browsern unterschiedlich sein, abhängig von der Unterstützung einzelner Filterprimitive, die im SVG-Filtereffekt verwendet werden, sowie von möglichen Browserfehlern.  Die Browserunterstützung kann sich auch unterscheiden, wenn ein SVG-Filter auf SVG-Elemente oder auf HTML-Elemente angewendet wird. </p><br><p>  Ich würde empfehlen, Filtereffekte als Erweiterung zu betrachten: Sie können einen Effekt fast immer als Verbesserung zusätzlich zu einer völlig nützlichen Erfahrung ohne Filter anwenden.  Viele Leute wissen, dass ich den progressiven Ansatz zur Erstellung einer Benutzeroberfläche unterstütze, wann immer dies möglich ist.  Daher werden wir uns in dieser Artikelserie nicht zu sehr um die Browserunterstützung kümmern. </p><br><p>  Obwohl die Unterstützung für SVG-Filter im Allgemeinen gut ist, sollten Sie bedenken, dass einige der Effekte, die wir später diskutieren werden, als experimentell angesehen werden können.  Ich werde auf größere Probleme oder Fehler hinweisen, wenn und wann sie auftreten. </p><br><p>  Wie definiere und erstelle ich einen Filtereffekt in SVG? </p><br><h2 id="element--filter">  &lt;Filter&gt; -Element </h2><br><p>  Wie lineare Verläufe, Masken, Muster und andere grafische Effekte in SVGs haben Filter ein zweckmäßiges Spezialelement: <strong>&lt;Filter&gt;</strong> . </p><br><p>  Es wird nie direkt angezeigt, sondern nur als Objekt verwendet, auf das mithilfe des <strong>Filterattributs</strong> in SVG oder der Funktion <strong>url ()</strong> in CSS verwiesen werden kann.  Elemente, die nicht ohne explizite Referenz angezeigt werden, werden normalerweise als Vorlagen in <strong>&lt;defs&gt;</strong> -Elementen in SVG definiert.  SVG <strong>&lt;Filter&gt;</strong> muss jedoch nicht in ein <strong>defs-</strong> Element eingeschlossen werden.  <strong>Unabhängig</strong> davon, ob Sie den Filter in ein <strong>defs-</strong> Element <strong>einschließen</strong> oder nicht, wird er ohnehin nicht angezeigt. </p><br><p>  Der Grund dafür ist, dass für den <strong>Filter die Verarbeitung des Originalbilds erforderlich ist</strong> .  Wenn Sie dieses Quellbild nicht explizit definieren, indem Sie den Filter aufrufen, hat der Filter nichts zu rendern und funktioniert daher nicht. </p><br><p>  Ein sehr einfaches, minimales Codebeispiel, das einen SVG-Filter definiert und auf das Originalbild in SVG anwendet, sieht folgendermaßen aus: </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="450" viewBox="0 0 600 450"&gt; &lt;filter id="myFilter"&gt; &lt;!-- filter effects go in here --&gt; &lt;/filter&gt; &lt;image xlink:href="..." width="100%" height="100%" x="0" y="0" filter="url(#myFilter)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>  Der Filter im obigen Codebeispiel macht im Moment nichts, da er leer ist.  Um einen Filtereffekt zu erstellen, müssen Sie eine Reihe von einer oder mehreren Filteroperationen definieren, die diesen Effekt innerhalb des Filters erzeugen.  Mit anderen Worten, das <strong>&lt;filter&gt;</strong> -Element ist ein Container für eine Reihe von Filteroperationen, die zusammen einen Filtereffekt erzeugen.  Diese Filteroperationen in SVG werden als " <strong>Filterprimitive</strong> " bezeichnet. </p><br><h2 id="primitivy-filtra">  Grundelemente filtern </h2><br><p>  Daher enthält in SVG jedes <strong>&lt;filter&gt;</strong> -Element eine Reihe von Filterprimitiven als untergeordnete Elemente.  Jedes Filterprimitiv führt eine elementare grafische Operation an einer oder mehreren Eingaben aus und erstellt ein grafisches Ergebnis. </p><br><p>  Filterprimitive werden zweckmäßigerweise nach den von ihnen ausgeführten Grafikoperationen benannt.  Ein <strong>Grundelement</strong> , das den Gaußschen Weichzeichnungseffekt auf eine <strong>Grafikquelle anwendet,</strong> heißt beispielsweise <strong>feGaussianBlur</strong> .  Alle Grundelemente haben das gleiche Präfix: zB, kurz für „ <em>Filtereffekt</em> “.  Auch hier sind Namen in SVG praktisch, um zu verstehen, was dieses Element ist oder was es tut. </p><br><p>  Der folgende Codeausschnitt zeigt, wie ein einfacher Filter aussieht, wenn Sie eine 5-Pixel-Gauß-Unschärfe auf das Bild anwenden: </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="450" viewBox="0 0 600 450"&gt; &lt;filter id="myFilter"&gt; &lt;feGaussianBlur stDeviation="5"&gt;&lt;/feGaussianBlur&gt; &lt;/filter&gt; &lt;image xlink:href="..." width="100%" height="100%" x="0" y="0" filter="url(#myFilter)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>  Derzeit definiert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die <strong>SVG-</strong></a> Filterspezifikation 17 Filterprimitive, die äußerst leistungsstarke Grafikeffekte erzeugen können, einschließlich, aber nicht beschränkt auf Rausch- und Texturgenerierung, Lichteffekte, Farbmanipulation (Kanal zu Kanal) und vieles mehr. </p><br><p>  Das Filterprimitiv akzeptiert eine Grafikquelle für die Eingabe und Ausgabe in eine andere.  Und die Ausgabe eines Filtereffekts kann als Eingabe für einen anderen verwendet werden.  Dies ist sehr wichtig und sehr effektiv, da Sie mit fast unzähligen Kombinationen von Filtereffekten fast unzählige Grafikeffekte erstellen können. </p><br><p>  Jedes Filterprimitiv kann eine oder zwei Eingaben akzeptieren und nur ein Ergebnis ausgeben.  Die Eingabe des Filterprimitivs wird im Attribut in definiert.  Das Ergebnis der Operation wird im <strong>Ergebnisattribut</strong> definiert.  Wenn für den Filtereffekt eine zweite Eingabe erforderlich ist, wird diese im Attribut <strong>in2</strong> angegeben.  Das Ergebnis der Operation kann als Eingabe für jede andere Operation verwendet werden. Wenn die Eingabe der Operation jedoch nicht im Attribut in angegeben ist, wird das Ergebnis der vorherigen Operation automatisch als Eingabe verwendet.  Wenn Sie das <strong>Ergebnis des</strong> Grundelements nicht angeben, wird das <strong>Ergebnis</strong> automatisch als Eingabe für das nächste Grundelement verwendet.  Dies wird klarer, wenn wir beginnen, Codebeispiele zu studieren. </p><br><p>  Das Filterprimitiv kann andere Datentypen als Eingabe verwenden, von denen die wichtigsten sind: </p><br><ul><li>  <strong>SourceGraphic</strong> : Element, auf das der gesamte Filter angewendet wird;  Zum Beispiel ein Bild oder ein Textstück. </li><li>  <strong>SourceAlpha</strong> : Dies ist dasselbe wie <strong>SourceGraphic</strong> , außer dass diese Grafik nur den Alphakanal des Elements enthält.  Bei einem JPEG-Bild ist dies beispielsweise ein schwarzes Rechteck von der Größe des Bildes. </li></ul><br><p>  Sie werden feststellen, dass Sie manchmal die Grafikquelle als Eingabe verwenden möchten und manchmal nur den Alphakanal.  Die Beispiele, die wir in diesem und den folgenden Artikeln behandeln werden, vermitteln ein klares Verständnis dafür, wann und was zu verwenden ist. </p><br><p>  Dieses Code-Snippet ist ein Beispiel dafür, wie ein Filter mit einem Paket von Filterprimitiven als untergeordnete Elemente aussehen könnte.  Mach dir keine Sorgen über Primitive und was sie tun.  Achten Sie an dieser Stelle nur darauf, wie die Ein- und Ausgänge bestimmter Grundelemente definiert und verwendet werden.  Ich habe einige Kommentare zur Hilfe hinzugefügt. </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="400" viewBox="0 0 850 650"&gt; &lt;filter id="filter"&gt; &lt;feOffset in="SourceAlpha" dx="20" dy="20"&gt;&lt;/feOffset&gt; &lt;!-- since the previous filter did not have a result defined and this following one does not have the input set, the result of the above primitive is automatically used as input to the following filter --&gt; &lt;feGaussianBlur stdDeviation="10" result="DROP"&gt;&lt;/feGaussianBlur&gt; &lt;!-- setting/defining the result names in all caps is a good way to make them more distinguishable and the overall code more readable --&gt; &lt;feFlood flood-color="#000" result="COLOR"&gt;&lt;/feFlood&gt; &lt;!-- This primitive is using the outputs of the previous two primitives as input, and outputting a new effect --&gt; &lt;feComposite in="DROP" in2="COLOR" operator="in" result="SHADOW1"&gt;&lt;/feComposite&gt; &lt;feComponentTransfer in="SHADOW1" result="SHADOW"&gt; &lt;feFuncA type="table" tableValues="0 0.5"&gt;&lt;/feFuncA&gt; &lt;/feComponentTransfer&gt; &lt;!-- You can use ANY two results as inputs to any primitive, regardless of their order in the DOM.--&gt; &lt;feMerge&gt; &lt;feMergeNode in="SHADOW"&gt;&lt;/feMergeNode&gt; &lt;feMergeNode in="SourceGraphic"&gt;&lt;/feMergeNode&gt; &lt;/feMerge&gt; &lt;/filter&gt; &lt;image xlink:href="..." x="0" y="0" width="100%" height="100%" filter="url(#filter)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>  Das letzte Konzept, das ich kurz erläutern möchte, bevor ich zu unserem ersten Filterbeispiel übergehe, ist das Konzept der Filterregion. </p><br><h2 id="oblast-filtracii">  Filtrationsbereich </h2><br><p>  Für eine Reihe von Filtervorgängen muss ein Bereich verarbeitet werden, auf den sie angewendet werden können.  Beispielsweise haben Sie möglicherweise eine komplexe SVG mit vielen Elementen und möchten den Filtereffekt nur auf einen bestimmten Bereich oder auf ein oder eine Gruppe von Elementen innerhalb dieser SVG anwenden. </p><br><p>  In SVG haben Elemente „Regionen“, deren Grenzen durch die Kanten des das Element begrenzenden Rechtecks ​​definiert sind.  Ein Begrenzungsrahmen (auch als „bbox“ abgekürzt) ist das kleinste umschließende Rechteck um ein Element.  In der folgenden Abbildung wird beispielsweise ein solches Rechteck für ein Textstück rosa hervorgehoben. </p><br><p><img src="https://habrastorage.org/webt/hu/uy/i1/huuyi1kr0i8ldvfpggxgwpdi6sm.png" alt="Das kleinste umschließende Rechteck um ein Textstück"><br>  <em>Abb_3.</em>  <em>Das kleinste umschließende Rechteck um ein Textstück.</em> </p><br><p>  Bitte beachten Sie, dass dieses Rechteck einige weitere vertikale Leerzeichen enthalten kann, da die Höhe der Textzeile bei der Berechnung der Höhe des Begrenzungsrechtecks ​​berücksichtigt wird. </p><br><p>  Standardmäßig ist der Elementfilterbereich der angrenzende Elementrahmen.  Wenn Sie daher einen Filtereffekt auf unser Textfragment anwenden, wird der Effekt auf dieses Rechteck beschränkt und alle Filterergebnisse, die außerhalb des Rechtecks ​​liegen, werden abgeschnitten.  Obwohl dies vernünftig ist, ist es nicht sehr praktisch, da viele Filter einige Pixel außerhalb des Begrenzungsrahmens beeinflussen und diese Pixel standardmäßig letztendlich abgeschnitten werden. </p><br><p>  Wenn Sie beispielsweise einen Unschärfeeffekt auf unser Textfragment anwenden, können Sie sehen, dass es am linken und rechten Rand des den Text begrenzenden Rechtecks ​​zugeschnitten ist: </p><br><p><img src="https://habrastorage.org/webt/ll/ih/e4/llihe4hbwx94zl3xk-w9zmcmmkq.png" alt="Der auf den Text angewendete Unschärfeeffekt wird sowohl auf der rechten als auch auf der linken Seite des den Text begrenzenden Rechtecks ​​zugeschnitten."><br>  <em>Abb_4.</em>  <em>Der auf den Text angewendete Unschärfeeffekt wird sowohl auf der rechten als auch auf der linken Seite des den Text begrenzenden Rechtecks ​​zugeschnitten.</em> </p><br><p>  Wie verhindern wir das?  Die Antwort lautet: durch Erweitern des Filterbereichs.  Wir können den Bereich, auf den der Filter angewendet wird, erweitern, indem wir die Attribute <strong>x</strong> , <strong>y</strong> , <strong>width</strong> und <strong>height</strong> des &lt;filter&gt; -Elements ändern. </p><br><p>  Gemäß der Spezifikation, </p><br><blockquote>  Oft ist es notwendig, Felder im Filterbereich bereitzustellen, da der Filtereffekt einige Bits außerhalb des Begrenzungsrahmens für ein bestimmtes Objekt beeinflussen kann.  Zu diesem Zweck können Sie den <strong>X-</strong> und <strong>Y-</strong> Eigenschaften negative Werte in Prozent und den Eigenschaften <strong>width</strong> und <strong>height</strong> Werte über 100% zuweisen. </blockquote><p>  Standardmäßig haben Filter Bereiche, die 10% der Breite und Höhe des Begrenzungsrahmens in alle vier Richtungen erstrecken.  Mit anderen Worten, die Standardwerte für die Attribute <strong>x</strong> , <strong>y</strong> , <strong>width</strong> und <strong>height</strong> sind: </p><br><pre> <code class="plaintext hljs">&lt;filter x="-10%" y="-10%" width="120%" height="120%" filterUnits="objectBoundingBox"&gt; &lt;!-- filter operations here --&gt; &lt;/filter&gt;</code> </pre> <br><p>  Wenn Sie diese Attribute nicht in das <strong>&lt;filter&gt;</strong> -Element aufnehmen, werden die Standardwerte verwendet.  Sie können sie auch überschreiben, um den Bereich nach Bedarf zu erweitern oder zu verkleinern. </p><br><p>  <strong>Beachten</strong> Sie, dass die in den Attributen <strong>x</strong> , <strong>y</strong> , <strong>width</strong> und <strong>height</strong> verwendeten Einheiten davon abhängen, welcher Attributwert <strong>filterUnits</strong> verwendet wird.  Es definiert das Koordinatensystem der Attribute <strong>x</strong> , <strong>y</strong> , <strong>width</strong> und <strong>height</strong> und kann einen von zwei Werten annehmen: </p><br><ul><li>  <strong>objectBoundingBox</strong> .  Dies ist der Standardwert.  Wenn <strong>filterUnits</strong> auf <strong>objectBoundingBox festgelegt ist</strong> , sind die Attributwerte <strong>x</strong> , <strong>y</strong> , <strong>width</strong> und <strong>height</strong> Prozentsätze oder Brüche der Größe des Begrenzungsrahmens des Elements.  Dies bedeutet auch, dass Sie Bruchwerte anstelle von Prozentsätzen verwenden können, wenn Sie dies bevorzugen. </li><li>  <strong>userSpaceOnUse</strong> Wenn <strong>filterUnits</strong> auf <strong>userSpaceOnUse</strong> <strong>festgelegt</strong> ist, <strong>beziehen</strong> sich die Koordinaten der Attribute x, y, width und height auf das aktuelle vom Benutzer verwendete Koordinatensystem.  Mit anderen Worten, dies bezieht sich auf das in SVG verwendete aktuelle Koordinatensystem, das Pixel als Maßeinheiten verwendet, und in der Regel auf die Größe des SVG selbst, vorausgesetzt, die <strong>viewBox-</strong> Werte entsprechen den Werten des ursprünglichen Koordinatensystems. </li></ul><br><blockquote>  Alles, was Sie über Koordinatensysteme in SVG wissen müssen, finden Sie in diesem Artikel, den ich vor einigen Jahren geschrieben habe. </blockquote><br><pre> <code class="plaintext hljs">&lt;!-- Using objectBoundingBox units --&gt; &lt;filter id="filter" x="5%" y="5%" width="100%" height="100%"&gt; &lt;!-- Using userSpaceOnUse units --&gt; &lt;filter id="filter" filterUnits="userSpaceOnUse" x="5px" y="5px" width="500px" height="350px"&gt;</code> </pre> <br><h3 id="bystryy-sovet-vizualizaciya-tekuschey-oblasti-filtra-s-pomoschyu-feflood">  Kurztipp: Visualisierung des aktuellen Filterbereichs mit feFlood </h3><br><p>  Wenn Sie jemals die Grenzen eines Filterbereichs sehen müssen, können Sie ihn visualisieren, indem Sie ihn mit etwas Farbe füllen.  Praktischerweise gibt es ein Filterprimitiv namens <strong>feFlood</strong> , dessen einziger Zweck genau dies ist: den aktuellen Filterbereich mit der im <strong>Flutfarbenattribut</strong> angegebenen Farbe zu füllen. </p><br><p>  Wenn wir also davon ausgehen, dass wir einen Text haben, dessen Filterbereich wir sehen möchten, sieht der Code möglicherweise folgendermaßen aus: </p><br><pre> <code class="plaintext hljs">&lt;svg width="600px" height="400px" viewBox="0 0 600 400"&gt; &lt;filter id="flooder" x="0" y="0" width="100%" height="100%"&gt; &lt;feFlood flood-color="#EB0066" flood-opacity=".9"&gt;&lt;/feFlood&gt; &lt;/filter&gt; &lt;text dx="100" dy="200" font-size="150" font-weight="bold" filter="url(#flooder)"&gt;Effect!&lt;/text&gt; &lt;/svg&gt;</code> </pre> <br><p>  Wie Sie dem obigen <strong>Codeausschnitt entnehmen können,</strong> akzeptiert das <strong>Grundelement feFlood</strong> auch das Attribut " <strong>Flutopazität"</strong> , mit dem die Transparenz der Füllfarbenebene erstellt werden kann. </p><br><p>  Das obige Snippet füllt den Filterbereich mit Pink.  Aber hier ist die Sache: Wenn Sie den Bereich mit Farbe füllen, füllen Sie ihn buchstäblich mit Farbe, was bedeutet, dass die Farbe alles im Filterbereich abdeckt, einschließlich aller Elemente und Effekte, die Sie zuvor erstellt haben, sowie den Text selbst.  Das ist doch das Konzept der Füllung, oder? </p><br><p><img src="https://habrastorage.org/webt/aj/pc/qc/ajpcqctctaikdiirvjexjeuh6yg.png" alt="Vor und nach dem Füllen des Filtertextbereichs mit Farbe"><br>  <em>Abb_5.</em>  <em>Vor und nach dem Füllen des Textbereichs des Filters mit Farbe.</em> </p><br><p>  Um dies zu ändern, müssen wir die Farbebene unten verschieben und die ursprüngliche Textebene oben anzeigen. </p><br><p>  Wenn Sie mehrere Kontextebenen haben, die im SVG-Filter übereinander angezeigt werden sollen, können Sie das <strong>Filterprimitiv &lt;feMerge&gt; verwenden</strong> .  Wie der Name schon sagt, wird das <strong>Grundelement feMerge</strong> verwendet, um Ebenen von Elementen oder Effekten miteinander zu kombinieren. </p><br><p>  Das Grundelement <strong>hat kein in-Attribut.</strong>  <strong>Zum Zusammenführen der Ebenen in <strong>&lt;feMerge&gt;</strong> werden zwei oder mehr <strong>&lt;feMergeNode&gt; verwendet</strong> , von denen jede ein eigenes Attribut hat, das die Ebene darstellt, die wir hinzufügen möchten.</strong> <br></p><p>  Die Schichtung der Schicht (oder des „Knotens“) hängt von der Reihenfolge der Quelle <strong>&lt;feMergeNode&gt; ab.</strong> Der erste <strong>&lt;feMergeNode&gt; wird</strong> „hinter“ oder „unter“ der zweiten angezeigt.  Der letzte <strong>&lt;feMergeNode&gt;</strong> repräsentiert die oberste Ebene.  Usw. </p><br><p>  In unserem Beispiel mit Text ist die Farbfüllung eine Ebene, und die Textquelle (Grafikquelle) ist eine andere Ebene, und wir möchten den Text über die Farbfüllung setzen.  Unser Code sieht folgendermaßen aus: </p><br><pre> <code class="plaintext hljs">&lt;svg width="600px" height="400px" viewBox="0 0 600 400"&gt; &lt;filter id="flooder"&gt; &lt;feFlood flood-color="#EB0066" flood-opacity=".9" result="FLOOD"&gt;&lt;/feFlood&gt; &lt;feMerge&gt; &lt;feMergeNode in="FLOOD" /&gt; &lt;feMergeNode in="SourceGraphic" /&gt; &lt;/feMerge&gt; &lt;/filter&gt; &lt;text dx="100" dy="200" font-size="150" font-weight="bold" filter="url(#flooder)"&gt;Effect!&lt;/text&gt; &lt;/svg&gt;</code> </pre> <br><p>  Beachten Sie, wie ich das Ergebnis von <strong>feFlood</strong> im <strong>Ergebnisattribut benannt habe</strong> , damit ich diesen Namen in der <strong>Ebene &lt;feMergeNode&gt;</strong> als Eingabe verwenden kann.  Da wir den Quelltext über der Farbe des Streams anzeigen möchten, verweisen wir mit <strong>SourceGraphic</strong> auf diesen Text.  Die folgende Demo zeigt das Ergebnis: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/SaraSoueidan/embed/preview/dJddbK" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="primenenie-teni-k-izobrazheniyu">  Wenden Sie einen Schatten auf ein Bild an </h2><br><p>  Lassen Sie mich mit einer kurzen Warnung beginnen: Erstellen Sie besser einen einfachen Schatten mit der CSS-Filterfunktion <strong>drop-shadow ()</strong> .  Der SVG-Filterpfad ist viel ausführlicher.  Wie bereits erwähnt, sind CSS-Filterfunktionen praktische Verknüpfungen.  Ich möchte dieses Beispiel dennoch als einfachen Einstiegspunkt für komplexere Filtereffekte betrachten, auf die wir in zukünftigen Artikeln eingehen werden. </p><br><p>  Wie entsteht der Schatten? </p><br><p>  Ein Schatten ist normalerweise eine hellgraue Schicht hinter oder unter einem Element, die dieselbe Form (oder Form) wie das Element selbst hat.  Mit anderen Worten, Sie können dies als eine verschwommene graue Kopie des Elements betrachten. </p><br><p>  Wenn Sie SVG-Filter erstellen, müssen Sie schrittweise argumentieren.  Welche Schritte sind erforderlich, um diesen oder jenen Effekt zu erzielen?  Für einen Schatten kann eine unscharfe graue Kopie eines Elements erzeugt werden, indem eine schwarze Kopie des Elements verwischt und dann diese schwarze Kopie eingefärbt wird, d. H.  mach sie grau.  Diese neu erstellte unscharfe graue Kopie wird dann hinter dem Originalelement platziert und leicht in beide Richtungen verschoben. </p><br><p>  Wir <strong>werden also zunächst eine schwarze Kopie unseres Elements erhalten und es verwischen</strong> .  Eine schwarze Kopie kann mithilfe des Alphakanals des Elements erstellt werden, wobei <strong>SourceAlpha</strong> als Filtereingabe verwendet wird. </p><br><p>  Das <strong>Grundelement feGaussianBlur</strong> wird verwendet, um Gaussian Blur auf diese SourceAlpha-Ebene anzuwenden.  Die erforderliche Unschärfe wird im Attribut <strong>stdDeviation</strong> (kurz für Standardabweichung) festgelegt.  Wenn Sie einen Wert für das Attribut <strong>stdDeviation festlegen</strong> , wird dieser Wert verwendet, um die Eingabedaten gleichmäßig zu verwischen.  Sie können auch zwei numerische Werte angeben. Der erste wird verwendet, um das Element in horizontaler Richtung zu verwischen, und der zweite wird für vertikale Unschärfe verwendet.  Für den Schatten müssen wir eine einheitliche Unschärfe anwenden, damit unser Code damit beginnt: </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="400" viewBox="0 0 850 650"&gt; &lt;filter id="drop-shadow"&gt; &lt;-- Grab a blakc copy of the source image and blur it by 10 --&gt; &lt;feGaussianBlur in="SourceAlpha" stdDeviation="10" result="DROP"&gt;&lt;/feGaussianBlur&gt; &lt;/filter&gt; &lt;image xlink:href="..." x="0" y="0" width="100%" height="100%" filter="url(#drop-shadow)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>  Das obige Codefragment führt zu folgendem Effekt, bei dem derzeit nur der unscharfe Alphakanal des Bildes angezeigt wird: </p><br><p><img src="https://habrastorage.org/webt/zd/e9/ye/zde9ye5ycftyjmi_cru94ty3jde.png" alt="Schwarzes Kopierbild mit Unschärfe (Schatten) erstellt"><br>  <em>Abb_6.</em>  <em>Schwarze Kopie des Bildes mit Unschärfe (Schatten) erstellt.</em> </p><br><p>  Dann wollen wir <strong>die Farbe des Schattens ändern und ihn grau machen</strong> .  Dazu wenden wir eine Farbfüllung auf den Filterbereich an und kombinieren diese Farbfüllungsebene mit der von uns erstellten Schattenebene. </p><br><p>  Ausrichtung ist die Verbindung eines grafischen Elements mit einem unscharfen Hintergrund.  Der unscharfe Hintergrund ist der Inhalt hinter dem Element, an dem das Element ausgerichtet ist.  In unserem Filter ist die Füllfarbe die oberste Ebene und der verschwommene Schatten der Hintergrund, da er dahinter liegt.  Wir werden das <strong>feComposite-Grundelement</strong> in den folgenden Artikeln ausführlicher behandeln. Wenn Sie also mit der Komposition und ihrer Funktionsweise nicht vertraut sind, empfehle ich Ihnen, einen <strong>ausführlichen Artikel</strong> zu diesem Thema in meinem Blog zu lesen. </p><br><p>  Das <strong>Grundelement feComposite</strong> verfügt über ein <strong>Operatorattribut</strong> , mit dem angegeben wird, welche zusammengesetzte Operation verwendet werden soll. </p><br><p>  Bei Verwendung des Operators " <strong>In Composite</strong> " wird die Farbfüllungsebene "abgeschnitten" und nur der Farbbereich angezeigt, der unserer Schattenebene entspricht.  Beide Schichten werden dort gemischt, wo sie sich schneiden, d.h.  graue Farbe wird verwendet, um unseren schwarzen Schatten zu färben. </p><br><p>  <strong>feComposite</strong>      ,    <strong>in</strong>  <strong>in2</strong> .   —    ,   —   .    ,    <strong>operator</strong> ,      : </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="400" viewBox="0 0 850 650"&gt; &lt;filter id="drop-shadow"&gt; &lt;feGaussianBlur in="SourceAlpha" stdDeviation="10" result="DROP"&gt;&lt;/feGaussianBlur&gt; &lt;feFlood flood-color="#bbb" result="COLOR"&gt;&lt;/feFlood&gt; &lt;feComposite in="COLOR" in2="DROP" operator="in" result="SHADOW"&gt;&lt;/feComposite&gt; &lt;/filter&gt; &lt;image xlink:href="..." x="0" y="0" width="100%" height="100%" filter="url(#drop-shadow)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>  ,   <strong>feGaussianBlur</strong>   <strong>feFlood</strong>       .     : </p><br><p><img src="https://habrastorage.org/webt/_c/c7/an/_cc7an_zj43v7gv4jka--6mpnpi.png" alt="  "><br> <em>_7.   .</em> </p><br><p>  ,        ,       / .          .     ,      ,       ,          . </p><br><p>     SVG   <strong>feOffset</strong> .    <strong>in</strong>  <strong>result</strong>      : <strong>dx</strong>  <strong>dy</strong> ,   ,         X  Y . </p><br><p>   ,       ,  <strong>feMerge</strong> ,  ,           —  <strong>mergeNode</strong>       ,    <strong>mergeNode</strong>    ,  <strong>SourceGraphic</strong>    .     : </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="400" viewBox="0 0 850 650"&gt; &lt;filter id="drop-shadow"&gt; &lt;!-- Get the source alpha and blur it; we'll name the result "DROP" --&gt; &lt;feGaussianBlur in="SourceAlpha" stdDeviation="10" result="DROP"&gt;&lt;/feGaussianBlur&gt; &lt;!-- flood the region with a ligh grey color; we'll name this layer "COLOR" --&gt; &lt;feFlood flood-color="#bbb" result="COLOR"&gt;&lt;/feFlood&gt; &lt;!-- Composite the DROP and COLOR layers together to colorize the shadow. The result is named "SHADOW" --&gt; &lt;feComposite in="COLOR" in2="DROP" operator="in" result="SHADOW"&gt;&lt;/feComposite&gt; &lt;!-- Move the SHADOW layer 20 pixels down and to the right. The new layer is now called "DROPSHADOW" --&gt; &lt;feOffset in="SHADOW" dx="20" dy="20" result="DROPSHADOW"&gt;&lt;/feOffset&gt; &lt;!-- Layer the DROPSHADOW and the Source Image, ensuring the image is positioned on top (remember: MergeNode order matters) --&gt; &lt;feMerge&gt; &lt;feMergeNode in="DROPSHADOW"&gt;&lt;/feMergeNode&gt; &lt;feMergeNode in="SourceGraphic"&gt;&lt;/feMergeNode&gt; &lt;/feMerge&gt; &lt;/filter&gt; &lt;!-- Apply the filter to the source image in the `filter` attribute --&gt; &lt;image xlink:href="..." x="0" y="0" width="100%" height="100%" filter="url(#drop-shadow)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>      : </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/SaraSoueidan/embed/preview/qpoqwQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>         SVG,   SVG.  ,        . </p><br><h2 id="est-drugoy-sposob">   … </h2><br><p>  ,     .  ,         ,    ,      ,    , , . </p><br><p>     ,     ,  <strong>feFlood</strong> ,  ,  , ,      .    ,    .    ,    ,     , ,  - ,  , ,    . </p><br><p>         <strong>feColorMatrix</strong> ,  <strong>feComponentTransfer</strong> .   <strong>feComponentTransfer</strong>       ,    <strong>feColorMatrix</strong> ,     . </p><br><p>  <strong>feColorMatrix</strong>   .         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Una Kravet</a> ,        . </p><br><p>  ,        R(), G(), B()  A()              -.  ,       .     : </p><br><pre> <code class="plaintext hljs">&lt;filter id="myFilter"&gt; &lt;feColorMatrix type="matrix" values="R 0 0 0 0 0 G 0 0 0 0 0 B 0 0 0 0 0 A 0 "/&gt; &lt;/feColorMatrix&gt; &lt;/filter&gt;</code> </pre> <br><p>      ,      . </p><br><p>        ,     ,     RGB,     -   : </p><br><pre> <code class="plaintext hljs">&lt;filter id="filter"&gt; &lt;!-- Get the source alpha and blur it, --&gt; &lt;feGaussianBlur in="SourceAlpha" stdDeviation="10" result="DROP"&gt;&lt;/feGaussianBlur&gt; &lt;!-- offset the drop shadow --&gt; &lt;feOffset in="SHADOW" dx="20" dy="20" result="DROPSHADOW"&gt;&lt;/feOffset&gt; &lt;!-- make the shadow translucent by reducing the alpha channel value to 0.3 --&gt; &lt;feColorMatrix type="matrix" in="DROPSHADOW" result="FINALSHADOW" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0.3 0"&gt; &lt;/feColorMatrix&gt; &lt;!-- Merge the shadow and the source image --&gt; &lt;feMerge&gt; &lt;feMergeNode in="FINALHADOW"&gt;&lt;/feMergeNode&gt; &lt;feMergeNode in="SourceGraphic"&gt;&lt;/feMergeNode&gt; &lt;/feMerge&gt; &lt;/filter&gt;</code> </pre> <br><p>     : </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/SaraSoueidan/embed/preview/opEZee" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>                   .         ,    .         ,         .  ,       ,   ,   ,   ,    .       ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> .   ,     ,  ,         .             . </p><br><p> ,     SVG-      ,            .  Bleib bei uns. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439282/">https://habr.com/ru/post/de439282/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439268/index.html">Wie VR-, AR- und 3D-Druck zusammenarbeiten: VR Concept-Erfahrung</a></li>
<li><a href="../de439270/index.html">Ein Beispiel für das Parsen von C ++ - Code mit libclang in Python</a></li>
<li><a href="../de439272/index.html">Jupyter Notebook auf Netflix</a></li>
<li><a href="../de439278/index.html">ACS meines LCD - Sicherheit an zwei Schrauben</a></li>
<li><a href="../de439280/index.html">Trautonium: die deutsche Welle in der Geschichte der Synthesizer</a></li>
<li><a href="../de439286/index.html">Über statische Analyse in aller Ehrlichkeit</a></li>
<li><a href="../de439288/index.html">SciPy, Optimierung</a></li>
<li><a href="../de439290/index.html">Beschleunigen Sie die Kompilierung in Xcode schnell</a></li>
<li><a href="../de439294/index.html">Überprüfung der Übersetzung „Wenn Software mit öffentlichen Geldern erstellt wird, muss der Code offen sein.“</a></li>
<li><a href="../de439296/index.html">Sowjetisches Nummernschild und Kolmogorov Komplexität</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>