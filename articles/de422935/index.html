<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🚒 👨‍👩‍👧‍👦 🙇🏽 2GIS ist an Ihren Fingerspitzen. Wie wir der Apple Watch eine Karte hinzugefügt haben 👼🏿 👸🏽 🙎🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Apple Watch gewann schnell an Popularität und wurde vor Rolex und anderen Herstellern zur beliebtesten Uhr der Welt. Die Idee, eine Anwendung für ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>2GIS ist an Ihren Fingerspitzen. Wie wir der Apple Watch eine Karte hinzugefügt haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/2gis/blog/422935/"><p><img src="https://habrastorage.org/webt/ut/d9/tb/utd9tb6vvq-zreaxgxkakez4gce.jpeg"></p><br><p>  Die Apple Watch gewann schnell an Popularität und wurde vor Rolex und anderen Herstellern zur beliebtesten Uhr der Welt.  Die Idee, eine Anwendung für Uhren zu erstellen, ist seit 2015 im 2GIS-Büro. </p><br><p>  Vor uns hat nur Apple selbst eine vollwertige Anwendung mit einer Karte auf der Uhr veröffentlicht.  Die Yandex.Map-Anwendung zeigt nur Verkehrs-Widgets und die Reisezeit nach Hause und zur Arbeit an.  Yandex.Navigator, Google Maps, Waze und Maps.Me sind auf der Uhr im Allgemeinen nicht verfügbar. </p><br><p>  Aufgrund der vielen Einschränkungen des Systems und der Komplexität der Entwicklung stellen Unternehmen entweder überhaupt keine Uhrenanwendungen her oder machen sie sehr einfach.  Sie können nicht einfach eine Karte auf die Uhr nehmen und zeichnen.  Aber wir könnten. </p><br><p>  Werfen Sie einen Blick unter die Katze, um herauszufinden, wie aus dem Haustierprojekt ein vollständiges Produkt geworden ist. </p><br><p>  <strong>UPD .:</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/teanet/DemoWatch</a> </p><a name="habracut"></a><br><h3 id="my-reshili-delat-kartu-chto-bylo-na-starte">  Wir beschlossen, eine Karte zu machen.  Was war am Anfang? </h3><br><ol><li>  Entwicklungserfahrung auf der Uhr - 2 Tage Arbeit an einem Testprojekt. </li><li>  Erfahrung mit SpriteKit - 0 Tage. </li><li>  MapKit-Schreiberfahrung - 0 Tage. </li><li>  Zweifel, dass etwas schief gehen könnte - ∞. </li></ol><br><h3 id="iteraciya-1--polet-mysli">  Iteration 1 - Flug des Denkens </h3><br><p>  Wir sind ernsthafte Menschen, deshalb haben wir uns zunächst entschlossen, einen Arbeitsplan zu erstellen.  Wir haben berücksichtigt, dass wir in einem gut geplanten Sprint arbeiten. Wir haben fünf Story-Punkte für „Aufgaben mit kleinen Produkten“ und wissen nicht, wo wir anfangen sollen. </p><br><p>  Eine Karte ist ein sehr großes Bild.  Wir können Bilder auf der Uhr anzeigen, was bedeutet, dass wir die Anzeige der Karte übernehmen können. </p><br><p>  Wir haben einen Service, der eine Karte in Stücke schneiden kann: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cu/or/kl/cuorkl7imghdolhexs7yb2qskr4.png"></div><br><p>  Wenn Sie ein solches Bild ausschneiden und WKImage einfügen, erhalten wir den einfachsten Prototyp für fünf Cent. </p><br><p>  Wenn Sie diesem Bild PanGesture hinzufügen und bei jedem Wischen ein neues Bild installieren, wird die Interaktion mit der Karte simuliert. </p><br><p>  / Freut euch / Es klingt schrecklich, es sieht ungefähr gleich aus, es funktioniert noch schlimmer, aber tatsächlich ist die Aufgabe erledigt. </p><br><h3 id="iteraciya-2--minimalnyy-prototip">  Iteration 2 - minimaler Prototyp </h3><br><p> Kontinuierliche Bilddownloads sind für einen Akku in Stunden teuer.  Ja, und die Startzeit selbst leidet.  Wir wollten etwas vollständigeres und reaktionsfähigeres bekommen.  Aus den Augenwinkeln hörten wir, dass die Uhr SpriteKit unterstützt - das einzige Framework für WatchOS, mit der Möglichkeit, Koordinaten zu verwenden, zu zoomen und all diese Pracht für sich selbst anzupassen. </p><br><p>  Nach ein paar Stunden StackOverflow Driven Development (SDD) erhalten wir die zweite Iteration: <br>  Ein SKSpriteNode, ein WKPanGestureRecognizer. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dr/bi/ub/drbiubucg4xxcr7jbyccmmth71m.gif"></div><br><p>  / Freut euch / Ja, das ist MapKit für 6 Kopeken, voll funktionsfähig.  Dringende Freigabe! </p><br><h3 id="iteraciya-3-dobavlyaem-tayly-i-zum">  Iteration 3 - Hinzufügen von Kacheln und Zoom </h3><br><p>  Wenn die Gefühle schliefen, fragten sie sich, wohin sie als nächstes gehen sollten. </p><br><p>  Verstanden, dass das Wichtigste: </p><br><ul><li>  Ersetzen Sie das Bild durch Kacheln. </li><li>  Befestigen Sie 4 Kacheln am Anwendungspaket und verbinden Sie sie miteinander. </li><li>  Stellen Sie Zoombilder bereit. <br>  Lassen Sie uns 4 Kacheln in das Anwendungspaket legen und sie dann auf eine bestimmte legen: </li></ul><br><pre><code class="hljs objectivec">let rootNode = <span class="hljs-built_in"><span class="hljs-built_in">SKSpriteNode</span></span>()</code> </pre> <br><p>  Mit Hilfe der einfachen Mathematik werden wir sie miteinander verbinden. <br>  Wir zoomen durch WKCrownDelegate: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">crownDidRotate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> crownSequencer: WKCrownSequencer?, rotationalDelta: Double )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.scale += <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>(rotationalDelta * <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.rootNode.setScale(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.scale) }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xf/zg/ws/xfzgwsd4wpsyappc4ehbejs8p2u.gif"></div><br><p>  / Freut euch / Nun, das ist sicher!  Ein paar Korrekturen und an den Meister. </p><br><h3 id="iteraciya-4--optimiziruem-vzaimodeystvie-s-kartoy">  Iteration 4 - Optimierung der Interaktion mit der Karte </h3><br><p>  Am nächsten Tag stellte sich heraus, dass AnchPoint für SpriteKit den Zoom nicht beeinflusst.  Zoom ignoriert anchorPoint vollständig und tritt relativ zur Mitte des rootNode auf.  Es stellt sich heraus, dass wir für jeden Zoomschritt die Position anpassen müssen. </p><br><p>  Es wäre auch schön, Kacheln vom Server zu laden, anstatt die ganze Welt im Speicher der Uhr zu speichern. <br>  Vergessen Sie nicht, dass die Kacheln an die Koordinaten gebunden werden sollten, damit sie nicht im Zentrum von SKScene liegen, sondern an den entsprechenden Stellen auf der Karte. </p><br><p>  Fliesen sehen ungefähr so ​​aus: </p><br><p><img src="https://habrastorage.org/webt/zo/-s/7d/zo-s7dhq--jmie8vigvbdqyp0g0.jpeg"></p><br><p>  Jede zoomLevel (im Folgenden „z“) verfügt über einen eigenen Satz von Kacheln.  Für z = 1 haben wir 4 Kacheln, aus denen die ganze Welt besteht. </p><br><p><img src="https://habrastorage.org/webt/oe/jl/6b/oejl6beiczhxnf09cj1oqyxr1-4.png"></p><br><p>  für z = 2 - um die ganze Welt abzudecken, brauchst du bereits 16 Kacheln, <br>  für z = 3 - 64 Fliesen. <br>  für z = 18 ≈ 68 * 10 ^ 9 Kacheln. <br>  Jetzt müssen sie in die Welt von SpriteKit aufgenommen werden. </p><br><p>  Die Größe einer Kachel beträgt 256 * 256 pt, was bedeutet <br>  für z = 1 beträgt die Größe der "Welt" 512 * 512 pt, <br>  für z = 2 ist die Größe der "Welt" gleich 1024 * 1024 pt. <br>  Legen Sie zur Vereinfachung der Berechnung die Kacheln wie folgt in die Welt: </p><br><p><img src="https://habrastorage.org/webt/l_/_u/vp/l__uvp1_sli-cirdspcwi_y6zlm.png"></p><br><p>  Codieren Sie die Kachel: </p><br><pre> <code class="hljs julia"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> kTileLength: CGFloat = <span class="hljs-number"><span class="hljs-number">256</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> TilePath { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> z: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> }</code> </pre> <br><p>  Definieren Sie die Koordinate der Kachel in einer solchen Welt: </p><br><pre> <code class="hljs objectivec">var position: <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span> { let x = <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x) let y = <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y) let offset: <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span> = pow(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.z - <span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span>(x: kTileLength * ( -offset + x ), y: kTileLength * ( offset - y - <span class="hljs-number"><span class="hljs-number">1</span></span> )) } var center: <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.position + <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span>(x: kTileLength, y: kTileLength) * <span class="hljs-number"><span class="hljs-number">0.5</span></span> }</code> </pre> <br><p>  Die Lage ist günstig, da Sie damit alles in die Koordinaten der realen Welt bringen können: Breite / Länge = 0, die sich genau im Zentrum der "Welt" befindet. </p><br><p>  Der Breiten- / Längengrad der realen Welt wird wie folgt in unsere Welt umgewandelt: </p><br><pre> <code class="hljs coffeescript">extension CLLocationCoordinate2D { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ( <span class="hljs-number"><span class="hljs-number">-1</span></span> &lt; TileLocation &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> ) func tileLocation() -&gt; CGPoint { var siny = sin(self.latitude * .pi / <span class="hljs-number"><span class="hljs-number">180</span></span>) siny = min(max(siny, <span class="hljs-number"><span class="hljs-number">-1</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>) let y = CGFloat(log( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params"> + siny )</span></span></span><span class="hljs-function"> / </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params"> - siny )</span></span></span><span class="hljs-function">)) return CGPoint</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( x: kTileLength * ( </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.5</span></span></span></span><span class="hljs-function"><span class="hljs-params"> + CGFloat(self.longitude) / </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">360</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ), y: kTileLength * ( </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.5</span></span></span></span><span class="hljs-function"><span class="hljs-params"> - y / ( </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * .pi ) ) )</span></span></span><span class="hljs-function"> } //       zoomLevel func location</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z: Int)</span></span></span><span class="hljs-function"> -&gt;</span></span> CGPoint { let tile = self.tileLocation() let zoom: CGFloat = pow(<span class="hljs-number"><span class="hljs-number">2</span></span>, CGFloat(z)) let offset = kTileLength * <span class="hljs-number"><span class="hljs-number">0.5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CGPoint( x: (tile.x - offset ) * zoom, y: (-tile.y + offset) * zoom ) } }</code> </pre> <br><p>  Mit Zoom-Leveling geharkt Probleme.  Ich musste ein paar Tage frei verbringen, um den gesamten mathematischen Apparat zusammenzustellen und die perfekte Verschmelzung der Kacheln sicherzustellen.  Das heißt, die Kachel für z = 1 sollte idealerweise in vier Kacheln für z = 2 und umgekehrt, die vier Kacheln für z = 2 sollten in eine Kachel für z = 1 gehen. </p><br><p><img src="https://habrastorage.org/webt/j_/62/0r/j_620racsivq_qnnj5euvweexlo.jpeg"></p><br><p>  Außerdem musste der lineare Zoom in einen exponentiellen umgewandelt werden, da die Zooms von 1 &lt;= z &lt;= 18 variieren und die Karte wie 2 ^ z skaliert. </p><br><p>  Ein sanfter Zoom wird durch ständiges Anpassen der Position der Kacheln erreicht.  Es ist wichtig, dass die Kacheln genau in der Mitte gestickt sind: Das heißt, dass die Kachel der Ebene 1 in 4 Kacheln der Ebene 2 mit einem Zoom von 1,5 eingeteilt wird. </p><br><p>  SpriteKit verwendet einen Schwimmer unter der Haube.  Für z = 18 erhalten wir eine Koordinatenverteilung (-33 554 432/33 554 432), und die Genauigkeit von float beträgt 7 Bit.  Am Ausgang haben wir einen Fehler im Bereich von 30 pt.  Um das Auftreten von "Lücken" zwischen den Hälften zu vermeiden, platzieren wir die sichtbare Kachel so nahe wie möglich an der Mitte von SKScene. </p><br><p>  / Freut euch / Nach all diesen Gesten haben wir einen Prototyp zum Testen vorbereitet. </p><br><h3 id="reliz">  Erscheinungsdatum </h3><br><p>  Da die Anwendung nicht wirklich TK hatte, fanden wir ein paar Freiwillige, die ein wenig testen konnten.  Sie fanden keine besonderen Probleme und beschlossen, zur Seite zu rollen. </p><br><p>  Nach der Veröffentlichung stellte sich heraus, dass der Prozessor auf der Uhr der ersten Serie keine Zeit hat, den ersten Frame der Karte in 10 Sekunden zu zeichnen, und fällt durch Timeout ab.  Ich musste zunächst eine Karte erstellen, die in 10 Sekunden vollständig leer war, und dann das Substrat nach und nach laden.  Entwickeln Sie zuerst alle Ebenen der Karte - und laden Sie dann Kacheln für sie. </p><br><p>  Das Debuggen des Netzwerks, das ordnungsgemäße Konfigurieren des Caches und ein kleiner Speicherbedarf haben viel Zeit in Anspruch genommen, damit WatchOS nicht versucht, unsere Anwendung so lange wie möglich zu beenden. </p><br><p>  Nachdem wir die Anwendung profiliert hatten, stellten wir fest, dass Sie anstelle der üblichen Kacheln Retina-Kacheln verwenden können, ohne die Ladezeit und den Speicherverbrauch zu beeinträchtigen. In der neuen Version wurden sie bereits auf diese Kacheln umgestellt. </p><br><h3 id="itogi-i-plany-na-buduschee">  Ergebnisse und Pläne für die Zukunft </h3><br><p>  Auf der Karte können wir bereits eine Route mit Manövern anzeigen, die in der Hauptanwendung integriert sind.  Die Funktion wird in einer der kommenden Versionen verfügbar sein. </p><br><p>  Das Projekt, das zunächst unmöglich schien, erwies sich für mich persönlich als äußerst nützlich.  Ich benutze die Anwendung oft, um zu verstehen, ob es Zeit ist, an der richtigen Haltestelle auszusteigen.  Ich glaube, dass es im Winter noch nützlicher sein wird. </p><br><p>  Gleichzeitig war er erneut davon überzeugt, dass die Komplexität des Projekts, das Vertrauen anderer in den Erfolg der Aufgabe oder die Verfügbarkeit von Freizeit bei der Arbeit nicht so wichtig sind.  Die Hauptsache ist der Wunsch, ein Projekt zu machen und eine langweilige, schrittweise Bewegung in Richtung des Ziels.  Als Ergebnis haben wir ein vollwertiges MapKit, das nahezu unbegrenzt ist und mit 3 WatchOS funktioniert.  Es kann nach Ihren Wünschen geändert werden, ohne darauf zu warten, dass Apple die entsprechende API für die Entwicklung bereitstellt. </p><br><p>  <strong>PS</strong> Für Interessierte kann ich ein fertiges Projekt auslegen.  Die Code-Ebene dort ist weit von der Produktion entfernt.  Aber nach dem militärischen Prinzip spielt es keine Rolle, wie es funktioniert, die Hauptsache ist, dass es funktioniert! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422935/">https://habr.com/ru/post/de422935/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422921/index.html">Von Kotlin zu Goblin: Wie TechTrain lief</a></li>
<li><a href="../de422923/index.html">So markieren Sie den Tag des Programmierers, ohne den Office-Ficus mit Nullen und Einsen zu dekorieren</a></li>
<li><a href="../de422925/index.html">Interview mit dem Sprecher der RubyRussia-Konferenz, Godfrey Chan</a></li>
<li><a href="../de422929/index.html">Yandex Mail [war] um 12:16 Uhr Moskauer Zeit etwa eine Stunde lang nicht verfügbar</a></li>
<li><a href="../de422931/index.html">Wir betrachten die Tools zur Überwachung verteilter Anwendungen</a></li>
<li><a href="../de422937/index.html">Festplatten-Caching von Lazy Computing-Bäumen</a></li>
<li><a href="../de422939/index.html">Das Buch "Kali Linux von Entwicklern"</a></li>
<li><a href="../de422941/index.html">"Drei in einem Boot, Armut und Hunde" oder wie Antiplagiat Paraphrase sucht</a></li>
<li><a href="../de422943/index.html">Ein bisschen über den industriellen Bergbau</a></li>
<li><a href="../de422945/index.html">27. September, Moskau - Mitap QIWI SERVER PARTY 3.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>