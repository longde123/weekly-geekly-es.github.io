<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∑Ô∏è üîÉ üöç Execute testes de unidade localmente no STM32CubeIDE no Windows üßïüèª üññüèº üñêüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 


 Todo mundo conhece os benef√≠cios do teste de unidade. Antes de tudo, escrever testes ao mesmo tempo que o c√≥digo permite detectar er...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Execute testes de unidade localmente no STM32CubeIDE no Windows</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469367/"><h3 id="vvedenie">  1. Introdu√ß√£o </h3><br><p><img src="https://habrastorage.org/webt/8f/3q/2r/8f3q2rt_-eycgp3_ejr_hfwqnva.png" align="left" width="200">  Todo mundo conhece os benef√≠cios do teste de unidade.  Antes de tudo, escrever testes ao mesmo tempo que o c√≥digo permite detectar erros mais cedo e n√£o perder tempo posteriormente em trabalhosa depura√ß√£o complexa.  No caso de desenvolvimento incorporado, o teste de unidade possui recursos relacionados, primeiramente, ao fato de o c√≥digo ser executado em algum lugar profundo nas entranhas do dispositivo e √© muito dif√≠cil interagir com ele; em segundo lugar, o c√≥digo est√° fortemente ligado ao hardware de destino . </p><br><p>  Se existem fragmentos no projeto que n√£o dependem do hardware e, ao mesmo tempo, implementam uma l√≥gica bastante complexa, para eles o uso de testes de unidade trar√° o maior benef√≠cio.  Por exemplo, pode ser a implementa√ß√£o de um protocolo de transfer√™ncia de dados, v√°rios c√°lculos ou uma m√°quina de estado de controle. </p><br><p>  Existem tr√™s maneiras de executar testes de unidade para plataformas incorporadas: </p><a name="habracut"></a><br><ol><li>  Inicie diretamente na plataforma de destino.  Nesse caso, voc√™ pode trabalhar com o equipamento do dispositivo e o c√≥digo funcionar√° exatamente da mesma forma que nas condi√ß√µes de combate.  No entanto, para testar, voc√™ precisar√° de acesso f√≠sico ao dispositivo.  Al√©m disso, o ciclo de testes ser√° bastante longo devido √† necessidade de baixar constantemente o c√≥digo para o dispositivo. </li><li>  Rodando em um emulador.  Esse m√©todo √© bom principalmente porque permite trabalhar mesmo quando a plataforma de destino n√£o est√° dispon√≠vel (por exemplo, porque ainda n√£o foi conclu√≠da).  As desvantagens s√£o a precis√£o limitada na reprodu√ß√£o do comportamento do ferro (e o mundo circundante), bem como a dificuldade de criar esse emulador. </li><li>  Executando na m√°quina host (localmente).  Ele n√£o funcionar√° com o equipamento (voc√™ pode usar stubs de teste), mas os testes ser√£o iniciados e funcionar√£o rapidamente e voc√™ n√£o precisar√° de acesso ao dispositivo de destino.  Um bom exemplo para usar esse m√©todo √© testar a implementa√ß√£o de um algoritmo computacional no microcontrolador, que por si s√≥ n√£o depende do hardware, mas usa os dados do sensor do dispositivo.  Testar um algoritmo com uma fonte de dados real ser√° muito inconveniente, √© muito melhor registrar essas medi√ß√µes uma vez e executar testes j√° nos dados armazenados.  Este script executar√° testes localmente e ser√° discutido posteriormente. </li></ol><br><p>  Esta publica√ß√£o fornece uma maneira de configurar testes de unidade no ambiente STM32CubeIDE, baseado no Eclipse e destinado ao desenvolvimento de controladores da fam√≠lia STM32.  A linguagem de desenvolvimento √© C, mas os testes em si s√£o escritos em C ++.  Os testes ser√£o executados em uma m√°quina host Windows usando Cygwin.  Como estrutura de teste, o Google Test √© usado.  Os resultados ser√£o exibidos em uma janela de plug-in especial para teste de unidade e podem ser iniciados com um bot√£o do projeto para STM32: </p><br><p><img src="https://habrastorage.org/webt/mo/_j/gw/mo_jgwdlc6e3qqzjkcbsxrslvaq.png"></p><br><p>  O m√©todo descrito √© adequado para outros ambientes de desenvolvimento baseados no Eclipse, a menos que os bons fabricantes os tenham cortado demais por conveni√™ncia dos desenvolvedores.  Este m√©todo tamb√©m funcionar√° com o CubeIDE no Linux, sem a necessidade de se preocupar com o Cygwin. </p><br><h3 id="vam-ponadobyatsya">  Voc√™ vai precisar </h3><br><ol><li>  Cygwin 3.0.7 x86 (como os testes s√£o para um microcontrolador de 32 bits, tamb√©m usaremos um ambiente de 32 bits em uma plataforma de 64 bits) </li><li>  STM32CubeIDE 1.0.2 para Windows. </li><li>  Estrutura de teste do Google 1.8.1 </li></ol><br><h3 id="ustanovka-cygwin-i-stm32cubeide">  Instale o Cygwin e o STM32CubeIDE </h3><br><h4 id="cygwin">  Cygwin </h4><br><p>  Instale o Cygwin, vers√£o x86.  No instalador, selecione pacotes adicionais: gcc-core, g ++, binutils, automake, autoconf, cmake, libtool, gdb, make.  Voc√™ pode instalar as √∫ltimas vers√µes est√°veis ‚Äã‚Äãdos pacotes. </p><br><p><img src="https://habrastorage.org/webt/xc/fj/6v/xcfj6v0wun10fgdbskuccodkqqk.png"></p><br><p>  Voc√™ tamb√©m precisa registrar vari√°veis ‚Äã‚Äãde ambiente: </p><br><p>  <strong>CAMINHO:</strong> ...; C: \ &lt;caminho_do_Cygwin&gt; \ Cygwin \ bin;  C: \ &lt;caminho_do_Cygwin&gt; \ Cygwin \ lib <br>  <strong>caminho de classe:</strong> C: \ &lt;path_to_Cygwin&gt; \ Cygwin \ lib </p><br><h4 id="stm32cubeide">  STM32CubeIDE </h4><br><p>  O ambiente √© instalado como de costume.  √â aconselh√°vel instalar o CubeIDE ap√≥s o Cygwin, pois nesse caso o Cube pegar√° a cadeia de ferramentas Cygwin existente. </p><br><p>  Primeiro, crie um projeto C ++ para a plataforma Cy86 x86.  Precisamos disso para, em primeiro lugar, verificar a funcionalidade do conjunto de ferramentas e, em segundo lugar, us√°-lo como um "doador" da configura√ß√£o da montagem para o projeto principal. </p><br><p>  Escolha Arquivo&gt; Novo&gt; Projeto C / C ++.  Selecione C ++ Managed Build.  Criamos um projeto do tipo hello world para a cadeia de ferramentas Cygwin GCC: </p><br><p><img src="https://habrastorage.org/webt/jc/ny/1n/jcny1ntttq4rzapxeth3-s2emim.png"></p><br><p>  Em seguida, voc√™ precisar√° escolher quais configura√ß√µes de montagem criar.  Apenas Debug √© suficiente. <br>  Agora voc√™ pode verificar se o projeto est√° em andamento, escolhendo Projeto&gt; Construir Tudo.  Tamb√©m √© aconselh√°vel verificar a depura√ß√£o no Cygwin executando Executar&gt; Depurar como&gt; Aplicativo C / C ++ local.  O aplicativo emitir√° "Hello world" para o console dentro do CubeIDE. </p><br><p>  Para que o depurador mostre linhas execut√°veis ‚Äã‚Äãnos arquivos de c√≥digo-fonte, voc√™ precisa configurar a exibi√ß√£o dos caminhos.  Na janela Janela&gt; Prefer√™ncias, na guia C / C ++&gt; Depura√ß√£o, selecione Caminho de pesquisa de origem e adicione uma nova exibi√ß√£o: Adicionar&gt; Mapeamento de caminho.  Na janela, voc√™ precisa nomear algo como uma nova exibi√ß√£o e adicionar linhas aos discos que est√£o no sistema: </p><br><ul><li>  \ cygdrive \ c - C: \ </li><li>  \ cygdrive \ g - G: \ </li></ul><br><p><img src="https://habrastorage.org/webt/fe/ro/2h/fero2hpb7i_n1cjf4sie1nfdndm.png"></p><br><p><img src="https://habrastorage.org/webt/cc/y3/4e/ccy34eo_dtfubifpmfnmkgzkjgu.png"></p><br><p>  Para uma bela execu√ß√£o de teste, tamb√©m precisamos de um plug-in para Eclipse com suporte para testes de unidade para C ++.  Ele √© instalado diretamente no STM32CubeIDE: menu Ajuda&gt; Instalar Novo Software, selecione o Reposit√≥rio Eclipse e instale o plug-in C / C ++ Unit Testing Support. </p><br><p><img src="https://habrastorage.org/webt/67/eh/ns/67ehnsuupvabu-i1vvkp6dfz4yc.png"></p><br><h3 id="sborka-biblioteki-google-test">  Crie a biblioteca de testes do Google </h3><br><p>  O c√≥digo-fonte da biblioteca pode ser obtido em: <a href="">https://github.com/google/googletest/tree/release-1.8.1</a> <br>  Descompacte as fontes, acesse o diret√≥rio googletest-release-1.8.1 usando o terminal Cygwin e execute: </p><br><pre><code class="bash hljs">cmake . make</code> </pre> <br><p>  Ap√≥s a montagem bem-sucedida, o arquivo est√°tico da biblioteca estar√° em ./googlemock/lib/libgtest.a, e os arquivos de cabe√ßalho estar√£o no diret√≥rio ./googletest/include/gtest/.  Eles precisar√£o ser copiados para o nosso projeto (ou escrever o caminho para esses arquivos nas configura√ß√µes do projeto). </p><br><h3 id="sozdanie-proekta-dlya-stm32">  Criando um projeto para STM32 </h3><br><p>  Projeto para a placa de depura√ß√£o STM32L476G-DISCO.  O exemplo n√£o ser√° muito sofisticado - h√° dois LEDs na placa, deixe-os mostrar um contador bin√°rio de 00 a 11. Implementaremos um m√≥dulo separado para o contador, descrito em um par de arquivos .he .c, e escreveremos um teste para ele. <br>  O projeto pode ser criado como de costume, usando o configurador Cube, o principal √© garantir que os pinos PB2 e PE8 estejam configurados como sa√≠das digitais.  Ao criar um projeto, seria melhor especificar o tipo - C ++, isso ser√° necess√°rio para compilar os testes (o c√≥digo principal ainda ser√° compilado pelo compilador C).  A convers√£o de um projeto de C ser√° poss√≠vel posteriormente, clicando no nome do projeto RMB e selecionando "Converter em C ++". </p><br><p>  Para compila√ß√£o no MK e para testes, precisamos de duas configura√ß√µes de montagem diferentes.  Nessas configura√ß√µes, diferentes conjuntos de arquivos ser√£o coletados - os principais receber√£o os m√≥dulos para trabalhar com o hardware e os m√≥dulos testados, e o teste obter√° os mesmos m√≥dulos e arquivos de teste testados.  Portanto, criaremos diret√≥rios diferentes na raiz do projeto - Aplicativo com o c√≥digo do aplicativo para MK (voc√™ pode simplesmente renomear o diret√≥rio Src que o Cube criou), Comum para m√≥dulos que n√£o dependem do ferro (que iremos testar) e Testes para testes.  Os diret√≥rios podem ser exclu√≠dos da montagem clicando em RMB em seu nome, menu Configura√ß√£o de Recursos&gt; Excluir da Constru√ß√£o. </p><br><p>  Adicione nosso m√≥dulo de contador ao diret√≥rio comum: </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo Led_counter</b> <div class="spoiler_text"><p>  (led_counter.h): </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> LED_COUNTER_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LED_COUNTER_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; void Led_Counter_Init(); uint8_t Led_Counter_Get_Next(); #endif /* LED_COUNTER_H_ */</span></span></span></span></code> </pre> <br><p>  led_counter.cpp: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"led_counter.h"</span></span></span><span class="hljs-meta"> static uint8_t led_cnt_state = 0; void Led_Counter_Init() { led_cnt_state = 0; } uint8_t Led_Counter_Get_Next() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(++led_cnt_state &gt; 3) led_cnt_state = 0; return led_cnt_state; }</span></span></code> </pre> </div></div><br><p>  Os diret√≥rios Common e Tests devem ser adicionados ao caminho de pesquisa para incluir arquivos: propriedades do projeto (Propriedades)&gt; C / C ++ Geral&gt; Caminhos e S√≠mbolos&gt; Inclui. </p><br><p>  Adicione ao trabalho com os principais LEDs </p><br><div class="spoiler">  <b class="spoiler_title">Fragmento main.c</b> <div class="spoiler_text"><p>  main.c: </p><br><pre> <code class="cpp hljs">‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN Includes */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"led_counter.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END Includes */</span></span></span><span class="hljs-meta"> ‚Ä¶ int main(void) { ‚Ä¶ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN WHILE */</span></span></span><span class="hljs-meta"> Led_Counter_Init(); uint8_t led_state = 0; while (1) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END WHILE */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN 3 */</span></span></span><span class="hljs-meta"> led_state = Led_Counter_Get_Next(); HAL_GPIO_WritePin(GPIOB, GPIO_PIN_2, led_state &amp; (1&lt;&lt;0)); HAL_GPIO_WritePin(GPIOE, GPIO_PIN_8, led_state &amp; (1&lt;&lt;1)); HAL_Delay(500); } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 3 */</span></span></span><span class="hljs-meta"> ‚Ä¶ }</span></span></code> </pre> </div></div><br><p>  O projeto deve compilar e executar, e os LEDs devem piscar. </p><br><h3 id="napisanie-testov">  Testes de escrita </h3><br><p>  Agora aquilo para o qual tudo foi iniciado. </p><br><p>  Crie uma nova configura√ß√£o de constru√ß√£o atrav√©s das propriedades do projeto - Propriedades&gt; Constru√ß√£o do C / C ++&gt; Configura√ß√µes&gt; Gerenciar configura√ß√µes.  O CubeIDE n√£o permitir√° que voc√™ crie uma configura√ß√£o para compilar no Cygwin; portanto, copie-a do projeto que criamos anteriormente: </p><br><p><img src="https://habrastorage.org/webt/4d/ro/kd/4drokdgkom2o6z18duo1v_tbmwi.png"></p><br><p>  Agora voc√™ precisa mudar para essa configura√ß√£o e configurar os caminhos para os arquivos de origem e de cabe√ßalho.  Nas propriedades do projeto na guia Caminhos e s√≠mbolos que prescrevemos (ao adicionar uma entrada, √© melhor colocar um daw no campo "adicionar a todos os idiomas"): </p><br><ul><li>  Inclui - testes / Inc, comum / Inc </li><li>  Bibliotecas - gtest </li><li>  Caminhos da Biblioteca - Testes / Lib </li><li>  Local de Origem - / &lt;nome_prj&gt; / Comum e / &lt;nome_prj&gt;&gt; / Tests (substitua &lt;nome_prj&gt; pelo nome do projeto) </li></ul><br><p>  Em seguida, copie a biblioteca gtest - o arquivo .a para o diret√≥rio Tests / Lib no projeto e os arquivos de cabe√ßalho na pasta gtest - para a pasta Tests / Inc.  Na pasta Testes, crie um novo arquivo main.cpp no ‚Äã‚Äãqual os testes ser√£o executados.  Seu conte√∫do √© padr√£o: </p><br><p>  main.cpp: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Unit tests main file */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"gtest/gtest.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { ::testing::InitGoogleTest(&amp;argc, argv); return RUN_ALL_TESTS(); }</span></span></code> </pre> <br><p>  Al√©m disso, para testar a configura√ß√£o, criaremos um teste que verificar√° se o tamanho do ponteiro √© de 32 bits em nosso ambiente (queremos garantir que seja o mesmo que no microcontrolador, para isso definimos o Cygwin de 32 bits). </p><br><p>  Crie o seguinte arquivo de teste test_platform.cpp: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"gtest/gtest.h"</span></span></span><span class="hljs-meta"> TEST(PlatformTest, TestPointerSize) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//Check pointer size is 32 bit ASSERT_EQ(sizeof(void*)*8, 32U); }</span></span></span></span></code> </pre> <br><p>  Agora, se o projeto for executado como o aplicativo C ++ usual, a sa√≠da de depura√ß√£o conter√° uma mensagem do Google Test informando que todos os testes foram aprovados. </p><br><p>  A estrutura do projeto deve se parecer com isso: <br><img src="https://habrastorage.org/webt/ev/ld/g2/evldg2fj_pqta199knozgvzicu8.png"></p><br><p>  Agora vamos escrever testes para o nosso m√≥dulo de contador de LED.  Os arquivos de teste podem estar localizados na pasta Testes: </p><br><div class="spoiler">  <b class="spoiler_title">test_led_counter.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"gtest/gtest.h"</span></span></span><span class="hljs-meta"> extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"led_counter.h"</span></span></span><span class="hljs-meta"> } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Test fixture class LedCounterTest: public ::testing::Test { protected: void SetUp() { Led_Counter_Init(); } }; // Check initial value TEST_F(LedCounterTest, TestInitialValue) { Led_Counter_Init(); ASSERT_EQ(Led_Counter_Get_Next(), 1); } // Check how value is incremented TEST_F(LedCounterTest, TestIncrementValue) { Led_Counter_Init(); unsigned int val = Led_Counter_Get_Next(); for(int i=0;i&lt;1;i++) { ASSERT_EQ(Led_Counter_Get_Next(), ++val); } } // Check how value return to 0 after 3 TEST_F(LedCounterTest, TestZeroCrossing) { Led_Counter_Init(); for(int i=0;i&lt;3;i++) { Led_Counter_Get_Next(); } ASSERT_EQ(Led_Counter_Get_Next(), 0); }</span></span></span></span></code> </pre> </div></div><br><p>  Para que os resultados do teste sejam exibidos em uma janela bonita, voc√™ precisa criar uma nova configura√ß√£o de inicializa√ß√£o no menu Executar&gt; Configura√ß√µes de Depura√ß√£o.  O plug-in instalado permite criar configura√ß√µes do tipo C / C ++ Unit.  Crie-o, chame Executar testes, selecione a configura√ß√£o de montagem "Testar" usada e desmarque a caixa de sele√ß√£o "parar na inicializa√ß√£o em" na guia Depurador.  Depois disso, a configura√ß√£o pode ser iniciada. </p><br><p>  Para que uma janela com os resultados apare√ßa, selecione-a em Janela&gt; Mostrar Visualiza√ß√£o&gt; Outra&gt; C / C ++&gt; Unidade C / C ++. </p><br><p><img src="https://habrastorage.org/webt/ip/qd/cr/ipqdcrsjl0iohvf1yq4_99xwieq.png"></p><br><p>  Feito!  Agora o projeto pode ser compilado e executado sob o alvo MK, como de costume.  Quando voc√™ precisar executar testes locais, quando executar a configura√ß√£o Executar Testes, o projeto ser√° reconstru√≠do automaticamente para x86, o ambiente executar√° os testes e mostrar√° o resultado. </p><br><h3 id="literatura">  Literatura </h3><br><ol><li>  J. Grenning.  Desenvolvimento Orientado a Testes para Embedded C. - trabalho fundamental em testes unit√°rios de sistemas embarcados e na aplica√ß√£o da metodologia TDD. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://uncannier.com/unit-testing-of-embedded-firmware-part-1-software-confucius/</a> - C√≥digo do microcontrolador x86 de teste de unidade no Texas Instruments Code Composer Studio, estrutura CppUTest </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://blog.atollic.com/why-running-your-embedded-arm-cortex-code-on-a-host-pc-is-a-good-thing</a> - um artigo sobre por que pode ser √∫til executar c√≥digo para um microcontrolador em uma plataforma de desktop </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt469367/">https://habr.com/ru/post/pt469367/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt469351/index.html">Intel Comet Lake-U e Comet Lake-Y: at√© 6 n√∫cleos para laptops finos e leves</a></li>
<li><a href="../pt469353/index.html">O resumo de materiais interessantes para o desenvolvedor m√≥vel # 317 (23 a 29 de setembro)</a></li>
<li><a href="../pt469355/index.html">Um tutorial chato de NumPy</a></li>
<li><a href="../pt469357/index.html">Corra, Gopher, corra! - sobre o que falaremos na GolangConf</a></li>
<li><a href="../pt469361/index.html">Dor e l√°grimas em Svelte 3</a></li>
<li><a href="../pt469369/index.html">Eventos digitais em Moscou, de 30 de setembro a 06 de outubro</a></li>
<li><a href="../pt469371/index.html">Descri√ß√£o da abordagem para organizar e testar c√≥digo usando o Redux Thunk</a></li>
<li><a href="../pt469373/index.html">Os resultados do projeto para criar uma interface neural para pacientes completamente paralisados ‚Äã‚Äãquestionaram</a></li>
<li><a href="../pt469375/index.html">Por que Mozilla, Coil e Creative Commons destinam US $ 100 milh√µes para projetos de c√≥digo aberto?</a></li>
<li><a href="../pt469379/index.html">Aplica√ß√£o de m√©todos formais de valida√ß√£o de modelo para UI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>