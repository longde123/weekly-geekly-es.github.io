<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêì üöó ü•á Tornamos o processo de desenvolvimento de software pesado para microcontroladores mais conveniente (n√£o) ü•ö üöí üïò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Agora ningu√©m pode se surpreender com os microcontroladores com mem√≥ria n√£o vol√°til (na maioria das vezes em Flash) de 512 kilobytes ou mais. Seu cust...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tornamos o processo de desenvolvimento de software pesado para microcontroladores mais conveniente (n√£o)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437848/"> Agora ningu√©m pode se surpreender com os microcontroladores com mem√≥ria n√£o vol√°til (na maioria das vezes em Flash) de 512 kilobytes ou mais.  Seu custo est√° diminuindo gradualmente e a acessibilidade, pelo contr√°rio, est√° aumentando.  A presen√ßa desse volume de mem√≥ria n√£o vol√°til torna poss√≠vel escrever aplicativos "pesados" em termos de mem√≥ria ocupada, facilitando a manuten√ß√£o subsequente do c√≥digo por meio do uso de solu√ß√µes prontas de v√°rias bibliotecas padr√£o.  No entanto, isso leva a um aumento no volume do arquivo de firmware do dispositivo de destino, que √© necess√°rio cada vez que √© completamente recarregado na mem√≥ria n√£o vol√°til do microcontrolador com a menor altera√ß√£o no c√≥digo. <br><br>  O objetivo do artigo √© falar sobre o m√©todo de constru√ß√£o de um projeto em C e / ou C ++, no qual, no caso de alterar a se√ß√£o de c√≥digo, que √© depurada com mais frequ√™ncia, a maioria do projeto n√£o precisa ser reescrita.  E tamb√©m mostre por que esse m√©todo nem sempre √© uma solu√ß√£o eficaz. <br><a name="habracut"></a><br><h2>  Requisitos do leitor </h2><br>  No curso da narrativa, assumirei que o leitor: <br><br><ul><li>  Ele √© fluente em C e C ++; </li><li>  possui experi√™ncia no trabalho com microcontroladores baseados em n√∫cleos Cortex-M3 / Cortex-M4 (por exemplo, a s√©rie stm32f4); </li><li>  sabe como construir o arquivo de costura final (elf / bin) a partir das fontes do projeto; </li><li>  Imagina para que servem os arquivos de script do vinculador; </li><li>  tem uma id√©ia do texto, bss, dados e outras se√ß√µes; </li><li>  trabalhou com qualquer uma das distribui√ß√µes linux; </li><li>  possui minimamente bash; </li><li>  possui experi√™ncia com o gcc na arquitetura dos processadores Cortex-M3 / Cortex-M4 (toolchain arm-none-eabi); </li><li>  tem habilidades iniciais com cmake. </li></ul><br><h2>  A ess√™ncia do m√©todo </h2><br>  Em um projeto "cl√°ssico" para microcontroladores, todos os dados imut√°veis ‚Äã‚Äã(texto, se√ß√µes rodata, valores de dados iniciais e outros) geralmente est√£o localizados "em uma linha", come√ßando no endere√ßo inicial da mem√≥ria n√£o vol√°til (no caso de um microcontrolador baseado no n√∫cleo Cortex-M3 / Cortex-M4 - c Endere√ßo 0x08000000).  De uma forma simplificada, o mapa de uso de mem√≥ria n√£o vol√°til de um programa de microcontrolador baseado no n√∫cleo Cortex-M3 / Cortex-M4, escrito em C ++, se parece com o seguinte: <br><br><img src="https://habrastorage.org/webt/hl/dw/jx/hldwjx8d-f6k7ogodnjthokeefc.png"><br><br>  O arquivo mem.ld para esse projeto geralmente se parece com isso: <br><br><pre><code class="bash hljs">MEMORY { FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 768K RAM (xrw) : ORIGIN = 0x20000000, LENGTH = 112K }</code> </pre> <br>  Aqui, toda a mem√≥ria n√£o vol√°til √© uma √∫nica parti√ß√£o denominada ‚ÄúFLASH‚Äù e toda a RAM √© uma parti√ß√£o denominada ‚ÄúRAM‚Äù.  Dessa forma, quando uma das se√ß√µes de c√≥digo √© alterada, todo o resto come√ßa a "mudar".  Para evitar isso, voc√™ pode "dividir" o arquivo de firmware em alguns blocos l√≥gicos.  Por exemplo, da seguinte maneira: <br><br><ul><li>  tabela de vetores de interrup√ß√£o; </li><li>  bibliotecas pr√≥prias; </li><li>  bibliotecas de terceiros (que n√£o devem ser alteradas); </li><li>  c√≥digo frequentemente modific√°vel. </li></ul><br>  Nesse caso, ao alterar uma se√ß√£o do c√≥digo, no arquivo bin final, apenas a se√ß√£o na qual o c√≥digo foi alterado e a se√ß√£o que estava de alguma forma conectada a ele ser√£o alteradas (por exemplo, a tabela de vetores de interrup√ß√£o, se a posi√ß√£o do manipulador em alguma das se√ß√µes). <br><br>  Basicamente, <b>bibliotecas est√°ticas</b> s√£o adicionadas ao projeto. <br><br>  Depois de receber a bandeja do arquivo do projeto, ele pode ser dividido em se√ß√µes e piscar cada se√ß√£o independentemente.  Assim, somente as √°reas alteradas ser√£o costuradas.  Isso tamb√©m leva √† falta de necessidade de firmware antes da depura√ß√£o, pois √© assumido que o microcontrolador ter√° imediatamente o firmware mais recente no microcontrolador e voc√™ poder√° iniciar a depura√ß√£o imediatamente. <br><br>  A seguir, descreverei em detalhes como implementar isso em um projeto real.  Os pr√≥s e contras de tal decis√£o ser√£o dados no final do artigo. <br><br><h2>  Campo para experimento </h2><br>  Antes de sugerir qualquer tipo de inova√ß√£o no trabalho, tento isso no meu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">projeto de casa</a> .  Como seu tamanho √© pr√≥ximo ao tamanho dos projetos de rotina em funcionamento, √© poss√≠vel entender se a inova√ß√£o √© vi√°vel ou n√£o e quais as nuances que ela carrega. <br><br><h2>  Descri√ß√£o do Projeto </h2><br>  O projeto cont√©m: <br><br><ul><li>  o c√≥digo do projeto principal em C ++ 14 usando tabelas virtuais, new / delete (trabalhando com um monte de FreeRTOS), shared_ptr (e outros ponteiros inteligentes) e outras del√≠cias das bibliotecas C ++ 14 padr√£o; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">FreeRTOS</a> usando cerca de 6 tarefas para manter a infraestrutura perif√©rica de hardware e cerca de 10 na l√≥gica de neg√≥cios ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">biblioteca de</a> gr√°ficos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MakiseGUI</a> , processamento de cliques, trabalhando com gordura ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">FatFS</a> ) etc.); </li><li>  16 reposit√≥rios com suas pr√≥prias bibliotecas para interagir com perif√©ricos de hardware na placa, stubs para chamadas do sistema e muito mais; </li></ul><br>  Com os par√¢metros de montagem -O0 -g3, o c√≥digo em uma implementa√ß√£o completa com suporte para unicode, cir√≠lico e outras coisas leva cerca de 700 KB.  No entanto, no est√°gio atual, quando os perif√©ricos de hardware s√£o est√°veis ‚Äã‚Äãe apenas a l√≥gica de neg√≥cios precisa ser depurada, a quantidade de c√≥digo a ser alterada √© de aproximadamente 20 KB.  Por esse motivo, √† primeira vista, parece que a abordagem atual √© uma solu√ß√£o ideal para o problema (a op√ß√£o com simula√ß√£o em um computador n√£o √© considerada por algum motivo). <br><br><h2>  Lista de a√ß√µes </h2><br>  Para implementar o m√©todo descrito, voc√™ precisar√° de: <br><br><ul><li>  reunir todos os subm√≥dulos como bibliotecas est√°ticas (a descri√ß√£o deste item n√£o est√° inclu√≠da na lista de itens analisados ‚Äã‚Äãdeste artigo); </li><li>  reescrever mem.ld; </li><li>  reescreva section.ld; </li><li>  adicione um utilit√°rio ao projeto principal para extrair se√ß√µes do arquivo bin final; </li><li>  adicione ao projeto uma chamada ao script para atualizar a mem√≥ria n√£o vol√°til do microcontrolador ao atualizar o arquivo de firmware. </li></ul><br><h2>  Reescrevendo mem.ld </h2><br>  O primeiro passo √© refinar o mem.ld ‚Äúpadr√£o‚Äù para o conceito atual.  Ao finalizar, deve-se ter em mente que a mem√≥ria n√£o vol√°til √© limpa por setores.  Leia mais sobre como os setores s√£o estruturados em um microcontrolador espec√≠fico deve ser lido na documenta√ß√£o (no caso dos microcontroladores stm32 - no manual de refer√™ncia).  Cada se√ß√£o pode ocupar pelo menos um setor (mais pode ser); caso contr√°rio, uma se√ß√£o substituir√° a outra. <br><br>  Tamb√©m deve-se ter em mente que, se uma biblioteca usa vari√°veis ‚Äã‚Äãglobais, para essa biblioteca voc√™ precisa reservar um lugar na RAM no est√°gio de vincula√ß√£o.  Caso contr√°rio, voc√™ poder√° encontrar bugs desagrad√°veis ‚Äã‚Äãque ser√£o extremamente dif√≠ceis de detectar.  Por exemplo, o c√≥digo da biblioteca FatFS estar√° na se√ß√£o ROM_EXTERNAL_LIBRARIES, mas requer 4 bytes de RAM no est√°gio de compila√ß√£o.  Portanto, voc√™ precisa garantir que haja uma se√ß√£o na RAM para os campos que o c√≥digo de ROM_EXTERNAL_LIBRARIES usar√°.  Neste exemplo, √© RAM_EXTERNAL_LIBRARIES. <br><br>  A √∫ltima se√ß√£o da mem√≥ria n√£o vol√°til merece aten√ß√£o especial.  Tudo o que n√£o foi decomposto nas se√ß√µes correspondentes anteriormente, de acordo com section.ld (sobre isso mais tarde), entrar√° nele. <br><br><div class="spoiler">  <b class="spoiler_title">No contexto do projeto atual, o mem.ld ter√° esta apar√™ncia.</b> <div class="spoiler_text"><pre> <code class="bash hljs">/*    stm32f405rgt6   ChiptunePlayer-2.22-MainBoard-v2-Firmware. */ MEMORY { /*-----------------------------FLASH-------------------------------*/ /*  0-1  . */ ROM_BOOTLOADER (RX) : ORIGIN = 0x08000000, LENGTH = 32K /*  2     . */ ROM_SYSCFG_PAGE_1 (R) : ORIGIN = 0x08008000, LENGTH = 16K /*  3      . */ ROM_SYSCFG_PAGE_2 (R) : ORIGIN = 0x0800C000, LENGTH = 16K /*  4 . */ ROM_RESERVE (R) : ORIGIN = 0x08010000, LENGTH = 16K /*  5, 6, 7      (FATFS, FREERTOS...). */ ROM_EXTERNAL_LIBRARIES (RX) : ORIGIN = 0x08020000, LENGTH = 384K /*  8, 9      ( ,  ...). */ ROM_USER_LIBRARIES (RX) : ORIGIN = 0x08080000, LENGTH = 384K /*  5, 6      . */ ROM_MAIN_PROGRAMM (RX) : ORIGIN = 0x080E0000, LENGTH = 128K /*-----------------------------RAM---------------------------------*/ /*      RAM    . */ RAM_PAGE_1 (RW) : ORIGIN = 0x20000000, LENGTH = 112K RAM_PAGE_2 (RW) : ORIGIN = 0x2001C000, LENGTH = 16K /*           FATFS  FreeRTOS. */ RAM_EXTERNAL_LIBRARIES (RW) : ORIGIN = 0x20000000, LENGTH = 10K /*        . */ RAM_USER_LIBRARIES (RW) : ORIGIN = 0x20002800, LENGTH = 90K /*    RAM    . */ RAM_MAIN_PROGRAMM (RW) : ORIGIN = 0x20019000, LENGTH = 27K /*   RAM    .    FreeRTOS. */ RAM_MAIN_PROGRAMM_STACK (RW) : ORIGIN = 0x2001FC00, LENGTH = 1K }</code> </pre> </div></div><br><h2>  Reescreva section.ld </h2><br>  Depois que o cart√£o de mem√≥ria existente for dividido em se√ß√µes, deve-se descrever qual parti√ß√£o ser√° colocada.  Para cada biblioteca (se houver uma se√ß√£o correspondente na biblioteca), indique onde est√£o localizados os textos .text, .rodata, .data, .bss e outras se√ß√µes.  A lista de se√ß√µes dispon√≠veis na biblioteca pode ser visualizada usando o objdump.  Por exemplo, para a biblioteca libstdc ++ _ nano.a, √© necess√°rio especificar onde colocar o texto, ARM.attributes, rodata, data, bss, se√ß√µes COMMON. <br><br><div class="spoiler">  <b class="spoiler_title">No contexto do projeto atual, o section.ld ter√° esta apar√™ncia.</b> <div class="spoiler_text"><pre> <code class="bash hljs">/*             RAM. */ __estack = ORIGIN(RAM_MAIN_PROGRAMM_STACK) + LENGTH(RAM_MAIN_PROGRAMM_STACK); /*   . */ __stack_size = LENGTH(RAM_MAIN_PROGRAMM_STACK); /*     Reset_Handler. */ ENTRY(Reset_Handler) /*  . */ SECTIONS { /*---------------------ROM  ------------------------*/ .section_bootloader : ALIGN(4) { /*     .             .          .o ,     .*/ . = ALIGN(4); KEEP(*(.user_code_isr_vector .user_code_isr_vector*)) . = ALIGN(4); } &gt;ROM_BOOTLOADER /*----------------ROM    -----------------*/ /* . */ .section_external_libraries_text : ALIGN(4) { /*  . */ . = ALIGN(4); *libstdc++_nano.a:*(.text .text*); . = ALIGN(4); *libgcc.a:*(.text .text*); . = ALIGN(4); *libg_nano.a:*(.text .text*); /*   */ . = ALIGN(4); *libSTM32F4_LOW_LEVEL_BY_ST.a:*(.text .text*); . = ALIGN(4); *libFATFS.a:*(.text .text*); . = ALIGN(4); *libFREERTOS.a:*(.text .text*); . = ALIGN(4); *libMAKISE_GUI.a:*(.text .text*); . = ALIGN(4); } &gt;ROM_EXTERNAL_LIBRARIES /* ,   */ .section_external_libraries_required_by_the_compiler : ALIGN(4) { /*  . */ . = ALIGN(4); *libgcc.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libstdc++_nano.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libg_nano.a:*(.ARM.attributes .ARM.attributes*); /*   */ . = ALIGN(4); *libSTM32F4_LOW_LEVEL_BY_ST.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libFATFS.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libFREERTOS.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libMAKISE_GUI.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); } &gt;ROM_EXTERNAL_LIBRARIES /*    . */ .section_external_libraries_rodata : ALIGN(4) { /*  . */ . = ALIGN(4); *libgcc.a:*(.rodata .rodata*); . = ALIGN(4); *libstdc++_nano.a:*(.rodata .rodata*); . = ALIGN(4); *libg_nano.a:*(.rodata .rodata*); /*   */ . = ALIGN(4); *libSTM32F4_LOW_LEVEL_BY_ST.a:*(.rodata .rodata*); . = ALIGN(4); *libFATFS.a:*(.rodata .rodata*); . = ALIGN(4); *libFREERTOS.a:*(.rodata .rodata*); . = ALIGN(4); *libMAKISE_GUI.a:*(.rodata .rodata*); . = ALIGN(4); } &gt;ROM_EXTERNAL_LIBRARIES /*----------------------- ---------------------*/ /* . */ .section_user_libraries_text : ALIGN(4) { . = ALIGN(4); *libUSER_FREERTOS_LEVEL.a:*(.text .text*); . = ALIGN(4); *libUSER_BSP_LEVEL.a:*(.text .text*); . = ALIGN(4); *libMC_INTERRUPT.a:*(.text .text*); . = ALIGN(4); *libMC_HARDWARE.a:*(.text .text*); . = ALIGN(4); *libPCB_HARDWARE.a:*(.text .text*); . = ALIGN(4); *libUSER_STARTUP.a:*(.text .text*); . = ALIGN(4); *libBUTTONS.a:*(.text .text*); . = ALIGN(4); *libCHIPTUNE.a:*(.text .text*); . = ALIGN(4); *libDIGITAL_POTENTIOMETER.a:*(.text .text*); . = ALIGN(4); *libLCD_DRIVER.a:*(.text .text*); . = ALIGN(4); *libMAKISE_GUI_ELEMENTS_BY_VADIMATORIK_ELEMENTS_BY_VADIMATORIK.a:*(.text .text*); . = ALIGN(4); *libMC_HARDWARE_INTERFACES_IMPLEMENTATION_FOR_STM32.a:*(.text .text*); . = ALIGN(4); *libMICROSD_LOW_LEVEL_DRIVER.a:*(.text .text*); . = ALIGN(4); *libSHIFT_REGISTER.a:*(.text .text*); . = ALIGN(4); *libWAVE_GENERATORS.a:*(.text .text*); . = ALIGN(4); *libRUN_TIME_LOGGER.a:*(.text .text*); . = ALIGN(4); } &gt;ROM_USER_LIBRARIES /* ,   */ .section_user_libraries_required_by_the_compiler : ALIGN(4) { . = ALIGN(4); *libUSER_FREERTOS_LEVEL.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libUSER_BSP_LEVEL.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libMC_INTERRUPT.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libMC_HARDWARE.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libPCB_HARDWARE.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libUSER_STARTUP.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libUSER_CODE.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libBUTTONS.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libCHIPTUNE.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libDIGITAL_POTENTIOMETER.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libLCD_DRIVER.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libMAKISE_GUI_ELEMENTS_BY_VADIMATORIK_ELEMENTS_BY_VADIMATORIK.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libMC_HARDWARE_INTERFACES_IMPLEMENTATION_FOR_STM32.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libMICROSD_LOW_LEVEL_DRIVER.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libSHIFT_REGISTER.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libWAVE_GENERATORS.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libRUN_TIME_LOGGER.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); } &gt;ROM_EXTERNAL_LIBRARIES /*    . */ .section_user_libraries_rodata : ALIGN(4) { . = ALIGN(4); *libUSER_FREERTOS_LEVEL.a:*(.rodata .rodata*); . = ALIGN(4); *libUSER_BSP_LEVEL.a:*(.rodata .rodata*); . = ALIGN(4); *libMC_INTERRUPT.a:*(.rodata .rodata*); . = ALIGN(4); *libMC_HARDWARE.a:*(.rodata .rodata*); . = ALIGN(4); *libPCB_HARDWARE.a:*(.rodata .rodata*); . = ALIGN(4); *libUSER_STARTUP.a:*(.rodata .rodata*); . = ALIGN(4); *libBUTTONS.a:*(.rodata .rodata*); . = ALIGN(4); *libCHIPTUNE.a:*(.rodata .rodata*); . = ALIGN(4); *libDIGITAL_POTENTIOMETER.a:*(.rodata .rodata*); . = ALIGN(4); *libLCD_DRIVER.a:*(.rodata .rodata*); . = ALIGN(4); *libMAKISE_GUI_ELEMENTS_BY_VADIMATORIK_ELEMENTS_BY_VADIMATORIK.a:*(.rodata .rodata*); . = ALIGN(4); *libMC_HARDWARE_INTERFACES_IMPLEMENTATION_FOR_STM32.a:*(.rodata .rodata*); . = ALIGN(4); *libMICROSD_LOW_LEVEL_DRIVER.a:*(.rodata .rodata*); . = ALIGN(4); *libSHIFT_REGISTER.a:*(.rodata .rodata*); . = ALIGN(4); *libWAVE_GENERATORS.a:*(.rodata .rodata*); . = ALIGN(4); *libRUN_TIME_LOGGER.a:*(.rodata .rodata*); . = ALIGN(4); } &gt;ROM_USER_LIBRARIES /*------------------------- ------------------------*/ /* . */ .section_user_code_text : ALIGN(4) { . = ALIGN(4); *(.text .text.*) . = ALIGN(4); } &gt;ROM_MAIN_PROGRAMM /* ,   */ .sections_user_code_required_by_the_compiler : ALIGN(4) { . = ALIGN(4); *(.glue_7 .glue_7*) /*  -  ARMv7 */ . = ALIGN(4); *(.glue_7t .glue_7t*) . = ALIGN(4); *(.vfp11_veneer .vfp11_veneer*) /*   . */ . = ALIGN(4); *(.v4_bx .v4_bx*) . = ALIGN(4); *(.iplt .iplt*) . = ALIGN(4); *(.rel.dyn .rel.dyn*) . = ALIGN(4); KEEP(*(.eh_frame .eh_frame*)) /*     CPP. */ . = ALIGN(4); *(.eh_framehdr .eh_framehdr*) . = ALIGN(4); *(.ARM.attributes .ARM.attributes.*) /*    ,  . */ . = ALIGN(4); *(vtable) /* C++ virtual tables */ PROVIDE_HIDDEN (__preinit_array_start = .); /*  ,   . */ . = ALIGN(4); KEEP(*(.preinit_array_sysinit .preinit_array_sysinit*)) . = ALIGN(4); KEEP(*(.preinit_array_platform .preinit_array_platform.*)) . = ALIGN(4); KEEP(*(.preinit_array .preinit_array.*)) PROVIDE_HIDDEN (__preinit_array_end = .); PROVIDE_HIDDEN (__init_array_start = .); /*    . */ . = ALIGN(4); KEEP(*(SORT(.init_array.*))) . = ALIGN(4); KEEP(*(.init_array)) . = ALIGN(4); PROVIDE_HIDDEN (__init_array_end = .); PROVIDE_HIDDEN (__fini_array_start = .); /*    . */ . = ALIGN(4); KEEP(*(SORT(.fini_array.*))) . = ALIGN(4); KEEP(*(.fini_array)) . = ALIGN(4); PROVIDE_HIDDEN (__fini_array_end = .); . = ALIGN(4); KEEP(*(.cfmconfig)) . = ALIGN(4); *(.after_vectors .after_vectors.*) . = ALIGN(4); } &gt;ROM_MAIN_PROGRAMM /*    . */ .section_user_code_rodata : ALIGN(4) { . = ALIGN(4); *(.rodata .rodata.*) . = ALIGN(4); } &gt;ROM_MAIN_PROGRAMM /*  stack trace. */ .ARM.exidx : { . = ALIGN(4); *(.ARM.extab* .gnu.linkonce.armextab.*) . = ALIGN(4); *(.ARM.exidx* .gnu.linkonce.armexidx.*) . = ALIGN(4); } &gt; ROM_MAIN_PROGRAMM /*-------------------------------RAM-----------------------------*/ /*    . */ .section_external_libraries_data : ALIGN(4) { . = ALIGN(4); __external_lib_data_start = . ; /*  . */ . = ALIGN(4); *libgcc.a:*(.data .data*); . = ALIGN(4); *libstdc++_nano.a:*(.data .data*); . = ALIGN(4); *libg_nano.a:*(.data .data*); /*   */ . = ALIGN(4); *libSTM32F4_LOW_LEVEL_BY_ST.a:*(.data .data*); . = ALIGN(4); *libFATFS.a:*(.data .data*); . = ALIGN(4); *libFREERTOS.a:*(.data .data*); . = ALIGN(4); *libMAKISE_GUI.a:*(.data .data*); . = ALIGN(4); __external_lib_data_end = . ; } &gt;RAM_EXTERNAL_LIBRARIES AT&gt; ROM_EXTERNAL_LIBRARIES /*       RAM */ .section_external_libraries_bss : ALIGN(4) { . = ALIGN(4); __external_lib_bss_start = .; /*  . */ . = ALIGN(4); *libgcc.a:*(.bss .bss*); . = ALIGN(4); *libstdc++_nano.a:*(.bss .bss*); . = ALIGN(4); *libg_nano.a:*(*COMMON); . = ALIGN(4); *libgcc.a:*(*COMMON); . = ALIGN(4); *libstdc++_nano.a:*(*COMMON); . = ALIGN(4); *libg_nano.a:*(*COMMON); /*   */ . = ALIGN(4); *libSTM32F4_LOW_LEVEL_BY_ST.a:*(.bss .bss*); . = ALIGN(4); *libFATFS.a:*(.bss .bss*); . = ALIGN(4); *libFREERTOS.a:*(.bss .bss*); . = ALIGN(4); *libMAKISE_GUI.a:*(.bss .bss*); . = ALIGN(4); *libSTM32F4_LOW_LEVEL_BY_ST.a:*(*COMMON); . = ALIGN(4); *libFATFS.a:*(*COMMON); . = ALIGN(4); *libFREERTOS.a:*(*COMMON); . = ALIGN(4); *libMAKISE_GUI.a:*(*COMMON); . = ALIGN(4); __external_lib_bss_end = .; } &gt;RAM_EXTERNAL_LIBRARIES /*    . */ .section_user_libraries_data : ALIGN(4) { . = ALIGN(4); __user_lib_data_start = . ; . = ALIGN(4); *libUSER_FREERTOS_LEVEL.a:*(.data .data*); . = ALIGN(4); *libUSER_BSP_LEVEL.a:*(.data .data*); . = ALIGN(4); *libMC_INTERRUPT.a:*(.data .data*); . = ALIGN(4); *libMC_HARDWARE.a:*(.data .data*); . = ALIGN(4); *libPCB_HARDWARE.a:*(.data .data*); . = ALIGN(4); *libUSER_STARTUP.a:*(.data .data*); . = ALIGN(4); *libBUTTONS.a:*(.data .data*); . = ALIGN(4); *libCHIPTUNE.a:*(.data .data*); . = ALIGN(4); *libDIGITAL_POTENTIOMETER.a:*(.data .data*); . = ALIGN(4); *libLCD_DRIVER.a:*(.data .data*); . = ALIGN(4); *libMAKISE_GUI_ELEMENTS_BY_VADIMATORIK_ELEMENTS_BY_VADIMATORIK.a:*(.data .data*); . = ALIGN(4); *libMC_HARDWARE_INTERFACES_IMPLEMENTATION_FOR_STM32.a:*(.data .data*); . = ALIGN(4); *libMICROSD_LOW_LEVEL_DRIVER.a:*(.data .data*); . = ALIGN(4); *libSHIFT_REGISTER.a:*(.data .data*); . = ALIGN(4); *libWAVE_GENERATORS.a:*(.data .data*); . = ALIGN(4); *libRUN_TIME_LOGGER.a:*(.data .data*); . = ALIGN(4); __user_lib_data_end = . ; } &gt;RAM_USER_LIBRARIES AT&gt; ROM_USER_LIBRARIES .section_user_libraries_bss : ALIGN(4) { . = ALIGN(4); __user_lib_bss_start = .; . = ALIGN(4); *libUSER_FREERTOS_LEVEL.a:*(.bss .bss*); . = ALIGN(4); *libUSER_BSP_LEVEL.a:*(.bss .bss*); . = ALIGN(4); *libMC_INTERRUPT.a:*(.bss .bss*); . = ALIGN(4); *libMC_HARDWARE.a:*(.bss .bss*); . = ALIGN(4); *libPCB_HARDWARE.a:*(.bss .bss*); . = ALIGN(4); *libUSER_CODE.a:*(.bss .bss*); . = ALIGN(4); *libBUTTONS.a:*(.bss .bss*); . = ALIGN(4); *libCHIPTUNE.a:*(.bss .bss*); . = ALIGN(4); *libDIGITAL_POTENTIOMETER.a:*(.bss .bss*); . = ALIGN(4); *libLCD_DRIVER.a:*(.bss .bss*); . = ALIGN(4); *libMAKISE_GUI_ELEMENTS_BY_VADIMATORIK_ELEMENTS_BY_VADIMATORIK.a:*(.bss .bss*); . = ALIGN(4); *libMC_HARDWARE_INTERFACES_IMPLEMENTATION_FOR_STM32.a:*(.bss .bss*); . = ALIGN(4); *libMICROSD_LOW_LEVEL_DRIVER.a:*(.bss .bss*); . = ALIGN(4); *libSHIFT_REGISTER.a:*(.bss .bss*); . = ALIGN(4); *libWAVE_GENERATORS.a:*(.bss .bss*); . = ALIGN(4); *libUSER_FREERTOS_LEVEL.a:*(.bss .bss*); . = ALIGN(4); *libRUN_TIME_LOGGER.a:*(.bss .bss*); . = ALIGN(4); *libUSER_BSP_LEVEL.a:*(*COMMON); . = ALIGN(4); *libMC_INTERRUPT.a:*(*COMMON); . = ALIGN(4); *libMC_HARDWARE.a:*(*COMMON); . = ALIGN(4); *libPCB_HARDWARE.a:*(*COMMON); . = ALIGN(4); *libUSER_CODE.a:*(*COMMON); . = ALIGN(4); *libBUTTONS.a:*(*COMMON); . = ALIGN(4); *libCHIPTUNE.a:*(*COMMON); . = ALIGN(4); *libDIGITAL_POTENTIOMETER.a:*(*COMMON); . = ALIGN(4); *libLCD_DRIVER.a:*(*COMMON); . = ALIGN(4); *libMAKISE_GUI_ELEMENTS_BY_VADIMATORIK_ELEMENTS_BY_VADIMATORIK.a:*(*COMMON); . = ALIGN(4); *libMC_HARDWARE_INTERFACES_IMPLEMENTATION_FOR_STM32.a:*(*COMMON); . = ALIGN(4); *libMICROSD_LOW_LEVEL_DRIVER.a:*(*COMMON); . = ALIGN(4); *libSHIFT_REGISTER.a:*(*COMMON); . = ALIGN(4); *libWAVE_GENERATORS.a:*(*COMMON); . = ALIGN(4); *libRUN_TIME_LOGGER.a:*(.COMMON*); . = ALIGN(4); __user_lib_bss_end = .; } &gt;RAM_USER_LIBRARIES /*    . */ .section_user_code_data : ALIGN(4) { . = ALIGN(4); __user_code_data_start = . ; . = ALIGN(4); *(.data .data.*) . = ALIGN(4); __user_code_data_end = . ; } &gt;RAM_MAIN_PROGRAMM AT&gt; ROM_MAIN_PROGRAMM .section_user_code_bss : ALIGN(4) { . = ALIGN(4); __bss_start__ = .; __user_code_bss_start = .; *(.bss .bss.*) *(COMMON) . = ALIGN(4); __bss_end__ = .; __user_code_bss_end = .; } &gt;RAM_MAIN_PROGRAMM __external_lib_data_in_rom_start = LOADADDR(.section_external_libraries_data); __user_lib_data_in_rom_start = LOADADDR(.section_user_libraries_data); __user_code_data_in_rom_start = LOADADDR(.section_user_code_data); /*------------------------- -----------------*/ /* Stabs debugging sections. */ .stab 0 : { *(.stab) } .stabstr 0 : { *(.stabstr) } .stab.excl 0 : { *(.stab.excl) } .stab.exclstr 0 : { *(.stab.exclstr) } .stab.index 0 : { *(.stab.index) } .stab.indexstr 0 : { *(.stab.indexstr) } .comment 0 : { *(.comment) } /* * DWARF debug sections. * Symbols <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the DWARF debugging sections are relative to the beginning * of the section so we begin them at 0. */ /* DWARF 1 */ .debug 0 : { *(.debug) } .line 0 : { *(.line) } /* GNU DWARF 1 extensions */ .debug_srcinfo 0 : { *(.debug_srcinfo) } .debug_sfnames 0 : { *(.debug_sfnames) } /* DWARF 1.1 and DWARF 2 */ .debug_aranges 0 : { *(.debug_aranges) } .debug_pubnames 0 : { *(.debug_pubnames) } /* DWARF 2 */ .debug_info 0 : { *(.debug_info .gnu.linkonce.wi.*) } .debug_abbrev 0 : { *(.debug_abbrev) } .debug_line 0 : { *(.debug_line) } .debug_frame 0 : { *(.debug_frame) } .debug_str 0 : { *(.debug_str) } .debug_loc 0 : { *(.debug_loc) } .debug_macinfo 0 : { *(.debug_macinfo) } /* SGI/MIPS DWARF 2 extensions */ .debug_weaknames 0 : { *(.debug_weaknames) } .debug_funcnames 0 : { *(.debug_funcnames) } .debug_typenames 0 : { *(.debug_typenames) } .debug_varnames 0 : { *(.debug_varnames) } .debug_macro 0 : { *(.debug_macro) } .debug_ranges 0 : { *(.debug_ranges) } }</code> </pre> </div></div><br><h2>  Adicione um utilit√°rio ao projeto principal para extrair se√ß√µes do arquivo bin final </h2><br>  Infelizmente, n√£o foi poss√≠vel encontrar sinalizadores no objcopy ou no objdump para extrair c√≥digo entre endere√ßos espec√≠ficos do arquivo elf.  O <b>sinalizador --only-section existe</b> , no entanto, n√£o leva em considera√ß√£o o fato de que, depois de todas as entidades listadas na se√ß√£o.ld, as informa√ß√µes de depura√ß√£o ainda s√£o colocadas na mem√≥ria n√£o vol√°til.  Sem ele, o firmware final, montado a partir de pe√ßas, n√£o funcionar√° (por raz√µes √≥bvias).  Portanto, tive que escrever um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">utilit√°rio</a> simples que pega um arquivo bin comum e extrai a se√ß√£o necess√°ria em um arquivo separado para o intervalo de endere√ßos especificado.  No entanto, a nuance a seguir surge aqui.  Por padr√£o, o objcopy preenche o espa√ßo entre as se√ß√µes com 0s.  No entanto, o espa√ßo vazio na mem√≥ria flash √© 0xFF.  Para resolver esse problema, voc√™ precisa compor o arquivo da bandeja de sa√≠da com o sinalizador <b>--gap-fill = 0xff</b> . <br><br><h2>  Adicione uma chamada ao script do projeto para atualizar a mem√≥ria n√£o vol√°til do microcontrolador ao atualizar o arquivo de firmware </h2><br>  Para rastrear as mudan√ßas no projeto, ap√≥s cada reconstru√ß√£o do arquivo elf, voc√™ precisa chamar um script de verifica√ß√£o que extrair√° o arquivo bin final do arquivo elf, compare a se√ß√£o desejada dele, compare-a com a extra√≠da anteriormente e, se houver alguma diferen√ßa, atualize a se√ß√£o na mem√≥ria do microcontrolador. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo do script de compara√ß√£o</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # # $1 -  .   ,    . # $2 -     elf . # $3 -      STM32. # echo "Old file name: $1" echo "New file name: $2" # ,     . flag_rewrite=0 #    ,         #  ,      (   #     ). #    ,   ,   -    #  ,     .  ,   . if [ -e $1 ] then #         . echo "Both files exist." #  md5   ,     . buf=$(md5sum $1 --binary) md5_old=${buf:0:32} #      md5   . #   32 . buf=$(md5sum $2 --binary) md5_new=${buf:0:32} echo "Started file comparison." if [ $md5_old == $md5_new ] then #     ,  . echo "The file has not been updated." echo "The new file will be deleted." rm $2 echo "Removed." else #   ,    . echo "The file has been modified." echo "Old will be replaced by new." mv $2 $1 echo "Replaced." flag_rewrite=1 #    . fi else #    . echo "Old file does not exist." echo "New will be renamed to old." mv $2 $1 #    . flag_rewrite=1 #    . echo "Renamed." fi #       ,     . if [ $flag_rewrite -eq 1 ] then echo "Started flashing." echo "CMD params: $3" $3 fi</span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No pr√≥prio projeto, voc√™ pode chamar a fun√ß√£o cmake, que far√° tudo o que voc√™ precisa: </font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fun√ß√£o de atualiza√ß√£o Cmake</font></font></b> <div class="spoiler_text"><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(write_sector SECTOR ADDR_BASE ADDR_START ADDR_END) <span class="hljs-keyword"><span class="hljs-keyword">add_custom_command</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> <span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>.elf POST_BUILD <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> <span class="hljs-variable"><span class="hljs-variable">${ARM_OBJCOPY}</span></span> --output-<span class="hljs-keyword"><span class="hljs-keyword">target</span></span>=binary --gap-fill=<span class="hljs-number"><span class="hljs-number">0</span></span>xff <span class="hljs-variable"><span class="hljs-variable">${PROJECT_BINARY_DIR}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>.elf <span class="hljs-variable"><span class="hljs-variable">${PROJECT_BINARY_DIR}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>_all.bin COMMENT <span class="hljs-string"><span class="hljs-string">"Creating a binary file of the &lt;&lt;${SECTOR}&gt;&gt; sector"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> <span class="hljs-variable"><span class="hljs-variable">${BIN_EXTRACTOR}</span></span> -p <span class="hljs-variable"><span class="hljs-variable">${PROJECT_BINARY_DIR}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>_all.bin -o <span class="hljs-variable"><span class="hljs-variable">${PROJECT_BINARY_DIR}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>_section_<span class="hljs-variable"><span class="hljs-variable">${SECTOR}</span></span>_new.bin -b <span class="hljs-variable"><span class="hljs-variable">${ADDR_BASE}</span></span> -s <span class="hljs-variable"><span class="hljs-variable">${ADDR_START}</span></span> -e <span class="hljs-variable"><span class="hljs-variable">${ADDR_END}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> cd <span class="hljs-variable"><span class="hljs-variable">${CMAKE_SOURCE_DIR}</span></span> &amp;&amp; ./cmp.sh <span class="hljs-variable"><span class="hljs-variable">${PROJECT_BINARY_DIR}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>_section_<span class="hljs-variable"><span class="hljs-variable">${SECTOR}</span></span>.bin <span class="hljs-variable"><span class="hljs-variable">${PROJECT_BINARY_DIR}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>_section_<span class="hljs-variable"><span class="hljs-variable">${SECTOR}</span></span>_new.bin <span class="hljs-string"><span class="hljs-string">"${STM32PROG} -c port=${STM32PROG_PORT} freq=${STM32PROG_FREQ} -w ${PROJECT_BINARY_DIR}/${PROJECT_NAME}_section_${SECTOR}.bin ${ADDR_START}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">endfunction</span></span>(write_sector)</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A fun√ß√£o usa stm32programmer para escrever. </font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um exemplo de uso de uma fun√ß√£o do c√≥digo do projeto</font></font></b> <div class="spoiler_text"><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (STM32PROG_USE <span class="hljs-keyword"><span class="hljs-keyword">STREQUAL</span></span> <span class="hljs-string"><span class="hljs-string">"ON"</span></span>) write_sector(<span class="hljs-string"><span class="hljs-string">"bootloader"</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_BOOTLOADER_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_BOOTLOADER_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_SYSCFG_PAGE_1_ADDRESS}</span></span>) write_sector(<span class="hljs-string"><span class="hljs-string">"external_libraries"</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_BOOTLOADER_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_EXTERNAL_LIB_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_USER_LIBRARIES_ADDRESS}</span></span>) write_sector(<span class="hljs-string"><span class="hljs-string">"user_libraries"</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_BOOTLOADER_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_USER_LIBRARIES_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_USER_CODE_ADDRESS}</span></span>) write_sector(<span class="hljs-string"><span class="hljs-string">"main_programm"</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_BOOTLOADER_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_USER_CODE_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${ADDR_END_FLASH}</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">endif</span></span> ()</code> </pre> </div></div><br><br><h2>  Conclus√µes </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As vantagens desta abordagem: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em 95% dos casos, o que √© realmente necess√°rio √© atualizado; </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Contras desta abordagem: </font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o h√° ganho de velocidade, pois antes de cada firmware √© necess√°rio carregar um gerenciador de inicializa√ß√£o no microcontrolador para piscar a mem√≥ria n√£o vol√°til (isso √© feito automaticamente pelo stm32programmer). </font><font style="vertical-align: inherit;">Pelo contr√°rio, quando o projeto √© remontado completamente, √© necess√°rio costurar todas as se√ß√µes novamente;</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o tamanho de section.ld desencoraja qualquer desejo de adicionar ou alterar algo nele. </font><font style="vertical-align: inherit;">Se voc√™ precisar aplicar essa metodologia em um projeto real, precisar√° escrever uma GUI conveniente para editar este arquivo;</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se o dispositivo controlar sua pr√≥pria energia, voc√™ poder√° n√£o perceber que uma das parti√ß√µes n√£o foi conectada corretamente (com queda de tens√£o, por exemplo) e depurar parti√ß√µes de diferentes montagens por um longo tempo :). </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ pode ver a vers√£o de trabalho do m√©todo atual </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neste commit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">O projeto pode ser montado no CLion, tendo compilado anteriormente um utilit√°rio para extrair a se√ß√£o do arquivo bin.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt437848/">https://habr.com/ru/post/pt437848/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt437836/index.html">Sob o cap√¥ Screeps - virtualiza√ß√£o na caixa de areia MMO para programadores</a></li>
<li><a href="../pt437838/index.html">As tecnologias de aprendizado de m√°quina aceleram o processo de adapta√ß√£o dos pacientes √†s pr√≥teses bi√¥nicas</a></li>
<li><a href="../pt437842/index.html">A hist√≥ria secreta de Donkey Kong: das m√°quinas de arcade ao NES</a></li>
<li><a href="../pt437844/index.html">O conflito permanente de digita√ß√£o est√°tica versus din√¢mica - o TypeScript n√£o ajuda</a></li>
<li><a href="../pt437846/index.html">bobaoskit - acess√≥rios, dnssd e WebSocket</a></li>
<li><a href="../pt437850/index.html">Quem √© mais eficaz no layout de PCB?</a></li>
<li><a href="../pt437852/index.html">Hist√≥ria do Shipastik</a></li>
<li><a href="../pt437858/index.html">Palestras adicionais do curso "Designing Highly Loaded Systems" (outono de 2018) em Technopolis</a></li>
<li><a href="../pt437864/index.html">Sistema de Monitoramento para servidores Windows em SQL puro, e como eu o havia arrastado secretamente para a Produ√ß√£o</a></li>
<li><a href="../pt437868/index.html">Semana 05 de seguran√ßa: Impressoras, c√¢meras, 7zip e √©tica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>