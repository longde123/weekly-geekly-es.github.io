<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôéüèæ üí∏ ü•ô TrustZone: OS de confiance et ses applications üíè üà¥ üë®üèæ‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans les articles pr√©c√©dents, nous avons examin√© le p√©riph√©rique mat√©riel TrustZone et le fonctionnement du m√©canisme Secure Monitor. Aujourd'hui, nou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TrustZone: OS de confiance et ses applications</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/aladdinrd/blog/428311/">  Dans les articles pr√©c√©dents, nous avons examin√© le p√©riph√©rique mat√©riel TrustZone et le fonctionnement du m√©canisme Secure Monitor.  Aujourd'hui, nous allons nous concentrer sur le syst√®me d'exploitation de confiance (TEE) et ses applications.  Et si la derni√®re fois, il y avait des choses de bas niveau, maintenant tout sera √† un niveau tr√®s √©lev√© - au niveau du syst√®me d'exploitation. <a name="habracut"></a><br><br><h2>  Qu'est-ce que TEE? </h2><br>  Qu'est-ce que TEE?  Il s'agit de l'environnement d'ex√©cution de confiance (Trusted Execution Environment), en premier lieu - c'est l'environnement d'ex√©cution des programmes.  Nous le d√©crivons en termes de fonction et de propri√©t√©s, mais pas dans le sens de la programmation, mais dans un sens philosophique. <br><br>  Par exemple, un train longue distance, un train et un taxi ont l'une des fonctions les plus importantes - pour transporter des personnes.  Mais selon leurs propri√©t√©s, ils diff√®rent, par exemple: un train circule entre les villes, un train √©lectrique - hors ville, et un taxi - principalement en ville.  Train et train pour les billets, taxi - no.  Et ainsi de suite. <br><br>  La fonction TEE est de stocker en toute s√©curit√© certaines donn√©es pour nous et de lancer des applications pour nous.  Nous voulons transmettre des commandes TEE: lancer telle ou telle application, prendre telle ou telle donn√©e et faire ceci et cela avec eux.  Dans le m√™me temps, nous ne pouvons pas voir le code de l'application, ainsi que les donn√©es.  Nous n'obtiendrons que le r√©sultat.  L'interaction avec TEE est tr√®s similaire √† RPC. <br><br>  Cette fonction est id√©ale pour diverses cryptographies, par exemple pour la signature √©lectronique: les cl√©s sont stock√©es dans TEE, et nous demandons √† TEE de signer les donn√©es transmises avec une cl√© stock√©e dans TEE.  Nous obtenons le r√©sultat, mais n'avons pas acc√®s √† la cl√©. <br><br>  TEE a un certain nombre de propri√©t√©s, mais les principales sont: a) nous faisons confiance √† sa mise en ≈ìuvre, et b) il est s√©par√© de mani√®re fiable du syst√®me d'exploitation principal de l'appareil, prot√©g√©, il est difficile de le casser ou de le casser.  Il existe d'autres propri√©t√©s, mais nous l'appelons un syst√®me d'exploitation de confiance pour cela.  Propri√©t√© b) la chose la plus importante est que le TEE est s√©par√© et difficile √† casser, c'est-√†-dire qu'il est prot√©g√©. <br><br>  Si vous regardez TEE √† travers le prisme des fonctions et des propri√©t√©s, il devient clair que TEE ne concerne m√™me pas TrustZone.  TrustZone est l'un des moyens de s√©parer TEE du syst√®me d'exploitation principal (invit√©). <br><br><h2>  Options de mise en ≈ìuvre de TEE </h2><br>  Si les principales propri√©t√©s de TEE sont qu'il est s√©par√© et difficile √† casser, nous pouvons proposer diff√©rentes options pour impl√©menter TEE: <br><br><ul><li>  Utilisez TrustZone - nous obtenons la s√©paration de TEE et du syst√®me d'exploitation principal au sein du m√™me c≈ìur de processeur. </li><li>  Ex√©cutez TEE sur un noyau s√©par√© du syst√®me sur une puce et communiquez avec lui via une interface mat√©rielle.  Certains processeurs sp√©cialis√©s ont des c≈ìurs de confiance distincts pour ex√©cuter TEE, mais vous ne pouvez pas les acheter dans le magasin, h√©las.  Mais vous pouvez prendre un cristal dual-core, par exemple, Cortex-A + Cortex-M0 / M4 et l'ex√©cuter sur Cortex-M TEE. </li><li>  Ex√©cutez TEE sur une puce distincte et √©tablissez une connexion s√©curis√©e avec lui via une interface externe, par exemple SPI ou SMbus.  Pour prot√©ger la communication, utilisez des m√©thodes cryptographiques. <br>  Cette m√©thode est utilis√©e lorsque vous √©tablissez une connexion avec une carte √† puce, telle qu'une carte de paiement en plastique puce sur puce.  Dans un sens, TEE est ex√©cut√© dans la puce, car √† notre demande, il effectue tr√®s en toute confiance des transactions financi√®res, stocke des donn√©es, etc. <br>  La m√™me m√©thode est utilis√©e dans le TPM (Trusted Platform Module) de l'architecture PC moderne. </li></ul><br>  Nous ne parlerons que de l'impl√©mentation de TEE dans TrustZone, car il s'agit d'une version tr√®s courante de l'impl√©mentation de TEE.  Mais une grande partie de ce qui pr√©c√®de s'appliquera au TEE en g√©n√©ral. <br><br><h2>  TEE as OS </h2><br>  Dans les articles pr√©c√©dents, nous avons toujours appel√© TEE un syst√®me d'exploitation de confiance et d√©clar√© qu'il ressemblait beaucoup √† de vrais syst√®mes d'exploitation. <br><br>  Sans pr√©tendre √™tre g√©n√©ral, nous disons que la majorit√© des TEE ont: <br><ul><li> applications et processus: TEE peut t√©l√©charger des applications et les ex√©cuter; </li><li>  s√©paration de la m√©moire du processus et du noyau: utilis√©e par la MMU pour prot√©ger l'espace de la m√©moire du processus et pour prot√©ger la m√©moire centrale du TEE; </li><li>  fils, interactions de processus; </li><li>  stockage de donn√©es. </li></ul><br>  Vous pouvez proposer des versions plus tronqu√©es de TEE, par exemple, sans chargement d'application dynamique, sans interaction de processus, sans threads, mais les applications elles-m√™mes, le stockage de donn√©es et la s√©paration de la m√©moire de processus et de l'espace du noyau resteront. <div class="spoiler">  <b class="spoiler_title">Texte masqu√©</b> <div class="spoiler_text">  Un exemple d'un TEE tronqu√© peut √™tre vu maintenant dans le projet ARM Trusted Firmware-M pour la nouvelle g√©n√©ration de microcontr√¥leurs Cortex-M sur la plate-forme ARMv8-M.  Il s'agit d'un TEE all√©g√©, il existe d√©sormais un support pour les microcontr√¥leurs sur les c≈ìurs Cortex-M23 et Cortex-M33.  Il s'agit de microcontr√¥leurs bas√©s sur flash, √† peu pr√®s √©quivalents √† Cortex-M0 et Cortex-M3, mais avec prise en charge de TrustZone.  Ils ont peu de RAM, le programme s'ex√©cute principalement √† partir de Flash, et donc dans TEE il n'y a pas de chargement dynamique des programmes.  √Ä l'heure actuelle, TF-M est √©galement monofil. <br></div></div><br><h2>  Interface logicielle TEE </h2><br>  Pour interagir avec d'autres composants logiciels, TEE dispose d'une API: <br><br><ul><li>  TEE fournit une API pour les programmes via les appels syst√®me (appel du superviseur, commande SVC); </li><li>  TEE fournit l'API pour Normal World via des appels √† Secure Monitor (commande SMC). </li></ul><br>  Gr√¢ce aux appels syst√®me, les programmes enregistrent les donn√©es et appellent les fonctions du syst√®me d'exploitation.  Comme tout syst√®me d'exploitation d√©cent, TEE essaie d'abstraire des programmes du mat√©riel √† un degr√© ou √† un autre. <br>  Par exemple, les r√©sum√©s Linux fonctionnent avec des fichiers via des appels ouverts, lus, √©crits et ferm√©s - toutes les fonctions stdio rel√®vent essentiellement des appels du syst√®me d'exploitation.  Et TEE permet √©galement √† ses applications de travailler avec des donn√©es stock√©es via des appels qui stockent et chargent de mani√®re abstraite des objets (blocs de donn√©es) dans le stockage.  TEE peut √©galement fournir certaines fonctions cryptographiques au niveau du syst√®me, etc. <br><br>  Il existe un ensemble de sp√©cifications <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GlobalPlatform</a> pour TEE, elles d√©crivent les API, les exigences, les sc√©narios d'utilisation, etc. <br>  Les principales API TEE de ses programmes sont d√©crites dans la sp√©cification TEE Internal Core API.  Il d√©crit les fonctions de stockage de donn√©es, les fonctions cryptographiques, etc. Et l '¬´API client TEE¬ª d√©crit comment appeler des applications depuis Normal World. <br><br>  Si votre TEE impl√©mente ces API, l'√©criture d'une application sera assez simple.  Gr√¢ce √† une API, la portabilit√© des programmes est √©galement impl√©ment√©e. <br><br><h2>  Diff√©rences entre TEE et OS standard </h2><br>  Les deux principales diff√©rences entre TEE et Linux et d'autres syst√®mes d'exploitation courants que nous connaissons sont: <br><br><ol><li>  TEE effectue des actions non pas sur la commande de l'utilisateur, mais sur la commande de Normal World; </li><li>  TEE dans TrustZone n'a pas son propre planificateur. </li></ol><br>  Dans un syst√®me d'exploitation normal, l'utilisateur g√©n√®re une entr√©e - entre des commandes, clique sur les ic√¥nes et le syst√®me d'exploitation traite cette entr√©e, la transf√®re aux programmes et les programmes la traitent.  Dans la version serveur, l'entr√©e ne provient pas de l'utilisateur, mais de certains clients, tr√®s probablement via le r√©seau.  Mais l'OS, cependant, agit sur la base d'une entr√©e externe. <br><br>  TEE ne traite pas les donn√©es externes et ne les transf√®re pas aux applications.  Au lieu de cela, il traite les commandes et les donn√©es transmises depuis Normal World via l'API client TEE, et c'est presque tout.  Il s'av√®re que TEE agit pour le syst√®me d'exploitation comme une biblioth√®que avec une interface RPC, dont les fonctions sont appel√©es.  Apr√®s avoir trait√© les fonctions, TEE peut ne rien faire. <br><br>  La deuxi√®me diff√©rence d√©coule de la premi√®re.  Le TEE de Trustee partage le temps CPU avec Normal World et est appel√© comme biblioth√®que.  TEE n'alloue pas constamment de temps processeur pour lui-m√™me, il passe autant de temps qu'il le faut pour terminer la demande, puis transf√®re le contr√¥le √† Normal World.  Et si c'est le cas, elle ne devrait pas avoir son propre planificateur - elle a besoin d'un planificateur de syst√®me d'exploitation invit√©. <br><br>  Le planificateur principal du syst√®me d'exploitation transf√®re indirectement le contr√¥le √† TEE: <br><br><ul><li>  le planificateur d√©finit la t√¢che √† accomplir; </li><li>  la t√¢che appelle l'appel syst√®me du noyau; </li><li>  un appel syst√®me appelle TEE, si n√©cessaire; </li><li>  TEE travaille aussi longtemps que n√©cessaire pour compl√©ter la demande et renvoie le contr√¥le √† Normal World. </li></ul><br><h2>  Applications TEE </h2><br>  Les applications ex√©cut√©es sur TEE sont appel√©es trustlets - similaires aux applets qui s'ex√©cutent sur des cartes √† puce. <br>  Citation de Wikipedia: <br><blockquote>  Applet (Eng. Applet from application - application and -let - diminutive suffix) est un composant logiciel non autonome travaillant dans le contexte d'une autre application compl√®te, con√ßu pour une t√¢che √©troite et n'ayant pas de valeur ind√©pendamment de l'application de base. </blockquote><br>  Trustlet est une applet de confiance.  Il s'agit d'un programme pour TEE, comme nous l'avons d√©j√† d√©couvert, il communique avec TEE via des appels syst√®me, il a un cycle de vie, etc. <br><br>  Mais quand m√™me, le nom indique qu'il s'agit d'un composant non autonome.  Ici, l'ind√©pendance s'exprime dans le fait que le trustlet fera des appels depuis Normal World, puis se d√©connectera avec TEE.  S'il tourne dans une boucle infinie, le c≈ìur du processeur cessera de fonctionner comme un syst√®me d'exploitation et tout finira par se bloquer.  Mais le programme pour un syst√®me d'exploitation normal peut tourner dans une boucle sans fin et le mien pour compter certaines t√¢ches, c'est tout √† fait normal pour le programme.  √Ä cet √©gard, il est ind√©pendant du trustlet. <br><br>  Le trustlet doit avoir une sorte d'identifiant pour que Normal World puisse l'appeler.  Il est habituel de donner des trustlets sous forme d'UUID - identifiants uniques. <br><br><h2>  Cycle de vie du Trustlet </h2><br>  Consid√©rez comment le trastlet est lanc√© et les commandes sont ex√©cut√©es. <br><br>  Il serait logique de charger le trustlet en m√©moire et de commencer √† travailler, mais dans l'API client GlobalPlatform TEE pour d√©marrer le trustlet, vous devez cr√©er un contexte et √©tablir une session avec le trustlet. <br><br>  La cr√©ation d'un contexte est l'√©tablissement d'une connexion entre le monde normal et TEE.  Dans ce cas, la sp√©cification GlobalPlatform suppose que le p√©riph√©rique peut avoir plusieurs TEE et, au moment de la cr√©ation du contexte, vous pouvez choisir le TEE √† contacter. <br><br>  Dans l'API client GlobalPlatform TEE, une fonction est fournie pour cela: <br><br><pre> TEEC_Result TEEC_InitializeContext (const char * name, TEEC_Context * context)
</pre><br>  Cette fonction est appel√©e depuis l'application Normal World.  Ici, le nom indique le TEE s√©lectionnable.  Si nous voulons TEE par d√©faut ou si nous sommes s√ªrs que nous n'avons qu'un seul TEE, nous substituons NULL.  En contexte, le contexte cr√©√© est enregistr√©. <br><br>  Apr√®s avoir cr√©√© le contexte, vous devez √©tablir une session avec l'approbation.  Ici, l'UUID du trustlet nous est utile.  Pour ce faire, la fonction est appel√©e: <br><br><pre> TEEC_Result TEEC_OpenSession (
	 Contexte TEEC_Context *, session TEEC_Session *,
	 const TEEC_UUID * destination, uint32_t connectionMethod,
	 const void * connectionData, op√©ration TEEC_Operation *,
	 uint32_t * returnOrigin)
</pre><br>  Une session √©quivaut √† travailler avec une instance de programme dans un syst√®me d'exploitation normal: il peut y avoir de nombreuses instances du m√™me programme dans le syst√®me d'exploitation, et elles fonctionneront ind√©pendamment.  Mais il existe de nombreuses sessions dans TEE, et essentiellement, ce sont des connexions √† des instances uniques du trustlet en m√©moire.  Dans ce cas, la zone de code sera probablement la m√™me, mapp√©e via MMU √† la m√©moire de diff√©rents processus.  Mais chaque processus aura sa propre zone de donn√©es, permettant aux instances de fonctionner ind√©pendamment.  Tout comme sur Linux. <br><br>  Lorsque TEEC_OpenSession est appel√©, le contexte et l'UUID de l'approbation de destination sont transmis en entr√©e.  La session √©tablie sera enregistr√©e dans ¬´session¬ª.  Certains param√®tres ci-apr√®s ne seront pas pris en compte, ils ne sont pas si importants pour la compr√©hension. <br><br>  Au moment de la cr√©ation de la session, le trustlet peut √™tre charg√© en m√©moire.  C'est ce qui se passe avec les applications du syst√®me d'exploitation.  En gros TEE, l'√©diteur de liens est responsable de cela, il t√©l√©charge l'image binaire du trustlet, c'est un tel fichier ELF sign√©.  S'il s'agit d'un petit TEE, le trustlet doit d√©j√† √™tre charg√© en m√©moire - il peut √™tre li√© statiquement ou, pour les microcontr√¥leurs flash, √©crit dans la m√©moire flash √† l'adresse sp√©cifi√©e. <br><br>  Supposons que nous avons un grand TEE et que nous devons charger le trustlet en m√©moire.  D'o√π vient-il?  En principe, TEE au moment du chargement a besoin d'un objet avec un certain UUID, et le m√©canisme pour obtenir cet objet peut √™tre n'importe lequel: <br><br><ul><li>  l'objet peut d√©j√† √™tre en m√©moire; </li><li>  l'objet peut √™tre plac√© statiquement dans la m√©moire flash (pour les microcontr√¥leurs flash); </li><li>  l'objet peut √™tre li√© statiquement √† TEE - pour les trustlets syst√®me; </li><li>  enfin, vous pouvez t√©l√©charger le fichier en RAM √† partir du syst√®me de fichiers, ou m√™me sur le r√©seau. </li></ul><br>  Demandez-vous plus tard, comment ce TEE t√©l√©charge-t-il les donn√©es √† partir d'un syst√®me de fichiers ou sur un r√©seau? !!! <br><br>  Apr√®s avoir t√©l√©charg√© l'image du trustlet, sa signature num√©rique est v√©rifi√©e.  Un syst√®me de certificats est utilis√© et TEE v√©rifiera que l'approbation est sign√©e par une partie √† laquelle TEE fait confiance.  Ceci est tr√®s important car il √©limine la possibilit√© de t√©l√©charger un trustlet usurp√© avec certains logiciels malveillants. <br><br>  Lorsque l'image du trustlet est re√ßue et que la signature est v√©rifi√©e, TEE cr√©e l'espace d'adressage pour l'instance de trustlet dans la MMU, et l'√©diteur de liens charge la zone de code en m√©moire, la mappe √† l'espace d'adressage du trustlet et initialise la zone de donn√©es.  Le r√©sultat est une instance enti√®rement initialis√©e du trustlet pour travailler avec l'application appelante sp√©cifique - il s'agit de la cr√©ation de la session. <br><br>  Une fois la session cr√©√©e, le trustlet est en pleine pr√©paration et peut ex√©cuter les demandes de l'application appelante.  Afin d'appeler les fonctions de trustlet √† partir du syst√®me d'exploitation, la fonction est utilis√©e: <br><br><pre> TEEC_Result TEEC_InvokeCommand (
	 Session TEEC_Session *,
	 uint32_t commandID,
	 Op√©ration TEEC_Operation *,
	 uint32_t * returnOrigin) 
</pre><br>  Ici, ¬´session¬ª indique notre session, c'est-√†-dire l'instance TEE et l'instance de trustlet avec lesquelles nous travaillons. <br><br>  "CommandID" indique la fonction appel√©e du trustlet.  Il s'agit de la fonction de trustlet, pas de la fonction TEE.  Tous les soucis de TEE sont de d√©marrer le trustlet et d'envoyer des commandes, et les num√©ros de commande √† attribuer pour communiquer avec le trustlet d√©pendent de vous, il n'y a pas de r√®gle ou de liste globale de fonctions. <br><br>  Si vous devez passer des param√®tres √† la fonction appel√©e, ils sont pass√©s par l'op√©ration - il s'agit d'un pointeur vers la structure TEEC_Operation.  Nous n'entrerons pas trop dans les d√©tails maintenant, notez simplement que cette structure contient jusqu'√† 4 param√®tres de fonction (type TEEC_Parameter).  Les param√®tres peuvent √™tre un simple TEEC_Value ou un pointeur vers la m√©moire.  Les param√®tres ont √©galement une typification dans le sens: TEEC_VALUE_INPUT (entr√©e), TEEC_VALUE_OUTPUT (sortie) ou TEEC_VALUE_INOUT (bidirectionnel). <br><br>  Si nous passons un pointeur sur la structure TEEC_Operation, nous devons d'abord l'initialiser: d√©finir toutes les valeurs et directions.  Une fois l'appel termin√©, nous pouvons v√©rifier les valeurs renvoy√©es dans cette structure (pour TEEC_VALUE_OUTPUT et TEEC_VALUE_INOUT). <br><br>  Pendant la session, nous pouvons appeler les fonctions du trustlet autant de fois que n√©cessaire.  √Ä la fin du travail, vous devrez terminer la session et lib√©rer le contexte en appelant TEEC_CloseSession et TEEC_FinalizeContext. <br><br>  Tout cela fait tr√®s penser au RPC, non?  En principe, toutes les op√©rations avec TEE sont con√ßues comme RPC, et gr√¢ce √† cela, vous pouvez travailler avec une vari√©t√© d'impl√©mentations TEE: dans TrustZone, dans un noyau s√©par√©, dans une puce distincte. <br><br><h2>  Suppliant </h2><br>  Ci-dessus, nous nous sommes demand√©: comment TEE t√©l√©charge-t-il les donn√©es √† partir d'un syst√®me de fichiers ou sur un r√©seau? <br>  Si vous y r√©fl√©chissez, TEE lui-m√™me n'a pas acc√®s au syst√®me de fichiers du syst√®me d'exploitation.  Autrement dit, TEE impl√©ment√© dans TrustZone pourrait avoir un tel acc√®s, mais il devrait ensuite le partager avec Normal World, et ce n'est pas si simple.  Par exemple, Linux fonctionne constamment avec le syst√®me de fichiers, et son √©tat actuel est uniquement dans la m√©moire du noyau Linux, et non sur le disque.  Si TEE veut intervenir et travailler avec le syst√®me de fichiers en parall√®le, ce sera tr√®s difficile.  Avec le partage r√©seau identique. <br><br>  En outre, TEE est un syst√®me d'exploitation plut√¥t petit et il ne serait pas rentable d'impl√©menter des pilotes de bas niveau pour travailler avec des m√©dias, avec un contr√¥leur r√©seau et prendre en charge une pile r√©seau ou un pilote FS.  De plus, cela augmente consid√©rablement la surface d'attaque - il y aurait une chance de casser TEE en glissant un inode inhabituel sur ext2 ou quelque chose comme √ßa.  Nous n'en voulons pas. <br>  Par cons√©quent, lorsque le syst√®me d'exploitation d√©marre, le soi-disant Supplicant est charg√© - un programme assistant.  Il est toujours connect√© √† TEE et TEE l'utilise pour acc√©der aux ressources Normal World. <br><br>  Par cons√©quent, si TEE souhaite t√©l√©charger l'image du trustlet √† partir du syst√®me de fichiers, il appelle Supplicant: <br><br>  <i>TEE: Qu'en est-il d'un objet avec un tel UUID?</i> <i><br></i>  <i>Suppliant: (Charge un objet √† partir du syst√®me de fichiers) D√©sol√©, monsieur!</i> <br><br>  Bien s√ªr, la s√©curit√© de ces appels doit √™tre v√©rifi√©e.  Dans ce cas, nous v√©rifions la signature dans le trustlet et ne prenons presque aucun risque - soit la signature est correcte et le trustlet fonctionne, soit la signature est incorrecte.  Autrement dit, nous le risquons - il peut ne pas y avoir de trustlet, Supplicant ne peut pas √™tre lanc√©, mais c'est une autre partie du mod√®le de menace. <br><br><h2>  Biblioth√®que d'espace utilisateur </h2><br>  L'interface du programme (appels √† TEEC_OpenSession, etc.) est impl√©ment√©e √† l'aide d'une biblioth√®que qui transmet un appel du niveau application √† TEE. <br><br>  Lors de l'impl√©mentation de TEE dans TrustZone, pour cela, la biblioth√®que doit d'abord transf√©rer l'appel au niveau du noyau OS, car seul le noyau OS peut appeler SMC (Secure Monitor Call). <br>  Dans le bundle Linux + OP-TEE, la biblioth√®que de l'espace utilisateur est libteec.  Il traduit les appels de l'API client GlobalPlatform TEE vers le pilote du noyau via les op√©rations ioctl sur le fichier du p√©riph√©rique: lorsque le syst√®me d'exploitation d√©marre, le module du noyau (pilote) est charg√©, le pilote cr√©e le fichier du p√©riph√©rique.  En ouvrant le fichier de p√©riph√©rique avec libteec, le programme utilisateur peut fonctionner avec l'API client TEE. <br><br>  Autrement dit, cette conception fonctionne: <br><blockquote>  <b>Application&gt; libteec&gt; fichier de p√©riph√©rique&gt; pilote du noyau&gt; SMC&gt; TEE&gt; trust.</b> </blockquote><br><h2>  Un exemple de trustlet </h2><br>  Voici comment cela fonctionne dans une application r√©elle: <br><img src="https://habrastorage.org/webt/td/yg/s6/tdygs6hnze62ralshuabjivepr4.png" alt="image"><br>  Ici, le trustlet est utilis√© pour signer √©lectroniquement des documents.  Un programme de Linux appelle le trustlet, dans ce but un contexte TEE est cr√©√©, une session avec le trustlet, les donn√©es pour la signature sont transmises et la signature √©lectronique est retourn√©e. <br><br><h2>  Conclusion </h2><br>  Dans cet article, nous avons compris ce que sont les TEE et les trustlets.  Nous avons rencontr√© l'API TEE et appris comment les trustlets sont appel√©s. <br><br>  Nous avons d√©lib√©r√©ment laiss√© de c√¥t√© beaucoup de choses, telles que l'utilisation de la m√©moire partag√©e et l'√©criture de trastlets, car l'article ne pr√©tend pas √™tre un guide exhaustif. <br><br>  Si vous √™tes int√©ress√© par le sujet du TEE, continuez √† √©tudier par vous-m√™me: vous pouvez commencer par √©tudier les sp√©cifications de GlobalPlatform ou en explorant OP-TEE.  Vous pouvez √©galement nous envoyer un curriculum vitae marqu√© ¬´TrustZone¬ª. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr428311/">https://habr.com/ru/post/fr428311/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr428299/index.html">Messagers vs r√©seaux sociaux vs ... - Suite</a></li>
<li><a href="../fr428301/index.html">Kaspersky Start Russia: concours de projets d'avenir</a></li>
<li><a href="../fr428303/index.html">Un jour dans la vie d'un ing√©nieur syst√®me</a></li>
<li><a href="../fr428305/index.html">√âtudiez-vous l'anglais? Des bandes dessin√©es √† la rescousse</a></li>
<li><a href="../fr428307/index.html">Java Challengers # 1: surcharge de m√©thode dans la machine virtuelle Java</a></li>
<li><a href="../fr428313/index.html">Telegram sur MacOS [vraisemblablement] stocke √©galement localement la correspondance sous une forme accessible</a></li>
<li><a href="../fr428315/index.html">5 peurs des d√©veloppeurs que nous avons surmont√©es</a></li>
<li><a href="../fr428317/index.html">React hooks - gagner ou perdre?</a></li>
<li><a href="../fr428321/index.html">Analyse pr√©dictive des donn√©es - mod√©lisation et validation</a></li>
<li><a href="../fr428327/index.html">Que rechercher: R√®glement europ√©en sur l'identification √©lectronique eIDAS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>