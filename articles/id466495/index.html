<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐁 🔫 🚮 Bagaimana tidak salah dengan persaingan di Go 💕 👨🏾‍🎨 🖊️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mengapa kita bahkan ingin menulis kode kompetitif? Karena prosesor berhenti tumbuh di sepanjang dips dan mulai tumbuh di sepanjang core. Jumlah inti p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana tidak salah dengan persaingan di Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/avito/blog/466495/"><p>  Mengapa kita bahkan ingin menulis kode kompetitif?  Karena prosesor berhenti tumbuh di sepanjang dips dan mulai tumbuh di sepanjang core.  Jumlah inti prosesor meningkat setiap tahun, dan kami ingin menggunakannya secara efektif.  Go adalah bahasa yang dibuat untuk ini.  Dokumentasi mengatakan demikian. </p><br><p> Kami mengambil Go, mulai menulis kode kompetitif.  Tentu saja, kami berharap bahwa kami dapat dengan mudah mengekang kekuatan setiap inti prosesor kami.  Benarkah begitu? </p><br><p>  <em>Nama saya Artemy.</em>  <em>Posting ini adalah transkrip gratis pembicaraan saya dengan GopherCon Russia.</em>  <em>Itu muncul sebagai upaya untuk memberikan dorongan kepada orang-orang yang ingin mengetahui cara menulis kode yang baik dan kompetitif.</em> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/4U3EaVufuW4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <em>Video dari konferensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GopherCon Russia</a></em> </p><a name="habracut"></a><br><h1 id="modeli-vzaimodeystviya">  Model interaksi </h1><br><p>  Untuk memahami apakah Go benar-benar membuatnya lebih mudah bagi kami, mari kita lihat dua model interaksi: <strong>Memori Bersama</strong> dan <strong>Passing Pesan</strong> . </p><br><p><img src="https://habrastorage.org/webt/xv/09/f1/xv09f1rq3eum5hnsuwdqdgrj97m.png"></p><br><ul><li><p>  <strong>Memori Bersama</strong> adalah tentang memori bersama yang digunakan beberapa utas untuk bertukar data.  Akses ke memori perlu disinkronkan.  Sinkronisasi ini biasanya dilaksanakan oleh beberapa jenis kunci.  Pendekatan ini dianggap komunikasi implisit. </p><br></li><li><p>  <strong>Message Passing</strong> mengatakan bahwa kami akan berinteraksi secara eksplisit, dan untuk ini kami akan menggunakan saluran di mana kami akan mengirim pesan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CSP</a> ( <em>Communicating Sequential Processes</em> ) dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Actor Model</a> didasarkan pada pendekatan ini. </p><br></li></ul><br><p><img src="https://habrastorage.org/webt/wi/ss/jr/wissjrv4uu2-3ng62qsdtjbunbk.png"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rob Pike</a> , yang merupakan bapak pendiri Go, mengatakan bahwa Anda harus meninggalkan pemrograman tingkat rendah menggunakan <strong>Memori Bersama</strong> dan menggunakan pendekatan <strong>Message Passing</strong> .  Pendekatan ini akan membantu Anda menulis kode lebih mudah, lebih efisien dan, yang paling penting, dengan lebih sedikit bug.  Go memilih pendekatan <strong>CSP</strong> .  Pendekatan yang sama sangat memengaruhi perkembangan bahasa seperti Erlang. </p><br><p>  Pertanyaan: Apakah benar bahwa jika kita mengambil Go, semuanya akan baik-baik saja? </p><br><p><img src="https://habrastorage.org/webt/ld/uc/px/lducpx4ezb14rvygaamxzz0_-vy.png"></p><br><p>  Saya menemukan sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penelitian</a> di mana tablet ini ditemukan.  Tablet menunjukkan alasan dan jumlah bug yang terkait dengan kunci.  Kolom pertama menunjukkan produk yang dibawa ke dalam penelitian.  Ini adalah produk paling populer yang ditulis dalam Go.  Kolom Memori Bersama menunjukkan jumlah bug yang muncul karena penggunaan yang tidak benar dari Memori Bersama, dan kolom Passing Pesan, masing-masing, menunjukkan jumlah bug karena Passing Pesan. </p><br><p>  Yang paling penting pada plat ini adalah garis <strong>Total</strong> .  Jika Anda melihatnya, Anda akan melihat bahwa ada lebih banyak bug ketika menggunakan <strong>Passing Pesan</strong> daripada saat menggunakan <strong>Memori Bersama</strong> .  Saya yakin bahwa orang-orang yang menulis Kubernetes, Docker atau etcd adalah pengembang yang cukup berpengalaman, tetapi bahkan <strong>Message Passing</strong> mereka tidak menyelamatkan dari kesalahan, dan tidak ada yang lebih sedikit daripada kesalahan ini daripada dengan Memori Bersama. </p><br><p>  Jadi hanya mengambil Go dan mulai menulis kode bebas kesalahan akan gagal. </p><br><h1 id="concurrency-i-parallelism">  Konkurensi dan paralelisme </h1><br><p>  Ketika kita mulai berbicara tentang pengembangan multi-utas, kita perlu memperkenalkan konsep-konsep seperti <strong>Konkurensi</strong> dan <strong>Paralelisme</strong> .  Di dunia Go, ada ungkapan <em>"Konkurensi bukan Paralelisme</em> . <em>"</em>  Intinya adalah bahwa <strong>Concurrency</strong> adalah tentang desain, yaitu, bagaimana kami merancang program kami.  <strong>Paralelisme</strong> hanyalah cara untuk mengeksekusi kode kita. </p><br><p><img src="https://habrastorage.org/webt/uk/tr/es/uktresizsgqpphu4mkmjlep00fe.png"></p><br><p>  Jika kami memiliki beberapa utas instruksi yang dieksekusi secara bersamaan, maka kami mengeksekusi kode secara paralel.  Paralelisme membutuhkan kompetisi.  Tidak akan mungkin untuk memparalelkan suatu program tanpa desain yang kompetitif, sementara daya saing tidak memerlukan paralelisme, karena suatu program yang dapat berjalan pada banyak inti, pada kenyataannya, dapat berjalan pada satu inti. </p><br><p>  Go adalah bahasa yang membantu kita menulis program kompetitif, membantu kita membangun desain.  Ini memungkinkan Anda untuk berpikir sedikit tentang hal-hal tingkat rendah. </p><br><h1 id="zakon-amdala">  Hukum Amdahl </h1><br><p>  Kami ingin memanfaatkan inti prosesor, kami menulis beberapa kode untuk ini.  Tetapi muncul pertanyaan: peningkatan produktivitas seperti apa yang kita dapatkan dengan peningkatan jumlah core.  Jadi, akselerasi yang bisa kita dapatkan, justru dibatasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">oleh hukum Amdal</a> . </p><br><p><img src="https://habrastorage.org/webt/dz/cc/bu/dzccbu8elu2vaogt54-u_gg4m4w.png"></p><br><p>  Apa itu akselerasi?  Akselerasi adalah waktu ketika suatu program berjalan pada satu prosesor dibagi dengan waktu ketika suatu program berjalan pada prosesor <strong>P.</strong>  Huruf <strong>F</strong> ( <em>Fraksi</em> ) menunjukkan bagian dari program yang harus dieksekusi secara berurutan.  Dan di sini bahkan tidak perlu mempelajari rumusnya, yang terpenting adalah mencatat bahwa akselerasi maksimum yang kita dapatkan dengan peningkatan jumlah core tergantung pada <strong>F.</strong>  Lihatlah grafik untuk memvisualisasikan hubungan ini. </p><br><p><img src="https://habrastorage.org/webt/uw/c7/bn/uwc7bn5ngru2scvqaphzayuvboc.png"></p><br><p>  Bahkan jika kita hanya memiliki 5% dari program yang akan dieksekusi secara berurutan, akselerasi maksimum yang kita dapatkan akan sangat berkurang dengan peningkatan jumlah core.  Anda dapat memperkirakan bagian apa yang meningkatkan <strong>F.</strong> </p><br><p><img src="https://habrastorage.org/webt/4o/pu/a8/4opua82_adysln9-enejf9-m-iu.png"></p><br><h1 id="cpu-bound-vs-io-bound">  CPU Bound vs I / O Bound </h1><br><p>  Tidak selalu masuk akal untuk menggunakan multithreading.  Pertama, Anda perlu melihat jenis beban.  Ada dua jenis beban: <strong>CPU Bound</strong> dan <strong>I / O Bound</strong> .  Perbedaannya adalah bahwa dengan CPU Bound kita dibatasi oleh kinerja prosesor, dan dengan I / O Bound kita dibatasi oleh kecepatan subsistem I / O kita.  Bahkan kecepatan, tetapi waktu menunggu untuk jawaban.  Pergi online - menunggu jawaban, pergi ke disk - lagi menunggu jawaban.  Apa bedanya, berapa inti yang ada, jika sebagian besar waktu kita menunggu jawaban? </p><br><p><img src="https://habrastorage.org/webt/xp/dk/yl/xpdkylyp6etnvk2qlw0txhjktby.png"></p><br><p>  Oleh karena itu, satu inti atau seribu, kami tidak akan mendapatkan peningkatan kinerja di bawah beban I / O Bound.  Tetapi jika kita memiliki CPU Bound load, maka ada peluang untuk mendapatkan akselerasi saat memparalelkan program kita. </p><br><p>  Meskipun ada beberapa situasi ketika CPU Bound memuat, ia sebenarnya merosot menjadi I / O Bound.  Misalnya, jika kita ingin mengambil dan menjumlahkan semua elemen dari array besar, apa yang akan kita lakukan?  Kami akan menulis siklus, semuanya akan berhasil.  Kemudian kita berpikir: “Jadi kita memiliki banyak inti.  Mari kita ambil saja, bagi array menjadi potongan-potongan dan sejajarkan semuanya. "  Apa hasilnya? </p><br><p><img src="https://habrastorage.org/webt/5z/hy/zo/5zhyzoxnnpay_wnc1ypjmwesxeo.png"></p><br><p>  Hasilnya adalah situasi di mana prosesor kami memproses data lebih cepat daripada yang mereka dapat dari memori.  Dalam hal ini, sebagian besar waktu kita akan menunggu data dari memori, dan beban, yang tampaknya CPU Bound, sebenarnya ternyata adalah I / O Bound. </p><br><h1 id="false-sharing">  Berbagi salah </h1><br><p>  Apalagi ada cerita seperti <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">False Sharing</a></strong> .  Berbagi Palsu adalah situasi ketika kernel mulai saling mengganggu.  Ada inti pertama, ada inti kedua, dan masing-masing dari mereka memiliki <strong>L1 Cache</strong> sendiri.  L1 Cache dibagi menjadi beberapa baris ( <em>Cache Line</em> ) sebesar 64 byte.  Ketika kami mendapatkan beberapa data dari memori, kami selalu mendapatkan tidak kurang dari 64 byte.  Dengan mengubah data ini, kami menonaktifkan cache semua inti. </p><br><p><img src="https://habrastorage.org/webt/b4/ug/ne/b4ugnemfq4lkhv22yhxhuxeytdq.png"></p><br><p>  Ternyata jika dua core mengubah data yang sangat dekat satu sama lain ( <em>pada jarak kurang dari 64 byte</em> ), mereka mulai saling mengganggu, cache yang tidak valid.  Dalam hal ini, jika program ditulis berurutan, itu akan bekerja lebih cepat daripada ketika menggunakan beberapa core yang saling mengganggu.  Semakin banyak core, semakin rendah kinerjanya. </p><br><h1 id="schedulers">  Penjadwal </h1><br><p>  Kami akan naik ke tingkat abstraksi berikutnya - ke perencana. </p><br><p>  Ketika pekerjaan dimulai dengan kode kompetitif, penjadwal muncul.  Go memiliki apa yang disebut <strong>penjadwal ruang-pengguna</strong> yang beroperasi pada <strong>goroutine</strong> .  Sistem operasi juga memiliki <strong>penjadwal</strong> sendiri, yang beroperasi dengan <strong>utas sistem operasi</strong> .  Dan bahkan prosesornya tidak begitu sederhana.  Misalnya, prosesor modern memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prediksi cabang</a> dan cara lain untuk merusak gambar indah kita tentang kelurusan linier dunia. </p><br><p><img src="https://habrastorage.org/webt/cf/dc/1k/cfdc1kw8l7axejmswctoqpawlmc.png"></p><br><p>  Penjadwal dibagi berdasarkan jenis multitasking.  Ada <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">multitasking kooperatif</a></strong> dan <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">multitasking preemptive</a></strong> .  Dalam kasus <strong>multitasking kooperatif</strong> , <strong>proses</strong> pelaksanaannya <strong>sendiri memutuskan</strong> kapan perlu mentransfer kontrol ke proses lain, dan dalam kasus <strong>multitasking yang ramai,</strong> ada <strong>komponen eksternal</strong> - penjadwal, yang mengontrol berapa banyak sumber daya yang dialokasikan untuk proses tersebut. </p><br><p><img src="https://habrastorage.org/webt/vo/o_/tx/voo_tx_4vfug0jinekpu5f-o-ha.png"></p><br><p>  Multitasking kooperatif memungkinkan satu proses untuk "memonopoli" seluruh sumber daya CPU.  Dalam multitasking preemptive, ini tidak akan terjadi, karena ada badan pengontrol.  Tetapi dengan multitasking yang kooperatif, alih konteks lebih efisien, karena proses tahu pasti pada titik apa lebih baik untuk memberikan kontrol ke proses lain.  Dalam multitasking preemptive, scheduler dapat menghentikan proses kapan saja - itu tidak terlalu efisien.  Pada saat yang sama, dalam multitasking preemptive, kami dapat menyediakan sumber daya yang sama untuk setiap proses berkat penjadwal eksternal. </p><br><p>  Sistem operasi menggunakan penjadwal berdasarkan multitasking preemptive, karena OS diperlukan untuk menjamin kondisi yang sama untuk setiap pengguna.  Bagaimana dengan Go? </p><br><p><img src="https://habrastorage.org/webt/8d/ry/dd/8drydde54y4ytkr_t2qrcznevvy.png"></p><br><p>  Jika kita membaca dokumentasi, kita mengetahui bahwa scheduler di Go adalah preemptive.  Tetapi, ketika kita mulai mengerti, ternyata Go tidak memiliki scheduler sebagai komponen eksternal.  Di Go, kompiler menetapkan titik switching konteks.  Dan meskipun kita, sebagai pengembang, tidak perlu secara manual beralih konteks, kontrol beralih tidak dibawa ke komponen eksternal.  Berkat ini, Go sangat efektif untuk mengganti satu goroutine ke yang lain.  Tetapi kesalahpahaman tentang fitur-fitur dari pekerjaan seperti "perencana" dapat menyebabkan perilaku yang tidak terduga.  Misalnya, apa yang akan dihasilkan kode ini? </p><br><p><img src="https://habrastorage.org/webt/4p/7i/tm/4p7itmw8_pusfpg5whtkjawfqt4.png"></p><br><p>  Kode seperti itu akan membeku. </p><br><p> Mengapa  Karena pada awalnya, menggunakan <code>GOMAXPROCS</code> , kami memaksa program untuk menggunakan hanya satu inti.  Setelah itu, goroutine dimasukkan ke dalam antrian, di mana siklus yang tidak ada habisnya akan bekerja.  Kemudian kita menunggu 500 ms dan mencetak <code>x</code> .  Setelah waktu. <code>time.Sleep</code> goroutine akan benar-benar mulai, tetapi tidak akan ada jalan keluar dari loop tak terbatas, karena kompiler tidak akan meletakkan titik saklar konteks.  Program membeku. </p><br><p>  Dan jika kita menambahkan <code>runtime.Gosched()</code> di dalam loop, maka semuanya akan baik-baik saja, karena kita akan secara eksplisit menunjukkan bahwa kita ingin beralih konteks. </p><br><p>  Fitur-fitur seperti itu juga perlu diketahui dan diingat. </p><br><p>  Kami berbicara tentang pengalihan konteks, tetapi di mana Go biasanya memasukkan titik pengalih? </p><br><p><img src="https://habrastorage.org/webt/8k/6k/bo/8k6kbop0qpvsimvezerzshdc0qm.png"></p><br><p>  <code>runtime.morestack()</code> dan <code>runtime.newstack()</code> biasanya dimasukkan pada saat fungsi dipanggil.  <code>runtime.Goshed()</code> kami dapat menyediakan sendiri.  Dan tentu saja, pengalihan konteks terjadi selama kunci, kenaikan jaringan, dan panggilan sistem.  Anda dapat melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan ini oleh Kirill Lashkevich tentang topik ini</a> .  Sangat bagus, saya sarankan. </p><br><p>  Mari kita melangkah lebih dekat ke kode.  Kami akan melihat kesalahannya. </p><br><h1 id="race-condition">  Kondisi balapan </h1><br><p>  Salah satu kesalahan paling populer yang kami lakukan adalah <code>Race Condition</code> .  Intinya adalah ketika kita melakukan, misalnya, kenaikan, sebenarnya kita tidak melakukan satu operasi, tetapi beberapa: prosesor membaca data dari memori untuk mendaftar, memperbarui register dan menulis data ke memori. </p><br><p><img src="https://habrastorage.org/webt/jf/ar/zs/jfarzsk1prxonyme8fx7b1yvg1s.png"></p><br><p>  Ketiga operasi ini tidak dilakukan secara atom.  Oleh karena itu, penjadwal kapan saja, pada salah satu dari operasi ini, dapat mengambil dan menghentikan aliran kami.  Ternyata tindakan belum selesai, dan karena ini kami menangkap bug. </p><br><p>  Berikut adalah contoh kode semacam itu ( <em>kenaikan tersebut segera diuraikan menjadi beberapa operasi</em> ). </p><br><p><img src="https://habrastorage.org/webt/jt/kj/c9/jtkjc97ruwb4ejlt7btjhybjh0u.png"></p><br><p>  Penjadwal dapat mendahului utas pertama setelah baris pertama dieksekusi, dan utas kedua setelah memeriksa kondisinya.  Dalam hal ini, kedua aliran akan jatuh ke bagian kritis, dan karena itu "kritis" - kedua aliran tidak dapat dimasukkan di sana secara bersamaan. </p><br><p>  Kita dapat mengunci menggunakan <code>sync.Mutex</code> dari paket <code>sync</code> standar.  Pemblokiran akses memungkinkan kami untuk secara eksplisit menunjukkan bahwa kode harus dijalankan oleh satu utas pada satu waktu.  Dengan kode ini, kita mendapatkan apa yang kita butuhkan. </p><br><p><img src="https://habrastorage.org/webt/5w/hf/2w/5whf2wr5xmhbkhxrnarppopowfe.png"></p><br><p>  Kunci adalah operasi yang cukup mahal.  Oleh karena itu, ada operasi atom pada level prosesor.  Dalam hal ini, kenaikan dapat dibuat atom dengan menggantinya dengan operasi <code>atomic</code> . <code>atomic.AddInt64</code> dari paket <code>atomic</code> . </p><br><p><img src="https://habrastorage.org/webt/-f/1o/rz/-f1orz2g4oar-_b0ef0vk7m4o6y.png"></p><br><p>  Jika kita mulai bekerja dengan instruksi atom, maka kita tidak hanya perlu menulis secara atom, tetapi juga membaca secara atom.  Jika tidak, maka masalah akan muncul. </p><br><h1 id="optimizacii--what-could-possibly-go-wrong">  Optimalisasi - Apa yang Mungkin Salah? </h1><br><p>  Kunci itu bagus, tetapi bisa mahal.  Atom cukup murah untuk tidak khawatir tentang kinerja. </p><br><p>  Jadi kami mengetahui bahwa primitif sinkronisasi memperkenalkan overhead, dan memutuskan untuk menambahkan optimisasi - kami akan memeriksa bendera tanpa memperhatikan multithreading, dan kemudian memeriksa ulang menggunakan primitif sinkronisasi.  Semuanya terlihat baik dan harus bekerja. </p><br><p><img src="https://habrastorage.org/webt/jq/9u/cm/jq9ucmurmj-x9y4i9eu8ojzkfem.png"></p><br><p>  Semuanya baik-baik saja, kecuali bahwa kompiler sedang mencoba untuk mengoptimalkan kode kami.  Apa yang dia lakukan  Dia menukar instruksi tugas, dan kita mendapatkan perilaku yang tidak valid, karena kita <code>done</code> menjadi <code>true</code> sebelum nilai variabel " <code></code> " ditugaskan. </p><br><p>  Jangan mencoba melakukan optimasi seperti itu - karena mereka Anda akan mendapatkan banyak masalah.  Saya menyarankan Anda untuk membaca spesifikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The Go Memory Model</a> dan sebuah artikel oleh Dmitry Vyukova ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@dvyukov</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Benign Data Races: Apa yang Mungkin Salah?</a>  untuk lebih memahami masalahnya. </p><br><p>  Jika Anda benar-benar mengandalkan kinerja pada kunci - tulis kode bebas kunci, tetapi Anda tidak perlu melakukan akses yang tidak disinkronkan ke memori. </p><br><h1 id="deadlock">  Jalan buntu </h1><br><p>  Masalah selanjutnya yang akan kita hadapi adalah Deadlock.  Tampaknya semuanya cukup sepele di sini.  Ada dua sumber daya, misalnya, dua <code>Mutex</code> .  Di utas pertama, pertama-tama kita menangkap <code>Mutex</code> pertama, dan di utas kedua pertama-tama kita menangkap <code>Mutex</code> kedua.  Selanjutnya kami ingin mengambil <code>Mutex</code> kedua di utas pertama, tetapi kami tidak akan dapat melakukan ini, karena sudah diblokir.  Di utas kedua, kami akan mencoba untuk mengambil, masing-masing, <code>Mutex</code> pertama dan juga blok.  Itu dia, Deadlock. </p><br><p><img src="https://habrastorage.org/webt/pe/vk/y1/pevky1zcbkqtftopczdgbg2_xuu.png"></p><br><p>  Tidak satu pun dari kedua utas ini yang dapat maju lebih jauh, karena keduanya akan menunggu sumber daya.  Bagaimana ini diselesaikan?  Kami bertukar kunci, dan kemudian tidak ada masalah yang muncul.  Tentu saja, itu mudah untuk dikatakan, tetapi mempertahankan aturan ini sepanjang umur produk tidak mudah.  Jika memungkinkan, lakukan - <strong>ambil dan berikan kunci dalam urutan yang sama</strong> . </p><br><p>  Tampaknya pengembang yang berpengalaman tidak menemukan kesalahan seperti itu, tetapi di sini adalah contoh jalan buntu dari kode proyek, dll. </p><br><p><img src="https://habrastorage.org/webt/iq/8l/pe/iq8lpexqj2xc_ykt2qzzgbxxiwu.png"></p><br><p>  Di sini tangkapan utamanya adalah bahwa menulis ke saluran yang tidak disadap menghalangi, untuk menulis, Anda memerlukan pembaca di sisi lain.  Mengambil mutex, utas pertama menunggu pembaca muncul.  Utas kedua tidak lagi dapat menangkap mutex.  Jalan buntu </p><br><p>  Saya menyarankan Anda untuk mencoba game yang menarik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The Deadlock Empire</a> .  Dalam permainan ini, Anda bertindak sebagai penjadwal yang harus mengalihkan konteks untuk mencegah kode dieksekusi dengan benar. </p><br><h1 id="sort-of-problems">  Semacam masalah </h1><br><p>  Masalah apa yang masih ada?  Kami mulai dengan <strong>Ketentuan Ras</strong> .  Selanjutnya kita melihat <strong>Deadlock</strong> (masih ada varian <strong>Livelock</strong> , inilah saatnya kita tidak dapat menangkap sumber daya, tetapi tidak ada kunci eksplisit).  Ada <strong>Kelaparan</strong> , inilah saatnya kita pergi ke printer untuk mencetak selembar kertas, dan ada antrian, dan kita tidak dapat mengakses sumber daya.  Kami melihat perilaku program dengan <strong>False Sharing</strong> .  Masih ada masalah - <strong>Lock Contention</strong> , ketika kinerja menurun karena banyak kompetisi untuk sumber daya (misalnya, satu mutex yang dibutuhkan sejumlah besar utas). </p><br><p><img src="https://habrastorage.org/webt/yo/5x/dz/yo5xdzb1iqwunpsqjitejygw_ji.png"></p><br><h1 id="race-detection">  Deteksi ras </h1><br><p>  Go sangat kuat dengan kotak peralatan yang disediakan di luar kotak.  <strong>Race Detector</strong> adalah salah satu alat tersebut.  Menggunakannya sederhana: kita menulis tes atau menjalankannya pada muatan tempur dan menangkap kesalahan. <br>  Anda dapat membaca lebih lanjut tentang menggunakan Pendeteksi Ras <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam dokumentasi</a> , tetapi ingat bahwa ia memiliki keterbatasan.  Mari kita membahasnya lebih detail. </p><br><p><img src="https://habrastorage.org/webt/sq/ft/kq/sqftkq68nj93cffxblalpvqss9s.png"></p><br><p>  Pertama, kode yang tidak dieksekusi tidak diperiksa oleh Race Detector.  Karena itu, cakupan tes harus tinggi.  Selain itu, Detektor Balap mengingat riwayat panggilan ke setiap kata dalam memori, tetapi riwayat panggilan ini memiliki kedalaman.  Di Go, misalnya, kedalaman ini adalah empat - empat elemen, empat akses.  Jika Detektor Balap tidak menangkap perlombaan dalam kedalaman ini, ia percaya tidak ada balapan.  Oleh karena itu, meskipun Race Detector tidak pernah salah, ia tidak akan menangkap semua kesalahan.  Anda dapat berharap untuk Race Detector, tetapi Anda harus mengingat keterbatasannya.  Secara terpisah, Anda dapat membaca tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma kerja</a> . </p><br><h1 id="block-profile">  Blokir profil </h1><br><p>  <strong>Profil blok</strong> adalah alat lain yang memungkinkan kita menemukan dan memperbaiki masalah pemblokiran. </p><br><p><img src="https://habrastorage.org/webt/hg/ex/ft/hgexftmdroak4fgg0udjq4s4vow.png"></p><br><p>  Ini dapat digunakan baik pada level tes benchmark, dan dapat ditonton selama pertempuran.  Karena itu, jika Anda mencari masalah yang terkait dengan sinkronisasi akses data, coba mulai dengan Race Detector dan terus menggunakan Block Profile. </p><br><h1 id="primer-programmy">  Contoh program </h1><br><p>  Mari kita lihat kode asli yang bisa kita temukan.  Kami akan menulis fungsi yang hanya mengambil array permintaan dan mencoba mengeksekusinya: setiap permintaan secara berurutan.  Jika salah satu permintaan mengembalikan kesalahan, fungsi menghentikan eksekusi. </p><br><p><img src="https://habrastorage.org/webt/r_/kl/3w/r_kl3wjbfxfsfa5dvbs34afvtww.png"></p><br><p>  Jika kita menulis di Go, kita harus menggunakan kekuatan penuh dari bahasa tersebut.  Kami mencoba.  Kami mendapatkan kode tiga kali lebih banyak. </p><br><p><img src="https://habrastorage.org/webt/nc/qt/_q/ncqt_qwhoahbahx9tdmuspt1_1c.png"></p><br><p>  Pertanyaan: apakah ada kesalahan dalam kode? </p><br><p>  Tentu saja!  Mari kita lihat yang mana. </p><br><p>  Dalam loop kami menjalankan goroutine.  Untuk orkestrasi goroutine, kami menggunakan <code>sync.WaitGroup</code> .  Tapi apa yang kita lakukan salah?  Sudah di dalam goroutine yang berjalan, kami memanggil <code>wg.Add(1)</code> , mis. Kami menambahkan satu lagi goroutine untuk menunggu.  Dan menggunakan <code>wg.Wait()</code> , kami menunggu semua goroutine selesai.  Tetapi mungkin terjadi pada saat <code>wg.Wait()</code> dipanggil, tidak ada satu pun goroutine yang akan mulai.  Dalam hal ini, <code>wg.Wait()</code> mempertimbangkan bahwa semuanya sudah selesai, kami akan menutup saluran dan keluar dari fungsi tanpa kesalahan, percaya bahwa semuanya baik-baik saja. </p><br><p><img src="https://habrastorage.org/webt/o1/wv/7m/o1wv7mielcch1r4k3zmdgfksbk4.png"></p><br><p>  Apa yang akan terjadi selanjutnya?  Kemudian goroutine akan mulai, kode akan dieksekusi, dan mungkin salah satu permintaan akan mengembalikan kesalahan.  Kesalahan ditulis ke saluran tertutup, dan menulis ke saluran tertutup adalah panik.  Aplikasi kita akan macet.  Tidak mungkin ini yang ingin saya dapatkan, jadi kami memperbaikinya dengan menunjukkan sebelumnya berapa banyak goroutine yang akan kami luncurkan. </p><br><p><img src="https://habrastorage.org/webt/ly/re/v6/lyrev61roq8cswx4q0itv12reyy.png"></p><br><p>  Mungkin masih ada beberapa masalah? </p><br><p>  Ada kesalahan terkait dengan bagaimana objek <code>req</code> muncul di dalam fungsi.  Variabel <code>req</code> bertindak sebagai iterator siklus, dan kami tidak tahu nilai apa yang akan dimilikinya pada saat peluncuran goroutine. </p><br><p><img src="https://habrastorage.org/webt/wi/xc/m2/wixcm2d3adxkmbqobaoapwm4ofq.png"></p><br><p>  Dalam praktiknya, dalam kode ini, nilai <code>req</code> kemungkinan besar akan sama dengan elemen terakhir dari array.  Karena itu, Anda hanya mengirim permintaan yang sama sebanyak N kali.  Perbaiki: secara eksplisit mengirimkan permintaan kami sebagai argumen ke fungsi. </p><br><p><img src="https://habrastorage.org/webt/3g/gq/ty/3ggqtyg5-pgxmfhfkwruozrajyg.png"></p><br><p>  Mari kita lihat lebih dekat bagaimana kita menangani kesalahan.  Kami mendeklarasikan saluran buffered pada satu slot.  Ketika kesalahan terjadi, kami mengirimkannya ke saluran ini.  Semuanya tampak baik-baik saja: terjadi kesalahan - kami mengembalikan kesalahan ini dari suatu fungsi. </p><br><p><img src="https://habrastorage.org/webt/3_/5-/ku/3_5-kufkknuxpfmc1tpsqn_aqr4.png"></p><br><p>  Tetapi bagaimana jika semua permintaan kembali dengan kesalahan? </p><br><p>  Kemudian menulis ke saluran hanya akan mendapatkan kesalahan pertama, sisanya akan memblokir eksekusi goroutine.  Karena tidak akan ada lagi pembacaan dari saluran pada saat keluar dari fungsi baca, kami mengalami kebocoran goroutine.  Yaitu, semua gorutin yang tidak bisa menulis kesalahan ke saluran hanya bertahan di memori. </p><br><p>  Kami memperbaikinya dengan sangat sederhana: kami memilih di saluran slot jumlah permintaan.  Ini menyelesaikan masalah kita yang tidak terlalu hemat memori, karena jika kita memiliki satu miliar permintaan, kita perlu mengalokasikan satu miliar slot. </p><br><p><img src="https://habrastorage.org/webt/qe/nm/te/qenmteeutwuvzmmlu_lqjrnrhgy.png"></p><br><p>  Kami memecahkan masalah.  Kode sekarang kompetitif.  Tetapi masalahnya adalah dengan keterbacaan - dibandingkan dengan versi kode sinkron, ada banyak.  Dan ini tidak keren, karena pengembangan program kompetitif sudah sulit, mengapa kita menyulitkannya dengan banyak kode? </p><br><p><img src="https://habrastorage.org/webt/ww/jx/v3/wwjxv3vhcewmqajtzlsrgqrsbli.png"></p><br><h1 id="errgroup">  Errgroup </h1><br><p>  Saya menyarankan untuk meningkatkan keterbacaan kode. </p><br><p>  Saya suka menggunakan paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">errgroup</a> alih-alih <code>sync.WaitGroup</code> .  Paket ini tidak memerlukan menentukan berapa banyak goroutine yang diharapkan, dan memungkinkan Anda untuk mengabaikan kumpulan kesalahan.  Beginilah fungsi kami akan terlihat saat menggunakan <code>errgroup</code> : </p><br><p><img src="https://habrastorage.org/webt/p4/da/no/p4danooucpgyforvks7qd4eqmmi.png"></p><br><p>  Selain itu, <code>errgroup</code> memungkinkan <code>errgroup</code> untuk dengan mudah mengatur komponen program kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konteks</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Konteks</a> .  Apa yang saya maksud </p><br><p>  Misalkan kita memiliki beberapa komponen program kita, jika setidaknya salah satu dari mereka gagal, kita ingin menyelesaikan yang lain dengan hati-hati.  Jadi <code>errgroup</code> ketika kesalahan <code>errgroup</code> , menyelesaikan <code>context</code> dan, dengan demikian, semua komponen menerima pemberitahuan tentang perlunya menyelesaikan pekerjaan. </p><br><p><img src="https://habrastorage.org/webt/5l/gb/95/5lgb95elqafmsoakuaktm1_nn2u.png"></p><br><p>  Ini dapat digunakan untuk membangun program multikomponen kompleks yang berperilaku dapat diprediksi. </p><br><h1 id="vyvody">  Kesimpulan </h1><br><p>  Buat sesederhana mungkin.  Lebih baik secara sinkron.  Pengembangan program multithreaded umumnya merupakan proses yang kompleks, yang mengarah pada munculnya bug yang tidak menyenangkan. </p><br><p><img src="https://habrastorage.org/webt/by/bl/nz/byblnzeor9pzwpraobylgc5yfme.png"></p><br><p>  Jangan gunakan sinkronisasi implisit.  Jika Anda benar-benar beristirahat di dalamnya, pikirkan tentang cara menyingkirkan kunci, cara membuat algoritma bebas kunci. </p><br><p>  Go adalah bahasa yang baik untuk menulis program yang bekerja secara efektif dengan sejumlah besar inti, tetapi tidak lebih baik dari semua bahasa lain, dan kesalahan akan selalu muncul.  Oleh karena itu, walaupun dipersenjatai dengan Go, cobalah untuk memahami beberapa tingkat abstraksi yang lebih rendah dari apa yang Anda bekerja. </p><br><p><img src="https://habrastorage.org/webt/ze/i7/rd/zei7rd4-t5-oxw-imkx2is7qlrc.png"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466495/">https://habr.com/ru/post/id466495/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466479/index.html">Menggunakan PVS-Studio ketika memeriksa proyek-proyek Unreal Engine pada sistem operasi Windows</a></li>
<li><a href="../id466485/index.html">Mobil listrik dari tahun 90an. Bagian 1. Brothers Citroen dan Peugeot</a></li>
<li><a href="../id466489/index.html">Insinyur Korea menyarankan menggunakan Hololens sebagai alternatif untuk partisi kantor</a></li>
<li><a href="../id466491/index.html">Proyek Pelatihan di Godot - Pong (Bagian 2) Membuat dan Menyiapkan Bola</a></li>
<li><a href="../id466493/index.html">Docker: Untuk memulai. Perhatian Sebarkan</a></li>
<li><a href="../id466497/index.html">Lingkungan modern untuk aplikasi Bereaksi Asli</a></li>
<li><a href="../id466499/index.html">C / C ++ dari Python (ctypes)</a></li>
<li><a href="../id466501/index.html">Tindakan Github dan pembangunan lintas platform</a></li>
<li><a href="../id466503/index.html">Slurm DevOps. Hari kedua IaC, pengujian infrastruktur dan “Slurm menginspirasi!”</a></li>
<li><a href="../id466505/index.html">YIMP - Control Panel untuk Yii 2 di Bootstrap 4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>