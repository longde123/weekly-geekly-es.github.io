<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>▶️ ☪️ 👼🏻 Dominando Vuex - De cero a héroe 🍔 👨🏽 👩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Les presento la traducción del artículo "Dominando Vuex - Zero to Hero" por Sanath Kumar. 


 La documentación oficial de Vuex lo define co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dominando Vuex - De cero a héroe</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421551/"><p>  Hola Habr!  Les presento la traducción del artículo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Dominando Vuex - Zero to Hero"</a> por Sanath Kumar. </p><br><p>  La documentación oficial de Vuex lo define como un <b>patrón de gestión de estado</b> + biblioteca para aplicaciones Vue.js.  <i>¿Pero qué significa eso?</i>  <i>¿Qué es un patrón de gestión estatal?</i> </p><br><p>  Imagine que está trabajando en una gran aplicación web con cientos de rutas y componentes.  ¿No sería más fácil si pudiéramos almacenar todos los datos que necesitaríamos en una aplicación en un almacenamiento centralizado? </p><br><img src="https://habrastorage.org/webt/dm/rc/t5/dmrct5ro7paby7tugthhzagynxw.jpeg"><a name="habracut"></a><br><p> Cada componente o ruta dentro de nuestra aplicación solicitará datos del estado de Vuex y transferirá los datos modificados nuevamente al estado. </p><br><p>  En esencia, el estado de Vuex puede verse como la única fuente de verdad para toda la aplicación. </p><br><p>  Los datos se almacenan dentro del estado como un objeto JSON.  Por ejemplo: </p><br><pre><code class="plaintext hljs">state: { name: "John Doe", age: "28" }</code> </pre> <br><p>  Pero, ¿cómo pueden nuestros componentes y rutas acceder a los datos almacenados en nuestro estado?  Para hacer esto, necesitamos definir captadores dentro de nuestro repositorio Vuex que devolverán los datos del repositorio a nuestros componentes.  Veamos cómo se ve un <b>getter</b> simple, que obtiene el nombre de nuestro repositorio: </p><br><pre> <code class="plaintext hljs">getters: { NAME: state =&gt; { return state.name; }, }</code> </pre> <br><p>  Observe que el nombre del captador está en mayúsculas.  Esto es solo una recomendación de estilo de código.  No es necesario seguirlo si no te gusta. </p><br><p>  Ahora que hemos definido un captador para el nombre, es increíblemente fácil obtener el valor del nombre dentro de nuestro componente.  El siguiente código le permite hacer esto. </p><br><pre> <code class="plaintext hljs">let name = this.$store.getters.NAME;</code> </pre> <br><p>  Descubrimos cómo <b>obtener</b> datos del almacenamiento.  Ahora veamos cómo podemos <b>establecer los</b> datos en el repositorio.  Definiremos setters, ¿verdad?  Además, los setters de Vuex se nombran un poco diferente.  Definimos una <b>mutación</b> para establecer datos en nuestro estado Vuex. </p><br><pre> <code class="plaintext hljs">mutations: { SET_NAME: (state, payload) =&gt; { state.name = payload; }, }</code> </pre> <br><p>  ¿Qué más es la carga útil?  <b>La carga útil</b> son los datos transmitidos a nuestra mutación desde el componente que hace la mutación.  ¿Cómo podemos hacer esto?  Muy simple: </p><br><pre> <code class="plaintext hljs">this.$store.commit('SET_NAME', your_name);</code> </pre> <br><p>  Este código cambiará el estado de la aplicación y establecerá cualquier valor asignado a <i>your_name</i> para la propiedad de nombre dentro de nuestro repositorio. </p><br><p>  MUTACIONES SINCRONICAS </p><br><p>  Imagine que tenemos una lista de nombres almacenados en una base de datos en un servidor remoto.  El servidor nos proporciona un punto final que devuelve una serie de nombres que se pueden usar en nuestro Vue.js.  Por supuesto, podemos usar <b>Axios</b> para consultar el punto final y obtener los datos. </p><br><pre> <code class="plaintext hljs">let {data} = await Axios.get('https://myapiendpoint.com/api/names');</code> </pre> <br><p>  Después de eso, podemos pasar la matriz devuelta a nuestro estado Vuex de la tienda usando una mutación.  Fácil, verdad?  Pero en realidad no.  Las mutaciones son síncronas, y no podemos ejecutar operaciones asíncronas, como llamadas de API, dentro de una mutación. </p><br><p>  ¿Qué debemos hacer entonces?  Crea <b>acciones</b> . </p><br><p>  Las acciones son como mutaciones, pero en lugar de cambiar directamente el estado, hacen una mutación.  ¿Suena confuso?  Veamos el anuncio de la acción. </p><br><pre> <code class="plaintext hljs">actions: { SET_NAME: (context, payload) { context.commit('SET_NAME', payload); }, }</code> </pre> <br><p>  Definimos una acción llamada SET_NAME que toma el contexto y la <i>carga útil</i> como parámetros.  La acción confirma la mutación SET_NAME, creada anteriormente, con los datos que se le pasan, es decir, <b>su_nombre</b> . </p><br><p>  Ahora, en lugar de invocar la mutación directamente, nuestros componentes activan la acción SET_NAME con un nuevo nombre como datos de la siguiente manera: </p><br><pre> <code class="plaintext hljs">this.$store.dispatch('SET_NAME', your_name);</code> </pre> <br><p>  Luego, la acción inicia la mutación con los datos que se le pasan, es decir, <i>su_nombre</i> . </p><br><br><h2>  Pero por que? </h2><br><p>  Quizás se pregunte por qué se requiere una declaración de acción si simplemente podemos iniciar mutaciones con un nuevo valor directamente desde nuestros componentes.  Como se mencionó anteriormente, las mutaciones son sincrónicas, pero no acciones. </p><br><p>  En el ejemplo anterior, el caso se considera cuando necesita actualizar el valor del nombre, pero no solo en su estado, sino también en la base de datos que se ejecuta en el servidor remoto.  Estoy seguro de que así es como pretende utilizar Vuex en un proyecto real en el 99% de los casos.  Eche un vistazo al siguiente fragmento de código: </p><br><pre> <code class="plaintext hljs">mutations: { SET_NAME: (state, name) =&gt; { state.name = name; }, }, actions: { SET_NAME: async (context, name) =&gt; { let {data} = await Axios.post('http://myapiendpoint.com/api/name', {name: name}); if (data.status == 200) { context.commit('SET_NAME', name); } }, }</code> </pre> <br><p>  El código en sí se explica por sí mismo.  Usamos Axios para enviar el nombre al punto final.  Si la solicitud POST se realizó correctamente y el valor del nombre del campo se modificó correctamente en el servidor, iniciamos la mutación SET_ NAME para actualizar el valor del nombre dentro de nuestro estado. </p><br><p>  TOMA PRÁCTICA NUNCA INICIES MUTACIONES DIRECTAMENTE.  PARA ESTE SIEMPRE USE ACCIONES. </p><br><br><h2>  Configurar el almacenamiento de Vuex en Vue.JS </h2><br><p>  Profundicemos más y descubramos cómo podemos implementar Vuex en una aplicación real. </p><br><h3>  Paso 1. Instala Vuex </h3><br><pre> <code class="plaintext hljs">npm install --save vuex</code> </pre> <br><h3>  Paso 2. Crear un repositorio de Vuex </h3><br><ol><li>  Cree el directorio de la <b>tienda</b> en la raíz de nuestra aplicación. </li><li>  Cree el archivo <b>index.js</b> en este directorio y use el siguiente código para crear un nuevo repositorio. </li></ol><br><pre> <code class="plaintext hljs">import Vue from 'vue'; import Vuex from 'vuex'; Vue.use(Vuex); export const store = new Vuex.Store({ state: {}, getters: {}, mutations: {}, actions: {}, });</code> </pre> <br><h3>  Paso 3. Agregar almacenamiento Vuex a la aplicación Vue.JS </h3><br><p>  1. Importe el <b>repositorio</b> al archivo main.js: </p><br><pre> <code class="plaintext hljs">import {store} from './store';</code> </pre> <br><p>  2. Agregue <b>almacenamiento</b> a la instancia de Vue, como se muestra a continuación: </p><br><pre> <code class="plaintext hljs">new Vue({ el: '#app', store, router, render: h =&gt; h(App), });</code> </pre> <br><p>  Ahora podemos agregar variables de estado, captadores, mutaciones y acciones a nuestro repositorio Vuex. </p><br><br><h2>  Ejemplo </h2><br><p>  Eche un vistazo al repositorio de Vuex de una aplicación de lista de tareas simple.  "¡No solo otra lista de tareas pendientes!".  ¿Eh?  No te preocupes  Al final de este artículo, aprenderá cómo usar todo el poder y el poder de Vuex. </p><br><pre> <code class="plaintext hljs">import Vue from 'vue'; import Vuex from 'vuex'; import Axios from 'axios'; Vue.use(Vuex); export const store = new Vuex.Store({ state: { todos: null, }, getters: { TODOS: state =&gt; { return state.todos; }, }, mutations: { SET_TODO: (state, payload) =&gt; { state.todos = payload; }, ADD_TODO: (state, payload) =&gt; { state.todos.push(payload); }, }, actions: { GET_TODO: async (context, payload) =&gt; { let {data} = await Axios.get('http://yourwebsite.com/api/todo'); context.commit('SET_TODO', data); }, SAVE_TODO: async (context, payload) =&gt; { let {data} = await Axios.post('http://yourwebsite.com/api/todo'); context.commit('ADD_TODO', payload); }, }, });</code> </pre> <br><br><h2>  Agregar un nuevo elemento a la lista de tareas </h2><br><p>  Dentro de su componente, inicie la acción SAVE_TODO pasándole un nuevo elemento de tarea pendiente, como se muestra en el fragmento de código a continuación. </p><br><pre> <code class="plaintext hljs">let item = 'Get groceries'; this.$store.dispatch('SAVE_TODO', item);</code> </pre> <br><p>  La acción <b>SAVE_TODO</b> realiza una solicitud POST al punto final y luego inicia la <b>mutación ADD_TODO</b> , que agrega un elemento de <b>tarea</b> pendiente a la variable de estado <b>todos</b> . </p><br><br><h2>  Obtención de tareas pendientes </h2><br><p>  Dentro del bloque <b>montado ()</b> de su componente, inicie la segunda acción <b>GET_TODO</b> , que recibe todos los elementos de tareas desde el punto final y los almacena en la variable de estado <i>todos</i> , iniciando la mutación SET_TODO: </p><br><pre> <code class="plaintext hljs">mounted() { this.$store.dispatch('GET_TODO'); }</code> </pre> <br><br><h2>  Acceda a tareas pendientes dentro de un componente </h2><br><p>  Para acceder al elemento <i>todos</i> dentro de un componente, cree una propiedad calculada: </p><br><pre> <code class="plaintext hljs">computed: { todoList() { return this.$store.getters.TODOS; }, }</code> </pre> <br><p>  Dentro del componente, puede acceder a la propiedad calculada: </p><br><pre> <code class="plaintext hljs">&lt;div class="todo-item" v-for="item in todoList"&gt;&lt;/div&gt;</code> </pre> <br><br><h2>  Usando el método mapGetters </h2><br><p>  Hay una manera aún más fácil de acceder a las tareas pendientes dentro de un componente utilizando el método <b>mapGetters</b> proporcionado por Vuex. </p><br><pre> <code class="plaintext hljs">import {mapGetters} from 'vuex'; computed : { ...mapGetters(['TODOS']), //    }</code> </pre> <br><p>  Es posible que ya haya adivinado que el código dentro de la plantilla debe cambiarse, como se muestra en el fragmento a continuación. </p><br><pre> <code class="plaintext hljs">&lt;div class="todo-item" v-for="item in TODOS"&gt;&lt;/div&gt;</code> </pre> <br><p>  Observe cómo usamos el operador de distribución ES6 [...] dentro de nuestras propiedades calculadas. </p><br><p>  ALMACENAMIENTO DE VUEX NO ES SOLO LA FUENTE DEL ESTADO ACTUAL DE SU APLICACIÓN.  TAMBIÉN ES EL ÚNICO PUNTO QUE DEBE CAMBIAR ESTE ESTADO. </p><br><p>  Esto requiere una pequeña explicación.  Ya hemos aprendido cómo crear acciones para <b>recibir</b> e <b>instalar</b> elementos de <b>tareas</b> en nuestro repositorio.  ¿Qué sucede si necesitamos actualizar un elemento y marcarlo?  ¿Dónde ejecutamos el código para esto? </p><br><p>  En Internet puede encontrar diferentes opiniones sobre este asunto.  La documentación también carece de una guía clara al respecto. </p><br><p>  Recomendaría almacenar todas las llamadas API dentro de las acciones en su repositorio Vuex.  Por lo tanto, cada cambio de estado ocurre solo dentro del repositorio, lo que facilita la depuración y simplifica la comprensión del código, y también facilita la edición del código. </p><br><br><h2>  Organización del código </h2><br><p>  Guardar todas las variables de estado, captadores, acciones y mutaciones en un archivo rápidamente lo hará engorroso tan pronto como comience a trabajar con aplicaciones grandes.  Veamos cómo puede organizar el almacenamiento en varios archivos como módulos. </p><br><p>  Cree un nuevo directorio dentro de su repositorio y asígnele el nombre <i>módulos</i> .  Agregue el archivo <i>todos.js</i> al directorio creado que contiene el siguiente código: </p><br><pre> <code class="plaintext hljs">const state = {}; const getters = {}; const mutations = {}; const actions = {}; export default { state, getters, mutations, actions, };</code> </pre> <br><p>  Ahora podemos mover las variables de estado, captadores, mutaciones y acciones del archivo <b>index.js al</b> archivo <b>todos.js</b> .  Recuerde importar <b>Axios</b> .  Todo lo que necesitamos hacer es informarle a Vuex que creamos el módulo de almacenamiento y dónde encontrarlo.  El archivo <i>index.js</i> actualizado debería verse así: </p><br><pre> <code class="plaintext hljs">import Vue from 'vue'; import Vuex from 'vuex'; import Axios from 'axios'; import todos from './modules/todos'; Vue.use(Vuex); export const store = new Vuex.Store({ state: {}, getters: {}, mutations: {}, actions: {}, modules: { todos, }, });</code> </pre> <br><p>  El archivo <b>todos.js</b> se verá así: </p><br><pre> <code class="plaintext hljs">import Axios from 'axios'; state = { todos: null, }; getters = { TODOS: state =&gt; { return state.todos; }, }; mutations = { SET_TODO: (state, payload) =&gt; { state.todos = payload; }, ADD_TODO: (state, payload) =&gt; { state.todos.push(payload); }, }; actions = { GET_TODO: async (context, payload) =&gt; { let {data} = await Axios.get('http://yourwebsite.com/api/todo'); context.commit('SET_TODO', data); }, SAVE_TODO: async (context, payload) =&gt; { let {data} = await Axios.post('http://yourwebsite.com/api/todo'); context.commit('ADD_TODO', payload); }, }; export default { state, getters, mutations, actions, };</code> </pre> <br><br><h2>  Resumen </h2><br><ol><li>  El estado de la aplicación se almacena como un objeto JSON grande. </li><li>  <b>Los captadores</b> se utilizan para acceder a los valores almacenados en la tienda. </li><li>  <b>Las mutaciones</b> actualizan su condición.  Debe recordarse que las mutaciones son sincrónicas. </li><li>  Todas las operaciones asincrónicas deben realizarse dentro de las <b>acciones</b> .  Las acciones cambian de estado, iniciando mutaciones. </li><li>  Establezca una regla para iniciar <b>mutaciones</b> exclusivamente a través de la <b>acción</b> . </li><li>  <b>Los módulos</b> se pueden usar para organizar su almacenamiento en varios archivos pequeños. </li></ol><br><p>  Vuex hace que trabajar con Vue sea mucho más fácil y divertido.  Si es un principiante, puede haber situaciones en las que le resulte difícil decidir si usar Vuex en ciertas áreas de su aplicación.  Sigue tu instinto.  Alcanzarás alta velocidad bastante rápido. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es421551/">https://habr.com/ru/post/es421551/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es421537/index.html">Funciones de orden superior en JS: Young Fighter Course</a></li>
<li><a href="../es421543/index.html">Clonar una tarjeta sin contacto usando una aplicación móvil</a></li>
<li><a href="../es421545/index.html">Revisión de PocketBook 616: la billetera 2018 más económica con función de retroiluminación</a></li>
<li><a href="../es421547/index.html">Aceptación del centro de datos independiente</a></li>
<li><a href="../es421549/index.html">Estamos escribiendo documentación técnica: una guía para el profano</a></li>
<li><a href="../es421553/index.html">Compartimos contenido tecnológico: hemos reunido todos nuestros materiales en un solo sitio</a></li>
<li><a href="../es421555/index.html">Proyecto WideNES: vaya más allá de los límites de la pantalla NES</a></li>
<li><a href="../es421557/index.html">Lección abierta "Programación asincrónica en Java"</a></li>
<li><a href="../es421559/index.html">Arquitectura de IU de componentes en la aplicación iOS</a></li>
<li><a href="../es421563/index.html">Es posible que deba sentarse de manera diferente para deshacerse del dolor de espalda.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>