<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤠 🍵 🎚️ [DotNetBook] الاستثناءات: اكتب بنية النظام ❄️ 🙈 🧜🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="مع هذه المقالة ، أواصل نشر سلسلة من المقالات ، ستكون نتائجه كتابًا عن عمل .NET CLR و .NET بشكل عام. للروابط - مرحبا بك في القط. 
 هندسة الاستثناء 


 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>[DotNetBook] الاستثناءات: اكتب بنية النظام</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/419927/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl"><img width="350" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png" align="left">  مع هذه المقالة ، أواصل نشر سلسلة من المقالات ، ستكون نتائجه كتابًا عن عمل .NET CLR و .NET بشكل عام.  للروابط - مرحبا بك في القط. </p><br><h2 id="arhitektura-isklyuchitelnoy-situacii" style=";text-align:right;direction:rtl">  هندسة الاستثناء </h2><br><p style=";text-align:right;direction:rtl"> ربما تكون واحدة من أهم القضايا المتعلقة بموضوع الاستثناءات هي مسألة بناء بنية استثناء في تطبيقك.  هذا السؤال مثير للاهتمام لأسباب عديدة.  أما بالنسبة لي ، فالشيء الرئيسي هو البساطة الواضحة التي ليس من الواضح دائمًا ما يجب فعله.  هذه الخاصية متأصلة في جميع الإنشاءات الأساسية التي يتم استخدامها في كل مكان: فهي قابلة <code>IObservable</code> و <code>IDisposable</code> و <code>IObservable</code> وغيرها.  من ناحية ، يتم استدعاءهم من خلال بساطتهم ، وإشراك أنفسهم في استخدام أنفسهم في مجموعة متنوعة من المواقف.  ومن ناحية أخرى ، فهي مليئة بالدوامات والمعابد ، والتي من خلالها لا تعرف كيف لا تخرج في بعض الأحيان على الإطلاق.  وربما بالنظر إلى المجلد المستقبلي ، فقد نضج سؤالك: فما هو في المواقف الاستثنائية؟ </p><br><blockquote style=";text-align:right;direction:rtl"><h3 style=";text-align:right;direction:rtl">  ملاحظة </h3><br>  لم يتم تحديث الفصل المنشور على حبري ، وربما يكون قديمًا بالفعل.  وبالتالي ، يرجى الرجوع إلى النص الأصلي للحصول على نص أحدث: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  كتاب CLR: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">جيثب ، جدول المحتويات</a> </li><li style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR كتاب: <a href="">جيثب ، الفصل</a> </li><li style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/eo/6g/eo/eo6geog0tg5ernqmv2lcmufefta.png">  الإصدار 0.5.2 كتب ، PDF: <a href="">إصدار GitHub</a> </li></ul><br></blockquote><p style=";text-align:right;direction:rtl"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p><a name="habracut"></a><br><p style=";text-align:right;direction:rtl">  ولكن من أجل التوصل إلى بعض الاستنتاجات المتعلقة ببناء بنية فئات استثنائية ، يجب أن نجمع بعض الخبرة معك فيما يتعلق بتصنيفها.  بعد كل شيء ، بعد أن فهمت ما سنتعامل معه ، وكيف وفي أي المواقف يجب على المبرمج اختيار نوع الخطأ ، وفي أي اختيار - اختيار المصيد أو تخطي الاستثناءات ، يمكنك فهم كيف يمكنك بناء نظام نوع بطريقة تجعله واضحًا للمستخدم كود.  لذلك ، سنحاول تصنيف المواقف الاستثنائية (ليس أنواع الاستثناءات نفسها ، ولكن المواقف بدقة) وفقًا لمعايير مختلفة. </p><br><h3 id="po-teoreticheskoy-vozmozhnosti-perehvata-proektiruemogo-isklyucheniya" style=";text-align:right;direction:rtl">  حسب الإمكانية النظرية للقبض على الاستثناء المتوقع </h3><br><p style=";text-align:right;direction:rtl">  من حيث الاعتراض النظري ، يمكن بسهولة تقسيم الاستثناءات إلى نوعين: تلك التي سيتم اعتراضها بدقة وتلك التي من المرجح أن يتم اعتراضها.  لماذا <em>بدرجة عالية من الاحتمال</em> ؟  لأنه سيكون هناك دائمًا شخص سيحاول الاعتراض ، على الرغم من أنه لم يكن من الضروري القيام بذلك بالكامل. </p><br><p style=";text-align:right;direction:rtl">  دعونا نكشف أولاً عن ميزات المجموعة الأولى: الاستثناءات التي يجب أن تكتسب. </p><br><p style=";text-align:right;direction:rtl">  عندما نقدم استثناءً من هذا النوع ، فإننا من ناحية نبلغ النظام الفرعي الخارجي بأننا في وضع لا تكون فيه الإجراءات الأخرى داخل بياناتنا منطقية.  من ناحية أخرى ، نعني أنه لم يتم كسر أي شيء عالمي وإذا تم إزالتنا ، فلن يتغير شيء ، وبالتالي يمكن اعتراض هذا الاستثناء بسهولة لتحسين الوضع.  هذه الخاصية مهمة جدًا: فهي تحدد مدى خطورة الخطأ والاعتقاد بأنه إذا التقطت الاستثناء وقمت فقط بمسح الموارد ، يمكنك تنفيذ التعليمات البرمجية بأمان أكثر. </p><br><p style=";text-align:right;direction:rtl">  المجموعة الثانية ، بغض النظر عن مدى غرابة الأمر ، مسؤولة عن الاستثناءات التي لا تحتاج إلى القبض عليها.  يمكن استخدامها فقط للكتابة في سجل الأخطاء ، ولكن ليس من أجل تصحيح الوضع بطريقة أو بأخرى.  المثال الأبسط هو استثناءات مجموعة <code>ArgumentException</code> و <code>NullReferenceException</code> .  في الواقع ، في الوضع العادي ، لا يجب ، على سبيل المثال ، التقاط استثناء <code>ArgumentNullException</code> لأن مصدر المشكلة هنا سيكون أنت ، وليس أي شخص آخر.  إذا حصلت على هذا الاستثناء ، فإنك تفترض أنك ارتكبت خطأ وأعطت الطريقة التي لا يمكنك منحها لـ: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">void SomeMethod(object argument) { try { AnotherMethod(argument); } catch (ArgumentNullException exception) { // Log it } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  في هذه الطريقة ، نحاول التقاط <code>ArgumentNullException</code> .  لكن في اعتقادي ، يبدو اعتراضها غريبًا جدًا: إن إلقاء الحجج الصحيحة على الطريقة هو قلقنا تمامًا.  لن يكون من الصحيح الاستجابة بعد الحقيقة: في مثل هذه الحالة ، فإن الشيء الأكثر صحة الذي يمكن القيام به هو التحقق من البيانات المرسلة مقدمًا ، قبل استدعاء الطريقة ، أو حتى أفضل ، لإنشاء الرمز بطريقة لا يمكن فيها ببساطة تلقي معلمات غير صحيحة. </p><br><p style=";text-align:right;direction:rtl">  مجموعة أخرى هي القضاء على الأخطاء الفادحة.  إذا تم كسر ذاكرة تخزين مؤقت معينة ولن يكون تشغيل النظام الفرعي صحيحًا على أي حال؟  ثم هذا خطأ فادح ولن يتم ضمان كود الأقرب إلى المكدس لاعتراضه: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">T GetFromCacheOrCalculate() { try { if(_cache.TryGetValue(Key, out var result)) { return result; } else { T res = Strategy(Key); _cache[Key] = res; return res; } } catch (CacheCorreptedException exception) { RecreateCache(); return GetFromCacheOrCalculate(); } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  ودع <code>CacheCorreptedException</code> يكون استثناء بمعنى "ذاكرة التخزين المؤقت على القرص الصلب ليست متسقة."  ثم اتضح أنه إذا كان سبب هذا الخطأ فادحًا للنظام الفرعي للتخزين المؤقت (على سبيل المثال ، لا توجد أذونات لملف ذاكرة التخزين المؤقت) ، فإن الرمز الإضافي إذا لم يتمكن من إعادة إنشاء ذاكرة التخزين المؤقت باستخدام الأمر <code>RecreateCache</code> ، وبالتالي فإن حقيقة التقاط هذا الاستثناء خطأ في حد ذاته. </p><br><h3 id="po-fakticheskomu-perehvatu-isklyuchitelnoy-situacii" style=";text-align:right;direction:rtl">  على الاعتراض الفعلي للاستثناء </h3><br><p style=";text-align:right;direction:rtl">  السؤال الآخر الذي يوقف رحلة تفكيرنا في خوارزميات البرمجة هو الفهم: هل يستحق الأمر اكتشاف هذه الاستثناءات أو غيرها أم أنه يستحق شخصًا يفهمها للسماح لهم من خلالها.  من خلال ترجمة لغة المصطلحات ، فإن السؤال الذي نحتاج إلى حله هو التمييز بين مجالات المسؤولية.  دعونا نلقي نظرة على الكود التالي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">namespace JetFinance.Strategies { public class WildStrategy : StrategyBase { private Random random = new Random(); public void PlayRussianRoulette() { if(DateTime.Now.Second == (random.Next() % 60)) { throw new StrategyException(); } } } public class StrategyException : Exception { /* .. */ } } namespace JetFinance.Investments { public class WildInvestment { WildStrategy _strategy; public WildInvestment(WildStrategy strategy) { _strategy = strategy; } public void DoSomethingWild() { ?try? { _strategy.PlayRussianRoulette(); } catch(StrategyException exception) { } } } } using JetFinance.Strategies; using JetFinance.Investments; void Main() { var foo = new WildStrategy(); var boo = new WildInvestment(foo); ?try? { boo.DoSomethingWild(); } catch(StrategyException exception) { } }</code> </pre><br><p style=";text-align:right;direction:rtl">  أي من الإستراتيجيتين المقترحتين هي الأصح؟  مجال المسؤولية مهم جدا.  في البداية ، قد يبدو أنه نظرًا لأن عمل <code>WildInvestment</code> واتساقها يعتمد كليًا على <code>WildStrategy</code> ، إذا تجاهلت <code>WildInvestment</code> هذا الاستثناء ببساطة ، <code>WildInvestment</code> إلى مستوى أعلى وليس هناك حاجة للقيام بأي شيء آخر.  ومع ذلك ، يرجى ملاحظة أن هناك مشكلة معمارية بحتة: الطريقة <code>Main</code> تستحوذ على استثناء من طبقة واحدة هندسياً من خلال استدعاء طريقة مختلفة هندسياً.  كيف يبدو من حيث الاستخدام؟  نعم ، بشكل عام ، يبدو كما يلي: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  لقد فاقنا الاهتمام بهذا الاستثناء ببساطة ؛ </li><li style=";text-align:right;direction:rtl">  مستخدم هذه الفئة غير متأكد من طرح هذا الاستثناء من خلال عدد من الأساليب المعروضة علينا تحديدًا </li><li style=";text-align:right;direction:rtl">  نبدأ في رسم الإدمان غير الضروري ، الذي تخلصنا منه ، مما تسبب في طبقة متوسطة. </li></ul><br><p style=";text-align:right;direction:rtl">  ومع ذلك ، هناك استنتاج آخر يتبع من هذا الاستنتاج: يجب علينا ضبط <code>catch</code> في طريقة <code>DoSomethingWild</code> .  وهذا غريب إلى حد ما بالنسبة لنا: يبدو أن <code>WildInvestment</code> تعتمد بشكل كبير على شخص ما.  على سبيل المثال  إذا لم يتمكن <code>PlayRussianRoulette</code> العمل ، فإن <code>DoSomethingWild</code> أيضًا: ليس لديه رموز إرجاع ، ولكن يجب أن يلعب الروليت.  ماذا تفعل في مثل هذا الوضع الذي يبدو ميؤوس منه؟  الجواب بسيط في الواقع: كونه في طبقة أخرى ، يجب أن يقوم <code>DoSomethingWild</code> باستثناء خاص به ، والذي يشير إلى هذه الطبقة ويلف الأصل كمصدر أصلي للمشكلة - في <code>InnerException</code> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">namespace JetFinance.Strategies { pubilc class WildStrategy { private Random random = new Random(); public void PlayRussianRoulette() { if(DateTime.Now.Second == (random.Next() % 60)) { throw new StrategyException(); } } } public class StrategyException : Exception { /* .. */ } } namespace JetFinance.Investments { public class WildInvestment { WildStrategy _strategy; public WildInvestment(WildStrategy strategy) { _strategy = strategy; } public void DoSomethingWild() { try { _strategy.PlayRussianRoulette(); } catch(StrategyException exception) { throw new FailedInvestmentException("Oops", exception); } } } public class InvestmentException : Exception { /* .. */ } public class FailedInvestmentException : Exception { /* .. */ } } using JetFinance.Investments; void Main() { var foo = new WildStrategy(); var boo = new WildInvestment(foo); try { boo.DoSomethingWild(); } catch(FailedInvestmentException exception) { } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  عند تحويل الاستثناء إلى طبقة أخرى ، فإننا ننقل المشكلات بشكل أساسي من طبقة تطبيق إلى أخرى ، مما يجعل عملها أكثر قابلية للتنبؤ به من وجهة نظر مستخدم هذه الفئة: الطريقة <code>Main</code> . </p><br><h3 id="po-voprosam-pereispolzovaniya" style=";text-align:right;direction:rtl">  لقضايا إعادة الاستخدام </h3><br><p style=";text-align:right;direction:rtl">  في كثير من الأحيان نواجه مهمة صعبة: من ناحية ، نحن كسالى للغاية لإنشاء نوع جديد من الاستثناءات ، وعندما نقرر ، ليس من الواضح دائمًا ما يجب الدفع منه: أي نوع يجب أن نأخذه كأساس.  لكن هذه القرارات بالتحديد هي التي تحدد البنية الكاملة للمواقف الاستثنائية.  لنستعرض الحلول الشائعة ونستخلص بعض الاستنتاجات. </p><br><p style=";text-align:right;direction:rtl">  عند اختيار نوع الاستثناءات ، يمكنك محاولة اتخاذ حل موجود بالفعل: ابحث عن استثناء له معنى مشابه في الاسم واستخدمه.  على سبيل المثال ، إذا تم منحنا كيانًا من خلال معلمة لا <code>InvalidArgumentException</code> بطريقة أو بأخرى ، فيمكننا طرح <code>InvalidArgumentException</code> ، مما يشير إلى سبب الخطأ في الرسالة.  يبدو هذا السيناريو جيدًا ، خاصة بالنظر إلى أن <code>InvalidArgumentException</code> موجود في مجموعة الاستثناءات التي لا تخضع للصيد الإلزامي.  ولكن اختيار <code>InvalidDataException</code> سيكون سيئًا إذا كنت تعمل مع أي بيانات.  فقط لأن هذا النوع موجود في منطقة <code>System.IO</code> ، وهذا بالكاد ما تفعله.  على سبيل المثال  اتضح أن العثور على النوع الحالي لأن القيام بعملك الكسول سيكون دائمًا النهج الخاطئ.  لا توجد استثناءات تقريبًا تم إنشاؤها للدائرة العامة للمهام.  تم إنشاء كل منهم تقريبًا لحالات محددة وستكون إعادة استخدامها انتهاكًا صارخًا لبنية حالات استثنائية.  ليس ذلك فحسب ، بعد تلقي استثناء من نوع معين (على سبيل المثال ، نفس <code>System.IO.InvalidDataException</code> ) ، سيتم الخلط بين المستخدم: من ناحية ، سيرى مصدر المشكلة في <code>System.IO</code> اسم استثناء ، ومن ناحية أخرى ، مساحة اسم نقطة رمي مختلفة تمامًا.  بالإضافة إلى ذلك ، عند التفكير في قواعد طرح هذا الاستثناء ، ستنتقل إلى <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">sourcesource.microsoft.com</a> وستجد <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">جميع الأماكن التي يتم طرحها فيها</a> : </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> <code>internal class System.IO.Compression.Inflater</code> </li> </ul><br><p style=";text-align:right;direction:rtl">  وسوف يفهم ذلك <del>  مجرد شخص لديه أيدي ملتوية </del>  إن اختيار نوع الاستثناء يربكه ، لأن الطريقة التي طرحت الاستثناء لم تكن متضمنة في الضغط. </p><br><p style=";text-align:right;direction:rtl">  أيضًا ، من أجل تبسيط إعادة الاستخدام ، يمكنك ببساطة إنشاء وإنشاء استثناء واحد عن طريق الإعلان عن حقل <code>ErrorCode</code> مع رمز خطأ والعيش بسعادة بعد ذلك.  يبدو: حل جيد.  قم برمي الاستثناء نفسه في كل مكان ، وقم بتعيين الشفرة ، والتقط صيدًا واحدًا فقط <code>catch</code> وبالتالي زيادة استقرار التطبيق: وليس هناك المزيد للقيام به.  ومع ذلك ، يرجى عدم الموافقة على هذا الموقف.  التصرف بهذه الطريقة طوال التطبيق ، من ناحية ، بالطبع ، تبسط حياتك.  ولكن من ناحية أخرى ، تتجاهل القدرة على الإمساك بمجموعة فرعية من الاستثناءات ، توحدها بعض الميزات المشتركة.  كيف يتم ذلك ، على سبيل المثال ، مع <code>ArgumentException</code> ، الذي يجمع في حد ذاته مجموعة كاملة من الاستثناءات عن طريق الميراث.  النقص الثاني الخطير هو أوراق كبيرة جدًا وغير قابلة للقراءة من التعليمات البرمجية التي ستنظم التصفية حسب رمز الخطأ.  ولكن إذا كنت تأخذ موقفًا مختلفًا: عندما لا يكون إنهاء الخطأ مهمًا للمستخدم النهائي ، فإن إدخال نوع معمم بالإضافة إلى رمز خطأ يبدو بالفعل تطبيقًا أكثر صحة: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">public class ParserException : Exception { public ParserError ErrorCode { get; } public ParserException(ParserError errorCode) { ErrorCode = errorCode; } public override string Message { get { return Resources.GetResource($"{nameof(ParserException)}{Enum.GetName(typeof(ParserError), ErrorCode)}"); } } } public enum ParserError { MissingModifier, MissingBracket, // ... } // Usage throw new ParserException(ParserError.MissingModifier);</code> </pre> <br><p style=";text-align:right;direction:rtl">  غالبًا ما تكون الشفرة التي تحمي استدعاء المحلل غير مبالية لسبب حظر التحليل: حقيقة الخطأ نفسها مهمة لها.  ومع ذلك ، إذا أصبح هذا مهمًا ، فسيكون المستخدم دائمًا قادرًا على استخراج رمز الخطأ من <code>ErrorCode</code> .  للقيام بذلك ، ليس من الضروري على الإطلاق البحث عن الكلمات الضرورية عن طريق السلاسل الفرعية في <code>Message</code> . </p><br><p style=";text-align:right;direction:rtl">  إذا بدأت في تجاهل مشكلات إعادة الاستخدام ، يمكنك إنشاء نوع استثناء لكل موقف.  من ناحية ، يبدو منطقيًا: نوع واحد من الخطأ هو نوع واحد من الاستثناء.  ومع ذلك ، هنا ، كما هو الحال في كل شيء ، الشيء الرئيسي هو عدم المبالغة في ذلك: وجود عمليات استثنائية في كل نقطة إصدار ، تتسبب في مشاكل للاعتراض: سيتم تحميل رمز طريقة الاستدعاء بشكل زائد مع كتل <code>catch</code> .  بعد كل شيء ، يحتاج إلى التعامل مع جميع أنواع الاستثناءات التي تريد منحها له.  ناقص آخر هو معماري بحت.  إذا كنت لا تستخدم الميراث ، فأنت تربك مستخدم هذه الاستثناءات: يمكن أن يكون هناك الكثير من الأشياء المشتركة بينهما ، ويجب عليك اعتراضها بشكل فردي. </p><br><p style=";text-align:right;direction:rtl">  ومع ذلك ، هناك سيناريوهات جيدة لإدخال أنواع معينة لمواقف محددة.  على سبيل المثال ، عندما يحدث انهيار ليس للكيان بأكمله ككل ، ولكن لطريقة معينة.  ثم يجب أن يكون هذا النوع في التسلسل الهرمي للميراث في مثل هذا المكان بحيث لا يفكر في اعتراضه مع شيء آخر: على سبيل المثال ، تحديده من خلال فرع وراثة منفصل. </p><br><p style=";text-align:right;direction:rtl">  بالإضافة إلى ذلك ، إذا قمت بدمج هذين النهجين ، يمكنك الحصول على صندوق أدوات قوي جدًا للعمل مع مجموعة من الأخطاء: يمكنك تقديم نوع مجرد معمم ترث منه مواقف معينة معينة.  يجب أن تكون الفئة الأساسية (نوع التعميم الخاص بنا) مجهزة بخاصية مجردة تخزن رمز الخطأ ، وسوف يتجاوز الورثة هذه الخاصية لتحديد رمز الخطأ هذا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">public abstract class ParserException : Exception { public abstract ParserError ErrorCode { get; } public override string Message { get { return Resources.GetResource($"{nameof(ParserException)}{Enum.GetName(typeof(ParserError), ErrorCode)}"); } } } public enum ParserError { MissingModifier, MissingBracket } public class MissingModifierParserException : ParserException { public override ParserError ErrorCode { get; } =&gt; ParserError.MissingModifier; } public class MissingBracketParserException : ParserException { public override ParserError ErrorCode { get; } =&gt; ParserError.MissingBracket; } // Usage throw new MissingModifierParserException(ParserError.MissingModifier);</code> </pre> <br><p style=";text-align:right;direction:rtl">  ما هي الخصائص الرائعة التي نحصل عليها مع هذا النهج؟ </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  من ناحية ، احتفظنا بصيد الاستثناء من النوع الأساسي ؛ </li><li style=";text-align:right;direction:rtl">  من ناحية أخرى ، من خلال التقاط استثناء من النوع الأساسي ، كان لا يزال من الممكن معرفة حالة معينة ؛ </li><li style=";text-align:right;direction:rtl">  بالإضافة إلى كل شيء ، من الممكن اعتراض نوع معين ، وليس لنوع أساسي ، دون استخدام البنية المسطحة للفئات. </li></ul><br><p style=";text-align:right;direction:rtl">  بالنسبة لي ، هذا خيار مناسب للغاية. </p><br><h3 id="po-otnosheniyu-k-edinoy-gruppe-povedencheskih-situaciy" style=";text-align:right;direction:rtl">  فيما يتعلق بمجموعة واحدة من المواقف السلوكية </h3><br><p style=";text-align:right;direction:rtl">  ما هي الاستنتاجات التي يمكن استخلاصها بناءً على المنطق الموصوف سابقًا؟  دعونا نحاول صياغتها: </p><br><p style=";text-align:right;direction:rtl">  لنبدأ ، لنقرر ما تعنيه المواقف.  عندما نتحدث عن الطبقات والكائنات ، فإننا معتادون في المقام الأول على الكيانات العاملة مع بعض الحالة الداخلية التي يمكننا تنفيذ الإجراءات عليها.  اتضح أنه من خلال القيام بذلك ، وجدنا النوع الأول من الموقف السلوكي: الإجراءات على كيان معين.  علاوة على ذلك ، إذا نظرت إلى الرسم البياني للكائنات كما لو كان من الخارج ، فستلاحظ أنه تم دمجها منطقياً في مجموعات وظيفية: أولها يتعامل مع التخزين المؤقت ، والثاني يتعامل مع قواعد البيانات ، والثالث يقوم بحسابات رياضية.  يمكن أن تمر الطبقات بجميع هذه المجموعات الوظيفية: طبقة تسجيل من حالات داخلية مختلفة ، تسجيل العملية ، تتبع استدعاءات الطريقة.  يمكن أن تكون الطبقات أكثر شمولاً: الجمع بين عدة مجموعات وظيفية.  على سبيل المثال ، طبقة نموذج ، طبقة تحكم ، طبقة عرض.  يمكن أن تكون هذه المجموعات في نفس التجمع ، أو في مجموعات مختلفة تمامًا ، ولكن يمكن لكل منها إنشاء مواقف استثنائية خاصة بها. </p><br><p style=";text-align:right;direction:rtl">  اتضح أنه إذا جادلت بهذه الطريقة ، يمكنك بناء بعض التسلسل الهرمي لأنواع المواقف الاستثنائية ، بناءً على النوع الذي ينتمي إلى مجموعة أو طبقة معينة ، وبالتالي إنشاء القدرة على التقاط الاستثناءات من التعليمات البرمجية للتنقل الدلالي السهل في هذا النوع من التسلسل الهرمي. </p><br><p style=";text-align:right;direction:rtl">  دعونا نلقي نظرة على الرمز: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">namespace JetFinance { namespace FinancialPipe { namespace Services { namespace XmlParserService { } namespace JsonCompilerService { } namespace TransactionalPostman { } } } namespace Accounting { /* ... */ } }</code> </pre><br><p style=";text-align:right;direction:rtl">  كيف تبدو؟  بالنسبة لي ، تعد مساحات الأسماء فرصة رائعة لتجميع أنواع الاستثناءات طبقًا لمواقفهم السلوكية: يجب أن يكون كل شيء ينتمي إلى مجموعات معينة موجودًا ، بما في ذلك الاستثناءات.  علاوة على ذلك ، عندما تتلقى استثناءً معينًا ، بالإضافة إلى اسم نوعه ، سترى مساحة الاسم الخاصة به ، والتي ستحدد بوضوح انتمائها.  هل تتذكر مثال إعادة الاستخدام السيئ لنوع <code>InvalidDataException</code> الذي تم تعريفه بالفعل في مساحة الاسم <code>System.IO</code> ؟  ويعني انتمائه إلى مساحة الاسم هذه أنه في جوهره يمكن استبعاد استثناء من هذا النوع من الفئات الموجودة في مساحة الاسم <code>System.IO</code> أو في واحدة أكثر تداخلًا.  لكن الاستثناء نفسه تم طرده من مكان مختلف تمامًا ، مما أربك الباحث بالمشكلة التي نشأت.  من خلال تركيز أنواع الاستثناءات على نفس مساحات الأسماء مثل الأنواع التي تطرح هذه الاستثناءات ، فإنك تحافظ على بنية النوع متسقة من ناحية ، ومن ناحية أخرى ، تجعل من السهل على المطور النهائي فهم أسباب ما حدث. </p><br><p style=";text-align:right;direction:rtl">  ما هي الطريقة الثانية للتجميع على مستوى الرمز؟  الميراث: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">public abstract class LoggerExceptionBase : Exception { protected LoggerExceptionBase(..); } public class IOLoggerException : LoggerExceptionBase { internal IOLoggerException(..); } public class ConfigLoggerException : LoggerExceptionBase { internal ConfigLoggerException(..); }</code> </pre><br><p style=";text-align:right;direction:rtl">  علاوة على ذلك ، إذا كان الميراث في حالة كيانات التطبيق العادية ، يعني ميراث السلوك والبيانات ، والجمع بين الأنواع من خلال الانتماء إلى <em>مجموعة واحدة من الكيانات</em> ، فعندئذ في حالة الاستثناءات ، يعني الميراث الانتماء إلى <em>مجموعة واحدة من المواقف</em> ، حيث أن جوهر الاستثناء ليس الجوهر ، ولكن إشكالي. </p><br><p style=";text-align:right;direction:rtl">  من خلال الجمع بين طريقتين للتجميع ، يمكننا استخلاص بعض الاستنتاجات: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  داخل التجميع (التجميع) يجب أن يقدم النوع الأساسي من الاستثناءات التي يطرحها هذا التجميع.  يجب أن يكون هذا النوع من الاستثناء في مساحة اسم الجذر للتجميع.  ستكون هذه الطبقة الأولى من التجميع ؛ </li><li style=";text-align:right;direction:rtl">  داخل التجميع نفسه ، قد يكون هناك واحد أو أكثر من مساحات الأسماء المختلفة.  يقسم كل منهم التجميع إلى بعض المناطق الوظيفية ، وبالتالي تحديد مجموعات المواقف التي تنشأ في هذا التجميع.  يمكن أن تكون هذه مناطق وحدات التحكم وكيانات قاعدة البيانات وخوارزميات معالجة البيانات وغيرها.  بالنسبة لنا ، فإن مساحات الأسماء هذه هي مجموعة من الأنواع حسب الانتماء الوظيفي ، ومن وجهة نظر الاستثناءات ، فهي تجمع حسب مناطق المشاكل في نفس التجميع ؛ </li><li style=";text-align:right;direction:rtl">  يمكن أن ينتقل وراثة الاستثناءات فقط من الأنواع الموجودة في نفس مساحة الاسم أو في الجذر الأكثر.  وهذا يضمن فهمًا لا لبس فيه للوضع من قبل المستخدم النهائي وغياب اعتراض الاستثناءات <em>اليسرى</em> عند اعتراضها وفقًا للنوع الأساسي. :     <code>global::Finiki.Logistics.OhMyException</code> ,  <code>catch(global::Legacy.LoggerExeption exception)</code> ,      : </li></ul><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">namespace JetFinance.FinancialPipe { namespace Services.XmlParserService { public class XmlParserServiceException : FinancialPipeExceptionBase { // .. } public class Parser { public void Parse(string input) { // .. } } } public abstract class FinancialPipeExceptionBase : Exception { } } using JetFinance.FinancialPipe; using JetFinance.FinancialPipe.Services.XmlParserService; var parser = new Parser(); try { parser.Parse(); } catch (XmlParserServiceException exception) { // Something wrong in parser } catch (FinancialPipeExceptionBase exception) { // Something else wrong. Looks critical because we don't know real reason }</code> </pre><br><p style=";text-align:right;direction:rtl"> ,   :        , ,   ,       <code>XmlParserServiceException</code> . ,   ,      ,  <code>JetFinance.FinancialPipe.FinancialPipeExceptionBase</code> ,       :    <code>XmlParserService</code>    ,       .          ,               <code>catch</code>      :          . </p><br><p style=";text-align:right;direction:rtl">     ? </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">        .     .     —      ,       : , -, UI.  على سبيل المثال     ; </li><li style=";text-align:right;direction:rtl">        ,   :      ,      <code>catch</code> ; </li><li style=";text-align:right;direction:rtl">       –      .        ; </li><li style=";text-align:right;direction:rtl">             ,       .      :       ,         , ,  . ,   -    :        ,   —  ,  , ,        ; </li><li style=";text-align:right;direction:rtl">         </li><li style=";text-align:right;direction:rtl">       ,      :     ; </li><li style=";text-align:right;direction:rtl">           ,  Mixed Mode c ErrorCode. </li></ul><br><h3 id="po-istochniku-oshibki" style=";text-align:right;direction:rtl">    </h3><br><p style=";text-align:right;direction:rtl">             . ,     ,     : </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  unsafe ,    .      :         ,      (,   )     ; </li><li style=";text-align:right;direction:rtl">     ,   ,      , ..       .        ,             ,     .  ,       ,       .            —        —  <code>InnerExcepton</code> .            —          ; </li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الكود الخاص بنا الذي تم إدخاله عشوائيًا في حالة غير متناسقة. </font><font style="vertical-align: inherit;">تحليل النص هو مثال جيد. </font><font style="vertical-align: inherit;">لا توجد تبعيات خارجية ، ولا يوجد انسحاب </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، ولكن هناك خطأ في التحليل.</font></font></li></ul><br><blockquote style=";text-align:right;direction:rtl"><h3 style=";text-align:right;direction:rtl">  رابط للكتاب كله </h3><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  كتاب CLR: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">جيثب</a> </li><li style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/eo/6g/eo/eo6geog0tg5ernqmv2lcmufefta.png">  الإصدار 0.5.0 كتب ، PDF: <a href="">إصدار GitHub</a> </li></ul><br></blockquote><p style=";text-align:right;direction:rtl"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar419927/">https://habr.com/ru/post/ar419927/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar419917/index.html">الشبكات العصبية: تنفيذ مهمة الفطر على Tensor Flow و Python</a></li>
<li><a href="../ar419919/index.html">التحكم في الإصدار داخل SQL Server</a></li>
<li><a href="../ar419921/index.html">كيفية إسقاط 10 مليون علبة في الثانية</a></li>
<li><a href="../ar419923/index.html">عملي المؤقت ، ساعات اللوحة الأم</a></li>
<li><a href="../ar419925/index.html">التحكم في إصدار الملفات الفردية باستخدام GitHub Gist</a></li>
<li><a href="../ar419929/index.html">[DotNetBook] أحداث الاستثناء وكيفية الحصول على StackOverflow و ExecutionEngineException من البداية</a></li>
<li><a href="../ar419931/index.html">[DotNetBook] حان الوقت للترفيه عن القصص: حالات استثنائية استثنائية</a></li>
<li><a href="../ar419933/index.html">كيفية إجراء عمليات بحث المستخدم على Github باستخدام Angular</a></li>
<li><a href="../ar419935/index.html">مرة واحدة بالضبط ليست هي نفسها: تحليل المقالة</a></li>
<li><a href="../ar419939/index.html">كيف جعلت الملاحة في React Native ليست رهيبة جدًا</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>