<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌼 🍼 🔑 Kubernetes 1.17: aperçu des principales innovations 🌺 🦇 👲🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hier 9 décembre, la prochaine version de Kubernetes - 1.17. Selon la tradition de notre blog, nous parlons des changements les plus importants dans la...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernetes 1.17: aperçu des principales innovations</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/476998/">  Hier 9 décembre, <a href="https://kubernetes.io/blog/2019/12/09/kubernetes-1-17-release-announcement/">la</a> prochaine version de Kubernetes - 1.17.  Selon la tradition de notre blog, nous parlons des changements les plus importants dans la nouvelle version. <br><br><img src="https://habrastorage.org/webt/ua/2c/m4/ua2cm4hxjp5lqj0krsgrjyra5tk.png"><br><br>  Les informations utilisées pour préparer ce matériel sont tirées de l'annonce officielle, <a href="https://docs.google.com/spreadsheets/d/1ebKGsYB1TmMnkx86bR2ZDOibm5KWWCs_UjV3Ys71WIs/edit">du tableau de suivi des améliorations de Kubernetes</a> , de <a href="">CHANGELOG-1.17</a> et des problèmes connexes, des demandes d'extraction, ainsi que des propositions d'amélioration de Kubernetes (KEP).  Alors quoi de neuf? .. <a name="habracut"></a><br><br><h2>  Routage basé sur la topologie </h2><br>  Depuis longtemps, la communauté Kubernetes attend cette fonctionnalité - le <b>routage de service prenant en charge la topologie</b> .  Si <a href="">KEP est</a> basé sur celui-ci en octobre 2018 et que l' <a href="https://github.com/kubernetes/enhancements/issues/536">amélioration</a> officielle date d'il y a 2 ans, les problèmes habituels <i>(comme <a href="https://github.com/kubernetes/kubernetes/issues/7433">celui-ci</a> )</i> sont même plus anciens de quelques années ... <br><br>  L'idée générale se résume à fournir la possibilité de mettre en œuvre un routage «local» pour les services situés dans Kubernetes.  «Localité» dans ce cas signifie «le même niveau topologique» <i>(niveau topologique)</i> , qui peut être: <br><br><ul><li>  même noeud pour les services, </li><li>  même rack de serveur </li><li>  la même région </li><li>  le même fournisseur de cloud </li><li>  ... </li></ul><br>  Exemples d'utilisation d'une telle fonctionnalité: <br><br><ul><li>  économie sur le trafic dans les installations cloud avec de nombreuses zones de disponibilité (multi-AZ) - voir la <a href="https://www.lastweekinaws.com/blog/aws-cross-az-data-transfer-costs-more-than-aws-says/">dernière illustration</a> sur l'exemple du trafic d'une région, mais différents AZ dans AWS; </li><li>  moins de latence dans les performances / meilleur débit; </li><li>  un service fragmenté qui a des informations de nœud local dans chaque fragment; </li><li>  placer fluentd (ou analogues) sur un nœud avec des applications dont les journaux sont collectés; </li><li>  ... </li></ul><br>  Ce routage, "connaissant" la topologie, est également appelé affinité de l'affinité du réseau - similaire à l' <a href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/">affinité du nœud</a> , l' <a href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/">affinité / l'anti-affinité du pod</a> ou la <a href="">planification de volume</a> (et l' <a href="https://kubernetes.io/blog/2018/10/11/topology-aware-volume-provisioning-in-kubernetes/">approvisionnement de volume</a> ) <a href="https://habr.com/ru/company/flant/blog/353114/">récemment prise en compte de la</a> <a href="">topologie</a> .  Le niveau d'implémentation actuel de <code>ServiceTopology</code> dans Kubernetes est la version alpha. <br><br>  Pour plus de détails sur la façon dont la fonctionnalité est organisée et comment elle peut déjà être utilisée, lisez <a href="https://imroc.io/posts/kubernetes/service-topology-en/">cet article</a> de l'un des auteurs. <br><br><h2>  Prise en charge double pile IPv4 / IPv6 </h2><br>  Des progrès significatifs ont été <a href="https://github.com/kubernetes/enhancements/issues/563">enregistrés</a> dans une autre fonctionnalité du réseau: la prise en charge simultanée de deux piles IP, qui a été introduite pour la première fois dans <a href="https://habr.com/ru/company/flant/blog/467477/">K8s 1.16</a> .  En particulier, la nouvelle version a apporté les modifications suivantes: <br><br><ul><li>  kube-proxy <a href="https://github.com/kubernetes/kubernetes/pull/79576">implémente la</a> possibilité d'un fonctionnement simultané dans les deux modes (IPv4 et IPv6); </li><li>  la prise en charge de l'API descendante est <a href="https://github.com/kubernetes/kubernetes/pull/83123">apparue</a> dans <code>Pod.Status.PodIPs</code> (en même temps, <code>/etc/hosts</code> nécessite désormais l'ajout d'une adresse IPv6 pour l'hôte) </li><li>  prise en charge de deux piles dans <a href="https://github.com/kubernetes-sigs/kind/pull/692">KIND</a> (Kubernetes IN Docker) et <a href="https://github.com/kubernetes/kubeadm/issues/1612">kubeadm</a> ; </li><li>  Tests e2e mis à jour. </li></ul><br><img src="https://habrastorage.org/webt/oc/cn/ua/occnua2w-r5kotwelaorckvyvr0.png"><br>  <i>KIND IPV4 / IPv6 Double pile Illustration</i> <br><br><h2>  Progrès du CSI </h2><br>  La <a href="https://github.com/kubernetes/enhancements/issues/557"><b>prise en charge de la topologie</b></a> pour les référentiels basés sur CSI, introduite pour la première fois dans <a href="https://habr.com/ru/company/flant/blog/424331/">K8s 1.12, a été déclarée stable</a> . <br><br>  Initiative <a href="https://github.com/kubernetes/enhancements/issues/625">CSI Migration</a> <b>Volume Plugins</b> - <a href="https://github.com/kubernetes/enhancements/issues/625">Migration CSI</a> - Bêta atteinte.  Cette fonctionnalité est essentielle pour transférer les plugins existants <i>dans l'arborescence</i> vers une interface moderne <i>(CSI, hors arborescence)</i> inaperçue par les utilisateurs finaux de Kubernetes.  Il suffira que les administrateurs de cluster activent la migration CSI, après quoi les ressources et charges de travail avec état existantes «fonctionneront toujours» ... mais en utilisant les pilotes CSI actuels au lieu de ceux obsolètes inclus dans le noyau Kubernetes. <br><br>  Pour le moment, le statut de migration des pilotes AWS EBS ( <code>kubernetes.io/aws-ebs</code> ) et GCE PD ( <code>kubernetes.io/gce-pd</code> ) est prêt en statut bêta.  Les prévisions pour les autres référentiels sont les suivantes: <br><br><img src="https://habrastorage.org/webt/es/qt/eq/esqteq_1gkc3skwaiuzjmule_zo.png"><br><br>  Comment le support de stockage «traditionnel» dans les K8 est venu à CSI, nous en avons parlé dans <a href="https://habr.com/ru/company/flant/blog/465417/">cet article</a> .  Une transition vers la migration de CSI en version bêta est consacrée à une <a href="https://kubernetes.io/blog/2019/12/09/kubernetes-1-17-feature-csi-migration-beta/">publication distincte</a> sur le blog du projet. <br><br>  De plus, le statut de la version bêta (c'est-à-dire l'inclusion par défaut) dans la version Kubernetes 1.17 a été atteint par une autre fonctionnalité importante dans le contexte de CSI, originaire de (implémentation alpha) dans K8s 1.12 - <b><a href="https://github.com/kubernetes/enhancements/issues/177">créer des instantanés</a> et les restaurer à partir d'eux</b> .  Parmi les modifications apportées à Kubernetes Volume Snapshot sur le chemin de la version bêta: <br><br><ul><li>  diviser le snapshotter externe CSI du side-car en deux contrôleurs, </li><li>  ajout d'un <i>secret de suppression</i> en tant qu'annotation au contenu de l'instantané de volume, </li><li>  Un nouveau finaliseur pour empêcher la suppression de l'objet API d'instantané s'il reste des connexions. </li></ul><br>  Au moment de la sortie de la version 1.17, la fonction était prise en charge par trois pilotes CSI: le pilote CCE du disque persistant GCE, le pilote CSI Portworx et le pilote CSI NetApp Trident.  Vous pouvez en savoir plus sur sa mise en œuvre et son utilisation dans <a href="https://kubernetes.io/blog/2019/12/09/kubernetes-1-17-feature-cis-volume-snapshot-beta/">cet</a> article de blog. <br><br><h2>  Étiquettes de fournisseur de cloud </h2><br>  Les étiquettes qui sont automatiquement <b>attribuées aux nœuds et volumes créés en fonction du fournisseur de cloud utilisé</b> sont disponibles dans Kubernetes en version bêta depuis très longtemps - à commencer par la sortie de K8s 1.2 <i>(avril 2016!)</i> .  Compte tenu de leur utilisation répandue depuis si longtemps, les développeurs ont <a href="https://github.com/kubernetes/enhancements/issues/837">décidé</a> qu'il était temps de déclarer la fonctionnalité stable (GA). <br><br>  Par conséquent, ils ont tous été renommés en conséquence (par topologie): <br><br><ul><li>  <code>beta.kubernetes.io/instance-type</code> → <code>node.kubernetes.io/instance-type</code> </li><li>  <code>failure-domain.beta.kubernetes.io/zone</code> → <code>topology.kubernetes.io/zone</code> </li><li>  <code>failure-domain.beta.kubernetes.io/region</code> → <code>topology.kubernetes.io/region</code> </li></ul><br>  ... mais toujours disponible par leurs anciens noms (pour des raisons de compatibilité descendante).  Cependant, tous les administrateurs sont encouragés à passer aux étiquettes actuelles.  La <a href="https://kubernetes.io/docs/reference/kubernetes-api/labels-annotations-taints/">documentation pertinente de</a> K8 a été mise à jour. <br><br><h2>  Kubeadm à sortie structurée </h2><br>  Au format alpha, <a href="https://github.com/kubernetes/enhancements/issues/1053">la sortie structurée de l'utilitaire kubeadm</a> est présentée pour la première fois.  Formats pris en charge: JSON, YAML, Go-template. <br><br>  La motivation pour implémenter cette fonctionnalité (selon <a href="">KEP</a> ) est la suivante: <br><br><blockquote>  Bien que Kubernetes puisse être déployé manuellement, la norme de facto (sinon de jure) pour cette opération consiste à utiliser kubeadm.  Les outils de gestion de système populaires comme Terraform s'appuient sur kubeadm pour le déploiement de Kubernetes.  Les améliorations planifiées de l'API de cluster incluent un package composable pour l'amorçage Kubernetes avec kubeadm et cloud-init. <br><br>  Sans sortie structurée, même les changements les plus anodins à première vue peuvent casser Terraform, l'API de cluster et d'autres logiciels qui utilisent les résultats de kubeadm. </blockquote><br>  Dans un avenir proche, le support apparaît (sous forme de sortie structurée) pour les commandes kubeadm suivantes: <br><br><ul><li> <code>alpha certs</code> </li> <li> <code>config images list</code> </li> <li> <code>init</code> </li> <li> <code>token create</code> </li> <li> <code>token list</code> </li> <li> <code>upgrade plan</code> </li> <li> <code>version</code> </li> </ul><br>  Illustration de la réponse JSON à la commande <code>kubeadm init -o json</code> : <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"node0"</span></span>: <span class="hljs-string"><span class="hljs-string">"192.168.20.51:443"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"caCrt"</span></span>: <span class="hljs-string"><span class="hljs-string">"sha256:1f40ff4bd1b854fb4a5cf5d2f38267a5ce5f89e34d34b0f62bf335d74eef91a3"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"token"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"5ndzuu.ngie1sxkgielfpb1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ttl"</span></span>: <span class="hljs-string"><span class="hljs-string">"23h"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"expires"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-05-08T18:58:07Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"usages"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"authentication"</span></span>, <span class="hljs-string"><span class="hljs-string">"signing"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"The default bootstrap token generated by 'kubeadm init'."</span></span>, <span class="hljs-attr"><span class="hljs-attr">"extraGroups"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"system:bootstrappers:kubeadm:default-node-token"</span></span> ] }, <span class="hljs-attr"><span class="hljs-attr">"raw"</span></span>: <span class="hljs-string"><span class="hljs-string">"Rm9yIHRoZSBhY3R1YWwgb3V0cHV0IG9mIHRoZSAia3ViZWFkbSBpbml0IiBjb21tYW5kLCBwbGVhc2Ugc2VlIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2FrdXR6LzdhNjg2ZGU1N2JmNDMzZjkyZjcxYjZmYjc3ZDRkOWJhI2ZpbGUta3ViZWFkbS1pbml0LW91dHB1dC1sb2c="</span></span> }</code> </pre> <br><h2>  Stabilisation d'autres innovations </h2><br>  En général, la sortie de Kubernetes 1.17 a eu lieu sous la devise " <b>Stabilité</b> ".  Cela a été facilité par le fait que tant de fonctionnalités (leur nombre total est de <b>14</b> ) ont reçu le statut GA.  Parmi ceux-ci: <br><br><ul><li>  «Marquage» des nœuds sous certaines conditions ( <a href="https://github.com/kubernetes/enhancements/issues/382"><code>TaintNodesByCondition</code></a> ), qui est apparu dans <a href="https://habr.com/ru/company/flant/blog/338230/">K8s 1.8</a> ; </li><li>  <a href="https://github.com/kubernetes/enhancements/issues/956">Watch Bookmarks</a> - un nouveau type d'événements avec une étiquette selon laquelle tous les objets jusqu'à une certaine version ( <code>resourceVersion</code> ) ont déjà été traités par watch; </li><li>  valeurs <a href="https://github.com/kubernetes/enhancements/issues/575">par défaut</a> pour les ressources personnalisées; </li><li>  <a href="https://kubernetes.io/docs/tasks/configure-pod-container/share-process-namespace/">partagé entre les conteneurs</a> dans les espaces de noms du processus pod; </li><li>  <code>ScheduleDaemonSetPods</code> - <a href="https://github.com/kubernetes/enhancements/issues/548">planification des pods dans DaemonSet à l'</a> aide du kube-scheduler (au lieu du contrôleur DaemonSet); </li><li>  <a href="https://github.com/kubernetes/enhancements/issues/554">limites dynamiques</a> du nombre de volumes en fonction du type de nœud; </li><li>  <a href="https://github.com/kubernetes/enhancements/issues/559">prise en charge des variables d'environnement</a> pour les noms de répertoire montés en tant que <code>subPath</code> ; </li><li>  <a href="https://github.com/kubernetes/enhancements/issues/589">le portage des battements</a> de <a href="https://github.com/kubernetes/enhancements/issues/589">cœur de Kubelet</a> vers une API de location spécialisée; </li><li>  « <a href="https://github.com/kubernetes/enhancements/issues/980">Finalizer Protection</a> » pour les équilibreurs de charge (vérification des ressources de service correspondantes avant de supprimer les ressources LoadBalancer); </li><li>  <a href="https://github.com/kubernetes/enhancements/issues/1152">l'optimisation des</a> performances de <a href="https://github.com/kubernetes/enhancements/issues/1152">kube-apiserver</a> lorsque vous travaillez avec plusieurs montres qui surveillent des ensembles d'objets identiques est obtenue en évitant la sérialisation répétée des mêmes objets pour chaque observateur. </li></ul><br><h2>  Autres changements </h2><br>  Bien entendu, la liste complète des innovations de Kubernetes 1.17 n'est pas limitée à celles répertoriées ci-dessus.  En voici d'autres (et pour une liste plus complète - voir <a href="">CHANGELOG</a> ): <br><br><ul><li>  La version bêta de <a href="https://github.com/kubernetes/enhancements/issues/1043"><code>RunAsUserName</code> pour Windows</a> présentée dans la version précédente est passée à la version bêta; </li><li>  un changement similaire est <a href="https://github.com/kubernetes/kubernetes/pull/85365">arrivé à l'</a> API EndpointSlice (également à partir de K8s 1.16), mais jusqu'à présent, cette solution pour améliorer les performances / l'évolutivité de l'API Endpoint n'a pas été activée par défaut; </li><li>  les pods critiques pour le fonctionnement du cluster <a href="https://github.com/kubernetes/kubernetes/pull/76310">peuvent</a> désormais <a href="https://github.com/kubernetes/kubernetes/pull/76310">être créés</a> non seulement dans les espaces de noms du <code>kube-system</code> <i>(voir la documentation pour la <a href="https://kubernetes.io/docs/concepts/policy/resource-quotas/">consommation de classe de priorité limite pour</a> plus <a href="https://kubernetes.io/docs/concepts/policy/resource-quotas/">de</a> détails)</i> ; </li><li>  une nouvelle option pour kubelet - <a href="https://github.com/kubernetes/kubernetes/pull/83592"><code>--reserved-cpus</code></a> - vous permet de définir explicitement une liste de CPU réservés au système; </li><li>  pour les <code>kubectl logs</code> <a href="https://github.com/kubernetes/kubernetes/pull/76471">un</a> nouveau drapeau <a href="https://github.com/kubernetes/kubernetes/pull/76471">est présenté</a> - préfixe, ajoutant le nom du pod et du conteneur source à chaque ligne du journal; </li><li>  dans <code>label.Selector</code> <a href="https://github.com/kubernetes/kubernetes/pull/85048">ajouté</a> <code>RequiresExactMatch</code> ; </li><li>  tous les conteneurs dans kube-dns <a href="https://github.com/kubernetes/kubernetes/pull/82347">s'exécutent maintenant</a> avec moins de privilèges; </li><li>  <a href="https://github.com/kubernetes/kubernetes/tree/master/cluster/images/hyperkube">hyperkube est</a> alloué à un référentiel GitHub séparé et ne sera plus inclus dans les versions de Kubernetes; </li><li>  Amélioration significative des <a href="https://github.com/kubernetes/kubernetes/pull/83208">performances du</a> proxy de cube pour les ports non UDP. </li></ul><br>  Changements de dépendance: <br><br><ul><li>  Version CoreDNS dans kubeadm - 1.6.5; </li><li>  version crictl mise à jour vers v1.16.1; </li><li>  CSI 1.2.0; </li><li>  etcd 3.4.3; </li><li>  La dernière version testée de Docker a été mise à niveau vers 19/03; </li><li>  la version Go minimum requise pour construire Kubernetes 1.17 est 1.13.4. </li></ul><br><h2>  PS </h2><br>  Lisez aussi dans notre blog: <br><br><ul><li>  « <a href="https://habr.com/ru/company/flant/blog/467477/">Kubernetes 1.16: un aperçu des principales innovations</a> »; </li><li>  « <a href="https://habr.com/ru/company/flant/blog/456084/">Kubernetes 1.15: un aperçu des principales innovations</a> »; </li><li>  « <a href="https://habr.com/ru/company/flant/blog/445196/">Kubernetes 1.14: un aperçu des principales innovations</a> »; </li><li>  " <a href="https://habr.com/ru/company/flant/blog/432208/">Kubernetes 1.13: un aperçu des principales innovations</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr476998/">https://habr.com/ru/post/fr476998/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr476984/index.html">Cas de Narcade: les développeurs turcs parlent de la localisation des jeux mobiles et du marché turc des jeux</a></li>
<li><a href="../fr476986/index.html">Multiplexage des données de sortie vers un affichage de port parallèle</a></li>
<li><a href="../fr476990/index.html">Vous ne pouvez pas simplement le prendre et tout faire parfaitement: ce qui reste derrière les rideaux du record du monde Guinness</a></li>
<li><a href="../fr476994/index.html">Ce qui a rendu Lisp spécial</a></li>
<li><a href="../fr476996/index.html">Résoudre le problème de la commutation alt + shift sous Linux, dans les applications sur Electron</a></li>
<li><a href="../fr477000/index.html">Comment augmenter la précision des capteurs</a></li>
<li><a href="../fr477002/index.html">Comment nous avons hébergé le scandaleux tableau d'images 8chan</a></li>
<li><a href="../fr477004/index.html">Énergie solaire salée</a></li>
<li><a href="../fr477006/index.html">Java est-il le meilleur langage de programmation pour les débutants?</a></li>
<li><a href="../fr477008/index.html">Buildroot: Création d'un firmware multiplateforme avec zabbix-server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>