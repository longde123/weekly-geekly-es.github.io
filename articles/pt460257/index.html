<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë≤üèΩ üõåüèº üìø Ol√° Mundo! Imers√£o profunda em terminais üèæ üåï üëø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fui inspirado a escrever este artigo por um artigo sobre a an√°lise de Sishny printf . No entanto, houve um momento em que os dados seguem depois que e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ol√° Mundo! Imers√£o profunda em terminais</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460257/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/ha/5f/0v/ha5f0vjiijc9c92bnnt56z7jcpg.jpeg"></a> </p><br><p>  Fui inspirado a escrever este artigo por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um artigo sobre a an√°lise de Sishny printf</a> .  No entanto, houve um momento em que os dados seguem depois que entram no dispositivo terminal.  Neste artigo, desejo corrigir esse defeito e analisar o caminho dos dados no terminal.  Tamb√©m descobriremos como o Terminal difere do Shell, o que √© o Pseudoterminal, como os emuladores de terminal funcionam e muito mais. </p><a name="habracut"></a><br><h2 id="osnovy">  O b√°sico </h2><br><p>  Vamos primeiro entender o que √© Terminal, Shell, Console, como o Emulador de Terminal difere do Terminal comum e por que esse nome √© chamado.  Muitas informa√ß√µes j√° foram escritas sobre isso, ent√£o voc√™ n√£o ouvir√° nada de novo aqui.  Quase todas as informa√ß√µes aqui foram retiradas da Internet, fornecerei links no final do artigo.  Quem j√° sabe o que todas essas coisas significam, pode pular esta se√ß√£o com seguran√ßa. </p><br><hr><br><h3 id="terminal">  Terminal </h3><br><p>  <strong>Um terminal</strong> √© uma combina√ß√£o de uma tela e um teclado, ou seja, um dispositivo f√≠sico.  Antes de os terminais se tornarem essa combina√ß√£o espec√≠fica, eles eram um tipo de dispositivo chamado tele-impressora (teletipo, teletipo ou TTY), ou seja, uma combina√ß√£o de impressora e teclado.  Normalmente, v√°rios terminais est√£o conectados ao mesmo computador.  Assim, foi poss√≠vel trabalhar para v√°rios usu√°rios no mesmo computador, e cada um teve sua pr√≥pria sess√£o, independente dos outros.  O terminal recebeu esse nome porque estava localizado na extremidade do cabo do terminal. </p><br><p>  Este √© o <strong>Teletype</strong> : </p><br><img src="https://habrastorage.org/webt/m3/_3/yt/m3_3ytmmoofzwgpr3dpu78w8m7i.jpeg" alt="Teletype" title="Teletipo" width="430" height="370"><br><br><p>  E este √© o <strong>Terminal</strong> : </p><br><img src="https://habrastorage.org/webt/pz/lj/eu/pzljeumccjvqmrunt-pqolnyx-c.jpeg" alt="Terminal" title="Terminal" width="430" height="370"><br><br><hr><br><h3 id="console">  Console </h3><br><p>  <strong>Console (console)</strong> - um terminal conectado diretamente ao computador.  O fato √© que a maioria dos terminais estava conectada implicitamente, mas pelo menos um estava conectado diretamente ao computador.  O console teve permiss√£o para usar um c√≠rculo estritamente definido de pessoas, pois permitiu configurar o computador. </p><br><hr><br><h3 id="shell">  Shell </h3><br><p>  Se os dois anteriores forem dispositivos f√≠sicos, essa defini√ß√£o se refere exclusivamente ao software. </p><br><p>  <strong>Shell</strong> √© um int√©rprete de linha de comando.  O principal objetivo √© executar outros programas.  H√° um grande n√∫mero de conchas diferentes.  O mais comum √© o Bash (do ingl√™s Bourne Again SHell, que, como sugere a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Wikipedia</a> , √© um trocadilho com o Shell "Born again", ou seja, um Shell "revivido").  Outros exemplos: Dash (um Shell leve, dispon√≠vel se voc√™ executar o bin√°rio em / bin / sh), Zsh. </p><br><hr><br><p>  Obviamente, tanto os terminais quanto os consoles n√£o conseguiram deixar de refletir seus tempos modernos.  Portanto, consideraremos ainda mais o <em>Emulador de Terminal</em> e <em>o Console Virtual</em> . </p><br><h3 id="terminal-emulator">  Emulador de terminal </h3><br><p>  <strong>Emulador de terminal</strong> - um emulador do bom e velho terminal.  √â necess√°rio um emulador de terminal para programas que n√£o podem interagir diretamente com o X Window System - Bash, Vim e outros. </p><br><p>  Vamos primeiro estabelecer as responsabilidades do terminal: </p><br><ol><li>  Transferir entrada do usu√°rio para um computador </li><li>  Entrega da sa√≠da do computador para a tela </li></ol><br><p>  Portanto, nosso Emulador de Terminal faz exatamente a mesma coisa: entrega a entrada do usu√°rio ao programa em execu√ß√£o e tamb√©m exibe a sa√≠da do programa no visor.  De qualquer forma, o significado permanece - entre o usu√°rio e o programa em execu√ß√£o, existe algum tipo de camada respons√°vel pela entrada / sa√≠da.  Exemplos de emulador de terminal: gnome-terminal, xterm, konsole. </p><br><p>  <strong>Por favor, n√£o confunda Shell e Emulador de Terminal!</strong> <br>  O Emulador de Terminal √© um aplicativo GUI, ou seja, uma janela no Sistema X Window.  O Shell √© um interpretador de linha de comando, ou seja, apenas um executor de comando, n√£o possui um shell gr√°fico.  Falando corretamente, voc√™ <strong>n√£o inicia o Bash</strong> , <strong>executa o Emulador de Terminal, que inicia o Bash dentro de si</strong> .  Terminal Emulator e Bash s√£o absolutamente 2 programas diferentes.  O primeiro √© o √∫nico respons√°vel pela entrada / sa√≠da, o segundo - pelo processamento de comandos. </p><br><p>  Mais adiante neste artigo, todas as refer√™ncias ao terminal se referir√£o ao emulador de terminal. </p><br><hr><br><h3 id="virtual-console-virtual-terminal">  Console Virtual (Terminal Virtual) </h3><br><p>  Pressione Ctrl + Alt + FN, onde N geralmente possui valores de 1 a 6. O que voc√™ acabou de ver se chama Console Virtual (console virtual) ou Terminal Virtual (terminal virtual).  Lembra do que eu disse anteriormente sobre terminais?  Muitos terminais foram conectados a um computador e cada terminal foi uma sess√£o separada, independente dos outros.  O Console virtual repete essa id√©ia: pode haver v√°rias sess√µes independentes dentro do seu computador (no entanto, os recursos do computador ainda est√£o obviamente compartilhados). </p><br><p>  Voc√™ pode nomear essa entidade como Console virtual e Terminal virtual, porque, por defini√ß√£o, um console √© um terminal conectado diretamente a um computador, mas todos os terminais virtuais s√£o, de certo modo, conectados diretamente a um computador. </p><br><hr><br><h3 id="tty-ustroystva">  Dispositivos TTY </h3><br><p>  Cada terminal possui seu pr√≥prio <em>dispositivo TTY</em> (dispositivo de terminal), que fornece o console.  Embora voc√™ n√£o encontre teletipos, mas a redu√ß√£o no TTY sobreviveu at√© hoje. </p><br><p>  Um dispositivo TTY consiste em dois componentes fundamentais: </p><br><ol><li>  <strong>Driver de dispositivo</strong>  Ele √© respons√°vel por fornecer a entrada do teclado para o programa e exibir a sa√≠da do programa na tela. </li><li>  <strong>Disciplina de linha TTY</strong> (disciplina de linha russa).  A disciplina de linha √© a interface de acesso ao driver, que, no entanto, traz muita l√≥gica ao dispositivo TTY.  Podemos dizer que os proxies de disciplina de linha chamam o driver.  Qual √© a √°rea de responsabilidade desse componente, descobriremos durante o artigo. </li></ol><br><p>  Crie um dispositivo TTY: </p><br><p><img src="https://habrastorage.org/webt/zn/zw/dy/znzwdyjadyeidyogqoap8kfvgng.jpeg" title="Construir dispositivo TTY"></p><br><p>  Existem 3 tipos de dispositivos TTY: </p><br><ol><li>  <em>Dispositivo do console</em> - fornece opera√ß√£o do console virtual.  A entrada e sa√≠da deste dispositivo √© totalmente controlada pelo kernel. </li><li>  <em>Dispositivo PTY</em> (pseudo-terminal) - fornece opera√ß√£o do terminal na interface da janela.  A entrada e sa√≠da deste dispositivo √© controlada por um emulador de terminal que opera no espa√ßo do usu√°rio. </li><li>  <em>Dispositivo serial</em> - comunica-se diretamente com o hardware.  Geralmente n√£o √© usado diretamente, mas existe como o n√≠vel mais baixo na organiza√ß√£o da arquitetura de um dispositivo terminal. </li></ol><br><p>  Neste artigo, falaremos especificamente sobre o segundo tipo de dispositivos TTY - pseudo-terminais. </p><br><hr><br><h2 id="tty-line-discipline">  Disciplina de Linha TTY </h2><br><p>  Come√ßamos a examinar a disciplina da linha de dispositivos TTY. </p><br><p>  A primeira caracter√≠stica importante de uma disciplina de linha √© que ela √© respons√°vel pelo processamento de E / S.  Isso inclui, por exemplo, o processamento de caracteres de controle (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Caracteres de controle">Caracteres de controle</a> ) e a formata√ß√£o da sa√≠da.  Por exemplo, voc√™ digita qualquer texto, mas de repente percebe que estava errado ao escrever algo e deseja apag√°-lo - √© aqui que a disciplina de linha entra em cena. </p><br><p>  Analisaremos em detalhes o que exatamente acontece quando trabalhamos no Bash em execu√ß√£o no terminal.  Por padr√£o, um dispositivo TTY opera no modo can√¥nico com o <em>eco ativado</em> .  Um eco √© uma exibi√ß√£o dos caracteres que voc√™ inseriu na tela. </p><br><p> Quando inserimos, por exemplo, o caractere <code>a</code> , esse caractere √© enviado ao dispositivo TTY, mas √© interceptado pela disciplina da linha TTY do dispositivo.  Ela l√™ um personagem em seu buffer interno, v√™ que o modo de <code>echo</code> est√° ativado e exibe o personagem na tela.  No momento, nada ainda est√° dispon√≠vel para leitura no programa ao qual o dispositivo terminal est√° conectado.  Vamos pressionar <code>backspace</code> no teclado.  Symbol <code>^?</code>  novamente interceptado pela disciplina de linha, e o √∫ltimo, percebendo que o usu√°rio deseja apagar o √∫ltimo caractere inserido, remove esse caractere do buffer interno e apaga esse caractere tamb√©m da tela.  Agora, se pressionarmos Enter, a Disciplina de Linha TTY finalmente enviar√° para o buffer de leitura do dispositivo terminal tudo o que foi escrito anteriormente para o buffer interno da disciplina, incluindo LF.  Ao mesmo tempo, os caracteres CR e LF s√£o exibidos na tela para mover o cursor para uma nova linha - esta √© a formata√ß√£o da sa√≠da. </p><br><p>  √â assim que o modo can√¥nico funciona - ele transfere todos os caracteres inseridos no dispositivo somente depois de pressionar <code>Enter</code> , processa os caracteres de controle e formata a sa√≠da. </p><br><h3 id="tty-line-editing">  Edi√ß√£o de linha TTY </h3><br><p>  <strong>A edi√ß√£o de linha TTY</strong> √© o componente respons√°vel pelo processamento de entrada na disciplina de linha.  Deve-se dizer que a <em>edi√ß√£o de linha</em> √© um conceito geral e se refere ao processamento de entrada.  Por exemplo, Bash e Vim t√™m sua pr√≥pria edi√ß√£o de linha. </p><br><p>  Podemos controlar as configura√ß√µes de disciplina da linha do dispositivo TTY atual usando o programa <strong>stty</strong> .  Vamos experimentar um pouco. </p><br><p>  Abra o Bash ou qualquer outro Shell e digite: </p><br><pre> <code class="plaintext hljs">stty icanon -echo</code> </pre> <br><p>  Agora, tente digitar alguma coisa e voc√™ n√£o ver√° a sua entrada (n√£o se preocupe, voc√™ ainda pode passar a entrada para o programa).  Voc√™ acabou de desativar o eco - ou seja, a exibi√ß√£o dos caracteres digitados na tela.  Agora digite: </p><br><pre> <code class="plaintext hljs">stty raw echo</code> </pre> <br><p>  Tente digitar alguma coisa.  Voc√™ v√™ como a conclus√£o √© quebrada.  Mas, para mais efeito, vamos para o Dash - digite <code>/bin/sh</code> .  Agora tente inserir caracteres especiais ( <code>Ctrl</code> + qualquer caractere no teclado) ou apenas pressione <code>Enter</code> .  Voc√™ est√° perplexo - quais s√£o esses caracteres estranhos na tela?  O fato √© que, ao entrar no Shell mais simples, al√©m da edi√ß√£o de linha da pr√≥pria disciplina, tamb√©m desabilitamos o Bash de edi√ß√£o de linhas e agora podemos observar com poder e principal o efeito da inclus√£o do modo <em>bruto</em> de disciplina da linha.  Este modo n√£o processa a entrada e n√£o formata a sa√≠da.  Por que o modo bruto √© necess√°rio?  Por exemplo, para o <em>Vim</em> : ele se abre em toda a janela do terminal e processa a entrada em si, pelo menos para que s√≠mbolos especiais da disciplina de linha n√£o se cruzem com s√≠mbolos especiais do pr√≥prio Vim. </p><br><p>  Para um entendimento ainda maior, vejamos a personaliza√ß√£o dos caracteres de controle.  O <code>stty &lt;control-character&gt; &lt;string&gt;</code> nos ajudar√° com isso. <br>  Entre no Bash: </p><br><pre> <code class="bash hljs">stty erase 0</code> </pre> <br><p>  Agora, o caractere de controle de <code>erase</code> ser√° atribu√≠do ao caractere <code>0</code> .  O bot√£o <code>backspace</code> geralmente importa <code>^?</code>  , mas agora esse caractere especial ser√° enviado para o buffer de leitura do PTS literalmente - tente voc√™ mesmo.  Agora voc√™ pode apagar caracteres usando o bot√£o <code>0</code> no teclado, porque voc√™ mesmo solicitou a disciplina de linha tty para reconhecer o caractere inserido como um caractere de controle de exclus√£o.  Voc√™ pode retornar a configura√ß√£o usando o comando <code>stty erase ^\?</code>  ou apenas fechando o terminal, porque afetamos apenas o dispositivo tty atual. </p><br><p>  Voc√™ pode encontrar mais informa√ß√µes no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="homem stty">man stty</a> . </p><br><hr><br><h2 id="terminal-emulator-i-pseudoterminal">  Emulador de terminal e pseudoterminal </h2><br><p>  Cada vez que abrimos um novo terminal no Sistema X Window, o GNOME Terminal Server gera um novo processo e inicia o programa padr√£o nele.  Geralmente, esse √© algum tipo de shell (por exemplo, Bash). </p><br><p>  A comunica√ß√£o com o programa em execu√ß√£o ocorre atrav√©s do chamado <strong>Pseudoterminal</strong> (pseudo-terminal, PTY).  O pr√≥prio pseudo-terminal existe no kernel, no entanto, recebe entrada do espa√ßo do usu√°rio - do emulador de terminal. </p><br><p>  O pseudo-terminal consiste nos seguintes dois <em>dispositivos TTY virtuais</em> : <br>  1) <strong>Mestre PTY (PTM)</strong> - a parte principal do pseudo-terminal.  Usado pelo GNOME Terminal Server para transferir a entrada do teclado para um programa em execu√ß√£o dentro do terminal, bem como para ler a sa√≠da do programa e exibir a sa√≠da.  O GNOME Terminal Server, por sua vez, se comunica com o Sistema X Window atrav√©s do protocolo X. <br>  2) <strong>PTY escravo (PTS)</strong> - parte escrava do pseudo-terminal.  Usado por um programa em execu√ß√£o dentro do terminal para ler a entrada do teclado e exibir a sa√≠da na tela.  Pelo menos, o pr√≥prio programa pensa assim (vou explicar o que isso significa, um pouco mais). </p><br><p>  Qualquer dado gravado no dispositivo PTS √© a entrada do dispositivo PTM, ou seja, fica leg√≠vel no dispositivo PTM.  E vice-versa: qualquer dado gravado no dispositivo PTM √© a entrada do dispositivo PTS.  √â assim que o GNOME Terminal Server e o programa em execu√ß√£o no terminal se comunicam.  Cada dispositivo PTM est√° associado ao seu pr√≥prio dispositivo PTS. </p><br><p>  O processo de lan√ßamento de um novo terminal √© mais ou menos assim: <br>  1) O GNOME Terminal Server cria dispositivos mestre e escravo chamando a fun√ß√£o open () em um dispositivo especial <strong>/ dev / ptmx</strong> .  A chamada open () retorna o descritor de arquivo do dispositivo PTM criado - <em>master_fd</em> . <br>  2) O GNOME Terminal Server cria um novo processo chamando <code>fork()</code> .  Este processo ser√° o novo terminal. <br>  3) No terminal PTS, o dispositivo abre nos descritores de arquivo 0, 1, 2 (stdin, stdout e stderr, respectivamente).  Agora, a E / S do terminal padr√£o flui para este dispositivo. <br>  4) O programa desejado √© iniciado no terminal chamando a fun√ß√£o <code>exec()</code> .  Alguns Shell geralmente iniciam (por exemplo, Bash).  Qualquer programa lan√ßado posteriormente a partir do Bash ter√° os mesmos descritores de arquivo que o pr√≥prio Bash, ou seja, os fluxos do programa ser√£o direcionados ao dispositivo PTS. </p><br><p>  Voc√™ pode ver por si mesmo onde os fluxos de sa√≠da do terminal padr√£o s√£o direcionados usando o <code>ls -la /proc/self/fd</code> : <br><img src="https://habrastorage.org/webt/nr/dx/97/nrdx97wllflvapnt76p3qqki3fw.jpeg"></p><br><p>  O dispositivo PTS est√° localizado no caminho <strong>/ dev / pts / N</strong> , e o caminho para o dispositivo PTM n√£o nos interessa.  O fato √© que o GNOME Terminal Server j√° possui um descritor de arquivo para o dispositivo PTM aberto e n√£o precisa de um caminho para ele, no entanto, no processo filho, precisamos abrir o dispositivo PTS nos fluxos de sa√≠da padr√£o chamando a fun√ß√£o <code>open()</code> , que requer o caminho para o arquivo. </p><br><p>  Lembre-se, eu disse que um programa que usa um dispositivo PTS pensa apenas que se comunica diretamente com o terminal?  O fato √© que o PTS tamb√©m √© um <em>dispositivo terminal</em> ( <em>dispositivo</em> TTY), mas a diferen√ßa entre o dispositivo PTS e o dispositivo TTY real √© que o dispositivo PTS recebe entrada n√£o do teclado, mas do dispositivo mestre, e a sa√≠da n√£o vai para a tela, mas para dispositivo mestre.  √â por isso que o pseudo-terminal √© nomeado assim - o pseudo-terminal apenas imita (de novo?) O terminal.  A diferen√ßa entre o emulador de terminal e o pseudo-terminal √© que o emulador de terminal √© apenas um programa gr√°fico que permite executar o terminal diretamente dentro da interface da janela, mas esse recurso √© implementado usando o pseudo-terminal. </p><br><p>  O fato de o <em>dispositivo PTS ser um dispositivo TTY</em> √© muito importante.  Aqui est√° o porqu√™: </p><br><ol><li>  O programa ao qual o dispositivo terminal est√° conectado possui todos os recursos de um terminal convencional.  Por exemplo: desativar eco, desativar / ativar a exibi√ß√£o can√¥nica. </li><li>  O programa, sabendo que um dispositivo terminal est√° conectado a ele (diz-se que o programa possui um terminal de controle), pode trabalhar interativamente e pedir entrada ao usu√°rio.  Por exemplo, solicite um nome de usu√°rio e senha. </li><li>  H√° tamb√©m uma Disciplina de Linha TTY, portanto, temos a capacidade de processar caracteres de controle antes que eles cheguem ao programa, al√©m de formatar a sa√≠da do programa. </li></ol><br><p>  O dispositivo PTM tamb√©m √© um dispositivo TTY, mas n√£o desempenha nenhum papel, pois n√£o √© usado como um terminal de controle.  Al√©m disso, a disciplina de linha do dispositivo PTM √© configurada para o modo bruto, portanto, o processamento n√£o √© realizado ao transferir dados do PTS para o dispositivo PTM.  No entanto, as chamadas para <code>read()</code> e <code>write()</code> do espa√ßo do usu√°rio ainda s√£o atendidas pela disciplina de linha nos dois dispositivos.  Este momento ter√° um papel ainda maior, como veremos mais adiante. </p><br><p>  O processo de comunica√ß√£o entre o GNOME Terminal Server e o programa em execu√ß√£o no terminal √© o seguinte: </p><br><p><img src="https://habrastorage.org/webt/jz/y0/sg/jzy0sg0zjcceaflg6wyg7d5lkti.jpeg" title="O processo de comunica√ß√£o do GNOME Terminal Server e um programa em execu√ß√£o dentro do terminal"></p><br><p>  Vale a pena examinar com mais detalhes o papel que a disciplina de linha desempenha na comunica√ß√£o entre as duas partes de um pseudo-terminal.  Aqui, a disciplina de linha √© respons√°vel pelo processamento de dados que <em>passam do PTM para o dispositivo PTS</em> , bem como pela entrega de dados de uma parte do pseudo-terminal para outra.  Quando estamos no driver de dispositivo PTS, adotamos a disciplina de linha do dispositivo PTM e vice-versa. </p><br><hr><br><h2 id="virtualnye-ustroystva">  Dispositivos virtuais </h2><br><p>  Voc√™ provavelmente pensaria que poderia abrir o arquivo ao longo do caminho <em>/ dev / pts / N</em> e escrever ou ler dados dele, como em um arquivo de texto comum?  Sim, todos os dispositivos em sistemas semelhantes ao Unix s√£o arquivos, gra√ßas ao princ√≠pio fundamental do Unix, que afirma que tudo √© um arquivo.  No entanto, nenhum arquivo de dispositivo especial (ingl√™s - arquivo de dispositivo) √© um arquivo de texto.  Esses dispositivos s√£o chamados <strong>de dispositivos virtuais</strong> - ou seja, eles existem exclusivamente na mem√≥ria, n√£o no disco. </p><br><p>  N√£o tente abrir esses arquivos como arquivos de texto regulares.  No entanto, voc√™ pode usar esses dispositivos atrav√©s das opera√ß√µes <code>write()</code> e <code>read()</code> , cuja chamada ser√° atendida pelo driver do dispositivo.  Vamos tentar fazer isso. </p><br><p>  Abra duas janelas de terminal e insira <code>tty</code> em cada comando.  Este comando mostrar√° qual dispositivo TTY est√° servindo o terminal atualmente ativo.  Agora digite <code>echo "Hello, World!" &gt; /dev/pts/N</code>  <code>echo "Hello, World!" &gt; /dev/pts/N</code> na primeira janela do terminal, onde N √© o √≠ndice PTS do dispositivo da segunda janela, alterne para a segunda janela e voc√™ ver√° a entrada da primeira janela.  Agora voc√™ gravou os dados no dispositivo PTS da segunda janela <em>como se tivessem sido executados por um programa em execu√ß√£o naquele terminal</em> . </p><br><p><img src="https://habrastorage.org/webt/nj/3s/rp/nj3srpuzyahyvukzicfr0b5wnja.png"></p><br><hr><br><h2 id="ustroystvo-psevdoterminala">  Dispositivo pseudo-terminal </h2><br><p>  Estamos nos aproximando cada vez mais da parte final do artigo, mas antes disso examinamos "por baixo do cap√¥" do Linux - considere o dispositivo do pseudo-terminal no n√≠vel do kernel.  Haver√° muito c√≥digo, mas tentarei explicar cada bloco de c√≥digo com o m√°ximo de detalhes poss√≠vel, reduzir detalhes sem import√¢ncia e seguir em seq√º√™ncia. </p><br><p>  Antes de come√ßar, apresentamos a chamada "cesta de componentes".  √Ä medida que avan√ßamos no n√∫cleo, adicionaremos mais e mais componentes a ele e encontraremos uma conex√£o entre eles.  Espero que isso ajude voc√™ a entender melhor o dispositivo pseudo-terminal.  Vamos come√ßar. </p><br><p>  Quando o Linux inicia, ele carrega os drivers de dispositivo necess√°rios.  Nosso pseudo-terminal tamb√©m possui esse driver.  Seu registro come√ßa com uma chamada para esta fun√ß√£o: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __init pty_init(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { legacy_pty_init(); unix98_pty_init(); <span class="hljs-comment"><span class="hljs-comment">// &lt;- ,    return 0; } device_initcall(pty_init); // ,      </span></span></code> </pre> <br><p>  Para todos os sistemas modernos, a fun√ß√£o <code>unix98_pty_init()</code> ser√° chamada: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __init unix98_pty_init(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { ptm_driver = tty_alloc_driver(NR_UNIX98_PTY_MAX, TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV | TTY_DRIVER_DEVPTS_MEM | TTY_DRIVER_DYNAMIC_ALLOC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(ptm_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't allocate Unix98 ptm driver"</span></span>); pts_driver = tty_alloc_driver(NR_UNIX98_PTY_MAX, TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV | TTY_DRIVER_DEVPTS_MEM | TTY_DRIVER_DYNAMIC_ALLOC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(pts_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't allocate Unix98 pts driver"</span></span>); ptm_driver-&gt;driver_name = <span class="hljs-string"><span class="hljs-string">"pty_master"</span></span>; ptm_driver-&gt;name = <span class="hljs-string"><span class="hljs-string">"ptm"</span></span>; ptm_driver-&gt;major = UNIX98_PTY_MASTER_MAJOR; ptm_driver-&gt;minor_start = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;type = TTY_DRIVER_TYPE_PTY; ptm_driver-&gt;subtype = PTY_TYPE_MASTER; ptm_driver-&gt;init_termios = tty_std_termios; ptm_driver-&gt;init_termios.c_iflag = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;init_termios.c_oflag = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;init_termios.c_cflag = B38400 | CS8 | CREAD; ptm_driver-&gt;init_termios.c_lflag = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;init_termios.c_ispeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; ptm_driver-&gt;init_termios.c_ospeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; ptm_driver-&gt;other = pts_driver; tty_set_operations(ptm_driver, &amp;ptm_unix98_ops); pts_driver-&gt;driver_name = <span class="hljs-string"><span class="hljs-string">"pty_slave"</span></span>; pts_driver-&gt;name = <span class="hljs-string"><span class="hljs-string">"pts"</span></span>; pts_driver-&gt;major = UNIX98_PTY_SLAVE_MAJOR; pts_driver-&gt;minor_start = <span class="hljs-number"><span class="hljs-number">0</span></span>; pts_driver-&gt;type = TTY_DRIVER_TYPE_PTY; pts_driver-&gt;subtype = PTY_TYPE_SLAVE; pts_driver-&gt;init_termios = tty_std_termios; pts_driver-&gt;init_termios.c_cflag = B38400 | CS8 | CREAD; pts_driver-&gt;init_termios.c_ispeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; pts_driver-&gt;init_termios.c_ospeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; pts_driver-&gt;other = ptm_driver; tty_set_operations(pts_driver, &amp;pty_unix98_ops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tty_register_driver(ptm_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't register Unix98 ptm driver"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tty_register_driver(pts_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't register Unix98 pts driver"</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Now create the /dev/ptmx special device */</span></span> tty_default_fops(&amp;ptmx_fops); ptmx_fops.open = ptmx_open; cdev_init(&amp;ptmx_cdev, &amp;ptmx_fops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cdev_add(&amp;ptmx_cdev, <span class="hljs-built_in"><span class="hljs-built_in">MKDEV</span></span>(TTYAUX_MAJOR, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>) || register_chrdev_region(<span class="hljs-built_in"><span class="hljs-built_in">MKDEV</span></span>(TTYAUX_MAJOR, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"/dev/ptmx"</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't register /dev/ptmx driver"</span></span>); device_create(tty_class, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">MKDEV</span></span>(TTYAUX_MAJOR, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">"ptmx"</span></span>);</code> </pre> <br><p>  Aqui estamos interessados ‚Äã‚Äãem 3 coisas: </p><br><ol><li>  Chama <code>tty_set_operatons</code> para o driver mestre pty e dispositivos escravo pty. </li><li>  A fun√ß√£o <code>ptmx_open</code> , respons√°vel por criar as duas partes do pseudo-terminal ao abrir o dispositivo especial <em>/ dev / ptmx</em> .  Importante: / dev / ptmx n√£o √© um dispositivo PTM, mas apenas uma interface para criar um novo pseudo-terminal. </li><li>  Registre os drivers de dispositivo PTM e PTS. </li></ol><br><p>  Vamos em ordem: </p><br><h4 id="1-tty_set_operations">  1. tty_set_operations </h4><br><p>  A fun√ß√£o <strong>tty_set_operations ()</strong> apenas configura uma tabela de fun√ß√µes para o driver atual: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> tty_set_operations(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations *op) { driver-&gt;ops = op; };</code> </pre> <br><p>  A estrutura <strong>tty_operations</strong> √© uma tabela de fun√ß√µes usada para acessar as fun√ß√µes do driver TTY do dispositivo. </p><br><p>  Vou destacar o mais importante nas estruturas <code>pty_unix98_ops</code> e <code>ptm_unix98_ops</code> , que s√£o a tabela de fun√ß√µes para as partes correspondentes do pseudo-terminal: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations ptm_unix98_ops = { .install = pty_unix98_install, .remove = pty_unix98_remove, .open = pty_open, .close = pty_close, .write = pty_write, <span class="hljs-comment"><span class="hljs-comment">// ... }; static const struct tty_operations pty_unix98_ops = { .install = pty_unix98_install, .remove = pty_unix98_remove, .open = pty_open, .close = pty_close, .write = pty_write, // ... };</span></span></code> </pre> <br><p>  Aqui voc√™ pode observar a fun√ß√£o pty_write, <code>pty_write</code> j√° √© familiar no artigo sobre Sishny printf - retornaremos a ela um pouco mais tarde. </p><br><p>  Vamos adicionar essa estrutura √† nossa cesta de componentes: <br><img src="https://habrastorage.org/webt/o8/e-/kc/o8e-kcpqestn7f481gcx38qmzuo.jpeg"></p><br><p>  Como voc√™ pode ver, os principais m√©todos de ambos os drivers n√£o s√£o de todo diferentes.  A prop√≥sito, observe que n√£o h√° fun√ß√£o para a opera√ß√£o read () - n√£o h√° nada como <code>pty_read()</code> .  O fato √© que a leitura ser√° servida apenas pela disciplina de linha.  Assim, aprendemos sobre o segundo recurso importante da disciplina de linha - leitura de dados de um dispositivo TTY. </p><br><hr><br><h4 id="2-ptmx_open">  2. ptmx_open </h4><br><p>  Agora vamos para <strong>ptmx_open ()</strong> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ptmx_open(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> inode *inode, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *filp) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty; <span class="hljs-comment"><span class="hljs-comment">//    -   ! fsi = devpts_acquire(filp); //     devpts index = devpts_new_index(fsi); //       /dev/pts // ... tty = tty_init_dev(ptm_driver, index); // ... devpts_pty_new(fsi, index, tty-&gt;link); //     /dev/pts retval = ptm_driver-&gt;ops-&gt;open(tty, filp); //  PTM ,   }</span></span></code> </pre> <br><p>  Estamos interessados ‚Äã‚Äãna fun√ß√£o <code>tty_init_dev()</code> , onde o primeiro argumento √© o driver de dispositivo PTM e o segundo √© o √≠ndice do dispositivo.  Aqui deixamos a zona de responsabilidade do driver PTY e vamos para o arquivo, que √© respons√°vel apenas pelos dispositivos TTY gerais e n√£o sabe nada sobre o nosso pseudo-terminal. </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty_init_dev(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty; tty = alloc_tty_struct(driver, idx); retval = tty_driver_install_tty(driver, tty); <span class="hljs-comment"><span class="hljs-comment">/* * Structures all installed ... call the ldisc open routines. */</span></span> retval = tty_ldisc_setup(tty, tty-&gt;link); <span class="hljs-comment"><span class="hljs-comment">//  ,       return tty; }</span></span></code> </pre> <br><p>  Primeiro, <code>alloc_tty_struct()</code> fun√ß√£o <code>alloc_tty_struct()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *alloc_tty_struct(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty; tty = kzalloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*tty), GFP_KERNEL); <span class="hljs-comment"><span class="hljs-comment">//  tty_struct tty_ldisc_init(tty) //      tty_struct tty-&gt;driver = driver; //       tty_struct tty-&gt;ops = driver-&gt;ops; //        tty_struct.     tty-&gt;index = idx; //   tty  return tty; }</span></span></code> </pre> <br><p>  A √∫nica coisa que nos interessa aqui √© a fun√ß√£o <code>tty_ldisc_init()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tty_ldisc_init(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *ld = tty_ldisc_get(tty, N_TTY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(ld)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PTR_ERR(ld); tty-&gt;ldisc = ld; <span class="hljs-comment"><span class="hljs-comment">//        tty_struct return 0; }</span></span></code> </pre> <br><p>  Que chama <code>tty_ldisc_get()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *tty_ldisc_get(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> disc) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *ld; <span class="hljs-comment"><span class="hljs-comment">//    struct tty_ldisc_ops *ldops; //     ldops = get_ldops(disc); //      .   ,       .   - N_TTY ld = kmalloc(sizeof(struct tty_ldisc), GFP_KERNEL | __GFP_NOFAIL); ld-&gt;ops = ldops; //       ld-&gt;tty = tty; //    tty_struct   .          return ld; }</span></span></code> </pre> <br><p>  Ent√£o, examinamos a chamada para a fun√ß√£o <code>alloc_tty_struct()</code> , que cria a estrutura <em>tty_struct</em> junto com a disciplina de linha - a estrutura <em>tty_ldisc</em> .  Ambas as estruturas t√™m links entre si.  Vamos dar uma olhada nessas estruturas. </p><br><ul><li>  <strong>tty_struct</strong> √© uma estrutura para acessar o driver de dispositivo TTY e alguns outros campos.  √â assim: </li></ul><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver; <span class="hljs-comment"><span class="hljs-comment">//  TTY  const struct tty_operations *ops; //  .    ,   driver-&gt;ops,       int index; //   struct tty_ldisc *ldisc; //     struct tty_struct *link; //     PTY // ... }</span></span></code> </pre> <br><ul><li>  <strong>tty_ldisc</strong> √© a estrutura para a disciplina da linha TTY do dispositivo.  Consiste em apenas dois campos e tem a seguinte apar√™ncia: </li></ul><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc_ops *ops; <span class="hljs-comment"><span class="hljs-comment">//    struct tty_struct *tty; //   tty_struct  .       };</span></span></code> </pre> <br><p>  Parece n√£o ser nada complicado?  Vamos adicionar todas as estruturas consideradas at√© esse momento √† nossa cesta e vincul√°-las da mesma maneira que est√£o conectadas no c√≥digo: <br><img src="https://habrastorage.org/webt/1d/bt/n4/1dbtn4m_6c6i4n7oaohoguci2m0.jpeg" alt="Crie tty_struct" title="Crie tty_struct"></p><br><p>  Mas criamos tty_struct apenas para o dispositivo PTM.  E o dispositivo PTS?  Para fazer isso, retornamos √† fun√ß√£o <code>tty_init_dev()</code> e lembramos que devemos chamar a fun√ß√£o <code>tty_driver_install_tty()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * This method is responsible * for ensuring any need additional structures are allocated and configured. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tty_driver_install_tty(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> driver-&gt;ops-&gt;install ? driver-&gt;ops-&gt;install(driver, tty) : tty_standard_install(driver, tty); }</code> </pre> <br><p>  O coment√°rio nos diz que esse m√©todo √© respons√°vel pela cria√ß√£o de v√°rias estruturas adicionais.  Dispositivo PTS e ser√° nossa estrutura adicional.  Eu admito, foi extremamente surpreendente para mim, porque √©, diabos, todo o dispositivo, e n√£o apenas algum tipo de estrutura adicional!  Mas todos entendemos que todos os dispositivos s√£o apenas algum tipo de estrutura, ent√£o siga em frente.  Ok, o que √© <em>driver-&gt; ops-&gt; instalar aqui</em> ?  Para fazer isso, consulte a tabela de fun√ß√µes do driver PTM novamente: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations ptm_unix98_ops = { .install = pty_unix98_install, <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre> <br><p>  E entendemos que estamos interessados ‚Äã‚Äãna fun√ß√£o <code>pty_unix98_install()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pty_unix98_install(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pty_common_install(driver, tty, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><p>  Que chama a fun√ß√£o <code>pty_common_install()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pty_common_install(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> legacy) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *o_tty; <span class="hljs-comment"><span class="hljs-comment">// tty_struct    PTY -    PTS  //    ,       install.   ,   PTM     tty_struct,        if (driver-&gt;subtype != PTY_TYPE_MASTER) return -EIO; o_tty = alloc_tty_struct(driver-&gt;other, idx); tty-&gt;link = o_tty; o_tty-&gt;link = tty; }</span></span></code> </pre> <br><p>  ,   PTS       <em>tty_struct</em>   ,       PTS .           .  tty_struct  PTS    . </p><br><hr><br><h4 id="registraciya-drayvera">   </h4><br><p>        ,           TTY  (   -         ?). <br>  ‚Äî  ,       PTM,   PTS : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file_operations tty_fops = { .llseek = no_llseek, .read = tty_read, .write = tty_write, .poll = tty_poll, .unlocked_ioctl = tty_ioctl, .compat_ioctl = tty_compat_ioctl, .open = tty_open, .release = tty_release, .fasync = tty_fasync, .show_fdinfo = tty_show_fdinfo, };</code> </pre> <br><p>         ,                  TTY . </p><br><hr><br><p>  Feito.      ,       <em>/dev/ptmx</em> .  ,   PTS ,      ,   PTM ,      : </p><br><p><img src="https://habrastorage.org/webt/5w/aw/rg/5wawrgbqqw1_llmi1r8g2kbwrzc.jpeg" title="Build PTY"></p><br><hr><br><h2 id="hello-world">  Ol√° Mundo! </h2><br><p>        .          "Hello, World!",        . </p><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><span class="hljs-meta"> void main() { printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Hello, World!\n"</span></span></span><span class="hljs-meta">); }</span></span></code> </pre> <br><p> ,   "Hello, World!"    .   ,    ,  ,       .    ,    .  stdout  <em>/dev/null</em> ‚Äî       .          ,       Linux. </p><br><p>      Unix        <em>write()</em> , <em>read()</em> , <em>close()</em>  ,    write()  /dev/pts/0         <code>__vfs_write()</code> : </p><br><pre> <code class="objectivec hljs">ssize_t __vfs_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *file, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __user *buf, size_t count, loff_t *pos) { ssize_t ret; <span class="hljs-comment"><span class="hljs-comment">//... ret = file-&gt;f_op-&gt;write(file, buf, count, pos); //... return ret; }</span></span></code> </pre> <br><p>     write()      .   ,            : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file_operations tty_fops = { <span class="hljs-comment"><span class="hljs-comment">// ... .write = tty_write, // ...</span></span></code> </pre> <br><p>  <code>tty_write()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ssize_t tty_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *file, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __user *buf, size_t count, loff_t *ppos) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty = file_tty(file); <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *ld; ssize_t ret; ld = tty_ldisc_ref_wait(tty); ret = do_tty_write(ld-&gt;ops-&gt;write, tty, file, buf, count); tty_ldisc_deref(ld); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre> <br><p>     <em>tty_struct</em>    TTY ,           write()  .       : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc_ops n_tty_ops = { .write = n_tty_write, <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>    <code>n_tty_write()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * n_tty_write - write function for tty * @tty: tty device * @file: file object * @buf: userspace buffer pointer * @nr: size of I/O */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ssize_t n_tty_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *file, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buf, size_t nr) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *b = buf; <span class="hljs-comment"><span class="hljs-comment">// b - ,       "Hello, World!".          int c; //    //     PTS ,  write()    0,  ,     while (nr &gt; 0) { c = tty-&gt;ops-&gt;write(tty, b, nr); //  write()       TTY  if (!c) break; b += c; //     nr -= c; //      :  -  -  -  } }</span></span></code> </pre> <br><p> ,  "Hello, World!"    write()   PTS .       : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations pty_unix98_ops = { .write = pty_write, <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  <code>pty_write()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pty_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buf, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *to = tty-&gt;link; <span class="hljs-comment"><span class="hljs-comment">//      PTY.    -  PTM  if (c &gt; 0) { //    PTM  c = tty_insert_flip_string(to-&gt;port, buf, c); //     ,       if (c) { tty_flip_buffer_push(to-&gt;port); tty_wakeup(tty); } } return c; }</span></span></code> </pre> <br><p>          : </p><br><pre> <code class="objectivec hljs"> __vfs_write() -&gt; <span class="hljs-comment"><span class="hljs-comment">// 1- :   tty_write() -&gt; do_tty_write() -&gt; n_tty_write() -&gt; // 2- :   pty_write() // 3- : </span></span></code> </pre> <br><p>     . ,       PTM . ,    . </p><br><p>  ,          <em>flip buffer</em> . <strong>Flip buffer</strong> ‚Äî   ,    .  tty driver   ,      .   ,              .      ,        ,       .     ,      ,            .  -        flip buffer ‚Äî       (,    -  ,         flip). </p><br><p>          ,       .  <code>tty_insert_flip_string()</code>         <code>tty_insert_flip_string_fixed_flag()</code> ,           PTM : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tty_insert_flip_string_fixed_flag(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *chars, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> flag, size_t size) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> copied = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> goal = min_t(size_t, size - copied, TTY_BUFFER_PAGE); <span class="hljs-comment"><span class="hljs-comment">//      int space = __tty_buffer_request_room(port, goal, flags); //     struct tty_buffer *tb = port-&gt;buf.tail; //       if (unlikely(space == 0)) break; memcpy(char_buf_ptr(tb, tb-&gt;used), chars, space); //      tb-&gt;used += space; copied += space; chars += space; /* There is a small chance that we need to split the data over several buffers. If this is the case we must loop */ } while (unlikely(size &gt; copied)); return copied; }</span></span></code> </pre> <br><p>   , flip buffer        ,       ,         .        ,   ‚Äî        PTM ,             . </p><br><p> ,   "Hello, World!"   PTM .    GNOME Terminal Server    <em>poll()</em> (  I/O)        master .  ,         ?  N√£o importa como.      ,     ,      ‚Äî        . </p><br><p>            <code>tty_flip_buffer_push()</code> (   pty_write): </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * tty_flip_buffer_push - terminal * @port: tty port to push * * Queue a push of the terminal flip buffers to the line discipline. * Can be called from IRQ/atomic context. * * In the event of the queue being busy for flipping the work will be * held off and retried later. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> tty_flip_buffer_push(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port) { tty_schedule_flip(port); }</code> </pre> <br><p>  <code>tty_schedule_flip()</code> ,   ,        : </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * tty_schedule_flip - push characters to ldisc * @port: tty port to push from * * Takes any pending buffers and transfers their ownership to the * ldisc side of the queue. It then schedules those characters for * processing by the line discipline. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> tty_schedule_flip(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_bufhead *buf = &amp;port-&gt;buf; <span class="hljs-comment"><span class="hljs-comment">/* paired w/ acquire in flush_to_ldisc(); ensures * flush_to_ldisc() sees buffer data. */</span></span> smp_store_release(&amp;buf-&gt;tail-&gt;commit, buf-&gt;tail-&gt;used); queue_work(system_unbound_wq, &amp;buf-&gt;work); }</code> </pre> <br><p>   ,     <em>work</em> (,   -       )       ,      ‚Äî    ,    <code>flush_to_ldisc()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> flush_to_ldisc(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> work_struct *work) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port = container_of(work, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port, buf.work); <span class="hljs-comment"><span class="hljs-comment">//   tty_port PTM . tty_port -       TTY  struct tty_bufhead *buf = &amp;port-&gt;buf; struct tty_buffer *head = buf-&gt;head; // ... receive_buf(port, head); // ... }</span></span></code> </pre> <br><p>  <code>receive_buf()</code>          <code>__receive_buf()</code> ,      : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __receive_buf(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *cp, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *fp, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> n_tty_data *ldata = tty-&gt;disc_data; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> preops = I_ISTRIP(tty) || (I_IUCLC(tty) &amp;&amp; L_IEXTEN(tty)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ldata-&gt;real_raw) n_tty_receive_buf_real_raw(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ldata-&gt;raw || (L_EXTPROC(tty) &amp;&amp; !preops)) n_tty_receive_buf_raw(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tty-&gt;closing &amp;&amp; !L_EXTPROC(tty)) n_tty_receive_buf_closing(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ldata-&gt;lnext) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> flag = TTY_NORMAL; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fp) flag = *fp++; n_tty_receive_char_lnext(tty, *cp++, flag); count--; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!preops &amp;&amp; !I_PARMRK(tty)) n_tty_receive_buf_fast(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> n_tty_receive_buf_standard(tty, cp, fp, count); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (read_cnt(ldata)) { kill_fasync(&amp;tty-&gt;fasync, SIGIO, POLL_IN); wake_up_interruptible_poll(&amp;tty-&gt;read_wait, EPOLLIN); } }</code> </pre> <br><p>  ,   <em>n_tty_receive_buf</em> ( ,    _raw)           <strong>read_buf</strong> ,         TTY .      PTM    raw ,           read_buf. ,        PTM  PTS ,     . </p><br><p>       ,   : </p><br><pre> <code class="objectivec hljs"> ... pty_write() -&gt; <span class="hljs-comment"><span class="hljs-comment">// 3- :  PTS  tty_insert_flip_string + tty_flip_buffer_push() -&gt; tty_schedule_flip() -&gt; --- //    PTM  flush_to_ldisc() -&gt; // 2- :   PTM  receive_buf() -&gt; n_tty_receive_buf -&gt; n_tty_receive_buf_common -&gt; __receive_buf()</span></span></code> </pre> <br><p> ,   PTM        ‚Äî         PTS . </p><br><p>  :       PTM .  GNOME Terminal Server      "Hello, World!",  read()  PTM .  read()    write()    ‚Äî  <code>n_tty_read()</code> .      ,  ,          ‚Äî <em>read_buf</em> ‚Äî   .  GNOME Terminal Server    X Server,     . </p><br><p>  ,   "Hello, World!"   : </p><br><pre> <code class="plaintext hljs"> -&gt; PTY slave -&gt; PTY master -&gt; GNOME-TERMINAl-SERVER -&gt; X Server -&gt; -&gt; </code> </pre> <br><hr><br><h2 id="zaklyuchenie">  Conclus√£o </h2><br><p>  .     : </p><br><ol><li>     </li><li>     </li><li>   TTY  </li><li>    </li><li>    ,         </li></ol><br><p>   ,   !     -  ‚Äî     ,   ! </p><br><h3 id="istochniki">  Fontes </h3><br><ul><li> Linux man pages </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://unix.stackexchange.com/q/96694/346664</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://unix.stackexchange.com/q/93531/346664</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://unix.stackexchange.com/q/117981/346664</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://askubuntu.com/q/506510</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.linusakesson.net/programming/tty/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://spin0r.wordpress.com/2012/12/28/terminally-confused-part-seven/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://habr.com/ru/company/neobit/blog/330764/</a> </li><li>  Advanced Programming in the UNIX Environment, 3rd Edition </li></ul><cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt460257/">https://habr.com/ru/post/pt460257/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt460247/index.html">Receitas para ELFs</a></li>
<li><a href="../pt460249/index.html">Solu√ß√£o da tarefa com pwnable.kr 07 - entrada. Entendendo pwntools</a></li>
<li><a href="../pt460251/index.html">Estupidez Artificial: um bot que n√£o me ajudou</a></li>
<li><a href="../pt460253/index.html">10 raz√µes para fazer sua habilidade para assistente de voz</a></li>
<li><a href="../pt460255/index.html">Backdoor no Node.js: por que, por que e como funciona</a></li>
<li><a href="../pt460259/index.html">O que √© design de interface do usu√°rio e UX? O que √© comum e diferente?</a></li>
<li><a href="../pt460261/index.html">Amazon: 25 anos de sucesso no com√©rcio eletr√¥nico</a></li>
<li><a href="../pt460263/index.html">Fazendo uma pesquisa realmente inteligente: guia passo a passo</a></li>
<li><a href="../pt460265/index.html">Criar um modelo de projeto do Xcode</a></li>
<li><a href="../pt460273/index.html">Autoriza√ß√£o no Apple Pay pelo menor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>