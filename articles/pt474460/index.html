<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö∫ üë®‚Äçüç≥ üëÇüèª Descri√ß√£o das arquiteturas de processador no LLVM usando o TableGen üßë üì° üï∫üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No momento, o LLVM j√° se tornou um sistema muito popular, que muitas pessoas usam ativamente para criar v√°rios compiladores, analisadores, etc. Um gra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Descri√ß√£o das arquiteturas de processador no LLVM usando o TableGen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474460/"> No momento, o LLVM j√° se tornou um sistema muito popular, que muitas pessoas usam ativamente para criar v√°rios compiladores, analisadores, etc.  Um grande n√∫mero de materiais √∫teis sobre esse t√≥pico j√° foi escrito, inclusive em russo, o que √© uma boa not√≠cia.  No entanto, na maioria dos casos, o principal vi√©s nos artigos √© feito no LLVM front-end e middle-end.  Obviamente, ao descrever o esquema completo da opera√ß√£o do LLVM, a gera√ß√£o do c√≥digo da m√°quina n√£o √© ignorada, mas basicamente esse t√≥pico √© abordado casualmente, especialmente em publica√ß√µes em russo.  Ao mesmo tempo, o LLVM possui um mecanismo bastante flex√≠vel e interessante para descrever arquiteturas de processadores.  Portanto, esse material ser√° dedicado √† utilidade um tanto negligenciada TableGen, que faz parte do LLVM. <br><br>  A raz√£o pela qual o compilador precisa ter informa√ß√µes sobre a arquitetura de cada uma das plataformas de destino √© bastante √≥bvia.  Naturalmente, cada modelo de processador possui seu pr√≥prio conjunto de registros, suas pr√≥prias instru√ß√µes de m√°quina, etc.  E o compilador precisa ter todas as informa√ß√µes necess√°rias sobre eles para poder gerar c√≥digo de m√°quina v√°lido e eficiente.  O compilador resolve v√°rias tarefas espec√≠ficas da plataforma: distribui registros, etc.  Al√©m disso, os back-ends do LLVM tamb√©m realizam otimiza√ß√µes no IR da m√°quina, mais pr√≥ximo das instru√ß√µes reais ou nas pr√≥prias instru√ß√µes do montador.  Nessas otimiza√ß√µes, as instru√ß√µes precisam ser substitu√≠das e transformadas; portanto, todas as informa√ß√µes sobre elas devem estar dispon√≠veis. <br><a name="habracut"></a><br>  Para resolver o problema de descrever a arquitetura do processador, o LLVM adotou um √∫nico formato para determinar as propriedades do processador necess√°rias para o compilador.  Para cada arquitetura suportada, um <code>.td</code> cont√©m uma descri√ß√£o em um idioma formal especial.  Ele √© convertido em arquivos <code>.inc</code> ao criar o compilador usando o utilit√°rio TableGen inclu√≠do no LLVM.  Os arquivos resultantes, de fato, s√£o de origem C, mas t√™m uma extens√£o separada, provavelmente, apenas para que esses arquivos gerados automaticamente possam ser facilmente distinguidos e filtrados.  A documenta√ß√£o oficial do TableGen est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> e fornece todas as informa√ß√µes necess√°rias, h√° tamb√©m uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">descri√ß√£o formal do idioma</a> e uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">introdu√ß√£o geral</a> . <br><br>  Obviamente, esse √© um t√≥pico muito extenso, onde h√° muitos detalhes sobre os quais voc√™ pode escrever artigos individuais.  Neste artigo, consideramos simplesmente os pontos b√°sicos da descri√ß√£o dos processadores, mesmo sem uma vis√£o geral de todos os recursos. <br><br><h2>  Descri√ß√£o da arquitetura no arquivo .td </h2><br>  Portanto, a linguagem de descri√ß√£o formal usada no TableGen possui recursos semelhantes √†s linguagens de programa√ß√£o comuns e permite descrever as caracter√≠sticas da arquitetura em um estilo declarativo.  E pelo que entendi, esse idioma tamb√©m √© chamado de TableGen.  I.e.  Neste artigo, o TableGen usa o nome da pr√≥pria linguagem formal e o utilit√°rio que gera os artefatos resultantes. <br><br>  Os processadores modernos s√£o sistemas muito complexos, portanto, n√£o √© de surpreender que sua descri√ß√£o seja bastante volumosa.  Dessa forma, para criar a estrutura e simplificar a manuten√ß√£o de arquivos <code>.td</code> podemos incluir um ao outro usando a diretiva <code>#include</code> usual para programadores C.  Com a ajuda dessa diretiva, o arquivo <code>Target.td</code> √© sempre inclu√≠do primeiro, contendo interfaces independentes de plataforma que devem ser implementadas para fornecer todas as informa√ß√µes necess√°rias sobre TableGen.  Esse arquivo j√° inclui um arquivo <code>.td</code> com descri√ß√µes intr√≠nsecas do LLVM, mas, por si s√≥, cont√©m principalmente classes base, como <code>Register</code> , <code>Instruction</code> , <code>Processor</code> etc., das quais voc√™ precisa herdar para criar sua pr√≥pria arquitetura para o compilador com base em LLVM.  A partir da senten√ßa anterior, fica claro que o TableGen possui a no√ß√£o de classes conhecida por todos os programadores. <br><br>  Em geral, o TableGen possui apenas duas entidades b√°sicas: <b>classes</b> e <b>defini√ß√µes</b> . <br><br><h3>  Aulas </h3><br>  As classes TableGen tamb√©m s√£o abstra√ß√µes, como em todas as linguagens de programa√ß√£o orientadas a objetos, mas s√£o entidades mais simples. <br><br>  As classes podem ter par√¢metros e campos e tamb√©m podem herdar outras classes. <br>  Por exemplo, uma das classes base √© apresentada abaixo. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// A class representing the register size, spill size and spill alignment // in bits of a register. class RegInfo&lt;int RS, int SS, int SA&gt; { int RegSize = RS; // Register size in bits. int SpillSize = SS; // Spill slot size in bits. int SpillAlignment = SA; // Spill slot alignment in bits. }</span></span></code> </pre> <br>  Os colchetes angulares indicam os par√¢metros de entrada atribu√≠dos √†s propriedades da classe.  Neste exemplo, voc√™ tamb√©m pode observar que o idioma do TableGen √© estaticamente digitado.  Os tipos que existem no TableGen: <code>bit</code> (um an√°logo do tipo Booleano com valores 0 e 1), <code>int</code> , <code>string</code> , <code>code</code> (um peda√ßo de c√≥digo, esse √© um tipo, simplesmente porque o TableGen n√£o possui m√©todos e fun√ß√µes no sentido usual, as linhas de c√≥digo s√£o escritas em <code>[{ ... }]</code> bits &lt;n&gt;, lista &lt;tipo&gt; (os valores s√£o definidos usando colchetes [...] como no Python e em outras linguagens de programa√ß√£o), <code>class type</code> , <code>dag</code> . <br><br>  A maioria dos tipos deve ser entendida, mas se tiverem perguntas, todas ser√£o descritas em detalhes na especifica√ß√£o do idioma, dispon√≠vel no link fornecido no in√≠cio do artigo. <br><br>  A heran√ßa tamb√©m √© descrita por uma sintaxe bastante familiar com <code>:</code> <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X86MemOperand</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">printMethod</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsmOperandClass</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parserMatchClass</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X86MemAsmOperand</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Operand</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iPTR</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">PrintMethod</span></span> = printMethod; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">MIOperandInfo</span></span> = (ops ptr_rc, i8imm, ptr_rc_nosp, i32imm, <span class="hljs-type"><span class="hljs-type">SEGMENT_REG</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">ParserMatchClass</span></span> = parserMatchClass; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">OperandType</span></span> = <span class="hljs-string"><span class="hljs-string">"OPERAND_MEMORY"</span></span>; }</code> </pre> <br>  Nesse caso, a classe criada, √© claro, pode substituir os valores dos campos especificados na classe base usando a palavra-chave <code>let</code> .  E pode adicionar seus pr√≥prios campos semelhantes √† descri√ß√£o fornecida no exemplo anterior, indicando o tipo de campo. <br><br><h3>  Defini√ß√µes </h3><br>  As defini√ß√µes j√° s√£o entidades concretas, voc√™ pode compar√°-las com o familiar para todos os objetos.  As defini√ß√µes s√£o definidas usando a palavra-chave <code>def</code> e podem implementar uma classe, redefinir os campos das classes base exatamente da mesma maneira como descrito acima, e tamb√©m possuem seus pr√≥prios campos. <br><br><pre> <code class="swift hljs">def i8mem : <span class="hljs-type"><span class="hljs-type">X86MemOperand</span></span>&lt;<span class="hljs-string"><span class="hljs-string">"printbytemem"</span></span>, <span class="hljs-type"><span class="hljs-type">X86Mem8AsmOperand</span></span>&gt;; def <span class="hljs-type"><span class="hljs-type">X86AbsMemAsmOperand</span></span> : <span class="hljs-type"><span class="hljs-type">AsmOperandClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">Name</span></span> = <span class="hljs-string"><span class="hljs-string">"AbsMem"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">SuperClasses</span></span> = [<span class="hljs-type"><span class="hljs-type">X86MemAsmOperand</span></span>]; }</code> </pre><br><h3>  Multiclasses </h3><br>  Naturalmente, um grande n√∫mero de instru√ß√µes nos processadores possui sem√¢ntica semelhante.  Por exemplo, pode haver um conjunto de instru√ß√µes de tr√™s endere√ßos que assumem as duas formas <code>‚Äúreg = reg op reg‚Äù</code> e <code>‚Äúreg = reg op imm‚Äù</code> .  Em um caso, os valores s√£o retirados dos registradores e o resultado tamb√©m √© salvo no registrador; no outro, o segundo operando √© um valor constante (operando im-imediato). <br><br>  Listar todas as combina√ß√µes manualmente √© um tanto tedioso; o risco de cometer um erro aumenta.  Obviamente, eles podem ser gerados automaticamente escrevendo um script simples, mas isso n√£o √© necess√°rio, porque existe um conceito como multiclasses na linguagem TableGen. <br><br><pre> <code class="cpp hljs">multiclass ri_inst&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> opc, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> asmstr&gt; { def _rr : inst&lt;opc, !strconcat(asmstr, <span class="hljs-string"><span class="hljs-string">" $dst, $src1, $src2"</span></span>), (ops GPR:$dst, GPR:$src1, GPR:$src2)&gt;; def _ri : inst&lt;opc, !strconcat(asmstr, <span class="hljs-string"><span class="hljs-string">" $dst, $src1, $src2"</span></span>), (ops GPR:$dst, GPR:$src1, Imm:$src2)&gt;; }</code> </pre> <br>  Dentro de v√°rias classes, voc√™ precisa descrever todas as formas poss√≠veis de instru√ß√µes usando a palavra-chave <code>def</code> .  Mas essa n√£o √© uma forma completa de instru√ß√µes a serem geradas.  Ao mesmo tempo, voc√™ pode redefinir os campos neles e fazer tudo o que √© poss√≠vel nas defini√ß√µes usuais.  Para criar defini√ß√µes reais com base em uma <code>defm</code> , √© necess√°rio usar a palavra-chave <code>defm</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Instantiations of the ri_inst multiclass. defm ADD : ri_inst&lt;0b111, "add"&gt;; defm SUB : ri_inst&lt;0b101, "sub"&gt;; defm MUL : ri_inst&lt;0b100, "mul"&gt;;</span></span></code> </pre> <br>  E, como resultado, para cada defini√ß√£o dada por meio de <code>defm</code> de fato, v√°rias defini√ß√µes ser√£o constru√≠das que s√£o uma combina√ß√£o da instru√ß√£o principal e de todas as formas poss√≠veis descritas na multiclasse.  Como resultado, as seguintes instru√ß√µes ser√£o geradas neste exemplo: <code>ADD_rr</code> , <code>ADD_ri</code> , <code>SUB_rr</code> , <code>SUB_ri</code> , <code>MUL_rr</code> , <code>MUL_ri</code> . <br><br>  Multiclasses podem conter n√£o apenas defini√ß√µes com <code>def</code> , mas tamb√©m <code>defm</code> aninhado, permitindo assim a gera√ß√£o de formas complexas de instru√ß√µes.  Um exemplo que ilustra a cria√ß√£o de tais cadeias pode ser encontrado na documenta√ß√£o oficial. <br><br><h3>  Subtargets </h3><br>  Outra coisa b√°sica e √∫til para processadores que t√™m diferentes varia√ß√µes do conjunto de instru√ß√µes √© o suporte ao subtarget no LLVM.  Um exemplo de uso √© a implementa√ß√£o LLVM SPARC, que abrange tr√™s vers√µes principais da arquitetura do microprocessador SPARC de uma vez: Vers√£o 8 (V8, arquitetura de 32 bits), Vers√£o 9 (V9, arquitetura de 64 bits) e arquitetura UltraSPARC.  A diferen√ßa entre as arquiteturas √© bastante grande, um n√∫mero diferente de registros de diferentes tipos, ordem de bytes suportados etc.  Nesses casos, se houver v√°rias configura√ß√µes, vale a pena implementar a classe <code>XXXSubtarget</code> para a arquitetura.  O uso dessa classe na descri√ß√£o resultar√° em novas op√ß√µes de linha de comando <code>-mcpu=</code> e <code>-mattr=</code> . <br><br>  Al√©m da <code>Subtarget</code> classe <code>Subtarget</code> , a classe <code>Subtarget</code> importante. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SubtargetFeature</span></span></span><span class="hljs-class">&lt;string n, string a, string v, string d, list&lt;SubtargetFeature&gt; i = []&gt; {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Name = n; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Attribute = a; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Value = v; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Desc = d; <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;SubtargetFeature&gt; Implies = i; }</code> </pre> <br>  No arquivo <code>Sparc.td</code> , voc√™ pode encontrar exemplos da implementa√ß√£o do <code>SubtargetFeature</code> , que permitem descrever a disponibilidade de um conjunto de instru√ß√µes para cada subtipo individual da arquitetura. <br><br><pre> <code class="cpp hljs">def FeatureV9 : SubtargetFeature&lt;<span class="hljs-string"><span class="hljs-string">"v9"</span></span>, <span class="hljs-string"><span class="hljs-string">"IsV9"</span></span>, <span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-string"><span class="hljs-string">"Enable SPARC-V9 instructions"</span></span>&gt;; def FeatureV8Deprecated : SubtargetFeature&lt;<span class="hljs-string"><span class="hljs-string">"deprecated-v8"</span></span>, <span class="hljs-string"><span class="hljs-string">"V8DeprecatedInsts"</span></span>, <span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-string"><span class="hljs-string">"Enable deprecated V8 instructions in V9 mode"</span></span>&gt;; def FeatureVIS : SubtargetFeature&lt;<span class="hljs-string"><span class="hljs-string">"vis"</span></span>, <span class="hljs-string"><span class="hljs-string">"IsVIS"</span></span>, <span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-string"><span class="hljs-string">"Enable UltraSPARC Visual Instruction Set extensions"</span></span>&gt;;</code> </pre><br>  Nesse caso, de qualquer maneira, <code>Sparc.td</code> ainda define a classe <code>Proc</code> , que √© usada para descrever subtipos espec√≠ficos de processadores SPARC, que podem ter apenas as propriedades descritas acima, incluindo diferentes conjuntos de instru√ß√µes. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Proc</span></span></span><span class="hljs-class">&lt;string Name, list&lt;SubtargetFeature&gt; Features&gt; :</span></span> Processor&lt;Name, NoItineraries, Features&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"generic"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"v8"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"supersparc"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"sparclite"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"f934"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"hypersparc"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"sparclite86x"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"sparclet"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"tsc701"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"v9"</span></span>, [FeatureV9]&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"ultrasparc"</span></span>, [FeatureV9, FeatureV8Deprecated]&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"ultrasparc3"</span></span>, [FeatureV9, FeatureV8Deprecated]&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"ultrasparc3-vis"</span></span>, [FeatureV9, FeatureV8Deprecated, FeatureVIS]&gt;;</code> </pre> <br><h2>  Rela√ß√£o entre as propriedades das instru√ß√µes em TableGen e o c√≥digo de back-end do LLVM </h2><br>  As propriedades de classes e defini√ß√µes permitem gerar e configurar corretamente os recursos de arquitetura, mas n√£o h√° acesso direto a eles a partir do c√≥digo-fonte de back-end do LLVM.  No entanto, √†s vezes voc√™ deseja obter algumas propriedades de instru√ß√µes espec√≠ficas da plataforma diretamente no c√≥digo do compilador. <br><br><h3>  TSFlags </h3><br>  Para fazer isso, a classe base <code>Instruction</code> possui um campo <code>TSFlags</code> especial, tamanho de 64 bits, que √© convertido por TableGen em um campo de objetos C ++ da classe <code>MCInstrDesc</code> , gerados com base nos dados recebidos da descri√ß√£o TableGen.  Voc√™ pode especificar qualquer n√∫mero de bits necess√°rio para armazenar informa√ß√µes.  Pode ser algum valor booleano, por exemplo, para indicar que estamos usando uma ALU escalar. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">TSFlags</span></span>{<span class="hljs-number"><span class="hljs-number">0</span></span>} = <span class="hljs-type"><span class="hljs-type">SALU</span></span>;</code> </pre> <br>  Ou podemos armazenar o tipo de instru√ß√£o.  Ent√£o precisamos, √© claro, de mais de um pouco. <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// Instruction type according to the ISA. IType Type = type; let TSFlags{7-1} = Type.Value;</span></span></code> </pre> <br>  Como resultado, torna-se poss√≠vel obter essas propriedades da instru√ß√£o no c√≥digo de back-end. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isSALU = MI.getDesc().TSFlags &amp; SIInstrFlags::SALU;</code> </pre> <br>  Se a propriedade for mais complexa, voc√™ poder√° compar√°-la com o valor descrito em TableGen, que ser√° adicionado √† enumera√ß√£o gerada automaticamente. <br><br><pre> <code class="cpp hljs">(Desc.TSFlags &amp; X86II::FormMask) == X86II::MRMSrcMem</code> </pre> <br><br><h3>  Predicados de fun√ß√£o </h3><br>  Al√©m disso, os predicados de fun√ß√£o podem ser usados ‚Äã‚Äãpara obter as informa√ß√µes necess√°rias sobre as instru√ß√µes.  Com a ajuda deles, voc√™ pode mostrar ao TableGen que voc√™ precisa gerar uma fun√ß√£o que estar√° dispon√≠vel no c√≥digo de back-end.  A classe base com a qual voc√™ pode criar essa defini√ß√£o de fun√ß√£o √© apresentada abaixo. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Base class for function predicates. class FunctionPredicateBase&lt;string name, MCStatement body&gt; { string FunctionName = name; MCStatement Body = body; }</span></span></code> </pre> <br>  Voc√™ pode encontrar facilmente exemplos de uso no back-end para X86.  Portanto, h√° sua pr√≥pria classe intermedi√°ria, com a ajuda da qual as defini√ß√µes necess√°rias de fun√ß√µes j√° foram criadas. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Check that a call to method `Name` in class "XXXInstrInfo" (where XXX is // the name of a target) returns true. // // TIIPredicate definitions are used to model calls to the target-specific // InstrInfo. A TIIPredicate is treated specially by the InstrInfoEmitter // tablegen backend, which will use it to automatically generate a definition in // the target specific `InstrInfo` class. // // There cannot be multiple TIIPredicate definitions with the same name for the // same target class TIIPredicate&lt;string Name, MCStatement body&gt; : FunctionPredicateBase&lt;Name, body&gt;, MCInstPredicate; // This predicate evaluates to true only if the input machine instruction is a // 3-operands LEA. Tablegen automatically generates a new method for it in // X86GenInstrInfo. def IsThreeOperandsLEAFn : TIIPredicate&lt;"isThreeOperandsLEA", IsThreeOperandsLEABody&gt;; //   -    ,  -  ,       // Used to generate the body of a TII member function. def IsThreeOperandsLEABody : MCOpcodeSwitchStatement&lt;[LEACases], MCReturnStatement&lt;FalsePred&gt;&gt;;</span></span></code> </pre> <br>  Como resultado, voc√™ pode usar o m√©todo <code>isThreeOperandsLEA</code> no c√≥digo C ++. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(TII-&gt;isThreeOperandsLEA(MI) || hasInefficientLEABaseReg(Base, Index)) || !TII-&gt;isSafeToClobberEFLAGS(MBB, MI) || Segment.getReg() != X86::NoRegister) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br>  Aqui, TII √© a informa√ß√£o da instru√ß√£o de destino, que pode ser obtida usando o m√©todo <code>getInstrInfo()</code> do <code>MCSubtargetInfo</code> para a arquitetura desejada. <br><br><h2>  Transforma√ß√£o de instru√ß√µes durante otimiza√ß√µes.  Mapeamento de instru√ß√µes </h2><br>  Durante um grande n√∫mero de otimiza√ß√µes realizadas nos est√°gios posteriores da compila√ß√£o, geralmente surge a tarefa de converter todas ou apenas parte das instru√ß√µes de um formul√°rio em instru√ß√µes de outro formul√°rio.  Dada a aplica√ß√£o das multiclasses descritas no in√≠cio, podemos ter um grande n√∫mero de instru√ß√µes com propriedades e sem√¢nticas semelhantes.  No c√≥digo, essas transforma√ß√µes, √© claro, poderiam ser escritas na forma de grandes constru√ß√µes de <code>switch-case</code> , que para cada instru√ß√£o esmagavam a transforma√ß√£o correspondente.  Parcialmente, essas enormes constru√ß√µes podem ser reduzidas com a ajuda de macros, que formariam o nome necess√°rio da instru√ß√£o de acordo com regras conhecidas.  Mas, ainda assim, essa abordagem √© muito inconveniente, √© dif√≠cil de manter devido ao fato de todos os nomes de instru√ß√µes serem listados explicitamente.  Adicionar uma nova instru√ß√£o pode facilmente levar a um erro, porque  lembre-se de adicion√°-lo a todas as convers√µes relevantes.  Tendo sido atormentado com essa abordagem, o LLVM criou um mecanismo especial para converter eficientemente uma forma de instru√ß√£o em outro <code>Instruction Mapping</code> . <br><br>  A ideia √© muito simples, √© necess√°rio descrever poss√≠veis modelos para transformar instru√ß√µes diretamente no TableGen.  Portanto, no LLVM TableGen, h√° uma classe base para descrever esses modelos. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InstrMapping</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// Used to reduce search space only to the instructions using this // relation model. string FilterClass; // List of fields/attributes that should be same for all the instructions in // a row of the relation table. Think of this as a set of properties shared // by all the instructions related by this relationship. list&lt;string&gt; RowFields = []; // List of fields/attributes that are same for all the instructions // in a column of the relation table. list&lt;string&gt; ColFields = []; // Values for the fields/attributes listed in 'ColFields' corresponding to // the key instruction. This is the instruction that will be transformed // using this relation model. list&lt;string&gt; KeyCol = []; // List of values for the fields/attributes listed in 'ColFields', one for // each column in the relation table. These are the instructions a key // instruction will be transformed into. list&lt;list&lt;string&gt; &gt; ValueCols = []; }</span></span></code> </pre> <br>  Vejamos um exemplo que √© dado na documenta√ß√£o.  Os exemplos que podem ser encontrados no c√≥digo fonte s√£o agora ainda mais simples, pois apenas duas colunas s√£o obtidas na tabela final.  No c√≥digo de back-end, voc√™ pode encontrar a convers√£o de formul√°rios antigos para novas formas de instru√ß√µes, instru√ß√µes dsp em mmdsp, etc., descritas usando o Mapeamento de Instru√ß√µes.  De fato, esse mecanismo n√£o √© t√£o amplamente usado at√© agora, simplesmente porque a maioria dos back-end come√ßou a ser criada antes de aparecer e, para que funcione, voc√™ ainda precisa definir as propriedades corretas para as instru√ß√µes, portanto, mudar para ele nem sempre √© f√°cil, talvez seja necess√°rio refatora√ß√£o. <br><br>  Ent√£o, por exemplo.  Suponha que tenhamos formas de instru√ß√µes sem predicados e instru√ß√µes em que o predicado √© respectivamente verdadeiro e falso.  N√≥s os descrevemos com a ajuda de uma classe m√∫ltipla e uma classe especial, que usaremos apenas como filtro.  Uma descri√ß√£o simplificada sem par√¢metros e muitas propriedades pode ser algo assim. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PredRel</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">multiclass</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInstruction</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">BaseOpcode</span></span> = name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> { def : <span class="hljs-type"><span class="hljs-type">PredRel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">PredSense</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span>; } def _pt: <span class="hljs-type"><span class="hljs-type">PredRel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">PredSense</span></span> = <span class="hljs-string"><span class="hljs-string">"true"</span></span>; } def _pf: <span class="hljs-type"><span class="hljs-type">PredRel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">PredSense</span></span> = <span class="hljs-string"><span class="hljs-string">"false"</span></span>; } } } defm <span class="hljs-type"><span class="hljs-type">ADD</span></span>: <span class="hljs-type"><span class="hljs-type">MyInstruction</span></span>&lt;‚Äù<span class="hljs-type"><span class="hljs-type">ADD</span></span>‚Äù&gt;; defm <span class="hljs-type"><span class="hljs-type">SUB</span></span>: <span class="hljs-type"><span class="hljs-type">MyIntruction</span></span>&lt;‚Äù<span class="hljs-type"><span class="hljs-type">SUB</span></span>‚Äù&gt;; defm <span class="hljs-type"><span class="hljs-type">MUL</span></span>: <span class="hljs-type"><span class="hljs-type">MyInstruction</span></span>&lt;‚Äù<span class="hljs-type"><span class="hljs-type">MUL</span></span>‚Äù&gt;; ‚Ä¶</code> </pre> <br>  Neste exemplo, a prop√≥sito, tamb√©m √© mostrado como substituir uma propriedade por v√°rias defini√ß√µes de uma s√≥ vez usando a constru√ß√£o <code>let ‚Ä¶ in</code> .  Como resultado, temos muitas instru√ß√µes que armazenam seu nome base e propriedade que descrevem exclusivamente seu formul√°rio.  Ent√£o voc√™ pode criar um modelo de transforma√ß√£o. <br><br><pre> <code class="swift hljs">def getPredOpcode : <span class="hljs-type"><span class="hljs-type">InstrMapping</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,       - PredRel  let FilterClass = "PredRel"; //         ,      let RowFields = ["BaseOpcode"]; //          PredSense. let ColFields = ["PredSense"]; //  ,  ,       ,     PredSense=‚Äù‚Äù let KeyCol = [""]; //   PredSense      let ValueCols = [["true"], ["false"]]; }</span></span></code> </pre> <br>  Como resultado, a tabela a seguir ser√° gerada a partir dessa descri√ß√£o. <br><br><div class="scrollable-table"><table><tbody><tr><th>  PredSense = "" </th><th>  PredSense = "verdadeiro" </th><th>  PredSense = "falso" </th></tr><tr><td>  ADICIONAR </td><td>  ADD_pt </td><td>  ADD_pf </td></tr><tr><td>  SUB </td><td>  SUB_pt </td><td>  SUB_pf </td></tr><tr><td>  Mul </td><td>  MUL_pt </td><td>  MUL_pf </td></tr></tbody></table></div><br>  Uma fun√ß√£o ser√° gerada no arquivo <code>.inc</code> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPredOpcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Opcode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">enum</span></span></span></span><span class="hljs-function"><span class="hljs-params"> PredSense inPredSense)</span></span></span></span></code> </pre> <br>  Que, consequentemente, aceita um c√≥digo de instru√ß√£o para convers√£o e o valor da enumera√ß√£o gerada automaticamente do PredSense, que cont√©m todos os valores poss√≠veis nas colunas.  A implementa√ß√£o desta fun√ß√£o √© muito simples, porque  retorna o elemento de matriz desejado para a instru√ß√£o de seu interesse. <br><br>  E no c√≥digo de back-end, em vez de escrever uma <code>switch-case</code> basta chamar a fun√ß√£o gerada, que retornar√° o c√≥digo da instru√ß√£o convertida.  Uma solu√ß√£o simples, onde adicionar novas instru√ß√µes, n√£o levar√° √† necessidade de a√ß√£o adicional. <br><br><h2>  Artefatos gerados <code>.inc</code> (arquivos <code>.inc</code> ) </h2><br>  Toda a intera√ß√£o entre a descri√ß√£o do TableGen e o c√≥digo de back-end do LLVM √© garantida pelos arquivos <code>.inc</code> gerados que cont√™m o c√≥digo C.  Para obter uma imagem completa, vamos ver um pouco o que exatamente eles s√£o. <br><br>  Ap√≥s cada constru√ß√£o, para cada arquitetura, haver√° v√°rios arquivos <code>.inc</code> no diret√≥rio de constru√ß√£o, cada um dos quais armazena informa√ß√µes separadas sobre a arquitetura.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, h√° um arquivo </font></font><code>&lt;TargetName&gt;GenInstrInfo.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que cont√©m informa√ß√µes sobre as instru√ß√µes </font></font><code>&lt;TargetName&gt;GenRegisterInfo.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, respectivamente, que cont√©m informa√ß√µes sobre os registros, existem arquivos para trabalhar diretamente com a montadora e sua sa√≠da </font></font><code>&lt;TargetName&gt;GenAsmMatcher.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>&lt;TargetName&gt;GenAsmWriter.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">etc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ent√£o, no que esses arquivos consistem? Em geral, eles cont√™m enumera√ß√µes, matrizes, estruturas e fun√ß√µes simples. Por exemplo, voc√™ pode ver as informa√ß√µes convertidas nas instru√ß√µes em </font></font><code>&lt;TargetName&gt;GenInstrInfo.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na primeira parte, no espa√ßo de nomes com o nome do destino, h√° uma enumera√ß√£o contendo todas as instru√ß√µes que foram descritas.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> X86 { <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { PHI = <span class="hljs-number"><span class="hljs-number">0</span></span>, ‚Ä¶ ADD16i16 = <span class="hljs-number"><span class="hljs-number">287</span></span>, ADD16mi = <span class="hljs-number"><span class="hljs-number">288</span></span>, ADD16mi8 = <span class="hljs-number"><span class="hljs-number">289</span></span>, ADD16mr = <span class="hljs-number"><span class="hljs-number">290</span></span>, ADD16ri = <span class="hljs-number"><span class="hljs-number">291</span></span>, ADD16ri8 = <span class="hljs-number"><span class="hljs-number">292</span></span>, ADD16rm = <span class="hljs-number"><span class="hljs-number">293</span></span>, ADD16rr = <span class="hljs-number"><span class="hljs-number">294</span></span>, ADD16rr_REV = <span class="hljs-number"><span class="hljs-number">295</span></span>, ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A seguir, √© apresentada uma matriz que descreve as propriedades das instru√ß√µes </font></font><code>const MCInstrDesc X86Insts[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">As seguintes matrizes cont√™m informa√ß√µes sobre nomes de instru√ß√µes, etc. </font><font style="vertical-align: inherit;">Basicamente, todas as informa√ß√µes s√£o armazenadas em transfer√™ncias e matrizes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tamb√©m h√° fun√ß√µes que foram descritas usando predicados. </font><font style="vertical-align: inherit;">Com base na defini√ß√£o de predicado de fun√ß√£o discutida na se√ß√£o anterior, a seguinte fun√ß√£o ser√° gerada.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> X86InstrInfo::isThreeOperandsLEA(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MachineInstr &amp;MI) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(MI.getOpcode()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> X86::LEA32r: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> X86::LEA64r: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> X86::LEA64_32r: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> X86::LEA16r: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( MI.getOperand(<span class="hljs-number"><span class="hljs-number">1</span></span>).isReg() &amp;&amp; MI.getOperand(<span class="hljs-number"><span class="hljs-number">1</span></span>).getReg() != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; MI.getOperand(<span class="hljs-number"><span class="hljs-number">3</span></span>).isReg() &amp;&amp; MI.getOperand(<span class="hljs-number"><span class="hljs-number">3</span></span>).getReg() != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; ( ( MI.getOperand(<span class="hljs-number"><span class="hljs-number">4</span></span>).isImm() &amp;&amp; MI.getOperand(<span class="hljs-number"><span class="hljs-number">4</span></span>).getImm() != <span class="hljs-number"><span class="hljs-number">0</span></span> ) || (MI.getOperand(<span class="hljs-number"><span class="hljs-number">4</span></span>).isGlobal()) ) ); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// end of switch-stmt }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas existem dados nos arquivos e estruturas gerados. </font><font style="vertical-align: inherit;">Em </font></font><code>X86GenSubtargetInfo.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">voc√™ pode encontrar um exemplo da estrutura que deve ser usada no c√≥digo de back-end para obter informa√ß√µes sobre a arquitetura, por meio dela, na se√ß√£o anterior, descobriu-se TTI.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X86GenMCSubtargetInfo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MCSubtargetInfo { X86GenMCSubtargetInfo(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Triple &amp;TT, StringRef CPU, StringRef FS, ArrayRef&lt;SubtargetFeatureKV&gt; PF, ArrayRef&lt;SubtargetSubTypeKV&gt; PD, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MCWriteProcResEntry *WPR, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MCWriteLatencyEntry *WL, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MCReadAdvanceEntry *RA, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InstrStage *IS, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> *OC, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> *FP) : MCSubtargetInfo(TT, CPU, FS, PF, PD, WPR, WL, RA, IS, OC, FP) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolveVariantSchedClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SchedClass, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MCInst *MI, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CPUID)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> X86_MC::resolveVariantSchedClassImpl(SchedClass, MI, CPUID); } };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se usado </font></font><code>Subtarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para descrever v√°rias configura√ß√µes </font></font><code>XXXGenSubtarget.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, uma enumera√ß√£o ser√° criada com as propriedades descritas usando </font></font><code>SubtargetFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">matrizes com valores constantes para indicar as caracter√≠sticas e subtipos da CPU, e ser√° gerada uma fun√ß√£o </font></font><code>ParseSubtargetFeatures</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que processa a sequ√™ncia com o conjunto de op√ß√µes </font></font><code>Subtarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Al√©m disso, a implementa√ß√£o do m√©todo </font></font><code>XXXSubtarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no c√≥digo de back-end deve corresponder ao seguinte pseudo-c√≥digo, no qual √© necess√°rio usar esta fun√ß√£o:</font></font><br><br><pre> <code class="cpp hljs">XXXSubtarget::XXXSubtarget(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Module &amp;M, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;FS) { <span class="hljs-comment"><span class="hljs-comment">// Set the default features // Determine default and user specified characteristics of the CPU // Call ParseSubtargetFeatures(FS, CPU) to parse the features string // Perform any additional operations }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apesar de os </font></font><code>.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arquivos serem muito volumosos e conterem grandes matrizes, isso permite otimizar o tempo de acesso √†s informa√ß√µes, pois o acesso a um elemento da matriz tem um tempo constante. </font><font style="vertical-align: inherit;">As fun√ß√µes de pesquisa geradas por instru√ß√µes s√£o implementadas usando um algoritmo de pesquisa bin√°ria para minimizar o tempo de opera√ß√£o. </font><font style="vertical-align: inherit;">Portanto, o armazenamento nesta forma √© bastante justificado.</font></font><br><br><h2>  Conclus√£o </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, gra√ßas ao TableGen no LLVM, temos descri√ß√µes de arquitetura leg√≠veis e facilmente suportadas em um √∫nico formato com v√°rios mecanismos para interagir e acessar informa√ß√µes do c√≥digo-fonte de back-end do LLVM para otimiza√ß√µes e gera√ß√£o de c√≥digo. </font><font style="vertical-align: inherit;">Ao mesmo tempo, essa descri√ß√£o n√£o afeta o desempenho do compilador devido ao c√≥digo gerado automaticamente que usa solu√ß√µes e estruturas de dados eficientes.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt474460/">https://habr.com/ru/post/pt474460/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt474444/index.html">Mais 5 projetos de treinamento ousados ‚Äã‚Äãpara o desenvolvedor (Camada, Squoosh, Calculadora, Rastreador de sites, Leitor de m√∫sica)</a></li>
<li><a href="../pt474448/index.html">O que o c√©rebro de um estudante no mundo da computa√ß√£o √© capaz</a></li>
<li><a href="../pt474450/index.html">Pare de usar TTL ridiculamente pequeno para DNS</a></li>
<li><a href="../pt474452/index.html">Relat√≥rio de status de outono Haxe</a></li>
<li><a href="../pt474458/index.html">Total acumulado em SQL</a></li>
<li><a href="../pt474462/index.html">Enorme conjunto de dados aberto da vers√£o 1.0 do discurso russo</a></li>
<li><a href="../pt474466/index.html">Hist√≥ria do primeiro Diablo</a></li>
<li><a href="../pt474470/index.html">Ataque DDoS aos servi√ßos RDP: reconhe√ßa e supere. Experi√™ncia bem sucedida de Tucha</a></li>
<li><a href="../pt474472/index.html">Lista de verifica√ß√£o UX de 30 pontos para aplicativos m√≥veis</a></li>
<li><a href="../pt474474/index.html">Benchmarks abertos para teste de carga de servidores e aplicativos da web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>