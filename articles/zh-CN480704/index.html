<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧝🏽 🍨 ☮️ 在网站上进行响应式内容加载 💘 👦🏽 😞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 

 我正在为我的项目建立一个网站。 在网站上，您需要同时显示很多GIF，每个GIF都很好。 如果一次显示所有内容，则页面加载时间很长。 同时，提供没有GIF的页面（以便可以在此处下载）也是不可能的。 

 任何对我如何处理此问题感兴趣的人，我都会要求猫。 

 其实问题是 
 就像我说的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在网站上进行响应式内容加载</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480704/"> 哈Ha！ <br><br> 我正在为我的项目建立一个网站。 在网站上，您需要同时显示很多GIF，每个GIF都很好。 如果一次显示所有内容，则页面加载时间很长。 同时，提供没有GIF的页面（以便可以在此处下载）也是不可能的。 <br><br> 任何对我如何处理此问题感兴趣的人，我都会要求猫。 <br><a name="habracut"></a><br><h2> 其实问题是 </h2><br> 就像我说的，网站上有非常多的gif，不同而不同。 您可以自己查看其中的多少个： <a href="https://reface.tech/">reface.tech</a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/468/0e4/bb9/4680e4bb9c37c109cfbb02929ac29633.jpg" alt="图片"><br><br> 看到该着陆程序的Beta版后，我立即遇到了加载问题：对于某些用户，页面已加载了很长时间。 对于一个严肃的企业，当然不是这样。 <br><br> 有必要以某种方式解决这个问题。 简单的无损压缩是不可能实现的，因为那时所有媒体内容都已经通过<a href="https://compressor.io/">compressor.io</a>驱动了。 因此，有必要压缩损失并赋予GIF较差的质量。 <br><br> 但是向拥有良好互联网的用户提供不良媒体内容是一种牺牲。 因此，决定以某种方式确定Internet的速度，并根据速度来确定适当的质量。 <br><br><h2> 我们做一个粗略的草图 </h2><br> 我们将有一个数组，其中包含要加载的媒体内容的描述。 <br><br> 一个例子： <br><br><pre><code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"large"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">0.6211118698120117</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"gifs/control/large/control_1.gif"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"middle"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">0.5330495834350586</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"gifs/control/middle/control_1.gif"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"small"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">0.4901447296142578</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"gifs/control/small/control_1.gif"</span></span> } } ]</code> </pre> <br> 在适当质量的基本要素中，这里是url和文件大小。 <br><br> 我们将简单地： <br><br><ol><li> 遍历数组（加载页面时） </li><li> 阅读每种质量等级加载的总大小 </li><li> 确定是否会在4秒内加载所有内容（这是个人困扰我的时间） </li></ol><br> 因此，有必要： <br><br><ol><li> 看到了某种东西，它将组成这样一个数组，以便一切都不会用笔计算（在python中） </li><li> 看到互联网速度 </li></ol><br><h2> 锯速表 </h2><br> 这将相对简单。 我们在浏览器的地址栏中输入<a href="httpbin.org/stream-bytes/51200">eu.httpbin.org/stream-bytes/51200</a> 。 下载长度为51200字节的文件。 我们在公共场合将其推向自己（以衡量托管的速度）。 <br><br> 现在我们需要检查文件摆动了多少。 我们将为此提供一个简单的函数，它将以兆字节每秒的速度返回给我们。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> checkDownloadSpeed(baseUrl, fileSizeInBytes) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, _</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> startTime = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>().getTime(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> axios.get(baseUrl).then( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> endTime = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>().getTime(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> duration = (endTime - startTime) / <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bytesPerSecond = (fileSizeInBytes / duration); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> megabytesPerSecond = (bytesPerSecond / <span class="hljs-number"><span class="hljs-number">1000</span></span> / <span class="hljs-number"><span class="hljs-number">1000</span></span>); resolve(megabytesPerSecond); }); }).catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(error); }); }</code> </pre><br> 也就是说，我们记录了下载的开始时间，结束时间，并测量了差异，并且，由于我们知道文件的大小，因此只需对其进行划分即可。 <br><br> 现在，我们将编写一个将以特定速度执行操作的函数： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> getNetworkDownloadSpeed() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baseUrl = process.env.PUBLIC_URL + <span class="hljs-string"><span class="hljs-string">'/51200'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fileSize = <span class="hljs-number"><span class="hljs-number">51200</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> speed = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.checkDownloadSpeed(baseUrl, fileSize); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Network speed: "</span></span> + speed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (speed.mbps === <span class="hljs-string"><span class="hljs-string">"Infinity"</span></span>) { SpeedMeasure.speed = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { SpeedMeasure.speed = speed * <span class="hljs-number"><span class="hljs-number">5</span></span>; } }</code> </pre><br> 通常，此代码存在一个问题：由于文件较小，因此无法确定确切的连接速度。 但是下载更多内容对我们来说太昂贵了，因此我们只需将结果速度乘以5。即使有余地，我们也可以接受，因为实际上速度会更高。 <br><br> 现在，我们将提交一个函数，该函数将根据速度来确定相应的质量： <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> getResolution(gifsArray) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> totalSizeLevel1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> totalSizeLevel2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> totalSizeLevel3 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; gifsArray.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span>; a &lt; gifsArray[i].length; a++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> element = gifsArray[i][a]; totalSizeLevel1 += element.small.size; totalSizeLevel2 += element.middle.size; totalSizeLevel3 += element.large.size; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">isNaN</span></span>(SpeedMeasure.speed)) { SpeedMeasure.speed = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timeLevel1 = totalSizeLevel1 / SpeedMeasure.speed; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timeLevel2 = totalSizeLevel2 / SpeedMeasure.speed; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timeLevel3 = totalSizeLevel3 / SpeedMeasure.speed; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (timeLevel3 &lt; APPROPRIATE_TIME_LIMIT) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"large"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (timeLevel2 &lt; APPROPRIATE_TIME_LIMIT) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"middle"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"small"</span></span>; } }</code> </pre><br> 由于计算速度的函数与我们异步，因此SpeedMeasure.speed可能为零。 默认情况下，我们认为连接速度为每秒1 MB。 当函数计算速度时，我们只是重新渲染容器。 <br><br> 我们将数组的数组传递给getResolution函数。 怎么了 因为如果页面上有多个容器，将数组中的相应内容传输到每个容器中比较方便，但是我们需要一次考虑所有下载速度。 <br><br><h2> 使用范例 </h2><br> 这是一个用法示例（在React上）： <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> runFunction() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> speedMeasure = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpeedMeasure(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> speedMeasure.getNetworkDownloadSpeed(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forceUpdate() } componentDidMount() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.runFunction(); } render() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> quality = SpeedMeasure.getResolution([ Control.getControlArray(), Health.getHealthArray() ]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;div className="app"&gt; &lt;Presentation /&gt; &lt;Control quality={quality} /&gt; &lt;Health quality={quality} /&gt; &lt;/div&gt; ); }</code> </pre><br> 因此，当我们确定速度后，将再次渲染容器。 <br> 在容器内部（例如，在Control内部），您只需从数组中获取相应的GIF（按索引），然后按质量获取对象，并按url获取链接。 一切都很简单。 <br><br><h2> 编写Python脚本 </h2><br> 现在，我们需要以某种方式自动压缩gif并输出包含内容描述的数组。 <br><br> 首先，让我们编写一个压缩脚本。 我们将使用gifsicle。 对于中等压缩的内容，压缩级别将为80（200个压缩级别），对于非常强大的功能，压缩级别将为160。 <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os GIFS_DIR = <span class="hljs-string"><span class="hljs-string">"/home/mixeden//Landingv2/"</span></span> COMPRESSOR_DIR = <span class="hljs-string"><span class="hljs-string">"/home/mixeden//gifsicle-static"</span></span> NOT_OPTIMIZED_DIR = <span class="hljs-string"><span class="hljs-string">"not_optimized"</span></span> OPTIMIZED_DIR = <span class="hljs-string"><span class="hljs-string">"optimized"</span></span> GIF_RESIZED_DIR = <span class="hljs-string"><span class="hljs-string">"gif_not_optimized_resized"</span></span> GIF_COMPRESSED_DIR = <span class="hljs-string"><span class="hljs-string">"gif_compressed"</span></span> COMPRESSION_TYPE = [<span class="hljs-string"><span class="hljs-string">"middle"</span></span>, <span class="hljs-string"><span class="hljs-string">"small"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (root, dirs, files) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> os.walk(GIFS_DIR, topdown=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(files) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> GIF_RESIZED_DIR <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> root: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> file <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> files: path = root + <span class="hljs-string"><span class="hljs-string">"/"</span></span> + file <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> compression <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> COMPRESSION_TYPE: final_path = path.replace(GIF_RESIZED_DIR, GIF_COMPRESSED_DIR + <span class="hljs-string"><span class="hljs-string">"/"</span></span> + compression + <span class="hljs-string"><span class="hljs-string">"/"</span></span> + OPTIMIZED_DIR) print(path, final_path) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> compression == COMPRESSION_TYPE[<span class="hljs-number"><span class="hljs-number">0</span></span>]: rate = <span class="hljs-number"><span class="hljs-number">80</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: rate = <span class="hljs-number"><span class="hljs-number">160</span></span> os.system(<span class="hljs-string"><span class="hljs-string">"echo 0 &gt; "</span></span> + final_path) os.system(COMPRESSOR_DIR + <span class="hljs-string"><span class="hljs-string">" -O3 --lossy={} -o {} {}"</span></span>.format(rate, final_path, path))</code> </pre><br> 为了使文件路径易于理解，以下是带有gif的文件目录说明： <br><br><ol><li>  NOT_OPTIMIZED_DIR-未优化的GIF </li><li>  GIF_RESIZED_DIR-未优化的GIF，但会根据容器的大小进行调整 </li><li>  GIF_COMPRESSED_DIR-压缩的GIF </li></ol><br> 文件夹内有带有GIF类别名称的文件夹。 在具有特定文件夹的文件夹内，包含“大”，“中”和“小”（在压缩文件的类型下）。 <br><br> 在脚本中，我们浏览带有gif的目录，对于每个文件，我们执行两种类型的压缩，调用相应的命令行命令。 <br><br> 现在，让我们继续执行脚本以创建一个包含信息的数组。 <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os GIFS_DIR = <span class="hljs-string"><span class="hljs-string">"/home/mixeden//Landingv2/"</span></span> COMPRESSOR_DIR = <span class="hljs-string"><span class="hljs-string">"/home/mixeden//gifsicle-static"</span></span> NOT_OPTIMIZED_DIR = <span class="hljs-string"><span class="hljs-string">"not_optimized"</span></span> OPTIMIZED_DIR = <span class="hljs-string"><span class="hljs-string">"optimized"</span></span> GIF_RESIZED_DIR = <span class="hljs-string"><span class="hljs-string">"gif_not_optimized_resized"</span></span> GIF_COMPRESSED_DIR = <span class="hljs-string"><span class="hljs-string">"gif_compressed"</span></span> COMPRESSION_TYPE = [<span class="hljs-string"><span class="hljs-string">"large"</span></span>, <span class="hljs-string"><span class="hljs-string">"middle"</span></span>, <span class="hljs-string"><span class="hljs-string">"small"</span></span>] OUTPUT = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (root, dirs, files) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> os.walk(GIFS_DIR, topdown=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(files) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> GIF_COMPRESSED_DIR <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> root <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> NOT_OPTIMIZED_DIR <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> root: files.sort() type = root.split(GIFS_DIR)[<span class="hljs-number"><span class="hljs-number">1</span></span>].split(GIF_COMPRESSED_DIR)[<span class="hljs-number"><span class="hljs-number">0</span></span>].replace(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>) print(type) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> OUTPUT: OUTPUT[type] = [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(OUTPUT[type]) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> file <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> files: OUTPUT[type].append( { <span class="hljs-string"><span class="hljs-string">"large"</span></span>: { <span class="hljs-string"><span class="hljs-string">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-string"><span class="hljs-string">"middle"</span></span>: { <span class="hljs-string"><span class="hljs-string">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-string"><span class="hljs-string">"small"</span></span>: { <span class="hljs-string"><span class="hljs-string">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } }) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> file <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> files: full_path = root + <span class="hljs-string"><span class="hljs-string">"/"</span></span> + file bytes_size = os.path.getsize(full_path) kilobytes_size = bytes_size / <span class="hljs-number"><span class="hljs-number">1000</span></span> megabytes_size = kilobytes_size / <span class="hljs-number"><span class="hljs-number">1000</span></span> index = int(file.split(<span class="hljs-string"><span class="hljs-string">"_"</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>].replace(<span class="hljs-string"><span class="hljs-string">".gif"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>)) - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> typer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> COMPRESSION_TYPE: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> typer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> root: local_type = typer new_url = <span class="hljs-string"><span class="hljs-string">"gifs/"</span></span> + full_path.replace(GIFS_DIR, <span class="hljs-string"><span class="hljs-string">""</span></span>).replace(<span class="hljs-string"><span class="hljs-string">"/"</span></span> + GIF_COMPRESSED_DIR, <span class="hljs-string"><span class="hljs-string">""</span></span>).replace(<span class="hljs-string"><span class="hljs-string">"/"</span></span> + OPTIMIZED_DIR, <span class="hljs-string"><span class="hljs-string">""</span></span>) OUTPUT[type][index][local_type][<span class="hljs-string"><span class="hljs-string">'url'</span></span>] = new_url OUTPUT[type][index][local_type][<span class="hljs-string"><span class="hljs-string">'size'</span></span>] = megabytes_size print(OUTPUT) print(json.dumps(OUTPUT, indent=<span class="hljs-number"><span class="hljs-number">4</span></span>, sort_keys=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>))</code> </pre><br> 在这里，我们浏览包含文件的文件夹，确定文件大小，找出压缩类型，然后将常规信息放入OUTPUT数组。 然后，我们将这个数组输出到控制台以进行复制。 <br><br><h2> 结论 </h2><br> 希望本文对您有所帮助。 伙计们，编码不错。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN480704/">https://habr.com/ru/post/zh-CN480704/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN480690/index.html">我们便宜地管理英寸百叶窗</a></li>
<li><a href="../zh-CN480692/index.html">MobX或Redux：哪个更适合React状态管理？</a></li>
<li><a href="../zh-CN480694/index.html">我们可以停止调用UX的可访问性和可用性吗？</a></li>
<li><a href="../zh-CN480700/index.html">我们在Chrome中使用console.log（）</a></li>
<li><a href="../zh-CN480702/index.html">人力资源和人才，专家和创造力：第八届哈勃拉撒米纳尔会议过得如何</a></li>
<li><a href="../zh-CN480708/index.html">几十年即将结束。 在过去10年中，Google Play上哪些应用下载最多？</a></li>
<li><a href="../zh-CN480710/index.html">重构SFML游戏</a></li>
<li><a href="../zh-CN480712/index.html">口袋里有剂量计的飞行</a></li>
<li><a href="../zh-CN480714/index.html">如何将编解码器添加到FFmpeg</a></li>
<li><a href="../zh-CN480716/index.html">Matlab与 朱莉娅vs. 巨蟒</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>