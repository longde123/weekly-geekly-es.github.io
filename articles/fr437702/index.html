<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🚒 👨🏻‍🔬 🤟🏻 Analyse des entrevues d'emploi Google: requêtes synonymes 🤜🏼 🚚 📞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il s'agit d'un nouvel article d'une discussion sur les tâches des entretiens dans Google . Lorsque j'y ai travaillé, j'ai proposé de telles tâches aux...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyse des entrevues d'emploi Google: requêtes synonymes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437702/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec4/467/e92/ec4467e926275a35882c2a8848097877.png" width="530"></div><br><br>  Il s'agit d'un nouvel article d'une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">discussion sur les tâches des entretiens dans Google</a> .  Lorsque j'y ai travaillé, j'ai proposé de telles tâches aux candidats.  Puis il y a eu une fuite et ils ont été interdits.  Mais la pièce a un revers: je peux maintenant expliquer librement la solution. <br><a name="habracut"></a><br>  Excellente nouvelle pour commencer: j'ai quitté Google!  Je suis heureux de vous informer que je travaille actuellement en tant que responsable technique pour Reddit à New York!  Mais cette série d'articles se poursuivra. <br><br>  <i>Avertissement: Bien que l'entretien des candidats soit l'une de mes fonctions professionnelles, sur ce blog, je partage des observations personnelles, des histoires et des opinions personnelles.</i>  <i>Veuillez ne pas considérer cela comme une déclaration officielle de Google, Alphabet, Reddit, de toute autre personne ou organisation.</i> <br><br><h1>  Question </h1><br>  Après les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deux derniers</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">articles</a> sur les progrès du cheval dans la composition d'un numéro de téléphone, j'ai reçu des critiques selon lesquelles ce n'est pas un problème réaliste.  Peu importe l'utilité d'étudier les capacités de réflexion du candidat, mais je dois admettre que la tâche est vraiment un peu irréaliste.  Même si j'ai quelques réflexions sur la corrélation entre les questions d'entrevue et la réalité, je vais les laisser pour l'instant.  Soyez sûr, j'ai lu des commentaires partout et j'ai quelque chose à répondre, mais pas maintenant. <br><br>  Mais lorsque la tâche de dépasser le cheval a été interdite il y a plusieurs années, j'ai pris à cœur la critique et j'ai essayé de la remplacer par une question un peu plus pertinente pour le périmètre de Google.  Et quoi de plus pertinent pour Google que la mécanique des requêtes de recherche?  J'ai donc trouvé cette question et l'ai utilisée pendant longtemps avant qu'elle ne soit également rendue publique et interdite.  Comme précédemment, je formulerai la question, plongerai dans son explication, puis dirai comment je l'ai utilisée dans les entretiens et pourquoi je l'aime. <br><br>  La question est donc. <br><br>  Imaginez que vous gérez un moteur de recherche populaire et que vous voyez deux demandes dans les journaux: disons, «Notes d'approbation d'Obama» et «Niveau de popularité d'Obama» (si je me souviens bien, ce sont de vrais exemples de la base de questions, bien qu'ils soient un peu dépassés maintenant ...) .  Nous voyons différentes requêtes, mais tout le monde sera d'accord: les utilisateurs recherchent essentiellement les mêmes informations, donc les requêtes doivent être considérées comme équivalentes lors du comptage du nombre de requêtes, de l'affichage des résultats, etc. <b>Comment déterminez-vous si deux requêtes sont synonymes?</b> <br><br>  Formalisons la tâche.  Supposons qu'il existe deux ensembles de paires de chaînes: les paires de synonymes et les paires de requêtes. <br><br>  Plus précisément, voici un exemple d'entrée pour illustrer: <br><br><pre><code class="python hljs">SYNONYMS = [ (<span class="hljs-string"><span class="hljs-string">'rate'</span></span>, <span class="hljs-string"><span class="hljs-string">'ratings'</span></span>), (<span class="hljs-string"><span class="hljs-string">'approval'</span></span>, <span class="hljs-string"><span class="hljs-string">'popularity'</span></span>), ] QUERIES = [ (<span class="hljs-string"><span class="hljs-string">'obama approval rate'</span></span>, <span class="hljs-string"><span class="hljs-string">'obama popularity ratings'</span></span>), (<span class="hljs-string"><span class="hljs-string">'obama approval rates'</span></span>, <span class="hljs-string"><span class="hljs-string">'obama popularity ratings'</span></span>), (<span class="hljs-string"><span class="hljs-string">'obama approval rate'</span></span>, <span class="hljs-string"><span class="hljs-string">'popularity ratings obama'</span></span>) ]</code> </pre> <br>  Il est nécessaire de produire une liste de valeurs logiques: les requêtes dans chaque paire sont-elles synonymes. <br><br><h1>  Toutes les nouvelles questions ... </h1><br>  À première vue, il s'agit d'une tâche simple.  Mais plus vous pensez longtemps, plus cela devient difficile.  Un mot peut-il avoir plusieurs synonymes?  L'ordre des mots est-il important?  Les relations synonymes sont-elles transitives, c'est-à-dire que si A est synonyme de B et B est synonyme de C, A est-il synonyme de C?  Les synonymes peuvent-ils couvrir quelques mots, comment «USA» est-il synonyme des expressions «États-Unis d'Amérique» ou «États-Unis»? <br><br>  Une telle ambiguïté permet immédiatement de faire ses preuves auprès d'un bon candidat.  La première chose qu'il fait est de rechercher de telles ambiguïtés et d'essayer de les résoudre.  Tout le monde le fait de différentes manières: certains approchent le conseil d'administration et essaient de résoudre manuellement des cas spécifiques, tandis que d'autres examinent la question et voient immédiatement les lacunes.  Dans tous les cas, l'identification de ces problèmes à un stade précoce est cruciale. <br><br>  La phase de «compréhension du problème» est d'une grande importance.  J'aime appeler le génie logiciel une discipline fractale.  Comme les fractales, l'approximation révèle une complexité supplémentaire.  Vous pensez que vous comprenez le problème, puis regardez de plus près - et vous voyez que vous avez manqué une subtilité ou des détails de la mise en œuvre qui peuvent être améliorés.  Ou une approche différente du problème. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ee2/53b/e5a/ee253be5a2b504b310dea6050559bcba.gif"><br>  <i><font color="gray">Ensemble Mandelbrot</font></i> <br><br>  <b>Le calibre d'un ingénieur est largement déterminé par la profondeur avec laquelle il peut comprendre le problème.</b>  La transformation d'un énoncé vague du problème en un ensemble détaillé d'exigences est la première étape de ce processus, et un euphémisme délibéré vous permet d'évaluer dans quelle mesure le candidat est adapté à de nouvelles situations. <br><br>  <i>Nous laissons de côté des questions triviales, telles que «Les lettres majuscules sont-elles importantes?» Qui n'affectent pas l'algorithme principal.</i>  <i>Je donne toujours la réponse la plus simple à ces questions (dans ce cas, «supposons que toutes les lettres sont déjà prétraitées et converties en minuscules»)</i> <br><br><h1>  Partie 1. (Pas tout à fait) un cas simple </h1><br>  Si les candidats posent des questions, je commence toujours par le cas le plus simple: un mot peut avoir plusieurs synonymes, l'ordre des mots est important, les synonymes ne sont pas transitifs.  Cela donne au moteur de recherche des fonctionnalités assez limitées, mais il a suffisamment de subtilités pour une interview intéressante. <br><br>  Un aperçu de haut niveau est le suivant: divisez la requête en mots (par exemple, par des espaces) et comparez les paires correspondantes pour rechercher des mots et des synonymes identiques.  Visuellement, cela ressemble à ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c1/a65/908/7c1a6590877f4632beffa60d8cbb0afa.png"><br><br>  Dans le code: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">synonym_queries</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(synonym_words, queries)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">''' synonym_words: iterable of pairs of strings representing synonymous words queries: iterable of pairs of strings representing queries to be tested for synonymous-ness '''</span></span> output = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> q1, q2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> queries: q1, q2 = q1.split(), q2.split() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(q1) != len(q2): output.append(<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(q1)): w1, w2 = q1[i], q2[i] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1 == w2: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> words_are_synonyms(w1, w2): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> output.append(result) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output</code> </pre> <br>  Facile, non?  Algorithmiquement, c'est assez simple.  Pas de programmation dynamique, récursivité, structures complexes, etc. Manipulation simple de la bibliothèque standard et d'un algorithme qui fonctionne en temps linéaire, non? <br><br>  Mais il y a plus de nuances qu'il n'y paraît à première vue.  Bien sûr, l'élément le plus difficile est la comparaison des synonymes.  Bien que le composant soit facile à comprendre et à décrire, il existe de nombreuses façons de faire des erreurs.  Je vais vous parler des erreurs les plus courantes. <br><br>  Pour plus de clarté: aucune erreur ne disqualifiera un candidat;  si cela, je signale simplement une erreur dans l'implémentation, elle corrige, et nous continuons.  Cependant, une interview est avant tout une lutte contre le temps.  Vous ferez, remarquerez et corrigerez des erreurs, mais il faut du temps qui peut être consacré à une autre, par exemple, pour créer une solution plus optimale.  Presque tout le monde fait des erreurs, c'est normal, mais les candidats qui les réduisent affichent de meilleurs résultats simplement parce qu'ils passent moins de temps à les corriger. <br><br>  C'est pourquoi j'aime ce problème.  Si le mouvement d'un chevalier nécessite une compréhension de la compréhension de l'algorithme, puis (j'espère) une implémentation simple, alors la solution ici est beaucoup d'étapes dans la bonne direction.  Chaque étape représente un petit obstacle à travers lequel le candidat peut soit gracieusement sauter par-dessus, soit trébucher et se lever.  Grâce à l'expérience et à l'intuition, les bons candidats évitent ces petits pièges - et obtiennent une solution plus détaillée et correcte, tandis que les plus faibles consacrent du temps et de l'énergie aux erreurs et restent généralement avec le mauvais code. <br><br>  À chaque entretien, j'ai vu une combinaison différente de succès et d'échec, ce sont les erreurs les plus courantes. <br><br><h4>  Des tueurs de performances aléatoires </h4><br>  Tout d'abord, certains candidats ont implémenté la détection des synonymes en parcourant simplement la liste des synonymes: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> (w1, w2) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> ...</code> </pre> <br>  À première vue, cela semble raisonnable.  Mais à y regarder de plus près, l'idée est très, très mauvaise.  Pour ceux d'entre vous qui ne connaissent pas Python, le mot clé in est du sucre syntaxique pour la méthode <i>contains</i> et fonctionne sur tous les conteneurs Python standard.  Il s'agit d'un problème car <code>synonym_words</code> est une liste qui implémente le mot clé in à l'aide de la recherche linéaire.  Les utilisateurs de Python sont particulièrement sensibles à cette erreur car le langage masque les types, mais les utilisateurs C ++ et Java ont également parfois fait des erreurs similaires. <br><br>  Au cours de ma carrière, je n'ai écrit que quelques fois avec un code de recherche linéaire, et chacun sur une liste de pas plus de deux douzaines d'éléments.  Et même dans ce cas, il a écrit un long commentaire expliquant pourquoi il a choisi une telle approche apparemment sous-optimale.  Je soupçonne que certains candidats l'ont utilisé simplement parce qu'ils ne savaient pas comment fonctionne le mot clé in dans les listes de la bibliothèque standard Python.  C'est une simple erreur, pas fatale, mais une mauvaise connaissance de votre langue préférée n'est pas très bonne. <br><br>  En pratique, cette erreur est facilement évitée.  Tout d'abord, n'oubliez jamais vos types d'objets, même si vous utilisez un langage non typé tel que Python!  Deuxièmement, n'oubliez pas que lorsque vous utilisez le mot clé <i>in dans</i> la liste, une recherche linéaire démarre.  S'il n'y a aucune garantie que cette liste restera toujours très petite, cela réduira les performances. <br><br>  Pour que le candidat reprenne ses esprits, il suffit généralement de lui rappeler que la structure d'entrée est une liste.  Il est très important d'observer comment le candidat répond à l'invite.  Les meilleurs candidats essaient immédiatement de prétraiter les synonymes, ce qui est un bon début.  Mais cette approche n'est pas sans écueils ... <br><br><h4>  Utilisez la bonne structure de données </h4><br>  D'après le code ci-dessus, il est immédiatement clair que pour implémenter cet algorithme en temps linéaire, il est nécessaire de trouver rapidement des synonymes.  Et quand on parle de recherches rapides, c'est toujours une carte ou un tableau de hachages. <br><br>  Peu importe que le candidat choisisse une carte ou un tableau de hachages.  L'important est qu'il le mette là (au fait, n'utilisez jamais dict / hashmap avec la transition vers <code>True</code> ou <code>False</code> ).  La plupart des candidats choisissent une sorte de dict / hashmap.  L'erreur la plus courante est l'hypothèse subconsciente que chaque mot n'a pas plus d'un synonyme: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span>synonyms = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1] = w2 ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> synonyms[w1] == w2: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span></code> </pre> <br>  Je ne punis pas les candidats pour cette erreur.  La tâche est spécialement formulée de manière à ne pas se concentrer sur le fait que les mots peuvent avoir plusieurs synonymes, et certains candidats n'ont tout simplement pas rencontré une telle situation.  Corrige le plus rapidement un bug quand je le pointe.  Les bons candidats le remarquent à un stade précoce et ne passent généralement pas beaucoup de temps. <br><br>  Un problème un peu plus grave est le manque de conscience que la relation des synonymes se propage dans les deux sens.  Notez que dans le code ci-dessus, cela est pris en compte.  Mais il existe des implémentations avec une erreur: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span>synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1].append(w2) synonyms[w2].append(w1) ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms.get(w1, tuple()): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span></code> </pre> <br>  Pourquoi faire deux insertions et utiliser deux fois plus de mémoire? <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span>synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1].append(w2) ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> (w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms.get(w1, tuple()) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms.get(w2, tuple())): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span></code> </pre> <br>  Conclusion: <i>pensez toujours à optimiser le code</i> !  Rétrospectivement, la permutation des fonctions de recherche est une optimisation évidente, sinon nous pouvons conclure que le candidat n'a pas pensé aux options d'optimisation.  Encore une fois, je suis heureux de donner un indice, mais il vaut mieux deviner par vous-même. <br><br><h1>  Trier? </h1><br>  Certains candidats intelligents souhaitent trier la liste des synonymes, puis utiliser la recherche binaire.  En fait, cette approche présente un avantage important: elle ne nécessite pas d'espace supplémentaire, à l'exception de la liste des synonymes (à condition que la liste puisse être modifiée). <br><br>  Malheureusement, la complexité temporelle interfère: le tri d'une liste de synonymes nécessite du temps <code>Nlog(N)</code> , puis un autre <code>log(N)</code> pour rechercher chaque paire de synonymes, tandis que la solution de prétraitement décrite se déroule en temps linéaire puis constant.  De plus, je suis catégoriquement contre de forcer le candidat à implémenter le tri et la recherche binaire sur le tableau, car: 1) les algorithmes de tri sont bien connus, donc, à ma connaissance, le candidat peut le publier sans réfléchir;  2) ces algorithmes sont diaboliquement difficiles à mettre en œuvre correctement, et souvent même les meilleurs candidats font des erreurs qui ne disent rien sur leurs compétences en programmation. <br><br>  Chaque fois qu'un candidat proposait une telle solution, j'étais intéressé par le temps d'exécution du programme et demandais s'il y avait une meilleure option.  Pour information: si l'enquêteur vous demande s'il existe une meilleure option, la réponse est presque toujours oui.  Si jamais je vous pose cette question, la réponse sera certainement celle-là. <br><br><h4>  Enfin solution </h4><br>  Au final, le candidat propose quelque chose de correct et raisonnablement optimal.  Voici une implémentation en temps linéaire et en espace linéaire pour des conditions données: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">synonym_queries</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(synonym_words, queries)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">''' synonym_words: iterable of pairs of strings representing synonymous words queries: iterable of pairs of strings representing queries to be tested for synonymous-ness '''</span></span> synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1].add(w2) output = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> q1, q2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> queries: q1, q2 = q1.split(), q2.split() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(q1) != len(q2): output.append(<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(q1)): w1, w2 = q1[i], q2[i] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1 == w2: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> ((w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w1]) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w2])): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> output.append(result) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output</code> </pre> <br>  Quelques notes rapides: <br><br><ul><li>  Notez l'utilisation de <code>dict.get()</code> .  Vous pouvez implémenter une vérification pour voir si la clé est dans le dict, puis l'obtenir, mais c'est une approche compliquée, bien que de cette façon vous montrerez votre connaissance de la bibliothèque standard. </li><li>  Personnellement, je ne suis pas un fan de code avec une <code>continue</code> fréquente et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">certains guides de style les interdisent ou ne les recommandent pas</a> .  J'ai moi-même dans la première édition de ce code oublié la déclaration <code>continue</code> après avoir vérifié la longueur de la demande.  Ce n'est pas une mauvaise approche, sachez simplement qu'elle est sujette aux erreurs. </li></ul><br><h1>  Partie 2: devient plus difficile! </h1><br>  Les bons candidats, après avoir résolu le problème, ont encore dix à quinze minutes de temps.  Heureusement, il y a un tas de questions supplémentaires, bien qu'il soit peu probable que nous écrivions beaucoup de code pendant cette période.  Cependant, ce n'est pas nécessaire.  Je veux savoir deux choses sur le candidat: est-il capable de développer des algorithmes et est-il capable de coder?  Le problème avec le mouvement du chevalier répond d'abord à la question de développer un algorithme, puis vérifie le codage, et ici nous obtenons les réponses dans l'ordre inverse. <br><br>  Au moment où le candidat a terminé la première partie de la question, il avait déjà résolu le problème du codage (étonnamment non trivial).  À ce stade, je peux parler en toute confiance de sa capacité à développer des algorithmes rudimentaires et à traduire des idées en code, ainsi que de sa connaissance de son langage préféré et de sa bibliothèque standard.  Maintenant, la conversation devient beaucoup plus intéressante, car les exigences de programmation peuvent être assouplies et nous allons plonger dans les algorithmes. <br><br>  Pour cela, nous revenons aux principaux postulats de la première partie: l'ordre des mots est important, les synonymes sont non transitifs et pour chaque mot il peut y avoir plusieurs synonymes.  Au fur et à mesure de l'entretien, je modifie chacune de ces restrictions, et dans cette nouvelle phase, le candidat et moi avons une discussion purement algorithmique.  Ici, je vais donner des exemples de code pour illustrer mon point de vue, mais dans une vraie interview, nous ne parlons que d'algorithmes. <br><br>  Avant de commencer, je vais expliquer ma position: toutes les actions ultérieures à ce stade de l’entretien sont principalement des «points bonus».  Mon approche personnelle consiste à identifier les candidats qui franchissent exactement la première étape et sont aptes au travail.  La deuxième étape est nécessaire pour mettre en valeur le meilleur.  La première note est déjà très forte et signifie que le candidat est assez bon pour l'entreprise, et la deuxième note dit que le candidat est excellent et son embauche sera une grande victoire pour nous. <br><br><h1>  Transitivité: approches naïves </h1><br>  Tout d'abord, j'aime supprimer la contrainte de transitivité, donc si les paires A - B et B - C sont synonymes, alors les mots A et C sont également synonymes.  Les candidats intelligents comprendront rapidement comment adapter leur solution précédente, bien qu'avec la suppression supplémentaire d'autres restrictions, la logique de base de l'algorithme cessera de fonctionner. <br><br>  Mais comment l'adapter?  Une approche courante consiste à conserver un ensemble complet de synonymes pour chaque mot en fonction des relations transitives.  Chaque fois que nous insérons un mot dans un ensemble de synonymes, nous l'ajoutons également aux ensembles correspondants pour tous les mots de cet ensemble: <br><br><pre> <code class="python hljs">synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w1]: synonyms[w].add(w2) synonyms[w1].add(w2) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w2]: synonyms[w].add(w1) synonyms[w2].add(w1)</code> </pre> <br>  <i><font color="gray">Veuillez noter que lors de la création du code, nous avons déjà exploré cette solution.</font></i> <br><br>  Cette solution fonctionne, mais loin d'être optimale.  Pour comprendre les raisons, nous estimons la complexité spatiale de cette solution.  Chaque synonyme doit être ajouté non seulement à l'ensemble du mot initial, mais également aux ensembles de tous ses synonymes.  S'il existe un synonyme, une entrée est ajoutée.  Mais si nous avons 50 synonymes, vous devez ajouter 50 entrées.  Dans la figure, cela ressemble à ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3f/ab6/e25/e3fab6e25d14821ec06d623925db9ac5.png"></div><br><br>  Notez que nous sommes passés de trois clés et six enregistrements à quatre clés et douze enregistrements.  Un mot avec 50 synonymes nécessitera 50 touches et près de 2500 entrées.  L'espace nécessaire pour représenter un mot augmente de façon quadratique avec une augmentation de l'ensemble des synonymes, ce qui est plutôt inutile. <br><br>  Il existe d'autres solutions, mais je n'irai pas trop loin pour ne pas gonfler l'article.  Le plus intéressant d'entre eux est l'utilisation de la structure de données synonyme pour construire un graphe orienté, puis une recherche en premier pour trouver le chemin entre deux mots.  C'est une excellente solution, mais la recherche devient de taille linéaire dans l'ensemble des synonymes du mot.  Comme nous effectuons cette recherche plusieurs fois pour chaque demande, cette approche n'est pas optimale. <br><br><h1>  Transitivité: utilisation d'ensembles disjoints </h1><br>  Il s'avère que la recherche de synonymes est possible pendant un temps (presque) constant grâce à une structure de données appelée ensembles disjoints.  Cette structure offre des possibilités légèrement différentes d'un ensemble de données classique. <br><br>  La structure d'ensemble habituelle (hashset, treeset) est un conteneur qui vous permet de déterminer rapidement si un objet se trouve à l'intérieur ou à l'extérieur de celui-ci.  Les ensembles disjoints résolvent un problème complètement différent: au lieu de définir un élément spécifique, ils vous permettent de déterminer <i>si deux éléments appartiennent au même ensemble</i> .  De plus, la structure le fait pour un temps <code>O(a(n))</code> extrêmement rapide, où <code>a(n)</code> est la fonction Ackerman inverse.  Si vous n'avez pas étudié les algorithmes avancés, vous ne connaissez peut-être pas cette fonction qui, pour toutes les entrées raisonnables, est en fait exécutée en temps constant. <br><br>  À un niveau élevé, l'algorithme fonctionne comme suit.  Les ensembles sont représentés par des arbres avec des parents pour chaque élément.  Étant donné que chaque arbre a une racine (un élément qui est son propre parent), nous pouvons déterminer si deux éléments appartiennent au même ensemble en traçant leurs parents jusqu'à la racine.  Si deux éléments ont une racine, ils appartiennent à un ensemble.  La combinaison d'ensembles est également simple: il suffit de trouver les éléments racine et de faire de l'un d'eux la racine de l'autre. <br><br>  Jusqu'ici tout va bien, mais jusqu'à présent, aucune vitesse éblouissante n'a été observée.  Le génie de cette structure réside dans une procédure appelée <i>compression</i> .  Supposons que vous ayez l'arborescence suivante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4b/132/102/e4b13210226d0375adc1acf7835ef4a2.png"></div><br><br>  Imaginez que vous vouliez savoir si <i>rapide</i> et <i>hâtif</i> sont synonymes.  Passez par chaque parent - et trouvez la même racine <i>rapide</i> .  Supposons maintenant que nous effectuions une vérification similaire pour les mots <i>rapides</i> et <i>rapides</i> .  Encore une fois, nous montons à la racine, et à grande <i>vitesse,</i> nous empruntons le même chemin.  La duplication des travaux peut-elle être évitée? <br><br>  Il s'avère que vous le pouvez.  Dans un sens, chaque élément de cet arbre est destiné à venir au <i>jeûne</i> .  Au lieu de parcourir l'arborescence entière à chaque fois, pourquoi ne pas changer le parent de tous <i>les</i> descendants <i>rapides</i> pour raccourcir la route vers la racine?  Ce processus est appelé compression et, dans les ensembles disjoints, il est intégré à l'opération de recherche racine.  Par exemple, après la première opération de comparaison <i>rapide</i> et <i>rapide, la</i> structure comprendra qu'il s'agit de synonymes et compressera l'arborescence comme suit: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d4/381/3b9/2d43813b9925bf86d0e4b3a2c9a99707.png"></div><br>  <i><font color="gray">Pour tous les mots entre rapide et rapide, le parent a été mis à jour, la même chose s'est produite avec hâte</font></i> <br><br>  Maintenant, tous les appels suivants se produiront en temps constant, car chaque nœud de cet arbre pointe vers <i>rapide</i> .  Il n'est pas très facile d'évaluer la complexité temporelle des opérations: en fait, elle n'est pas constante, car elle dépend de la profondeur des arbres, mais elle est proche de constante, car la structure est rapidement optimisée.  Pour simplifier, nous supposons que le temps est constant. <br><br>  Avec ce concept, nous implémentons des ensembles non liés à notre problème: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DisjointSet</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.parents = {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_root</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, w)</span></span></span><span class="hljs-function">:</span></span> words_traversed = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> self.parents[w] != w: words_traversed.append(w) w = self.parents[w] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> word <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> words_traversed: self.parents[word] = w <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> w <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_synonyms</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, w1, w2)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1 <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.parents: self.parents[w1] = w1 <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w2 <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.parents: self.parents[w2] = w2 w1_root = self.get_root(w1) w2_root = self.get_root(w2) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1_root &lt; w2_root: w1_root, w2_root = w2_root, w1_root self.parents[w2_root] = w1_root <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">are_synonymous</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, w1, w2)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.get_root(w1) == self.get_root(w2)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En utilisant cette structure, vous pouvez prétraiter des synonymes et résoudre le problème en temps linéaire. </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Note et notes </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À ce stade, nous avons atteint la limite de ce qu'un candidat peut montrer en 40 à 45 minutes d'entrevue. </font><font style="vertical-align: inherit;">À tous les candidats qui ont fait face à la partie introductive et qui ont fait des progrès significatifs dans la description (pas la mise en œuvre) d'ensembles non liés, j'ai attribué la note «Hautement recommandé pour l'emploi» et leur ai permis de poser des questions. </font><font style="vertical-align: inherit;">Je n'ai jamais vu un candidat aller aussi loin et il me reste beaucoup de temps. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En principe, il existe encore des variantes du problème de la transitivité: par exemple, supprimer la restriction sur l'ordre des mots ou sur plusieurs synonymes d'un mot. </font><font style="vertical-align: inherit;">Chaque décision sera difficile et délicieuse, mais je les laisserai pour plus tard.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le mérite de cette tâche est qu'elle permet aux candidats de faire des erreurs. </font><font style="vertical-align: inherit;">Le développement logiciel quotidien consiste en des cycles sans fin d'analyse, d'exécution et de raffinement. </font><font style="vertical-align: inherit;">Ce problème permet aux candidats de démontrer leurs capacités à chaque étape. </font><font style="vertical-align: inherit;">Considérez les compétences nécessaires pour obtenir le score maximum sur cette question:</font></font><br><br><ul><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analyser l'énoncé du problème</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">déterminer où il n'est pas clairement formulé</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , développer une formulation non ambiguë. </font><font style="vertical-align: inherit;">Continuez à le faire pendant que vous résolvez et que de nouvelles questions surgissent. </font><font style="vertical-align: inherit;">Pour une efficacité maximale, effectuez ces opérations le plus tôt possible, car plus le travail est avancé, plus il faudra de temps pour corriger l'erreur.</font></font><br></li><li> <i> </i>  ,        .       ,         . <br></li><li> <i>  </i> .          ,    ,      . <br></li><li>  , <i>    </i> .     ,      <code>continue</code> ,   ,     . <br></li><li>    , <i>  :   ,   </i> ,    ,    . ,      ,       ,    . <br></li><li> <i>    </i> .   —    ,          .        —    . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aucune de ces compétences ne peut être apprise des manuels (à l'exception peut-être des structures de données et des algorithmes). </font><font style="vertical-align: inherit;">La seule façon de les acquérir est de pratiquer régulièrement et largement, ce qui est en bon accord avec ce dont l'employeur a besoin: des candidats expérimentés qui sont capables d'appliquer efficacement leurs connaissances. </font><font style="vertical-align: inherit;">Le but des interviews était de trouver de telles personnes, et la tâche de cet article m'a bien aidé pendant longtemps.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plans futurs </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme vous pouvez le comprendre, la tâche a finalement </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">été connue du public</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Depuis lors, j'ai utilisé plusieurs autres questions, en fonction de ce que les intervieweurs précédents m'ont demandé et de mon humeur (poser une question est tout le temps ennuyeux). J'utilise toujours quelques questions, donc je vais les garder secrètes, mais certaines ne le sont pas! Vous pouvez les trouver dans les articles suivants. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans un avenir proche, je prévois deux articles. Tout d'abord, comme promis ci-dessus, je vais expliquer la solution aux deux problèmes restants pour cette tâche. Je ne leur ai jamais posé de questions lors des interviews, mais elles sont intéressantes en elles-mêmes. En outre, je partagerai mes réflexions et mon opinion personnelle sur la procédure de recherche d'employés en informatique, ce qui est particulièrement intéressant pour moi maintenant, car je recherche des ingénieurs pour mon équipe dans Reddit.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme toujours, si vous souhaitez être informé de la sortie de nouveaux articles, suivez-moi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur Twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Medium</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si vous avez aimé cet article, n'oubliez pas de voter pour lui ou de laisser un commentaire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merci d'avoir lu! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS: Vous pouvez examiner le code de tous les articles dans </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le dépôt GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jouer avec eux en </font><font style="vertical-align: inherit;">direct</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> grâce à mes bons amis de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repl.it</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr437702/">https://habr.com/ru/post/fr437702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr437686/index.html">Learning Go: écrire un messager p2p avec un cryptage de bout en bout</a></li>
<li><a href="../fr437688/index.html">OpenSceneGraph: Techniques de programmation de base</a></li>
<li><a href="../fr437694/index.html">Analyse de l'utilitaire Files.walkFileTree ();</a></li>
<li><a href="../fr437696/index.html">Le condensé de matériaux intéressants pour le développeur mobile # 283 (du 21 au 27 janvier)</a></li>
<li><a href="../fr437698/index.html">Service de traduction de brevets de l'OMPI Translate - Mes expériences</a></li>
<li><a href="../fr437704/index.html">Excellente connaissance du programme scolaire en tant qu'indicateur d'une intelligence pas la plus élevée</a></li>
<li><a href="../fr437706/index.html">Année avec Tesla</a></li>
<li><a href="../fr437710/index.html">Limiter au minimum les droits des utilisateurs locaux sur Linux</a></li>
<li><a href="../fr437712/index.html">Station spatiale Roskomnadzor</a></li>
<li><a href="../fr437714/index.html">Nous dessinons une explosion de dessin animé pour 180 lignes de C ++ nu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>