<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüöí üë®üèª‚Äçüî¨ ü§üüèª Analyse des entrevues d'emploi Google: requ√™tes synonymes ü§úüèº üöö üìû</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il s'agit d'un nouvel article d'une discussion sur les t√¢ches des entretiens dans Google . Lorsque j'y ai travaill√©, j'ai propos√© de telles t√¢ches aux...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyse des entrevues d'emploi Google: requ√™tes synonymes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437702/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec4/467/e92/ec4467e926275a35882c2a8848097877.png" width="530"></div><br><br>  Il s'agit d'un nouvel article d'une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">discussion sur les t√¢ches des entretiens dans Google</a> .  Lorsque j'y ai travaill√©, j'ai propos√© de telles t√¢ches aux candidats.  Puis il y a eu une fuite et ils ont √©t√© interdits.  Mais la pi√®ce a un revers: je peux maintenant expliquer librement la solution. <br><a name="habracut"></a><br>  Excellente nouvelle pour commencer: j'ai quitt√© Google!  Je suis heureux de vous informer que je travaille actuellement en tant que responsable technique pour Reddit √† New York!  Mais cette s√©rie d'articles se poursuivra. <br><br>  <i>Avertissement: Bien que l'entretien des candidats soit l'une de mes fonctions professionnelles, sur ce blog, je partage des observations personnelles, des histoires et des opinions personnelles.</i>  <i>Veuillez ne pas consid√©rer cela comme une d√©claration officielle de Google, Alphabet, Reddit, de toute autre personne ou organisation.</i> <br><br><h1>  Question </h1><br>  Apr√®s les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deux derniers</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">articles</a> sur les progr√®s du cheval dans la composition d'un num√©ro de t√©l√©phone, j'ai re√ßu des critiques selon lesquelles ce n'est pas un probl√®me r√©aliste.  Peu importe l'utilit√© d'√©tudier les capacit√©s de r√©flexion du candidat, mais je dois admettre que la t√¢che est vraiment un peu irr√©aliste.  M√™me si j'ai quelques r√©flexions sur la corr√©lation entre les questions d'entrevue et la r√©alit√©, je vais les laisser pour l'instant.  Soyez s√ªr, j'ai lu des commentaires partout et j'ai quelque chose √† r√©pondre, mais pas maintenant. <br><br>  Mais lorsque la t√¢che de d√©passer le cheval a √©t√© interdite il y a plusieurs ann√©es, j'ai pris √† c≈ìur la critique et j'ai essay√© de la remplacer par une question un peu plus pertinente pour le p√©rim√®tre de Google.  Et quoi de plus pertinent pour Google que la m√©canique des requ√™tes de recherche?  J'ai donc trouv√© cette question et l'ai utilis√©e pendant longtemps avant qu'elle ne soit √©galement rendue publique et interdite.  Comme pr√©c√©demment, je formulerai la question, plongerai dans son explication, puis dirai comment je l'ai utilis√©e dans les entretiens et pourquoi je l'aime. <br><br>  La question est donc. <br><br>  Imaginez que vous g√©rez un moteur de recherche populaire et que vous voyez deux demandes dans les journaux: disons, ¬´Notes d'approbation d'Obama¬ª et ¬´Niveau de popularit√© d'Obama¬ª (si je me souviens bien, ce sont de vrais exemples de la base de questions, bien qu'ils soient un peu d√©pass√©s maintenant ...) .  Nous voyons diff√©rentes requ√™tes, mais tout le monde sera d'accord: les utilisateurs recherchent essentiellement les m√™mes informations, donc les requ√™tes doivent √™tre consid√©r√©es comme √©quivalentes lors du comptage du nombre de requ√™tes, de l'affichage des r√©sultats, etc. <b>Comment d√©terminez-vous si deux requ√™tes sont synonymes?</b> <br><br>  Formalisons la t√¢che.  Supposons qu'il existe deux ensembles de paires de cha√Ænes: les paires de synonymes et les paires de requ√™tes. <br><br>  Plus pr√©cis√©ment, voici un exemple d'entr√©e pour illustrer: <br><br><pre><code class="python hljs">SYNONYMS = [ (<span class="hljs-string"><span class="hljs-string">'rate'</span></span>, <span class="hljs-string"><span class="hljs-string">'ratings'</span></span>), (<span class="hljs-string"><span class="hljs-string">'approval'</span></span>, <span class="hljs-string"><span class="hljs-string">'popularity'</span></span>), ] QUERIES = [ (<span class="hljs-string"><span class="hljs-string">'obama approval rate'</span></span>, <span class="hljs-string"><span class="hljs-string">'obama popularity ratings'</span></span>), (<span class="hljs-string"><span class="hljs-string">'obama approval rates'</span></span>, <span class="hljs-string"><span class="hljs-string">'obama popularity ratings'</span></span>), (<span class="hljs-string"><span class="hljs-string">'obama approval rate'</span></span>, <span class="hljs-string"><span class="hljs-string">'popularity ratings obama'</span></span>) ]</code> </pre> <br>  Il est n√©cessaire de produire une liste de valeurs logiques: les requ√™tes dans chaque paire sont-elles synonymes. <br><br><h1>  Toutes les nouvelles questions ... </h1><br>  √Ä premi√®re vue, il s'agit d'une t√¢che simple.  Mais plus vous pensez longtemps, plus cela devient difficile.  Un mot peut-il avoir plusieurs synonymes?  L'ordre des mots est-il important?  Les relations synonymes sont-elles transitives, c'est-√†-dire que si A est synonyme de B et B est synonyme de C, A est-il synonyme de C?  Les synonymes peuvent-ils couvrir quelques mots, comment ¬´USA¬ª est-il synonyme des expressions ¬´√âtats-Unis d'Am√©rique¬ª ou ¬´√âtats-Unis¬ª? <br><br>  Une telle ambigu√Øt√© permet imm√©diatement de faire ses preuves aupr√®s d'un bon candidat.  La premi√®re chose qu'il fait est de rechercher de telles ambigu√Øt√©s et d'essayer de les r√©soudre.  Tout le monde le fait de diff√©rentes mani√®res: certains approchent le conseil d'administration et essaient de r√©soudre manuellement des cas sp√©cifiques, tandis que d'autres examinent la question et voient imm√©diatement les lacunes.  Dans tous les cas, l'identification de ces probl√®mes √† un stade pr√©coce est cruciale. <br><br>  La phase de ¬´compr√©hension du probl√®me¬ª est d'une grande importance.  J'aime appeler le g√©nie logiciel une discipline fractale.  Comme les fractales, l'approximation r√©v√®le une complexit√© suppl√©mentaire.  Vous pensez que vous comprenez le probl√®me, puis regardez de plus pr√®s - et vous voyez que vous avez manqu√© une subtilit√© ou des d√©tails de la mise en ≈ìuvre qui peuvent √™tre am√©lior√©s.  Ou une approche diff√©rente du probl√®me. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ee2/53b/e5a/ee253be5a2b504b310dea6050559bcba.gif"><br>  <i><font color="gray">Ensemble Mandelbrot</font></i> <br><br>  <b>Le calibre d'un ing√©nieur est largement d√©termin√© par la profondeur avec laquelle il peut comprendre le probl√®me.</b>  La transformation d'un √©nonc√© vague du probl√®me en un ensemble d√©taill√© d'exigences est la premi√®re √©tape de ce processus, et un euph√©misme d√©lib√©r√© vous permet d'√©valuer dans quelle mesure le candidat est adapt√© √† de nouvelles situations. <br><br>  <i>Nous laissons de c√¥t√© des questions triviales, telles que ¬´Les lettres majuscules sont-elles importantes?¬ª Qui n'affectent pas l'algorithme principal.</i>  <i>Je donne toujours la r√©ponse la plus simple √† ces questions (dans ce cas, ¬´supposons que toutes les lettres sont d√©j√† pr√©trait√©es et converties en minuscules¬ª)</i> <br><br><h1>  Partie 1. (Pas tout √† fait) un cas simple </h1><br>  Si les candidats posent des questions, je commence toujours par le cas le plus simple: un mot peut avoir plusieurs synonymes, l'ordre des mots est important, les synonymes ne sont pas transitifs.  Cela donne au moteur de recherche des fonctionnalit√©s assez limit√©es, mais il a suffisamment de subtilit√©s pour une interview int√©ressante. <br><br>  Un aper√ßu de haut niveau est le suivant: divisez la requ√™te en mots (par exemple, par des espaces) et comparez les paires correspondantes pour rechercher des mots et des synonymes identiques.  Visuellement, cela ressemble √† ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c1/a65/908/7c1a6590877f4632beffa60d8cbb0afa.png"><br><br>  Dans le code: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">synonym_queries</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(synonym_words, queries)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">''' synonym_words: iterable of pairs of strings representing synonymous words queries: iterable of pairs of strings representing queries to be tested for synonymous-ness '''</span></span> output = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> q1, q2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> queries: q1, q2 = q1.split(), q2.split() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(q1) != len(q2): output.append(<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(q1)): w1, w2 = q1[i], q2[i] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1 == w2: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> words_are_synonyms(w1, w2): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> output.append(result) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output</code> </pre> <br>  Facile, non?  Algorithmiquement, c'est assez simple.  Pas de programmation dynamique, r√©cursivit√©, structures complexes, etc. Manipulation simple de la biblioth√®que standard et d'un algorithme qui fonctionne en temps lin√©aire, non? <br><br>  Mais il y a plus de nuances qu'il n'y para√Æt √† premi√®re vue.  Bien s√ªr, l'√©l√©ment le plus difficile est la comparaison des synonymes.  Bien que le composant soit facile √† comprendre et √† d√©crire, il existe de nombreuses fa√ßons de faire des erreurs.  Je vais vous parler des erreurs les plus courantes. <br><br>  Pour plus de clart√©: aucune erreur ne disqualifiera un candidat;  si cela, je signale simplement une erreur dans l'impl√©mentation, elle corrige, et nous continuons.  Cependant, une interview est avant tout une lutte contre le temps.  Vous ferez, remarquerez et corrigerez des erreurs, mais il faut du temps qui peut √™tre consacr√© √† une autre, par exemple, pour cr√©er une solution plus optimale.  Presque tout le monde fait des erreurs, c'est normal, mais les candidats qui les r√©duisent affichent de meilleurs r√©sultats simplement parce qu'ils passent moins de temps √† les corriger. <br><br>  C'est pourquoi j'aime ce probl√®me.  Si le mouvement d'un chevalier n√©cessite une compr√©hension de la compr√©hension de l'algorithme, puis (j'esp√®re) une impl√©mentation simple, alors la solution ici est beaucoup d'√©tapes dans la bonne direction.  Chaque √©tape repr√©sente un petit obstacle √† travers lequel le candidat peut soit gracieusement sauter par-dessus, soit tr√©bucher et se lever.  Gr√¢ce √† l'exp√©rience et √† l'intuition, les bons candidats √©vitent ces petits pi√®ges - et obtiennent une solution plus d√©taill√©e et correcte, tandis que les plus faibles consacrent du temps et de l'√©nergie aux erreurs et restent g√©n√©ralement avec le mauvais code. <br><br>  √Ä chaque entretien, j'ai vu une combinaison diff√©rente de succ√®s et d'√©chec, ce sont les erreurs les plus courantes. <br><br><h4>  Des tueurs de performances al√©atoires </h4><br>  Tout d'abord, certains candidats ont impl√©ment√© la d√©tection des synonymes en parcourant simplement la liste des synonymes: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> (w1, w2) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> ...</code> </pre> <br>  √Ä premi√®re vue, cela semble raisonnable.  Mais √† y regarder de plus pr√®s, l'id√©e est tr√®s, tr√®s mauvaise.  Pour ceux d'entre vous qui ne connaissent pas Python, le mot cl√© in est du sucre syntaxique pour la m√©thode <i>contains</i> et fonctionne sur tous les conteneurs Python standard.  Il s'agit d'un probl√®me car <code>synonym_words</code> est une liste qui impl√©mente le mot cl√© in √† l'aide de la recherche lin√©aire.  Les utilisateurs de Python sont particuli√®rement sensibles √† cette erreur car le langage masque les types, mais les utilisateurs C ++ et Java ont √©galement parfois fait des erreurs similaires. <br><br>  Au cours de ma carri√®re, je n'ai √©crit que quelques fois avec un code de recherche lin√©aire, et chacun sur une liste de pas plus de deux douzaines d'√©l√©ments.  Et m√™me dans ce cas, il a √©crit un long commentaire expliquant pourquoi il a choisi une telle approche apparemment sous-optimale.  Je soup√ßonne que certains candidats l'ont utilis√© simplement parce qu'ils ne savaient pas comment fonctionne le mot cl√© in dans les listes de la biblioth√®que standard Python.  C'est une simple erreur, pas fatale, mais une mauvaise connaissance de votre langue pr√©f√©r√©e n'est pas tr√®s bonne. <br><br>  En pratique, cette erreur est facilement √©vit√©e.  Tout d'abord, n'oubliez jamais vos types d'objets, m√™me si vous utilisez un langage non typ√© tel que Python!  Deuxi√®mement, n'oubliez pas que lorsque vous utilisez le mot cl√© <i>in dans</i> la liste, une recherche lin√©aire d√©marre.  S'il n'y a aucune garantie que cette liste restera toujours tr√®s petite, cela r√©duira les performances. <br><br>  Pour que le candidat reprenne ses esprits, il suffit g√©n√©ralement de lui rappeler que la structure d'entr√©e est une liste.  Il est tr√®s important d'observer comment le candidat r√©pond √† l'invite.  Les meilleurs candidats essaient imm√©diatement de pr√©traiter les synonymes, ce qui est un bon d√©but.  Mais cette approche n'est pas sans √©cueils ... <br><br><h4>  Utilisez la bonne structure de donn√©es </h4><br>  D'apr√®s le code ci-dessus, il est imm√©diatement clair que pour impl√©menter cet algorithme en temps lin√©aire, il est n√©cessaire de trouver rapidement des synonymes.  Et quand on parle de recherches rapides, c'est toujours une carte ou un tableau de hachages. <br><br>  Peu importe que le candidat choisisse une carte ou un tableau de hachages.  L'important est qu'il le mette l√† (au fait, n'utilisez jamais dict / hashmap avec la transition vers <code>True</code> ou <code>False</code> ).  La plupart des candidats choisissent une sorte de dict / hashmap.  L'erreur la plus courante est l'hypoth√®se subconsciente que chaque mot n'a pas plus d'un synonyme: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span>synonyms = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1] = w2 ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> synonyms[w1] == w2: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span></code> </pre> <br>  Je ne punis pas les candidats pour cette erreur.  La t√¢che est sp√©cialement formul√©e de mani√®re √† ne pas se concentrer sur le fait que les mots peuvent avoir plusieurs synonymes, et certains candidats n'ont tout simplement pas rencontr√© une telle situation.  Corrige le plus rapidement un bug quand je le pointe.  Les bons candidats le remarquent √† un stade pr√©coce et ne passent g√©n√©ralement pas beaucoup de temps. <br><br>  Un probl√®me un peu plus grave est le manque de conscience que la relation des synonymes se propage dans les deux sens.  Notez que dans le code ci-dessus, cela est pris en compte.  Mais il existe des impl√©mentations avec une erreur: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span>synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1].append(w2) synonyms[w2].append(w1) ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms.get(w1, tuple()): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span></code> </pre> <br>  Pourquoi faire deux insertions et utiliser deux fois plus de m√©moire? <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span>synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1].append(w2) ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> (w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms.get(w1, tuple()) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms.get(w2, tuple())): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span></code> </pre> <br>  Conclusion: <i>pensez toujours √† optimiser le code</i> !  R√©trospectivement, la permutation des fonctions de recherche est une optimisation √©vidente, sinon nous pouvons conclure que le candidat n'a pas pens√© aux options d'optimisation.  Encore une fois, je suis heureux de donner un indice, mais il vaut mieux deviner par vous-m√™me. <br><br><h1>  Trier? </h1><br>  Certains candidats intelligents souhaitent trier la liste des synonymes, puis utiliser la recherche binaire.  En fait, cette approche pr√©sente un avantage important: elle ne n√©cessite pas d'espace suppl√©mentaire, √† l'exception de la liste des synonymes (√† condition que la liste puisse √™tre modifi√©e). <br><br>  Malheureusement, la complexit√© temporelle interf√®re: le tri d'une liste de synonymes n√©cessite du temps <code>Nlog(N)</code> , puis un autre <code>log(N)</code> pour rechercher chaque paire de synonymes, tandis que la solution de pr√©traitement d√©crite se d√©roule en temps lin√©aire puis constant.  De plus, je suis cat√©goriquement contre de forcer le candidat √† impl√©menter le tri et la recherche binaire sur le tableau, car: 1) les algorithmes de tri sont bien connus, donc, √† ma connaissance, le candidat peut le publier sans r√©fl√©chir;  2) ces algorithmes sont diaboliquement difficiles √† mettre en ≈ìuvre correctement, et souvent m√™me les meilleurs candidats font des erreurs qui ne disent rien sur leurs comp√©tences en programmation. <br><br>  Chaque fois qu'un candidat proposait une telle solution, j'√©tais int√©ress√© par le temps d'ex√©cution du programme et demandais s'il y avait une meilleure option.  Pour information: si l'enqu√™teur vous demande s'il existe une meilleure option, la r√©ponse est presque toujours oui.  Si jamais je vous pose cette question, la r√©ponse sera certainement celle-l√†. <br><br><h4>  Enfin solution </h4><br>  Au final, le candidat propose quelque chose de correct et raisonnablement optimal.  Voici une impl√©mentation en temps lin√©aire et en espace lin√©aire pour des conditions donn√©es: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">synonym_queries</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(synonym_words, queries)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">''' synonym_words: iterable of pairs of strings representing synonymous words queries: iterable of pairs of strings representing queries to be tested for synonymous-ness '''</span></span> synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1].add(w2) output = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> q1, q2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> queries: q1, q2 = q1.split(), q2.split() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(q1) != len(q2): output.append(<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(q1)): w1, w2 = q1[i], q2[i] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1 == w2: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> ((w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w1]) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w2])): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> output.append(result) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output</code> </pre> <br>  Quelques notes rapides: <br><br><ul><li>  Notez l'utilisation de <code>dict.get()</code> .  Vous pouvez impl√©menter une v√©rification pour voir si la cl√© est dans le dict, puis l'obtenir, mais c'est une approche compliqu√©e, bien que de cette fa√ßon vous montrerez votre connaissance de la biblioth√®que standard. </li><li>  Personnellement, je ne suis pas un fan de code avec une <code>continue</code> fr√©quente et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">certains guides de style les interdisent ou ne les recommandent pas</a> .  J'ai moi-m√™me dans la premi√®re √©dition de ce code oubli√© la d√©claration <code>continue</code> apr√®s avoir v√©rifi√© la longueur de la demande.  Ce n'est pas une mauvaise approche, sachez simplement qu'elle est sujette aux erreurs. </li></ul><br><h1>  Partie 2: devient plus difficile! </h1><br>  Les bons candidats, apr√®s avoir r√©solu le probl√®me, ont encore dix √† quinze minutes de temps.  Heureusement, il y a un tas de questions suppl√©mentaires, bien qu'il soit peu probable que nous √©crivions beaucoup de code pendant cette p√©riode.  Cependant, ce n'est pas n√©cessaire.  Je veux savoir deux choses sur le candidat: est-il capable de d√©velopper des algorithmes et est-il capable de coder?  Le probl√®me avec le mouvement du chevalier r√©pond d'abord √† la question de d√©velopper un algorithme, puis v√©rifie le codage, et ici nous obtenons les r√©ponses dans l'ordre inverse. <br><br>  Au moment o√π le candidat a termin√© la premi√®re partie de la question, il avait d√©j√† r√©solu le probl√®me du codage (√©tonnamment non trivial).  √Ä ce stade, je peux parler en toute confiance de sa capacit√© √† d√©velopper des algorithmes rudimentaires et √† traduire des id√©es en code, ainsi que de sa connaissance de son langage pr√©f√©r√© et de sa biblioth√®que standard.  Maintenant, la conversation devient beaucoup plus int√©ressante, car les exigences de programmation peuvent √™tre assouplies et nous allons plonger dans les algorithmes. <br><br>  Pour cela, nous revenons aux principaux postulats de la premi√®re partie: l'ordre des mots est important, les synonymes sont non transitifs et pour chaque mot il peut y avoir plusieurs synonymes.  Au fur et √† mesure de l'entretien, je modifie chacune de ces restrictions, et dans cette nouvelle phase, le candidat et moi avons une discussion purement algorithmique.  Ici, je vais donner des exemples de code pour illustrer mon point de vue, mais dans une vraie interview, nous ne parlons que d'algorithmes. <br><br>  Avant de commencer, je vais expliquer ma position: toutes les actions ult√©rieures √† ce stade de l‚Äôentretien sont principalement des ¬´points bonus¬ª.  Mon approche personnelle consiste √† identifier les candidats qui franchissent exactement la premi√®re √©tape et sont aptes au travail.  La deuxi√®me √©tape est n√©cessaire pour mettre en valeur le meilleur.  La premi√®re note est d√©j√† tr√®s forte et signifie que le candidat est assez bon pour l'entreprise, et la deuxi√®me note dit que le candidat est excellent et son embauche sera une grande victoire pour nous. <br><br><h1>  Transitivit√©: approches na√Øves </h1><br>  Tout d'abord, j'aime supprimer la contrainte de transitivit√©, donc si les paires A - B et B - C sont synonymes, alors les mots A et C sont √©galement synonymes.  Les candidats intelligents comprendront rapidement comment adapter leur solution pr√©c√©dente, bien qu'avec la suppression suppl√©mentaire d'autres restrictions, la logique de base de l'algorithme cessera de fonctionner. <br><br>  Mais comment l'adapter?  Une approche courante consiste √† conserver un ensemble complet de synonymes pour chaque mot en fonction des relations transitives.  Chaque fois que nous ins√©rons un mot dans un ensemble de synonymes, nous l'ajoutons √©galement aux ensembles correspondants pour tous les mots de cet ensemble: <br><br><pre> <code class="python hljs">synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w1]: synonyms[w].add(w2) synonyms[w1].add(w2) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w2]: synonyms[w].add(w1) synonyms[w2].add(w1)</code> </pre> <br>  <i><font color="gray">Veuillez noter que lors de la cr√©ation du code, nous avons d√©j√† explor√© cette solution.</font></i> <br><br>  Cette solution fonctionne, mais loin d'√™tre optimale.  Pour comprendre les raisons, nous estimons la complexit√© spatiale de cette solution.  Chaque synonyme doit √™tre ajout√© non seulement √† l'ensemble du mot initial, mais √©galement aux ensembles de tous ses synonymes.  S'il existe un synonyme, une entr√©e est ajout√©e.  Mais si nous avons 50 synonymes, vous devez ajouter 50 entr√©es.  Dans la figure, cela ressemble √† ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3f/ab6/e25/e3fab6e25d14821ec06d623925db9ac5.png"></div><br><br>  Notez que nous sommes pass√©s de trois cl√©s et six enregistrements √† quatre cl√©s et douze enregistrements.  Un mot avec 50 synonymes n√©cessitera 50 touches et pr√®s de 2500 entr√©es.  L'espace n√©cessaire pour repr√©senter un mot augmente de fa√ßon quadratique avec une augmentation de l'ensemble des synonymes, ce qui est plut√¥t inutile. <br><br>  Il existe d'autres solutions, mais je n'irai pas trop loin pour ne pas gonfler l'article.  Le plus int√©ressant d'entre eux est l'utilisation de la structure de donn√©es synonyme pour construire un graphe orient√©, puis une recherche en premier pour trouver le chemin entre deux mots.  C'est une excellente solution, mais la recherche devient de taille lin√©aire dans l'ensemble des synonymes du mot.  Comme nous effectuons cette recherche plusieurs fois pour chaque demande, cette approche n'est pas optimale. <br><br><h1>  Transitivit√©: utilisation d'ensembles disjoints </h1><br>  Il s'av√®re que la recherche de synonymes est possible pendant un temps (presque) constant gr√¢ce √† une structure de donn√©es appel√©e ensembles disjoints.  Cette structure offre des possibilit√©s l√©g√®rement diff√©rentes d'un ensemble de donn√©es classique. <br><br>  La structure d'ensemble habituelle (hashset, treeset) est un conteneur qui vous permet de d√©terminer rapidement si un objet se trouve √† l'int√©rieur ou √† l'ext√©rieur de celui-ci.  Les ensembles disjoints r√©solvent un probl√®me compl√®tement diff√©rent: au lieu de d√©finir un √©l√©ment sp√©cifique, ils vous permettent de d√©terminer <i>si deux √©l√©ments appartiennent au m√™me ensemble</i> .  De plus, la structure le fait pour un temps <code>O(a(n))</code> extr√™mement rapide, o√π <code>a(n)</code> est la fonction Ackerman inverse.  Si vous n'avez pas √©tudi√© les algorithmes avanc√©s, vous ne connaissez peut-√™tre pas cette fonction qui, pour toutes les entr√©es raisonnables, est en fait ex√©cut√©e en temps constant. <br><br>  √Ä un niveau √©lev√©, l'algorithme fonctionne comme suit.  Les ensembles sont repr√©sent√©s par des arbres avec des parents pour chaque √©l√©ment.  √âtant donn√© que chaque arbre a une racine (un √©l√©ment qui est son propre parent), nous pouvons d√©terminer si deux √©l√©ments appartiennent au m√™me ensemble en tra√ßant leurs parents jusqu'√† la racine.  Si deux √©l√©ments ont une racine, ils appartiennent √† un ensemble.  La combinaison d'ensembles est √©galement simple: il suffit de trouver les √©l√©ments racine et de faire de l'un d'eux la racine de l'autre. <br><br>  Jusqu'ici tout va bien, mais jusqu'√† pr√©sent, aucune vitesse √©blouissante n'a √©t√© observ√©e.  Le g√©nie de cette structure r√©side dans une proc√©dure appel√©e <i>compression</i> .  Supposons que vous ayez l'arborescence suivante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4b/132/102/e4b13210226d0375adc1acf7835ef4a2.png"></div><br><br>  Imaginez que vous vouliez savoir si <i>rapide</i> et <i>h√¢tif</i> sont synonymes.  Passez par chaque parent - et trouvez la m√™me racine <i>rapide</i> .  Supposons maintenant que nous effectuions une v√©rification similaire pour les mots <i>rapides</i> et <i>rapides</i> .  Encore une fois, nous montons √† la racine, et √† grande <i>vitesse,</i> nous empruntons le m√™me chemin.  La duplication des travaux peut-elle √™tre √©vit√©e? <br><br>  Il s'av√®re que vous le pouvez.  Dans un sens, chaque √©l√©ment de cet arbre est destin√© √† venir au <i>je√ªne</i> .  Au lieu de parcourir l'arborescence enti√®re √† chaque fois, pourquoi ne pas changer le parent de tous <i>les</i> descendants <i>rapides</i> pour raccourcir la route vers la racine?  Ce processus est appel√© compression et, dans les ensembles disjoints, il est int√©gr√© √† l'op√©ration de recherche racine.  Par exemple, apr√®s la premi√®re op√©ration de comparaison <i>rapide</i> et <i>rapide, la</i> structure comprendra qu'il s'agit de synonymes et compressera l'arborescence comme suit: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d4/381/3b9/2d43813b9925bf86d0e4b3a2c9a99707.png"></div><br>  <i><font color="gray">Pour tous les mots entre rapide et rapide, le parent a √©t√© mis √† jour, la m√™me chose s'est produite avec h√¢te</font></i> <br><br>  Maintenant, tous les appels suivants se produiront en temps constant, car chaque n≈ìud de cet arbre pointe vers <i>rapide</i> .  Il n'est pas tr√®s facile d'√©valuer la complexit√© temporelle des op√©rations: en fait, elle n'est pas constante, car elle d√©pend de la profondeur des arbres, mais elle est proche de constante, car la structure est rapidement optimis√©e.  Pour simplifier, nous supposons que le temps est constant. <br><br>  Avec ce concept, nous impl√©mentons des ensembles non li√©s √† notre probl√®me: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DisjointSet</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.parents = {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_root</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, w)</span></span></span><span class="hljs-function">:</span></span> words_traversed = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> self.parents[w] != w: words_traversed.append(w) w = self.parents[w] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> word <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> words_traversed: self.parents[word] = w <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> w <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_synonyms</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, w1, w2)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1 <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.parents: self.parents[w1] = w1 <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w2 <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.parents: self.parents[w2] = w2 w1_root = self.get_root(w1) w2_root = self.get_root(w2) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1_root &lt; w2_root: w1_root, w2_root = w2_root, w1_root self.parents[w2_root] = w1_root <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">are_synonymous</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, w1, w2)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.get_root(w1) == self.get_root(w2)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En utilisant cette structure, vous pouvez pr√©traiter des synonymes et r√©soudre le probl√®me en temps lin√©aire. </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Note et notes </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä ce stade, nous avons atteint la limite de ce qu'un candidat peut montrer en 40 √† 45 minutes d'entrevue. </font><font style="vertical-align: inherit;">√Ä tous les candidats qui ont fait face √† la partie introductive et qui ont fait des progr√®s significatifs dans la description (pas la mise en ≈ìuvre) d'ensembles non li√©s, j'ai attribu√© la note ¬´Hautement recommand√© pour l'emploi¬ª et leur ai permis de poser des questions. </font><font style="vertical-align: inherit;">Je n'ai jamais vu un candidat aller aussi loin et il me reste beaucoup de temps. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En principe, il existe encore des variantes du probl√®me de la transitivit√©: par exemple, supprimer la restriction sur l'ordre des mots ou sur plusieurs synonymes d'un mot. </font><font style="vertical-align: inherit;">Chaque d√©cision sera difficile et d√©licieuse, mais je les laisserai pour plus tard.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le m√©rite de cette t√¢che est qu'elle permet aux candidats de faire des erreurs. </font><font style="vertical-align: inherit;">Le d√©veloppement logiciel quotidien consiste en des cycles sans fin d'analyse, d'ex√©cution et de raffinement. </font><font style="vertical-align: inherit;">Ce probl√®me permet aux candidats de d√©montrer leurs capacit√©s √† chaque √©tape. </font><font style="vertical-align: inherit;">Consid√©rez les comp√©tences n√©cessaires pour obtenir le score maximum sur cette question:</font></font><br><br><ul><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analyser l'√©nonc√© du probl√®me</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©terminer o√π il n'est pas clairement formul√©</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , d√©velopper une formulation non ambigu√´. </font><font style="vertical-align: inherit;">Continuez √† le faire pendant que vous r√©solvez et que de nouvelles questions surgissent. </font><font style="vertical-align: inherit;">Pour une efficacit√© maximale, effectuez ces op√©rations le plus t√¥t possible, car plus le travail est avanc√©, plus il faudra de temps pour corriger l'erreur.</font></font><br></li><li> <i> </i>  ,        .       ,         . <br></li><li> <i>  </i> .          ,    ,      . <br></li><li>  , <i>    </i> .     ,      <code>continue</code> ,   ,     . <br></li><li>    , <i>  :   ,   </i> ,    ,    . ,      ,       ,    . <br></li><li> <i>    </i> .   ‚Äî    ,          .        ‚Äî    . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aucune de ces comp√©tences ne peut √™tre apprise des manuels (√† l'exception peut-√™tre des structures de donn√©es et des algorithmes). </font><font style="vertical-align: inherit;">La seule fa√ßon de les acqu√©rir est de pratiquer r√©guli√®rement et largement, ce qui est en bon accord avec ce dont l'employeur a besoin: des candidats exp√©riment√©s qui sont capables d'appliquer efficacement leurs connaissances. </font><font style="vertical-align: inherit;">Le but des interviews √©tait de trouver de telles personnes, et la t√¢che de cet article m'a bien aid√© pendant longtemps.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plans futurs </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme vous pouvez le comprendre, la t√¢che a finalement </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©t√© connue du public</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Depuis lors, j'ai utilis√© plusieurs autres questions, en fonction de ce que les intervieweurs pr√©c√©dents m'ont demand√© et de mon humeur (poser une question est tout le temps ennuyeux). J'utilise toujours quelques questions, donc je vais les garder secr√®tes, mais certaines ne le sont pas! Vous pouvez les trouver dans les articles suivants. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans un avenir proche, je pr√©vois deux articles. Tout d'abord, comme promis ci-dessus, je vais expliquer la solution aux deux probl√®mes restants pour cette t√¢che. Je ne leur ai jamais pos√© de questions lors des interviews, mais elles sont int√©ressantes en elles-m√™mes. En outre, je partagerai mes r√©flexions et mon opinion personnelle sur la proc√©dure de recherche d'employ√©s en informatique, ce qui est particuli√®rement int√©ressant pour moi maintenant, car je recherche des ing√©nieurs pour mon √©quipe dans Reddit.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme toujours, si vous souhaitez √™tre inform√© de la sortie de nouveaux articles, suivez-moi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur Twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Medium</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si vous avez aim√© cet article, n'oubliez pas de voter pour lui ou de laisser un commentaire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merci d'avoir lu! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS: Vous pouvez examiner le code de tous les articles dans </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le d√©p√¥t GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jouer avec eux en </font><font style="vertical-align: inherit;">direct</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gr√¢ce √† mes bons amis de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repl.it</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr437702/">https://habr.com/ru/post/fr437702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr437686/index.html">Learning Go: √©crire un messager p2p avec un cryptage de bout en bout</a></li>
<li><a href="../fr437688/index.html">OpenSceneGraph: Techniques de programmation de base</a></li>
<li><a href="../fr437694/index.html">Analyse de l'utilitaire Files.walkFileTree ();</a></li>
<li><a href="../fr437696/index.html">Le condens√© de mat√©riaux int√©ressants pour le d√©veloppeur mobile # 283 (du 21 au 27 janvier)</a></li>
<li><a href="../fr437698/index.html">Service de traduction de brevets de l'OMPI Translate - Mes exp√©riences</a></li>
<li><a href="../fr437704/index.html">Excellente connaissance du programme scolaire en tant qu'indicateur d'une intelligence pas la plus √©lev√©e</a></li>
<li><a href="../fr437706/index.html">Ann√©e avec Tesla</a></li>
<li><a href="../fr437710/index.html">Limiter au minimum les droits des utilisateurs locaux sur Linux</a></li>
<li><a href="../fr437712/index.html">Station spatiale Roskomnadzor</a></li>
<li><a href="../fr437714/index.html">Nous dessinons une explosion de dessin anim√© pour 180 lignes de C ++ nu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>