<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🔬 😂 😏 Beschleunigen von WebGL / Three.js mit OffscreenCanvas und Web Workers 🛀🏽 👨🏿‍💻 🧙🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Tutorial werde ich Ihnen OffscreenCanvas , wie ich mit OffscreenCanvas den gesamten Code für die Arbeit mit WebGL und Three.js in einen sepa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Beschleunigen von WebGL / Three.js mit OffscreenCanvas und Web Workers</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446682/"><img src="https://habrastorage.org/webt/bf/on/iy/bfoniye-iabtwkniabif7hbru48.png" alt="Beschleunigen von WebGL / Three.js mit OffscreenCanvas und Web Workers"><br><br>  In diesem Tutorial werde ich Ihnen <code>OffscreenCanvas</code> , wie ich mit <code>OffscreenCanvas</code> den gesamten Code für die Arbeit mit WebGL und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Three.js</a> in einen separaten Webworker-Thread <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eingefügt habe</a> .  Dies beschleunigte die Arbeit der Site und auf schwachen Geräten verschwanden Friese beim Laden der Seite. <br><br>  Der Artikel basiert auf persönlichen Erfahrungen, als ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meiner Website</a> rotierende 3D-Erde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hinzufügte</a> und in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google Lighthouse</a> 5 Produktivitätspunkte benötigte - zu viel für einfache Vorführungen. <a name="habracut"></a><br><br><h2>  Das Problem </h2><br>  Three.js verbirgt viele komplexe WebGL-Probleme, hat jedoch einen erheblichen Preis: Die Bibliothek fügt Ihrem JS-Build für Browser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">563 KB</a> hinzu (und die Bibliotheksarchitektur ermöglicht kein effizientes Trichashing). <br><br>  Einige mögen sagen, dass Bilder oft die gleichen 500 KB wiegen - und sehr falsch sind.  Jede KB des Skripts ist wesentlich leistungsfähiger als die KB des Bildes.  Damit eine Site schnell ist, müssen Sie nicht nur die Kanalbreite und die Verzögerungszeit berücksichtigen, sondern auch die Betriebszeit der CPU des Computers für die Verarbeitung von Dateien.  Auf Telefonen und schwachen Laptops kann die Verarbeitung länger dauern als das Laden. <br><br><img src="https://habrastorage.org/webt/zv/s5/fs/zvs5fskgph3-pyhnf1c7v1xkz-0.png" alt="Die 170K JS-Verarbeitung dauert 3,5 Sekunden gegenüber 0,1 Sekunden für 170K-Bilder"><br>  <i>Die 170K JS-Verarbeitung dauert 3,5 Sekunden gegenüber 0,1 Sekunden für 170K-Bilder - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eddie Osmani</a></i> <br><br>  Während der Browser 500 KB Three.js ausführt, wird der Hauptseitenfluss blockiert und der Benutzer sieht den Schnittstellenfries. <br><br><h2>  Web Worker und Offscreen Canvas </h2><br>  Wir haben seit langem die Lösung gefunden, den Fries während der langen Laufzeit von JS-Web-Workern, die den Code in einem separaten Thread ausführen, nicht zu entfernen. <br><br>  Damit die Arbeit mit Web-Workern nicht zur Hölle der Multithread-Programmierung wird, hat ein Web-Worker keinen Zugriff auf das DOM.  Nur der Hauptthread funktioniert mit der HTML-Seite.  Aber wie kann man Three.js ohne Zugriff auf das DOM starten, was direkten Zugriff auf <code>&lt;canvas&gt;</code> erfordert? <br><br>  Zu diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zweck</a> gibt es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OffscreenCanvas</a> , mit dem Sie <code>&lt;canvas&gt;</code> an einen Web-Worker übergeben können.  Um die Tore der Multithread-Hölle nicht zu öffnen, verliert der Haupt-Thread nach der Übertragung den Zugriff auf diese <code>&lt;canvas&gt;</code> - nur ein Thread wird damit arbeiten. <br><br>  Es scheint, dass wir dem Ziel nahe sind, aber es stellt sich heraus, dass nur Chrome <code>OffscreenCanvas</code> unterstützt. <br><br><img src="https://habrastorage.org/webt/hc/nk/eu/hcnkeuc2-0yaa58te6qt_wrrc8g.png" alt="Nur Chrome unterstützt OffscreenCanvas"><br>  <i>OffscreenCanvas-Unterstützung für April 2019 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gemäß Can I Use</a></i> <br><br>  Aber auch hier sollten wir angesichts des Hauptfeindes des Webentwicklers, der Browserunterstützung, nicht aufgeben.  Wir kommen zusammen und finden das letzte Element des Puzzles - dies ist ein idealer Fall für "progressive Verbesserung".  In Chrome und zukünftigen Browsern entfernen wir den Fries und andere Browser funktionieren wie zuvor. <br><br>  Daher müssen wir eine Datei schreiben, die in zwei verschiedenen Umgebungen gleichzeitig arbeiten kann - in einem Web-Worker und in einem regulären Haupt-JS-Stream. <br><br><h2>  Lösung </h2><br>  Um die Hacks unter einer Zuckerschicht zu verstecken, habe ich eine kleine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Offscreen-Canvas-</a> JS-Bibliothek mit 400 Bytes (!) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellt</a> .  In den Beispielen wird der Code es verwenden, aber ich werde Ihnen sagen, wie es "unter der Haube" funktioniert. <br><br>  Beginnen wir mit der Installation der Bibliothek: <br><br><pre> <code class="bash hljs">npm install offscreen-canvas</code> </pre> <br>  Wir benötigen eine separate JS-Datei für den Web-Worker. Erstellen Sie eine separate Assembly-Datei in Webpack oder Parcel: <br><br><pre> <code class="diff hljs"> entry: { 'app': './src/app.js', + 'webgl-worker': './src/webgl-worker.js' }</code> </pre><br>  Die Kollektoren ändern den Dateinamen während der Bereitstellung aufgrund von Cache-Bustern ständig. Wir müssen den Namen mithilfe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Preload-Tags</a> in HTML schreiben.  Hier ist das Beispiel abstrakt, da der tatsächliche Code stark von den Funktionen Ihrer Assembly abhängt. <br><br><pre> <code class="html hljs xml"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">link</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"preload"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">as</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"script"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"./webgl-worker.js"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Jetzt müssen wir den DOM-Knoten für die <code>&lt;canvas&gt;</code> und den Inhalt des Preload-Tags in der Haupt-JS-Datei abrufen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> createWorker <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'offscreen-canvas/create-worker'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> workerUrl = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'[rel=preload][as=script]'</span></span>).href <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> canvas = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'canvas'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> worker = createWorker(canvas, workerUrl)</code> </pre><br>  <a href=""><code>createWorker</code></a> wenn <a href=""><code>createWorker</code></a> vorhanden ist, <code>canvas.transferControlToOffscreen</code> die JS-Datei in den Web Worker.  Und in Abwesenheit dieser Methode - wie ein reguläres <code>&lt;script&gt;</code> . <br><br>  Erstellen Sie diese <code>webgl-worker.js</code> für den Arbeiter: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> insideWorker <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'offscreen-canvas/inside-worker'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> worker = insideWorker(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.data.canvas) { <span class="hljs-comment"><span class="hljs-comment">//       &lt;canvas&gt; } })</span></span></code> </pre><br>  <a href=""><code>insideWorker</code></a> prüft, ob es in einen Web Worker geladen wurde.  Abhängig von der Umgebung werden verschiedene Kommunikationssysteme mit dem Hauptthread gestartet. <br><br>  Die Bibliothek führt für jede neue Nachricht vom Hauptthread eine an <code>insideWorker</code> Funktion aus.  Unmittelbar nach dem Laden <code>createWorker</code> die erste Nachricht <code>{ canvas, width, height }</code> <code>createWorker</code> <code>{ canvas, width, height }</code> um den ersten Frame auf <code>&lt;canvas&gt;</code> zu zeichnen. <br><br><pre> <code class="diff hljs"><span class="hljs-addition"><span class="hljs-addition">+ import { + WebGLRenderer, Scene, PerspectiveCamera, AmbientLight, + Mesh, SphereGeometry, MeshPhongMaterial + } from 'three' import insideWorker from 'offscreen-canvas/inside-worker' + const scene = new Scene() + const camera = new PerspectiveCamera(45, 1, 0.01, 1000) + scene.add(new AmbientLight(0x909090)) + + let sphere = new Mesh( + new SphereGeometry(0.5, 64, 64), + new MeshPhongMaterial() + ) + scene.add(sphere) + + let renderer + function render () { + renderer.render(scene, camera) + } const worker = insideWorker(e =&gt; { if (e.data.canvas) { + // canvas  -    —    ,     Three.js + if (!canvas.style) canvas.style = { width, height } + renderer = new WebGLRenderer({ canvas, antialias: true }) + renderer.setPixelRatio(pixelRatio) + renderer.setSize(width, height) + + render() } })</span></span></code> </pre><br>  Wenn Sie Ihren alten Code für Three.js auf einen Web-Worker portieren, werden möglicherweise Fehler angezeigt, da der Web-Worker keine DOM-API hat.  Beispielsweise gibt es kein <code>document.createElement</code> zum Laden von SVG-Texturen.  Daher benötigen wir manchmal verschiedene Lader in einem Web-Worker und in einem regulären Skript.  Um die Art der Umgebung zu überprüfen, haben wir <code>worker.isWorker</code> : <br><br><pre> <code class="diff hljs"> renderer.setPixelRatio(pixelRatio) renderer.setSize(width, height) + const loader = worker.isWorker ? new ImageBitmapLoader() : new ImageLoader() + loader.load('/texture.png', mapImage =&gt; { + sphere.material.map = new CanvasTexture(mapImage) + render() + }) render()</code> </pre><br>  Wir haben den ersten Frame gezeichnet.  Die meisten WebGL-Szenen sollten jedoch auf Benutzeraktionen reagieren.  Drehen Sie beispielsweise die Kamera, wenn sich der Cursor bewegt, oder zeichnen Sie einen Rahmen, wenn die Fenstergröße geändert wird.  Leider kann der Web-Worker keine DOM-Ereignisse abhören.  Wir müssen sie im Hauptstrom anhören und Nachrichten an den Web-Worker senden. <br><br><pre> <code class="diff hljs"> import createWorker from 'offscreen-canvas/create-worker' const workerUrl = document.querySelector('[rel=preload][as=script]').href const canvas = document.querySelector('canvas') const worker = createWorker(canvas, workerUrl) + window.addEventListener('resize', () =&gt; { + worker.post({ + type: 'resize', width: canvas.clientWidth, height: canvas.clientHeight + }) + })</code> </pre><br><pre> <code class="diff hljs"> const worker = insideWorker(e =&gt; { if (e.data.canvas) { if (!canvas.style) canvas.style = { width, height } renderer = new WebGLRenderer({ canvas, antialias: true }) renderer.setPixelRatio(pixelRatio) renderer.setSize(width, height) const loader = worker.isWorker ? new ImageBitmapLoader() : new ImageLoader() loader.load('/texture.png', mapImage =&gt; { sphere.material.map = new CanvasTexture(mapImage) render() }) render() - } + } else if (e.data.type <span class="hljs-comment"><span class="hljs-comment">=== 'resize') { + renderer.setSize(width, height) + render() + } })</span></span></code> </pre><br><h2>  Ergebnis </h2><br>  Mit <code>OffscreenCanvas</code> ich Friese auf meiner Website besiegt und 100% Punkte bei Google Lighthouse erhalten.  Und WebGL funktioniert in allen Browsern, auch ohne <code>OffscreenCanvas</code> Unterstützung. <br><br>  Sie können sich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Live-Site</b></a> und den <b>Quellcode des</b> <a href="">Hauptthreads</a> oder <a href="">Workers</a> ansehen. <br><br><img src="https://habrastorage.org/webt/yl/0o/dw/yl0odwd7t8cz8xmdvgxzd-f1uni.png"><br>  <i>Mit OffscreenCanvas stieg die Brille von Google Lighthouse von 95 auf 100</i> <br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446682/">https://habr.com/ru/post/de446682/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446668/index.html">Python für das Web: Was ein Junior wissen muss, um zu arbeiten und zu wachsen</a></li>
<li><a href="../de446674/index.html">Wir modellieren den MUSIC-Algorithmus zur Bestimmung der Ankunftsrichtung einer elektromagnetischen Welle</a></li>
<li><a href="../de446676/index.html">Fehlende Schlüssel für die Commodore 116-Gummitastatur erstellen</a></li>
<li><a href="../de446678/index.html">Live Battle: Porto ICPC Finale</a></li>
<li><a href="../de446680/index.html">Der Hauptinstinkt des Encoders besteht darin, ineffektive Lösungen von überall zu entfernen</a></li>
<li><a href="../de446688/index.html">SIMD-Erweiterung auf C ++ OpenMP in Visual Studio</a></li>
<li><a href="../de446690/index.html">Electrolux bringt intelligente Luftreiniger für die am stärksten verschmutzten Städte auf den Markt</a></li>
<li><a href="../de446694/index.html">JBOD modularer Speicher und Freiheitsgrade</a></li>
<li><a href="../de446696/index.html">Mythen über 152-FZ, die für den Betreiber personenbezogener Daten teuer sein können</a></li>
<li><a href="../de446700/index.html">Lazydocker - GUI für Docker direkt im Terminal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>