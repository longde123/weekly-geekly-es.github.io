<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ù§Ô∏è üë∂üèª ‚ô•Ô∏è Wandering Monster: Wie man Probleme auf der Karte beseitigt üçü ü§≤ üëßüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bereits im Prozess der Erstellung von The Witness ist eines meiner Lieblingsspiele geworden. Ich begann es von dem Moment an zu spielen, als Jonathan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wandering Monster: Wie man Probleme auf der Karte beseitigt</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423519/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/24d/6ba/bda24d6ba69e530c352a7d9a0e3c8a3a.png" alt="Bild"></div><br>  Bereits im Prozess der Erstellung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The Witness</a> ist eines meiner Lieblingsspiele geworden.  Ich begann es von dem Moment an zu spielen, als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jonathan Blow</a> anfing, es zu entwickeln, und konnte es kaum erwarten, dass es ver√∂ffentlicht wurde. <br><br>  Im Gegensatz zu John <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Braids</a> vorherigem Spiel war <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die</a> Ressourcen- und Programmierskala von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The Witness</a> AAA-Projekten viel n√§her als Indie-Spielen.  Jeder, der an solchen Projekten arbeitet, wei√ü, dass der Arbeitsaufwand bei der Auswahl dieses Pfades erheblich zunimmt.  Es arbeiteten viel mehr Leute an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The Witness</a> als an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Braid</a> , aber wie bei jedem Projekt dieser Ebene gibt es viele Aspekte, die mehr Aufmerksamkeit erfordern, als sich das Projektmanagement leisten kann. <br><br>  Deshalb wollte ich immer Freizeit finden, um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The Witness</a> bei der Ver√∂ffentlichung des Spiels zu unterst√ºtzen.  Eines Tages setzten sich Thanksgiving, John und ich zusammen und sahen uns die Liste der Dinge in der Codebasis an, die von zus√§tzlichen Anstrengungen eines anderen Programmierers profitieren w√ºrden.  Nachdem wir uns f√ºr die relative Bedeutung der Elemente auf der Liste entschieden hatten, entschieden wir, dass das Gameplay am meisten davon profitieren wird, wenn wir den Bewegungscode des Spielers verbessern. <br><a name="habracut"></a><br><h2>  Walkmonster in der Wand </h2><br>  Im Kontext von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The Witness</a> ist es das Ziel des Bewegungscodes eines Spielers, so unauff√§llig wie m√∂glich zu sein.  Der Spieler muss vollst√§ndig in eine alternative Realit√§t eintauchen, und bei diesem Spielerlebnis ist jedes Detail wichtig.  Das Letzte, was wir wollten, war, dass der Spieler bemerkte, dass er am Computer sa√ü und die virtuelle Kamera bewegte. <br><br>  Daher muss der Bewegungscode des Spielers absolut zuverl√§ssig sein.  Wenn sich ein Spieler an Ecken festh√§lt, in W√§nden steckt, durch den Boden f√§llt, von einem H√ºgel herabsteigt, ohne zur√ºckgehen zu k√∂nnen usw., zerst√∂rt dies sofort die Illusion des Eintauchens und erinnert den Spieler daran, dass er sich in einem k√ºnstlichen Spielprozess befindet, der durch ein unzuverl√§ssiges System gest√∂rt wird Verschiebungen.  Unter bestimmten Umst√§nden kann dies sogar zu katastrophalen Folgen f√ºr den Spieler f√ºhren, wenn er nicht die M√∂glichkeit hat, das Problem durch einen Neustart des Spiels oder ein erneutes Laden des (wahrscheinlich sehr alten) "Speicherns" zu l√∂sen.  Wenn Sie oft Spiele spielen, m√ºssen Sie auf Probleme dieser Art gesto√üen sein, und Sie wissen, was ich meine. <br><br>  Nach unserer Diskussion begann ich mit der Arbeit an dieser Aufgabe.  Zun√§chst habe ich beschlossen, integrierte Tools f√ºr die Arbeit mit dem Bewegungscode des Spielers zu schreiben, damit wir ihn analysieren und sein aktuelles Verhalten beobachten k√∂nnen.  Nachdem ich das Projekt ge√∂ffnet hatte, stie√ü ich auf ein ernstes Problem, das mir bereits bekannt war: Wie soll ich die erste Quellcodedatei nennen?  Dies ist immer der wichtigste Teil eines Projekts ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie Bob Pollard einmal √ºber die Namen von Musikgruppen und Alben sagte</a> ).  Wenn Sie der Quelldatei einen geeigneten Namen geben, ist die weitere Arbeit klar und reibungslos.  W√§hlen Sie die falsche - Sie k√∂nnen das gesamte Projekt zerst√∂ren. <br><br>  Aber wie hei√üt das System, um die Qualit√§t des Bewegungscodes des Spielers sicherzustellen?  Ich musste noch nie so einen Code schreiben.  Als ich dar√ºber nachdachte, wurde mir klar, dass ich pers√∂nlich nur einmal ein Beispiel f√ºr einen solchen Code gesehen habe: beim Spielen der fr√ºhen Beta von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quake</a> .  Es enthielt Fehler mit der Position von Monstern, und im Konsolenfenster konnten Fehlermeldungen angezeigt werden, die besagten, dass Monster erstellt werden, anstatt auf der Erdoberfl√§che zu erstellen, die sich teilweise mit der Geometrie der Ebenen √ºberschneiden.  Jede Debug-Nachricht begann mit dem Satz "Walkmonster in Wall at ...". <br><br>  Bingo!  Es ist schwierig, einen besseren Namen f√ºr die Codedatei als "walk_monster.cpp" zu finden.  Und ich war mir fast sicher, dass der Code von nun an ohne Probleme erstellt werden w√ºrde. <br><br><h2>  Bewegung auf den Punkt </h2><br>  Wenn Sie das System testen m√∂chten, ist es am wichtigsten, <i>das System tats√§chlich zu testen</i> .  Obwohl diese Regel einfach zu sein scheint, halten sich Personen, die Tests schreiben, h√§ufig nicht daran. <br><br>  In unserem speziellen Fall ist es sehr leicht <i>vorstellbar,</i> dass wir den Bewegungscode eines Spielers testen, ohne ihn tats√§chlich zu testen.  Hier ein Beispiel: Sie k√∂nnen das Volumen von Kollisionen und Oberfl√§chen analysieren, auf denen Sie sich im Spiel bewegen k√∂nnen, nach kleinen Oberfl√§chen, L√ºcken usw. suchen.  Nachdem wir all diese Probleme beseitigt haben, k√∂nnen wir sagen, dass der Spieler sich jetzt sicher bewegen und um die Welt gehen kann. <br><br>  Tats√§chlich haben wir die Daten getestet, nicht den Code.  Es ist sehr wahrscheinlich, dass der Bewegungscode Fehler enth√§lt, die selbst bei qualitativ hochwertigen Daten zu einem schlechten Verhalten f√ºhren. <br><br>  Um eine solche Falle zu vermeiden, wollte ich, dass das Testsystem dem Verhalten der Person, die die Bewegung des Charakters im Spiel tats√§chlich kontrolliert, so nahe wie m√∂glich kommt.  Ich begann damit, zwei Verfahren zu schreiben, die die Bausteine ‚Äã‚Äãf√ºr solche Tests werden sollten. <br><br>  Das erste Verfahren kommt echten menschlichen Handlungen am n√§chsten.  Dies ist ein Aktualisierungsaufruf, der eine Verbindung zum Eingabeverarbeitungssystem von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The Witness</a> herstellt und die synthetisierten Tastatur- und Mausereignisse an dieses √ºbergibt.  Es ist zu einfachen Dingen f√§hig, die eine Person tun kann: sich umsehen, zu einem Punkt gehen, einen Punkt betrachten und so weiter.  Die Prozedur f√ºhrt diese Aktionen aus, indem sie einfach die Interaktion des Benutzers mit der Tastatur und der Maus emuliert. Ich war mir also sicher, dass bei der Verarbeitung der Eingabe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The Witness</a> alles genau so ausgef√ºhrt wird, wie es beim Testen war.  In den folgenden Artikeln werde ich mehr √ºber dieses System und seine Verwendung sprechen. <br><br>  Das zweite Verfahren ist ein Schritt, der auf dieser Ebene nicht verwendet wird.  Dies ist eine Funktion namens <i>DriveTowardPoint</i> , die zwei Punkte in der Welt erh√§lt und aufgrund eines vorhandenen Kollisionssystems eines Spielers versucht, nahtlos von einem Punkt zum anderen zu gelangen.  Bei der R√ºckgabe √ºbermittelt sie Informationen √ºber den Versuch: Auf welche Hindernisse sie unterwegs gesto√üen ist und ob sie den Endpunkt erreicht hat. <br><br>  Diese Funktion ist nicht so zuverl√§ssig wie eine Testmethode mit synthetisierten Eingaben, da ein Teil des Bewegungssystems des Spielers nicht mehr getestet werden kann.  Beispielsweise wirkt sich eine fehlerhafte Bedingung, die mit dem Standort des Spielers bei Problemen mit dem Kollisionssystem verbunden ist, nicht auf das Testen mit dieser Funktion aus.  Trotzdem hielt ich diese Teststufe f√ºr wertvoll, da sie gro√üe Gebiete viel schneller testen kann, da nicht der gesamte Spielzyklus ausgef√ºhrt werden muss, dh sie kann weltweit viel h√§ufiger verwendet werden und nicht nur in separaten Testl√§ufen . <br><br>  Es ist auch erw√§hnenswert, dass diese Funktion keine physischen Eingabedaten √ºbertr√§gt.  Beispielsweise werden Geschwindigkeiten f√ºr den Startpunkt nicht angezeigt.  Dies liegt daran, dass <i>The Witness</i> kein Actionspiel ist und der Spieler daher nur wenige signifikante physikalische Eigenschaften hat.  Spieler k√∂nnen nicht springen, an W√§nden rennen oder die Kugelzeit einschalten.  Sie k√∂nnen solche Verhaltensweisen mithilfe von Systemen unterst√ºtzen, die ich sp√§ter beschreiben werde. Sie erh√∂hen jedoch die Komplexit√§t, die in unserem Projekt nicht erforderlich waren. <br><br>  Wie dem auch sei, nach der Implementierung von <i>DriveTowardPoint</i> k√∂nnte ich beginnen, die erste Aufgabe des Systems zu l√∂sen: zu bestimmen, wo der Spieler nach <i>The Witness</i> Island ziehen kann. <br><br><h2>  Schnelle Erkundung zuf√§lliger B√§ume </h2><br>  Wohin k√∂nnen Spieler gehen?  Dies scheint eine einfache Frage zu sein, aber Sie werden √ºberrascht sein, wie viele Spiele ver√∂ffentlicht wurden, als das Entwicklerteam die richtige Antwort nicht kannte.  Wenn dies m√∂glich ist, wollte ich, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The Witness</a> eines der wenigen Spiele ist, in denen Entwickler vor der Ver√∂ffentlichung genau wussten, wo ein Spieler hin konnte und was nicht - keine √úberraschungen. <br><br>  Dies macht die Problemstellung (aber wahrscheinlich nicht ihre L√∂sung) sehr einfach: Wenn es eine <i>DriveTowardPoint-</i> Funktion gibt, die zuverl√§ssig bestimmt, ob sich der Spieler in einer geraden Linie zwischen zwei Punkten bewegen kann, erstellen Sie eine Abdeckungskarte, die zeigt, wo sich der Spieler m√∂glicherweise befindet. <br><br>  Aus irgendeinem Grund, ohne eine einzige Codezeile zu schreiben, dachte ich aus irgendeinem Grund, dass es am besten w√§re, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rapidly Exploring Random Tree zu verwenden</a> .  F√ºr diejenigen, die mit diesem Algorithmus nicht vertraut sind, erkl√§re ich: Dies ist ein sehr einfacher Prozess, bei dem wir alle Punkte, die wir besucht haben, in Bezug auf den Punkt aufzeichnen, von dem wir gekommen sind.  Um dem Baum einen Punkt hinzuzuf√ºgen, nehmen wir einen zuf√§lligen Zielpunkt irgendwo auf der Welt, w√§hlen den Punkt aus, der ihm am n√§chsten liegt, bereits im Baum, und versuchen, von diesem Punkt zum Ziel zu gelangen.  Der Ort, an dem wir gelandet sind, wird zum n√§chsten Probenahmepunkt. <br><br>  Normalerweise wird dieser Algorithmus verwendet, um nach Pfaden zu suchen: Alternativ w√§hlen wir f√ºr zuf√§llige Punkte immer den gleichen Punkt wie das Ziel aus.  Dies neigt die Erforschung des Weltraums zum Zielpunkt, und dies ist erforderlich, wenn unsere einzige Aufgabe darin besteht, das Ziel zu erreichen.  In diesem Fall wollte ich jedoch eine vollst√§ndige Karte der Orte erstellen, in die der Spieler fallen k√∂nnte, daher verwende ich nur Zufallsstichproben. <br><br>  Nach der Implementierung dieses Algorithmus (zum Gl√ºck ist er sehr einfach und ben√∂tigt nicht viel Zeit) stellte ich fest, dass er die Raumforschung ziemlich gut erkundet hat (die gezeigten Pfade sind durch wei√üe Pfade dargestellt und die vertikalen roten Linien zeigen die Stellen an, an denen der Algorithmus mit einem Hindernis kollidierte). :: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed2/ca3/fe3/ed2ca3fe3dbfe02cb7c9779af50f9ca6.png"></div><br>  Nachdem ich sein Verhalten beobachtet hatte, wurde mir klar, dass ich tats√§chlich keinen solchen Algorithmus brauche.  Zum Beispiel ist er selbst nach vielen Iterationen trotz der dichten Abdeckung der Au√üenbereiche kaum in der Lage, die R√§ume zu erkunden, die den unten gezeigten √§hnlich sind.  Dies liegt daran, dass er einfach nicht in der Lage ist, ausreichend zuf√§llige Punkte in den R√§umen auszuw√§hlen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/983/2d4/5a5/9832d45a5c14dc13df9a03cf5216697f.png" width="1280" height="720"></div><br>  Wenn ich vor Beginn der Arbeit dar√ºber nachdenken w√ºrde, w√ºrde ich verstehen, dass der Vorteil von Algorithmen wie Rapidly Exploring Random Tree darin besteht, dass sie hochdimensionale R√§ume effektiv erkunden.  In der Tat ist dies normalerweise der Hauptgrund f√ºr ihre Verwendung.  Aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Zeuge hat</a> keine hochdimensionalen R√§ume.  Wir haben einen zweidimensionalen Raum (ja, verteilt auf eine komplexe Vielfalt, aber dies ist immer noch ein zweidimensionaler Raum). <br><br>  In diesem niedrigdimensionalen Raum sind die Vorteile von Rapidly Exploring Random Tree schwach, und sein Nachteil ist f√ºr meine Aufgabe von entscheidender Bedeutung: Der Algorithmus ist f√ºr die effizienteste Suche nach Pfaden zu verbundenen Punktpaaren im Raum und nicht f√ºr die effiziente Suche nach allen erreichbaren Punkten dieses Raums ausgelegt.  Wenn Sie eine solche Aufgabe haben, wird die schnelle Erkundung eines zuf√§lligen Baums tats√§chlich sehr viel Zeit in Anspruch nehmen, um sie zu l√∂sen. <br><br>  So wurde mir schnell klar, dass ich nach einem Algorithmus suchen musste, der niedrigdimensionale R√§ume effektiv vollst√§ndig abdeckte. <br><br><h2>  3D-Hochwasserf√ºllung </h2><br>  Als ich wirklich √ºber die Auswahl eines Algorithmus nachdachte, wurde mir klar, dass ich tats√§chlich so etwas wie die gute alte zweidimensionale F√ºllung brauchte, mit der Bereiche der Bitmap gef√ºllt werden.  F√ºr jeden Ausgangspunkt musste ich nur den gesamten Raum ausf√ºllen und jeden m√∂glichen Weg gr√ºndlich pr√ºfen.  Leider ist die L√∂sung f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The Witness</a> aus vielen Gr√ºnden viel komplizierter als f√ºr eine zweidimensionale Bitmap. <br><br>  Erstens haben wir kein klares Konzept f√ºr die endliche Verbundenheit eines Punktes.  Der gesamte Raum ist durchgehend.  Dies ist f√ºr ein Pixel, wir k√∂nnen leicht 4 m√∂gliche Orte auflisten, die von einem bestimmten Punkt aus erreicht werden k√∂nnen, und jeden von ihnen nacheinander √ºberpr√ºfen. <br><br>  Zweitens gibt es keine feste Gr√∂√üe der Position im Raum, wie ein Pixel auf einer Bitmap.  Die Oberfl√§chen, auf denen sich der Spieler bewegt, und Hindernisse k√∂nnen sich √ºberall befinden. Sie haben keine maximale oder minimale topologische Gr√∂√üe und sind nicht an ein externes Gitter gebunden. <br><br>  Drittens, obwohl die Bewegung durch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den</a> Raum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The Witness</a> lokal als Bewegung entlang einer Ebene betrachtet werden kann, ist der Raum selbst tats√§chlich eine tief miteinander verbundene und sich ver√§ndernde Mannigfaltigkeit, in der sich die begehbaren Bereiche des Spielers direkt √ºber anderen Bereichen befinden (manchmal k√∂nnen mehrere Ebenen √ºbereinander liegen). .  Dar√ºber hinaus gibt es Verbindungen, die je nach Weltbedingungen variieren (offene / geschlossene T√ºren, Aufz√ºge, die steigen / fallen usw.). <br><br>  Angesichts der beschriebenen Schwierigkeiten ist es sehr einfach, eine eigene Implementierungsoption f√ºr das Bef√ºllen zu finden, die infolgedessen mit sich √ºberschneidenden Bereichen, fehlenden wichtigen Routen und fehlerhaften Informationen √ºber Verbindungen an komplexen Orten der Sorte gef√ºllt wird.  Am Ende wird der Algorithmus zu umst√§ndlich zu verwenden sein, da er erneut ausgef√ºhrt werden muss, um √Ñnderungen im Zustand der Welt zu ber√ºcksichtigen. <br><br>  Ich dachte nicht sofort an eine gute L√∂sung, also beschloss ich, mit einfachen Experimenten zu beginnen.  Mit dem von mir geschriebenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rapidly Exploring Random Tree-</a> Code habe ich die Auswahl der Zielpunkte von zuf√§llig auf sehr kontrolliert ge√§ndert.  Jedes Mal, wenn dem Baum ein neuer Punkt hinzugef√ºgt wurde, gab ich an, dass sich die Punkte in einem Einheitsabstand entlang der Hauptrichtungen von dem Punkt befinden, der als zuk√ºnftiger Zielpunkt betrachtet wird, wie dies bei einer einfachen zweidimensionalen F√ºllung der Fall ist. <br><br>  Wenn Sie jedoch nicht vorsichtig sind, f√ºhrt dies nat√ºrlich zu einem nutzlosen Abtastzyklus.  Der Punkt verzweigt sich in die benachbarten 8 Punkte um ihn herum, aber diese 8 Punkte versuchen dann erneut, zum Startpunkt zur√ºckzukehren, und dies wird f√ºr immer fortgesetzt.  Daher ben√∂tige ich zus√§tzlich zur kontrollierten Auswahl von Zielpunkten eine einfache Einschr√§nkung: Jeder Zielpunkt, der sich nicht innerhalb eines bestimmten Mindestabstands von einem vorhandenen Zielpunkt befindet, wird nicht ber√ºcksichtigt.  Zu meiner √úberraschung sorgen diese beiden einfachen Regeln f√ºr eine ziemlich erfolgreiche F√ºllung: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/591/cf6/446/591cf6446fdcc8281f7ebd9449c48703.png"></div><br>  Nicht schlecht f√ºr ein ziemlich einfaches Experiment.  Aber der Algorithmus leidet unter dem, was ich das "Grenzecho" nenne.  Dieser Effekt ist im folgenden Screenshot zu sehen, der w√§hrend des Studiums der Karte aufgenommen wurde: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/58e/fd0/25f/58efd025f80d2b96274ed849d3e4c568.png"></div><br>  In Gebieten ohne Hindernisse funktioniert der Algorithmus gut, indem er in relativ gleichen Abst√§nden abtastet.  Wenn der Schnittpunkt jedoch die Grenze ber√ºhrt, erzeugen sie Punkte, die ‚Äûau√üerhalb des Gitters‚Äú liegen, dh sie werden nicht nach dem Muster der Stichproben ausgerichtet, nach dem der Algorithmus den benachbarten offenen Bereich ausf√ºllt.  Der Grund daf√ºr, dass die Punkte ‚Äûim Raster‚Äú keine √ºberm√§√üig dichte Tessellation erzeugen, liegt darin, dass jeder neue Punkt, der versucht, zu einem der vorherigen zur√ºckzukehren, den vorherigen Punkt dort findet und sich weigert, ihn erneut zu erz√§hlen.  Wenn Sie jedoch neue Punkte an der Grenze erstellen, sind diese v√∂llig unausgerichtet, sodass nichts sie daran hindern kann, in den bereits erkundeten Raum zur√ºckzukehren.  Dies f√ºhrt zur Erzeugung einer Welle von vorgespannten Abtastwerten, die fortgesetzt wird, bis sie eine zuf√§llige Punktlinie an einer anderen Stelle erreicht, die nahe genug ist, damit der Algorithmus feststellen kann, dass sie mit der sich bewegenden Vorderseite der Punkte √ºbereinstimmt. <br><br>  Obwohl dies kein ernstes Problem zu sein scheint, ist es tats√§chlich kritisch.  Der Sinn solcher Algorithmen besteht darin, die Proben auf Bereiche zu konzentrieren, in denen sie am wahrscheinlichsten produktive Ergebnisse liefern.  Je mehr Zeit wir mit dem Abtasten und erneuten Abtasten gro√üer offener Bereiche verbringen, desto weniger Zeit werden wir damit verbringen, die Gesichter dieses Bereichs zu markieren, die die Informationen sind, die wir ben√∂tigen.  Da es sich um einen kontinuierlichen Raum handelt und nur eine unendliche Anzahl von Proben seine wahre Form beschreiben kann, ist das Verh√§ltnis von signifikanten zu nicht signifikanten Proben buchst√§blich ein Ma√ü f√ºr die Wirksamkeit des Algorithmus bei der Erstellung einer f√ºr einen Spieler passierbaren Oberfl√§che. <br><br>  Es gibt jedoch eine einfache L√∂sung f√ºr dieses spezielle Problem: Sie m√ºssen den Abstand vergr√∂√üern, in dem die beiden Punkte als "ziemlich nahe" betrachtet werden.  Auf diese Weise reduzieren wir die Abtastdichte an Stellen, die <i>f√ºr</i> uns <i>nicht wichtig</i> sind, verlieren aber auch die Abtastdichte an Stellen, die <i>f√ºr</i> uns <i>wichtig</i> sind, z. B. in den Bereichen um die Grenzen, die wir sorgf√§ltig auf das Vorhandensein von "L√∂chern" pr√ºfen m√∂chten. <br><br><h2>  Lokalisierte Richtungsabtastung </h2><br>  Wahrscheinlich, weil ich mit dem Rapidly Exploring Random Tree angefangen habe, hat mein Gehirn alle anderen Ideen au√üer der Idee der N√§he verdr√§ngt.  Alle vorherigen Algorithmen verwendeten die N√§he f√ºr ihre Aufgabe, um beispielsweise einen neuen Punkt zu bestimmen, der als n√§chstes ber√ºcksichtigt werden muss, oder um einen Punkt auszuw√§hlen, von dem aus begonnen werden soll, um zu einem neuen Zielpunkt zu gelangen. <br><br>  Aber nachdem ich einige Zeit √ºber die Aufgabe nachgedacht hatte, wurde mir klar, dass alles logischer wird, wenn wir nicht nur an N√§he, sondern auch an <i>Richtung</i> denken.  Dann wird es offensichtlich, aber wenn Sie an √§hnlichen Aufgaben gearbeitet haben, wissen Sie, dass es leicht ist, in die Falle des engstirnigen Denkens zu geraten und das gro√üe Ganze nicht zu sehen, selbst wenn es sich als einfacher herausstellt.  Genau das ist mir passiert. <br><br>  Als ich meine Sicht der Dinge √§nderte, schien der richtige Ansatz f√ºr die Probenahme offensichtlich.  Jedes Mal, wenn ich meine Erforschung des Weltraums von einem Punkt aus erweitern wollte, beantragte ich die Existenz von nahe gelegenen Punkten in der lokalen Umgebung.  Anstatt den Abstand zu diesen Punkten f√ºr Forschungszwecke zu verwenden, werde ich sie nach ihren Richtungen klassifizieren (vorher habe ich nur acht Hauptrichtungen verwendet, aber ich wollte mit anderen Kerneln experimentieren). <br><br>  In jeder Richtung, in der ich den Punkt nicht ‚Äûsehe‚Äú, gehe ich durch die angegebene Entfernung und f√ºge an jeder Stelle, an der ich angehalten habe, einen Punkt hinzu (unabh√§ngig davon, ob ich auf etwas gesto√üen bin oder nicht).  Wenn ich einen Punkt in einer der Richtungen sehe, bewege ich mich dorthin und √ºberpr√ºfe, ob ich dorthin gelangen kann.  Wenn ich kann, f√ºge ich einfach eine sichtbare Kante hinzu, damit der Benutzer leicht sehen kann, dass die Punkte verbunden sind.  Wenn ich nicht kann, f√ºge ich am Kollisionspunkt einen neuen Punkt hinzu, der die Grenze des Hindernisses definiert. <br><br>      .            ,        ,       : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/699/e45/60e/699e4560ef50242ff48ba0682554248a.png"></div><br>      ,     ,             ,   : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f3/673/618/6f3673618d182bb1810e2577c18ab1ef.png"></div><br>  ,            .      ,       ,        .         ,                     ,             . <br><br>         ,    . ,       ?      .        ,             (    - ). <br><br><h2>    </h2><br>         ,      ,     ,          ,           .  ,    ,      ,             ,        . <br><br>       ,        ,     .     ,  ,              .          ,   ,   ,     ,      . <br><br>                 .     ,    : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6dc/c9f/f6d/6dcc9ff6d78ddb981413ed4b795dcd5b.png"></div><br>        : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/24d/6ba/bda24d6ba69e530c352a7d9a0e3c8a3a.png"></div><br>        ,          ,         . <br><br><h2>   </h2><br>            ,   ,  Walk Monster      ,      .   ,       : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ed/6f6/823/4ed6f6823ba2de2886a0fd83f702aa97.png"></div><br>         ,      .   ,            .   ,    ,   ,       . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/530/c38/b83/530c38b83fd5762238c3210d45e72d86.png"></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The Witness</a>     ,   ,  ,   ,   ,      .   ,   ,   -          .    ,   ,     ,     ,      . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/122/233/c86/122233c86cd7f7cf4f08e69cbb76404a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/012/616/377/012616377b5515b2ee23d71da78bdeeb.png"></div><br>       ,  Walk Monster ,    .   ‚Äî Walk Monster ,   -      (  ‚Äî  ),     .  ,       ( ).       ! <br><br><h2>   </h2><br>    ,    ,  .   ,       ,      !          ,     ,     .           ,      . <br><br> -,      ,     ?           ,     ,  , ,        . <br><br> -,       ,      ¬´¬ª?         ,      ,         ? <br><br> -,        ‚Äî   ?         ,     ,    ,    ,   ,       . <br><br> -,          ,      ? ,        ,      ,             -  ,           .     ?     ? <br><br>   ,    Walk Monster      ,  ,      .                ,  ,             .         .      ,    ,       - ,     Walk Monster      . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423519/">https://habr.com/ru/post/de423519/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423505/index.html">Zuckerberg verkauft Facebook-Aktien f√ºr 13 Milliarden US-Dollar, damit ‚Äûunsere Kinder nie krank werden m√ºssen‚Äú</a></li>
<li><a href="../de423507/index.html">So speichern Sie Speicher auf Browser-Registerkarten, ohne deren Inhalt zu verlieren. Die Erfahrung des Yandex.Browser-Teams</a></li>
<li><a href="../de423511/index.html">Abfangen der Installation von Firefox und Chrome unter Windows 10</a></li>
<li><a href="../de423513/index.html">Wir sparen auf einem RAID-Controller oder wie man Varia mit Iops f√ºttert</a></li>
<li><a href="../de423515/index.html">Ist DRY gut oder kann es O von SOLID brechen</a></li>
<li><a href="../de423521/index.html">Sieben Faustregeln zum Experimentieren mit Websites</a></li>
<li><a href="../de423523/index.html">Kombinierter Sensor mit Vorlieben und Dichtern</a></li>
<li><a href="../de423527/index.html">Kinder-Apps sammeln massiv personenbezogene Daten und geben diese an Dritte weiter</a></li>
<li><a href="../de423529/index.html">Was braucht das ganze Team, um zu arbeiten? Wie kann man alle in das Projektmanagementsystem ziehen?</a></li>
<li><a href="../de423531/index.html">Reddit Mobile Architecture Evolution</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>