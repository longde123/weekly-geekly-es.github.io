<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèì üß¶ üßõüèª Implementa√ß√£o de PPPOS no stm32f4-discovery üë®üèª‚Äçüéì üë®üèΩ‚Äçüåæ ‚õ∏Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Uma vez, antes de mim, havia uma tarefa para fornecer acesso √† Internet no STM32, tendo para isso apenas uma porta COM. Para resolver esse problema, e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementa√ß√£o de PPPOS no stm32f4-discovery</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419037/">  Uma vez, antes de mim, havia uma tarefa para fornecer acesso √† Internet no STM32, tendo para isso apenas uma porta COM.  Para resolver esse problema, eu precisava do PPP, ou, para ser mais preciso, do PPPoS (Protocolo Ponto a Ponto sobre Serial - uma das maneiras de implementar o PPP, ele √© usado na conex√£o via porta COM). <br><br>  No processo de resolu√ß√£o da tarefa que me foi apresentada, encontrei algumas dificuldades, uma das quais, na minha opini√£o, era uma cobertura insuficiente de quest√µes relacionadas ao PPPoS na Internet.  Com este post, tentarei preencher a lacuna designada, tanto quanto meu conhecimento modesto permitir. <br><br>  Este artigo descreve como criar um projeto para o System Workbench for STM32 do zero.  Mostra um exemplo de trabalho com o UART.  Existem exemplos de c√≥digo para implementar o PPP.  E, claro, um exemplo de envio de uma mensagem para um computador vizinho. <br><a name="habracut"></a><br><h3>  1. Introdu√ß√£o </h3><br>  O PPP (Protocolo ponto a ponto) √© um protocolo de link de dados de dois pontos do modelo de rede OSI.  Geralmente √© usado para estabelecer comunica√ß√£o direta entre dois n√≥s da rede e pode fornecer autentica√ß√£o de conex√£o, criptografia e compacta√ß√£o de dados.  Usado em muitos tipos de redes f√≠sicas: cabo de modem nulo, linha telef√¥nica, celular, etc. <br><br>  Frequentemente, existem subesp√©cies do protocolo PPP, como o protocolo ponto a ponto pela Ethernet (PPPoE), usado para conectar via Ethernet e, √†s vezes, por DSL;  e Protocolo ponto a ponto sobre ATM (PPPoA), usado para conex√£o via ATM Adaptation Layer 5 (AAL5), que √© a principal alternativa de PPPoE para DSL. <br><br>  O PPP √© uma fam√≠lia de protocolos: Protocolo de Controle de Link (LCP), Protocolo de Controle de Rede (NCP), Protocolos de Autentica√ß√£o (PAP, CHAP), PPP Multicanal (MLPPP). <br><br>  <i>Da Wikipedia</i> . <br><br><h3>  Prepara√ß√£o </h3><br>  Para resolver o problema, precisamos: <br><br><h4>  Ferro: </h4><br><ol><li>  Placa de depura√ß√£o stm32f4_discovery: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u1/0k/6-/u10k6-una1bkmaphl4wlazibaca.jpeg"></div></li><li>  Adaptador USB para miniUSB para conectar a placa a um computador. </li><li>  Dois adaptadores USBtoUART FT232: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uh/uk/mo/uhukmolq4_t-pckn8h2rjofspnu.png"></div></li><li>  Dois cabos de extens√£o USB tamb√©m s√£o √∫teis, n√£o necessariamente, mas apenas convenientes. </li></ol><br><h4>  Suave: </h4><br><ol><li>  M√°quina virtual VirtualBox.  Voc√™ pode baix√°-lo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Tamb√©m baixamos e instalamos o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Extension Pack</a> for VirtualBox. </li><li>  Dois discos de instala√ß√£o com os sistemas operacionais Windows e Linux.  N√≥s levamos o Windows <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> , o Linux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Depois de instalar o sistema operacional, voc√™ precisar√° instalar complementos para o sistema operacional convidado.  Para a tarefa, temos sistemas 32x suficientes, voc√™ n√£o pode se enganar com a inclus√£o da virtualiza√ß√£o. </li><li>  Para o Windows, precisamos de um programa que possa aceitar solicita√ß√µes e responder a elas via TCP / IP e um programa de terminal para trabalhar com uma porta COM.  Fa√ßa o download do PacketSender <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> (clique em ‚ÄúN√£o, obrigado, deixe-me baixar.‚Äù), O terminal est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Al√©m disso, precisamos do STM32CubeMX para a configura√ß√£o inicial do projeto.  Download em st.com (ap√≥s o registro, o link ser√° enviado por e-mail). </li><li>  Colocamos o System Workbench for STM32 no sistema operacional principal.  Baixe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> (√© necess√°rio registro). </li></ol><br><h3>  Etapa 1. Criando um Projeto </h3><br>  Primeiro, abra o STM32CubeMX e crie um novo projeto para a nossa placa stm32f4-discovery.  Ligue RCC, Ethernet (ETH), SYS, USART2, USART3 e, em seguida, ligue FREERTOS e LWIP. <br><br><img src="https://habrastorage.org/webt/vr/jk/ve/vrjkveavft5ry-oasa7h2e07rwe.png"><br><img src="https://habrastorage.org/webt/9c/v2/rv/9cv2rv-_8yf5w67mr7bw7ynp1vk.png"><br><br>  Para diagn√≥sticos, precisamos de LEDs na placa.  Para isso, configure as pernas do PD12-PD15 como GPIO_Output. <br><br><img src="https://habrastorage.org/webt/-s/bb/lk/-sbblkybmbdz1wrftiow38tq4eg.png"><br><br>  Na guia Configura√ß√£o do rel√≥gio, defina a frequ√™ncia, como na figura abaixo. <br><br><img src="https://habrastorage.org/webt/sd/cc/qy/sdccqyreetba7g_m8yq_gypc-ge.png"><br><br>  Em seguida, na guia Configura√ß√£o, configure as portas USART.  Vamos trabalhar com eles no modo DMA.  Temos duas portas USART, uma que usaremos para transmitir e receber dados via PPP, a segunda para registro.  Para faz√™-los funcionar, precisamos configurar o DMA no RX e TX para ambas as portas.  Para todas as pernas de ajuste do DMA, defina M√©dio como prioridade.  Para a perna USART2 RX, defina o modo para "Circular".  O restante das configura√ß√µes s√£o deixadas por padr√£o. <br><br><img src="https://habrastorage.org/webt/96/s8/9u/96s89uloxfrdtxd0scqvcyb-zng.png"><br><br>  Voc√™ tamb√©m precisar√° ativar a interrup√ß√£o global para ambas as portas na guia ‚ÄúNVIC Settings‚Äù. <br><br>  Isso conclui a configura√ß√£o inicial do projeto no STM32CubeMX.  Salvamos o arquivo do projeto e geramos o c√≥digo para o System Workbench for STM32. <br><br><img src="https://habrastorage.org/webt/ss/_d/8l/ss_d8lzdxneoj5mjasvmyhhhxiu.png"><br><br><h4>  Implementa√ß√£o </h4><br>  Agora vamos verificar se o c√≥digo baixado √© compilado e funciona.  Para fazer isso, no arquivo main.c na fun√ß√£o "StartDefaultTask", substitu√≠mos o corpo do loop infinito para (; ;;) pelo c√≥digo de ativa√ß√£o e desativa√ß√£o do LED. <br><br>  Deve ser assim: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* StartDefaultTask function */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartDefaultTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * argument)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* init code for LWIP */</span></span> MX_LWIP_Init(); <span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 5 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Infinite loop */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_SET); osDelay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET); osDelay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/* USER CODE END 5 */</span></span> }</code> </pre> <br>  N√≥s compilamos o firmware e olhamos.  Todos os quatro LEDs devem piscar no quadro. <br><br><h3>  Etapa 2. Trabalhar com USART </h3><br>  Nossa pr√≥xima tarefa √© verificar a opera√ß√£o correta do nosso USART. <br><br>  A primeira coisa que precisamos fazer √© conectar nosso FT232 √† descoberta.  Para fazer isso, observe quais pernas as interfaces USART s√£o divorciadas.  Eu tenho PD6 e PD5 para USART2_RX e USART2_TX, respectivamente. <br><br><img src="https://habrastorage.org/webt/qj/yh/yo/qjyhyoohdofxtqedphuhzq7qcac.png"><br><br>  Assim como PD9 e PD8 para USART3_RX e USART3_TX, respectivamente. <br><br><img src="https://habrastorage.org/webt/37/bf/om/37bfomzqqcapediljrf14flpuiu.png"><br><br>  Al√©m disso, precisamos de um p√© GND. <br><br>  N√≥s encontramos esses pinos na placa e os conectamos aos pinos do FT232, enquanto o pino GND na placa pode ser qualquer, o pino RX na placa deve estar conectado ao pino TX no FT232 e o pino TX na placa deve estar conectado ao pino RX no FT232.  As demais conclus√µes n√£o s√£o usadas. <br><br>  Resta conectar o FT232 √†s portas USB do computador, bem como conectar a pr√≥pria placa de descoberta atrav√©s do conector miniUSB ao computador (n√£o confunda com microUSB). <br><br>  Ap√≥s conectar o FT232, o sistema operacional principal instalar√° os drivers para eles, ap√≥s o que esses dispositivos precisar√£o ser encaminhados ao convidado do Windows na m√°quina virtual. <br><br>  Agora adicionamos o c√≥digo do programa necess√°rio para a opera√ß√£o do nosso USART.  Para fazer isso, adicionaremos quatro arquivos: usart.h, usart.c, logger.h, logger.c. <br><br>  Conte√∫do do arquivo: <br><br>  <b>arquivo usart.h</b> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _USART_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _USART_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f4xx_hal.h"</span></span></span><span class="hljs-meta"> void usart_Open(void); bool usart_Send(char* bArray, int size_bArray); uint16_t usart_Recv(char* bArray, uint16_t maxLength); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* _USART_ */</span></span></span></span></code> </pre><br>  <b>arquivo usart.c</b> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"usart.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"logger.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cmsis_os.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Q_USART2_SIZE 200 xQueueHandle g_qUsart; osThreadId g_usart_rxTaskHandle; extern UART_HandleTypeDef huart2; void usart_rxTask(void); uint8_t bGet[Q_USART2_SIZE] = {0}; uint16_t g_tail = 0; void usart_Open(void) { g_qUsart = xQueueCreate( Q_USART2_SIZE, sizeof( unsigned char ) ); osThreadDef(usart_rxTask_NAME, usart_rxTask, osPriorityNormal, 0, Q_USART2_SIZE/4+128); g_usart_rxTaskHandle = osThreadCreate(osThread(usart_rxTask_NAME), NULL); HAL_UART_Receive_DMA(&amp;huart2, bGet, Q_USART2_SIZE); } void usart_rxTask(void) { for(;;) { uint16_t length = Q_USART2_SIZE - huart2.hdmarx-&gt;Instance-&gt;NDTR; while(length - g_tail) { uint8_t tmp = bGet[g_tail]; xQueueSendToBack( g_qUsart, &amp;tmp, 100 ); g_tail++; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (g_tail == Q_USART2_SIZE) g_tail = 0; } } } bool usart_Send(char* bArray, int size_bArray) { HAL_StatusTypeDef status; status = HAL_UART_Transmit_DMA(&amp;huart2, bArray, size_bArray); while (HAL_UART_GetState(&amp;huart2) != HAL_UART_STATE_READY) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (HAL_UART_GetState(&amp;huart2) == HAL_UART_STATE_BUSY_RX) break; osDelay(1); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (status == HAL_OK) return true; return false; } uint16_t usart_Recv(char* bArray, uint16_t maxLength) { uint8_t tmp = 0; uint16_t length = 0; while(uxQueueMessagesWaiting(g_qUsart)) { xQueueReceive( g_qUsart, &amp;tmp, 100 ); bArray[length] = tmp; length++; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (length &gt;= maxLength) break; } return length; }</span></span></code> </pre><br>  <b>arquivo logger.h</b> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _LOGGER_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _LOGGER_ void logger(const char *format, ...); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* _LOGGER_ */</span></span></span></span></code> </pre><br>  <b>arquivo logger.c</b> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"logger.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f4xx_hal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdarg.h&gt; extern UART_HandleTypeDef huart3; #define MAX_STRING_SIZE 1024 HAL_StatusTypeDef logger_Send(char* bArray, uint32_t size_bArray) { HAL_StatusTypeDef status; for(int i=0;i&lt;5;i++) { status = HAL_UART_Transmit_DMA(&amp;huart3, bArray, size_bArray); if (status == HAL_OK) break; osDelay(2); } while (HAL_UART_GetState(&amp;huart3) != HAL_UART_STATE_READY) { osDelay(1); } return status; } void logger(const char *format, ...) { char buffer[MAX_STRING_SIZE]; va_list args; va_start (args, format); vsprintf(buffer, format, args); va_end(args); buffer[MAX_STRING_SIZE-1]=0; logger_Send(buffer, strlen(buffer)); }</span></span></span></span></code> </pre><br>  Precisamos de arte para transmitir e receber dados sobre arte2.  Ser√° a nossa principal interface de comunica√ß√£o com um servidor PPP. <br><br>  Precisamos do Logger para implementar o log enviando mensagens para o terminal.  A fun√ß√£o void usart_Open (void) forma uma fila e inicia a tarefa de atender a essa fila.  Esta fun√ß√£o deve ser conclu√≠da antes de usar o USART.  Ent√£o tudo √© simples, a fun√ß√£o bool usart_Send (char * bArray, int size_bArray) envia dados para a porta e <br>  uint16_t usart_Recv (char * bArray, uint16_t maxLength) os obt√©m da fila na qual a fun√ß√£o void usart_rxTask (void) os adicionou gentilmente. <br><br>  Para o criador de logs, ainda √© mais simples; n√£o h√° necessidade de obter dados; portanto, nem a tarefa de manuten√ß√£o da fila nem a fila s√£o necess√°rias. <br><br>  No in√≠cio do arquivo <b>main.h</b> , <b>voc√™</b> precisa adicionar v√°rias <b>defini√ß√µes que</b> descrevem o tipo de bool, que n√£o est√° dispon√≠vel em C. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN Includes */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> true 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> false 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END Includes */</span></span></span></span></code> </pre><br>  Agora √© hora de verificar a funcionalidade do c√≥digo resultante.  Para fazer isso, no arquivo <b>main.c</b> , altere o c√≥digo da tarefa j√° conhecida "StartDefaultTask" <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 4 */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"usart.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"logger.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_MESSAGE_LENGTH 100 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 4 */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* StartDefaultTask function */</span></span></span><span class="hljs-meta"> void StartDefaultTask(void const * argument) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* init code for LWIP */</span></span></span><span class="hljs-meta"> MX_LWIP_Init(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN 5 */</span></span></span><span class="hljs-meta"> usart_Open(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Infinite loop */</span></span></span><span class="hljs-meta"> uint8_t send[] = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Send message\r\n"</span></span></span><span class="hljs-meta">; uint8_t recv[MAX_MESSAGE_LENGTH] = {0}; uint16_t recvLength = 0; for(;;) { HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_SET); osDelay(1000); HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET); osDelay(1000); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (usart_Send(send, sizeof(send)-1)) logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SEND - %s"</span></span></span><span class="hljs-meta">, send); recvLength = usart_Recv(recv, MAX_MESSAGE_LENGTH-1); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (recvLength) { recv[recvLength] = 0; logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"RECV - %s\r\n"</span></span></span><span class="hljs-meta">, recv); } } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 5 */</span></span></span><span class="hljs-meta"> }</span></span></code> </pre><br>  Al√©m disso, precisamos dar mais mem√≥ria √† pilha de nossa tarefa.  Para fazer isso, na chamada para a fun√ß√£o osThreadDef (), o arquivo main.c, √© necess√°rio corrigir 128 por 128 * 10 para obter isso: <br><br><pre> <code class="hljs lisp">osThreadDef(<span class="hljs-name"><span class="hljs-name">defaultTask</span></span>, StartDefaultTask, osPriorityNormal, <span class="hljs-number"><span class="hljs-number">0</span></span>, &lt;b&gt;128*10&lt;/b&gt;)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  N√≥s compilamos e flash.  Os LEDs piscam da mesma maneira que na tarefa anterior. <br><br>  Para ver o resultado do nosso trabalho, voc√™ precisa executar o programa Terminal em nossa m√°quina virtual.  Uma inst√¢ncia do programa para a porta de log, a segunda para a principal.  Procure no gerenciador de dispositivos quais n√∫meros de porta foram atribu√≠dos ao seu FT232.  Se os n√∫meros tiverem sido atribu√≠dos com mais de 10, reatribua. <br><br>  Quando voc√™ inicia a segunda inst√¢ncia do programa, pode ocorrer um erro, feche a janela com o erro e continue trabalhando com o programa. <br><br>  Para ambas as portas, estabelecemos uma conex√£o em 115200 baud, bits de dados - 8, paridade - nenhum, bits de parada - 1, handshake - nenhum. <br><br>  Se voc√™ fez tudo corretamente, na janela do terminal para usart2 a mensagem "Enviar mensagem" ser√° transmitida.  A mesma mensagem ser√° duplicada na janela do terminal para o logger apenas com o prefixo "SEND -" <br><br>  Se na janela do terminal para usart2 voc√™ digitar algum texto no campo "Enviar" e clicar no bot√£o correspondente √† direita desse campo, na janela do logger voc√™ ver√° a mesma mensagem com o prefixo "RECV -" <br><br>  Na figura abaixo: √† esquerda est√° o logger, √† direita est√° usart2. <br><br><img src="https://habrastorage.org/webt/k5/v6/hc/k5v6hcxebj6hfdgbitfwyzs1ffw.png"><br><br><h3>  Etapa 3. Introdu√ß√£o ao PPP </h3><br>  Como parte dessa tarefa, criaremos uma conex√£o PPP.  Primeiro, habilite o uso do PPP, altere o valor do PPP_SUPPORT definido no arquivo ppp_opts.h para 1. Em seguida, redefinimos as defini√ß√µes necess√°rias no arquivo lwipopts.h, <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MEMP_NUM_SYS_TIMEOUT 8 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CHECKSUM_GEN_IP 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CHECKSUM_GEN_TCP 1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 1 */</span></span></span></span></code> </pre><br>  Ao mesmo tempo, as defini√ß√µes antigas precisam ser comentadas. <br><br>  Agora, modificamos o arquivo lwip.c, insira o seguinte c√≥digo no bloco "/ * USER CODE BEGIN 0 * /": <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 0 */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"usart.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pppos.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sio.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"dns.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp.h"</span></span></span><span class="hljs-meta"> static ppp_pcb *ppp; struct netif pppos_netif; void PppGetTask(void const * argument) { uint8_t recv[2048]; uint16_t length = 0; for(;;) { length=usart_Recv(recv, 2048); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (length) { pppos_input(ppp, recv, length); logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"read - PppGetTask() len = %d\n"</span></span></span><span class="hljs-meta">, length); } osDelay(10); } } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ip4_addr.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"dns.h"</span></span></span><span class="hljs-meta"> static void ppp_link_status_cb(ppp_pcb *pcb, int err_code, void *ctx) { struct netif *pppif = ppp_netif(pcb); LWIP_UNUSED_ARG(ctx); switch(err_code) { case PPPERR_NONE: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* No error. */</span></span></span><span class="hljs-meta"> { logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_NONE\n\r"</span></span></span><span class="hljs-meta">); logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" our_ip4addr = %s\n\r"</span></span></span><span class="hljs-meta">, ip4addr_ntoa(netif_ip4_addr(pppif))); logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" his_ipaddr = %s\n\r"</span></span></span><span class="hljs-meta">, ip4addr_ntoa(netif_ip4_gw(pppif))); logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" netmask = %s\n\r"</span></span></span><span class="hljs-meta">, ip4addr_ntoa(netif_ip4_netmask(pppif))); } break; case PPPERR_PARAM: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Invalid parameter. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_PARAM\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_OPEN: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Unable to open PPP session. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_OPEN\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_DEVICE: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Invalid I/O device for PPP. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_DEVICE\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_ALLOC: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Unable to allocate resources. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_ALLOC\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_USER: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* User interrupt. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_USER\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_CONNECT: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Connection lost. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_CONNECT\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_AUTHFAIL: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Failed authentication challenge. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_AUTHFAIL\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_PROTOCOL: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Failed to meet protocol. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_PROTOCOL\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_PEERDEAD: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Connection timeout. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_PEERDEAD\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_IDLETIMEOUT: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Idle Timeout. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_IDLETIMEOUT\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_CONNECTTIME: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* PPPERR_CONNECTTIME. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_CONNECTTIME\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_LOOPBACK: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Connection timeout. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_LOOPBACK\n"</span></span></span><span class="hljs-meta">); break; default: logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: unknown errCode %d\n"</span></span></span><span class="hljs-meta">, err_code); break; } } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Callback used by ppp connection static u32_t ppp_output_cb(ppp_pcb *pcb, u8_t *data, u32_t len, void *ctx) { LWIP_UNUSED_ARG(pcb); LWIP_UNUSED_ARG(ctx); if (len &gt; 0) { if (!usart_Send(data, len)) return 0x05; } logger("write - ppp_output_cb() len = %d\n", len); return len; } void pppConnect(void) { ppp = pppos_create(&amp;pppos_netif, ppp_output_cb, ppp_link_status_cb, NULL); ppp_set_default(ppp); osThreadId PppGetTaskHandle; osThreadDef(PPP_GET_TASK_NAME, PppGetTask, osPriorityNormal, 0, 128*10); PppGetTaskHandle = osThreadCreate(osThread(PPP_GET_TASK_NAME), NULL); err_t err = ppp_connect(ppp,0); if (err == ERR_ALREADY) { logger("Connected successfully"); } for(int i=0;i&lt;40;i++) { osDelay(500); if (ppp-&gt;phase &gt;= PPP_PHASE_RUNNING) break; } } /* USER CODE END 0 */</span></span></span></span></code> </pre><br>  Ent√£o, na fun√ß√£o MX_LWIP_Init (), no bloco ‚Äú/ * USER CODE BEGIN 3 * /‚Äù, adicionamos uma chamada √† fun√ß√£o pppConnect (). <br><br>  Al√©m disso, voc√™ precisa aumentar o tamanho da pilha, para isso, no arquivo FreeRTOSConfig.h, voc√™ deve comentar a defini√ß√£o configTOTAL_HEAP_SIZE e, no final do arquivo, no bloco / * USER CODE BEGIN Define * / bloco, declare-o com um novo valor. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN Defines */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Section where parameter definitions can be added (for instance, to override default ones in FreeRTOS.h) */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> configTOTAL_HEAP_SIZE ((size_t)1024*30) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END Defines */</span></span></span></span></code> </pre><br>  Al√©m disso, no arquivo usart.c, altere o valor da defini√ß√£o Q_USART2_SIZE para 2048. <br><br>  A configura√ß√£o da conex√£o come√ßa com a fun√ß√£o MX_LWIP_Init (); foi criada automaticamente; apenas adicionamos uma chamada √† fun√ß√£o pppConnect ().  Nesta fun√ß√£o, as tarefas que atendem √† conex√£o PPPOS s√£o iniciadas.  As fun√ß√µes pppos_create () precisam receber os endere√ßos das fun√ß√µes que servir√£o para o envio de mensagens e a sa√≠da de informa√ß√µes sobre a altera√ß√£o do status da conex√£o.  Para n√≥s, essas s√£o as fun√ß√µes ppp_output_cb () e ppp_link_status_cb (), respectivamente.  Al√©m disso, a fun√ß√£o pppConnect () iniciar√° a tarefa de atender √†s mensagens recebidas.  No final de sua opera√ß√£o, a fun√ß√£o pppConnect () aguardar√° o estabelecimento de uma conex√£o com o servidor e concluir√° sua opera√ß√£o. <br><br>  O trabalho com a rede ser√° realizado em um n√≠vel superior, assim que o LWIP decidir que √© necess√°rio enviar uma mensagem para a rede, a fun√ß√£o ppp_output_cb () ser√° chamada automaticamente.  A resposta da rede ser√° recebida pela fun√ß√£o PppGetTask (), como parte da tarefa de atender as mensagens recebidas, e transferida para as entranhas do LWIP.  Se o status da conex√£o mudar, a fun√ß√£o ppp_link_status_cb () ser√° chamada automaticamente. <br><br>  Por fim, modificaremos a tarefa StartDefaultTask.  Agora deve ficar assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartDefaultTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * argument)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* init code for LWIP */</span></span> <span class="hljs-comment"><span class="hljs-comment">// MX_LWIP_Init(); /* USER CODE BEGIN 5 */ usart_Open(); MX_LWIP_Init(); /* Infinite loop */ for(;;) { HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_SET); osDelay(1000); HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET); osDelay(1000); } /* USER CODE END 5 */ }</span></span></code> </pre><br>  Feito, voc√™ pode compilar e fazer o flash. <br><br>  Neste ponto, voc√™ precisa iniciar o servidor PPP.  Para fazer isso, voc√™ deve primeiro implantar uma m√°quina virtual com Linux.  Eu usei o Ubuntu 16.04 x32.  Depois de instalar o sistema operacional, voc√™ precisa configurar o uso da porta COM. <br><br>  Nesta parte, n√£o precisamos de uma m√°quina virtual com Windows, podemos desativ√°-la com seguran√ßa.  N√≥s conectamos o FT232 no Linux. <br><br>  No Linux, antes de come√ßar a trabalhar com uma porta COM, √© necess√°rio permitir que o usu√°rio a use.  Para fazer isso, execute o seguinte comando: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sudo</span></span> addgroup USERNAME dialout</code> </pre> <br>  onde USERNAME √© o nome do usu√°rio atual. <br><br>  Para ver as portas dispon√≠veis no sistema COM, voc√™ precisa executar o comando: <br><br><pre> <code class="hljs perl">dmesg | <span class="hljs-keyword"><span class="hljs-keyword">grep</span></span> tty</code> </pre> <br><img src="https://habrastorage.org/webt/zc/h4/mp/zch4mpfwyybln76dl1jnhpxjt0s.png"><br><br>  Vemos que existem duas portas ttyUSB no sistema.  N√£o podemos dizer imediatamente qual √© o logger e qual √© o usart2.  Voc√™ s√≥ precisa verific√°-los por vez. <br><br>  Primeiro, execute os comandos para ler de uma porta: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">stty</span></span> -F /dev/ttyUSB0 <span class="hljs-number"><span class="hljs-number">115200</span></span> cat /dev/ttyUSB0</code> </pre> <br>  depois de outro: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">stty</span></span> -F /dev/ttyUSB1 <span class="hljs-number"><span class="hljs-number">115200</span></span> cat /dev/ttyUSB1</code> </pre> <br>  Onde vemos essa imagem, isso √© logger. <br><br><img src="https://habrastorage.org/webt/u0/cu/zc/u0cuzcnbhzppwdhpibm2o6zelpk.png"><br><br>  Voc√™ pode sair desta janela, isso n√£o vai nos incomodar. <br><br>  Em seguida, voc√™ precisa permitir que os pacotes enviados de nossa placa deixem os limites de suas sub-redes.  Para fazer isso, configure o iptables.  Realizamos as seguintes a√ß√µes: <br><br>  1. Abra uma nova janela do console <br>  2. Voc√™ precisa descobrir o seu ip e o nome da interface de rede (execute o comando <b>ifconfig</b> ) <br><br><img src="https://habrastorage.org/webt/jy/d4/9s/jyd49satpc3erdlzeddi44gwcy4.png"><br><br>  3. Execute os comandos de configura√ß√£o nat <br><br><pre> <code class="hljs powershell">sudo echo <span class="hljs-number"><span class="hljs-number">1</span></span> | sudo tee <span class="hljs-literal"><span class="hljs-literal">-a</span></span> /proc/sys/net/ipv4/ip_forward &gt; /dev/null sudo echo <span class="hljs-number"><span class="hljs-number">1</span></span> | sudo tee <span class="hljs-literal"><span class="hljs-literal">-a</span></span> /proc/sys/net/ipv4/ip_dynaddr &gt; /dev/null sudo iptables <span class="hljs-operator"><span class="hljs-operator">-F</span></span> FORWARD sudo iptables <span class="hljs-operator"><span class="hljs-operator">-F</span></span> <span class="hljs-literal"><span class="hljs-literal">-t</span></span> nat sudo iptables <span class="hljs-literal"><span class="hljs-literal">-t</span></span> nat <span class="hljs-literal"><span class="hljs-literal">-A</span></span> POSTROUTING <span class="hljs-literal"><span class="hljs-literal">-o</span></span> enp0s3 <span class="hljs-literal"><span class="hljs-literal">-j</span></span> SNAT -<span class="hljs-literal"><span class="hljs-literal">-to</span></span><span class="hljs-literal"><span class="hljs-literal">-source</span></span> <span class="hljs-number"><span class="hljs-number">192.168</span></span>.<span class="hljs-number"><span class="hljs-number">10.196</span></span> sudo iptables <span class="hljs-literal"><span class="hljs-literal">-t</span></span> nat <span class="hljs-literal"><span class="hljs-literal">-L</span></span></code> </pre> <br>  em que enp0s3 √© o nome da interface de rede <br>  192.168.10.196 - seu endere√ßo IP <br>  / proc / sys / net / ipv4 / - caminho para o arquivo correspondente. <br><br>  Esses comandos podem ser reescritos em um arquivo em lotes e executados sempre antes de iniciar o servidor PPP.  Voc√™ pode adicion√°-lo √† execu√ß√£o autom√°tica, mas n√£o o fiz. <br><br>  Agora estamos prontos para iniciar o servidor, resta apenas criar um arquivo de configura√ß√µes.  Eu chamei de ‚Äú <b>pppd.conf</b> ‚Äù, sugiro usar as seguintes configura√ß√µes: <br><br><pre> <code class="hljs pgsql">nodetach noauth passive <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-keyword"><span class="hljs-keyword">debug</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> <span class="hljs-number"><span class="hljs-number">192.168</span></span><span class="hljs-number"><span class="hljs-number">.250</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>:<span class="hljs-number"><span class="hljs-number">192.168</span></span><span class="hljs-number"><span class="hljs-number">.250</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span> /dev/ttyUSB1 <span class="hljs-number"><span class="hljs-number">115200</span></span> lcp-echo-<span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> lcp-echo-failure <span class="hljs-number"><span class="hljs-number">1</span></span> cdtrcts</code> </pre> <br>  Reescrevemos as configura√ß√µes em um arquivo e voc√™ pode iniciar o servidor.  Isso √© feito com o <b>comando sudo pppd file ./pppd.conf</b> <br><br>  O servidor PPPD deve ser iniciado antes do in√≠cio da descoberta; portanto, ap√≥s o in√≠cio do PPPD, voc√™ precisa clicar no bot√£o "Redefinir" localizado na placa. <br><br>  Se voc√™ fez tudo corretamente, ver√° a seguinte imagem: <br><br><img src="https://habrastorage.org/webt/kv/-p/lj/kv-pljob3duk3bigzj3iazcsasa.png"><br><br>  Executando pppd √† esquerda, registrador √† direita. <br><br><h3>  Etapa 4. Enviamos uma sacola </h3><br>  Nesta fase, precisamos das duas m√°quinas virtuais.  Linux para pppd e Windows para receber o pacote.  Para simplificar a tarefa, √© necess√°rio que ambas as m√°quinas estejam na mesma sub-rede, a solu√ß√£o ideal seria especificar uma conex√£o de ponte de rede para ambas as m√°quinas nas configura√ß√µes de rede do VirtualBox e desativar o firewall no Windows. <br><br>  Iniciamos as m√°quinas virtuais e configuramos a conex√£o ppp da placa de descoberta com o pppd.  No Windows, descobrimos o endere√ßo IP da m√°quina (comando ipconfig), obtive-o 192.168.10.97. <br><br>  Inicie o Packet Sender e configure-o da seguinte maneira: <br><br><img src="https://habrastorage.org/webt/k8/zt/uv/k8ztuv4eccjueyvlk8gigjbmkj0.png"><br><br>  Agora, novamente, modifique a tarefa StartDefaultTask no arquivo <b>main.c.</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 4 */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"logger.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sockets.h"</span></span></span><span class="hljs-meta"> typedef uint32_t SOCKET; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 4 */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* StartDefaultTask function */</span></span></span><span class="hljs-meta"> void StartDefaultTask(void const * argument) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* init code for LWIP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// MX_LWIP_Init(); /* USER CODE BEGIN 5 */ usart_Open(); MX_LWIP_Init(); /* Infinite loop */ uint8_t sendStr[]="Test message TCP/IP."; uint8_t resvStr[100]={0}; int resvLength = 0; struct sockaddr_in sockAddr; sockAddr.sin_family = AF_INET; sockAddr.sin_port = htons( 6565 ); uint32_t addr = inet_addr("192.168.10.97"); sockAddr.sin_addr.s_addr = addr; SOCKET socket = NULL; int nError = 0; /* Infinite loop */ for(;;) { HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_SET); osDelay(1000); HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET); osDelay(1000); socket = socket( AF_INET, SOCK_STREAM, 0 ); nError = connect( socket, (struct sockaddr*)&amp;sockAddr, sizeof(sockAddr) ); if ( nError == 0 ) { nError = send( socket, sendStr, sizeof(sendStr)-1, 0 ); if ( nError &lt; 0 ) logger("SEND ERROR %d\n", nError); else { logger("SEND - %s\n", sendStr); resvLength = 0; while(resvLength &lt; 1) resvLength = lwip_recv( socket, resvStr, sizeof(resvStr), MSG_WAITALL); resvStr[resvLength]=0; logger("GET - %s\n", resvStr); } lwip_close(socket); } else logger("CONNECT ERROR %d\n", nError); } /* USER CODE END 5 */ }</span></span></span></span></code> </pre><br>  Como o valor da vari√°vel addr, usamos o endere√ßo da m√°quina Windows, n√∫mero da porta 6565. <br>  Mensagem enviada ‚ÄúMensagem de teste TCP / IP.‚Äù, Resposta ‚ÄúA mensagem foi recebida.‚Äù <br><br>  Aqui voc√™ pode ver que as fun√ß√µes PPP n√£o s√£o usadas diretamente para enviar e receber mensagens.  Todo o trabalho ocorre em um n√≠vel superior e nossas fun√ß√µes s√£o chamadas automaticamente. <br><br>  N√≥s compilamos e flash. <br><br>  O resultado da conex√£o com o pppd √© vis√≠vel em uma m√°quina Linux: <br><br><img src="https://habrastorage.org/webt/il/og/h6/ilogh6wuak7zym8unedcnddcjr4.png"><br><br>  Solicita√ß√µes recebidas e respostas enviadas podem ser vistas no programa Packet Sender em uma m√°quina Windows: <br><br><img src="https://habrastorage.org/webt/30/yh/4m/30yh4m_l52nvlkdixrv9zmivehc.png"><br><br>  Bem, isso √© tudo, o pacote enviado por n√≥s da placa de descoberta foi para a porta COM, chegou ao servidor pppd, foi enviado √† porta 6565 do Windows da m√°quina, foi recebido com sucesso, em resposta a ele foi enviado outro pacote que passou por este dire√ß√£o oposta e foi adotada com sucesso no quadro.  Voc√™ tamb√©m pode enviar mensagens para qualquer m√°quina na Internet. <br><br>  ‚Üí O c√≥digo completo do projeto pode ser baixado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt419037/">https://habr.com/ru/post/pt419037/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt419025/index.html">@Pythonetc compilation, julho de 2018</a></li>
<li><a href="../pt419027/index.html">Seguran√ßa da informa√ß√£o de pagamentos banc√°rios sem dinheiro. Parte 6 - An√°lise do Crime Banc√°rio</a></li>
<li><a href="../pt419029/index.html">Fortnite se tornou um fen√¥meno social. Os pais est√£o cada vez mais contratando treinadores para seus filhos e brincando com eles</a></li>
<li><a href="../pt419033/index.html">Uma pequena observa√ß√£o sobre o t√≥pico de execu√ß√£o do vue.js no cluster kubernetes</a></li>
<li><a href="../pt419035/index.html">Livro ‚ÄúHead First Agile. Gerenciamento flex√≠vel de projetos ‚Äù</a></li>
<li><a href="../pt419041/index.html">Os nove ancinhos do Elasticsearch em que pisei</a></li>
<li><a href="../pt419043/index.html">O esquivo problema de temporiza√ß√£o de quadros</a></li>
<li><a href="../pt419047/index.html">Reddit hackeado, vazou banco de dados com senhas e e-mail para 2005-2007</a></li>
<li><a href="../pt419049/index.html">GeekBrains lan√ßa maratona educacional on-line gratuita ‚ÄúEncontre-se na Digital‚Äù</a></li>
<li><a href="../pt419051/index.html">Como Flant ajuda iniciantes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>