<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>âœï¸ ğŸŒ· ğŸ« Monorepositori: tolong ğŸ‘±ğŸ¿ ğŸ‘ˆğŸ» ğŸ’‡ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terjemahan artikel disiapkan untuk siswa kursus Praktek dan Alat DevOps dalam proyek pendidikan OTUS . 



 Anda harus memilih repositori mono, karena...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Monorepositori: tolong</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/453958/"><p><img src="https://habrastorage.org/webt/zb/qs/gu/zbqsgutqkd38ocudlbvzx5zeldc.png" alt="gambar"></p><br><p>  <em>Terjemahan artikel disiapkan untuk siswa kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Praktek dan Alat DevOps dalam</a> proyek pendidikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OTUS</a> .</em> </p><br><hr><br><p>  Anda harus memilih repositori mono, karena perilaku yang dipromosikannya dalam tim Anda adalah transparansi dan tanggung jawab bersama, terutama dengan pertumbuhan tim.  Bagaimanapun, Anda harus berinvestasi dalam alat, tetapi itu selalu lebih baik ketika perilaku default adalah perilaku yang ingin Anda lihat dalam perintah Anda. <a name="habracut"></a></p><br><h1 id="pochemu-my-govorim-ob-etom">  Mengapa kita membicarakan ini? </h1><br><p>  Matt Klein menulis sebuah artikel, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Monorepos: Tolong jangan!"</a>  (komentar penerjemah: terjemahan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hub "Monorepositories: tolong jangan"</a> ).  Saya suka Matt, saya pikir dia sangat cerdas, dan Anda harus membaca sudut pandangnya.  Dia awalnya mentweet jajak pendapat: </p><br><p><img src="https://habrastorage.org/webt/x2/pl/sm/x2plsmnmw3xzn-hoeo7ksirx1rm.png" alt="gambar"></p><br><p>  <em>Terjemahan:</em> <br>  <em>Pada hari Tahun Baru ini, saya akan berdebat tentang betapa konyolnya monorepositori itu.</em>  <em>2019 mulai tanpa disadari.</em>  <em>Dalam semangat ini, saya menawarkan Anda survei.</em>  <em>Siapa fanatik besar itu?</em>  <em>Pendukung:</em> <br>  - <em>Monorepositori</em> <br>  - <em>Karat</em> <br>  - <em>Survei yang salah / baik itu dan itu</em> </p><br><p>  Jawaban saya adalah: "Saya benar-benar adalah orang-orang ini."  Daripada berbicara tentang obat Rust macam apa, mari kita cari tahu mengapa saya pikir dia salah tentang repositori tunggal.  Sedikit tentang dirimu.  Saya adalah CTO Perangkat Lunak Chef.  Kami memiliki sekitar 100 insinyur, basis kode sekitar 11-12 tahun, dan 4 produk utama.  Bagian dari kode ini ada dalam polyrepository (posisi awal saya), bagian dalam monorepositori (posisi saya saat ini). </p><br><p>  Sebelum saya mulai: setiap argumen yang saya bawa ke sini akan diterapkan pada kedua jenis repositori.  Menurut pendapat saya, tidak ada alasan teknis mengapa Anda harus memilih satu atau jenis repositori lainnya.  Anda dapat membuat pendekatan apa pun berhasil.  Saya senang membicarakan ini, tetapi saya tidak tertarik pada alasan teknis buatan mengapa yang satu lebih unggul dari yang lain. </p><br><p>  Saya setuju dengan bagian pertama dari sudut pandang Matt: </p><br><p>  <em>Karena dalam skala besar, monorepositori akan menyelesaikan semua masalah yang sama yang dipecahkan oleh polyrepository, tetapi pada saat yang sama memprovokasi Anda untuk koherensi yang kuat dari kode Anda dan membutuhkan upaya luar biasa untuk meningkatkan skalabilitas sistem kontrol versi Anda.</em> </p><br><p>  Anda harus menyelesaikan masalah yang sama, terlepas dari apakah Anda memilih repositori mono atau repositori.  Bagaimana Anda merilis rilis?  Apa pendekatan Anda terhadap pembaruan?  Kompatibel dengan belakang?  Ketergantungan lintas proyek?  Gaya arsitektur apa yang dapat diterima?  Bagaimana Anda mengelola infrastruktur bangunan dan pengujian Anda?  Daftar ini tidak ada habisnya.  Dan Anda akan menyelesaikan semuanya saat Anda tumbuh.  Tidak ada keju gratis. </p><br><p>  Saya pikir argumen Matt mirip dengan pandangan yang dibagikan oleh banyak insinyur (dan manajer) yang saya hormati.  Ini terjadi dari sudut pandang insinyur yang mengerjakan komponen, atau tim yang mengerjakan komponen.  Anda mendengar hal-hal seperti: </p><br><ul><li>  Basis kode rumit - saya tidak perlu semua sampah ini. </li><li> Ini lebih sulit untuk diuji karena saya harus memeriksa semua sampah yang tidak saya butuhkan. </li><li>  Lebih sulit untuk bekerja dengan ketergantungan eksternal. </li><li>  Saya membutuhkan sistem kontrol versi virtual saya sendiri. </li></ul><br><p>  Tentu saja, semua poin ini masuk akal.  Ini terjadi dalam kedua kasus - dalam repositori saya memiliki barang-barang saya sendiri, selain yang dibutuhkan untuk perakitan ... Saya mungkin perlu barang lain juga.  Karena itu, saya "hanya" membuat alat yang memeriksa seluruh proyek.  Atau apakah saya membuat repositori mono palsu dengan submodul.  Kita bisa berjalan sepanjang hari di sekitar ini.  Tapi saya pikir argumen Matt melewatkan alasan utama, yang saya cukup banyak berpihak pada monorepositori: </p><br><h1 id="on-provociruet-obschenie-i-pokazyvaet-problemy">  Ini memancing komunikasi dan menunjukkan masalah. </h1><br><p>  Ketika kami berbagi repositori, kami secara de facto menciptakan masalah koordinasi dan transparansi.  Ini sesuai dengan cara kita berpikir tentang tim (terutama cara masing-masing peserta memikirkannya): kita bertanggung jawab atas komponen tertentu.  Kami bekerja dalam isolasi relatif.  Batas-batas ditetapkan pada tim saya dan komponen yang sedang kami kerjakan. </p><br><p>  Dengan kompleksitas arsitekturnya, satu tim tidak bisa lagi mengelolanya sendiri.  Sangat sedikit insinyur yang menyimpan seluruh sistem di kepala mereka.  Misalkan Anda mengontrol komponen umum A, yang digunakan oleh perintah B, C, dan D. Tim A refactores, meningkatkan API, dan juga mengubah implementasi internal.  Akibatnya, perubahan mundur tidak kompatibel.  Apa saran yang akan Anda berikan? </p><br><ul><li>  Temukan semua tempat di mana API lama digunakan. </li><li>  Apakah ada tempat di mana API baru tidak dapat digunakan? </li><li>  Bisakah Anda memperbaiki dan menguji komponen lain untuk memastikan mereka tidak rusak? </li><li>  Bisakah tim ini memeriksa perubahan Anda sekarang? </li></ul><br><p>  Harap dicatat bahwa pertanyaan-pertanyaan ini tidak tergantung pada jenis repositori.  Anda perlu menemukan tim B, C, dan D. Anda perlu berbicara dengan mereka, mencari tahu waktu, memahami prioritas mereka.  Setidaknya kami harap Anda melakukannya. </p><br><p>  Tidak ada yang benar-benar ingin melakukan ini.  Ini jauh lebih tidak menyenangkan daripada hanya memperbaiki API sialan.  Semua ini manusia dan bingung.  Di repositori, Anda bisa membuat perubahan, memberikan ulasan kepada mereka yang mengerjakan komponen ini (mungkin bukan B, C atau D), dan melanjutkan.  Tim B, C, dan D bisa tetap menggunakan versi mereka saat ini.  Mereka akan diperbarui ketika mereka menyadari kejeniusan Anda! </p><br><p>  Dalam repositori tunggal, tanggung jawab digeser secara default.  Tim A mengganti komponennya dan, jika tidak hati-hati, segera memecahkan B, C dan D. Ini menyebabkan B, C dan D muncul di pintu A, bertanya-tanya mengapa tim A merusak perakitan.  Ini mengajarkan A bahwa mereka tidak dapat melewati daftar saya di atas.  Mereka harus berbicara tentang apa yang akan mereka lakukan.  Bisakah B, C, dan D bergerak?  Bagaimana jika B dan C bisa, tetapi D terkait erat dengan efek samping dari algoritma lama? </p><br><p>  Maka kita perlu berbicara tentang bagaimana kita keluar dari situasi ini: </p><br><ol><li>  Dukungan untuk beberapa API internal, sedangkan algoritma lama akan ditandai usang sampai D dapat berhenti menggunakannya. </li><li>  Dukungan untuk beberapa versi rilis, satu dengan antarmuka lama, satu dengan yang baru. </li><li>  Tertunda rilis perubahan ke A sampai B, C, dan D dapat menerimanya. </li></ol><br><p>  Misalkan kita memilih 1, beberapa API.  Dalam hal ini, kami memiliki dua potong kode.  Tua dan baru.  Cukup berguna dalam beberapa situasi.  Kami mengembalikan kode lama kembali, tandainya sudah usang dan menyepakati jadwal untuk penghapusan dengan perintah D. Ini pada dasarnya identik untuk poli dan untuk monorepositori. </p><br><p>  Untuk merilis beberapa versi, kami membutuhkan cabang.  Sekarang kami memiliki dua komponen - A1 dan A2.  Tim B dan C menggunakan A2, dan D menggunakan A1.  Kami membutuhkan setiap komponen untuk siap dirilis, karena sebelum D dapat melanjutkan, pembaruan keamanan dan perbaikan bug lainnya mungkin diperlukan.  Dalam repositori, kita bisa menyembunyikannya di cabang berumur panjang yang terasa enak.  Dalam mono-repositori, kami memaksakan kode dalam modul baru.  Tim D masih harus melakukan perubahan pada komponen "lama".  Semua orang dapat melihat biaya yang kami bayarkan di sini - kami sekarang memiliki kode dua kali lebih banyak, dan perbaikan bug apa pun yang berlaku untuk A1 dan A2 harus diterapkan pada keduanya.  Dengan pendekatan menggunakan cabang dalam repositori, ini tersembunyi di balik cherry-pick.  Kami menganggap biaya lebih murah karena tidak ada duplikasi.  Dari sudut pandang praktis, biayanya sama: Anda akan membuat, melepaskan, dan memelihara dua basis kode, yang pada dasarnya identik, hingga Anda dapat menghapus salah satunya.  Perbedaannya adalah bahwa dalam monorepositori, nyeri ini langsung dan terlihat.  <strong>Ini bahkan lebih buruk dan bagus.</strong> </p><br><p>  Akhirnya, kami sampai pada poin ketiga.  Lepaskan penundaan.  Mungkin saja perubahan yang dilakukan oleh A akan meningkatkan kehidupan tim A. Ini penting, tetapi tidak mendesak.  Bisakah kita bertahan?  Dalam repositori, kami mendorong ini untuk mengkonsolidasikan artefak.  Tentu saja, kita berbicara tentang tim ini D. Tetaplah pada versi lama sampai Anda menyusul!  Ini membuat game pengecut.  Tim A terus bekerja pada komponennya, mengabaikan fakta bahwa Tim D menggunakan versi yang semakin usang (ini adalah masalah bagi Tim D, mereka bodoh).  Sementara itu, tim D berbicara buruk tentang sikap ceroboh Tim A terhadap stabilitas kode, jika mereka membicarakannya sama sekali.  Bulan berlalu.  Akhirnya, tim D memutuskan untuk melihat opsi peningkatan, tetapi hanya ada lebih banyak perubahan pada A.  Tim A hampir tidak ingat kapan dan bagaimana mereka melanggar D. Memperbarui lebih menyakitkan dan akan lebih lama.  Yang mengirimkannya lebih jauh ke tumpukan prioritas.  Sampai hari itu, sampai kita memiliki masalah keamanan di A, yang memaksa kita untuk membuat cabang.  Tim A harus kembali ke masa lalu, menemukan momen ketika D stabil, memperbaiki masalah di sana dan membuatnya siap untuk dirilis.  <strong>Ini adalah pilihan de facto yang dibuat orang, dan sejauh ini yang terburuk.</strong>  Ini sepertinya baik untuk tim A dan D, selama kita bisa mengabaikan satu sama lain. </p><br><p>  Dalam monorepositori, yang ketiga benar-benar bukan pilihan.  Anda dipaksa untuk menghadapi situasi dengan salah satu dari dua cara.  Anda perlu melihat biaya memiliki dua cabang rilis.  Pelajari cara melindungi diri dari pembaruan yang merusak kompatibilitas.  Tetapi yang utama: <em>Anda tidak bisa menghindari percakapan yang sulit.</em> </p><br><p>  Dalam pengalaman saya, ketika tim menjadi besar, tidak mungkin lagi mengingat seluruh sistem, dan ini adalah bagian terpenting.  Anda harus meningkatkan visibilitas peluang di sistem.  Anda harus bekerja secara aktif untuk membuat tim mengalihkan pandangan dari komponen mereka dan melihat karya tim dan konsumen lain. </p><br><p>  Ya, Anda bisa membuat alat yang akan mencoba menyelesaikan masalah polrepositori.  Tetapi pengalaman saya dalam mengajar pengiriman terus menerus dan otomatisasi di perusahaan besar memberi tahu saya hal berikut: perilaku default tanpa menggunakan alat tambahan adalah perilaku yang Anda harapkan untuk dilihat.  <strong>Perilaku default repositori adalah isolasi, itulah intinya.</strong>  <strong>Perilaku default mono-repositori adalah tanggung jawab dan transparansi bersama, itulah intinya.</strong>  Dalam kedua kasus, saya akan membuat alat yang akan melicinkan sudut tajam.  Sebagai pemimpin, saya akan memilih repositori mono setiap saat, karena instrumen harus memperkuat budaya yang saya inginkan, dan budaya berasal dari keputusan kecil dan pekerjaan sehari-hari tim. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453958/">https://habr.com/ru/post/id453958/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453942/index.html">Tentang Etika dengan Contoh Codex PMI</a></li>
<li><a href="../id453944/index.html">Bug bertopeng di embedd</a></li>
<li><a href="../id453950/index.html">Anda seharusnya ada di sini! 22 tahun rilis game legendaris Duke Nukem 3D</a></li>
<li><a href="../id453952/index.html">"Permintaan telah matang": Alexei Fedorov tentang konferensi baru tentang sistem terdistribusi</a></li>
<li><a href="../id453956/index.html">Museum DataArt. Terminal video ADM-3A. Mobil itu berat, dapat diandalkan, dan disembelih</a></li>
<li><a href="../id453960/index.html">Global DevOps Bootcamp 2019 di Moskow</a></li>
<li><a href="../id453962/index.html">RxSwift dan Coroutines di Kotlin - pengembangan ponsel opsional dari AGIMA dan GeekBrains</a></li>
<li><a href="../id453964/index.html">OOP dalam bahasa R (bagian 1): kelas S3</a></li>
<li><a href="../id453968/index.html">Hapus praktik tinjauan kode beracun</a></li>
<li><a href="../id453970/index.html">Kami menulis proksi Reverse socks5 di PowerShell</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>