<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìè üöå üíáüèª 5 versteckte Geheimnisse in Java ü§∞üèΩ üéΩ üôã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habr Ich pr√§sentiere Ihnen die √úbersetzung des Artikels " 5 Hidden Secrets in Java " von Justin Albano . 

 Willst du ein Java Jedi werden? L√ºft...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 versteckte Geheimnisse in Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480544/"> Hallo habr  Ich pr√§sentiere Ihnen die √úbersetzung des Artikels " <a href="https://dzone.com/articles/5-hidden-secrets-in-java">5 Hidden Secrets in Java</a> " von <a href="https://dzone.com/users/1144561/albanoj2.html">Justin Albano</a> . <br><br>  Willst du ein Java Jedi werden?  L√ºfte die alten Geheimnisse von Java.  Wir werden uns auf das Erweitern von Annotationen, Initialisierungen, Kommentaren und Enum-Schnittstellen konzentrieren. <br><br>  Mit der Entwicklung der Programmiersprachen tauchen auch versteckte Funktionen auf, und Konstruktionen, an die die Gr√ºnder nie gedacht hatten, werden f√ºr den allgemeinen Gebrauch immer weiter verbreitet.  Einige dieser Funktionen werden in der Sprache allgemein akzeptiert, w√§hrend andere in die dunkelsten Winkel der Sprachgemeinschaft r√ºcken.  In diesem Artikel werden wir uns f√ºnf Geheimnisse ansehen, die von vielen Java-Entwicklern oft √ºbersehen werden (fairerweise haben einige gute Gr√ºnde daf√ºr).  Wir betrachten sowohl die Verwendungsm√∂glichkeiten als auch die Gr√ºnde, die zum Erscheinen der einzelnen Funktionen gef√ºhrt haben, sowie einige Beispiele, die zeigen, wann es ratsam ist, diese Funktionen zu verwenden. <br><a name="habracut"></a><br>  Der Leser sollte verstehen, dass nicht alle diese Funktionen tats√§chlich verborgen sind, sie werden im allt√§glichen Programmieren einfach nicht oft verwendet.  Einige von ihnen k√∂nnen zum richtigen Zeitpunkt sehr n√ºtzlich sein, w√§hrend die Verwendung anderer fast immer eine schlechte Idee ist, und sie werden in diesem Artikel gezeigt, um den Leser zu interessieren (und ihn oder sie m√∂glicherweise zum Lachen zu bringen).  Der Leser muss auch entscheiden, wann die in diesem Artikel beschriebenen Funktionen verwendet werden sollen: "Die Tatsache, dass dies m√∂glich ist, bedeutet nicht, dass dies erforderlich ist." <br><br><h3>  1. Implementieren Sie Anmerkungen </h3><br>  Ab dem Java Development Kit (JDK) 5 sind Anmerkungen ein wesentlicher Bestandteil vieler Java-Anwendungen und -Umgebungen.  In den allermeisten F√§llen beziehen sich Anmerkungen auf Konstrukte wie Klassen, Felder, Methoden usw.  Sie k√∂nnen jedoch auch als implementierte Schnittstellen verwendet werden.  Angenommen, wir haben die folgende Annotationsdefinition: <br><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-meta"><span class="hljs-meta">@Target</span></span>(ElementType.METHOD) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Test { <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br>  Wir wenden diese Annotation normalerweise auf eine der folgenden Methoden an: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyTestFixure</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">givenFooWhenBarThenBaz</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre> <br>  Anschlie√üend k√∂nnen wir diese Annotation wie unter <a href="https://dzone.com/articles/creating-custom-annotations-in-java">Erstellen von Annotationen in Java beschrieben verarbeiten</a> .  Wenn wir auch eine Schnittstelle erstellen m√∂chten, mit der wir Tests als Objekte erstellen k√∂nnen, m√ºssen wir eine neue Schnittstelle erstellen, die etwas anderes nennt, und nicht Test: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestInstance</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br>  Als N√§chstes k√∂nnen wir eine Instanz des TestInstance-Objekts erstellen: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooTestInstance</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestInstance</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Foo"</span></span>; } } TestInstance myTest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FooTestInstance();</code> </pre> <br>  Obwohl unsere Annotation und Benutzeroberfl√§che nahezu identisch sind, scheint es keine M√∂glichkeit zu geben, diese beiden Konstrukte zu kombinieren.  Gl√ºcklicherweise t√§uscht der Schein, und es gibt eine Methode zum Kombinieren dieser beiden Konstrukte: Implementieren von Anmerkungen: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Foo"</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Class&lt;? extends Annotation&gt; annotationType() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Test.class; } }</code> </pre> <br>  Beachten Sie, dass wir die annotationType-Methode implementieren und auch den Annotationstyp zur√ºckgeben m√ºssen, da dies ein impliziter Teil der Annotation-Schnittstelle ist.  Obwohl in fast allen F√§llen die Implementierung von Annotationen nicht die richtige L√∂sung f√ºr das Design ist (der Java-Compiler zeigt bei der Implementierung der Schnittstelle eine Warnung an), kann dies in einigen F√§llen hilfreich sein, z. B. im annotationsgesteuerten Framework. <br><br><h3>  2. Nicht statische Initialisierungsbl√∂cke. </h3><br>  In Java werden Objekte wie in den meisten objektorientierten Programmiersprachen ausschlie√ülich mit dem Konstruktor erstellt (mit einigen Ausnahmen, z. B. beim Deserialisieren von Java-Objekten).  Selbst wenn wir statische Factory-Methoden zum Erstellen von Objekten erstellen, f√ºgen wir einfach einen Aufruf in den Konstruktor des Objekts ein, um es zu instanziieren.  Zum Beispiel: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Foo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">withName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(name); } } Foo foo = Foo.withName(<span class="hljs-string"><span class="hljs-string">"Bar"</span></span>);</code> </pre> <br>  Wenn wir ein Objekt initialisieren m√∂chten, kombinieren wir daher die Initialisierungslogik im Konstruktor des Objekts.  Zum Beispiel setzen wir das Namensfeld der Foo-Klasse in ihrem parametrisierten Konstruktor.  Obwohl anzunehmen scheint, dass sich die gesamte Initialisierungslogik im Konstruktor oder in der Gruppe von Konstruktoren f√ºr die Klasse befindet, ist dies in Java nicht der Fall.  Stattdessen k√∂nnen wir beim Erstellen eines Objekts <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/initial.html">nicht statische Initialisierungsbl√∂cke verwenden</a> , um Code auszuf√ºhren: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:instance 1"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:constructor"</span></span>); } }</code> </pre> <br>  Nicht statische Initialisierungsbl√∂cke werden durch Hinzuf√ºgen von Initialisierungslogik zu einem Satz geschweifter Klammern in der Klassendefinition angegeben.  Wenn ein Objekt erstellt wird, werden zuerst nicht statische Initialisierungsbl√∂cke und dann die Konstruktoren des Objekts aufgerufen.  Beachten Sie, dass Sie mehr als einen nicht statischen Initialisierungsblock angeben k√∂nnen. In diesem Fall wird jeder in der Reihenfolge aufgerufen, in der er in der Klassendefinition angegeben ist.  Zus√§tzlich zu nicht statischen Initialisierungsbl√∂cken k√∂nnen statische Bl√∂cke erstellt werden, die ausgef√ºhrt werden, wenn die Klasse in den Speicher geladen wird.  Um einen statischen Initialisierungsblock zu erstellen, f√ºgen wir einfach das statische Schl√ºsselwort hinzu: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:instance 1"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:static 1"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:constructor"</span></span>); } }</code> </pre> <br>  Wenn alle drei Initialisierungsmethoden in der Klasse vorhanden sind (Konstruktoren, nicht statische Initialisierungsbl√∂cke und statische Initialisierungsbl√∂cke), werden statische immer zuerst (wenn die Klasse in den Speicher geladen wird) in der Reihenfolge ihrer Deklaration ausgef√ºhrt, und nicht statische Initialisierungsbl√∂cke werden in der Reihenfolge ausgef√ºhrt, in der sie deklariert wurden nach ihnen - die Designer.  Wenn eine Superklasse eingef√ºhrt wird, √§ndert sich die Ausf√ºhrungsreihenfolge ein wenig: <br><br><ol><li>  Statische Initialisierungsbl√∂cke der Oberklasse in der Reihenfolge ihrer Deklaration </li><li>  Initialisierungsbl√∂cke f√ºr statische Unterklassen in der Reihenfolge ihrer Deklaration </li><li>  Nicht statische Initialisierungsbl√∂cke der Oberklasse, in der Reihenfolge, in der sie deklariert sind </li><li>  Superklasse-Konstruktor </li><li>  Nicht statische Unterklassen-Initialisierungsbl√∂cke, in der Reihenfolge, in der sie deklariert sind </li><li>  Unterklassenkonstruktor </li></ol><br>  Beispielsweise k√∂nnen wir die folgende Anwendung erstellen: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:static 1"</span></span>); } { System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:instance 1"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:static 2"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:constructor"</span></span>); } { System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:instance 2"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:name-constructor"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:static 1"</span></span>); } { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:instance 1"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:static 2"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:constructor"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(name); System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:name-constructor"</span></span>); } { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:instance 2"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(); System.out.println(); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(<span class="hljs-string"><span class="hljs-string">"Baz"</span></span>); } }</code> </pre> <br>  Wenn wir diesen Code ausf√ºhren, erhalten wir die folgende Ausgabe: <br><br><pre> <code class="java hljs">Bar:<span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> Bar:<span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> Foo:<span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> Foo:<span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> Bar:instance <span class="hljs-number"><span class="hljs-number">1</span></span> Bar:instance <span class="hljs-number"><span class="hljs-number">2</span></span> Bar:constructor Foo:instance <span class="hljs-number"><span class="hljs-number">1</span></span> Foo:instance <span class="hljs-number"><span class="hljs-number">2</span></span> Foo:constructor Bar:instance <span class="hljs-number"><span class="hljs-number">1</span></span> Bar:instance <span class="hljs-number"><span class="hljs-number">2</span></span> Bar:name-constructor Foo:instance <span class="hljs-number"><span class="hljs-number">1</span></span> Foo:instance <span class="hljs-number"><span class="hljs-number">2</span></span> Foo:name-constructor</code> </pre> <br>  Beachten Sie, dass statische Initialisierungsbl√∂cke nur einmal ausgef√ºhrt wurden, selbst wenn zwei Foo-Objekte erstellt wurden.  Obwohl nicht statistische und statische Initialisierungsbl√∂cke n√ºtzlich sein k√∂nnen, sollte die Initialisierungslogik in den Konstruktoren platziert werden, und Methoden (oder statische Methoden) sollten in F√§llen verwendet werden, in denen komplexe Logik die Initialisierung des Status des Objekts erfordert. <br><br><h3>  3. Initialisierung in doppelten Klammern </h3><br>  Viele Programmiersprachen enthalten einen Syntaxmechanismus zum schnellen und kurzen Erstellen einer Liste oder Map (oder eines W√∂rterbuchs) ohne Verwendung von detailliertem Vorlagencode.  Beispielsweise enth√§lt C ++ eine <a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization">Initialisierung in Klammern</a> , mit der Entwickler schnell eine Liste von Aufz√§hlungswerten erstellen oder sogar ganze Objekte initialisieren k√∂nnen, wenn der Konstruktor f√ºr das Objekt diese Funktion unterst√ºtzt.  Leider wurde eine solche Funktion vor JDK 9 nicht implementiert (dazu sp√§ter mehr).  Um einfach eine Liste von Objekten zu erstellen, w√ºrden wir Folgendes tun: <br><br><pre> <code class="java hljs">List&lt;Integer&gt; myInts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); myInts.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); myInts.add(<span class="hljs-number"><span class="hljs-number">2</span></span>); myInts.add(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  Dies erf√ºllt zwar unser Ziel, eine neue Liste zu erstellen, die mit drei Werten initialisiert ist, ist jedoch zu ausf√ºhrlich, und der Entwickler muss den Namen der Listenvariablen f√ºr jedes Hinzuf√ºgen wiederholen.  Um diesen Code zu verk√ºrzen, k√∂nnen wir die <a href="https://stackoverflow.com/questions/1958636/what-is-double-brace-initialization-in-java">doppelte Initialisierung von Klammern verwenden</a> : <br><br><pre> <code class="java hljs">List &lt; Integer &gt;List&lt;Integer&gt; myInts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;() {{ add(<span class="hljs-number"><span class="hljs-number">1</span></span>); add(<span class="hljs-number"><span class="hljs-number">2</span></span>); add(<span class="hljs-number"><span class="hljs-number">3</span></span>); }};</code> </pre> <br>  Eine doppelte Klammer-Initialisierung, die ihren Namen von einem Satz aus zwei offenen und geschlossenen geschweiften Klammern ableitet, besteht eigentlich aus mehreren Syntaxelementen.  Zun√§chst erstellen wir <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html">eine anonyme innere Klasse</a> , die die ArrayList-Klasse erweitert.  Da ArrayList keine abstrakten Methoden hat, k√∂nnen wir einen leeren Body f√ºr eine anonyme Implementierung erstellen: <br><br><pre> <code class="java hljs">List&lt;Integer&gt; myInts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;() {};</code> </pre> <br>  Mit diesem Code erstellen wir im Wesentlichen eine anonyme Unterklasse. ArrayList entspricht genau der urspr√ºnglichen ArrayList.  Einer der Hauptunterschiede besteht darin, dass unsere innere Klasse implizit auf die enthaltende Klasse verweist (in Form einer von dieser erfassten Variablen), weil  Wir schaffen eine nicht-statische innere Klasse.  Dies erm√∂glicht es uns, einige interessante, wenn nicht verwirrende Logik zu schreiben.  Beispiel: Hinzuf√ºgen dieser Variablen zu einer anonymen inneren Klasse, die mit einer doppelten Klammer initialisiert wurde: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Foo&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getListWithMeIncluded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Foo&gt;() {{ add(Foo.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }}; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ Foo foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(); List&lt;Foo&gt; fooList = foo.getListWithMeIncluded(); System.out.println(foo.equals(fooList.get(<span class="hljs-number"><span class="hljs-number">0</span></span>))); } }</code> </pre> <br>  Wenn diese innere Klasse als statisch definiert w√§re, h√§tten wir keinen Zugriff auf Foo.this.  Der folgende Code, der eine statische innere Klasse FooArrayList erstellt, hat beispielsweise keinen Zugriff auf den Link Foo.this und wird daher nicht kompiliert: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Foo&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getListWithMeIncluded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FooArrayList(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooArrayList</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArrayList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class">&gt; </span></span>{{ add(Foo.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }} }</code> </pre> <br>  Wenn wir die Konstruktion mit unserer in doppelte Klammern gesetzten initialisierten ArrayList fortsetzen, verwenden wir, nachdem eine nicht statische innere Klasse erstellt wurde, nicht statische Initialisierungsbl√∂cke, um die drei Anfangselemente beim Instanziieren einer anonymen inneren Klasse hinzuzuf√ºgen.  Wenn eine anonyme innere Klasse erstellt wird und es nur ein Objekt einer anonymen inneren Klasse gibt, k√∂nnen wir sagen, dass wir ein nicht statisches inneres Objekt erstellt haben, das beim Erstellen drei Anfangselemente hinzuf√ºgt.  Dies wird sichtbar, wenn wir ein Paar geschweifte Klammern trennen, wobei eine geschweifte Klammer die Definition einer anonymen inneren Klasse darstellt und die andere den Beginn der Instanzinitialisierungslogik markiert: <br><br><pre> <code class="java hljs">List&lt;Integer&gt; myInts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;() { { add(<span class="hljs-number"><span class="hljs-number">1</span></span>); add(<span class="hljs-number"><span class="hljs-number">2</span></span>); add(<span class="hljs-number"><span class="hljs-number">3</span></span>); } };</code> </pre> <br>  Obwohl dieser Trick n√ºtzlich sein mag, hat JDK 9 ( <a href="http://openjdk.java.net/jeps/269">JEP 269</a> ) den Nutzen dieses Tricks durch eine Reihe statischer Factory-Methoden f√ºr List (sowie viele andere Arten von Sammlungen) ersetzt.  Zum Beispiel k√∂nnten wir eine Liste fr√ºher mit diesen statischen Factory-Methoden erstellen, wie unten gezeigt: <br><br><pre> <code class="java hljs">List&lt;Integer&gt; myInts = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  Diese statische Factory-Technik wird aus zwei Hauptgr√ºnden verwendet: (1) Es wird keine anonyme innere Klasse erstellt und (2) um den zum Erstellen einer Liste erforderlichen Standardcode zu reduzieren.  Es ist zu beachten, dass in diesem Fall das Ergebnis von List unver√§ndert bleibt und nach seiner Erstellung nicht mehr ge√§ndert werden kann.  Um eine ver√§nderbare Listendatei mit Anfangselementen zu erstellen, m√ºssen Sie eine regul√§re Methode oder eine Methode mit einer doppelten Initialisierungsklammer verwenden. <br><br>  Beachten Sie, dass die statischen Factory-Methoden f√ºr einfache Initialisierung, doppelte Klammer und JDK 9 nicht nur f√ºr List verf√ºgbar sind.  Sie sind f√ºr Set- und Map-Objekte verf√ºgbar, wie im folgenden Snippet gezeigt: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   Map&lt;String, Integer&gt; myMap = new HashMap&lt;&gt;(); myMap.put("Foo", 10); myMap.put("Bar", 15); //     Map&lt;String, Integer&gt; myMap = new HashMap&lt;&gt;() {{ put("Foo", 10); put("Bar", 15); }}; //    Map&lt;String, Integer&gt; myMap = Map.of("Foo", 10, "Bar", 15);</span></span></code> </pre> <br>  Es ist wichtig zu verstehen, wie die Doppelklammer initialisiert wird, bevor Sie sich f√ºr eine Verwendung entscheiden.  Dadurch wird die Lesbarkeit des Codes verbessert, es k√∂nnen jedoch einige Nebenwirkungen auftreten. <br><br><h3>  4. Ausf√ºhrbare Kommentare </h3><br>  Kommentare sind ein wesentlicher Bestandteil fast jedes Programms, und der Hauptvorteil von Kommentaren besteht darin, dass sie nicht ausgef√ºhrt werden.  Dies wird noch deutlicher, wenn wir eine Codezeile in unserem Programm auskommentieren: Wir m√∂chten den Code in unserer Anwendung speichern, aber nicht ausf√ºhren.  Das folgende Programm zeigt beispielsweise "5" als Ergebnis an: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// value = 8; System.out.println(value); }</span></span></code> </pre> <br>  Viele Leute denken, dass Kommentare nie ausgef√ºhrt werden, aber das ist nicht ganz richtig.  Was wird beispielsweise der folgende Codeausschnitt ausgeben? <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// \u000dvalue = 8; System.out.println(value); }</span></span></code> </pre> <br>  Sie k√∂nnten annehmen, dass dies wieder 5 ist, aber wenn wir den obigen Code ausf√ºhren, sehen wir 8 am Ausgang.  Der Grund f√ºr diesen "Fehler" ist das Unicode-Zeichen \ u000d;  Dieses Zeichen ist eigentlich ein <a href="https://www.compart.com/en/unicode/U%2B000D">Unicode-Wagenr√ºcklauf</a> und der Java-Quellcode wird vom Compiler als Textdatei im Unicode-Format verwendet.  Durch die Hinzuf√ºgung zum Code wird in der Zeile nach dem Kommentar der Wert = 8 festgelegt, um die Ausf√ºhrung sicherzustellen.  Dies bedeutet, dass das obige Codefragment tats√§chlich wie folgt lautet: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// value = 8; System.out.println(value); }</span></span></code> </pre> <br>  Obwohl dies wie ein Java-Fehler erscheint, ist es tats√§chlich ein spezielles Feature f√ºr die Sprache.  Das urspr√ºngliche Ziel bestand darin, eine plattformunabh√§ngige Sprache zu erstellen (daher die Erstellung einer virtuellen Java- oder JVM-Maschine), und die Interoperabilit√§t des Quellcodes ist ein Schl√ºsselaspekt dieses Ziels.  Indem wir zulassen, dass Java-Quellcode Unicode-Zeichen enth√§lt, k√∂nnen wir nicht-lateinische Zeichen universell verwenden.  Auf diese Weise wird sichergestellt, dass Code, der in einer Region der Welt geschrieben wurde (der m√∂glicherweise nicht-lateinische Zeichen enth√§lt, z. B. in Kommentaren), in einer anderen ausgef√ºhrt werden kann.  Weitere Informationen finden Sie in <a href="https://docs.oracle.com/javase/specs/jls/se9/html/jls-3.html">Abschnitt 3.3, Java- oder JLS-Sprachspezifikationen</a> . <br><br>  Wir k√∂nnen dies auf die Spitze treiben und sogar eine ganze Anwendung in Unicode schreiben.  Was macht beispielsweise das folgende Programm (von <a href="https://programming.guide/java/executing-code-in-comments.html">Java</a> abgeleiteter Quellcode <a href="https://programming.guide/java/executing-code-in-comments.html">: Codeausf√ºhrung in Kommentaren ?!</a> )? <br><br><pre> <code class="java hljs">\u0070\u0075\u0062\u006c\u0069\u0063\u0020\u0020\u0020\u0020 \u0063\u006c\u0061\u0073\u0073\u0020\u0055\u0067\u006c\u0079 \u007b\u0070\u0075\u0062\u006c\u0069\u0063\u0020\u0020\u0020 \u0020\u0020\u0020\u0020\u0073\u0074\u0061\u0074\u0069\u0063 \u0076\u006f\u0069\u0064\u0020\u006d\u0061\u0069\u006e\u0028 \u0053\u0074\u0072\u0069\u006e\u0067\u005b\u005d\u0020\u0020 \u0020\u0020\u0020\u0020\u0061\u0072\u0067\u0073\u0029\u007b \u0053\u0079\u0073\u0074\u0065\u006d\u002e\u006f\u0075\u0074 \u002e\u0070\u0072\u0069\u006e\u0074\u006c\u006e\u0028\u0020 \u0022\u0048\u0065\u006c\u006c\u006f\u0020\u0077\u0022\u002b \u0022\u006f\u0072\u006c\u0064\u0022\u0029\u003b\u007d\u007d</code> </pre> <br>  Wenn Sie den obigen Code in eine Datei mit dem Namen Ugly.java einf√ºgen und ausf√ºhren, wird Hello world auf der Standardausgabe gedruckt.  Wenn wir diese Unicode-Zeichen in Zeichen des <a href="https://en.wikipedia.org/wiki/ASCII">amerikanischen Standardcodes f√ºr den Informationsaustausch (ASCII)</a> konvertieren, erhalten wir das folgende Programm: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ugly</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hello w"</span></span>+<span class="hljs-string"><span class="hljs-string">"orld"</span></span>); } }</code> </pre> <br>  Daher k√∂nnen Unicode-Zeichen im Java-Quellcode enthalten sein. Wenn sie jedoch nicht erforderlich sind, wird dringend empfohlen, sie nicht zu verwenden (z. B. um nicht-lateinische Zeichen in Kommentare aufzunehmen).  Wenn sie dennoch erforderlich sind, stellen Sie sicher, dass sie keine Zeichen wie Wagenr√ºcklauf enthalten, die das erwartete Verhalten des Quellcodes √§ndern. <br><br><h3>  5. Implementierung der Enum-Schnittstelle </h3><br>  Eine der Einschr√§nkungen von Aufz√§hlungen (eine Aufz√§hlungsliste) im Vergleich zu anderen Klassen in Java besteht darin, dass Aufz√§hlungen keine andere Klasse erweitern k√∂nnen oder sich selbst auflisten.  Beispielsweise k√∂nnen Sie Folgendes nicht ausf√ºhren: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Speaker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hi"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Person extends Speaker { JOE(<span class="hljs-string"><span class="hljs-string">"Joseph"</span></span>), JIM(<span class="hljs-string"><span class="hljs-string">"James"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } } Person.JOE.speak();</code> </pre> <br>  Wir k√∂nnen jedoch unsere Aufz√§hlungen zwingen, die Schnittstelle wie folgt zu implementieren und eine Implementierung f√ºr ihre abstrakten Methoden bereitzustellen: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Speaker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Person implements Speaker { JOE(<span class="hljs-string"><span class="hljs-string">"Joseph"</span></span>), JIM(<span class="hljs-string"><span class="hljs-string">"James"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hi"</span></span>); } } Person.JOE.speak();</code> </pre> <br>  Jetzt k√∂nnen wir eine Instanz von Person √ºberall dort verwenden, wo ein Speaker-Objekt ben√∂tigt wird.  Dar√ºber hinaus k√∂nnen wir auch die kontinuierliche Implementierung abstrakter Schnittstellenmethoden sicherstellen (die sogenannten Methoden, die f√ºr Konstanten spezifisch sind): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Speaker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Person implements Speaker { JOE(<span class="hljs-string"><span class="hljs-string">"Joseph"</span></span>) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hi, my name is Joseph"</span></span>); } }, JIM(<span class="hljs-string"><span class="hljs-string">"James"</span></span>){ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hey, what's up?"</span></span>); } }; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hi"</span></span>); } } Person.JOE.speak();</code> </pre> <br>  Im Gegensatz zu einigen anderen Geheimnissen in diesem Artikel sollte diese Technik nur bei Bedarf eingesetzt werden.  Wenn beispielsweise eine Enum-Konstante wie JOE oder JIM anstelle einer Schnittstelle wie Speaker verwendet werden kann, muss die Enum-Definition einer Konstante diesen Schnittstellentyp implementieren.  Weitere Informationen finden Sie in Paragraph 38 (S. 177-9) <a href="https://www.amazon.com/Effective-Java-3rd-Joshua-Bloch/dp/0134685997">Effective Java, 3rd Edition</a> . <br><br><h3>  Fazit </h3><br>  In diesem Artikel haben wir f√ºnf versteckte Geheimnisse in Java untersucht, n√§mlich: (1) Annotationen k√∂nnen erweitert werden, (2) nicht statische Initialisierungsbl√∂cke k√∂nnen zum Konfigurieren eines Objekts verwendet werden, wenn es erstellt wird, (3) Initialisierung mit doppelten Klammern kann zum Ausf√ºhren von Anweisungen beim Erstellen verwendet werden Eine anonyme innere Klasse, (4) Kommentare k√∂nnen manchmal ausgef√ºhrt werden, und (5) Aufz√§hlungen k√∂nnen Schnittstellen implementieren.  Obwohl diese Funktionen von einem bestimmten Aufgabentyp verwendet werden, sollten einige davon vermieden werden (z. B. das Erstellen ausf√ºhrbarer Kommentare).  Beachten Sie bei der Verwendung dieser Geheimnisse die Regel: "Die Tatsache, dass dies m√∂glich ist, bedeutet nicht, dass dies erforderlich ist." </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480544/">https://habr.com/ru/post/de480544/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480530/index.html">IoT ist kein Spielzeug f√ºr Kinder. Wie Hackerangriffe auf das Internet der Dinge nicht nur gro√üe Unternehmen, sondern auch gew√∂hnliche Familien erschrecken</a></li>
<li><a href="../de480534/index.html">16 Entwicklungstipps f√ºr Android in Kotlin. Teil 2</a></li>
<li><a href="../de480538/index.html">Was ist besser f√ºr Spiele: Intel Optane oder SSD?</a></li>
<li><a href="../de480540/index.html">Umbraco 8.4 Release: CMS ist noch komfortabler</a></li>
<li><a href="../de480542/index.html">Sicherheitsbewusstsein f√ºr Erwachsene: So schlie√üen Sie eine Phishing-Sicherheitsanf√§lligkeit</a></li>
<li><a href="../de480550/index.html">Hallo Welt von Bytecode f√ºr JVM</a></li>
<li><a href="../de480552/index.html">Firefox k√§mpft f√ºr die Zukunft des Webs</a></li>
<li><a href="../de480554/index.html">Die Zukunft des Cloud Computing von Sun, die es nie gab</a></li>
<li><a href="../de480556/index.html">NGINX: Verifikation der russischen IT-Community</a></li>
<li><a href="../de480558/index.html">Wie die Gewinnschwelle des Bergbaus es Ihnen erm√∂glicht, den Dreh- und Angelpunkt von Bitcoin zu bestimmen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>