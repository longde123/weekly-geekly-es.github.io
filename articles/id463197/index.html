<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè® üë©üèª‚Äç‚öïÔ∏è üåÖ Blazor + MVVM = Silverlight menyerang balik karena kejahatan kuno tidak terkalahkan üàµ ü§úüèæ üï¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 

 Jadi ya, net core 3.0 akan segera hadir dan akan ada template proyek dengan Blazor sebagai salah satu yang default. Nama kerangka, menu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Blazor + MVVM = Silverlight menyerang balik karena kejahatan kuno tidak terkalahkan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463197/">  Halo, Habr! <br><br>  Jadi ya, net core 3.0 akan segera hadir dan akan ada template proyek dengan Blazor sebagai salah satu yang default.  Nama kerangka, menurut saya, mirip dengan nama beberapa Pokemon.  Blazor memasuki pertempuran!  Saya memutuskan untuk melihat jenis binatang apa itu dan apa yang dimakannya, jadi saya membuat selembar kertas Todo.  Nah, di Vue.js juga, untuk perbandingan dengan subjek karena menurut pendapat saya mereka mirip dengan sistem komponen dalam keduanya dan reaktivitas, dan itu saja.  Lebih banyak dewi dewa dewa!  Bahkan, ini adalah Panduan untuk anak muda, bukan yang kuat yang terlalu malas untuk belajar TypeScript atau JavaScript dan ingin membuat tombol dan input di situs.  Seperti dalam meme itu - "Teknisi itu ingin menulis buku tetapi instruksi ternyata."  Siapa yang tertarik dengan petualangan saya di ujung depan atau cari tahu Blazor seperti apa yang Anda sukai. <a name="habracut"></a><br><br><h2>  Pendahuluan </h2><br>  Microsoft pernah memiliki ide untuk bekerja C # di browser dan menyebut ide ini Silverlight.  Itu tidak lepas landas.  Ini tyrnets Anda kemudian berbeda sebagai browser yang sebenarnya.  Mengapa saya pikir itu lepas landas sekarang?  Karena sekarang web assemblies ada di semua browser modern secara default.  Tidak perlu menginstal ekstensi terpisah.  Masalah lainnya adalah ukuran aplikasi.  Jika Vue.js SPA memiliki berat 1,7 megabita, maka persis sama pada Blazor 21 megabita.  Sekarang Internet telah menjadi lebih cepat dan lebih dapat diandalkan daripada pada saat Silverlight, dan Anda perlu mengunduh aplikasi satu kali, dan kemudian ada cache dan semuanya.  Secara umum, Blazor tampak sangat mirip dengan Vue.js.  Jadi, sebagai penghargaan untuk Silverligtht, WPF dan UWP, dan hanya karena itu sangat umum di kalangan penajam, saya memutuskan untuk menggunakan pola MVVM untuk proyek saya.  Jadi untuk referensi - Saya umumnya back-end dan saya suka Blazor.  Saya memperingatkan orang yang lemah hati - Desain dan tata letak dalam contoh saya sangat buruk, dan dalam proyek dengan Vue.js seorang penulis front-end yang berpengalaman dapat melihat banyak govnokod.  Nah, dengan ejaan dan tanda baca, semuanya juga begitu-begitu. <br><br><h2>  Referensi </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh Todo pada Vue + Vuex</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh Todo di Blazor</a> <br><br><h2>  Model Penempatan </h2><br><ol><li>  Di sisi klien.  SPA standar yang dapat didistribusikan dengan berbagai cara.  Dalam contoh saya, saya menggunakan templat di mana file aplikasi dikirim ke server browser di asp.net core.  Kerugian dari pendekatan ini adalah 21 megabyte yang harus Anda unduh ke browser. </li><li>  Di sisi server.  Segala sesuatu terjadi di server, dan DOM yang sudah selesai diteruskan ke klien melalui soket.  Peramban tidak perlu mengunduh apa pun di awal, melainkan mengunduh unduhan DOM yang baru secara terus-menerus.  Nah, seluruh beban pada kode klien tiba-tiba jatuh ke server. </li></ol><br>  Saya pribadi lebih suka opsi pertama dan dapat digunakan dalam semua kasus ketika Anda tidak perlu khawatir tentang konversi pengguna.  Misalnya, ini adalah semacam sistem informasi internal perusahaan atau solusi B2B khusus karena Blazor telah mengunduh sejak lama untuk pertama kalinya.  Jika pengguna Anda terus-menerus masuk ke aplikasi Anda, maka mereka tidak akan melihat adanya perbedaan dengan versi JS.  Jika pengguna mengklik tautan iklan, lihat saja situs apa yang ada di sana, kemungkinan besar ia tidak akan menunggu lama untuk memuat situs dan pergi begitu saja.  Dalam hal ini, lebih baik menggunakan opsi penempatan kedua yaitu  Server Side Blazor <br><br><h2>  Pembuatan proyek </h2><br>  Unduh net core 3.0 <a href="">dotnet.microsoft.com/download/dotnet-core/3.0</a> <br>  Jalankan perintah di terminal yang akan memuat template yang diperlukan untuk Anda. <br><br><pre><code class="bash hljs">dotnet new -i Microsoft.AspNetCore.Blazor.Templates</code> </pre> <br>  Untuk membuat sisi server <br><br><pre> <code class="bash hljs">dotnet new blazorserverside -o MyWebApp</code> </pre><br>  Untuk Sisi Klien yang file-nya akan didistribusikan oleh server inti asp.net <br><br><pre> <code class="bash hljs">dotnet new blazorhosted -o MyWebApp</code> </pre><br>  Jika Anda menginginkan eksotisme dan tiba-tiba memutuskan untuk tidak menggunakan inti asp.net sebagai server, tetapi sesuatu yang lain (Apakah Anda memerlukannya?) Anda hanya dapat membuat klien tanpa server dengan perintah ini. <br><br><pre> <code class="bash hljs">dotnet new blazor -o MyWebApp</code> </pre><br><h2>  Binding </h2><br>  Mendukung pengikatan satu arah dan dua arah.  Jadi ya, Anda tidak perlu OnPropertichanged seperti pada WPF.  Saat mengubah Model Tampilan, tata letak berubah secara otomatis. <br><br><pre> <code class="cs hljs">&lt;label&gt;One way binding:&lt;/label&gt; &lt;br /&gt; &lt;input type=<span class="hljs-string"><span class="hljs-string">"text"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>=@Text /&gt; &lt;br /&gt; &lt;label&gt;Two way binding:&lt;/label&gt; &lt;br /&gt; &lt;input type=<span class="hljs-string"><span class="hljs-string">"text"</span></span> @bind=@Text /&gt; &lt;br /&gt; &lt;label&gt;Two way binding         Text   oninput:&lt;/label&gt; &lt;br /&gt; &lt;input type=<span class="hljs-string"><span class="hljs-string">"text"</span></span> @bind=@Text @bind:<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>=<span class="hljs-string"><span class="hljs-string">"oninput"</span></span> /&gt; <span class="hljs-comment"><span class="hljs-comment">//ViewModel @code{ string Text; async Task InpuValueChanged() { Console.WriteLine("Input value changed"); } }</span></span></code> </pre><br>  Jadi, di sini kita memiliki ViewModel (anonim) yang memiliki bidang Teks. <br><br>  Pada input pertama, melalui ‚Äúvalue = @ Text‚Äù kami membuat pengikatan satu arah.  Sekarang ketika kita mengubah Teks dalam kode, teks di dalam input akan segera berubah.  Hanya agar kami tidak mencetak dalam input kami, apakah hal ini mempengaruhi VM kami.  Pada input kedua, melalui "@ bind = @ Text" kami membuat penjilidan dua arah.  Sekarang jika kita menulis sesuatu yang baru di input kita, VM kita akan segera berubah, dan yang sebaliknya juga benar yaitu.  jika kita mengubah bidang Teks dalam kode, maka input kita akan segera menampilkan nilai baru.  Ada satu TETAPI - secara default, perubahan terkait dengan acara pertukaran input kami, sehingga VM hanya akan berubah ketika kami menyelesaikan input.  Pada input ketiga "@bind: event =" oninput "" kami mengubah acara untuk mentransfer data VM menjadi oninput sekarang setiap kali kami mencetak beberapa karakter, nilai baru segera ditransfer ke VM kami.  Anda juga dapat menentukan format untuk DateTime, misalnya, seperti ini. <br><br><pre> <code class="cs hljs">&lt;input @bind=@Today @bind:format=<span class="hljs-string"><span class="hljs-string">"yyyy-MM-dd"</span></span> /&gt;</code> </pre> <br><h2>  Lihat model </h2><br>  Anda dapat menjadikannya anonim sehingga Anda harus menghentikannya di dalam blok "@code {}" <br><br><pre> <code class="cs hljs">@page <span class="hljs-string"><span class="hljs-string">"/todo"</span></span> &lt;p&gt;  @UserName &lt;/p&gt; @code{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> UserName{<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} }</code> </pre><br>  atau Anda bisa meletakkannya di file terpisah.  Maka itu harus diwarisi dari ComponentBase dan di bagian atas halaman tentukan tautan ke VM kami menggunakan "@inherits" <br><br>  Sebagai contoh <br><br>  TodoViewModel.cs: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TodoViewModel</span></span>: <span class="hljs-title"><span class="hljs-title">ComponentBase</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> UserName{<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} }</code> </pre><br>  Todo.razor: <br><br><pre> <code class="cs hljs">@page <span class="hljs-string"><span class="hljs-string">"/todo"</span></span> @inherits MyWebApp.ViewModels.TodoViewModel &lt;p&gt;  @UserName &lt;/p&gt;</code> </pre><br><h2>  Routing </h2><br>  Rute ke mana halaman akan merespons ditunjukkan di awal halaman menggunakan "@page".  Apalagi mungkin ada beberapa.  Yang pertama akan dipilih dengan tepat sesuai urutan dari atas ke bawah.  Sebagai contoh: <br><br><pre> <code class="cs hljs">@page <span class="hljs-string"><span class="hljs-string">"/todo"</span></span> @page <span class="hljs-string"><span class="hljs-string">"/todo/delete"</span></span> &lt;h1&gt; Hello!&lt;/h1&gt;</code> </pre><br>  Halaman ini akan terbuka di "/ todo" atau "todo / delete" <br><br><h2>  Tata letak </h2><br>  Secara umum, hal-hal yang sama untuk beberapa halaman biasanya ditempatkan di sini.  Seperti bilah sisi, dan banyak lagi. <br><br>  Untuk menggunakan tata letak di tempat pertama, Anda harus membuatnya.  Itu harus diwarisi dari LayotComponentBase menggunakan "@inherits".  Sebagai contoh <br><br><pre> <code class="cs hljs">@inherits LayoutComponentBase &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"sidebar"</span></span>&gt; &lt;NavMenu /&gt; &lt;/div&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"main"</span></span>&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"top-row px-4"</span></span>&gt; &lt;a href=<span class="hljs-string"><span class="hljs-string">"http://blazor.net"</span></span> target=<span class="hljs-string"><span class="hljs-string">"_blank"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"ml-md-auto"</span></span>&gt;About&lt;/a&gt; &lt;/div&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"content px-4"</span></span>&gt; @Body &lt;/div&gt; &lt;/div&gt;</code> </pre><br>  Kedua, perlu diimpor.  Untuk melakukan ini, di direktori dengan halaman yang akan menggunakannya, Anda perlu membuat file _imports.razor dan kemudian menambahkan baris "@layout" ke file ini <br><br><pre> <code class="cs hljs">@layout MainLayout @<span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System</code> </pre><br>  Ketiga, Anda dapat menunjukkan pada halaman mana tata letak yang digunakannya secara langsung <br><br><pre> <code class="cs hljs">@layout MainLayout @page <span class="hljs-string"><span class="hljs-string">"/todo"</span></span> @inherits BlazorApp.Client.Presentation.TodoViewModel &lt;h3&gt;Todo&lt;/h3&gt;</code> </pre><br>  Secara umum, _imports.razor dan penggunaannya berfungsi pada semua halaman yang ada di folder yang sama dengannya. <br><br><h2>  Opsi Rute </h2><br>  Pertama, tentukan parameter dan jenisnya dalam kurung kurawal di rute kami (tidak sensitif huruf).  Jenis standar didukung.  Jadi ya, tidak ada parameter opsional yaitu  nilai harus selalu dilewati. <br><br>  Nilai itu sendiri dapat diperoleh dengan membuat properti ViewModel kami dengan nama yang sama dengan parameter dan dengan [Parameter] atribut BTB - berjalan sebelum - data dan peristiwa dalam komponen induk juga ditransmisikan dari komponen induk menggunakan atribut [Parameter] serta parameter cascading.  Mereka diteruskan dari komponen induk ke semua komponen turunannya dan komponen turunannya.  Mereka digunakan terutama untuk gaya, tetapi lebih baik melakukan gaya dalam CSS, jadi mengapa tidak peduli. <br><br><pre> <code class="cs hljs">@page <span class="hljs-string"><span class="hljs-string">"/todo/delete/{id:guid}"</span></span> &lt;h1&gt; Hello!&lt;/h1&gt; @code{ [Parameter] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Guid Id { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br><h2>  DI </h2><br>  Semuanya terdaftar di Startup.cs, seperti dalam aplikasi inti asp.net biasa.  Tidak ada yang baru di sini.  Tetapi implementasi dependensi untuk VM kami masih terjadi melalui properti publik dan bukan melalui konstruktor.  Properti hanya perlu didekorasi dengan atribut [Suntikkan] <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DeleteTodoViewModel</span></span> : <span class="hljs-title"><span class="hljs-title">ComponentBase</span></span> { [Parameter] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Guid Id { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } [Inject] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ICommandDispatcher CommandDispatcher { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br>  Secara default, ada 3 layanan yang sudah terhubung.  HttpClient - Ya, Anda tahu sebabnya.  IJSRuntime - Panggil kode JS dari C #.  IUriHelper - menggunakannya tidak mungkin untuk mengarahkan ulang ke halaman lain. <br><br><h2>  Contoh aplikasi </h2><br><h3>  Spreadsheet Todo </h3><br>  TodoTableComponent.razor: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//1) &lt;table class="table table-hover"&gt; &lt;thead&gt; &lt;th&gt; &lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt; &lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt; //2) @foreach (var item in Items) { //3) &lt;tr @onclick=@(()=&gt;ClickRow(item.Id)) class="@(item.Id == Current?"table-primary":null)"&gt; &lt;td&gt;&lt;input type="checkbox" checked="@item.IsComplite" disabled="disabled" /&gt;&lt;/td&gt; &lt;td&gt;@item.Name&lt;/td&gt; &lt;td&gt;@item.Created.ToString("dd.MM.yyyy HH:mm:ss")&lt;/td&gt; &lt;td&gt;&lt;a href="/todo/delete/@item.Id" class="btn btn-danger"&gt;&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; } &lt;/tbody&gt; &lt;/table&gt; @code { //4) [Parameter] private List&lt;BlazorApp.Client.Presentation.TodoDto&gt; Items { get; set; } [Parameter] private EventCallback&lt;UIMouseEventArgs&gt; OnClick { get; set; } [Parameter] private Guid Current { get; set; } private async Task ClickRow(Guid id) { //5 await OnClick.InvokeAsync(CreateArgs(id)); } private ClickTodoEventArgs CreateArgs(Guid id) { return new ClickTodoEventArgs { Id = id }; } //6) public class ClickTodoEventArgs : UIMouseEventArgs { public Guid Id { get; set; } } }</span></span></code> </pre><br><ol><li>  Karena komponen ini kita tidak perlu "@ halaman" dan "@ buka" karena tidak akan berpartisipasi dalam perutean dan akan menggunakan tata letak dari komponen induk </li><li>  Kode C # dimulai dengan simbol @.  Sebenarnya sama seperti di Razor </li><li><pre> <code class="cs hljs">@onclick=@(()=&gt;ClickRow(item.Id))</code> </pre>  Mengikat acara klik baris ke metode ClickRow dari ViewModel kami </li><li>  Tentukan parameter mana yang akan ditransfer dari komponen induk atau halaman ke kita menggunakan atribut [Parameter] </li><li>  Kami memanggil fungsi panggilan balik yang diterima dari komponen induk.  Jadi komponen induk mengetahui bahwa beberapa peristiwa telah terjadi pada anak.  Fungsi hanya dapat dilewatkan dengan dibungkus dalam EventCallback &lt;&gt; EventArgs yang diparameterisasi.  Daftar EventArgs yang memungkinkan dapat ditemukan di sini - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">docs.microsoft.com/ru-ru/aspnet/core/blazor/components?view=aspnetcore-3.0#event-handling</a> </li><li>  Karena daftar kemungkinan jenis EventArgs terbatas dan kami perlu memberikan properti ID tambahan ke pengendali event di sisi komponen induk, kami membuat kelas parameter kami sendiri yang diwarisi dari basis dan meneruskannya ke acara.  Jadi ya - dalam komponen induk, UIMouseEventArgs biasa akan terbang ke fungsi event handler dan itu perlu dikonversi ke tipe kami, misalnya menggunakan </li></ol><br>  Contoh penggunaan: <br><br><pre> <code class="cs hljs">&lt;TodoTableComponent Items=@Items OnClick=@Select Current=@(Selected?.Id??Guid.Empty)&gt;&lt;/TodoTableComponent&gt;</code> </pre> <br><h3>  Halaman Penghapusan Todo </h3><br>  ViewModel kami alias VM adalah DeleteTodoViewModel.cs: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DeleteTodoViewModel</span></span> : <span class="hljs-title"><span class="hljs-title">ComponentBase</span></span> { <span class="hljs-comment"><span class="hljs-comment">//1) [Parameter] private Guid Id { get; set; } //2) [Inject] public ICommandDispatcher CommandDispatcher { get; set; } [Inject] public IQueryDispatcher QueryDispatcher { get; set; } [Inject] public IUriHelper UriHelper { get; set; } //3) public TodoDto Todo { get; set; } protected override async Task OnInitAsync() { var todo = await QueryDispatcher.Execute&lt;GetById,TodoItem&gt;(new GetById(Id)); if (todo != null) Todo = new TodoDto { Id = todo.Id, IsComplite = todo.IsComplite, Name = todo.Name, Created = todo.Created }; await base.OnInitAsync(); } //4) public async Task Delete() { if (Todo != null) await CommandDispatcher.Execute(new Remove(Todo.Id)); Todo = null; //5) UriHelper.NavigateTo("/todo"); } }</span></span></code> </pre><br><ol><li>  Parameter rute "/ todo / delete / {id: guid}" diteruskan ke Guid di sini jika kita pergi, misalnya, ke localhost / todo / delete / ae434aae44 ... </li><li>  Suntikkan layanan dari wadah DI ke dalam VM kami. </li><li>  Hanya milik VM kami.  Kami menetapkan nilainya sendiri, seperti yang kami inginkan. </li><li>  Metode ini dipanggil secara otomatis ketika halaman diinisialisasi.  Di sini kita menetapkan nilai yang diperlukan untuk properti VM kami </li><li>  Metode VM kami.  Kami dapat mengikatnya, misalnya, ke acara mengklik tombol apa pun dari Tampilan kami </li><li>  Pergi ke halaman lain yang terletak di alamat "/ todo" yaitu  dia memiliki di awal baris "@ halaman" / todo "" <br>  Pandangan kami adalah DeleteTodo.razor: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//1) @page "/todo/delete/{id:guid}" @using BlazorApp.Client.TodoModule.Presentation @using BlazorApp.Client.Shared; //2) @layout MainLayout //3) @inherits DeleteTodoViewModel &lt;h3&gt; Todo &lt;/h3&gt; @if (Todo != null) { &lt;div class="row"&gt; &lt;div class="col"&gt; &lt;input type="checkbox" checked=@Todo.IsComplite disabled="disabled" /&gt; &lt;br /&gt; &lt;label&gt;@Todo.Name&lt;/label&gt; &lt;br /&gt; //4) &lt;button class="btn btn-danger" onclick=@Delete&gt;&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; } else { &lt;p&gt;&lt;em&gt; Todo  &lt;/em&gt;&lt;/p&gt; }</span></span></code> </pre><br><ol><li>  Kami mengindikasikan bahwa negara ini akan tersedia di alamat {alamat root situs kami} + "/ todo / delete /" + {semacam Guid}.  Misalnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">localhost / todo / delete / ae434aae44</a> ... </li><li>  Tentukan bahwa halaman kami akan dirender di dalam MainLayout.razor </li><li>  Tentukan bahwa halaman kami akan menggunakan properti dan metode kelas DeleteTodoViewModel </li><li>  Kami mempersempit bahwa ketika Anda mengklik tombol ini, metode Delete () dari VM kami akan dipanggil </li></ol><br><h3>  Todo Home </h3><br>  TodoViewModel.cs: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TodoViewModel</span></span> : <span class="hljs-title"><span class="hljs-title">ComponentBase</span></span> { [Inject] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ICommandDispatcher CommandDispatcher { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } [Inject] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IQueryDispatcher QueryDispatcher { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//1) [Required(ErrorMessage = "  Todo")] public string NewTodo { get; set; } public List&lt;TodoDto&gt; Items { get; set; } public TodoDto Selected { get; set; } protected override async Task OnInitAsync() { await LoadTodos(); await base.OnInitAsync(); } public async Task Create() { await CommandDispatcher.Execute(new Add(NewTodo)); await LoadTodos(); NewTodo = string.Empty; } //2) public async Task Select(UIMouseEventArgs args) { //3) var e = args as TodoTableComponent.ClickTodoEventArgs; if (e == null) return; var todo = await QueryDispatcher.Execute&lt;GetById, TodoItem&gt;(new GetById(e.Id)); if (todo == null) { Selected = null; return; } Selected = new TodoDto { Id = todo.Id, IsComplite = todo.IsComplite, Name = todo.Name, Created = todo.Created }; } public void CanselEdit() { Selected = null; } public async Task Update() { await CommandDispatcher.Execute(new Update(Selected.Id, Selected.Name, Selected.IsComplite)); Selected = null; await LoadTodos(); } private async Task LoadTodos() { var todos = await QueryDispatcher.Execute&lt;GetAll, List&lt;TodoItem&gt;&gt;(new GetAll()); Items = todos.Select(t =&gt; new TodoDto { Id = t.Id, IsComplite = t.IsComplite, Name = t.Name, Created = t.Created }) .ToList(); } }</span></span></code> </pre><br><ol><li>  Atribut validasi standar dari System.ComponentModel.DataAnnotations didukung.  Secara khusus, di sini kami menunjukkan bahwa bidang ini diperlukan dan teks yang akan ditampilkan jika pengguna tidak menentukan nilai dalam input yang akan dikaitkan dengan bidang ini. </li><li>  Metode untuk menangani suatu peristiwa dengan parameter.  Metode ini akan menangani acara dari komponen anak. </li><li>  Kami melemparkan argumen ke tipe yang kami buat di komponen anak </li></ol><br>  Todo.razor: <br><br><pre> <code class="cs hljs">@layout MainLayout @page <span class="hljs-string"><span class="hljs-string">"/todo"</span></span> @inherits BlazorApp.Client.Presentation.TodoViewModel &lt;h3&gt;Todo&lt;/h3&gt; &lt;h4&gt;&lt;/h4&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"row"</span></span>&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"col"</span></span>&gt; @<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Items == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { &lt;p&gt;&lt;em&gt;...&lt;/em&gt;&lt;/p&gt; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Items.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { &lt;p&gt;&lt;em&gt;   .    .&lt;/em&gt;&lt;/p&gt; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//1) &lt;TodoTableComponent Items=@Items OnClick=@Select Current=@(Selected?.Id??Guid.Empty)&gt;&lt;/TodoTableComponent&gt; } &lt;/div&gt; &lt;/div&gt; &lt;br /&gt; &lt;h4&gt; Todo&lt;/h4&gt; &lt;div class="row"&gt; &lt;div class="col"&gt; @if (Items != null) { //2) &lt;EditForm name="addForm" Model=@this OnValidSubmit=@Create&gt; //3) &lt;DataAnnotationsValidator /&gt; //4) &lt;ValidationSummary /&gt; &lt;div class="form-group"&gt; //5) &lt;InputText @bind-Value=@NewTodo /&gt; //6) &lt;ValidationMessage For="@(() =&gt; this. NewTodo)" /&gt; //7) &lt;button type="submit" class="btn btn-primary"&gt;&lt;/button&gt; &lt;/div&gt; &lt;/EditForm&gt; } &lt;/div&gt; &lt;/div&gt; &lt;br /&gt; &lt;h4&gt; Todo&lt;/h4&gt; &lt;div class="row"&gt; &lt;div class="col"&gt; @if (Items != null) { @if (Selected != null) { &lt;EditForm name="editForm" Model=@Selected OnValidSubmit=@Update&gt; &lt;DataAnnotationsValidator /&gt; &lt;ValidationSummary /&gt; &lt;div class="form-group"&gt; &lt;InputCheckbox @bind-Value=@Selected.IsComplite /&gt; &lt;InputText @bind-Value=@Selected.Name /&gt; &lt;button type="submit" class="btn btn-primary"&gt;&lt;/button&gt; &lt;button type="reset" class="btn btn-warning" @onclick=@CanselEdit&gt;&lt;/button&gt; &lt;/div&gt; &lt;/EditForm&gt; } else { &lt;p&gt;&lt;em&gt;     &lt;/em&gt;&lt;/p&gt; } } &lt;/div&gt; &lt;/div&gt;</span></span></code> </pre><br><ol><li>  Kami memanggil komponen turunan dan mengirimkannya properti dan metode VM kami sebagai parameter. </li><li>  Komponen formulir bawaan dengan validasi data.  Kami menunjukkan di dalamnya bahwa sebagai model ia akan menggunakan VM kami dan saat mengirim data yang valid ia akan memanggil metode Create () </li><li>  Validasi akan dilakukan menggunakan atribut model seperti [Dibutuhkan kembali], dll. </li><li>  Di sini saya akan menampilkan kesalahan umum validasi </li><li>  Akan membuat input dengan validasi.  Daftar kemungkinan tag adalah InputText, InputTextArea, InputSelect, InputNumber, InputCheckbox, InputDate </li><li>  Kesalahan validasi untuk properti string publik NewTodo {get; set;} akan ditampilkan di sini </li><li>  Ketika Anda mengklik tombol ini, acara OnValidSubmit dari formulir kami akan dimunculkan </li></ol><br><h3>  File startup.cs </h3><br>  Di sini kami mendaftarkan layanan kami <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Startup</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigureServices</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IServiceCollection services</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// LocalStorage  SessionStorage       //    //     Nuget  Blazor.Extensions.Storage services.AddStorage(); services.AddSingleton&lt;ITodoRepository, TodoRepository&gt;(); services.AddSingleton&lt;ICommandDispatcher, CommandDispatcher&gt;(); services.AddSingleton&lt;IQueryDispatcher, QueryDispatcher&gt;(); services.AddSingleton&lt;IQueryHandler&lt;GetAll, List&lt;TodoItem&gt;&gt;, GetAllHandler&gt;(); services.AddSingleton&lt;IQueryHandler&lt;GetById, TodoItem&gt;, GetByIdHandler&gt;(); services.AddSingleton&lt;ICommandHandler&lt;Add&gt;, AddHandler&gt;(); services.AddSingleton&lt;ICommandHandler&lt;Remove&gt;, RemoveHandler&gt;(); services.AddSingleton&lt;ICommandHandler&lt;Update&gt;, UpdateHandler&gt;(); } public void Configure(IComponentsApplicationBuilder app) { //       App.razor //        &lt;app&gt;&lt;/app&gt; app.AddComponent&lt;App&gt;("app"); } }</span></span></code> </pre><br><h2>  Epilog </h2><br>  Artikel ini ditulis untuk membangkitkan selera dan mendorong studi lebih lanjut tentang Blazor.  Saya berharap bahwa saya telah mencapai tujuan saya.  Nah, untuk mempelajarinya lebih baik, saya sarankan membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">manual resmi dari Microsoft</a> . <br><br><h2>  Ucapan Terima Kasih </h2><br>  Terima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">AndreyNikolin</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">win32nipuh</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">SemenPV</a> untuk kesalahan pengejaan dan tata bahasa yang ditemukan dalam teks. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463197/">https://habr.com/ru/post/id463197/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463183/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 13. Konfigurasikan VLAN</a></li>
<li><a href="../id463185/index.html">Betapa kuat gempa bumi Bolivia menemukan gunung di kedalaman 660 kilometer di bawah tanah</a></li>
<li><a href="../id463189/index.html">Tentang anonimitas di Internet, kehidupan dan relativitasnya</a></li>
<li><a href="../id463193/index.html">Konversi gambar hitam dan putih ke grafik ASCII menggunakan dekomposisi matriks non-negatif</a></li>
<li><a href="../id463195/index.html">Apa yang terjadi dengan Internet Tele2</a></li>
<li><a href="../id463203/index.html">Beban waktu yang berat. Yandex melaporkan kesalahan umum dalam bekerja dengan waktu</a></li>
<li><a href="../id463205/index.html">Awalnya tidak dapat dioperasikan: cara bertahan dengan laptop di Windows 10 dan drive 32-gigabyte</a></li>
<li><a href="../id463207/index.html">Pengembangan chatbot (telegram + youtube)</a></li>
<li><a href="../id463213/index.html">Kesalahpahaman untuk pengembang C # pemula. Mencoba menjawab pertanyaan standar</a></li>
<li><a href="../id463215/index.html">Para insinyur dan arsitek sudah merancang permukiman bulan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>