<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçüöí üå©Ô∏è üë©üèæ‚Äçüíº Aplicaci√≥n reactiva sin Redux / NgRx üíå üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë© üí£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy analizaremos en detalle una aplicaci√≥n angular reactiva ( repositorio github ), escrita completamente sobre la estrategia OnPush . Otra aplicaci√≥n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aplicaci√≥n reactiva sin Redux / NgRx</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/true_engineering/blog/426819/"><img src="https://habrastorage.org/webt/d4/ck/od/d4ckodq4-ei9nntgvweinv65mdu.jpeg"><br><br>  Hoy analizaremos en detalle una aplicaci√≥n angular reactiva ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repositorio github</a> ), escrita completamente sobre la estrategia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OnPush</a> .  Otra aplicaci√≥n usa formas reactivas, lo cual es bastante t√≠pico para una aplicaci√≥n empresarial. <br><br>  No utilizaremos Flux, Redux, NgRx y, en cambio, aprovecharemos las capacidades ya disponibles en Typecript, Angular y RxJS.  El hecho es que estas herramientas no son una bala de plata y pueden agregar complejidad innecesaria incluso a aplicaciones simples.  Honestamente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">uno de los autores de Flux</a> , el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">autor de Redux</a> y el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">autor de NgRx</a> nos advirtieron sobre esto. <br><br>  Pero estas herramientas le dan a nuestras aplicaciones caracter√≠sticas muy agradables: <br><br><ul><li>  Flujo de datos predecible; </li><li>  Soporte OnPush por dise√±o; </li><li>  La inmutabilidad de los datos, la falta de efectos secundarios acumulados y otras cosas agradables. </li></ul><br>  Intentaremos obtener las mismas caracter√≠sticas, pero sin introducir una complejidad adicional. <br><br>  Como ver√° al final del art√≠culo, esta es una tarea bastante simple: si elimina los detalles de Angular y OnPush del art√≠culo, solo hay algunas ideas simples. <br><a name="habracut"></a><br>  El art√≠culo no ofrece un nuevo patr√≥n universal, sino que solo comparte con el lector varias ideas que, por toda su simplicidad, por alguna raz√≥n no se le ocurrieron de inmediato.  Adem√°s, la soluci√≥n desarrollada no contradice ni reemplaza Flux / Redux / NgRx.  Se pueden conectar, si esto es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">realmente necesario</a> . <br><br>  <i>Para una lectura c√≥moda del art√≠culo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se</a> requiere una comprensi√≥n de los t√©rminos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">componentes inteligentes, de presentaci√≥n y de contenedor</a> .</i> <br><br><h2>  Plan de acci√≥n </h2><br>  La l√≥gica de la aplicaci√≥n, as√≠ como la secuencia de presentaci√≥n del material, se pueden describir en la forma de los siguientes pasos: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Datos separados para lectura (GET) y escritura (PUT / POST)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estado de carga como flujo en componente contenedor</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Distribuir estado a una jerarqu√≠a de componentes OnPush</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Notificar a Angular sobre cambios en los componentes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Edici√≥n de datos encapsulados</a> </li></ol><br>  Para implementar OnPush, necesitamos analizar todas las formas de ejecutar la detecci√≥n de cambios en Angular.  Solo hay cuatro de estos m√©todos, y los consideraremos sucesivamente a lo largo del art√≠culo. <br><br>  Entonces vamos. <br><br><a name="backend"></a><h2>  Compartir datos para leer y escribir </h2><br>  Por lo general, las aplicaciones frontend y backend usan contratos escritos (de lo contrario, ¬øpor qu√© mecanografiar?) <br><br>  El proyecto de demostraci√≥n que estamos considerando no tiene un backend real, pero contiene un archivo de descripci√≥n preparado previamente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">swagger.json</a> .  En funci√≥n de ello, la utilidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sw2dts</a> genera contratos mecanografiados. <br><br>  Los contratos generados tienen dos propiedades importantes. <br><br>  En primer lugar, la lectura y la escritura se realizan utilizando diferentes contratos.  Usamos una peque√±a convenci√≥n y nos referimos a leer contratos con el sufijo "Estado", y escribir contratos con el sufijo "Modelo". <br><br>  Al separar los contratos de esta manera, estamos compartiendo el flujo de datos en la aplicaci√≥n.  De arriba a abajo, un estado de solo lectura se propaga a trav√©s de la jerarqu√≠a de componentes.  Para modificar los datos, se crea un modelo que se llena inicialmente con datos del estado, pero que existe como un objeto separado.  Al final de la edici√≥n, el modelo se env√≠a al backend como un comando. <br><br>  El segundo punto importante es que todos los campos de estado est√°n marcados con un modificador de solo lectura.  Por lo tanto, recibimos inmunidad a nivel mecanografiado.  Ahora no podemos cambiar accidentalmente el estado en el c√≥digo o enlazarlo usando [(ngModel)] - al compilar la aplicaci√≥n en modo AOT, obtendremos un error. <br><br><a name="container"></a><h2>  Estado de carga como flujo en componente contenedor </h2><br>  Para cargar e inicializar el estado, utilizaremos servicios angulares ordinarios.  Ser√°n responsables de los siguientes escenarios: <br><br><ul><li>  Un ejemplo cl√°sico es cargar a trav√©s de HttpClient usando el par√°metro id obtenido por el componente del enrutador. </li><li>  Inicializando un estado vac√≠o al crear una nueva entidad.  Por ejemplo, si los campos tienen valores predeterminados o para inicializar, debe solicitar datos adicionales del back-end. </li><li>  Reiniciar un estado ya cargado despu√©s de que el usuario realiza una operaci√≥n que cambia los datos al backend. </li><li>  Reinicio del estado mediante notificaci√≥n push, por ejemplo, al coeditar datos.  En este caso, el servicio fusiona el estado local y el estado obtenido del backend. </li></ul><br>  En la aplicaci√≥n de demostraci√≥n, consideraremos los dos primeros escenarios como los m√°s t√≠picos.  Adem√°s, estos escenarios son simples y permiten que el servicio se implemente como simples objetos sin estado y no se distraiga por la complejidad, que no es el tema de este art√≠culo en particular. <br><br>  Un ejemplo de un servicio se puede encontrar en el archivo <a href="">some-entity.service.ts</a> . <br><br>  Queda por obtener el servicio a trav√©s de DI en el componente contenedor y el estado de carga.  Esto generalmente se hace as√≠: <br><br><pre><code class="plaintext hljs">route.params .pipe( pluck('id'), filter((id: any) =&gt; { return !!id; }), switchMap((id: string) =&gt; { return myFormService.get(id); }) ) .subscribe(state =&gt; { this.state = state; });</code> </pre> <br>  Pero con este enfoque, surgen dos problemas: <br><br><ul><li>  Debe darse de baja manualmente de la suscripci√≥n creada, de lo contrario se producir√° una p√©rdida de memoria. </li><li>  Si cambia el componente a la estrategia OnPush, dejar√° de responder a la carga de datos. </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La tuber√≠a as√≠ncrona</a> viene al rescate.  √âl escucha directamente al Observable y se da de baja de √©l cuando es necesario.  Adem√°s, cuando se utiliza una tuber√≠a as√≠ncrona, Angular activa autom√°ticamente la detecci√≥n de cambios cada vez que el Observable publica un nuevo valor. <br><br>  Un ejemplo de uso de tuber√≠a as√≠ncrona se puede encontrar en la plantilla para <a href="">alg√∫n componente de entidad</a> . <br><br>  Y en el c√≥digo del componente, eliminamos la l√≥gica repetida en operadores RxJS personalizados, agregamos el script para crear un estado vac√≠o, fusionamos ambas fuentes de estado en una secuencia con el operador de fusi√≥n y creamos un formulario para editar, que discutiremos m√°s adelante: <br><br><pre> <code class="plaintext hljs">this.state$ = merge( route.params.pipe( switchIfNotEmpty("id", (requestId: string) =&gt; requestService.get(requestId) ) ), route.params.pipe( switchIfEmpty("id", () =&gt; requestService.getEmptyState()) ) ).pipe( tap(state =&gt; { this.form = new SomeEntityFormGroup(state); }) );</code> </pre><br>  Esto es todo lo que deb√≠a hacerse en el componente contenedor.  Y colocamos en la alcanc√≠a la primera forma de llamar a la detecci√≥n de cambios en el componente OnPush: tuber√≠a as√≠ncrona.  Nos ser√° √∫til m√°s de una vez. <br><br><a name="presentation"></a><h2>  Distribuir estado a una jerarqu√≠a de componentes OnPush </h2><br>  Cuando necesita mostrar un estado complejo, creamos una jerarqu√≠a de componentes peque√±os: as√≠ es como lidiamos con la complejidad. <br><br>  Como regla general, los componentes se dividen en una jerarqu√≠a similar a la jerarqu√≠a de datos, y cada componente recibe su propio dato a trav√©s de los par√°metros de entrada para mostrarlos en la plantilla. <br><br>  Como vamos a implementar todos los componentes como OnPush, divaguemos por un momento y discutamos qu√© es y c√≥mo funciona Angular con los componentes de OnPush.  Si ya conoce este material, no dude en desplazarse hasta el final de la secci√≥n. <br><br>  Durante la compilaci√≥n de la aplicaci√≥n, Angular genera un detector de cambio de clase especial para cada componente, que "recuerda" todos los enlaces utilizados en la plantilla del componente.  En tiempo de ejecuci√≥n, la clase generada comienza a verificar las expresiones almacenadas con cada bucle de detecci√≥n de cambio.  Si la comprobaci√≥n mostr√≥ que el resultado de cualquier expresi√≥n ha cambiado, Angular vuelve a dibujar el componente. <br><br>  De forma predeterminada, Angular no sabe nada acerca de nuestros componentes y no puede determinar a qu√© componentes afectar√°, por ejemplo, el setTimeout que se acaba de activar o una solicitud AJAX que ha finalizado.  Por lo tanto, se ve obligado a verificar toda la aplicaci√≥n literalmente para cada evento dentro de la aplicaci√≥n, incluso un simple desplazamiento de ventana desencadena repetidamente la detecci√≥n de cambios para toda la jerarqu√≠a de componentes de la aplicaci√≥n. <br><br>  Aqu√≠ radica una fuente potencial de problemas de rendimiento: cuanto m√°s complejas son las plantillas de componentes, m√°s dif√≠ciles son las comprobaciones del detector de cambios.  Y si hay muchos componentes y las comprobaciones se ejecutan con frecuencia, la detecci√≥n de cambios comienza a tomar un tiempo considerable. <br><br>  Que hacer <br><br>  Si el componente no depende de ning√∫n efecto global (por cierto, es mejor dise√±ar los componentes de esta manera), entonces su estado interno est√° determinado por: <br><br><ul><li>  Par√°metros de entrada ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@Input</a> ); </li><li>  Eventos que ocurrieron en el componente mismo ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@Output</a> ). </li></ul><br>  Pospondremos el segundo punto por ahora y supondremos que el estado de nuestro componente depende solo de los par√°metros de entrada. <br><br>  Si todos los par√°metros de entrada del componente son objetos inmutables, entonces podemos marcar el componente como OnPush.  Luego, antes de ejecutar la detecci√≥n de cambios, Angular verificar√° si los enlaces a los par√°metros de entrada del componente han cambiado desde la verificaci√≥n anterior.  Y, si no han cambiado, Angular omitir√° la detecci√≥n de cambios para el componente en s√≠ y todos sus componentes secundarios. <br><br>  Por lo tanto, si creamos nuestra aplicaci√≥n completa de acuerdo con la estrategia de OnPush, eliminaremos toda una clase de problemas de rendimiento desde el principio. <br><br>  Dado que el estado en nuestra aplicaci√≥n ya es inmutable, los objetos inmutables tambi√©n se transfieren a los par√°metros de entrada de los componentes secundarios.  Es decir, estamos listos para habilitar OnPush para componentes secundarios y responder√°n a los cambios de estado. <br>  Por ejemplo, estos son <a href="">componentes</a> <a href="">readonly-info.component</a> y <a href="">nested-items.component</a> <br><br>  Ahora veamos c√≥mo implementar el cambio en el estado de los componentes en el paradigma OnPush. <br><br><a name="output"></a><h2>  Hable con Angular sobre su condici√≥n. </h2><br>  Estado de presentaci√≥n: estos son los par√°metros responsables de la apariencia del componente: indicadores de carga, indicadores de visibilidad de elementos o accesibilidad para el usuario de una acci√≥n en particular, pegados desde tres campos a una l√≠nea del nombre del usuario, etc. <br><br>  Cada vez que cambia el estado de presentaci√≥n de un componente, debemos notificar a Angular para que pueda mostrar los cambios en la interfaz de usuario. <br><br>  Dependiendo de cu√°l sea la fuente del estado del componente, hay varias formas de notificar a Angular. <br><br><h4>  Estado de presentaci√≥n, calculado en base a par√°metros de entrada </h4><br>  Esta es la opci√≥n m√°s f√°cil.  Ponemos la l√≥gica de c√°lculo del estado de presentaci√≥n en el gancho ngOnChanges.  La detecci√≥n de cambios comenzar√° por s√≠ misma cambiando los par√°metros de entrada @.  En la demostraci√≥n, esto es <a href="">readonly-info.component</a> . <br><br><pre> <code class="plaintext hljs">export class ReadOnlyInfoComponent implements OnChanges { @Input() public state: Backend.SomeEntityState; public traits: ReadonlyInfoTraits; public ngOnChanges(changes: { state: SimpleChange }): void { this.traits = new ReadonlyInfoTraits(changes.state.currentValue); } }</code> </pre><br>  Todo es extremadamente simple, pero hay un punto al que se debe prestar atenci√≥n. <br><br>  Si el estado de presentaci√≥n del componente es complejo, y especialmente si algunos de sus campos se calculan sobre la base de otros, tambi√©n calculados por los par√°metros de entrada, coloque el estado del componente en una clase separada, h√°galo inmutable y vuelva a crear ngOnChanges cada vez que se inicia.  En un proyecto de demostraci√≥n, un ejemplo es la clase <a href="">ReadonlyInfoComponentTraits</a> .  Con este enfoque, se protege de la necesidad de sincronizar datos dependientes cuando cambian. <br><br>  Al mismo tiempo, vale la pena considerarlo: quiz√°s el componente tiene un estado dif√≠cil debido al hecho de que tiene demasiada l√≥gica.  Un ejemplo t√≠pico es un intento en un componente de ajustar representaciones para diferentes usuarios que tienen formas muy diferentes de trabajar con el sistema. <br><br><h4>  Eventos nativos componentes </h4><br>  Para la comunicaci√≥n entre los componentes de la aplicaci√≥n, utilizamos eventos de salida.  Esta es tambi√©n la tercera forma de ejecutar la detecci√≥n de cambios.  Angular asume razonablemente que si un componente genera un evento, entonces algo podr√≠a haber cambiado en su estado.  Por lo tanto, Angular escucha todos los eventos de salida de componentes y activa la detecci√≥n de cambios cuando ocurren. <br><br>  En el proyecto de demostraci√≥n, es completamente sint√©tico, pero un ejemplo es el componente <a href="">submit-button.component</a> , que <i>genera</i> un evento <i>formSaved</i> .  El componente contenedor se suscribe a este evento y muestra una alerta con una notificaci√≥n. <br><br>  Utilice los eventos de salida para su prop√≥sito previsto, es decir, cr√©elos para la comunicaci√≥n con los componentes principales y no para activar la detecci√≥n de cambios.  De lo contrario, es probable, despu√©s de meses y a√±os, no recordar por qu√© este evento es innecesario para nadie aqu√≠, y eliminarlo, rompiendo todo. <br><br><h4>  Cambios en componentes inteligentes </h4><br>  A veces, el estado de un componente est√° determinado por una l√≥gica compleja: llamar asincr√≥nicamente al servicio, conectarse a un socket web, verificaciones que se ejecutan a trav√©s de setInterval, pero nunca se sabe qu√© m√°s.  Dichos componentes se denominan componentes inteligentes. <br><br>  En general, mientras menos componentes inteligentes en la aplicaci√≥n no sean componentes de contenedor, m√°s f√°cil ser√° vivir.  Pero a veces no puedes prescindir de ellos. <br><br>  La forma m√°s simple de asociar el estado de un componente inteligente con la detecci√≥n de cambios es convertirlo en un Observable y usar la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tuber√≠a as√≠ncrona</a> ya discutida anteriormente.  Por ejemplo, si la fuente de los cambios es una llamada de servicio o un estado de formulario reactivo, entonces este es un Observable listo para usar.  Si el estado se forma a partir de algo m√°s complejo, puede usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fromPromise</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">websocket</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">timer</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">intervalo</a> desde la composici√≥n de RxJS.  O genere una secuencia usted mismo usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Asunto</a> . <br><br><h4>  Si ninguna de las opciones es adecuada </h4><br>  En los casos en que ninguno de los tres m√©todos ya estudiados es adecuado, todav√≠a tenemos una opci√≥n a prueba de balas: usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ChangeDetectorRef</a> directamente.  Estamos hablando de los m√©todos detectChanges y markForCheck de esta clase. <br><br>  La documentaci√≥n completa responde a todas las preguntas, por lo que no nos detendremos en su trabajo.  Pero tenga en cuenta que el uso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ChangeDetectorRef</a> debe limitarse a casos en los que entienda claramente lo que est√° haciendo, ya que esta sigue siendo la cocina angular interna. <br><br>  Durante todo el tiempo encontramos solo unos pocos casos en los que este m√©todo puede ser necesario: <br><br><ol><li>  Trabajo manual con detecci√≥n de cambios: se utiliza en la implementaci√≥n de componentes de bajo nivel y es solo el caso "usted comprende claramente lo que est√° haciendo". </li><li>  Relaciones complejas entre componentes, por ejemplo, cuando necesita crear un enlace a un componente en una plantilla y pasarlo como par√°metro a otro componente ubicado m√°s arriba en la jerarqu√≠a o incluso en otra rama de la jerarqu√≠a de componentes.  ¬øSuena complicado?  As√≠ es  Y es mejor simplemente refactorizar dicho c√≥digo, porque traer√° dolor no solo con la detecci√≥n de cambios. </li><li>  Los detalles del comportamiento de Angular en s√≠ mismo: por ejemplo, al implementar un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ControlValueAccessor</a> personalizado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">,</a> es posible que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Angular</a> cambie el valor de control de forma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">asincr√≥nica</a> y que los cambios no se apliquen al ciclo de detecci√≥n de cambio deseado. </li></ol><br>  Como ejemplos de uso en la aplicaci√≥n de demostraci√≥n, existe la clase base <a href="">OnPushControlValueAccessor</a> , que resuelve el problema descrito en el √∫ltimo p√°rrafo.  Tambi√©n en el proyecto hay un heredero de esta clase: <a href="">componente de bot√≥n de radio</a> personalizado. <br><br>  Ahora hemos discutido las cuatro formas de ejecutar la detecci√≥n de cambios y las opciones de implementaci√≥n de OnPush para los tres tipos de componentes: contenedor, inteligente, presentacional.  Pasamos al punto final: editar datos con formas reactivas. <br><br><a name="form"></a><h2>  Edici√≥n de datos encapsulados </h2><br>  Las formas reactivas tienen varias limitaciones, pero a√∫n as√≠ esta es una de las mejores cosas que sucedieron en el ecosistema angular. <br><br>  En primer lugar, encapsulan el buen funcionamiento con el estado y proporcionan todas las herramientas necesarias para responder a los cambios de manera reactiva. <br><br>  De hecho, la forma reactiva es una especie de mini-tienda que encapsula el trabajo con el estado: datos y estados deshabilitados / v√°lidos / pendientes. <br><br>  Nos queda por apoyar esta encapsulaci√≥n tanto como sea posible y evitar mezclar la l√≥gica de presentaci√≥n y la l√≥gica del formulario. <br><br>  En la aplicaci√≥n de demostraci√≥n, puede ver <a href="">clases de formulario individuales</a> que encapsulan los detalles de su trabajo: validaci√≥n, creaci√≥n de grupos de formularios secundarios, trabajo con el estado deshabilitado de los campos de entrada. <br><br>  Creamos el formulario ra√≠z en el componente contenedor en el momento en que se carga el estado, y con cada reinicio del estado, se recrea el formulario.  Esto no es un requisito previo, pero de esta manera podemos estar seguros de que no hay efectos acumulados en la l√≥gica de formulario que queda del estado cargado anterior. <br><br>  Dentro del formulario mismo, construimos los controles y "empujamos" los datos que provienen de ellos, convirti√©ndolos del contrato estatal al contrato modelo.  La estructura de los formularios, en la medida de lo posible, coincide con los contratos de los modelos.  Como resultado, la propiedad de valor del formulario nos da un modelo listo para enviar al backend. <br><br>  Si en el futuro el estado o la estructura del modelo cambian, obtendremos un error de compilaci√≥n de mecanografiado exactamente en el lugar donde necesitamos agregar / eliminar campos, lo cual es muy conveniente. <br><br>  Adem√°s, si los objetos de estado y modelo tienen una estructura absolutamente id√©ntica, la tipificaci√≥n estructural utilizada en el mecanografiado elimina la necesidad de construir un mapeo sin sentido de uno a otro. <br><br>  Total, la l√≥gica de formulario est√° aislada de la l√≥gica de presentaci√≥n en componentes y vive "por s√≠ misma", sin aumentar la complejidad del flujo de datos de nuestra aplicaci√≥n como un todo. <br><br>  Eso es casi todo.  Quedan casos l√≠mite cuando no podemos aislar la l√≥gica del formulario del resto de la aplicaci√≥n: <br><br><ol><li>  Cambios en la forma que conducen a un cambio en el estado de presentaci√≥n, por ejemplo, la visibilidad de un bloque de datos dependiendo del valor ingresado.  Lo implementamos en el componente suscribi√©ndonos para formar eventos.  Puede hacerlo a trav√©s de los rasgos inmutables discutidos anteriormente. </li><li>  Si necesita un validador as√≠ncrono que llame al backend, construimos AsyncValidatorFn en el componente y lo pasamos al constructor del formulario, no al servicio. </li></ol><br>  Por lo tanto, toda la l√≥gica "l√≠mite" permanece en el lugar m√°s destacado: en los componentes. <br><br><h2>  Conclusiones </h2><br>  Resumamos lo que obtuvimos y qu√© otros puntos hay para estudiar y desarrollar. <br><br>  En primer lugar, el desarrollo de la estrategia OnPush nos obliga a dise√±ar cuidadosamente el flujo de datos de la aplicaci√≥n, ya que ahora estamos dictando las reglas del juego para Angular, y no para √©l. <br><br>  Hay dos consecuencias para esta situaci√≥n. <br><br>  En primer lugar, tenemos una agradable sensaci√≥n de control sobre la aplicaci√≥n.  Ya no hay ninguna magia que "de alguna manera funcione".  Usted es claramente consciente de lo que est√° sucediendo en cualquier momento en su solicitud.  La intuici√≥n se est√° desarrollando gradualmente, lo que le permite comprender el motivo del error encontrado, incluso antes de abrir el c√≥digo. <br><br>  En segundo lugar, ahora tenemos que pasar m√°s tiempo dise√±ando la aplicaci√≥n, pero el resultado siempre ser√° la soluci√≥n m√°s "directa" y, por lo tanto, la m√°s simple.  Esto reduce notablemente la probabilidad de una situaci√≥n en la que, a medida que la aplicaci√≥n crece, se convierte en un monstruo de enorme complejidad, los desarrolladores han perdido el control de esta complejidad y el desarrollo ahora se parece m√°s a ritos m√≠sticos. <br><br>  La complejidad controlada y la ausencia de "magia" reducen la probabilidad de que surja una clase completa de problemas, por ejemplo, de actualizaciones de datos c√≠clicos o efectos secundarios acumulados.  En cambio, estamos lidiando con problemas que ya son notables durante el desarrollo, cuando la aplicaci√≥n simplemente no funciona.  Y, por lo tanto, debe hacer que la aplicaci√≥n funcione de manera simple y clara. <br><br>  Tambi√©n mencionamos buenos efectos sobre el rendimiento.  Ahora, usando herramientas muy simples, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">profiler.timeChangeDetection</a> , podemos verificar en cualquier momento que nuestra aplicaci√≥n todav√≠a est√° en buena forma. <br><br>  Adem√°s, ahora es un pecado no intentar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">deshabilitar NgZone</a> .  En primer lugar, le permitir√° no cargar toda la biblioteca al iniciar la aplicaci√≥n.  En segundo lugar, eliminar√° una buena cantidad de magia de su aplicaci√≥n. <br><br>  Ah√≠ es donde terminamos nuestra historia. <br><br>  Estaremos en contacto! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es426819/">https://habr.com/ru/post/es426819/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es426809/index.html">Zeev Surasky: El futuro del motor Zend y Zend Framework</a></li>
<li><a href="../es426811/index.html">Trabajos de parkour, danza y construcci√≥n de Boston Dynamics</a></li>
<li><a href="../es426813/index.html">? Skype se ha convertido en una imagen aburrida ... ¬øy un producto que le permite obtener acceso completo a su sistema? ¬øHay alguna esperanza?</a></li>
<li><a href="../es426815/index.html">¬øC√≥mo obtener una subvenci√≥n para el desarrollo de proyectos si eres un estudiante pobre? ¬øY vale la pena?</a></li>
<li><a href="../es426817/index.html">CommuniGate Pro Private Keys y API web</a></li>
<li><a href="../es426821/index.html">C√≥mo organizar CI / CD en un proyecto: desde configurar tareas hasta configurar la canalizaci√≥n de implementaci√≥n</a></li>
<li><a href="../es426825/index.html">Algunos consejos para aut√≥nomos</a></li>
<li><a href="../es426831/index.html">Conversaci√≥n desagradable, herpet√≥logo y completa sorpresa.</a></li>
<li><a href="../es426835/index.html">An√°lisis comparativo y detallado de complementos de almacenamiento en cach√© para WordPress</a></li>
<li><a href="../es426837/index.html">Transmisi√≥n de video en su sitio que funciona</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>