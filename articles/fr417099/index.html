<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👨‍👧‍👧 😕 👩🏻‍🎨 Comment ai-je écrit la bibliothèque C ++ 11 standard ou pourquoi boost est si effrayant. Chapitre 2 💼 💉 👩🏻‍🤝‍👨🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Résumé des parties précédentes 
 En raison de restrictions sur la capacité à utiliser les compilateurs C ++ 11 et du manque d'alternativité, boost a v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment ai-je écrit la bibliothèque C ++ 11 standard ou pourquoi boost est si effrayant. Chapitre 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417099/"><img src="https://habrastorage.org/webt/lr/zq/if/lrzqifvfeajppx2fdvqbxnwf4ce.png" alt="Oui - oui, avec cette devise, je me suis précipité dans la bataille." width="300" height="350" align="left"><h3>  Résumé des parties précédentes </h3><br>  En raison de restrictions sur la capacité à utiliser les compilateurs C ++ 11 et du manque d'alternativité, boost a voulu écrire sa propre implémentation de la bibliothèque C ++ 11 standard en plus de la bibliothèque C ++ 98 / C ++ 03 fournie avec le compilateur. <br><br>  En plus des fichiers d'en-tête standard <b>type_traits</b> , <b>thread</b> , <b>mutex</b> , <b>chrono</b> , <b>nullptr.h a</b> été ajouté <b>qui</b> implémente <i>std :: nullptr_t</i> et <b>core.h</b> où des macros liées aux <b>fonctionnalités dépendantes du</b> compilateur ont été ajoutées, ainsi que l'extension de la bibliothèque standard. <br><br>  Lien vers GitHub avec le résultat d'aujourd'hui pour les impatients et les non-lecteurs: <br><br><blockquote>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les engagements et les critiques constructives sont les bienvenus</a></b> </blockquote><a name="habracut"></a><br><h4>  Table des matières </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Présentation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chapitre 1. Viam supervadet vadens</a> <br>  <b>Chapitre 2. #ifndef __CPP11_SUPPORT__ #define __COMPILER_SPECIFIC_BUILT_IN_AND_MACRO_HELL__ #endif</b> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chapitre 3. Recherche de l'implémentation nullptr parfaite</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chapitre 4. Magie des modèles C ++</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.1 On commence petit</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.2 À propos du nombre d'erreurs miraculeuses que le journal compile pour nous</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.3 Pointeurs et tout-tout</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.4 Quoi d'autre est nécessaire pour la bibliothèque de modèles</a> <br>  Chapitre 5 <br>  ... <br><br><h3>  Chapitre 2. #ifndef __CPP11_SUPPORT__ #define __COMPILER_SPECIFIC_BUILT_IN_AND_MACRO_HELL__ #endif </h3><br>  Une fois que tout le code a été peigné un peu et divisé par des en-têtes «standard» en un <b>espace de noms stdex</b> séparé <b>,</b> j'ai continué à remplir <b>type_traits</b> , <b>nullptr.h</b> et le même <b>core.h</b> , qui contenait des macros pour déterminer la version de la norme utilisée par le compilateur et la prendre en charge <b>Nullptr</b> <b>natif</b> , <b>char16_t</b> , <b>char32_t</b> et <b>static_assert</b> . <br><br>  En théorie, tout est simple - selon la norme C ++ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">(clause 14.8), la</a> macro <b>__cplusplus</b> doit être définie par le compilateur et correspondre à la version de la norme prise en charge: <br><br><pre><code class="cpp hljs">C++ pre-C++<span class="hljs-number"><span class="hljs-number">98</span></span>: <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __cplusplus 1 C++98: #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __cplusplus 199711L C++98 + TR1: #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __cplusplus 199711L </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// ??? C++11: #define __cplusplus 201103L C++14: #define __cplusplus 201402L C++17: #define __cplusplus 201703L</span></span></span></span></code> </pre> <br>  en conséquence, le code pour déterminer la disponibilité du support est trivial: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (__cplusplus &gt;= 201103L) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  C++ 11   #define _STDEX_NATIVE_CPP11_SUPPORT //   11  (nullptr, static_assert) #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT //    char16_t, char32_t #endif</span></span></span></span></code> </pre><br><img src="https://habrastorage.org/webt/oq/qj/y8/oqqjy8dy_l8fyahlkfb3m-6uv3u.jpeg" alt="image" width="300" height="250" align="left">  En fait, tout n'est pas si simple et maintenant des béquilles intéressantes avec un râteau commencent. <br><br>  Premièrement, tous les compilateurs, ou plutôt aucun, n'implémentent pas la norme suivante de manière complète et immédiate.  Par exemple, dans Visual Studio 2013, <b>constexpr a été</b> absent <b>pendant</b> très longtemps, alors qu'il a été affirmé qu'il prend en charge C ++ 11 - avec la mise en garde que l'implémentation n'est pas terminée.  Autrement dit, <b>auto</b> - s'il vous plaît, <b>static_assert</b> - est tout aussi facile (même à partir de MS VS antérieurs), mais <b>constexpr</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ne l'</a> est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pas</a> .  Deuxièmement, tous les compilateurs (et c'est encore plus surprenant) n'exposent pas correctement cette définition et la mettent à jour en temps opportun.  Du coup, dans le même compilateur, Visual Studio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">n'a pas changé la version de la</a> <b>définition</b> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">__cplusplus à</a> partir des toutes premières versions du compilateur, bien que la prise en charge complète de C ++ 11 soit annoncée depuis longtemps (ce qui n'est également pas vrai, pour lequel il existe des rayons de mécontentement distincts - dès que la conversation porte sur la fonctionnalité spécifique du «nouveau»). "11 développeurs standard disent immédiatement qu'il n'y a pas de préprocesseur C99, il n'y a pas d'autres" fonctionnalités ").  Et la situation est aggravée par le fait que les compilateurs standard sont autorisés à définir cette définition sur une valeur différente des valeurs ci-dessus, s'ils ne sont pas entièrement conformes aux normes déclarées.  Il serait logique de supposer, par exemple, un tel développement de définitions pour une macro donnée (avec l'introduction de nouvelles fonctionnalités, augmentez le nombre caché derrière cette définition): <br><br><pre> <code class="cpp hljs">standart C++<span class="hljs-number"><span class="hljs-number">98</span></span>: <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __cplusplus 199711L </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// C++98 standart C++98 + TR1: #define __cplusplus 200311L // C++03 nonstandart C++11: #define __cplusplus 200411L // C++03 + auto and dectype nonstandart C++11: #define __cplusplus 200511L // C++03 + auto, dectype and constexpr(partly) ... standart C++11: #define __cplusplus 201103L // C++11</span></span></span></span></code> </pre><br>  Mais en même temps, aucun des principaux compilateurs populaires n'est "usé" avec cette fonctionnalité. <br><br>  À cause de tout cela (je n'ai pas peur de ce mot), maintenant pour chaque compilateur non standard, vous devez écrire vos propres vérifications spécifiques afin de savoir quelle norme C ++ et dans quelle mesure elle prend en charge.  La bonne nouvelle est que nous devons en savoir plus sur quelques fonctions du compilateur pour fonctionner correctement.  Tout d'abord, nous ajoutons maintenant la vérification de version pour Visual Studio via la macro <b>_MSC_VER</b> , unique à ce compilateur.  Étant donné que dans mon arsenal de compilateurs pris en charge, il existe également C ++ Borland Builder 6.0, dont les développeurs, à leur tour, étaient très désireux de maintenir la compatibilité avec Visual Studio (y compris ses «fonctionnalités» et bogues), alors il y a soudainement cette macro là aussi.  Pour les compilateurs compatibles avec Clang, il existe une macro non standard <b>__has_feature (nom_fonction</b> <b>)</b> , qui vous permet de savoir si le compilateur prend en charge telle ou telle fonctionnalité.  En conséquence, le code est gonflé à: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __has_feature #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __has_feature(x) 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Compatibility with non-clang compilers. #endif // Any compiler claiming C++11 supports, Visual C++ 2015 and Clang version supporting constexpr #if ((__cplusplus &gt;= 201103L) || (_MSC_VER &gt;= 1900) || (__has_feature(cxx_constexpr))) // C++ 11 implementation #define _STDEX_NATIVE_CPP11_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif</span></span></span></span></code> </pre><br>  Vous voulez atteindre plus de compilateurs?  Nous ajoutons des vérifications pour Codegear C ++ Builder, qui est l'héritier de Borland (dans ses pires manifestations, mais plus à ce sujet plus tard): <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __has_feature #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __has_feature(x) 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Compatibility with non-clang compilers. #endif // Any compiler claiming C++11 supports, Visual C++ 2015 and Clang version supporting constexpr #if ((__cplusplus &gt;= 201103L) || (_MSC_VER &gt;= 1900) || (__has_feature(cxx_constexpr))) // C++ 11 implementation #define _STDEX_NATIVE_CPP11_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #if !defined(_STDEX_NATIVE_CPP11_TYPES_SUPPORT) #if ((__cplusplus &gt; 199711L) || defined(__CODEGEARC__)) #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif</span></span></span></span></code> </pre><br>  Il convient également de noter que, puisque Visual Studio prend déjà en charge <b>nullptr à</b> partir de la version du compilateur <b>_MSC_VER 1600</b> , ainsi que les types <b>intégrés char16_t</b> et <b>char32_t</b> , nous devons gérer cela correctement.  Quelques contrôles supplémentaires ajoutés: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __has_feature #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __has_feature(x) 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Compatibility with non-clang compilers. #endif // Any compiler claiming C++11 supports, Visual C++ 2015 and Clang version supporting constexpr #if ((__cplusplus &gt;= 201103L) || (_MSC_VER &gt;= 1900) || (__has_feature(cxx_constexpr))) // C++ 11 implementation #define _STDEX_NATIVE_CPP11_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #if !defined(_STDEX_NATIVE_CPP11_TYPES_SUPPORT) #if ((__cplusplus &gt; 199711L) || defined(__CODEGEARC__)) #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif #if ((!defined(_MSC_VER) || _MSC_VER &lt; 1600) &amp;&amp; !defined(_STDEX_NATIVE_CPP11_SUPPORT)) #define _STDEX_IMPLEMENTS_NULLPTR_SUPPORT #else #define _STDEX_NATIVE_NULLPTR_SUPPORT #endif #if (_MSC_VER &gt;= 1600) #ifndef _STDEX_NATIVE_CPP11_TYPES_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif</span></span></span></span></code> </pre><br>  En même temps, nous vérifierons également la prise en charge de C ++ 98, car pour les compilateurs sans, il n'y aura pas de fichiers d'en-tête de la bibliothèque standard, et nous ne pouvons pas vérifier leur absence à l'aide du compilateur. <br><br><div class="spoiler">  <b class="spoiler_title">Option complète</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __has_feature #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __has_feature(x) 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Compatibility with non-clang compilers. #endif // Any compiler claiming C++11 supports, Visual C++ 2015 and Clang version supporting constexpr #if ((__cplusplus &gt;= 201103L) || (_MSC_VER &gt;= 1900) || (__has_feature(cxx_constexpr))) // C++ 11 implementation #define _STDEX_NATIVE_CPP11_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #if !defined(_STDEX_NATIVE_CPP11_TYPES_SUPPORT) #if ((__cplusplus &gt; 199711L) || defined(__CODEGEARC__)) #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif #if ((!defined(_MSC_VER) || _MSC_VER &lt; 1600) &amp;&amp; !defined(_STDEX_NATIVE_CPP11_SUPPORT)) #define _STDEX_IMPLEMENTS_NULLPTR_SUPPORT #else #define _STDEX_NATIVE_NULLPTR_SUPPORT #endif #if (_MSC_VER &gt;= 1600) #ifndef _STDEX_NATIVE_CPP11_TYPES_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif #if _MSC_VER // Visual C++ fallback #define _STDEX_NATIVE_MICROSOFT_COMPILER_EXTENSIONS_SUPPORT #define _STDEX_CDECL __cdecl #if (__cplusplus &gt;= 199711L) #define _STDEX_NATIVE_CPP_98_SUPPORT #endif #endif // C++ 98 check: #if ((__cplusplus &gt;= 199711L) &amp;&amp; ((defined(__INTEL_COMPILER) || defined(__clang__) || (defined(__GNUC__) &amp;&amp; ((__GNUC__ &gt; 4) || (__GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &gt;= 4)))))) #ifndef _STDEX_NATIVE_CPP_98_SUPPORT #define _STDEX_NATIVE_CPP_98_SUPPORT #endif #endif</span></span></span></span></code> </pre><br></div></div><br>  Et maintenant, de volumineuses configurations de boost commencent à apparaître dans ma mémoire dans lesquelles beaucoup de développeurs assidus ont écrit toutes ces macros dépendantes du compilateur et ont fait une carte de ce qui est pris en charge et de ce qui ne l'est pas par un compilateur spécifique d'une version spécifique, dont je me sens personnellement mal à l'aise, Je veux ne plus jamais le regarder ni le toucher.  Mais la bonne nouvelle est que vous pouvez vous arrêter là.  Au moins, cela me suffit pour prendre en charge les compilateurs les plus populaires, mais si vous trouvez une inexactitude ou si vous souhaitez ajouter un autre compilateur, je ne serai que trop heureux d'accepter la demande de tirage. <br><br>  Une grande réussite par rapport au boost, je pense qu'il était possible de conserver la propagation des macros dépendantes du compilateur dans le code, ce qui rend le code plus propre et plus facile à comprendre, et n'empile pas non plus des dizaines de fichiers de configuration pour chaque OS et pour chaque compilateur.  Nous parlerons un peu plus tard des inconvénients de cette approche. <br><br>  À ce stade, nous pouvons déjà commencer à connecter les fonctionnalités manquantes des 11 normes, et la première chose que nous introduisons est <b>static_assert</b> . <br><br><h3>  static_assert </h3><br>  Nous définissons la structure <i>StaticAssertion</i> , qui prendra une valeur booléenne comme paramètre de modèle - il y aura notre condition, si elle n'est pas remplie (l'expression est <b>fausse</b> ), une erreur se produira lors de la compilation d'un modèle non spécialisé.  Et une autre structure factice pour recevoir <b>sizeof (</b> <i>StaticAssertion</i> <b>)</b> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> stdex { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StaticAssertion</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StaticAssertion</span></span></span><span class="hljs-class">&lt;true&gt; {</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// StaticAssertion&lt;true&gt; template&lt;int i&gt; struct StaticAssertionTest { }; // StaticAssertionTest&lt;int&gt; } }</span></span></code> </pre><br>  et encore plus de magie magique <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _STDEX_NATIVE_CPP11_SUPPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STATIC_ASSERT(expression, message) static_assert((expression), #message) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// no C++11 support #define CONCATENATE(arg1, arg2) CONCATENATE1(arg1, arg2) #define CONCATENATE1(arg1, arg2) CONCATENATE2(arg1, arg2) #define CONCATENATE2(arg1, arg2) arg1##arg2 #define STATIC_ASSERT(expression, message)\ struct CONCATENATE(__static_assertion_at_line_, __LINE__)\ {\ stdex::detail::StaticAssertion&lt;static_cast&lt;bool&gt;((expression))&gt; CONCATENATE(CONCATENATE(CONCATENATE(STATIC_ASSERTION_FAILED_AT_LINE_, __LINE__), _WITH__), message);\ };\ typedef stdex::detail::StaticAssertionTest&lt;sizeof(CONCATENATE(__static_assertion_at_line_, __LINE__))&gt; CONCATENATE(__static_assertion_test_at_line_, __LINE__) #ifndef _STDEX_NATIVE_NULLPTR_SUPPORT #define static_assert(expression, message) STATIC_ASSERT(expression, ERROR_MESSAGE_STRING) #endif #endif</span></span></span></span></code> </pre><br>  utilisation: <br><br><pre> <code class="cpp hljs">STATIC_ASSERT(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*) == <span class="hljs-number"><span class="hljs-number">4</span></span>, non_x32_platform_is_unsupported);</code> </pre><br><blockquote>  Une différence importante entre mon implémentation et celle <a href="">standard</a> est qu'il n'y a pas de surcharge de ce mot-clé <u>sans en</u> informer l'utilisateur.  Cela est dû au fait qu'en C ++, il est impossible de définir plusieurs définitions avec un nombre d'arguments différent mais un seul nom, et une implémentation sans message est beaucoup moins utile que l'option sélectionnée.  Cette fonctionnalité conduit au fait qu'en gros <b>STATIC_ASSERT</b> dans mon implémentation est la version ajoutée déjà en C ++ 11. </blockquote>  Jetons un coup d'œil à ce qui s'est passé.  À la suite des vérifications des versions de <b>__cplusplus</b> et des macros de compilateur non standard, nous avons suffisamment d'informations sur la prise en charge C ++ 11 (et donc <b>static_assert</b> ), exprimées par la <b>définition de</b> _STDEX_NATIVE_CPP11_SUPPORT.  Par conséquent, si cette macro est définie, nous pouvons simplement utiliser le <b>static_assert</b> standard: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _STDEX_NATIVE_CPP11_SUPPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STATIC_ASSERT(expression, message) static_assert((expression), #message)</span></span></code> </pre><br><blockquote>  Veuillez noter que le deuxième paramètre de la macro <b>STATIC_ASSERT</b> n'est pas du tout <b>un littéral de chaîne,</b> et par conséquent, en utilisant l'opérateur de préprocesseur <b>#,</b> nous convertirons le paramètre de <i>message</i> en une chaîne pour la transmission au <b>static_assert</b> standard. </blockquote>  Si nous n'avons pas de support du compilateur, alors nous procédons à notre implémentation.  Pour commencer, nous déclarerons des macros auxiliaires pour «coller» les chaînes (l'opérateur de préprocesseur <b>## en</b> est juste responsable). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCATENATE(arg1, arg2) CONCATENATE1(arg1, arg2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCATENATE1(arg1, arg2) CONCATENATE2(arg1, arg2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCATENATE2(arg1, arg2) arg1##arg2</span></span></code> </pre><br><blockquote>  En particulier, je n'ai pas utilisé simplement <b>#define CONCATENATE (</b> <i>arg1</i> , <i>arg2</i> <b>)</b> <i>arg1 ## arg2</i> afin de pouvoir transmettre le résultat de la même macro <b>CONCATENATE</b> comme argument à <i>arg1</i> et <i>arg2</i> . </blockquote>  Ensuite, nous déclarons une structure avec le beau nom __static_assertion_at_line_ {numéro de ligne} (la macro <b>__LINE__</b> est également définie par la norme et doit être étendue au numéro de ligne sur lequel elle a été appelée), et à l'intérieur de cette structure, nous ajoutons un champ de notre type <i>StaticAssertion</i> avec le nom STATIC_ASSERTION_FAILED_AT_LINE_ {numéro de ligne} _WITH __ messages d'erreur de la macro appelante}. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STATIC_ASSERT(expression, message)\ struct CONCATENATE(__static_assertion_at_line_, __LINE__)\ {\ stdex::detail::StaticAssertion</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;static_cast&lt;bool&gt;((expression))&gt; CONCATENATE(CONCATENATE(CONCATENATE(STATIC_ASSERTION_FAILED_AT_LINE_, __LINE__), _WITH__), message);\ };\ typedef stdex::detail::StaticAssertionTest&lt;sizeof(CONCATENATE(__static_assertion_at_line_, __LINE__))&gt; CONCATENATE(__static_assertion_test_at_line_, __LINE__)</span></span></span></span></code> </pre><br>  <i>Avec le</i> paramètre de modèle dans <i>StaticAssertion,</i> nous passons une expression qui est vérifiée dans <b>STATIC_ASSERT</b> , la menant à <b>bool</b> .  Enfin, afin d'éviter de créer des variables locales et de vérifier la surcharge de l'utilisateur, un alias est déclaré pour le type <i>StaticAssertionTest &lt;sizeof ({nom de la structure déclarée ci-dessus})</i> avec le nom __static_assertion_test_at_line_ {numéro de ligne}. <br><br>  Toute la beauté de la dénomination est nécessaire uniquement pour indiquer clairement à partir d'une erreur de compilation qu'il s'agit d'un résultat d'assertion, et pas seulement d'une erreur, mais également pour afficher un message d'erreur qui a été défini pour cette assertion.  L'astuce <b>sizeof</b> est nécessaire pour forcer le compilateur à instancier la classe de modèle <i>StaticAssertion</i> , qui se trouve à l'intérieur de la structure qui vient d'être déclarée, et ainsi vérifier la condition passée à assert. <br><br><div class="spoiler">  <b class="spoiler_title">Résultats STATIC_ASSERT</b> <div class="spoiler_text"><blockquote>  GCC: <br>  30: 103: erreur: le champ 'STATIC_ASSERTION_FAILED_AT_LINE_36_WITH__non_x32_platform_is_unsupported' a un type incomplet 'stdex :: detail :: StaticAssertion &lt;false&gt;' <br>  25:36: note: dans la définition de la macro 'CONCATENATE2' <br>  23:36: note: en expansion de la macro 'CONCATENATE1' <br>  30:67: note: en expansion de la macro 'CONCATENER' <br>  24:36: note: en expansion de la macro 'CONCATENATE2' <br>  23:36: note: en expansion de la macro 'CONCATENATE1' <br>  30:79: note: en expansion de la macro 'CONCATENER' <br>  24:36: note: en expansion de la macro 'CONCATENATE2' <br>  23:36: note: en expansion de la macro 'CONCATENATE1' <br>  30:91: note: en expansion de la macro 'CONCATENER' <br>  36: 3: note: en expansion de la macro 'STATIC_ASSERT' <br><br>  Borland C ++ Builder: <br>  [Erreur C ++] stdex_test.cpp (36): E2450 Structure non définie 'stdex :: detail :: StaticAssertion &lt;0&gt;' <br>  [Erreur C ++] stdex_test.cpp (36): E2449 La taille de 'STATIC_ASSERTION_FAILED_AT_LINE_36_WITH__non_x32_platform_is_unsupported' est inconnue ou nulle <br>  [Erreur C ++] stdex_test.cpp (36): E2450 Structure non définie 'stdex :: detail :: StaticAssertion &lt;0&gt;' <br><br>  Visual Studio: <br>  Erreur C2079 </blockquote><br></div></div><br>  Le deuxième "truc" que je voulais avoir, tout en <u>manquant</u> dans la norme, c'est <b>countof</b> - compter le nombre d'éléments dans le tableau.  Les Sishers aiment beaucoup déclarer cette macro via sizeof (arr) / sizeof (arr [0]), mais nous irons plus loin. <br><br><h3>  countof </h3><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _STDEX_NATIVE_CPP11_SUPPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstddef&gt; namespace stdex { namespace detail { template &lt;class T, std::size_t N&gt; constexpr std::size_t _my_countof(T const (&amp;)[N]) noexcept { return N; } } // namespace detail } #define countof(arr) stdex::detail::_my_countof(arr) #else //no C++11 support #ifdef _STDEX_NATIVE_MICROSOFT_COMPILER_EXTENSIONS_SUPPORT // Visual C++ fallback #include &lt;stdlib.h&gt; #define countof(arr) _countof(arr) #elif defined(_STDEX_NATIVE_CPP_98_SUPPORT)// C++ 98 trick #include &lt;cstddef&gt; template &lt;typename T, std::size_t N&gt; char(&amp;COUNTOF_REQUIRES_ARRAY_ARGUMENT(T(&amp;)[N]))[N]; #define countof(x) sizeof(COUNTOF_REQUIRES_ARRAY_ARGUMENT(x)) #else #define countof(arr) sizeof(arr) / sizeof(arr[0]) #endif</span></span></span></span></code> </pre><br>  Pour les compilateurs <b>prenant en</b> charge <b>constexpr</b> , <b>nous</b> déclarerons une version constexpr de ce modèle (ce qui n'est absolument pas nécessaire, pour toutes les normes, l'implémentation via le modèle <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT suffit</i> ), pour le reste, nous introduisons la version via la fonction de modèle <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT</i> .  Visual Studio se distingue à nouveau par la présence de sa propre implémentation de <b>_countof</b> dans le fichier d'en-tête <b>stdlib.h</b> . <br><br>  La fonction <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT</i> semble intimidante et <i>comprendre</i> ce qu'elle fait est assez délicat.  Si vous regardez attentivement, vous pouvez comprendre qu'il prend un tableau d'éléments de type de modèle <i>T</i> et de taille <i>N</i> comme seul argument - ainsi, dans le cas du transfert d'autres types d'éléments (pas de tableaux), nous obtenons une erreur de compilation, ce qui est sans aucun doute agréable.  En y regardant de plus près, vous pouvez comprendre (avec difficulté) qu'il retourne un tableau d'éléments <b>char</b> de taille <i>N.</i>  La question est, pourquoi avons-nous besoin de tout cela?  C'est là que l'opérateur <b>sizeof</b> entre en <b>jeu</b> et sa capacité unique à travailler au moment de la compilation.  La taille de l'appel <b>(</b> <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT</i> <b>)</b> détermine la taille du tableau d'éléments <b>char</b> retourné par la fonction, et puisque la taille standard de <b>(char)</b> == 1, c'est le nombre de <i>N</i> éléments dans le tableau d'origine.  Élégant, beau et totalement gratuit. <br><br><h3>  pour toujours </h3><br>  Une autre petite macro d'aide que j'utilise partout où une boucle infinie est nécessaire est <b>pour toujours</b> .  Il est défini comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> !defined(forever) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> forever for(;;) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STRINGIZE_HELPER(x) #x #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STRINGIZE(x) STRINGIZE_HELPER(x) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WARNING(desc) message(__FILE__ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"("</span></span></span><span class="hljs-meta"> STRINGIZE(__LINE__) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">") : warning: "</span></span></span><span class="hljs-meta"> desc) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> WARNING(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stdex library - macro 'forever' was previously defined by user; ignoring stdex macro definition"</span></span></span><span class="hljs-meta">) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> STRINGIZE_HELPER #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> STRINGIZE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> WARNING #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  Exemple de syntaxe pour définir une boucle infinie explicite: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; forever { ++i; }</code> </pre><br>  Cette macro est utilisée uniquement pour définir explicitement une boucle infinie et n'est incluse dans la bibliothèque que pour des raisons «d'ajout de sucre syntaxique».  À l'avenir, je propose de le remplacer par éventuellement en définissant la macro du plug-in <b>FOREVER</b> .  Ce qui est remarquable dans l'extrait de code ci-dessus de la bibliothèque est la macro très <b>WARNING</b> qui génère un message d'avertissement dans tous les compilateurs si la macro <b>forever</b> a déjà été définie par l'utilisateur.  Il utilise la macro <b>__LINE__</b> standard <b>familière</b> et la <b>macro __FILE__</b> standard, qui est convertie en une chaîne avec le nom du fichier source actuel. <br><br><h3>  stdex_assert </h3><br>  Pour implémenter <b>assert</b> en runtime, la macro <b>stdex_assert est</b> introduite comme: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(assert) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> NDEBUG #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #define stdex_assert(condition, message) \ do { \ if (! (condition)) { \ std::cerr &lt;&lt; "Assertion `" #condition "` failed in " &lt;&lt; __FILE__ \ &lt;&lt; " line " &lt;&lt; __LINE__ &lt;&lt; ": " &lt;&lt; message &lt;&lt; std::endl; \ std::terminate(); \ } \ } while (false) #else #define stdex_assert(condition, message) ((void)0) #endif #endif</span></span></span></span></code> </pre><br>  Je ne dirai pas que je suis très fier de cette implémentation (elle sera modifiée à l'avenir), mais une technique intéressante a été utilisée ici sur laquelle je voudrais attirer l'attention.  Afin de masquer les vérifications de la portée du code d'application, la construction <b>do</b> <i>{}</i> <b>while (false)</b> est utilisée, qui sera exécutée, ce qui est évident une fois et en même temps n'introduira pas de code "service" dans le code d'application général.  Cette technique est très utile et est utilisée à plusieurs autres endroits de la bibliothèque. <br><br>  Sinon, l'implémentation est très similaire à l' <b>assertion</b> standard - avec une certaine macro <b>NDEBUG</b> , que les compilateurs définissent généralement dans les versions de version, assert ne fait rien, sinon elle interrompt l'exécution du programme avec la sortie du message dans le flux d'erreur standard si la condition assert n'est pas remplie. <br><br><h3>  sauf </h3><br>  Pour les fonctions qui ne <b>génèrent</b> pas d'exceptions, le mot clé <b>noexcept</b> a été introduit dans la nouvelle norme.  Il est également assez simple et indolore à implémenter via la macro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _STDEX_NATIVE_CPP11_SUPPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> stdex_noexcept noexcept #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> stdex_noexcept throw() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  cependant, il est nécessaire de comprendre que, selon la norme, <b>noexcept</b> peut prendre la valeur <b>bool</b> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">être</a> également <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utilisé</a> pour déterminer au moment de la compilation que l'expression qui lui est passée ne <b>lève</b> pas d'exception.  Cette fonctionnalité ne peut pas être implémentée sans le support du compilateur, et il n'y a donc qu'un <b>stdex_noexcept</b> «dépouillé» dans la bibliothèque. <br><br>  La fin du deuxième chapitre.  Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">troisième chapitre</a> parlera des subtilités de l'implémentation nullptr, pourquoi elle est différente pour différents compilateurs, ainsi que du développement de type_traits, et quels autres bugs dans les compilateurs j'ai rencontrés au cours de son développement. <br><br>  Merci de votre attention. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr417099/">https://habr.com/ru/post/fr417099/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr417087/index.html">HPE Digitize 2018: événement et diffusion en direct</a></li>
<li><a href="../fr417089/index.html">Ordinateur quantique: un photon pour tout gouverner</a></li>
<li><a href="../fr417091/index.html">Créez un shader d'eau de dessin animé pour le Web. 3e partie</a></li>
<li><a href="../fr417093/index.html">Interrupteurs tactiles avec Modbus: pourquoi sont-ils nécessaires et comment les appliquer dans un appartement intelligent</a></li>
<li><a href="../fr417097/index.html">Métaprogrammation JavaScript</a></li>
<li><a href="../fr417101/index.html">Définition de prêt - ce que nous avons oublié de dire</a></li>
<li><a href="../fr417103/index.html">Spark SQL. Un peu sur l'optimiseur de requêtes</a></li>
<li><a href="../fr417105/index.html">Impression sur une imprimante 3D. Expériences secrètes de 3Dtool</a></li>
<li><a href="../fr417107/index.html">Créateur du jeu en mode True: découvrez () la programmation gamedev, les problèmes VR et les simulations ML</a></li>
<li><a href="../fr417109/index.html">Richard Hamming: Chapitre 10. Théorie du codage - I</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>