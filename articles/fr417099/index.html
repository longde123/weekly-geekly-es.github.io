<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë®‚Äçüëß‚Äçüëß üòï üë©üèª‚Äçüé® Comment ai-je √©crit la biblioth√®que C ++ 11 standard ou pourquoi boost est si effrayant. Chapitre 2 üíº üíâ üë©üèª‚Äçü§ù‚Äçüë®üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="R√©sum√© des parties pr√©c√©dentes 
 En raison de restrictions sur la capacit√© √† utiliser les compilateurs C ++ 11 et du manque d'alternativit√©, boost a v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment ai-je √©crit la biblioth√®que C ++ 11 standard ou pourquoi boost est si effrayant. Chapitre 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417099/"><img src="https://habrastorage.org/webt/lr/zq/if/lrzqifvfeajppx2fdvqbxnwf4ce.png" alt="Oui - oui, avec cette devise, je me suis pr√©cipit√© dans la bataille." width="300" height="350" align="left"><h3>  R√©sum√© des parties pr√©c√©dentes </h3><br>  En raison de restrictions sur la capacit√© √† utiliser les compilateurs C ++ 11 et du manque d'alternativit√©, boost a voulu √©crire sa propre impl√©mentation de la biblioth√®que C ++ 11 standard en plus de la biblioth√®que C ++ 98 / C ++ 03 fournie avec le compilateur. <br><br>  En plus des fichiers d'en-t√™te standard <b>type_traits</b> , <b>thread</b> , <b>mutex</b> , <b>chrono</b> , <b>nullptr.h a</b> √©t√© ajout√© <b>qui</b> impl√©mente <i>std :: nullptr_t</i> et <b>core.h</b> o√π des macros li√©es aux <b>fonctionnalit√©s d√©pendantes du</b> compilateur ont √©t√© ajout√©es, ainsi que l'extension de la biblioth√®que standard. <br><br>  Lien vers GitHub avec le r√©sultat d'aujourd'hui pour les impatients et les non-lecteurs: <br><br><blockquote>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les engagements et les critiques constructives sont les bienvenus</a></b> </blockquote><a name="habracut"></a><br><h4>  Table des mati√®res </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pr√©sentation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chapitre 1. Viam supervadet vadens</a> <br>  <b>Chapitre 2. #ifndef __CPP11_SUPPORT__ #define __COMPILER_SPECIFIC_BUILT_IN_AND_MACRO_HELL__ #endif</b> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chapitre 3. Recherche de l'impl√©mentation nullptr parfaite</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chapitre 4. Magie des mod√®les C ++</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.1 On commence petit</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.2 √Ä propos du nombre d'erreurs miraculeuses que le journal compile pour nous</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.3 Pointeurs et tout-tout</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.4 Quoi d'autre est n√©cessaire pour la biblioth√®que de mod√®les</a> <br>  Chapitre 5 <br>  ... <br><br><h3>  Chapitre 2. #ifndef __CPP11_SUPPORT__ #define __COMPILER_SPECIFIC_BUILT_IN_AND_MACRO_HELL__ #endif </h3><br>  Une fois que tout le code a √©t√© peign√© un peu et divis√© par des en-t√™tes ¬´standard¬ª en un <b>espace de noms stdex</b> s√©par√© <b>,</b> j'ai continu√© √† remplir <b>type_traits</b> , <b>nullptr.h</b> et le m√™me <b>core.h</b> , qui contenait des macros pour d√©terminer la version de la norme utilis√©e par le compilateur et la prendre en charge <b>Nullptr</b> <b>natif</b> , <b>char16_t</b> , <b>char32_t</b> et <b>static_assert</b> . <br><br>  En th√©orie, tout est simple - selon la norme C ++ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">(clause 14.8), la</a> macro <b>__cplusplus</b> doit √™tre d√©finie par le compilateur et correspondre √† la version de la norme prise en charge: <br><br><pre><code class="cpp hljs">C++ pre-C++<span class="hljs-number"><span class="hljs-number">98</span></span>: <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __cplusplus 1 C++98: #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __cplusplus 199711L C++98 + TR1: #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __cplusplus 199711L </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// ??? C++11: #define __cplusplus 201103L C++14: #define __cplusplus 201402L C++17: #define __cplusplus 201703L</span></span></span></span></code> </pre> <br>  en cons√©quence, le code pour d√©terminer la disponibilit√© du support est trivial: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (__cplusplus &gt;= 201103L) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  C++ 11   #define _STDEX_NATIVE_CPP11_SUPPORT //   11  (nullptr, static_assert) #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT //    char16_t, char32_t #endif</span></span></span></span></code> </pre><br><img src="https://habrastorage.org/webt/oq/qj/y8/oqqjy8dy_l8fyahlkfb3m-6uv3u.jpeg" alt="image" width="300" height="250" align="left">  En fait, tout n'est pas si simple et maintenant des b√©quilles int√©ressantes avec un r√¢teau commencent. <br><br>  Premi√®rement, tous les compilateurs, ou plut√¥t aucun, n'impl√©mentent pas la norme suivante de mani√®re compl√®te et imm√©diate.  Par exemple, dans Visual Studio 2013, <b>constexpr a √©t√©</b> absent <b>pendant</b> tr√®s longtemps, alors qu'il a √©t√© affirm√© qu'il prend en charge C ++ 11 - avec la mise en garde que l'impl√©mentation n'est pas termin√©e.  Autrement dit, <b>auto</b> - s'il vous pla√Æt, <b>static_assert</b> - est tout aussi facile (m√™me √† partir de MS VS ant√©rieurs), mais <b>constexpr</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ne l'</a> est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pas</a> .  Deuxi√®mement, tous les compilateurs (et c'est encore plus surprenant) n'exposent pas correctement cette d√©finition et la mettent √† jour en temps opportun.  Du coup, dans le m√™me compilateur, Visual Studio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">n'a pas chang√© la version de la</a> <b>d√©finition</b> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">__cplusplus √†</a> partir des toutes premi√®res versions du compilateur, bien que la prise en charge compl√®te de C ++ 11 soit annonc√©e depuis longtemps (ce qui n'est √©galement pas vrai, pour lequel il existe des rayons de m√©contentement distincts - d√®s que la conversation porte sur la fonctionnalit√© sp√©cifique du ¬´nouveau¬ª). "11 d√©veloppeurs standard disent imm√©diatement qu'il n'y a pas de pr√©processeur C99, il n'y a pas d'autres" fonctionnalit√©s ").  Et la situation est aggrav√©e par le fait que les compilateurs standard sont autoris√©s √† d√©finir cette d√©finition sur une valeur diff√©rente des valeurs ci-dessus, s'ils ne sont pas enti√®rement conformes aux normes d√©clar√©es.  Il serait logique de supposer, par exemple, un tel d√©veloppement de d√©finitions pour une macro donn√©e (avec l'introduction de nouvelles fonctionnalit√©s, augmentez le nombre cach√© derri√®re cette d√©finition): <br><br><pre> <code class="cpp hljs">standart C++<span class="hljs-number"><span class="hljs-number">98</span></span>: <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __cplusplus 199711L </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// C++98 standart C++98 + TR1: #define __cplusplus 200311L // C++03 nonstandart C++11: #define __cplusplus 200411L // C++03 + auto and dectype nonstandart C++11: #define __cplusplus 200511L // C++03 + auto, dectype and constexpr(partly) ... standart C++11: #define __cplusplus 201103L // C++11</span></span></span></span></code> </pre><br>  Mais en m√™me temps, aucun des principaux compilateurs populaires n'est "us√©" avec cette fonctionnalit√©. <br><br>  √Ä cause de tout cela (je n'ai pas peur de ce mot), maintenant pour chaque compilateur non standard, vous devez √©crire vos propres v√©rifications sp√©cifiques afin de savoir quelle norme C ++ et dans quelle mesure elle prend en charge.  La bonne nouvelle est que nous devons en savoir plus sur quelques fonctions du compilateur pour fonctionner correctement.  Tout d'abord, nous ajoutons maintenant la v√©rification de version pour Visual Studio via la macro <b>_MSC_VER</b> , unique √† ce compilateur.  √âtant donn√© que dans mon arsenal de compilateurs pris en charge, il existe √©galement C ++ Borland Builder 6.0, dont les d√©veloppeurs, √† leur tour, √©taient tr√®s d√©sireux de maintenir la compatibilit√© avec Visual Studio (y compris ses ¬´fonctionnalit√©s¬ª et bogues), alors il y a soudainement cette macro l√† aussi.  Pour les compilateurs compatibles avec Clang, il existe une macro non standard <b>__has_feature (nom_fonction</b> <b>)</b> , qui vous permet de savoir si le compilateur prend en charge telle ou telle fonctionnalit√©.  En cons√©quence, le code est gonfl√© √†: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __has_feature #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __has_feature(x) 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Compatibility with non-clang compilers. #endif // Any compiler claiming C++11 supports, Visual C++ 2015 and Clang version supporting constexpr #if ((__cplusplus &gt;= 201103L) || (_MSC_VER &gt;= 1900) || (__has_feature(cxx_constexpr))) // C++ 11 implementation #define _STDEX_NATIVE_CPP11_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif</span></span></span></span></code> </pre><br>  Vous voulez atteindre plus de compilateurs?  Nous ajoutons des v√©rifications pour Codegear C ++ Builder, qui est l'h√©ritier de Borland (dans ses pires manifestations, mais plus √† ce sujet plus tard): <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __has_feature #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __has_feature(x) 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Compatibility with non-clang compilers. #endif // Any compiler claiming C++11 supports, Visual C++ 2015 and Clang version supporting constexpr #if ((__cplusplus &gt;= 201103L) || (_MSC_VER &gt;= 1900) || (__has_feature(cxx_constexpr))) // C++ 11 implementation #define _STDEX_NATIVE_CPP11_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #if !defined(_STDEX_NATIVE_CPP11_TYPES_SUPPORT) #if ((__cplusplus &gt; 199711L) || defined(__CODEGEARC__)) #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif</span></span></span></span></code> </pre><br>  Il convient √©galement de noter que, puisque Visual Studio prend d√©j√† en charge <b>nullptr √†</b> partir de la version du compilateur <b>_MSC_VER 1600</b> , ainsi que les types <b>int√©gr√©s char16_t</b> et <b>char32_t</b> , nous devons g√©rer cela correctement.  Quelques contr√¥les suppl√©mentaires ajout√©s: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __has_feature #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __has_feature(x) 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Compatibility with non-clang compilers. #endif // Any compiler claiming C++11 supports, Visual C++ 2015 and Clang version supporting constexpr #if ((__cplusplus &gt;= 201103L) || (_MSC_VER &gt;= 1900) || (__has_feature(cxx_constexpr))) // C++ 11 implementation #define _STDEX_NATIVE_CPP11_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #if !defined(_STDEX_NATIVE_CPP11_TYPES_SUPPORT) #if ((__cplusplus &gt; 199711L) || defined(__CODEGEARC__)) #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif #if ((!defined(_MSC_VER) || _MSC_VER &lt; 1600) &amp;&amp; !defined(_STDEX_NATIVE_CPP11_SUPPORT)) #define _STDEX_IMPLEMENTS_NULLPTR_SUPPORT #else #define _STDEX_NATIVE_NULLPTR_SUPPORT #endif #if (_MSC_VER &gt;= 1600) #ifndef _STDEX_NATIVE_CPP11_TYPES_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif</span></span></span></span></code> </pre><br>  En m√™me temps, nous v√©rifierons √©galement la prise en charge de C ++ 98, car pour les compilateurs sans, il n'y aura pas de fichiers d'en-t√™te de la biblioth√®que standard, et nous ne pouvons pas v√©rifier leur absence √† l'aide du compilateur. <br><br><div class="spoiler">  <b class="spoiler_title">Option compl√®te</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __has_feature #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __has_feature(x) 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Compatibility with non-clang compilers. #endif // Any compiler claiming C++11 supports, Visual C++ 2015 and Clang version supporting constexpr #if ((__cplusplus &gt;= 201103L) || (_MSC_VER &gt;= 1900) || (__has_feature(cxx_constexpr))) // C++ 11 implementation #define _STDEX_NATIVE_CPP11_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #if !defined(_STDEX_NATIVE_CPP11_TYPES_SUPPORT) #if ((__cplusplus &gt; 199711L) || defined(__CODEGEARC__)) #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif #if ((!defined(_MSC_VER) || _MSC_VER &lt; 1600) &amp;&amp; !defined(_STDEX_NATIVE_CPP11_SUPPORT)) #define _STDEX_IMPLEMENTS_NULLPTR_SUPPORT #else #define _STDEX_NATIVE_NULLPTR_SUPPORT #endif #if (_MSC_VER &gt;= 1600) #ifndef _STDEX_NATIVE_CPP11_TYPES_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif #if _MSC_VER // Visual C++ fallback #define _STDEX_NATIVE_MICROSOFT_COMPILER_EXTENSIONS_SUPPORT #define _STDEX_CDECL __cdecl #if (__cplusplus &gt;= 199711L) #define _STDEX_NATIVE_CPP_98_SUPPORT #endif #endif // C++ 98 check: #if ((__cplusplus &gt;= 199711L) &amp;&amp; ((defined(__INTEL_COMPILER) || defined(__clang__) || (defined(__GNUC__) &amp;&amp; ((__GNUC__ &gt; 4) || (__GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &gt;= 4)))))) #ifndef _STDEX_NATIVE_CPP_98_SUPPORT #define _STDEX_NATIVE_CPP_98_SUPPORT #endif #endif</span></span></span></span></code> </pre><br></div></div><br>  Et maintenant, de volumineuses configurations de boost commencent √† appara√Ætre dans ma m√©moire dans lesquelles beaucoup de d√©veloppeurs assidus ont √©crit toutes ces macros d√©pendantes du compilateur et ont fait une carte de ce qui est pris en charge et de ce qui ne l'est pas par un compilateur sp√©cifique d'une version sp√©cifique, dont je me sens personnellement mal √† l'aise, Je veux ne plus jamais le regarder ni le toucher.  Mais la bonne nouvelle est que vous pouvez vous arr√™ter l√†.  Au moins, cela me suffit pour prendre en charge les compilateurs les plus populaires, mais si vous trouvez une inexactitude ou si vous souhaitez ajouter un autre compilateur, je ne serai que trop heureux d'accepter la demande de tirage. <br><br>  Une grande r√©ussite par rapport au boost, je pense qu'il √©tait possible de conserver la propagation des macros d√©pendantes du compilateur dans le code, ce qui rend le code plus propre et plus facile √† comprendre, et n'empile pas non plus des dizaines de fichiers de configuration pour chaque OS et pour chaque compilateur.  Nous parlerons un peu plus tard des inconv√©nients de cette approche. <br><br>  √Ä ce stade, nous pouvons d√©j√† commencer √† connecter les fonctionnalit√©s manquantes des 11 normes, et la premi√®re chose que nous introduisons est <b>static_assert</b> . <br><br><h3>  static_assert </h3><br>  Nous d√©finissons la structure <i>StaticAssertion</i> , qui prendra une valeur bool√©enne comme param√®tre de mod√®le - il y aura notre condition, si elle n'est pas remplie (l'expression est <b>fausse</b> ), une erreur se produira lors de la compilation d'un mod√®le non sp√©cialis√©.  Et une autre structure factice pour recevoir <b>sizeof (</b> <i>StaticAssertion</i> <b>)</b> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> stdex { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StaticAssertion</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StaticAssertion</span></span></span><span class="hljs-class">&lt;true&gt; {</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// StaticAssertion&lt;true&gt; template&lt;int i&gt; struct StaticAssertionTest { }; // StaticAssertionTest&lt;int&gt; } }</span></span></code> </pre><br>  et encore plus de magie magique <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _STDEX_NATIVE_CPP11_SUPPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STATIC_ASSERT(expression, message) static_assert((expression), #message) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// no C++11 support #define CONCATENATE(arg1, arg2) CONCATENATE1(arg1, arg2) #define CONCATENATE1(arg1, arg2) CONCATENATE2(arg1, arg2) #define CONCATENATE2(arg1, arg2) arg1##arg2 #define STATIC_ASSERT(expression, message)\ struct CONCATENATE(__static_assertion_at_line_, __LINE__)\ {\ stdex::detail::StaticAssertion&lt;static_cast&lt;bool&gt;((expression))&gt; CONCATENATE(CONCATENATE(CONCATENATE(STATIC_ASSERTION_FAILED_AT_LINE_, __LINE__), _WITH__), message);\ };\ typedef stdex::detail::StaticAssertionTest&lt;sizeof(CONCATENATE(__static_assertion_at_line_, __LINE__))&gt; CONCATENATE(__static_assertion_test_at_line_, __LINE__) #ifndef _STDEX_NATIVE_NULLPTR_SUPPORT #define static_assert(expression, message) STATIC_ASSERT(expression, ERROR_MESSAGE_STRING) #endif #endif</span></span></span></span></code> </pre><br>  utilisation: <br><br><pre> <code class="cpp hljs">STATIC_ASSERT(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*) == <span class="hljs-number"><span class="hljs-number">4</span></span>, non_x32_platform_is_unsupported);</code> </pre><br><blockquote>  Une diff√©rence importante entre mon impl√©mentation et celle <a href="">standard</a> est qu'il n'y a pas de surcharge de ce mot-cl√© <u>sans en</u> informer l'utilisateur.  Cela est d√ª au fait qu'en C ++, il est impossible de d√©finir plusieurs d√©finitions avec un nombre d'arguments diff√©rent mais un seul nom, et une impl√©mentation sans message est beaucoup moins utile que l'option s√©lectionn√©e.  Cette fonctionnalit√© conduit au fait qu'en gros <b>STATIC_ASSERT</b> dans mon impl√©mentation est la version ajout√©e d√©j√† en C ++ 11. </blockquote>  Jetons un coup d'≈ìil √† ce qui s'est pass√©.  √Ä la suite des v√©rifications des versions de <b>__cplusplus</b> et des macros de compilateur non standard, nous avons suffisamment d'informations sur la prise en charge C ++ 11 (et donc <b>static_assert</b> ), exprim√©es par la <b>d√©finition de</b> _STDEX_NATIVE_CPP11_SUPPORT.  Par cons√©quent, si cette macro est d√©finie, nous pouvons simplement utiliser le <b>static_assert</b> standard: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _STDEX_NATIVE_CPP11_SUPPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STATIC_ASSERT(expression, message) static_assert((expression), #message)</span></span></code> </pre><br><blockquote>  Veuillez noter que le deuxi√®me param√®tre de la macro <b>STATIC_ASSERT</b> n'est pas du tout <b>un litt√©ral de cha√Æne,</b> et par cons√©quent, en utilisant l'op√©rateur de pr√©processeur <b>#,</b> nous convertirons le param√®tre de <i>message</i> en une cha√Æne pour la transmission au <b>static_assert</b> standard. </blockquote>  Si nous n'avons pas de support du compilateur, alors nous proc√©dons √† notre impl√©mentation.  Pour commencer, nous d√©clarerons des macros auxiliaires pour ¬´coller¬ª les cha√Ænes (l'op√©rateur de pr√©processeur <b>## en</b> est juste responsable). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCATENATE(arg1, arg2) CONCATENATE1(arg1, arg2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCATENATE1(arg1, arg2) CONCATENATE2(arg1, arg2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCATENATE2(arg1, arg2) arg1##arg2</span></span></code> </pre><br><blockquote>  En particulier, je n'ai pas utilis√© simplement <b>#define CONCATENATE (</b> <i>arg1</i> , <i>arg2</i> <b>)</b> <i>arg1 ## arg2</i> afin de pouvoir transmettre le r√©sultat de la m√™me macro <b>CONCATENATE</b> comme argument √† <i>arg1</i> et <i>arg2</i> . </blockquote>  Ensuite, nous d√©clarons une structure avec le beau nom __static_assertion_at_line_ {num√©ro de ligne} (la macro <b>__LINE__</b> est √©galement d√©finie par la norme et doit √™tre √©tendue au num√©ro de ligne sur lequel elle a √©t√© appel√©e), et √† l'int√©rieur de cette structure, nous ajoutons un champ de notre type <i>StaticAssertion</i> avec le nom STATIC_ASSERTION_FAILED_AT_LINE_ {num√©ro de ligne} _WITH __ messages d'erreur de la macro appelante}. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STATIC_ASSERT(expression, message)\ struct CONCATENATE(__static_assertion_at_line_, __LINE__)\ {\ stdex::detail::StaticAssertion</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;static_cast&lt;bool&gt;((expression))&gt; CONCATENATE(CONCATENATE(CONCATENATE(STATIC_ASSERTION_FAILED_AT_LINE_, __LINE__), _WITH__), message);\ };\ typedef stdex::detail::StaticAssertionTest&lt;sizeof(CONCATENATE(__static_assertion_at_line_, __LINE__))&gt; CONCATENATE(__static_assertion_test_at_line_, __LINE__)</span></span></span></span></code> </pre><br>  <i>Avec le</i> param√®tre de mod√®le dans <i>StaticAssertion,</i> nous passons une expression qui est v√©rifi√©e dans <b>STATIC_ASSERT</b> , la menant √† <b>bool</b> .  Enfin, afin d'√©viter de cr√©er des variables locales et de v√©rifier la surcharge de l'utilisateur, un alias est d√©clar√© pour le type <i>StaticAssertionTest &lt;sizeof ({nom de la structure d√©clar√©e ci-dessus})</i> avec le nom __static_assertion_test_at_line_ {num√©ro de ligne}. <br><br>  Toute la beaut√© de la d√©nomination est n√©cessaire uniquement pour indiquer clairement √† partir d'une erreur de compilation qu'il s'agit d'un r√©sultat d'assertion, et pas seulement d'une erreur, mais √©galement pour afficher un message d'erreur qui a √©t√© d√©fini pour cette assertion.  L'astuce <b>sizeof</b> est n√©cessaire pour forcer le compilateur √† instancier la classe de mod√®le <i>StaticAssertion</i> , qui se trouve √† l'int√©rieur de la structure qui vient d'√™tre d√©clar√©e, et ainsi v√©rifier la condition pass√©e √† assert. <br><br><div class="spoiler">  <b class="spoiler_title">R√©sultats STATIC_ASSERT</b> <div class="spoiler_text"><blockquote>  GCC: <br>  30: 103: erreur: le champ 'STATIC_ASSERTION_FAILED_AT_LINE_36_WITH__non_x32_platform_is_unsupported' a un type incomplet 'stdex :: detail :: StaticAssertion &lt;false&gt;' <br>  25:36: note: dans la d√©finition de la macro 'CONCATENATE2' <br>  23:36: note: en expansion de la macro 'CONCATENATE1' <br>  30:67: note: en expansion de la macro 'CONCATENER' <br>  24:36: note: en expansion de la macro 'CONCATENATE2' <br>  23:36: note: en expansion de la macro 'CONCATENATE1' <br>  30:79: note: en expansion de la macro 'CONCATENER' <br>  24:36: note: en expansion de la macro 'CONCATENATE2' <br>  23:36: note: en expansion de la macro 'CONCATENATE1' <br>  30:91: note: en expansion de la macro 'CONCATENER' <br>  36: 3: note: en expansion de la macro 'STATIC_ASSERT' <br><br>  Borland C ++ Builder: <br>  [Erreur C ++] stdex_test.cpp (36): E2450 Structure non d√©finie 'stdex :: detail :: StaticAssertion &lt;0&gt;' <br>  [Erreur C ++] stdex_test.cpp (36): E2449 La taille de 'STATIC_ASSERTION_FAILED_AT_LINE_36_WITH__non_x32_platform_is_unsupported' est inconnue ou nulle <br>  [Erreur C ++] stdex_test.cpp (36): E2450 Structure non d√©finie 'stdex :: detail :: StaticAssertion &lt;0&gt;' <br><br>  Visual Studio: <br>  Erreur C2079 </blockquote><br></div></div><br>  Le deuxi√®me "truc" que je voulais avoir, tout en <u>manquant</u> dans la norme, c'est <b>countof</b> - compter le nombre d'√©l√©ments dans le tableau.  Les Sishers aiment beaucoup d√©clarer cette macro via sizeof (arr) / sizeof (arr [0]), mais nous irons plus loin. <br><br><h3>  countof </h3><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _STDEX_NATIVE_CPP11_SUPPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstddef&gt; namespace stdex { namespace detail { template &lt;class T, std::size_t N&gt; constexpr std::size_t _my_countof(T const (&amp;)[N]) noexcept { return N; } } // namespace detail } #define countof(arr) stdex::detail::_my_countof(arr) #else //no C++11 support #ifdef _STDEX_NATIVE_MICROSOFT_COMPILER_EXTENSIONS_SUPPORT // Visual C++ fallback #include &lt;stdlib.h&gt; #define countof(arr) _countof(arr) #elif defined(_STDEX_NATIVE_CPP_98_SUPPORT)// C++ 98 trick #include &lt;cstddef&gt; template &lt;typename T, std::size_t N&gt; char(&amp;COUNTOF_REQUIRES_ARRAY_ARGUMENT(T(&amp;)[N]))[N]; #define countof(x) sizeof(COUNTOF_REQUIRES_ARRAY_ARGUMENT(x)) #else #define countof(arr) sizeof(arr) / sizeof(arr[0]) #endif</span></span></span></span></code> </pre><br>  Pour les compilateurs <b>prenant en</b> charge <b>constexpr</b> , <b>nous</b> d√©clarerons une version constexpr de ce mod√®le (ce qui n'est absolument pas n√©cessaire, pour toutes les normes, l'impl√©mentation via le mod√®le <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT suffit</i> ), pour le reste, nous introduisons la version via la fonction de mod√®le <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT</i> .  Visual Studio se distingue √† nouveau par la pr√©sence de sa propre impl√©mentation de <b>_countof</b> dans le fichier d'en-t√™te <b>stdlib.h</b> . <br><br>  La fonction <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT</i> semble intimidante et <i>comprendre</i> ce qu'elle fait est assez d√©licat.  Si vous regardez attentivement, vous pouvez comprendre qu'il prend un tableau d'√©l√©ments de type de mod√®le <i>T</i> et de taille <i>N</i> comme seul argument - ainsi, dans le cas du transfert d'autres types d'√©l√©ments (pas de tableaux), nous obtenons une erreur de compilation, ce qui est sans aucun doute agr√©able.  En y regardant de plus pr√®s, vous pouvez comprendre (avec difficult√©) qu'il retourne un tableau d'√©l√©ments <b>char</b> de taille <i>N.</i>  La question est, pourquoi avons-nous besoin de tout cela?  C'est l√† que l'op√©rateur <b>sizeof</b> entre en <b>jeu</b> et sa capacit√© unique √† travailler au moment de la compilation.  La taille de l'appel <b>(</b> <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT</i> <b>)</b> d√©termine la taille du tableau d'√©l√©ments <b>char</b> retourn√© par la fonction, et puisque la taille standard de <b>(char)</b> == 1, c'est le nombre de <i>N</i> √©l√©ments dans le tableau d'origine.  √âl√©gant, beau et totalement gratuit. <br><br><h3>  pour toujours </h3><br>  Une autre petite macro d'aide que j'utilise partout o√π une boucle infinie est n√©cessaire est <b>pour toujours</b> .  Il est d√©fini comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> !defined(forever) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> forever for(;;) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STRINGIZE_HELPER(x) #x #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STRINGIZE(x) STRINGIZE_HELPER(x) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WARNING(desc) message(__FILE__ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"("</span></span></span><span class="hljs-meta"> STRINGIZE(__LINE__) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">") : warning: "</span></span></span><span class="hljs-meta"> desc) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> WARNING(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stdex library - macro 'forever' was previously defined by user; ignoring stdex macro definition"</span></span></span><span class="hljs-meta">) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> STRINGIZE_HELPER #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> STRINGIZE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> WARNING #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  Exemple de syntaxe pour d√©finir une boucle infinie explicite: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; forever { ++i; }</code> </pre><br>  Cette macro est utilis√©e uniquement pour d√©finir explicitement une boucle infinie et n'est incluse dans la biblioth√®que que pour des raisons ¬´d'ajout de sucre syntaxique¬ª.  √Ä l'avenir, je propose de le remplacer par √©ventuellement en d√©finissant la macro du plug-in <b>FOREVER</b> .  Ce qui est remarquable dans l'extrait de code ci-dessus de la biblioth√®que est la macro tr√®s <b>WARNING</b> qui g√©n√®re un message d'avertissement dans tous les compilateurs si la macro <b>forever</b> a d√©j√† √©t√© d√©finie par l'utilisateur.  Il utilise la macro <b>__LINE__</b> standard <b>famili√®re</b> et la <b>macro __FILE__</b> standard, qui est convertie en une cha√Æne avec le nom du fichier source actuel. <br><br><h3>  stdex_assert </h3><br>  Pour impl√©menter <b>assert</b> en runtime, la macro <b>stdex_assert est</b> introduite comme: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(assert) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> NDEBUG #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #define stdex_assert(condition, message) \ do { \ if (! (condition)) { \ std::cerr &lt;&lt; "Assertion `" #condition "` failed in " &lt;&lt; __FILE__ \ &lt;&lt; " line " &lt;&lt; __LINE__ &lt;&lt; ": " &lt;&lt; message &lt;&lt; std::endl; \ std::terminate(); \ } \ } while (false) #else #define stdex_assert(condition, message) ((void)0) #endif #endif</span></span></span></span></code> </pre><br>  Je ne dirai pas que je suis tr√®s fier de cette impl√©mentation (elle sera modifi√©e √† l'avenir), mais une technique int√©ressante a √©t√© utilis√©e ici sur laquelle je voudrais attirer l'attention.  Afin de masquer les v√©rifications de la port√©e du code d'application, la construction <b>do</b> <i>{}</i> <b>while (false)</b> est utilis√©e, qui sera ex√©cut√©e, ce qui est √©vident une fois et en m√™me temps n'introduira pas de code "service" dans le code d'application g√©n√©ral.  Cette technique est tr√®s utile et est utilis√©e √† plusieurs autres endroits de la biblioth√®que. <br><br>  Sinon, l'impl√©mentation est tr√®s similaire √† l' <b>assertion</b> standard - avec une certaine macro <b>NDEBUG</b> , que les compilateurs d√©finissent g√©n√©ralement dans les versions de version, assert ne fait rien, sinon elle interrompt l'ex√©cution du programme avec la sortie du message dans le flux d'erreur standard si la condition assert n'est pas remplie. <br><br><h3>  sauf </h3><br>  Pour les fonctions qui ne <b>g√©n√®rent</b> pas d'exceptions, le mot cl√© <b>noexcept</b> a √©t√© introduit dans la nouvelle norme.  Il est √©galement assez simple et indolore √† impl√©menter via la macro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _STDEX_NATIVE_CPP11_SUPPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> stdex_noexcept noexcept #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> stdex_noexcept throw() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  cependant, il est n√©cessaire de comprendre que, selon la norme, <b>noexcept</b> peut prendre la valeur <b>bool</b> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√™tre</a> √©galement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utilis√©</a> pour d√©terminer au moment de la compilation que l'expression qui lui est pass√©e ne <b>l√®ve</b> pas d'exception.  Cette fonctionnalit√© ne peut pas √™tre impl√©ment√©e sans le support du compilateur, et il n'y a donc qu'un <b>stdex_noexcept</b> ¬´d√©pouill√©¬ª dans la biblioth√®que. <br><br>  La fin du deuxi√®me chapitre.  Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">troisi√®me chapitre</a> parlera des subtilit√©s de l'impl√©mentation nullptr, pourquoi elle est diff√©rente pour diff√©rents compilateurs, ainsi que du d√©veloppement de type_traits, et quels autres bugs dans les compilateurs j'ai rencontr√©s au cours de son d√©veloppement. <br><br>  Merci de votre attention. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr417099/">https://habr.com/ru/post/fr417099/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr417087/index.html">HPE Digitize 2018: √©v√©nement et diffusion en direct</a></li>
<li><a href="../fr417089/index.html">Ordinateur quantique: un photon pour tout gouverner</a></li>
<li><a href="../fr417091/index.html">Cr√©ez un shader d'eau de dessin anim√© pour le Web. 3e partie</a></li>
<li><a href="../fr417093/index.html">Interrupteurs tactiles avec Modbus: pourquoi sont-ils n√©cessaires et comment les appliquer dans un appartement intelligent</a></li>
<li><a href="../fr417097/index.html">M√©taprogrammation JavaScript</a></li>
<li><a href="../fr417101/index.html">D√©finition de pr√™t - ce que nous avons oubli√© de dire</a></li>
<li><a href="../fr417103/index.html">Spark SQL. Un peu sur l'optimiseur de requ√™tes</a></li>
<li><a href="../fr417105/index.html">Impression sur une imprimante 3D. Exp√©riences secr√®tes de 3Dtool</a></li>
<li><a href="../fr417107/index.html">Cr√©ateur du jeu en mode True: d√©couvrez () la programmation gamedev, les probl√®mes VR et les simulations ML</a></li>
<li><a href="../fr417109/index.html">Richard Hamming: Chapitre 10. Th√©orie du codage - I</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>