<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö∞ üë®üèª‚Äçüè´ üôÖüèª Shaders de dissolution et exploration du monde üÜé üå§Ô∏è ü•ù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Partie 1: Dissolution Shader 
 Le shader de dissolution renvoie un bel effet, de plus, il est facile √† cr√©er et √† comprendre; Aujourd'hui, nous allons...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Shaders de dissolution et exploration du monde</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427401/"><h1>  Partie 1: Dissolution Shader </h1><br>  <strong>Le shader de dissolution</strong> renvoie un bel effet, de plus, il est facile √† cr√©er et √† comprendre;  Aujourd'hui, nous allons le faire dans <strong>Unity Shader Graph</strong> , et aussi √©crire sur <strong>HLSL</strong> . <br><br>  Voici un exemple de ce que nous allons cr√©er: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce4/46c/b99/ce446cb9949fdee3ed4b29d121aa1c89.gif"></div><br><br><h1>  Comment √ßa marche </h1><br>  Pour cr√©er un shader de <strong>dissolution</strong> , nous devrons <strong>travailler</strong> avec la valeur <strong>AlphaClipThreshold</strong> dans le shader ¬´Shader Graph¬ª ou utiliser la fonction HLSL appel√©e <strong>clip</strong> . <br><br>  Essentiellement, nous disons au shader de <strong>ne pas rendre le pixel en</strong> fonction de la <strong>texture</strong> et de la <strong>valeur</strong> transmises.  Nous devons savoir ce qui suit: les <strong>parties blanches se dissolvent plus rapidement</strong> . <br><a name="habracut"></a><br>  Nous utiliserons la texture suivante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cc/f52/1cd/1ccf521cdd1ba16cdaa45b33ae50fec4.png"></div><br>  Vous pouvez cr√©er les v√¥tres - des lignes droites, des triangles, mais n'importe quoi!  N'oubliez pas que les <strong>parties blanches se dissolvent plus rapidement</strong> . <br><br>  J'ai cr√©√© cette texture dans Photoshop en utilisant le filtre Clouds. <br><br>  M√™me si vous n'√™tes int√©ress√© que par le Shader Graph et que vous ne savez rien de HLSL, je recommande toujours de lire cette partie, car il est utile de comprendre comment fonctionne le Unity Shader Graph √† l'int√©rieur. <br><br><hr><br><h1>  Hlsl </h1><br>  En HLSL, nous utilisons la fonction <strong>clip (x)</strong> .  La fonction <strong>clip (x)</strong> supprime tous les pixels avec une valeur inf√©rieure √† <strong>z√©ro</strong> .  Par cons√©quent, si nous appelons <strong>clip (-1)</strong> , nous serons s√ªrs que le shader ne rendra jamais ce pixel.  Vous pouvez en savoir plus sur le <strong>clip</strong> dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Microsoft Docs</a> . <br><br><h4>  Les propri√©t√©s </h4><br>  Le shader a besoin de deux propri√©t√©s, <strong>Dissoudre la texture</strong> et la <strong>quantit√©</strong> (qui indiqueront le processus d'ex√©cution global).  Comme pour les autres propri√©t√©s et variables, vous pouvez les appeler comme bon vous semble. <br><br><pre><code class="hljs powershell">Properties { //Your other properties //[<span class="hljs-type"><span class="hljs-type">...</span></span>] //Dissolve shader properties _DissolveTexture(<span class="hljs-string"><span class="hljs-string">"Dissolve Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _Amount(<span class="hljs-string"><span class="hljs-string">"Amount"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br>  Assurez-vous d'ajouter ce qui suit apr√®s CGPROGRAM SubShader (en d'autres termes, d√©clarez les variables): <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sampler2D</span></span> _DissolveTexture; <span class="hljs-attribute"><span class="hljs-attribute">half</span></span> _Amount;</code> </pre> <br>  N'oubliez pas non plus.  que leurs noms doivent correspondre aux noms de la section Propri√©t√©s. <br><br><h4>  Fonction </h4><br>  Nous commen√ßons la fonction <strong>Surface</strong> ou <strong>Fragment</strong> en √©chantillonnant la <strong>texture de la dissolution</strong> et en obtenant la <strong>valeur du rouge</strong> .  PS Notre texture est stock√©e en <strong>niveaux</strong> de <strong>gris</strong> , c'est-√†-dire que ses valeurs de <strong>R</strong> , <strong>G</strong> et <strong>B</strong> sont √©gales, et vous pouvez <strong>choisir n'importe laquelle d'entre elles</strong> .  Par exemple, le <strong>blanc</strong> est <strong>(1,1,1)</strong> , le <strong>noir</strong> est <strong>(0,0,0)</strong> . <br><br>  Dans mon exemple, j'utilise un shader de surface: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> surf (Input IN, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { half dissolve_value = tex2D(_DissolveTexture, IN.uv_MainTex).r; <span class="hljs-comment"><span class="hljs-comment">//Get how much we have to dissolve based on our dissolve texture clip(dissolve_value - _Amount); //Dissolve! //Your shader body, you can set the Albedo etc. //[...] }</span></span></code> </pre> <br>  <strong>Et c'est tout!</strong>  Nous pouvons appliquer ce processus √† n'importe quel shader existant et le transformer en <strong>shader de dissolution</strong> ! <br><br>  Voici le Surface Shader standard du moteur Unity, transform√© en <strong>shader de dissolution</strong> <strong>bilat√©ral</strong> <strong>:</strong> <br><br><pre> <code class="hljs pgsql">Shader "Custom/DissolveSurface" { Properties { _Color ("Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Albedo (RGB)", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Glossiness ("Smoothness", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> _Metallic ("Metallic", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> //Dissolve properties _DissolveTexture("Dissolve Texutre", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Amount("Amount", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span> } SubShader { Tags { "RenderType"="Opaque" } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> Cull <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> //Fast way <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> turn your material <span class="hljs-type"><span class="hljs-type">double</span></span>-sided CGPROGRAM #pragma surface surf Standard fullforwardshadows #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; }; half _Glossiness; half _Metallic; fixed4 _Color; //Dissolve properties sampler2D _DissolveTexture; half _Amount; <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { //Dissolve <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> half dissolve_value = tex2D(_DissolveTexture, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex).r; clip(dissolve_value - _Amount); //Basic shader <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> fixed4 c = tex2D (_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * _Color; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</code> </pre> <br><hr><br><h1>  Graphique de shader </h1><br>  Si nous devons cr√©er cet effet √† l'aide du <strong>graphe</strong> Unity <strong>Shader</strong> , nous devons utiliser la valeur <strong>AlphaClipThreshold</strong> (qui fonctionne diff√©remment du <strong>clip (x)</strong> de HLSL).  Dans cet exemple, j'ai cr√©√© un shader PBR. <br><br>  La fonction <strong>AlphaClipThreshold</strong> demande au shader de supprimer tous les pixels dont la valeur est inf√©rieure √† sa valeur <strong>Alpha</strong> .  Par exemple, s'il est de <strong>0,3f</strong> et que notre valeur alpha est de <strong>0,2f</strong> , le shader <strong>ne rendra pas</strong> ce pixel.  La fonction <strong>AlphaClipThreshold</strong> se trouve dans la <strong>documentation Unity</strong> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PBR Master Node</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Unlit Master Node</a> . <br><br>  Voici notre shader fini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b9/368/ede/1b9368ede92dad1544f3ca702a2924ad.png"></div><br>  Nous √©chantillonnons la <strong>texture de dissolution</strong> et obtenons <strong>la valeur rouge</strong> , puis l'ajoutons √† la valeur <strong>Montant</strong> (qui est une propri√©t√© que j'ai ajout√©e pour indiquer le processus d'ex√©cution global, une valeur de 1 signifie une dissolution compl√®te) et la connectons √† <strong>AlphaClipThreshold</strong> .  <strong>C'est fait!</strong> <br><br>  Si vous souhaitez l'appliquer √† n'importe quel shader existant, <strong>copiez</strong> simplement <strong>les</strong> <strong>connexions de noeud</strong> vers <strong>AlphaClipThreshold</strong> (ne manquez pas les propri√©t√©s n√©cessaires!).  Vous pouvez √©galement le rendre <strong>recto-verso</strong> et obtenir un r√©sultat encore plus beau! <br><br><hr><br><h1>  Shader de dissolution de contour </h1><br>  Et si vous essayez d'y ajouter des <strong>contours</strong> ?  Faisons-le! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c59/0db/e64/c590dbe64e954bdc6c7ce1154726e80b.gif"></div><br>  Nous ne pouvons pas travailler avec des pixels d√©j√† dissous, car apr√®s les avoir d√©pos√©s <em>, ils disparaissent √† jamais</em> .  Au lieu de cela, nous pouvons travailler avec des valeurs ¬´presque dissoutes¬ª! <br><br>  En <strong>HLSL,</strong> c'est tr√®s simple, il suffit d'ajouter quelques lignes de code apr√®s avoir calcul√© le <strong>clip</strong> : <br><br><pre> <code class="hljs powershell">void surf (Input <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, inout SurfaceOutputStandard o) { //[<span class="hljs-type"><span class="hljs-type">...</span></span>] //After our clip calculations <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dissolve_value - _Amount &lt; .<span class="hljs-number"><span class="hljs-number">05</span></span>f) //outline width = .<span class="hljs-number"><span class="hljs-number">05</span></span>f o.Emission = fixed3(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); //emits white color //Your shader body, you can set the Albedo etc. //[<span class="hljs-type"><span class="hljs-type">...</span></span>] }</code> </pre> <br>  <strong>C'est fait!</strong> <br><br>  Lorsque vous travaillez avec <strong>Shader Graph, la</strong> logique est l√©g√®rement diff√©rente.  Voici le shader fini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e26/288/1ef/e262881ef6ad042856b345ba2d9f2765.png"></div><br><hr><br>  Nous pouvons cr√©er <strong>des effets</strong> tr√®s <strong>cool</strong> avec un simple <strong>shader de dissolution</strong> ;  Vous pouvez exp√©rimenter <strong>diff√©rentes textures</strong> et <strong>valeurs</strong> , ainsi que trouver autre chose! <br><br><h1>  Partie 2: Shader d'exploration du monde </h1><br>  Un shader d' <strong>exploration du monde</strong> (ou un ¬´ <strong>shader de dissolution du monde</strong> ou <strong>dissolution globale</strong> ¬ª) nous permet de masquer √©galement tous les objets de la sc√®ne en fonction de leur distance √† la position; maintenant, nous allons cr√©er un tel shader dans le <strong>graphique Unity Shader</strong> et l'√©crire en <strong>HLSL</strong> . <br><br>  Voici un exemple de ce que nous allons cr√©er: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/228/7bb/169/2287bb1692d36eae92224f36359648a3.gif"></div><br><hr><br><h2>  La distance comme param√®tre </h2><br>  Supposons que nous devions <strong>dissoudre un objet</strong> dans une sc√®ne s'il est <strong>trop √©loign√© du joueur</strong> .  Nous avons d√©j√† annonc√© le param√®tre <strong>_Amount</strong> , qui contr√¥le la disparition / dissolution de l'objet, nous devons donc le remplacer par la distance entre l'objet et le lecteur. <br><br>  Pour ce faire, nous devons prendre les positions de <strong>joueur</strong> et d' <strong>objet</strong> . <br><br><h3>  Position du joueur </h3><br>  <strong>Le processus</strong> sera similaire pour <strong>Unity Shader Graph</strong> et <strong>HLSL</strong> : nous devons transf√©rer la position du joueur dans le code. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Updates the _PlayerPos variable in all the shaders //Be aware that the parameter name has to match the one in your shaders or it wont' work Shader.SetGlobalVector("_PlayerPos", transform.position); //"transform" is the transform of the Player }</span></span></code> </pre> <br><hr><br><h2>  Graphique de shader </h2><br><h4>  Position et distance de l'objet </h4><br>  En utilisant le Shader Graph, nous pouvons utiliser les n≈ìuds Position et Distance. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation pour le n≈ìud Position</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation pour le n≈ìud Distance</a> . </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b1/cdb/078/7b1cdb078a844a10451317e40a14df7c.png"></div><br>  PS Pour que ce syst√®me fonctionne avec Sprite Renderers, vous devez ajouter la propri√©t√© _MainTex, l'√©chantillonner et la connecter √† albedo.  Vous pouvez lire mon pr√©c√©dent tutoriel sur les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">shaders diffus Sprites</a> (qui utilise le graphique des shaders). <br><br><hr><br><h2>  HLSL (surface) </h2><br><h4>  Position de l'objet </h4><br>  En HLSL, nous pouvons ajouter la variable <strong>worldPos</strong> √† notre structure <strong>Input</strong> pour obtenir les positions des sommets des objets. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ float2 uv_MainTex; float3 worldPos; <span class="hljs-comment"><span class="hljs-comment">//add this and Unity will set it automatically };</span></span></code> </pre> <br>  Sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la page de documentation Unity,</a> vous pouvez d√©couvrir quels autres param√®tres int√©gr√©s il est permis d'ajouter √† la structure d'entr√©e. <br><br><h4>  Appliquer la distance </h4><br>  Nous devons utiliser la distance entre les objets et le joueur comme quantit√© de dissolution.  Pour ce faire, vous pouvez utiliser la fonction de <strong>distance</strong> int√©gr√©e ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation Microsoft</a> ). <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> surf (Input IN, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { half dissolve_value = tex2D(_DissolveTexture, IN.uv_MainTex).x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = distance(_PlayerPos, IN.worldPos); clip(dissolve_value - dist/ <span class="hljs-number"><span class="hljs-number">6</span></span>f); <span class="hljs-comment"><span class="hljs-comment">//"6" is the maximum distance where your object will start showing //Set albedo, alpha, smoothness etc[...] }</span></span></code> </pre> <br><h3>  R√©sultat (3D) </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/868/f5c/2e8/868f5c2e803708138c71f84c95e3390c.gif"></div><br><h3>  R√©sultat (2D) </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/289/380/e2b/289380e2ba53cbe569621821affc7009.gif"></div><br>  Comme vous pouvez le voir, les objets se dissolvent ¬´localement¬ª, nous n'avons pas obtenu un effet uniforme, car nous obtenons la ¬´valeur de dissolution¬ª de la texture √©chantillonn√©e en utilisant les UV de chaque objet.  (En 2D, c'est moins visible). <br><br><hr><br><h3>  3D LocalUV Dissolve Shader sur HLSL </h3><br><pre> <code class="hljs pgsql">Shader "Custom/GlobalDissolveSurface" { Properties { _Color ("Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Albedo (RGB)", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Glossiness("Smoothness", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> _Metallic("Metallic", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> _DissolveTexture("Dissolve texture", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Radius("Distance", <span class="hljs-type"><span class="hljs-type">Float</span></span>) = <span class="hljs-number"><span class="hljs-number">1</span></span> //distance <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> we <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> reveal the objects } SubShader{ Tags { "RenderType" = "Opaque" } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> Cull <span class="hljs-keyword"><span class="hljs-keyword">off</span></span> //material <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> two sided CGPROGRAM #pragma surface surf Standard fullforwardshadows #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> sampler2D _MainTex; sampler2D _DissolveTexture; //texture <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> we <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> the dissolve <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float3 worldPos; //Built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> world position }; half _Glossiness; half _Metallic; fixed4 _Color; float3 _PlayerPos; //"Global Shader Variable", contains the Player Position <span class="hljs-type"><span class="hljs-type">float</span></span> _Radius; <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { half dissolve_value = tex2D(_DissolveTexture, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex).x; <span class="hljs-type"><span class="hljs-type">float</span></span> dist = distance(_PlayerPos, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos); clip(dissolve_value - dist/ _Radius); fixed4 c = tex2D (_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * _Color; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</code> </pre> <br><h3>  Sprites Diffuse - Local UV Dissolve Shader sur HLSL </h3><br><pre> <code class="hljs pgsql">Shader "Custom/GlobalDissolveSprites" { Properties { [PerRendererData] _MainTex("Sprite Texture", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Color("Tint", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) [MaterialToggle] PixelSnap("Pixel snap", <span class="hljs-type"><span class="hljs-type">Float</span></span>) = <span class="hljs-number"><span class="hljs-number">0</span></span> [HideInInspector] _RendererColor("RendererColor", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) [HideInInspector] _Flip("Flip", Vector) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) [PerRendererData] _AlphaTex("External Alpha", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} [PerRendererData] _EnableExternalAlpha("Enable External Alpha", <span class="hljs-type"><span class="hljs-type">Float</span></span>) = <span class="hljs-number"><span class="hljs-number">0</span></span> _DissolveTexture("Dissolve texture", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Radius("Distance", <span class="hljs-type"><span class="hljs-type">Float</span></span>) = <span class="hljs-number"><span class="hljs-number">1</span></span> //distance <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> we <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> reveal the objects } SubShader { Tags { "Queue" = "Transparent" "IgnoreProjector" = "True" "RenderType" = "Transparent" "PreviewType" = "Plane" "CanUseSpriteAtlas" = "True" } Cull <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> Lighting <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> ZWrite <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> Blend One OneMinusSrcAlpha CGPROGRAM #pragma surface surf Lambert vertex:vert nofog nolightmap nodynlightmap keepalpha noinstancing #pragma multi_compile _ PIXELSNAP_ON #pragma multi_compile _ ETC1_EXTERNAL_ALPHA #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "UnitySprites.cginc" struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; fixed4 color; float3 worldPos; //Built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> world position }; sampler2D _DissolveTexture; //texture <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> we <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> the dissolve <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> float3 _PlayerPos; //"Global Shader Variable", contains the Player Position <span class="hljs-type"><span class="hljs-type">float</span></span> _Radius; <span class="hljs-type"><span class="hljs-type">void</span></span> vert(<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> o) { v.vertex = UnityFlipSprite(v.vertex, _Flip); #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(PIXELSNAP_ON) v.vertex = UnityPixelSnap(v.vertex); #endif UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, o); o.color = v.color * _Color * _RendererColor; } <span class="hljs-type"><span class="hljs-type">void</span></span> surf(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutput o) { half dissolve_value = tex2D(_DissolveTexture, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex).x; <span class="hljs-type"><span class="hljs-type">float</span></span> dist = distance(_PlayerPos, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos); clip(dissolve_value - dist / _Radius); fixed4 c = SampleSpriteTexture(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.color; o.Albedo = c.rgb * ca; o.Alpha = ca; } ENDCG } Fallback "Transparent/VertexLit" }</code> </pre> <br>  PS Pour cr√©er le dernier shader, j'ai copi√© le shader Unity Sprites-Diffuse standard et ajout√© la partie ¬´fondu¬ª d√©crite plus haut dans cette partie de l'article.  Tous les shaders standard peuvent √™tre trouv√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><hr><br><h2>  Rendre l'effet homog√®ne </h2><br>  Pour rendre l'effet homog√®ne, nous pouvons utiliser les coordonn√©es globales (position dans le monde) comme coordonn√©es UV de la texture de dissolution.  Il est √©galement important de d√©finir <strong>Wrap = Repeat</strong> dans les param√®tres de texture de dissolution afin que nous puissions r√©p√©ter la texture sans le remarquer (assurez-vous que la texture est transparente et se r√©p√®te bien!) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7db/b9f/e0e/7dbb9fe0e582bf7a63b2dccfb43a9b9b.png"></div><br><h4>  HLSL (surface) </h4><br><pre> <code class="hljs delphi">half dissolve_value = tex2D(_DissolveTexture, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos / <span class="hljs-number"><span class="hljs-number">4</span></span>).x; <span class="hljs-comment"><span class="hljs-comment">//I modified the worldPos to reduce the texture size</span></span></code> </pre> <br><h4>  Graphique de shader </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/787/167/9c6/7871679c66cab1c842fe02c5ce523884.png"></div><br><h3>  R√©sultat (2D) </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/428/b34/425/428b344254f3e80ef68b63ba8754dfa2.gif"></div><br>  C'est le r√©sultat: on peut remarquer que la texture de la dissolution est d√©sormais uniforme pour le monde entier. <br><br>  Ce shader est d√©j√† <strong>id√©al pour les jeux 2D</strong> , mais pour <strong>les objets 3D</strong> il doit √™tre <strong>am√©lior√©</strong> . <br><br><h3>  Le probl√®me avec les objets 3D </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/231/1f4/09b/2311f409be1ca990c276895eb8e49695.png"></div><br>  Comme vous pouvez le voir, le shader ne fonctionne pas pour les faces "non verticales" et d√©forme consid√©rablement la texture.  C‚Äôest pourquoi il est  que les coordonn√©es UV ont besoin de la valeur float2, et si nous passons worldPos, alors il ne re√ßoit que X et Y. <br><br>  Si nous √©liminons ce probl√®me en appliquant des calculs pour afficher la texture sur toutes les faces, nous arriverons √† un nouveau probl√®me: lors de l'assombrissement, les objets se croiseront et ne resteront pas homog√®nes. <br><br>  Il sera difficile pour les d√©butants de comprendre la solution: il faut se d√©barrasser de la texture, g√©n√©rer du bruit tridimensionnel dans le monde et en tirer la ¬´valeur de dissolution¬ª.  Dans cet article je ne vous expliquerai pas la g√©n√©ration de bruit 3D, mais vous pouvez trouver un tas de fonctions pr√™tes √† l'emploi! <br><br>  Voici un exemple de shader de bruit: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/keijiro/NoiseShader</a> .  Vous pouvez √©galement apprendre √† g√©n√©rer du bruit ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://thebookofshaders.com/11/</a> et ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://catlikecoding.com/unity/tutorials/noise/</a> <br><br>  Je d√©finirai ma fonction de surface de cette fa√ßon (en supposant que vous avez d√©j√† √©crit la partie bruit): <br><br><pre> <code class="hljs powershell">void surf (Input <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, inout SurfaceOutputStandard o) { float dist = distance(_PlayerPos, IN.worldPos); //<span class="hljs-string"><span class="hljs-string">"abs"</span></span> because you have to make sure that the noise is between the range [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>] //you can remove <span class="hljs-string"><span class="hljs-string">"abs"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> your noise <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">between</span></span></span><span class="hljs-function"> [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">0</span></span></span><span class="hljs-function">,</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">1</span></span></span><span class="hljs-function">] //</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">also</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replace</span></span></span><span class="hljs-function"> "</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NOISE_FUNCTION_HERE</span></span></span><span class="hljs-function">" </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">with</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">your</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">3D</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">. </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">half</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dissolve_value</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">abs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NOISE_FUNCTION_HERE(IN.worldPos)</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dist &gt; _Radius)</span></span></span></span> { float clip_value = dissolve_value - ((dist - _Radius) / _Radius); clip(clip_value); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clip_value &lt; <span class="hljs-number"><span class="hljs-number">0.05</span></span>f) o.Emission = float3(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); } fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br>  Un bref rappel de HLSL: avant d'utiliser / d'appeler une fonction, elle doit √™tre √©crite / d√©clar√©e. <br><br>  PS Si vous souhaitez cr√©er un shader √† l'aide du graphe Unity Shader, vous devez utiliser des n≈ìuds personnalis√©s (et g√©n√©rer du bruit en y √©crivant du code HLSL).  Je parlerai des n≈ìuds personnalis√©s dans un futur tutoriel. <br><br><h3>  R√©sultat (3D) </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce6/a89/ad3/ce6a89ad324ff4a03d4bfabf1a694024.gif"></div><br><hr><br><h2>  Ajout de contours </h2><br>  Pour ajouter des contours, vous devez r√©p√©ter le processus de la partie pr√©c√©dente du didacticiel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/228/7bb/169/2287bb1692d36eae92224f36359648a3.gif"></div><br><hr><br><h2>  Effet invers√© </h2><br>  Et si nous voulons inverser cet effet?  (Les objets devraient dispara√Ætre si un joueur est √† proximit√©) <br><br>  Il nous suffit de changer une ligne: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> dist = _Radius - distance(_PlayerPos, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos);</code> </pre> <br>  (Le m√™me processus s'applique au Shader Graph). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/579/86c/1f9/57986c1f96a56f1ec478b64c89be3eba.gif"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr427401/">https://habr.com/ru/post/fr427401/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr427391/index.html">Conseils pour les juniors: construire de bonnes habitudes</a></li>
<li><a href="../fr427393/index.html">Analyse de s√©curit√© sans fil d'entreprise</a></li>
<li><a href="../fr427395/index.html">"Expliquons: ou pourquoi un programmeur math√©maticien." Un livre sur la fa√ßon de ne pas manquer les cours de math√©matiques</a></li>
<li><a href="../fr427397/index.html">D√©veloppement d'un ensemble de donn√©es acoustiques pour la formation d'un r√©seau neuronal</a></li>
<li><a href="../fr427399/index.html">Utilisation de donn√©es lors de la cr√©ation d'une API bas√©e sur GraphQL</a></li>
<li><a href="../fr427403/index.html">API ReportingObserver: un regard sur le code des pages web sous un nouvel angle</a></li>
<li><a href="../fr427405/index.html">ES2018 - enfin promet m√©thode</a></li>
<li><a href="../fr427407/index.html">M√©ta-clustering avec minimisation des erreurs, et pourquoi je pense que le cerveau fonctionne de cette fa√ßon</a></li>
<li><a href="../fr427409/index.html">Le livre "The Brilliant Agile. Gestion de projet flexible avec Agile, Scrum et Kanban ¬ª</a></li>
<li><a href="../fr427413/index.html">Lutter pour les ressources, partie 4: grand</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>