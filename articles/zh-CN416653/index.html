<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👦‍👦 ⛑️ 👩🏼‍💼 图书馆排序 🐼 🤦🏻 👨🏿‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="取一个反序数组，并通过简单的inserts对其进行排序 。 



 看看在正确的位置将下一个元素插入什么位置。 为此，您需要释放插入位置，因此必须移动所有先前插入的元素。 

 如果之前插入的元素之间有空白，那将会有多棒！ 这样一来，不必为了插入一个元素而拖动元素的行。 

 2004年，三位计算...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>图书馆排序</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416653/"><div style="text-align:center;"><img width="700" height="394" src="https://habrastorage.org/webt/8i/bj/do/8ibjdoxetlxsby3qiaj5seokxxa.jpeg"></div><br><br><a name="habracut"></a><br> 取一个反序数组，并<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">通过简单的inserts</a>对其<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">进行排序</a> 。 <br><br><img width="684" height="95" src="https://habrastorage.org/webt/il/qa/vz/ilqavzmmhgxwuhcityv7wuqqqig.gif"><br><br> 看看在正确的位置将下一个元素插入什么位置。 为此，您需要释放插入位置，因此必须移动所有先前插入的元素。 <br><br> 如果之前插入的元素之间有空白，那将会有多棒！ 这样一来，不必为了插入一个元素而拖动元素的行。 <br><br>  2004年，三位计算机科学专家-Michael Bender，Martin Farah-Colton和Miguel Mostiro-决定以这种方式用简单的插入内容修改排序。 他们建议形成阵列的有序部分，在插入的元素之间留出空隙。 <br><blockquote> 图书管理员需要将这些书按字母顺序排列在一个长架子上：从字母“ A”的左侧开始，这些书彼此之间紧挨着“ I”。 如果图书馆收到一本与“ B”节有关的新书，则要将其放在正确的位置，您必须移动每本书，从“ B”节的中间到最后一个“ I”。 这是通过简单的插入排序。 但是，如果图书馆员在每个部分都保留了自由空间，那么他只需要移动几本书就可以为新书腾出空间。 这是图书馆分类的基本原则。 </blockquote><h2> 演算法 </h2><br><img width="693" height="168" src="https://habrastorage.org/webt/jl/-l/wc/jl-lwclcowy6aohvc82uksordtg.gif"><br><br><ul><li>  <strong>1.创建一个空的辅助数组，比主数组大几倍。</strong> </li><li>  <strong>2.对于下一个元素，我们在辅助数组中寻找插入位置。</strong> <ul><li>  <strong>2.1。</strong>  <strong>如果找到要插入的位置，则转移物品并返回步骤2。</strong> </li><li>  <strong>2.2。</strong>  <strong>如果没有插入的地方，请重新平衡辅助阵列并返回到点2。</strong> </li></ul></li><li>  <strong>3.处理完所有元素后，将它们传送回主数组。</strong> </li></ul><br> 乍一看，排序似乎很简单。 为了消除这种幻想，我们将更详细地考虑算法的关键点。 <br><br><h2> 辅助阵列尺寸 </h2><br> 尽管尚无定论，但辅助阵列应比主阵列大多少倍。 <br><br> 如果您占用过多空间，那么元素之间将有很多空间，但是，由于元素之间的距离较大，因此搜索插入位置和重新平衡会变慢。 重新平衡的频率会降低，但是他们将不得不在上面花费更多的资源。 如果花费太少，那么搜索和重新平衡会更便宜，但是您将不得不更频繁地重新格式化阵列。 通常，仍然需要使用不同的值进行测试，科学戳的方法可以确定最佳选择。 <br><br> 如果我们确定辅助数组比主数组大多少倍，那么确定其确切元素数量的公式如下所示： <br><br>  <b>NewSize =ε×（大小+ 1）-1</b> <br><br>  <i>NewSize-辅助数组中的元素数</i> <i><br></i>  <i>ε-辅助数组比主数组大多少倍</i> <i><br></i>  <i>大小-主数组中的元素数</i> <br><br> 如果仅将<b>大小乘</b>以一个因子： <b>NewSize = Size×ε</b> ，则对于均匀分布，我们将没有足够的单元格<b>ε-1个</b> 。 即，可以将它们均匀地布置，但是第一个填充的单元格或最后一个填充的单元格将靠近辅助阵列的边缘。 并且我们需要从各个方面保留填充单元中的空白位置-包括第一个元素之前和最后一个元素之后。 <br><br><img width="692" height="312" src="https://habrastorage.org/webt/am/np/py/amnppyndj34-6az2hiyjakiakbk.png"><br><br> 这似乎是一件小事，但实际上对于重新平衡很重要，要保证有自由的位置可以插入任何地方，包括在处理主数组的最后一个元素时。 <br><br><h2> 搜索辅助数组中的插入位置 </h2><br> 当然，这里需要二进制搜索。 但是，经典实现对我们不起作用。 <br><br> 首先，辅助数组主要由void组成。 因此，递归地将结构二分，我们将大部分遇到未填充的单元格。 在这种情况下，您需要向左或向右一点走到最近的非空单元格。 然后，在该段的末尾将有重要的元素，使您可以计算算术平均值并继续进行深度二值搜索。 <br><br> 其次，不要忘记边缘。 如果您需要插入最小或最大元素，那么在较早插入的元素中进行二进制搜索将不会有任何结果。 因此，有必要考虑边界情况-首先检查是否有必要将元素放置在数组的左边界或右边界附近，如果不需要，则使用二进制搜索。 <br><br> 第三，考虑到应用程序的细节，值得进行额外的修改以最大程度地减少阵列再平衡的次数。 如果插入的元素等于段末尾之一的值，那么也许您不应该将其插入段中间。 将与其值相等的元素放在旁边是更合乎逻辑的。 这将更有效地填充辅助数组的空白空间。 <br><br> 第四，第五等等。 搜索插入位置的质量直接影响分拣速度，因为选择不成功的插入位置会导致不必要的重新平衡。 例如，根据插入元素的值更接近于哪条边缘，可能不值得在中间精确地划分段，而是更接近段的左边缘或右边缘？ <br><br> 二进制搜索算法本身充满陷阱，考虑到上述额外的细微差别，它最终绝不是一项艰巨的任务。 <br><br><h2> 阵列再平衡 </h2><br> 在这种排序中，二进制搜索并不是最难实现的事情。 仍在重新平衡。 <br><br> 如果没有要插入的位置（找到了相似的元素，但是它们之间没有空闲单元），则需要摇晃辅助阵列，以便释放插入位置。 阵列的抖动正在重新平衡。 <br><br> 而且，重新平衡是<i>局部的</i>或<i>完全的</i> 。 <br><br><h3> 本地再平衡 </h3><br> 我们将根据需要移动任意数量的元素以释放插入点。 这种平衡的实现非常简单，您只需要从插入点找出最近的空单元格并使用它移动几个元素。 <br><br> 有细微差别。 例如，寻找最近空置地点的方法是什么？ 为了避免无法进行平移的情况（也就是说，如果在某些侧面上所有单元格都位于阵列的最边缘），可以将焦点放在插入点相对于阵列中间的位置。 如果需要在数组的左侧插入，则向右移动，如果在右侧-向左移动。 如果<b>ε≥2</b> ，则此方法消除了无法进行移位的情况（因为辅助阵列的一半有足够的空间容纳所有元素）。 <br><br> 在作者对该算法的解释中，暗示了局部重新平衡。 <br><br><h3> 完全重新平衡 </h3><br> 本地解决方案的一个有趣替代方法是完全重新平衡。 也就是说，在辅助数组中，移动所有可用元素，以使它们之间（几乎）有相同的空间。 <br><br><img width="693" height="168" src="https://habrastorage.org/webt/xg/yi/nr/xgyinrhnartyvwhdgqvmucrmx7m.gif"><br><br> 我尝试了这两种方法，到目前为止，我发现通过局部重新平衡，该算法的工作速度比完整算法快1.5-2倍。 但是，仍然可以使用完全重新平衡。 例如，如果您必须过于频繁地进行局部重新平衡，则意味着在阵列中某些区域中积累了许多“血凝块”，从而阻碍了整个过程。 一次完整的重新平衡，可以让您一举摆脱所有本地拥堵。 <br><br> 让我们找出如何完全重新平衡。 <br><br> 首先，您需要计算可为辅助数组中的每个元素分配多少个最大单元。 应当记住，空单元格必须同时位于第一个和最后一个填充的单元格之前。 公式为： <br><br><img width="186" height="52" src="https://habrastorage.org/webt/9n/he/da/9nhedamesorkojp6daccahjow2q.png"><br><br>  <i>M-可以分配给每个元素的像元数</i> <i><br></i>  <i>NewSize-辅助数组的大小</i> <i><br></i>  <i>Count-辅助数组中当前非空元素的数量</i> <br><br> 该分数必须减小为整数值（即四舍五入）。 从公式中可以明显看出，已经有更多的元素转移到辅助数组中，我们可以为每个元素的邻域选择的单元越少。 <br><br> 知道了<b>M</b> ，我们很容易获得辅助数组中每个非空元素在重新平衡完成后应位于的确切位置。 <br><br>  <b>NewPos =数字×M</b> <br><br>  <i>NewPos-重新平衡后的新商品位置</i> <i><br></i>  <i>Number-辅助数组中的非空元素是什么<nobr>（1≤Number≤Count）</nobr></i> <i><br></i>  <i>M-分配给每个元素的像元数</i> <br><br> 新的职位是已知的，您能简单地将辅助数组中的非空元素分类出来并将它们转移到其他地方吗？ 哦，不，不要着急。 不仅需要转移元素，而且保持其顺序也很重要。 并且，由于二进制搜索和插入的结果，元素在重新平衡后可能位于应位于的位置的左侧和右侧。 在您要移动的地方，可能还有另一个元素也需要附加到某个地方。 此外，如果辅助阵列中的旧位置和新位置之间还有其他元素，则无法转移元素-否则这些元素会混合在一起，对于我们而言，不要混淆顺序非常重要。 <br><br> 因此，要重新平衡，仅经历通常的循环并仅将每个要素从一个口袋转移到另一个口袋是不够的。 仍然有必要使用递归。 如果某个元素无法移动到新位置（其他元素出现在其新旧位置之间），那么首先您需要（递归）找出这些不请自来的客人。 然后一切都会正确安排。 <br><br><h2> 退化案例 </h2><br> 对于大多数按插入排序的情况，最不利的情况是使用反向排序的数组。  ing，对图书馆员的分类也不例外。 <br><br><img width="693" height="168" src="https://habrastorage.org/webt/mm/zm/_c/mmzm_cvt2fvcawbrkkswtav0huo.gif"><br><br> 元素趋向于辅助阵列的左边缘，结果空点很快用完。 您必须经常重新平衡阵列。 <br><br> 顺便说一下，如果我们采用几乎有序的数组（通过简单插入进行排序的最佳情况），那么我们会遇到相同的问题。 新到达的元素不会阻塞辅助阵列的左侧，但会阻塞右侧，这也会导致太频繁的重新平衡。 <br><br> 库排序可有效处理随机数据集。 部分排序（正向和反向）会损害速度性能。 <br><br><h2> 算法复杂度 </h2><br> 对于大量随机数据，该算法给出时间复杂度O（ <b>n</b> log <b>n</b> ）。 一点都不差！ <br><br> 在正确选择系数<strong>ε</strong>并成功实现二进制搜索的一组随机唯一（或大多数唯一）数据上，可以最小化甚至避免重新平衡的次数。 可以认为该算法具有最佳的时间复杂度O（ <b>n</b> ）。 <br><br> 大量重复的数据值以及有序（正序或逆序）子序列数组中的数据会导致辅助数组的频繁重新平衡，结果是在最不利的情况下时间复杂度降低到O <b>（n <sup>2</sup></b> ）。 <br><br> 当然，该算法的缺点是辅助数组需要O（ <b>n</b> ）个附加内存。 <br><br><h2> 可能的改善方法 </h2><br> 尽管该算法本身对随机数据具有指导意义和效率，但在过去的十五年中，很少有人对此感兴趣。 <br><br> 如果您通过请求“库排序”进行搜索，则会在英语Wikipedia上找到粗略的文章，作者的PDF（很少了解），并且很少重新发布这些微薄的信息。 另外，YouTube中有很好的可视化效果，主要是将主阵列和辅助阵列组合在一起的。 所有链接都在文章末尾。 <br><br> 搜索“库排序”更加有趣-在示例中，您将发现不同库中包含的不同排序，但是，这些算法与<i>真实的库排序</i>无关。 <br><br> 还有一些需要改进的地方： <br><br><ol><li> 最佳系数<strong>ε的</strong>经验选择。 </li><li> 修改二进制搜索（考虑到通用算法的细节），以最有效地确定插入点。 </li><li> 最小化再平衡成本。 </li></ol><br> 如果您对这些地方进行了润饰，那么也许图书馆的排序速度等于快速排序？ <br><br><h2> 源代码 </h2><br> 我没有准备用Python准备实现，PHP中有可用的版本。 <br><br><div class="spoiler">  <b class="spoiler_title">基本算法</b> <div class="spoiler_text"><pre><code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LibrarySort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($arr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> $arr_new;<span class="hljs-comment"><span class="hljs-comment">//  $e = 3;//     $rebalance_local = true;// (true)   (false)  //   $newSize = $e * (count($arr) + 1) - 1; $arr_new = array_fill(0, $newSize, null); //       $arr_new[LibrarySort_Pos(1, 1, $newSize)] = $arr[0]; //    -    //     $start = 0; $finish = $newSize - 1; $i = 1; //      while($i &lt; count($arr)) { //        $pos = LibrarySort_BinarySearch($arr[$i], $start, $finish, $newSize); if($pos === false) {//        //    LibrarySort_Rebalance_Total($i, $newSize); } else {//  ,   ,    if($arr_new[$pos] !== null) {//   if($rebalance_local) {//  (+ ) LibrarySort_Rebalance_Local($arr[$i++], $pos, $newSize); } else {//  LibrarySort_Rebalance_Total($i, $newSize); } } else {//   ,   $arr_new[$pos] = $arr[$i++]; } } } //      $pos = 0; for($i = 0; $i &lt;= $newSize - 1; $i++) { if($arr_new[$i] !== null) $arr[$pos++] = $arr_new[$i]; } return $arr; }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">完全重新平衡后，元素在附加数组中的新位置</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// $number-    $count //     //$number -      ( )  //$count -       //$newSize -     //$number &lt;= $count &lt;= count($arr) &lt;= $newSize) function LibrarySort_Pos($number, $count, $newSize) { return $number * floor(($newSize + 1) / ($count + 1)) - 1; }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">辅助数组中插入位置的二进制搜索</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//       //$search -     ,      //($start, $finish) -   ,     //$newSize -     function LibrarySort_BinarySearch($search, $start, $finish, $newSize) { global $arr_new;//  //      //      ,     //  ,       while($arr_new[$start] === null &amp;&amp; $start &lt; $newSize - 1) { ++$start; } //         , //         if($search == $arr_new[$start]) { return LibrarySort_PosNearby($start, $newSize); //  ,        } elseif($search &lt; $arr_new[$start]) { //      //     if($start &gt; 0) {// $start    $finish = $start; $start = 0; return floor(($start + $finish) / 2); } else {//$start == 0,      return $start;//    ,    } } //      ,     //  ,       while($arr_new[$finish] === null &amp;&amp; $finish &gt; 0) { --$finish; } //         , //         if($search == $arr_new[$finish]) { return LibrarySort_PosNearby($finish, $newSize); //  ,        } elseif($search &gt; $arr_new[$finish]) { //      //     if($finish &lt; $newSize - 1) {// $finish    $start = $finish; $finish = $newSize - 1; return ceil(($start + $finish) / 2); } else {//$finish == $newSize - 1,      return $finish;//    ,    } } //     , //,    -   //   ,       If($finish - $start &gt; 1) {//   ,    3  $middle = ceil(($start + $finish) / 2); //   $middle_Pos = 0; // ""     $offset = 0; //         //,    /,      while($middle - $offset &gt; $start &amp;&amp; $middle_Pos == 0){ if($arr_new[$middle - $offset] !== null) { $middle_Pos = $middle - $offset; } elseif($middle + $offset &lt; $finish &amp;&amp; $arr_new[$middle + $offset] !== null) { $middle_Pos = $middle + $offset; } ++$offset; } //    , ,     , //              If($middle_Pos) { if($arr_new[$middle_Pos] == $search) { return LibrarySort_PosNearby($middle_Pos, $newSize); } else { if($arr_new[$middle_Pos] &gt; $search) { $finish = $middle_Pos; } else {//$arr_new[$middle_Pos] &lt; $search $start = $middle_Pos; } return LibrarySort_BinarySearch($search, $start, $finish, $newSize); } } else {//$middle_Pos == 0 -   (   )     return $middle;//   - ,     } } else {//  ,       return floor(($start + $finish) / 2); } return false;//  ,       }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">如果在搜索过程中该元素等于该段的末端之一</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,        //$start - ,        //$newSize -     function LibrarySort_PosNearby($start, $newSize) { global $arr_new;//  //       for($left = $start - 1; $left &gt;= 0; $left--) { if($arr_new[$left] === null) {//  return $left;//   } elseif($arr_new[$left] &lt;&gt; $arr_new[$start]) {//     break; //   ,      } } //     ,    for($right = $start + 1; $right &lt;= $newSize - 1; $right++) { if($arr_new[$right] === null) {//  return $right; //   } elseif($arr_new[$right] &lt;&gt; $arr_new[$start]) {//     break; //   ,      } } return $start; //          .      ,     }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">本地重新平衡其他阵列</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//    //$insert - ,    //$pos -            //$newSize -     function LibrarySort_Rebalance_Local($insert, $pos, $newSize) { global $arr_new;//  // $pos  $insert,       while($pos - 1 &gt;= 0 &amp;&amp; $arr_new[$pos - 1] !== null &amp;&amp; $arr_new[$pos - 1] &gt; $insert) {--$pos;} while($pos + 1 &lt;= $newSize - 1 &amp;&amp; $arr_new[$pos + 1] !== null &amp;&amp; $arr_new[$pos + 1] &lt; $insert) {++$pos;} $middle = (integer) $newSize / 2;//  if($pos &lt;= $middle) {//      if($arr_new[$pos] !== null &amp;&amp; $arr_new[$pos] &lt; $insert) ++$pos; //  $right = $pos; while($arr_new[++$right] !== null) {} for($i = $right; $i &gt; $pos; $i--) { $arr_new[$i] = $arr_new[$i - 1]; } } else {//      if($arr_new[$pos] !== null &amp;&amp; $insert &lt; $arr_new[$pos]) --$pos; //  $left = $pos; while($arr_new[--$left] !== null) {} for($i = $left; $i &lt; $pos; $i++) { $arr_new[$i] = $arr_new[$i + 1]; } } $arr_new[$pos] = $insert; }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">完全平衡其他阵列</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//    //$count -        //$newSize -     function LibrarySort_Rebalance_Total($count, $newSize) { global $arr_new;//  global $library_Number;//     global $library_LeftPos;//        $library_Number = $count; //        $library_LeftPos = $newSize - 1;// ,     //         $i = $newSize - 1; while($i &gt;= 0) { if($arr_new[$i] !== null) {//   $pos = LibrarySort_Pos($library_Number, $count, $newSize);//   newSize=$newSize"); if($i == $pos) {//      --$i;//      } elseif($i &lt; $pos) {//    $arr_new[$pos] = $arr_new[$i]; $arr_new[$i] = null; --$i;//      } else {//$i &gt; $pos -     //      LibrarySort_RemoveLeft($i, $pos, $count, $newSize); $i = ($i &gt; $library_LeftPos) ? $library_LeftPos - 1 : --$i; } --$library_Number;//      } else {// ,   --$i;//      } } }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">元素在完全平衡的情况下向左移动</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//     . //    ,   //$i -     ,    //$pos -       //$count -        //$newSize -     function LibrarySort_RemoveLeft($i, $pos, $count, $newSize) { global $arr_new;//  global $library_Number;//     global $library_LeftPos;//        $left = false; $left_Pos = false;//      $j = $i;//      //     while($j &gt; 0 &amp;&amp; $left === false) {//            --$j; //     if($arr_new[$j] !== null) $left = $j;//    } if($left === false || $left &lt; $pos) {//   (  )    //     } else { //$left &gt;= $pos,     --$library_Number;//,       $left_Pos = LibrarySort_Pos($library_Number, $count, $newSize);//     //        LibrarySort_RemoveLeft($left, $left_Pos, $count, $newSize); //  ,     } //    ,   $arr_new[$pos] = $arr_new[$i]; $arr_new[$i] = null; //,         if($pos &lt; $library_LeftPos) $library_LeftPos = $pos; }</span></span></code> </pre> </div></div><br> 我必须根据该方法的一般说明从头开始编写代码。 我没有看到接近快速排序的速度；我的库排序选项的排序速度比快速排序慢10到20倍。 但是，原因当然是我的实现过于粗糙，很多方面尚未考虑在内。 <br><br> 我想看看算法创建者的版本。 我今天写信给作者（并给他们链接到这个habrastatu的链接），他们会突然回答。 尽管...我记得，我曾尝试与Allen Beachich（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ABC排序</a> ）和Jason Morrison（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">J排序</a> ）联系，但是结果和我在Sportloto中写的一样。 <br><br>  <b>UPD</b>  <b>Martin Farah-Colton回答我说他们从未执行过该实现：</b> <blockquote> 恐怕我们从未实现过该算法。 </blockquote>  <b>最主要的是想法：)</b> <br><br><h2> 算法特征 </h2><div class="scrollable-table"><table><tbody><tr><th align="left"> 职称 </th><td align="left" colspan="2"> 图书馆分类，图书馆分类 </td></tr><tr><th align="left"> 其他名字 </th><td align="left" colspan="2"> 插入间隙排序 </td></tr><tr><th align="left"> 作者 </th><td align="left" colspan="2"> 迈克尔·本德尔（Michael A.Bender），马丁·法拉赫·科尔顿（MartínFarach-Colton），米格尔·莫斯特罗（Miguel Mosteiro） </td></tr><tr><th align="left"> 年份 </th><td align="left" colspan="2">  2004年 </td></tr><tr><th align="left"> 班级 </th><td align="left" colspan="2"> 插入排序 </td></tr><tr><th align="left"> 比较 </th><td align="left" colspan="2"> 有 </td></tr><tr><th align="left" rowspan="3"> 时间复杂度 </th><th align="left"> 最好的 </th><td align="left">  O（ <b>n</b> ） </td></tr><tr><th align="left"> 平均 </th><td align="left">  O（ <b>n</b> log <b>n</b> ） </td></tr><tr><th align="left"> 最坏的 </th><td align="left">  O（ <b>n <sup>2</sup></b> ） </td></tr><tr><th align="left"> 额外的内存复杂性 </th><td align="left" colspan="2">  O（ <b>n</b> ） </td></tr></tbody></table></div><br><h2> 参考文献 </h2><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">图书馆排序</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><img width="30" height="30" src="https://habrastorage.org/webt/sb/ln/dw/sblndwenhewoyoas_n3xp7tyuuu.png"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">库排序算法可视化</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><img width="84" height="30" src="https://habrastorage.org/webt/yv/lm/2t/yvlm2t2kl5affkpm0hzqh7qw5ly.png"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">插入排序为O（n log n）</a> <br><br><h3> 该算法的作者： </h3><br><img align="right" width="392" height="120" src="https://habrastorage.org/webt/il/dh/l9/ildhl9tnc4alqaexulf-kw2rmt0.png"><br clear="left"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">迈克尔·本德尔</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">马丁·法拉·科尔顿</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">米格尔·莫斯特罗（Miguel Mostiro）</a> </p><br><br><h3> 系列文章： </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Excel应用程序AlgoLab.xlsm</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">交换排序</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">插入排序</a> <ul><li>  <b>图书管理员排序</b> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">纸牌排序</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">排序“河内塔”</a> </li><li> 年轻表排序 </li><li> 反转排序 </li><li> 插入排序比较 </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">按选择排序</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">合并排序</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">按分布排序</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">混合排序</a> </li></ul><br><br><img align="right" width="364" height="192" src="https://habrastorage.org/webt/9y/1b/d5/9y1bd57yvcw4rt65o3ztjb59xum.png"><br clear="left"><p> 排序已添加到AlgoLab。 因此，您可以尝试使用小型数据集。 <br><br> 在这种情况下，您可以确定辅助阵列比主阵列大多少倍。 要选择系数<strong>ε，</strong>您可以在带有“库排序”的单元格上单击鼠标右键，然后选择“更改注释”。 并在注释中，小心地将<b>e</b>的整数值设置为2到5。如果您输入其他值而不是这些数字，则将使用默认值= 2。 <br><br> 您也可以选择重新平衡的类型。 如果将local设置为1，则将使用本地重新平衡。 如果本地= 0-满。 <br><br> 并且，不要忘记在开始可视化之前为过程表设置最佳比例，否则辅助阵列将无法显示在屏幕上。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN416653/">https://habr.com/ru/post/zh-CN416653/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN416641/index.html">开发移动应用程序界面的过程的8个阶段</a></li>
<li><a href="../zh-CN416643/index.html">十个步骤在Kubernetes上在AWS上部署Elasticsearch</a></li>
<li><a href="../zh-CN416645/index.html">MIS。 研究模式</a></li>
<li><a href="../zh-CN416647/index.html">政府机构是否梦想着电力风险？</a></li>
<li><a href="../zh-CN416651/index.html">1个CPU核心上的1M HTTP rps。 DPDK代替nginx + linux内核TCP / IP</a></li>
<li><a href="../zh-CN416657/index.html">三分之二的已用存储卡包含以前所有者的个人数据</a></li>
<li><a href="../zh-CN416659/index.html">由于零工经济的数字支付量将达到1.2万亿美元</a></li>
<li><a href="../zh-CN416661/index.html">移动银行的用户和提供商应考虑哪些趋势</a></li>
<li><a href="../zh-CN416665/index.html">通过Sonatype Nexus Repository OSS重用私有Android库</a></li>
<li><a href="../zh-CN416667/index.html">旧系统单元的预算防尘和隔音</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>