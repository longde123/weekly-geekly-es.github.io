<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👂🏾 💻 😧 Interrupts von externen Geräten in einem x86-System. Teil 1. Die Entwicklung der Interrupt-Controller 🧗🏾 👨‍👨‍👧‍👧 ℹ️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel möchte ich die Interrupt-Übermittlungsmechanismen von externen Geräten im x86-System betrachten und versuchen, die folgenden Fragen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interrupts von externen Geräten in einem x86-System. Teil 1. Die Entwicklung der Interrupt-Controller</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430548/">  In diesem Artikel möchte ich die Interrupt-Übermittlungsmechanismen von externen Geräten im x86-System betrachten und versuchen, die folgenden Fragen zu beantworten: <br><br><ul><li>  Was ist PIC und wofür ist es? </li><li>  Was ist APIC und wofür ist es?  Wofür sind LAPIC und I / O APIC? </li><li>  Was sind die Unterschiede zwischen APIC, xAPIC und x2APIC? </li><li>  Was ist MSI?  Was sind die Unterschiede zwischen MSI und MSI-X? </li><li>  Wie hängen die $ PIR-, MPtable- und ACPI-Tabellen damit zusammen? </li></ul><br>  Wenn Sie eine Antwort auf eine dieser Fragen erhalten möchten oder sich nur mit der Entwicklung der Interrupt-Controller im x86-System vertraut machen möchten, sind Sie bei cat willkommen. <br><a name="habracut"></a><br><h3>  Einführung </h3><br>  Wir alle wissen, was Unterbrechung ist.  Für diejenigen, die es nicht sind, zitieren Sie aus Wikipedia: <br><br><blockquote> Unterbrechung (englische Unterbrechung) - Ein Signal von Software oder Hardware, das den Prozessor über das Auftreten eines Ereignisses informiert, das sofortige Aufmerksamkeit erfordert.  Eine Unterbrechung benachrichtigt den Prozessor über das Auftreten eines Ereignisses mit hoher Priorität, das eine Unterbrechung des vom Prozessor ausgeführten aktuellen Codes erfordert.  Der Prozessor reagiert, indem er seine aktuelle Aktivität unterbricht, seinen Status beibehält und eine Funktion ausführt, die als Interrupt-Handler (oder Interrupt-Handler) bezeichnet wird und auf das Ereignis reagiert und es bedient. Danach gibt er die Kontrolle an den unterbrochenen Code zurück. <br><br>  Abhängig von der Quelle des Interrupt-Signals werden sie unterteilt in: <br><br><ul><li>  asynchron oder extern (Hardware) - Ereignisse, die von externen Hardwaregeräten (z. B. Peripheriegeräten) stammen und zu einem beliebigen Zeitpunkt auftreten können: ein Signal von einem Timer, einer Netzwerkkarte oder einem Festplattenlaufwerk, Tastenanschläge, Mausbewegungen.  Die Tatsache, dass ein solcher Interrupt im System auftritt, wird als Interrupt Request (IRQ) interpretiert. Geräte melden, dass sie die Aufmerksamkeit des Betriebssystems benötigen. </li><li>  synchrone oder interne Ereignisse im Prozessor selbst infolge der Verletzung bestimmter Bedingungen bei der Ausführung von Maschinencode: Division durch Null oder Stapelüberlauf, Zugriff auf ungültige Speicheradressen oder ungültigen Operationscode; </li></ul></blockquote>  In diesem Artikel möchte ich externe IRQ-Interrupts diskutieren. <br><br>  Warum werden sie gebraucht?  Angenommen, wir möchten eine Aktion mit einem Eingabepaket für eine Netzwerkkarte ausführen, wenn diese eintrifft.  Um die Netzwerkkarte nicht ständig zu fragen: "Haben Sie ein neues Paket?"  Verschwenden Sie keine Prozessorressourcen, Sie können den IRQ-Interrupt verwenden.  Die Geräte-Interrupt-Leitung ist mit der INTR-Leitung des Prozessors verbunden, und wenn ein Paket empfangen wird, "zieht" die Netzwerkkarte diese Leitung.  Der Prozessor versteht, dass Informationen dafür vorhanden sind, und liest das Paket. <br><br>  Aber was ist, wenn es viele Geräte gibt?  Sie können nicht genug von allen externen Geräten der Prozessorbeine erhalten. <br><br><img src="https://habrastorage.org/webt/vg/3q/3v/vg3q3v7kx8vjttp43xo99o8pccs.png"><br><br>  Um dieses Problem zu lösen, haben sie einen Chip entwickelt - einen Interrupt-Controller. <br><br><h3>  Pic </h3><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wiki</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">osdev</a> ) <br><br>  Der erste war ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intel 8259 PIC-</a> Chip.  8 Eingangsleitungen (IRQ0-7) und ein Ausgang, der den Controller mit der INTR-Leitung des Prozessors verbindet.  Wenn ein Interrupt von einem Gerät auftritt, zieht 8259 die INTR-Leitung, der Prozessor versteht, dass ein Gerät einen Interrupt signalisiert, und fragt den PIC ab, um zu verstehen, welcher IRQx-Zweig den Interrupt verursacht hat.  Es gibt eine zusätzliche Verzögerung für diese Umfrage, aber die Anzahl der Interrupt-Leitungen erhöht sich auf 8. <br><br><img src="https://habrastorage.org/webt/le/yf/6e/leyf6enogyzp6flpijo2d0x1w9g.png"><br><br>  8 Leitungen erwiesen sich jedoch schnell als klein, und um ihre Anzahl zu erhöhen, wurden 2 8259 in Kaskade geschaltete Controller (Master und Slave) (Dual PIC) verwendet. <br><br>  Die IRQs 0 bis 7 werden vom ersten Intel 8259 PIC (Master) und die IRQs 8 bis 15 vom zweiten 8259 PIC (Slave) verarbeitet.  Nur ein Master signalisiert das Auftreten eines Interrupts.  Wenn auf den Leitungen 8-15 ein Interrupt auftritt, signalisiert der zweite PIC (Slave) dem Master über IRQ 2 einen Interrupt, und der Master signalisiert wiederum der CPU.  Dieser kaskadierende Interrupt benötigt eine der 16 Leitungen, bietet jedoch am Ende 15 verfügbare Interrupts für Geräte. <br><br><img src="https://habrastorage.org/webt/xj/yn/dh/xjyndhabujjwz0alrbx831zfzt8.png"><br><br>  Die Schaltung hat sich etabliert, und das ist es, was sie bedeuten, wenn sie jetzt über PIC (Programm Interrupt Controller) sprechen.  Anschließend erhielten die 8259-Controller einige Verbesserungen und wurden als 8259A bekannt, und diese Schaltung wurde in den Chipsatz aufgenommen.  Zu einer Zeit, als der Hauptbus zum Anschließen externer Geräte der ISA-Bus war, reichte ein solches System insgesamt aus.  Es musste nur sichergestellt werden, dass verschiedene Geräte nicht mit derselben IRQ-Leitung verbunden waren, um Konflikte zu vermeiden, da ISA-Interrupts nicht gemeinsam genutzt werden. <br><br>  Normalerweise war das Layout von Interrupts für Geräte mehr oder weniger Standard <br><br>  Beispiel ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier genommen</a> ): <br>  IRQ 0 - Systemtimer <br>  IRQ 1 - Tastaturcontroller <br>  IRQ 2 - Kaskade (Interrupt vom Slave-Controller) <br>  IRQ 3 - serielle Schnittstelle COM2 <br>  IRQ 4 - serielle Schnittstelle COM1 <br>  IRQ 5 - Parallelport 2 und 3 oder Soundkarte <br>  IRQ 6 - Diskettenregler <br>  IRQ 7 - Parallelport 1 <br>  IRQ 8 - RTC-Timer <br>  IRQ 9 - ACPI <br>  IRQ 10 - offen / SCSI / NIC <br>  IRQ 11 - offen / SCSI / NIC <br>  IRQ 12 - Mauscontroller <br>  IRQ 13 - Mathe-Co-Prozessor <br>  IRQ 14 - ATA-Kanal 1 <br>  IRQ 15 - ATA-Kanal 2 <br><br>  Die Konfiguration und Arbeit mit 8259 Mikroschaltungen erfolgt über E / A-Ports: <br><div class="scrollable-table"><table><tbody><tr><th>  Chip </th><th>  Registrieren </th><th>  E / A-Port </th></tr><tr><td>  Meisterbild </td><td>  Befehl </td><td>  0x0020 </td></tr><tr><td>  Meisterbild </td><td>  Daten </td><td>  0x0021 </td></tr><tr><td>  Sklavenbild </td><td>  Befehl </td><td>  0x00A0 </td></tr><tr><td>  Sklavenbild </td><td>  Daten </td><td>  0x00A1 </td></tr></tbody></table></div><br>  → Die Dokumentation zum 8259A finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier.</a> <br><br>  Der ISA-Bus wurde durch den PCI-Bus ersetzt.  Und die Anzahl der Geräte begann deutlich die Zahl 15 zu überschreiten. Im Gegensatz zum statischen ISA-Bus können die Geräte in diesem Fall dynamisch zum System hinzugefügt werden.  Glücklicherweise können in diesem Bus Interrupts gemeinsam genutzt werden (dh mehrere Geräte können an dieselbe IRQ-Leitung angeschlossen werden).  Um das Problem des Fehlens von IRQ-Leitungen zu lösen, beschlossen sie, Interrupts von allen PCI-Geräten in PIRQ-Leitungen zu gruppieren (Programmable Interrupt Request). <br><br>  Angenommen, wir haben 4 Interrupt-Leitungen frei auf dem PIC-Controller und 20 PCI-Geräte.  Wir kombinieren die Interrupts von 5 Geräten pro PIRQx-Leitung und verbinden die PIRQx-Leitungen mit dem Controller.  Wenn auf der PIRQx-Leitung ein Interrupt auftritt, muss der Prozessor alle an diese Leitung angeschlossenen Geräte abfragen, um zu verstehen, von wem der Interrupt stammt. Dies löst jedoch im Allgemeinen das Problem.  Ein Gerät, das PCI-Interrupt-Leitungen in einer PIRQ-Leitung bindet, wird häufig als PIR-Router bezeichnet. <br><br>  Bei dieser Methode müssen Sie sicherstellen, dass die PIRQx-Leitungen nicht mit den IRQx-Leitungen verbunden sind, auf denen bereits ISA-Interrupts gestartet wurden (da dies zu Konflikten führt), und dass die PIRQx-Leitungen ausgeglichen sind (je mehr Geräte wir mit derselben PIRQ-Leitung verbunden haben, desto mehr Geräte benötigen Sie fragt den Prozessor ab, um zu verstehen, welches dieser Geräte den Interrupt verursacht hat). <br><br><img src="https://habrastorage.org/webt/u_/jr/u9/u_jru9pemdeda2xvvbqihvgtp3y.png"><br><br>  <b>Hinweis</b> : Das PCI-Gerät -&gt; PIR-Mapping wird im Bild abstrakt dargestellt, da es tatsächlich etwas komplizierter ist.  In der Realität verfügt jedes PCI-Gerät über 4 Interrupt-Leitungen (INTA, INTB, INTC, INTD).  Jedes PCI-Gerät kann bis zu 8 Funktionen haben, und jetzt hat jede Funktion einen INTx-Interrupt.  Welche INTx jede Funktion des Geräts abruft, hängt von der Konfiguration des Chipsatzes ab. <br><br>  Funktionen sind im Wesentlichen separate logische Blöcke.  Beispielsweise kann in einem PCI-Gerät eine Smbus-Controller-Funktion, eine SATA-Controller-Funktion oder eine LPC-Bridge-Funktion vorhanden sein.  Auf der Betriebssystemseite ist jede Funktion ein separates Gerät mit einem eigenen Konfigurationsbereich für die PCI-Konfiguration. <br><br>  Das Betriebssystem übertrug Informationen über Routing-Interrupts im BIOS des PIC-Controllers unter Verwendung der Tabelle $ PIR und durch Ausfüllen der Register 3Ch (INT_LN Interrupt Line (R / W)) und 3Dh (INT_PN Interrupt Pin (RO)) des PCI-Konfigurationsraums für jede Funktion.  Die Spezifikation für die $ PIR-Tabelle befand sich zuvor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf der Microsoft-Website</a> , ist jetzt jedoch nicht mehr vorhanden.  Der Inhalt der Zeilen der $ PIR-Tabelle kann der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PCI-BIOS-Spezifikation</a> [4.2.2.  Holen Sie sich PCI Interrupt Routing Options] oder lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> <br><br><h3>  Apic </h3><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wiki</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Osdev</a> ) <br><br>  Die vorherige Methode funktionierte, bis Multiprozessorsysteme erschienen.  Tatsache ist, dass PIC in seinem Gerät Interrupts nur an einen Hauptprozessor übertragen kann.  Ich möchte jedoch, dass die Belastung der Prozessoren durch die Interrupt-Behandlung ausgeglichen wird.  Die Lösung für dieses Problem war die neue Schnittstelle APIC (Advanced PIC). <br><br>  Für jeden Prozessor wird ein spezieller LAPIC-Controller (Local APIC) und ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">E / A-APIC-</a> Controller hinzugefügt, um Interrupts von Geräten weiterzuleiten.  Alle diese Steuerungen sind in einem gemeinsamen Bus namens APIC zusammengefasst (neue Systeme werden jetzt über einen Standardsystembus verbunden). <br><br>  Wenn ein Interrupt von einem Gerät am E / A-APIC-Pin ankommt, leitet die Steuerung den Interrupt an den LAPIC eines der Prozessoren weiter.  Durch das Vorhandensein von E / A-APIC können Sie die Verteilung von Interrupts von externen Geräten zwischen Prozessoren ausgleichen. <br><br>  Der erste APIC-Chip war <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">82489DX</a> , ein separater Chip, der LAPIC und I / O-APIC kombiniert.  Um ein System von 2 Prozessoren zu erstellen, wurden 3 solcher Mikroschaltungen benötigt.  2 würde als LAPIC und eine als I / O APIC fungieren.  Später wurde die LAPIC-Funktionalität direkt in die Prozessoren integriert, und die E / A-APIC-Funktionalität wurde in den 82093AA-Chip integriert. <br><br>  Der E / A-APIC <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">82093AA</a> enthielt 24 Eingangspins, und die APIC-Architektur konnte bis zu 16 CPUs unterstützen.  Um die Kompatibilität mit älteren Systemen aufrechtzuerhalten, wurden alten ISA-Interrupts 0 bis 15 Interrupts zugewiesen.  In der IRQ-Zeile 16-23 wurden Unterbrechungen durch PCI-Geräte angezeigt.  Jetzt war es möglich, nicht an Interrupt-Konflikte von ISA- und PCI-Geräten zu denken.  Dank der erhöhten Anzahl freier Interrupt-Leitungen ist es auch möglich geworden, die Anzahl der PIRQx-Leitungen zu erhöhen. <br><br><img src="https://habrastorage.org/webt/mc/ra/hj/mcrahjn-owk9qrcmyiixcmhomcq.png"><br><br>  Die E / A-APIC- und LAPIC-Programmierung erfolgt über MMIO.  LAPIC-Register befinden sich normalerweise bei 0xFEE00000, E / A-APIC-Register bei 0xFE00000.  Grundsätzlich können jedoch alle diese Adressen neu konfiguriert werden. <br><br>  Wie bei PIC wurden zunächst einzelne Chips später Teil des Chipsatzes. <br><br>  Anschließend wurde die APIC-Architektur modernisiert und die neue Version hieß xAPIC (x - erweitert).  Abwärtskompatibilität mit der vorherigen Version beibehalten.  Die Anzahl der möglichen CPUs im System wurde auf 256 erhöht. <br><br>  Die nächste Runde der Architekturentwicklung hieß <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">x2APIC</a> .  Die Anzahl der möglichen CPUs im System wurde auf 2 ^ 32 erhöht.  Die Controller können im xAPIC-Kompatibilitätsmodus oder im neuen x2APIC-Modus arbeiten, in dem die LAPIC-Programmierung nicht über MMIO, sondern über MSR-Register (was viel schneller ist) erfolgt.  Nach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Link zu</a> urteilen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, ist</a> IOMMU-Unterstützung erforderlich, damit dieser Modus funktioniert. <br><br>  Es ist zu beachten, dass das System möglicherweise über mehrere E / A-APIC-Controller verfügt.  Zum Beispiel eine für 24 Unterbrechungen in der Südbrücke, die andere für 32 im Norden.  Im Zusammenhang mit E / A werden APIC-Interrupts häufig als GSI (Global System Interrupt) bezeichnet.  In einem solchen System wird also GSI 0-55 sein. <br><br>  Gibt es eine eingebaute LAPIC in der CPU und welche Architektur von den Bit-Flags in der CPUID verstanden werden kann. <br>  Damit das System LAPIC und E / A-APIC erkennen kann, muss das BIOS dem System Informationen über diese entweder über die MPtable (die alte Methode) oder über die ACPI-Tabelle (in diesem Fall MADT) bereitstellen.  Zusätzlich zu allgemeinen Informationen sollten sowohl die MPtable als auch die ACPI (diesmal in der DSDT-Tabelle) Informationen zum Interrupt-Routing enthalten, dh Informationen darüber, welches Gerät auf welcher Interrupt-Leitung sitzt (analog zur $ PIR-Tabelle). <br><br>  Die MPTable-Tabelle finden Sie in der offiziellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20121002210153/">Spezifikation</a> .  Früher befand sich die Spezifikation auf der Intel-Website, jetzt ist sie nur noch im Archiv zu finden.  Die ACPI-Spezifikation befindet sich jetzt auf der UEFI-Website (aktuelle Version <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6.2</a> ).  Es ist zu beachten, dass Sie mit ACPI das Interrupt-Routing für Systeme ohne APIC festlegen können (anstatt die Tabelle $ PIR zu verwenden). <br><br><h3>  Msi </h3><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wiki</a> ) <br><br>  Die vorherige Version mit APIC ist gut, aber nicht ohne Mängel.  Alle diese Geräteunterbrechungsleitungen komplizieren die Schaltung und erhöhen die Fehlerwahrscheinlichkeit.  Der PCI-Bus wurde durch PCI Express ersetzt, bei dem die Interrupt-Leitungen einfach entfernt werden sollten.  Um die Kompatibilität zu gewährleisten, werden Interrupt-Signale (INTx #) von bestimmten Nachrichtentypen emuliert.  In diesem Schema fiel die logische Hinzufügung von Interrupt-Leitungen, die früher durch physische Verbindung von Drähten erfolgte, auf die Schultern von PCI-Brücken.  Die Unterstützung älterer INTx-Interrupts ist jedoch nur Unterstützung für die Abwärtskompatibilität mit dem PCI-Bus.  Tatsächlich hat PCI Express eine neue Methode zur Zustellung von Interrupt-Nachrichten vorgeschlagen - MSI (Message Signaled Interrupts).  Bei dieser Methode schreibt das Gerät einfach in den MMIO-Bereich, der dem Prozessor-LAPIC zugewiesen ist, um eine Unterbrechung zu signalisieren. <br><br><img src="https://habrastorage.org/webt/8z/qw/7h/8zqw7him-vupzm_wi5glkqtr1ja.png"><br><br>  Früher wurden einem PCI-Gerät (dh allen seinen Funktionen) nur 4 Interrupts zugewiesen, jetzt können jetzt bis zu 32 Interrupts adressiert werden. <br><br>  Bei MSI gibt es keine gemeinsame Nutzung für die Leitungen, jeder Interrupt entspricht seinem Gerät. <br><br>  MSI-Interrupts lösen auch ein anderes Problem.  Angenommen, ein Gerät führt eine Speicherschreibtransaktion durch und möchte seinen Abschluss über einen Interrupt melden.  Eine Schreibtransaktion auf dem Bus kann jedoch während des Übertragungsprozesses (von dem das Gerät überhaupt nichts weiß) verzögert sein, und das Interrupt-Signal wird vor dem Prozessor eintreffen.  Somit liest die CPU immer noch ungültige Daten.  Wenn MSI verwendet wird, werden Informationen über MSI sowie Daten übertragen und können einfach nicht früher eingehen. <br><br>  Es sollte beachtet werden, dass MSI-Interrupts ohne LAPIC nicht funktionieren können, aber die Verwendung von MSI kann uns durch I / O-APIC ersetzen (Design-Vereinfachung). <br><br>  Anschließend erhielt diese Methode die MSI-X-Erweiterung.  Jetzt kann jedes Gerät bis zu 2048 Interrupts haben.  Und es wurde möglich, jedem Interrupt einzeln anzugeben, auf welchem ​​Prozessor er ausgeführt werden soll.  Dies kann für stark belastete Geräte wie Netzwerkkarten sehr nützlich sein. <br><br>  Für die MSI-Unterstützung sind keine zusätzlichen BIOS-Tabellen erforderlich.  Das Gerät muss jedoch die MSI-Unterstützung in einer der Funktionen in seiner PCI-Konfiguration melden, und der Gerätetreiber muss die Arbeit mit MSI unterstützen. <br><br><h3>  Fazit </h3><br>  In diesem Artikel haben wir die Entwicklung von Interrupt-Controllern untersucht und allgemeine theoretische Informationen zur Übermittlung von Interrupts von externen Geräten in einem x86-System erhalten. <br><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nächsten Teil werden</a> wir uns ansehen, wie jeder der beschriebenen Controller in der Praxis unter Linux verwendet wird. <br><br><h4>  Referenzen: </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Interrupt Controller (Sachen in der Mitte)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was machen die verschiedenen Interrupts in PCIe?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reduzierung der Interrupt-Latenz durch die Verwendung von Interrupts mit Nachrichtensignalen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Interrupt-Verarbeitungsarchitektur für Intel-kompatible Systeme</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430548/">https://habr.com/ru/post/de430548/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430534/index.html">Erstellen einer Vorlage für Zabbix am Beispiel des DVR Trassir SDK</a></li>
<li><a href="../de430536/index.html">Entwerfen von Fensterfunktionen, die zu einer Einheit mit einem bestimmten Überlappungsgrad zusammengefasst werden</a></li>
<li><a href="../de430538/index.html">Lesen Sie Scaladoc für „offensichtliche“ Erfassungsmethoden? Oder warum Faulheit nicht immer gut ist</a></li>
<li><a href="../de430542/index.html">Offenes Webinar „Infrastruktur als Code“</a></li>
<li><a href="../de430546/index.html">"Es wurde angenommen, dass der Code durch UML-Diagramme ersetzt wird, aber es besteht keine Notwendigkeit zum Testen": ein Interview mit Alexei Barantsev</a></li>
<li><a href="../de430550/index.html">Aufbau eines reaktiven Komponentensystems mit Kotlin</a></li>
<li><a href="../de430552/index.html">Start des Tages (September-Oktober 2018)</a></li>
<li><a href="../de430554/index.html">Google patentierte VR-Schuhe, die Sie für immer laufen können</a></li>
<li><a href="../de430556/index.html">GeekBrains startet Produktmanager-Schulungskurs</a></li>
<li><a href="../de430558/index.html">Wie das Scoring in der Carsharing-Branche funktioniert. Teil 1. Überblick über gängige Tools für reale Daten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>