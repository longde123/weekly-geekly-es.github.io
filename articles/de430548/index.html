<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÇüèæ üíª üòß Interrupts von externen Ger√§ten in einem x86-System. Teil 1. Die Entwicklung der Interrupt-Controller üßóüèæ üë®‚Äçüë®‚Äçüëß‚Äçüëß ‚ÑπÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel m√∂chte ich die Interrupt-√úbermittlungsmechanismen von externen Ger√§ten im x86-System betrachten und versuchen, die folgenden Fragen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interrupts von externen Ger√§ten in einem x86-System. Teil 1. Die Entwicklung der Interrupt-Controller</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430548/">  In diesem Artikel m√∂chte ich die Interrupt-√úbermittlungsmechanismen von externen Ger√§ten im x86-System betrachten und versuchen, die folgenden Fragen zu beantworten: <br><br><ul><li>  Was ist PIC und wof√ºr ist es? </li><li>  Was ist APIC und wof√ºr ist es?  Wof√ºr sind LAPIC und I / O APIC? </li><li>  Was sind die Unterschiede zwischen APIC, xAPIC und x2APIC? </li><li>  Was ist MSI?  Was sind die Unterschiede zwischen MSI und MSI-X? </li><li>  Wie h√§ngen die $ PIR-, MPtable- und ACPI-Tabellen damit zusammen? </li></ul><br>  Wenn Sie eine Antwort auf eine dieser Fragen erhalten m√∂chten oder sich nur mit der Entwicklung der Interrupt-Controller im x86-System vertraut machen m√∂chten, sind Sie bei cat willkommen. <br><a name="habracut"></a><br><h3>  Einf√ºhrung </h3><br>  Wir alle wissen, was Unterbrechung ist.  F√ºr diejenigen, die es nicht sind, zitieren Sie aus Wikipedia: <br><br><blockquote> Unterbrechung (englische Unterbrechung) - Ein Signal von Software oder Hardware, das den Prozessor √ºber das Auftreten eines Ereignisses informiert, das sofortige Aufmerksamkeit erfordert.  Eine Unterbrechung benachrichtigt den Prozessor √ºber das Auftreten eines Ereignisses mit hoher Priorit√§t, das eine Unterbrechung des vom Prozessor ausgef√ºhrten aktuellen Codes erfordert.  Der Prozessor reagiert, indem er seine aktuelle Aktivit√§t unterbricht, seinen Status beibeh√§lt und eine Funktion ausf√ºhrt, die als Interrupt-Handler (oder Interrupt-Handler) bezeichnet wird und auf das Ereignis reagiert und es bedient. Danach gibt er die Kontrolle an den unterbrochenen Code zur√ºck. <br><br>  Abh√§ngig von der Quelle des Interrupt-Signals werden sie unterteilt in: <br><br><ul><li>  asynchron oder extern (Hardware) - Ereignisse, die von externen Hardwareger√§ten (z. B. Peripherieger√§ten) stammen und zu einem beliebigen Zeitpunkt auftreten k√∂nnen: ein Signal von einem Timer, einer Netzwerkkarte oder einem Festplattenlaufwerk, Tastenanschl√§ge, Mausbewegungen.  Die Tatsache, dass ein solcher Interrupt im System auftritt, wird als Interrupt Request (IRQ) interpretiert. Ger√§te melden, dass sie die Aufmerksamkeit des Betriebssystems ben√∂tigen. </li><li>  synchrone oder interne Ereignisse im Prozessor selbst infolge der Verletzung bestimmter Bedingungen bei der Ausf√ºhrung von Maschinencode: Division durch Null oder Stapel√ºberlauf, Zugriff auf ung√ºltige Speicheradressen oder ung√ºltigen Operationscode; </li></ul></blockquote>  In diesem Artikel m√∂chte ich externe IRQ-Interrupts diskutieren. <br><br>  Warum werden sie gebraucht?  Angenommen, wir m√∂chten eine Aktion mit einem Eingabepaket f√ºr eine Netzwerkkarte ausf√ºhren, wenn diese eintrifft.  Um die Netzwerkkarte nicht st√§ndig zu fragen: "Haben Sie ein neues Paket?"  Verschwenden Sie keine Prozessorressourcen, Sie k√∂nnen den IRQ-Interrupt verwenden.  Die Ger√§te-Interrupt-Leitung ist mit der INTR-Leitung des Prozessors verbunden, und wenn ein Paket empfangen wird, "zieht" die Netzwerkkarte diese Leitung.  Der Prozessor versteht, dass Informationen daf√ºr vorhanden sind, und liest das Paket. <br><br>  Aber was ist, wenn es viele Ger√§te gibt?  Sie k√∂nnen nicht genug von allen externen Ger√§ten der Prozessorbeine erhalten. <br><br><img src="https://habrastorage.org/webt/vg/3q/3v/vg3q3v7kx8vjttp43xo99o8pccs.png"><br><br>  Um dieses Problem zu l√∂sen, haben sie einen Chip entwickelt - einen Interrupt-Controller. <br><br><h3>  Pic </h3><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wiki</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">osdev</a> ) <br><br>  Der erste war ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intel 8259 PIC-</a> Chip.  8 Eingangsleitungen (IRQ0-7) und ein Ausgang, der den Controller mit der INTR-Leitung des Prozessors verbindet.  Wenn ein Interrupt von einem Ger√§t auftritt, zieht 8259 die INTR-Leitung, der Prozessor versteht, dass ein Ger√§t einen Interrupt signalisiert, und fragt den PIC ab, um zu verstehen, welcher IRQx-Zweig den Interrupt verursacht hat.  Es gibt eine zus√§tzliche Verz√∂gerung f√ºr diese Umfrage, aber die Anzahl der Interrupt-Leitungen erh√∂ht sich auf 8. <br><br><img src="https://habrastorage.org/webt/le/yf/6e/leyf6enogyzp6flpijo2d0x1w9g.png"><br><br>  8 Leitungen erwiesen sich jedoch schnell als klein, und um ihre Anzahl zu erh√∂hen, wurden 2 8259 in Kaskade geschaltete Controller (Master und Slave) (Dual PIC) verwendet. <br><br>  Die IRQs 0 bis 7 werden vom ersten Intel 8259 PIC (Master) und die IRQs 8 bis 15 vom zweiten 8259 PIC (Slave) verarbeitet.  Nur ein Master signalisiert das Auftreten eines Interrupts.  Wenn auf den Leitungen 8-15 ein Interrupt auftritt, signalisiert der zweite PIC (Slave) dem Master √ºber IRQ 2 einen Interrupt, und der Master signalisiert wiederum der CPU.  Dieser kaskadierende Interrupt ben√∂tigt eine der 16 Leitungen, bietet jedoch am Ende 15 verf√ºgbare Interrupts f√ºr Ger√§te. <br><br><img src="https://habrastorage.org/webt/xj/yn/dh/xjyndhabujjwz0alrbx831zfzt8.png"><br><br>  Die Schaltung hat sich etabliert, und das ist es, was sie bedeuten, wenn sie jetzt √ºber PIC (Programm Interrupt Controller) sprechen.  Anschlie√üend erhielten die 8259-Controller einige Verbesserungen und wurden als 8259A bekannt, und diese Schaltung wurde in den Chipsatz aufgenommen.  Zu einer Zeit, als der Hauptbus zum Anschlie√üen externer Ger√§te der ISA-Bus war, reichte ein solches System insgesamt aus.  Es musste nur sichergestellt werden, dass verschiedene Ger√§te nicht mit derselben IRQ-Leitung verbunden waren, um Konflikte zu vermeiden, da ISA-Interrupts nicht gemeinsam genutzt werden. <br><br>  Normalerweise war das Layout von Interrupts f√ºr Ger√§te mehr oder weniger Standard <br><br>  Beispiel ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier genommen</a> ): <br>  IRQ 0 - Systemtimer <br>  IRQ 1 - Tastaturcontroller <br>  IRQ 2 - Kaskade (Interrupt vom Slave-Controller) <br>  IRQ 3 - serielle Schnittstelle COM2 <br>  IRQ 4 - serielle Schnittstelle COM1 <br>  IRQ 5 - Parallelport 2 und 3 oder Soundkarte <br>  IRQ 6 - Diskettenregler <br>  IRQ 7 - Parallelport 1 <br>  IRQ 8 - RTC-Timer <br>  IRQ 9 - ACPI <br>  IRQ 10 - offen / SCSI / NIC <br>  IRQ 11 - offen / SCSI / NIC <br>  IRQ 12 - Mauscontroller <br>  IRQ 13 - Mathe-Co-Prozessor <br>  IRQ 14 - ATA-Kanal 1 <br>  IRQ 15 - ATA-Kanal 2 <br><br>  Die Konfiguration und Arbeit mit 8259 Mikroschaltungen erfolgt √ºber E / A-Ports: <br><div class="scrollable-table"><table><tbody><tr><th>  Chip </th><th>  Registrieren </th><th>  E / A-Port </th></tr><tr><td>  Meisterbild </td><td>  Befehl </td><td>  0x0020 </td></tr><tr><td>  Meisterbild </td><td>  Daten </td><td>  0x0021 </td></tr><tr><td>  Sklavenbild </td><td>  Befehl </td><td>  0x00A0 </td></tr><tr><td>  Sklavenbild </td><td>  Daten </td><td>  0x00A1 </td></tr></tbody></table></div><br>  ‚Üí Die Dokumentation zum 8259A finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier.</a> <br><br>  Der ISA-Bus wurde durch den PCI-Bus ersetzt.  Und die Anzahl der Ger√§te begann deutlich die Zahl 15 zu √ºberschreiten. Im Gegensatz zum statischen ISA-Bus k√∂nnen die Ger√§te in diesem Fall dynamisch zum System hinzugef√ºgt werden.  Gl√ºcklicherweise k√∂nnen in diesem Bus Interrupts gemeinsam genutzt werden (dh mehrere Ger√§te k√∂nnen an dieselbe IRQ-Leitung angeschlossen werden).  Um das Problem des Fehlens von IRQ-Leitungen zu l√∂sen, beschlossen sie, Interrupts von allen PCI-Ger√§ten in PIRQ-Leitungen zu gruppieren (Programmable Interrupt Request). <br><br>  Angenommen, wir haben 4 Interrupt-Leitungen frei auf dem PIC-Controller und 20 PCI-Ger√§te.  Wir kombinieren die Interrupts von 5 Ger√§ten pro PIRQx-Leitung und verbinden die PIRQx-Leitungen mit dem Controller.  Wenn auf der PIRQx-Leitung ein Interrupt auftritt, muss der Prozessor alle an diese Leitung angeschlossenen Ger√§te abfragen, um zu verstehen, von wem der Interrupt stammt. Dies l√∂st jedoch im Allgemeinen das Problem.  Ein Ger√§t, das PCI-Interrupt-Leitungen in einer PIRQ-Leitung bindet, wird h√§ufig als PIR-Router bezeichnet. <br><br>  Bei dieser Methode m√ºssen Sie sicherstellen, dass die PIRQx-Leitungen nicht mit den IRQx-Leitungen verbunden sind, auf denen bereits ISA-Interrupts gestartet wurden (da dies zu Konflikten f√ºhrt), und dass die PIRQx-Leitungen ausgeglichen sind (je mehr Ger√§te wir mit derselben PIRQ-Leitung verbunden haben, desto mehr Ger√§te ben√∂tigen Sie fragt den Prozessor ab, um zu verstehen, welches dieser Ger√§te den Interrupt verursacht hat). <br><br><img src="https://habrastorage.org/webt/u_/jr/u9/u_jru9pemdeda2xvvbqihvgtp3y.png"><br><br>  <b>Hinweis</b> : Das PCI-Ger√§t -&gt; PIR-Mapping wird im Bild abstrakt dargestellt, da es tats√§chlich etwas komplizierter ist.  In der Realit√§t verf√ºgt jedes PCI-Ger√§t √ºber 4 Interrupt-Leitungen (INTA, INTB, INTC, INTD).  Jedes PCI-Ger√§t kann bis zu 8 Funktionen haben, und jetzt hat jede Funktion einen INTx-Interrupt.  Welche INTx jede Funktion des Ger√§ts abruft, h√§ngt von der Konfiguration des Chipsatzes ab. <br><br>  Funktionen sind im Wesentlichen separate logische Bl√∂cke.  Beispielsweise kann in einem PCI-Ger√§t eine Smbus-Controller-Funktion, eine SATA-Controller-Funktion oder eine LPC-Bridge-Funktion vorhanden sein.  Auf der Betriebssystemseite ist jede Funktion ein separates Ger√§t mit einem eigenen Konfigurationsbereich f√ºr die PCI-Konfiguration. <br><br>  Das Betriebssystem √ºbertrug Informationen √ºber Routing-Interrupts im BIOS des PIC-Controllers unter Verwendung der Tabelle $ PIR und durch Ausf√ºllen der Register 3Ch (INT_LN Interrupt Line (R / W)) und 3Dh (INT_PN Interrupt Pin (RO)) des PCI-Konfigurationsraums f√ºr jede Funktion.  Die Spezifikation f√ºr die $ PIR-Tabelle befand sich zuvor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf der Microsoft-Website</a> , ist jetzt jedoch nicht mehr vorhanden.  Der Inhalt der Zeilen der $ PIR-Tabelle kann der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PCI-BIOS-Spezifikation</a> [4.2.2.  Holen Sie sich PCI Interrupt Routing Options] oder lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> <br><br><h3>  Apic </h3><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wiki</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Osdev</a> ) <br><br>  Die vorherige Methode funktionierte, bis Multiprozessorsysteme erschienen.  Tatsache ist, dass PIC in seinem Ger√§t Interrupts nur an einen Hauptprozessor √ºbertragen kann.  Ich m√∂chte jedoch, dass die Belastung der Prozessoren durch die Interrupt-Behandlung ausgeglichen wird.  Die L√∂sung f√ºr dieses Problem war die neue Schnittstelle APIC (Advanced PIC). <br><br>  F√ºr jeden Prozessor wird ein spezieller LAPIC-Controller (Local APIC) und ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">E / A-APIC-</a> Controller hinzugef√ºgt, um Interrupts von Ger√§ten weiterzuleiten.  Alle diese Steuerungen sind in einem gemeinsamen Bus namens APIC zusammengefasst (neue Systeme werden jetzt √ºber einen Standardsystembus verbunden). <br><br>  Wenn ein Interrupt von einem Ger√§t am E / A-APIC-Pin ankommt, leitet die Steuerung den Interrupt an den LAPIC eines der Prozessoren weiter.  Durch das Vorhandensein von E / A-APIC k√∂nnen Sie die Verteilung von Interrupts von externen Ger√§ten zwischen Prozessoren ausgleichen. <br><br>  Der erste APIC-Chip war <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">82489DX</a> , ein separater Chip, der LAPIC und I / O-APIC kombiniert.  Um ein System von 2 Prozessoren zu erstellen, wurden 3 solcher Mikroschaltungen ben√∂tigt.  2 w√ºrde als LAPIC und eine als I / O APIC fungieren.  Sp√§ter wurde die LAPIC-Funktionalit√§t direkt in die Prozessoren integriert, und die E / A-APIC-Funktionalit√§t wurde in den 82093AA-Chip integriert. <br><br>  Der E / A-APIC <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">82093AA</a> enthielt 24 Eingangspins, und die APIC-Architektur konnte bis zu 16 CPUs unterst√ºtzen.  Um die Kompatibilit√§t mit √§lteren Systemen aufrechtzuerhalten, wurden alten ISA-Interrupts 0 bis 15 Interrupts zugewiesen.  In der IRQ-Zeile 16-23 wurden Unterbrechungen durch PCI-Ger√§te angezeigt.  Jetzt war es m√∂glich, nicht an Interrupt-Konflikte von ISA- und PCI-Ger√§ten zu denken.  Dank der erh√∂hten Anzahl freier Interrupt-Leitungen ist es auch m√∂glich geworden, die Anzahl der PIRQx-Leitungen zu erh√∂hen. <br><br><img src="https://habrastorage.org/webt/mc/ra/hj/mcrahjn-owk9qrcmyiixcmhomcq.png"><br><br>  Die E / A-APIC- und LAPIC-Programmierung erfolgt √ºber MMIO.  LAPIC-Register befinden sich normalerweise bei 0xFEE00000, E / A-APIC-Register bei 0xFE00000.  Grunds√§tzlich k√∂nnen jedoch alle diese Adressen neu konfiguriert werden. <br><br>  Wie bei PIC wurden zun√§chst einzelne Chips sp√§ter Teil des Chipsatzes. <br><br>  Anschlie√üend wurde die APIC-Architektur modernisiert und die neue Version hie√ü xAPIC (x - erweitert).  Abw√§rtskompatibilit√§t mit der vorherigen Version beibehalten.  Die Anzahl der m√∂glichen CPUs im System wurde auf 256 erh√∂ht. <br><br>  Die n√§chste Runde der Architekturentwicklung hie√ü <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">x2APIC</a> .  Die Anzahl der m√∂glichen CPUs im System wurde auf 2 ^ 32 erh√∂ht.  Die Controller k√∂nnen im xAPIC-Kompatibilit√§tsmodus oder im neuen x2APIC-Modus arbeiten, in dem die LAPIC-Programmierung nicht √ºber MMIO, sondern √ºber MSR-Register (was viel schneller ist) erfolgt.  Nach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Link zu</a> urteilen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, ist</a> IOMMU-Unterst√ºtzung erforderlich, damit dieser Modus funktioniert. <br><br>  Es ist zu beachten, dass das System m√∂glicherweise √ºber mehrere E / A-APIC-Controller verf√ºgt.  Zum Beispiel eine f√ºr 24 Unterbrechungen in der S√ºdbr√ºcke, die andere f√ºr 32 im Norden.  Im Zusammenhang mit E / A werden APIC-Interrupts h√§ufig als GSI (Global System Interrupt) bezeichnet.  In einem solchen System wird also GSI 0-55 sein. <br><br>  Gibt es eine eingebaute LAPIC in der CPU und welche Architektur von den Bit-Flags in der CPUID verstanden werden kann. <br>  Damit das System LAPIC und E / A-APIC erkennen kann, muss das BIOS dem System Informationen √ºber diese entweder √ºber die MPtable (die alte Methode) oder √ºber die ACPI-Tabelle (in diesem Fall MADT) bereitstellen.  Zus√§tzlich zu allgemeinen Informationen sollten sowohl die MPtable als auch die ACPI (diesmal in der DSDT-Tabelle) Informationen zum Interrupt-Routing enthalten, dh Informationen dar√ºber, welches Ger√§t auf welcher Interrupt-Leitung sitzt (analog zur $ PIR-Tabelle). <br><br>  Die MPTable-Tabelle finden Sie in der offiziellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20121002210153/">Spezifikation</a> .  Fr√ºher befand sich die Spezifikation auf der Intel-Website, jetzt ist sie nur noch im Archiv zu finden.  Die ACPI-Spezifikation befindet sich jetzt auf der UEFI-Website (aktuelle Version <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6.2</a> ).  Es ist zu beachten, dass Sie mit ACPI das Interrupt-Routing f√ºr Systeme ohne APIC festlegen k√∂nnen (anstatt die Tabelle $ PIR zu verwenden). <br><br><h3>  Msi </h3><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wiki</a> ) <br><br>  Die vorherige Version mit APIC ist gut, aber nicht ohne M√§ngel.  Alle diese Ger√§teunterbrechungsleitungen komplizieren die Schaltung und erh√∂hen die Fehlerwahrscheinlichkeit.  Der PCI-Bus wurde durch PCI Express ersetzt, bei dem die Interrupt-Leitungen einfach entfernt werden sollten.  Um die Kompatibilit√§t zu gew√§hrleisten, werden Interrupt-Signale (INTx #) von bestimmten Nachrichtentypen emuliert.  In diesem Schema fiel die logische Hinzuf√ºgung von Interrupt-Leitungen, die fr√ºher durch physische Verbindung von Dr√§hten erfolgte, auf die Schultern von PCI-Br√ºcken.  Die Unterst√ºtzung √§lterer INTx-Interrupts ist jedoch nur Unterst√ºtzung f√ºr die Abw√§rtskompatibilit√§t mit dem PCI-Bus.  Tats√§chlich hat PCI Express eine neue Methode zur Zustellung von Interrupt-Nachrichten vorgeschlagen - MSI (Message Signaled Interrupts).  Bei dieser Methode schreibt das Ger√§t einfach in den MMIO-Bereich, der dem Prozessor-LAPIC zugewiesen ist, um eine Unterbrechung zu signalisieren. <br><br><img src="https://habrastorage.org/webt/8z/qw/7h/8zqw7him-vupzm_wi5glkqtr1ja.png"><br><br>  Fr√ºher wurden einem PCI-Ger√§t (dh allen seinen Funktionen) nur 4 Interrupts zugewiesen, jetzt k√∂nnen jetzt bis zu 32 Interrupts adressiert werden. <br><br>  Bei MSI gibt es keine gemeinsame Nutzung f√ºr die Leitungen, jeder Interrupt entspricht seinem Ger√§t. <br><br>  MSI-Interrupts l√∂sen auch ein anderes Problem.  Angenommen, ein Ger√§t f√ºhrt eine Speicherschreibtransaktion durch und m√∂chte seinen Abschluss √ºber einen Interrupt melden.  Eine Schreibtransaktion auf dem Bus kann jedoch w√§hrend des √úbertragungsprozesses (von dem das Ger√§t √ºberhaupt nichts wei√ü) verz√∂gert sein, und das Interrupt-Signal wird vor dem Prozessor eintreffen.  Somit liest die CPU immer noch ung√ºltige Daten.  Wenn MSI verwendet wird, werden Informationen √ºber MSI sowie Daten √ºbertragen und k√∂nnen einfach nicht fr√ºher eingehen. <br><br>  Es sollte beachtet werden, dass MSI-Interrupts ohne LAPIC nicht funktionieren k√∂nnen, aber die Verwendung von MSI kann uns durch I / O-APIC ersetzen (Design-Vereinfachung). <br><br>  Anschlie√üend erhielt diese Methode die MSI-X-Erweiterung.  Jetzt kann jedes Ger√§t bis zu 2048 Interrupts haben.  Und es wurde m√∂glich, jedem Interrupt einzeln anzugeben, auf welchem ‚Äã‚ÄãProzessor er ausgef√ºhrt werden soll.  Dies kann f√ºr stark belastete Ger√§te wie Netzwerkkarten sehr n√ºtzlich sein. <br><br>  F√ºr die MSI-Unterst√ºtzung sind keine zus√§tzlichen BIOS-Tabellen erforderlich.  Das Ger√§t muss jedoch die MSI-Unterst√ºtzung in einer der Funktionen in seiner PCI-Konfiguration melden, und der Ger√§tetreiber muss die Arbeit mit MSI unterst√ºtzen. <br><br><h3>  Fazit </h3><br>  In diesem Artikel haben wir die Entwicklung von Interrupt-Controllern untersucht und allgemeine theoretische Informationen zur √úbermittlung von Interrupts von externen Ger√§ten in einem x86-System erhalten. <br><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">n√§chsten Teil werden</a> wir uns ansehen, wie jeder der beschriebenen Controller in der Praxis unter Linux verwendet wird. <br><br><h4>  Referenzen: </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Interrupt Controller (Sachen in der Mitte)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was machen die verschiedenen Interrupts in PCIe?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reduzierung der Interrupt-Latenz durch die Verwendung von Interrupts mit Nachrichtensignalen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Interrupt-Verarbeitungsarchitektur f√ºr Intel-kompatible Systeme</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430548/">https://habr.com/ru/post/de430548/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430534/index.html">Erstellen einer Vorlage f√ºr Zabbix am Beispiel des DVR Trassir SDK</a></li>
<li><a href="../de430536/index.html">Entwerfen von Fensterfunktionen, die zu einer Einheit mit einem bestimmten √úberlappungsgrad zusammengefasst werden</a></li>
<li><a href="../de430538/index.html">Lesen Sie Scaladoc f√ºr ‚Äûoffensichtliche‚Äú Erfassungsmethoden? Oder warum Faulheit nicht immer gut ist</a></li>
<li><a href="../de430542/index.html">Offenes Webinar ‚ÄûInfrastruktur als Code‚Äú</a></li>
<li><a href="../de430546/index.html">"Es wurde angenommen, dass der Code durch UML-Diagramme ersetzt wird, aber es besteht keine Notwendigkeit zum Testen": ein Interview mit Alexei Barantsev</a></li>
<li><a href="../de430550/index.html">Aufbau eines reaktiven Komponentensystems mit Kotlin</a></li>
<li><a href="../de430552/index.html">Start des Tages (September-Oktober 2018)</a></li>
<li><a href="../de430554/index.html">Google patentierte VR-Schuhe, die Sie f√ºr immer laufen k√∂nnen</a></li>
<li><a href="../de430556/index.html">GeekBrains startet Produktmanager-Schulungskurs</a></li>
<li><a href="../de430558/index.html">Wie das Scoring in der Carsharing-Branche funktioniert. Teil 1. √úberblick √ºber g√§ngige Tools f√ºr reale Daten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>