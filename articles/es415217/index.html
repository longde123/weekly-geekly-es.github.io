<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚óºÔ∏è ü§ûüèª üóæ Creando un gancho de gato en Unity. Parte 2 üõèÔ∏è üîû üë®üèø‚Äçüöí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nota : este tutorial est√° destinado a usuarios avanzados y experimentados, y no cubre temas como agregar componentes, crear nuevos scripts de GameObje...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Creando un gancho de gato en Unity. Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415217/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db0/187/d5e/db0187d5e9f5fc2bfa78b078dcb2a178.png" alt="imagen"></div><br><blockquote> <em>Nota</em> : este tutorial est√° destinado a usuarios avanzados y experimentados, y no cubre temas como agregar componentes, crear nuevos scripts de GameObject y sintaxis de C #.  Si necesita mejorar sus habilidades de Unity, consulte nuestros tutoriales de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introducci√≥n a Unity</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introducci√≥n a las secuencias de comandos de Unity</a> . </blockquote><br>  En la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera parte del</a> tutorial, aprendimos c√≥mo crear un gancho para gatos con la mec√°nica de envolver una cuerda alrededor de los obst√°culos.  Sin embargo, queremos m√°s: la cuerda puede envolver objetos a nivel, pero no se desprende cuando regresa. <br><a name="habracut"></a><br><h2>  Llegar al trabajo </h2><br>  Abra el proyecto terminado desde la primera parte en Unity o descargue el <a href="">borrador</a> para esta parte del tutorial, luego abra <em>2DGrapplingHook-Part2-Starter</em> .  Como en la primera parte, utilizaremos Unity versi√≥n 2017.1 o superior. <br><br>  Abra la escena del <em>juego</em> en el editor desde la carpeta del proyecto <em>Escenas</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/89c/ee3/48c/89cee348caa1656418bcc0ded8e91bab.png"></div><br>  Inicie la escena del juego e intente enganchar el gancho del gato en las piedras sobre el personaje, y luego balancee para que la cuerda se enrolle alrededor de un par de bordes de piedra. <br><br>  Cuando regreses, notar√°s que los puntos de la piedra a trav√©s de los cuales la cuerda sol√≠a girar no se vuelven a desenganchar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e9/d83/da7/4e9d83da7eda544a3f48cecbf3e64b08.gif"></div><br>  Piensa en el punto en el que la cuerda debe desplegarse.  Para simplificar la tarea, es mejor usar el estuche cuando la cuerda se enrolla alrededor de los bordes. <br><br>  Si la babosa, que se aferra a una piedra sobre su cabeza, se balancea hacia la derecha, entonces la cuerda se doblar√° despu√©s del umbral en el que cruza el √°ngulo de 180 grados con la costilla a la que est√° unida la babosa.  En la figura siguiente, se muestra con un punto verde resaltado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3eb/257/132/3eb25713213c01fb76fb97c49e6958cf.png"></div><br>  Cuando la babosa se balancea en la otra direcci√≥n, la cuerda debe desengancharse nuevamente en el mismo punto (resaltado en rojo en la figura anterior): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ef/ad3/e22/2efad3e22fddf83cefcf52fca6175792.png"></div><br><h2>  La l√≥gica de desenrollar </h2><br>  Para calcular el momento en que necesita desenrollar la cuerda en los puntos sobre los que se envolvi√≥ anteriormente, necesitamos conocimientos de geometr√≠a.  En particular, utilizaremos una comparaci√≥n de √°ngulos para determinar cu√°ndo la cuerda debe separarse del borde. <br><br>  Esta tarea puede parecer un poco intimidante.  Las matem√°ticas pueden inspirar horror y desesperaci√≥n incluso en los m√°s valientes. <br><br>  Afortunadamente, Unity tiene excelentes funciones de ayuda matem√°tica que pueden hacernos la vida un poco m√°s f√°cil. <br><br>  Abra el script <em>RopeSystem</em> en el IDE y cree un nuevo m√©todo llamado <code>HandleRopeUnwrap()</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleRopeUnwrap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br>  Vaya a <code>Update()</code> y agregue al final una llamada a nuestro nuevo m√©todo. <br><br><pre> <code class="cs hljs">HandleRopeUnwrap();</code> </pre> <br>  Si bien <code>HandleRopeUnwrap()</code> no hace nada, ahora podemos procesar la l√≥gica asociada con todo el proceso de separaci√≥n de los bordes. <br><br>  Como recordar√° en la primera parte del tutorial, almacenamos las posiciones de envoltura de la cuerda en una colecci√≥n llamada <code>ropePositions</code> , que es una colecci√≥n <code>List&lt;Vector2&gt;</code> .  Cada vez que una cuerda se enrolla alrededor de un borde, mantenemos la posici√≥n de este punto de envoltura en esta colecci√≥n. <br><br>  Para que el proceso sea m√°s eficiente, no ejecutaremos ninguna l√≥gica en <code>HandleRopeUnwrap()</code> si el n√∫mero de posiciones almacenadas en la colecci√≥n es igual o menor que 1. <br><br>  En otras palabras, cuando la bala se ha enganchado al punto de partida y su cuerda a√∫n no se ha enrollado alrededor de los bordes, el n√∫mero de <code>ropePositions</code> de la <code>ropePositions</code> ser√° 1, y no seguiremos la l√≥gica de procesamiento de desenrollado. <br><br>  Agregue esta simple <code>return</code> a la parte superior de <code>HandleRopeUnwrap()</code> para guardar ciclos de CPU valiosos, porque este m√©todo se llama desde <code>Update()</code> muchas veces por segundo. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ropePositions.Count &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><h3>  Agregar nuevas variables </h3><br>  Bajo esta nueva prueba, agregaremos algunas dimensiones y referencias a los diferentes √°ngulos necesarios para implementar la base de la l√≥gica de desenrollado.  Agregue el siguiente c√≥digo a <code>HandleRopeUnwrap()</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Hinge =       // Anchor =     Hinge // Hinge Angle =   anchor  hinge // Player Angle =   anchor  player // 1 var anchorIndex = ropePositions.Count - 2; // 2 var hingeIndex = ropePositions.Count - 1; // 3 var anchorPosition = ropePositions[anchorIndex]; // 4 var hingePosition = ropePositions[hingeIndex]; // 5 var hingeDir = hingePosition - anchorPosition; // 6 var hingeAngle = Vector2.Angle(anchorPosition, hingeDir); // 7 var playerDir = playerPosition - anchorPosition; // 8 var playerAngle = Vector2.Angle(anchorPosition, playerDir);</span></span></code> </pre> <br>  Aqu√≠ hay muchas variables, por lo que explicar√© cada una de ellas y agregar√© una ilustraci√≥n conveniente que ayudar√° a comprender su prop√≥sito. <br><br><ol><li>  <code>anchorIndex</code> es el √≠ndice en la colecci√≥n <code>ropePositions</code> en dos posiciones desde el final de la colecci√≥n.  Podemos considerarlo como un punto en dos posiciones de la cuerda desde la posici√≥n de la bala.  En la figura siguiente, este es el primer punto de uni√≥n del gancho a la superficie.  Al llenar la colecci√≥n <code>ropePositions</code> nuevos puntos de envoltura, este punto siempre ser√° el punto de envoltura a una distancia de dos posiciones de la bala. </li><li>  <code>hingeIndex</code> es el √≠ndice de la colecci√≥n que almacena el punto de la bisagra actual;  en otras palabras, la posici√≥n en la que la cuerda se enrolla actualmente alrededor del punto m√°s cercano al extremo de la cuerda de la bala.  Siempre est√° a una distancia de una posici√≥n de la bala, por eso usamos <code>ropePositions.Count - 1</code> . </li><li>  <code>anchorPosition</code> calcula haciendo referencia al lugar <code>anchorIndex</code> en la colecci√≥n <code>ropePositions</code> y es el valor simple de Vector2 de esa posici√≥n. </li><li>  <code>hingePosition</code> calcula haciendo referencia al lugar de <code>hingeIndex</code> en la colecci√≥n <code>ropePositions</code> y es el valor simple de Vector2 de esa posici√≥n. </li><li>  <code>hingeDir</code> es un vector dirigido desde <code>anchorPosition</code> a <code>hingePosition</code> .  Se usa en la siguiente variable para obtener el √°ngulo. </li><li>  <code>hingeAngle</code> : la √∫til funci√≥n auxiliar <code>Vector2.Angle()</code> se usa aqu√≠ para calcular el √°ngulo entre <code>anchorPosition</code> y el punto de bisagra. </li><li>  <code>playerDir</code> es un vector dirigido desde <code>anchorPosition</code> a la posici√≥n actual de la babosa (playerPosition) </li><li>  Luego, usando el √°ngulo entre el punto de anclaje y el jugador (slug), <code>playerAngle</code> calcula <code>playerAngle</code> . </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73f/207/4c4/73f2074c470b3016bcd5ee386ce240e8.png"></div><br>  Todas estas variables se calculan utilizando las posiciones almacenadas como valores de Vector2 en la colecci√≥n <code>ropePositions</code> y comparando estas posiciones con otras posiciones o la posici√≥n actual del jugador (slug). <br><br>  Las dos variables importantes utilizadas para la comparaci√≥n son <code>hingeAngle</code> y <code>hingeAngle</code> . <br><br>  El valor almacenado en <code>hingeAngle</code> debe permanecer est√°tico porque siempre es un √°ngulo constante entre el punto en los dos "pliegues de la cuerda" de la barra y el "doblez de la cuerda" m√°s cercano a la barra que no se mueve hasta que la cuerda se desenrosca o despu√©s de doblar Se agregar√° un nuevo punto de curvatura. <br><br>  Cuando la babosa se <code>playerAngle</code> cambia.  Al comparar este √°ngulo con <code>hingeAngle</code> , y tambi√©n verificar si la barra est√° a la izquierda o derecha de esta esquina, podemos determinar si el punto de plegado actual m√°s cercano a la barra debe separarse. <br><br>  En la primera parte de este tutorial, guardamos las posiciones de plegado en un diccionario llamado <code>wrapPointsLookup</code> .  Cada vez que guardamos el punto de plegado, lo agregamos al diccionario con la posici√≥n como clave y con 0 como valor.  Sin embargo, este valor de 0 era bastante misterioso, ¬øverdad? <br><br>  Utilizaremos este valor para almacenar la posici√≥n de la babosa en relaci√≥n con su √°ngulo con el punto de bisagra (el punto de plegado actual m√°s cercano a la babosa). <br><br>  Si asigna un valor de <em>-1</em> , entonces el √°ngulo de la babosa ( <code>playerAngle</code> ) es menor que el √°ngulo de la bisagra ( <code>hingeAngle</code> ), y con un valor de <em>1, el</em> √°ngulo de <code>playerAngle</code> mayor que <code>hingeAngle</code> . <br><br>  Debido al hecho de que guardamos los valores en el diccionario, cada vez que comparamos <code>hingeAngle</code> con <code>hingeAngle</code> , podemos entender si la bala acaba de pasar el l√≠mite despu√©s del cual la cuerda debe desengancharse. <br><br>  Se puede explicar de manera diferente: si el √°ngulo de la bala acaba de comprobarse y es m√°s peque√±o que el √°ngulo de la bisagra, pero la √∫ltima vez que se guard√≥ en el diccionario de puntos de plegado se marc√≥ con un valor que indica que estaba en el otro lado de esta esquina, entonces el punto debe eliminarse inmediatamente ! <br><br><h3>  Cuerda de desacoplamiento </h3><br>  Echa un vistazo a la captura de pantalla a continuaci√≥n con notas.  Nuestra babosa se aferr√≥ a la roca, se balance√≥ hacia arriba, envolviendo una cuerda alrededor del borde de la roca en su camino. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db0/187/d5e/db0187d5e9f5fc2bfa78b078dcb2a178.png"></div><br>  Puede notar que en la posici√≥n de oscilaci√≥n m√°s alta, donde la bala es opaca, su punto de plegado m√°s cercano actual (marcado con un punto blanco) se almacenar√° en el diccionario <code>wrapPointsLookup</code> con un valor de <em>1</em> . <br><br>  En el camino hacia abajo, cuando <code>playerAngle</code> vuelve m√°s peque√±o que <code>hingeAngle</code> (dos l√≠neas verdes discontinuas), como se muestra con la flecha azul, se realiza una verificaci√≥n, y si el √∫ltimo valor (actual) del punto de curvatura era <em>1</em> , entonces el punto de curvatura deber√≠a eliminarse. <br><br>  Ahora implementemos esta l√≥gica en el c√≥digo.  Pero antes de comenzar, creemos un espacio en blanco del m√©todo que usaremos para desconectar.  Debido a esto, despu√©s de crear la l√≥gica, no dar√° lugar a un error. <br><br>  Agregue un nuevo m√©todo <code>UnwrapRopePosition(anchorIndex, hingeIndex)</code> insertando las siguientes l√≠neas: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnwrapRopePosition</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> anchorIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hingeIndex</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  Una vez hecho esto, regrese a <code>HandleRopeUnwrap()</code> .  Bajo las variables reci√©n agregadas, agregue la siguiente l√≥gica, que manejar√° dos casos: <code>playerAngle</code> menos que <code>hingeAngle</code> y <code>hingeAngle</code> m√°s que <code>hingeAngle</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (playerAngle &lt; hingeAngle) { <span class="hljs-comment"><span class="hljs-comment">// 1 if (wrapPointsLookup[hingePosition] == 1) { UnwrapRopePosition(anchorIndex, hingeIndex); return; } // 2 wrapPointsLookup[hingePosition] = -1; } else { // 3 if (wrapPointsLookup[hingePosition] == -1) { UnwrapRopePosition(anchorIndex, hingeIndex); return; } // 4 wrapPointsLookup[hingePosition] = 1; }</span></span></code> </pre> <br>  Este c√≥digo debe corresponder a la explicaci√≥n de la l√≥gica descrita anteriormente para el primer caso (cuando <code>hingeAngle</code> &lt; <code>hingeAngle</code> ), pero tambi√©n maneja el segundo caso (cuando <code>hingeAngle</code> &gt; <code>hingeAngle</code> ). <br><br><ol><li>  Si el punto de plegado actual m√°s cercano a la babosa tiene un valor de <em>1</em> en el punto donde <code>hingeAngle</code> &lt; <code>hingeAngle</code> , entonces eliminamos este punto y realizamos un retorno para que el resto del m√©todo no se ejecute. </li><li>  De lo contrario, si el punto de inflexi√≥n no se marc√≥ por √∫ltima vez con un valor de <em>1</em> , pero <code>playerAngle</code> menor que <code>hingeAngle</code> , entonces <em>se</em> asigna <em>-1</em> . </li><li>  Si el punto de plegado actual m√°s cercano a la babosa es <em>-1</em> en el punto donde <code>hingeAngle</code> &gt; <code>hingeAngle</code> , entonces elimine el punto y regrese. </li><li>  De lo contrario, asignamos las entradas en el diccionario de puntos de plegado en la posici√≥n de bisagra a <em>1</em> . </li></ol><br>  Este c√≥digo garantiza que el diccionario <code>wrapPointsLookup</code> siempre se actualice, asegurando que el valor del punto de plegado actual (m√°s cercano a la barra) coincida con el √°ngulo de barra actual en relaci√≥n con el punto de curvatura. <br><br>  No olvide que el valor es -1 cuando el √°ngulo del slug es menor que el √°ngulo de la bisagra (en relaci√≥n con el punto de referencia) y 1 cuando el √°ngulo del slug es mayor que el √°ngulo de la bisagra. <br><br>  Ahora <code>UnwrapRopePosition()</code> en el script <em>RopeSystem con un</em> c√≥digo que se enganchar√° directamente, desacoplando la posici√≥n de referencia y asignando un nuevo valor de distancia al valor de distancia de la cuerda DistanceJoint2D.  Agregue las siguientes l√≠neas al disco de m√©todo creado anteriormente: <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">// 1 var newAnchorPosition = ropePositions[anchorIndex]; wrapPointsLookup.Remove(ropePositions[hingeIndex]); ropePositions.RemoveAt(hingeIndex); // 2 ropeHingeAnchorRb.transform.position = newAnchorPosition; distanceSet = false; // Set new rope distance joint distance for anchor position if not yet set. if (distanceSet) { return; } ropeJoint.distance = Vector2.Distance(transform.position, newAnchorPosition); distanceSet = true;</span></span></code> </pre> <br><ol><li>  El √≠ndice del punto de anclaje actual (la segunda posici√≥n de la cuerda desde la bala) se convierte en la nueva posici√≥n de la bisagra, y se elimina la posici√≥n anterior de la bisagra (la que antes estaba m√°s cerca de la bala y que ahora estamos "desenroscando").  A la variable <code>newAnchorPosition</code> asigna el valor <code>anchorIndex</code> en la lista de posiciones de la cuerda.  Luego se usar√° para posicionar la posici√≥n actualizada del punto de anclaje. </li><li>  La junta de cuerda RigidBody2D (a la que se une la cuerda DistanceJoint2D) cambia su posici√≥n a la nueva posici√≥n del punto de anclaje.  Esto garantiza un movimiento continuo y suave de la bala en la cuerda cuando est√° conectada a DistanceJoint2D, y esta conexi√≥n deber√≠a permitirle seguir balance√°ndose en relaci√≥n con la nueva posici√≥n, que se convirti√≥ en la referencia, en otras palabras, en relaci√≥n con el siguiente punto hacia abajo de la cuerda desde su posici√≥n. </li><li>  Luego, debe actualizar el valor de distancia distanceJoint2D para tener en cuenta un cambio brusco en la distancia desde la bala hasta el nuevo punto de referencia.  Si esto a√∫n no se ha hecho, se realiza una comprobaci√≥n r√°pida del indicador <code>distanceSet</code> , y a la distancia se le asigna el valor de la distancia calculada entre el slug y la nueva posici√≥n del punto de anclaje. </li></ol><br>  Guarde el script y regrese al editor.  ¬°Comienza el juego nuevamente y observa c√≥mo la cuerda se desprende de los bordes cuando la bala supera los valores de umbral de cada punto de curvatura! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65b/4af/3a1/65b4af3a13e464947b394595dc052a06.gif"></div><br>  Aunque la l√≥gica est√° lista, agregaremos un c√≥digo auxiliar a <code>HandleRopeUnwrap()</code> justo antes de comparar <code>hingeAngle</code> con <code>hingeAngle</code> ( <code>if (playerAngle &lt; hingeAngle)</code> ). <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!wrapPointsLookup.ContainsKey(hingePosition)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"We were not tracking hingePosition ("</span></span> + hingePosition + <span class="hljs-string"><span class="hljs-string">") in the look up dictionary."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br>  En realidad, esto no deber√≠a suceder, porque redefinimos y desconectamos el gancho de gato cuando se enrolla alrededor de una costilla dos veces, pero si esto sigue sucediendo, podemos salir f√°cilmente de este m√©todo con una simple <code>return</code> y un mensaje de error en la consola <br><br>  Adem√°s, gracias a esto, manejaremos m√°s convenientemente tales casos limitantes;  Adem√°s, recibimos nuestro propio mensaje de error en caso de que ocurra algo innecesario. <br><br><h2>  ¬øA d√≥nde ir despu√©s? </h2><br>  Aqu√≠ hay un <a href="">enlace al proyecto terminado de</a> esta segunda y √∫ltima parte del tutorial. <br><br>  ¬°Felicitaciones por completar esta serie de tutoriales!  Cuando se trataba de comparar √°ngulos y posiciones, todo se volvi√≥ bastante complicado, pero sobrevivimos a esto y ahora tenemos un maravilloso sistema de gancho y cuerda que puede terminar en objetos en el juego. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5f/69a/cbe/b5f69acbefc9de390ff25f0fbc4cbe10.png"></div><br>  ¬øSab√≠as que nuestro equipo de desarrollo de Unity ha escrito un libro?  Si no, echa un vistazo a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Unity Games By Tutorials</a> .  Este juego te ense√±ar√° c√≥mo crear cuatro juegos listos para usar desde cero: <br><br><ul><li>  Tirador de dos palos </li><li>  Tirador en primera persona </li><li>  Juego de defensa de la torre (con soporte VR) </li><li>  Juego de plataformas 2D </li></ul><br>  ¬°Despu√©s de leer este libro, aprender√° c√≥mo crear sus propios juegos para Windows, macOS, iOS y otras plataformas! <br><br>  Este libro est√° destinado tanto a principiantes como a aquellos que desean actualizar sus habilidades de Unity a un nivel profesional.  Para dominar el libro necesitas tener experiencia en programaci√≥n (en cualquier idioma). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es415217/">https://habr.com/ru/post/es415217/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es415207/index.html">Cuando el cielo ha perdido la perfecci√≥n</a></li>
<li><a href="../es415209/index.html">"Necesitaba proteger una habitaci√≥n vac√≠a": la aparici√≥n de trabajos sin sentido</a></li>
<li><a href="../es415211/index.html">La V√≠a L√°ctea esconde decenas de miles de agujeros negros.</a></li>
<li><a href="../es415213/index.html">Las elecciones no funcionan en absoluto; las matem√°ticas deben ser culpadas</a></li>
<li><a href="../es415215/index.html">Universidad de Michigan presenta la computadora m√°s peque√±a del mundo</a></li>
<li><a href="../es415219/index.html">C√≥mo recib√≠ una oferta de un conocido editor extranjero para convertirme en autor de un curso en l√≠nea</a></li>
<li><a href="../es415221/index.html">Semana de la seguridad 23: 50 mil millones de dispositivos IoT</a></li>
<li><a href="../es415223/index.html">Embudo de ventas</a></li>
<li><a href="../es415227/index.html">Ecosistema de desarrollo en 2018: lo que viven los programadores en Rusia y en el mundo</a></li>
<li><a href="../es415229/index.html">DevTube - Nuevo agregador de video de c√≥digo abierto para desarrolladores</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>