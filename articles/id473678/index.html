<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍⚖️ 🚶🏽 💨 Sistem untuk menerima salinan memori di perangkat yang menjalankan Android melalui saluran nirkabel 🏐 ⛪️ 🎍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 


 Perangkat seluler - ponsel cerdas, tablet, dan perangkat seluler lainnya - menjadi bagian integral dari kehidupan manusia. Hampir 67% ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistem untuk menerima salinan memori di perangkat yang menjalankan Android melalui saluran nirkabel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473678/"><h1>  Pendahuluan </h1><br><p>  Perangkat seluler - ponsel cerdas, tablet, dan perangkat seluler lainnya - menjadi bagian integral dari kehidupan manusia.  Hampir 67% orang di dunia memiliki setidaknya satu smartphone;  5,8 miliar perangkat seluler aktif diperkirakan pada tahun 2025 [1]. </p><br><p>  Menurut IDC [2], dari semua perangkat seluler yang dijual pada kuartal ketiga 2018, 86,8% dilengkapi dengan OS Android.  Jumlah pengguna yang menggunakan OS Android lebih dari 1,4 miliar.  Menurut Securelist [3], pada 2018, 5,3 juta paket perangkat lunak berbahaya untuk keluarga Android OS terdeteksi.  Oleh karena itu, seorang spesialis di bidang forensik komputer harus menggunakan metode yang berbeda untuk mengekstraksi salinan memori untuk setiap perangkat. </p><br><p>  Saat ini, tidak ada cara untuk mendapatkan salinan memori secara seragam dari perangkat yang menjalankan OS Android.  Dalam hal ini, seorang spesialis dalam forensik komputer harus menggunakan banyak metode yang berbeda, di mana ia dihadapkan dengan masalah teknis.  Pertama-tama, masalah terkait dengan kurangnya driver atau dengan kerusakan konektor USB yang digunakan dalam metode tradisional untuk ekstraksi data.  Namun, untuk mendapatkan dan mengirimkan salinan memori, Anda dapat menggunakan saluran komunikasi nirkabel [4]. </p><a name="habracut"></a><br><p>  Bagian 1 akan menjelaskan arsitektur OS Android, skenario untuk menggunakan RAM, struktur data yang terkandung dalam RAM, perangkat lunak untuk mendapatkan salinan memori, dan perangkat lunak untuk mentransmisikan data. </p><br><p>  Bagian 2 akan menjelaskan arsitektur suatu sistem untuk mendapatkan salinan RAM, koneksi antara subsistem dan modul. </p><br><p>  Bagian 3 akan menjelaskan implementasi sistem untuk mendapatkan salinan RAM. </p><br><h1>  Bagian 1: Mengeksplorasi cara untuk mendapatkan salinan memori di perangkat yang menjalankan OS Android melalui saluran nirkabel </h1><br><p>  Bagian ini membahas perangkat lunak untuk memperoleh salinan memori dan perbandingannya, protokol jaringan untuk mentransfer salinan RAM, cara menjalankan file yang dapat dieksekusi melalui koneksi nirkabel untuk OS Android, struktur RAM, dan juga skenario untuk menggunakan salinan RAM. </p><br><h2>  Skenario untuk menggunakan salinan RAM </h2><br><p>  Saat ini, sistem operasi Android hadir pada perangkat yang berbeda berkat kernel Linux dan mesin virtual Dalvik.  Makalah ini membahas perangkat yang berjalan pada platform perangkat keras ARM dan x86 yang paling umum. </p><br><p>  Salinan memori adalah data biner terstruktur yang sulit untuk dianalisis tanpa alat khusus yang sesuai.  Pada saat penulisan ini, perangkat memiliki ukuran RAM tidak lebih dari sepuluh gigabyte, yang secara signifikan meningkatkan waktu analisis salinan RAM ukuran ini.  Saat ini, tidak ada cara tunggal untuk menganalisis semua struktur RAM.  Untuk analisis RAM yang lengkap membutuhkan penggunaan beberapa alat perangkat lunak. </p><br><p>  Tidak ada jaminan untuk analisis yang berhasil dari salinan RAM, bahkan jika Anda memiliki semua alat yang diperlukan karena masalah pada tahap memperoleh salinan memori.  Jika tidak ada kemungkinan untuk terhubung ke perangkat atau ada risiko besar kerusakan data, maka cara nirkabel untuk mendapatkan salinan memori tetap menjadi satu-satunya dan aman.  Sayangnya, saat ini tidak ada alat perangkat lunak untuk secara otomatis menerima salinan memori melalui komunikasi nirkabel. </p><br><p>  Salinan dapat digunakan dalam forensik komputer.  Misalnya, jika data pada perangkat yang diteliti dienkripsi, salinan memori dapat membantu mendekripsi data yang berisi kata sandi dan kunci kriptografi [5].  Setiap aplikasi yang memproses data pribadi menggunakan enkripsi data.  Memiliki gambar salinan RAM dan beberapa keterampilan dalam bekerja dengannya, ada kemungkinan untuk mengembalikan pesan terbaru atau file sementara yang dapat membantu dalam penyelidikan forensik. </p><br><p>  Dalam kasus serangan pada perangkat, analisis salinan RAM perangkat memungkinkan Anda untuk mengetahui bagaimana serangan itu dilakukan, saluran komunikasi, malware dan kerentanan apa yang digunakan oleh penyerang untuk mencegah serangan seperti itu di masa depan. </p><br><p>  Menyalin data penting secara berkala untuk mendeteksi perangkat lunak berbahaya.  Pendekatan ini digunakan untuk mendeteksi malware yang menggunakan metode untuk menyembunyikan keberadaannya di sistem. </p><br><p>  Juga, salinan memori (atau bagian yang hanya berisi konteks aplikasi atau proses yang sedang dipelajari) dapat digunakan untuk mengidentifikasi kerentanan dan fitur-fitur tidak terdokumentasi dari perangkat lunak.  Alat perangkat lunak khusus yang ada menggunakan salinan RAM untuk mendeteksi rootkit [6].  Salinan memori seluruh sistem dapat digunakan untuk memantau perubahan di seluruh sistem untuk mengidentifikasi tindakan ilegal. </p><br><p>  Untuk menganalisis salinan operasional, Kerangka Volatilitas digunakan [7].  Volatility Framework adalah seperangkat alat untuk mendapatkan dan menganalisis salinan RAM dari berbagai sistem operasi, termasuk Android.  Dengan menggunakan alat ini, Anda bisa mendapatkan informasi yang diperlukan yang terdapat dalam gambar RAM.  Untuk mendapatkan salinan RAM, Volatility Framework menggunakan modul kernel LiME.  Untuk mengekstrak salinan RAM melalui LiME, diperlukan kode sumber dari kernel Linux perangkat yang diteliti. </p><br><h2>  Analisis alat dan metode untuk mengeksekusi file yang dapat dieksekusi melalui koneksi nirkabel untuk Android OS </h2><br><p>  Untuk menginstal aplikasi, seperti pada sistem operasi mirip UNIX, paket digunakan.  Di Android, paket ini memiliki ekstensi .apk.  Paket-paket tersebut disimpan dalam memori perangkat bahkan setelah instalasi dan dihapus hanya ketika aplikasi dihapus.  Paket .apk berisi kode Java yang dikompilasi, serta file AndroidManifest.xml yang menyatakan izin yang diperlukan agar aplikasi berfungsi. </p><br><p>  Ada dua jenis aplikasi: sistem dan pengguna.  Aplikasi sistem, tidak seperti aplikasi pengguna, memiliki lebih banyak hak istimewa, sehingga mengubah atau menghapusnya hanya mungkin jika Anda memiliki hak pengguna super.  Paket aplikasi pengguna berada di direktori "/ data / app".  Paket aplikasi sistem terletak di direktori "/ system / app". </p><br><p>  Dimulai dengan Android 5.0, mesin virtual Android Runtime digunakan alih-alih mesin virtual Dalvik.  Tidak seperti Dalvík, Android Runtime tidak mengkompilasi aplikasi saat startup, tetapi selama instalasi.  Ini meningkatkan kecepatan peluncuran program dan meningkatkan masa pakai baterai.  Untuk memastikan kompatibilitas, Android Runtime menggunakan bytecode yang sama dengan Dalvik. </p><br><p>  Tidak seperti proses sistem, proses pengguna memiliki lebih sedikit hak istimewa pada sistem.  Untuk mendapatkan hak istimewa seperti proses sistem, proses pengguna membutuhkan hak pengguna super atau hak "root".  Superuser adalah pengguna sistem operasi yang memiliki hak tak terbatas dalam sistem. <br>  Hak pengguna super terdiri dari dua jenis: permanen dan sementara.  Hak superuser permanen dipertahankan bahkan setelah reboot, dan hak sementara berlaku hingga perangkat di-boot ulang. </p><br><p>  Biasanya, hak pengguna super pada perangkat tidak tersedia.  Karena beragamnya perangkat, tidak ada cara yang seragam untuk mendapatkan hak pengguna super.  Oleh karena itu, untuk mendapatkan hak pengguna super, berbagai alat digunakan.  Diperolehnya hak pengguna super untuk mendapatkan salinan memori dari perangkat Android. <br>  Untuk menjalankan file yang dapat dieksekusi, beberapa hak istimewa diperlukan pada sistem, serta seperangkat perintah Unix.  Awalnya, Android memiliki beberapa set perintah minimal, yang biasanya tidak cukup untuk mendapatkan salinan memori.  Oleh karena itu, mereka menggunakan BusyBox, yang mencakup serangkaian perintah yang diperluas.  Utilitas yang disertakan dengan BusyBox memungkinkan Anda untuk bekerja dalam sistem file, meluncurkan aplikasi, menampilkan informasi sistem, dan banyak lagi.  Dimungkinkan juga untuk membuat skrip shell. </p><br><p>  Skrip shell adalah file yang dapat dieksekusi yang berisi skrip untuk mengeksekusi serangkaian perintah.  Berbeda dengan aplikasi, skrip shell tidak memerlukan instalasi dan kompilasi.  Jika Anda perlu memperbaiki sesuatu, maka lakukan saja perubahan pada file skrip shell. <br>  Karena file yang dapat dieksekusi diluncurkan melalui komunikasi nirkabel, kami akan mempertimbangkan dua cara untuk meluncurkan file yang dapat dieksekusi menggunakan ADB dan SSH. </p><br><p>  Untuk metode pertama, cukup menjalankan “setprop service.adb.tcp.port 5555;  hentikan adbd; mulai adbd ”.  Selanjutnya, jalankan prompt perintah di komputer dan sambungkan ke perangkat menggunakan perintah "adb connect X", di mana "X" adalah alamat IP perangkat di jaringan dan nilai port adalah 5555. Untuk menjalankan file yang dapat dieksekusi, gunakan perintah "adb shell am start -n com. package.name/com.package.name.ActivityName ”jika ini adalah aplikasi.  Jika file yang dapat dieksekusi adalah skrip shell, maka itu diluncurkan menggunakan perintah "adb shell ./name", di mana nama adalah nama skrip. </p><br><p>  Metode kedua menggunakan protokol SSH.  Berbeda dengan metode sebelumnya, metode ini membutuhkan klien SSH di komputer, dan server SSH di perangkat.  Di Windows, Anda dapat menggunakan Putty, atau di Linux Openssh.  Setelah menghubungkan perangkat ke komputer, kami mendapatkan akses ke shell perintah Shell.  Perintah untuk menjalankan file yang dapat dieksekusi sama seperti pada metode pertama. </p><br><p>  Dengan demikian, dapat dilihat bahwa kedua metode hanya berbeda dalam metode koneksi.  Kedua metode menggunakan shell perintah Shell untuk menjalankan file yang dapat dieksekusi.  Dari sini dapat disimpulkan bahwa ketika mendapatkan akses ke shell, Anda dapat menjalankan perintah apa pun, serta menjalankan file yang dapat dieksekusi, apakah itu aplikasi atau skrip shell. </p><br><h2>  Alat perangkat lunak untuk mendapatkan salinan RAM </h2><br><p>  Metode perangkat lunak yang ada dapat dibagi menjadi dua kategori: </p><br><ul><li>  mendapatkan salinan memori dari ruang pengguna dan kernel; </li><li>  mengambil salinan memori hanya dari ruang pengguna. </li></ul><br><p>  Alat perangkat lunak untuk mengambil salinan ruang pengguna dan ruang kernel termasuk AMExtractor dan LiME.  Alat Mem dan Memfetch hanya bisa mendapatkan salinan memori dari ruang pengguna saja. </p><br><p>  Pertimbangkan alat perangkat lunak yang disebutkan di atas untuk mendapatkan salinan RAM dari perangkat di bawah kendali sistem operasi Android: </p><br><ul><li>  Mem: utilitas open source yang digunakan untuk mendapatkan data RAM proses [8]; </li><li>  Memfetch: utilitas open source untuk mendapatkan ruang alamat RAM proses menggunakan perangkat / proc / $ pid / peta dan / proc / $ pid / mem [9]; </li><li>  LiME: modul untuk kernel Linux dengan kode sumber terbuka untuk mendapatkan data yang disimpan dalam RAM di ruang pengguna dan kernel [10]; </li><li>  AMExtractor: utilitas open source yang menggunakan perangkat pseudo / dev / kmem untuk memuat ke dalam memori kernel [11]. </li></ul><br><p>  Program Mem dan Memfetch dapat digunakan tanpa konfigurasi awal, tetapi mereka tidak dapat memperoleh data dari area memori kernel dan membutuhkan hak pengguna super untuk pekerjaan mereka. </p><br><p>  Terlepas dari penggunaannya yang luas dan keserbagunaannya, modul LiME membutuhkan konfigurasi dan kode sumber yang benar untuk kernel Linux untuk setiap perangkat. <br>  Agar AMExtractor berfungsi, informasi diperlukan tentang jenis model pengalamatan memori virtual yang digunakan oleh hak kernel dan superuser. </p><br><p>  Alat perangkat lunak yang dipertimbangkan dalam karya ini, kode sumber yang tersedia untuk umum, hanya digunakan untuk mendapatkan salinan RAM. </p><br><p>  Alat perangkat lunak seperti Oxygen, UFED, dan MSAB XRY harganya mahal dan hanya tersedia untuk penggunaan komersial.  Program tingkat ini mampu: menerima salinan memori dari perangkat yang terkunci, mendapatkan hak pengguna super, menghasilkan laporan forensik, dan banyak lagi. </p><br><p>  Alat ANDROPHSY adalah alat sumber terbuka pertama yang mendukung semua tahap penyelidikan forensik perangkat Android [12].  Arsitektur ANDROPHSY terdiri dari empat modul utama: modul pemrosesan, modul koleksi, modul analisis, dan modul pelaporan.  Akuisisi data dilakukan dengan menggunakan alat dd dan layanan ADB.  Kabel USB digunakan untuk menghubungkan antara komputer dan perangkat yang sedang diselidiki, dan data ditransmisikan melalui protokol TCP. </p><br><p>  Konfirmasi relevansi karya ini adalah adanya kekurangan di ANDROPHSY.  Ini termasuk kinerja hanya di lingkungan Linux, kurangnya fungsi untuk mendapatkan dan menganalisis salinan RAM perangkat dan kurangnya koneksi ke perangkat melalui Wi-Fi atau Bluetooth untuk mengekstrak data. </p><br><p>  Berdasarkan analisis, tabel komparatif dibangun (lihat Gambar 1).  Dalam tabel 1, simbol "+" menunjukkan dana yang memenuhi persyaratan, dan simbol "-" menunjukkan yang sebaliknya. </p><br><img src="https://habrastorage.org/webt/uh/yg/q7/uhygq7zf3ghxnqpkoxpv0o4pjfg.png"><br><p>  <em>Gambar 1 - Perangkat lunak untuk mendapatkan salinan RAM</em> </p><br><p>  Menurut hasil perbandingan, diputuskan untuk menggunakan AMExtractor untuk mengambil gambar RAM, karena penerimaan salinan lengkap dari RAM, serta kurangnya kebutuhan akan kode sumber kernel dan dukungan untuk memuat modul. </p><br><h2>  Perangkat Lunak Transfer Data </h2><br><p>  Kabel USB digunakan untuk mengambil data dari perangkat yang menjalankan sistem operasi Android.  Sebagian besar perangkat Android dapat dihubungkan ke komputer pribadi menggunakan kabel USB. </p><br><p>  Namun, selama penyelidikan perangkat Android, dapat terjadi bahwa tidak mungkin untuk mengekstrak data darinya menggunakan koneksi USB.  Alasannya mungkin karena kabel yang rusak atau konektor yang rusak.  Dalam kasus ini, hanya kartu memori eksternal, yang tidak ditemukan pada semua perangkat, akan tersedia untuk ahli untuk penelitian.  Terkadang perangkat hanya berisi memori internal.  Isi memori ini, serta RAM, dapat dihapus dengan aman melalui koneksi USB.  Alternatif untuk koneksi kabel adalah nirkabel.  Dari semua protokol nirkabel, sistem operasi Android mendukung yang paling populer: Wi-Fi dan Bluetooth. </p><br><p>  Wi-Fi di perangkat Android modern digunakan untuk mengakses Internet atau mentransfer data.  Perangkat seluler berbasis-droid mendukung sebagian besar standar Wi-Fi hingga 802.11ac.  Kecepatan transfer data antara perangkat melalui Wi-Fi melebihi kecepatan transfer data melalui Bluetooth [13]. </p><br><p>  Untuk menghubungkan perangkat melalui Wi-Fi, cukup sambungkan ke titik akses bersama.  Karena perangkat lain dapat terhubung ke jalur akses bersama, penting untuk membatasi akses mereka ke jaringan.  Ketersediaan dukungan di Android, Wi-Fi Hotspot, memungkinkan Anda untuk menggunakan perangkat sebagai titik akses. </p><br><p>  Protokol nirkabel Bluetooth, tersedia pada perangkat An-droid, dirancang untuk mentransfer data antara perangkat yang memiliki baterai kecil.  Dibandingkan dengan Wi-Fi, kecepatan transfer file melalui Bluetooth jauh lebih rendah.  Protokol didasarkan pada piconet yang terdiri dari simpul utama dan beberapa simpul bawahan [14].  Profil digunakan untuk mentransfer berbagai jenis data.  Profil Bluetooth menentukan perintah dan fungsionalitas yang dapat dipertukarkan oleh perangkat di antara mereka.  Setidaknya ada 27 profil Bluetooth. </p><br><p>  Profil PAN digunakan untuk membuat WPAN antara dua perangkat.  Profil HID memungkinkan Anda menghubungkan mouse, keyboard, dan perangkat periferal lainnya yang mendukung profil ini [14]. </p><br><p>  Dalam pekerjaan ini, berdasarkan pada fitur sistem operasi Android, kami mempertimbangkan transfer data perangkat lunak berikut: </p><br><ul><li>  SSHFS: klien sistem file berbasis FUSE untuk memasang direktori jarak jauh melalui koneksi SSH [15]; </li><li>  Rsync: utilitas open source yang menyediakan transfer data langkah demi langkah yang cepat [16]; </li><li>  SCP: utilitas dan protokol untuk mengirimkan data melalui protokol SSH [17]; </li><li>  SFTP: dibandingkan dengan SCP, yang memungkinkan Anda untuk hanya menyalin file, SFTP memiliki kemampuan untuk melakukan operasi file: misalnya, melanjutkan transfer file setelah pemutusan, menghapus file di server, dan banyak operasi lainnya [18]; </li><li>  NetCat: Utilitas UNIX yang membaca dan menulis data melalui koneksi jaringan menggunakan protokol TCP atau UDP [19]. </li></ul><br><p>  Utilitas rsync dalam banyak kasus digunakan untuk menyinkronkan file atau direktori.  Selama sinkronisasi, hanya perubahan yang dikirim menggunakan algoritma pencarian checksum yang efektif.  Fungsi Rsync memungkinkan Anda mentransfer melalui protokol SSH, mengkompres file, serta menyalin tautan, file perangkat, atribut pemilik, grup, dan hak. <br>  Sebagian besar cara memperoleh salinan memori menggunakan protokol TCP untuk transfer data untuk mengecualikan kemungkinan menulis data ke memori perangkat yang sedang dipelajari. </p><br><p>  Untuk transfer data yang aman, penting agar perangkat lunak menggunakan protokol SSH.  Secure Shell Protocol (SSH) adalah protokol untuk login jarak jauh yang aman ke sistem dan layanan jaringan aman lainnya melalui jaringan tidak aman [20]. </p><br><p>  Kompresi data dapat secara signifikan meningkatkan laju transmisi pada bandwidth saluran rendah.  Transfer file, beserta atributnya, sangat penting untuk analisis forensik berikutnya. </p><br><p>        dd.   dd     ,         ,     . </p><br><p>       (.  2).   “+”  ,  ,   “-” — . </p><br><img src="https://habrastorage.org/webt/fl/ll/t1/flllt1dgzvexd1h4_nmyfwnr8xo.png"><br><p> <em> 2 —        .</em> </p><br><p>         -    NetCat,  Rsync      ,     </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laporan Ekonomi Seluler Global GSMA 2018 [Sumber daya elektronik]. </font><font style="vertical-align: inherit;">// GSMA. </font><font style="vertical-align: inherit;">- Mode akses sumber daya: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://www.gsma.com/mobileeconomy/</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (diakses: 04/15/2019).</font></font></li><li> International Data Corporation, Worldwide Quarterly Mobile Phone Tracker [ ]. // International Data Corporation —    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://www.idc.com/prodserv/smartphone-os-market-share.jsp</a> ( : 15.04.2019). </li><li> Securelist, Mobile malware evolution 2018 [ ]. // Kaspersky Lab —    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://securelist.ru/mobile-malware-evolution-2018/93451/</a> ( : 15.04.2019). </li><li> Oleg Davydov. Mobile Phone Forensics Challenges [ ] // Eforensics magazine. —    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://www.tverlingua.by.ru/archive/005/5_3_1.htm</a> ( : 22.08.2018). </li><li> Christian Hilgers. Post-Mortem Memory Analysis of Cold-Booted Android Devices [ ].// IEEE Xplore Digital Library —    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6824082</a> ( : 15.09.2018) </li><li> Haiyu Yang. A Tool for Volatile Memory Acquisition from Android Devices [ ]. // ResearchGate —    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.researchgate.net/publication/308300539_A_Tool_for_Volatile_Memory_Acquisition_from_Android_Devices</a> ( : 16.09.2018). </li><li> About Volatility Framework [ ]. // Volatility Foundation —    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.volatilityfoundation.org/about</a> ( : 16.09.2018). </li><li>   Mem [ ]. // GitHub —    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/MobileForensicsResearch/mem</a> ( : 23.10.2018). </li><li>   LiME [ ]. // GitHub —    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/volatilityfoundation/volatility/wiki/Android</a> ( : 23.10.2018). </li><li>   Memfetch [ ]. // GitHub —    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/citypw/lcamtuf-memfetch</a> ( : 23.10.2018). </li><li>   AMExtractor [ ]. // GitHub —    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/ir193/AMExtractor</a> ( : 23.10.2018). </li><li>   ANDROPHSY [ ]. // GitHub —    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/scorelab/ANDROPHSY</a> ( : 23.10.2018). </li><li> Android Developer [ ]. // Google Developers —    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://developer.android.com/guide/topics/connectivity/wifip2p.html</a> ( : 18.11.2018). </li><li> Bluetooth overview [ ]. // Google Developers. —    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://developer.android.com/guide/topics/connectivity/bluetooth</a> ( : 23.11.2018). </li><li> SSHFS [ ]. // ArchLinux —    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://wiki.archlinux.org/index.php/SSHFS</a> ( : 08.11.2018). </li><li>   Rsync [ ]. // Rsync —    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://rsync.samba.org/</a> ( : 23.11.2018). </li><li>   SCP [ ]. // Die.net —    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://linux.die.net/man/1/scp</a> ( : 08.12.2018). </li><li>   SFTP [ ]. // SSH Communications Security —    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.ssh.com/ssh/sftp/#sec-SCP-Command-on-Linux/</a> ( : 08.12.2018). </li><li>  Unix . Netcat [ ]. //    —    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://handynotes.ru/2010/01/unix-utility-netcat.html</a> ( : 08.12.2018). </li><li> The Secure Shell (SSH) Connection Protocol [ ]. // IETF —    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tools.ietf.org/html/rfc4254</a> ( : 13.12.2018). </li></ol></div></div><br><p> PS  ... </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id473678/">https://habr.com/ru/post/id473678/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id473666/index.html">Sebagai penulis fiksi ilmiah, Arthur Clark hampir menutup jurnal Tech - Youth</a></li>
<li><a href="../id473668/index.html">Mengapa Bitrix - Bitrix</a></li>
<li><a href="../id473670/index.html">Stoloto: cara memperkenalkan ponsel ke lotre</a></li>
<li><a href="../id473672/index.html">Kenapa, Bitrix? Atau dunia peri 1C</a></li>
<li><a href="../id473676/index.html">Kerentanan backport di RouterOS membahayakan ratusan ribu perangkat</a></li>
<li><a href="../id473680/index.html">AC nya. Bagian II</a></li>
<li><a href="../id473684/index.html">Dari tulip mania hingga perdagangan elektronik: opsi apa saja, dan bagaimana investor menggunakannya hari ini</a></li>
<li><a href="../id473692/index.html">Ennoble Phicomm K3C Wi-Fi Router</a></li>
<li><a href="../id473694/index.html">Rusia adalah pusat pengembangan CAD global. Tahukah Anda tentang ini?</a></li>
<li><a href="../id473702/index.html">Apa yang sharding di blockchain terahash</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>