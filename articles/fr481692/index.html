<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÑ üíÉüèø üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë® Utilisation de Intel Processor Trace pour tracer le code du mode de gestion du syst√®me üîÅ ‚ûø üö©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article est consacr√© √† tester la possibilit√© d'utiliser la technologie Intel Processor Trace (Intel PT) pour enregistrer des pistes en mode System...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Utilisation de Intel Processor Trace pour tracer le code du mode de gestion du syst√®me</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/481692/"><p><img src="https://habrastorage.org/webt/ek/w6/yn/ekw6ynxfsk4gnib6pbdy0glmkxy.png"></p><br><p>  Cet article est consacr√© √† tester la possibilit√© d'utiliser la technologie Intel Processor Trace (Intel PT) pour enregistrer des pistes en mode System Management Mode (SMM).  Ce travail a √©t√© r√©alis√© dans le cadre de Summer Of Hack 2019. Publi√© par <a href="https://twitter.com/sysenter_eip">@sysenter_eip</a> . </p><br><p>  La plupart des outils utilis√©s sont √©crits par d'autres personnes (en particulier <a href="https://twitter.com/d_olex">@d_olex</a> , <a href="https://twitter.com/aionescu">@aionescu</a> ).  Le r√©sultat est juste une combinaison des outils disponibles afin d'obtenir le chemin d'ex√©cution du code en mode SMM pour <strong>une</strong> carte m√®re <strong>sp√©cifique</strong> .  Cependant, le mat√©riel peut √™tre int√©ressant pour ceux qui veulent r√©p√©ter cela pour leur plate-forme ou qui sont simplement int√©ress√©s par le travail de SMM. </p><a name="habracut"></a><br><h2 id="system-management-mode">  Mode de gestion du syst√®me </h2><br><p> SMM est un mode sp√©cial et privil√©gi√© du processeur d'architecture x86, qui est disponible pendant que le syst√®me d'exploitation est en cours d'ex√©cution, mais qui lui est compl√®tement invisible.  Il est con√ßu pour une interaction de bas niveau avec le mat√©riel, la gestion de l'alimentation, l'√©mulation de l'h√©ritage de l'appareil, la transition vers le mode veille (S3), l'acc√®s au TPM et plus encore.  Il fonctionne compl√®tement isol√© du syst√®me d'exploitation.  Pendant la dur√©e de l'ex√©cution de SMM, le syst√®me d'exploitation s'arr√™te compl√®tement.  Le code de programme qui s'ex√©cute dans ce mode est stock√© dans la m√©moire SPI-Flash de la carte m√®re et fait partie du micrologiciel du BIOS UEFI. </p><br><p>  Le passage en mode SMM s'effectue √† l'aide d'interruptions SMI sp√©ciales (System Management Interrupt).  L'une des options de cette interruption est disponible pour une utilisation dans l'anneau z√©ro (c'est-√†-dire √† partir du noyau du syst√®me d'exploitation) - Interruption SMI au niveau de l'application (Software SMI).  De plus, nous nous concentrerons sur ces interruptions. </p><br><p>  En raison de ses privil√®ges √©lev√©s, SMM pr√©sente un int√©r√™t particulier pour la recherche en s√©curit√©.  Le compromis de SMM entra√Æne de graves violations de l'int√©grit√© et de la confidentialit√© de l'ensemble du syst√®me, et dans la plupart des cas, il vous permet d'injecter du code malveillant qui ne peut pas √™tre supprim√© et ne peut pas √™tre d√©tect√© par le syst√®me d'exploitation dans le micrologiciel du BIOS UEFI. </p><br><h2 id="intel-processor-trace">  Intel Processor Trace </h2><br><p>  L'un des √©cueils du processus de d√©bogage pour diverses applications tr√®s charg√©es est les frais g√©n√©raux - les co√ªts des outils de d√©bogage.  Ils peuvent √™tre r√©duits avec une solution mat√©rielle. </p><br><p>  La cinqui√®me g√©n√©ration de processeurs d'Intel (Broadwell) a pr√©sent√© au monde des technologies telles que Intel Processor Trace.  En quoi est-il utile?  Intel PT vous permet d'obtenir le flux complet d'ex√©cution (Control Flow) de l'application d√©bogu√©e avec un minimum de surcharge (&lt;5%).  Dans le m√™me temps, il prend en charge le multithreading et peut aider √† corriger des erreurs telles que la ¬´condition de concurrence critique¬ª en raison des horodatages lors de l'enregistrement de la trace d'application.  Sans aucun doute, la technologie Intel PT offre de grandes opportunit√©s pour √©crire des outils de recherche de vuln√©rabilit√© dans les applications. </p><br><p>  Aujourd'hui, cette technologie est utilis√©e dans divers outils de tra√ßage, de d√©bogage et d'√©valuation de la couverture de code - √† la fois dans les applications de niveau utilisateur et noyau.  Des exemples d'outils sont disponibles sur le site Web d' <a href="https://software.intel.com/en-us/node/721535">Intel</a> .  Une option AFL fuzzer qui tire parti d'Intel PT est disponible dans le r√©f√©rentiel <a href="https://github.com/hunter-ht-2018/ptfuzzer">PTfuzzer</a> .  Parmi les projets r√©cents, faites attention √† l' <a href="https://github.com/ohjeongwook/iptanalyzer">iptanalyzer</a> . </p><br><p>  Cependant, nous n'avons vu aucun travail sur l'utilisation d'Intel PT en mode SMM.  Puisque rien ne nous emp√™che d'utiliser Intel PT dans ce contexte, nous avons d√©cid√© de savoir s'il √©tait possible de tracer le code du mode de gestion du syst√®me avec lui. </p><br><h2 id="podgotovka-k-rabote">  Pr√©paration au travail </h2><br><p>  Il r√©sulte du <a href="https://www.intel.ru/content/www/ru/ru/architecture-and-technology/64-ia-32-architectures-software-developer-vol-3c-part-3-manual.html">manuel du d√©veloppeur Intel</a> qu'il est impossible d'activer le tra√ßage Intel PT dans SMM de l'ext√©rieur en utilisant des moyens r√©guliers.  S'il √©tait actif au moment o√π le SMI a √©t√© d√©clench√©, le processeur le d√©sactivera avant de transf√©rer le contr√¥le au point d'entr√©e du gestionnaire SMI.  La seule m√©thode d'activation est l'inclusion volontaire du gestionnaire SMI par le code lui-m√™me. </p><br><p>  M√™me si le processeur ne fournit pas initialement une telle opportunit√©, nous pouvons l'intercepter et activer manuellement Intel PT.  Cependant, vous devez en quelque sorte d√©terminer que le syst√®me est pr√™t √† enregistrer la trace (l'adresse du tampon de sortie est d√©finie) et √©galement d√©sactiver le suivi √† la fin de l'ex√©cution du processeur (ex√©cution de l'instruction RSM).  Sinon, le processeur arr√™tera tout le syst√®me. </p><br><p>  Tout d'abord, vous devez acc√©der √† SMRAM (la zone de RAM dans laquelle se trouve le code ex√©cut√© en mode SMM).  √âtant donn√© que cette r√©gion RAM est prot√©g√©e, nous ne pouvons pas y acc√©der √† partir du syst√®me d'exploitation (m√™me cela ne peut pas √™tre fait avec DMA).  Il existe plusieurs sc√©narios: </p><br><ol><li>  exploiter une vuln√©rabilit√© connue dans SMM et en tirer la primitive R / W.  Cela peut √™tre une erreur logicielle (une vuln√©rabilit√© dans le processeur SMI lui-m√™me; en r√®gle g√©n√©rale, dans SMM, il y a suffisamment de code qui a √©t√© ajout√© par l'OEM, donc les vuln√©rabilit√©s ne sont pas rares), ainsi qu'une configuration de plate-forme vuln√©rable (d√©verrouillage / d√©placement de SMRAM); </li><li>  pour patcher l'image UEFI de telle mani√®re que nous ayons une interface pour lire et √©crire dans des adresses arbitraires - une porte d√©rob√©e.  Pour impl√©menter cette option, vous devez trouver une carte m√®re sur laquelle Intel Boot Guard est d√©sactiv√© ou il existe des vuln√©rabilit√©s qui peuvent la contourner. </li></ol><br><h2 id="vnedrenie-svoego-koda-v-proshivku">  Int√©grez votre code dans le firmware </h2><br><p>  Malgr√© le fait que des vuln√©rabilit√©s SMM dans le code de diff√©rents fabricants se trouvent de <a href="https://embedi.org/blog/uefi-bios-holes-so-much-magic-dont-come-inside/">temps</a> en <a href="https://embedi.org/blog/uefi-bios-holes-so-much-magic-dont-come-inside/">temps</a> , il vaudrait mieux que nous ne nous appuyions pas sur elles.  Il est plus int√©ressant pour nous de retracer le code sur un nouveau firmware et, en cons√©quence, d'essayer de trouver des vuln√©rabilit√©s dans ceux-ci.  Nous avions d√©j√† la carte m√®re GIGABYTE GA-Q270M-D3H avec Intel Boot Guard d√©sactiv√©e, donc tout ce que nous avions √† faire √©tait d'ajouter une porte d√©rob√©e √† SMM. </p><br><p><img src="https://habrastorage.org/webt/cj/gs/ub/cjgsubzj6xwovbitbn7dob_tsz4.jpeg"><br>  Figure 1. Banc d'essai </p><br><p>  Il existe d√©j√† un <a href="https://github.com/Cr4sh/SmmBackdoor">cadre pour ¬´infecter¬ª SMM et travailler avec une porte d√©rob√©e</a> .  Il se compose de trois composants: le pilote UEFI en C, l '"infecteur" et le script client en Python.  Pour son fonctionnement, vous devez extraire un pilote DXE arbitraire (vous pouvez le faire en utilisant <a href="https://github.com/LongSoft/UEFITool">UEFITool</a> ) et le traiter avec un infecteur.  Le module d'origine a √©t√© remplac√© par ¬´am√©lior√©¬ª et le micrologiciel a √©t√© t√©l√©charg√© dans la m√©moire SPI (pour faciliter le flashage, le lecteur flash SPI a √©t√© retir√© de la carte). </p><br><p><img src="https://habrastorage.org/webt/bv/2a/ih/bv2aihyunbskeqjvp6ppqvqhzmi.jpeg"><br>  Figure 2. Puce de m√©moire SPI-Flash </p><br><p>  Le syst√®me a d√©marr√© avec succ√®s et nous avons maintenant un acc√®s complet √† SMRAM depuis Python (un exemple d'utilisation est fourni avec la porte d√©rob√©e).  √âtant donn√© que le script client pour la porte d√©rob√©e est bas√© sur <a href="https://github.com/chipsec/chipsec">CHIPSEC</a> , vous devez lui donner acc√®s au mode noyau (nous avons utilis√© le pilote RWEverything; il sera pratique pour quelqu'un d'utiliser son propre pilote CHIPSEC avec la v√©rification de signature d√©sactiv√©e dans le syst√®me). </p><br><p>  Vous pouvez v√©rifier la porte d√©rob√©e en demandant un vidage SMRAM. </p><br><p><code>$ python SmmBackdoor.py -d</code> </p> <br><p>  Apr√®s avoir ex√©cut√© cette commande, le fichier SMRAM_dump_cb000000_cb7fffff.bin sera cr√©√© contenant l'√©tat SMRAM actuel.  Les valeurs cb000000 et cb7fffff sont, respectivement, les adresses physiques du d√©but et de la fin de SMRAM. </p><br><h2 id="rabota-s-dampom-smram">  Travailler avec dump SMRAM </h2><br><p>  Le vidage SMRAM peut √™tre charg√© dans un d√©sassembleur ou transmis pour analyse au script <a href="https://github.com/Cr4sh/smram_parse">smram_parse.py</a> , qui extraira de nombreuses informations utiles pour nous.  Le plus important pour nous sera l'adresse des points d'entr√©e SMI.  Ce sont les adresses des fonctions vers lesquelles le contr√¥le sera transf√©r√© lorsque SMI sera d√©clench√©.  Chaque CPU a son propre point d'entr√©e. </p><br><p><img src="https://habrastorage.org/webt/8a/20/jq/8a20jq29bgn7rhqeim16vqhfxam.png"><br>  Figure 3. La sortie du script smram_parse </p><br><p>  Regardons leur code.  √âtant donn√© que SMM commence son ex√©cution en mode r√©el 16 bits (les 4 premiers Go de RAM se refl√®tent dans l'espace virtuel), la premi√®re chose que le code fait est de passer en mode 64 bits.  Dans le m√™me temps, l'int√©gralit√© de la SMRAM est disponible avec des droits d'√©criture et d'ex√©cution, car un seul segment a √©t√© cr√©√© (existe-t-il des fournisseurs qui le font diff√©remment?). </p><br><p>  Nous ne voudrions pas √©crire du code 16 bits ou pr√©parer tout le n√©cessaire pour passer en mode 64 bits par nous-m√™mes, nous placerons donc notre intercepteur juste avant d'appeler la fonction de gestionnaire SMI (cette fonction d√©termine quel module SMM l'ex√©cution doit √™tre transf√©r√©e en fonction de quel service a √©t√© appel√© ou quel √©v√©nement s'est produit). </p><br><p><img src="https://habrastorage.org/webt/_u/b0/4k/_ub04kwpncdmptrknltqyl0i3jg.png"><br>  Figure 4. Emplacement pour le crochet </p><br><p>  La fa√ßon la plus simple de prendre le contr√¥le est de remplacer l'adresse du r√©partiteur par la n√¥tre.  Tous les points d'entr√©e ont le m√™me code, donc le patch doit √™tre r√©p√©t√© pour chacun. </p><br><p>  <strong>Remarque:</strong> Concernant l'emplacement du code d'intercepteur.  Puisque la structure de SMRAM n'est pas compl√®tement connue de nous, nous avons choisi un morceau al√©atoire de m√©moire nulle pr√®s d'un des points d'entr√©e, o√π nous avons plac√© le code d'intercepteur.  La meilleure option serait d'ajouter votre module SMM au firmware, que l'UEFI placerait l√©galement dans SMRAM, afin de ne pas craindre que quelque chose d'important soit √©cras√© par notre code. </p><br><h2 id="realizaciya-perehvatchika-dispetchera-smi">  Impl√©mentation d'un intercepteur SMI Manager </h2><br><p>  D√©signons ce que nous allons faire exactement √† l'int√©rieur de notre intercepteur.  Nous devons d'abord d√©terminer si Intel PT a √©t√© activ√© avant de passer √† SMM.  Il est connu de la documentation d'Intel que chaque processeur a sa propre base SMBASE (MSR 0x9E) et son propre espace pour stocker l'√©tat du processeur (SMM Save State area) au moment de la transition vers SMM. </p><br><p><img src="https://habrastorage.org/webt/bz/ti/i2/bztii2soe7myxor_zprtytfr09q.png"><br>  Figure 5. Disposition SMBASE </p><br><h3 id="opredelyaem-sostoyanie-intel-pt">  Nous d√©terminons le statut d'Intel PT </h3><br><p>  Dans le Save State SMM, la valeur du registre MSR IA32_RTIT_CTL, qui est responsable de la gestion du suivi Intel PT, doit √™tre enregistr√©e.  Malheureusement, Intel Manual n'indique pas o√π le processeur enregistre l'√©tat du bit IA32_RTIT_CTL.TraceEn au moment de la transition vers SMM (si le tra√ßage est activ√©, z√©ro bit).  Cependant, nous pouvons le d√©terminer nous-m√™mes en vidant deux fois le Save State SMM: avec et sans tra√ßage activ√©. </p><br><p>  Nous avons utilis√© l'outil <a href="https://ionescu007.github.io/winipt/">WinIPT</a> pour activer le tra√ßage sur le processus d'interpr√©teur Python (pid <strong>1337</strong> ), allouant 2 ^ <strong>12</strong> (4096) octets au tampon de trace, puis ex√©cutant le script SmmBackdoor.py √† l'int√©rieur de l'interpr√©teur (l'argument <strong>0</strong> est un indicateur, pour nous, ils ne le sont pas important, car dans SMM, vous devez toujours forcer vos param√®tres de trace). </p><br><p> <code>$ ipttool.exe --start 1337 12 0</code> </p> <br><p>  En comparant les instantan√©s SMRAM, nous avons d√©termin√© l'emplacement du registre IA32_RTIT_CTL dans la structure d'√©tat de sauvegarde SMM.  Il est stock√© √† l'offset SMBASE + 0xFE3C.  L'√©tat du bit IA32_RTIT_CTL.TraceEn est la condition principale pour la r√©activation d'Intel PT dans SMM.  Le champ √† ce d√©calage est marqu√© comme r√©serv√© dans le manuel du d√©veloppeur Intel. </p><br><p><img src="https://habrastorage.org/webt/tf/uy/hx/tfuyhxbfmhemoyy8gh003uo37s8.png"><br>  Figure 6. Marquage que les champs sont r√©serv√©s </p><br><h3 id="pishem-shellcode">  √âcriture du shellcode </h3><br><p>  Nous ne voulions pas configurer Intel PT dans SMM par nous-m√™mes, car cela compliquerait notre shellcode (par exemple, √©tant dans SMM, il serait difficile d'allouer un gros morceau de RAM afin qu'il ne soit pas utilis√© par le syst√®me d'exploitation lui-m√™me).  Par cons√©quent, nous avons d√©cid√© d'utiliser le traceur d√©j√† configur√© et de simplement le "sauter" dans SMM, d'autant plus qu'il a d√©j√† pour fonction d'enregistrer la trace dans un fichier. </p><br><p>  √âtant donn√© que nous avons utilis√© WinIPT √† cette fin, qui √† l'√©poque ne prenait pas en charge le tra√ßage du code du noyau (CPL == 0), il √©tait √©vident que m√™me lorsque la trace √©tait incluse dans SMM, rien n'apparaissait dans le journal, car le code SMM √©tait ex√©cut√© √† CPL = 0 .  Nous devons modifier certains filtres afin que le traceur puisse fonctionner tout au long du temps pass√© dans SMM.  Nous listons tout ce qui doit √™tre v√©rifi√© et install√©: </p><br><ol><li>  Le tra√ßage avec CPL = 0 doit √™tre activ√©. </li><li>  Le tra√ßage pour CPL&gt; 0 doit √™tre activ√© (facultatif). </li><li>  Les plages IP valides pour l'enregistrement des √©v√©nements doivent √™tre d√©sactiv√©es. </li><li>  IA32_RTIT_STATUS.PacketByteCnt doit √™tre r√©initialis√©. </li><li>  Le filtrage CR3 doit √™tre d√©sactiv√©. </li></ol><br><p>  Il faut dire quelques mots sur PacketByteCnt.  Ce compteur d√©termine √† quel moment vous devez ins√©rer des paquets de synchronisation (une s√©quence de plusieurs commandes PSB) dans la trace.  Nous devons r√©initialiser ce compteur, sinon, pendant le traitement de la trace, le moment d'entrer dans le SMM sera manqu√© et la trace commencera √† partir d'un endroit al√©atoire lorsque le PSB est g√©n√©r√© naturellement. </p><br><p>  Voici le shellcode que nous avons utilis√©: </p><br><pre> <code class="plaintext hljs"> sub rsp, 0x18 ; this will align stack at 16 byte boundary (in case SMM ; code uses align dependent instructions) mov qword ptr ss:[rsp+0x10], rcx ; need to save rcx for SMI_Dispatcher mov ecx, 0x9E ; MSR_IA32_SMBASE rdmsr test byte ptr ds:[rax+0xFE3C], 0x1 ; Save State area contains saved ; IA32_RTIT_CTL.TraceEn je short @NoTrace call @Trace_Enable mov rcx, qword ptr ss:[rsp+0x10] ; SMI_Dispatcher is __fastcall ; (first argument in rcx) mov eax, 0xCB7DDAA4 ; original SMI_Dispatcher !!!!!!!!!!!!!!!!!!!!! call rax call @Trace_Disable add rsp, 0x18 ret @NoTrace: mov rcx, qword ptr ss:[rsp+0x10] ; SMI_Dispatcher is __fastcall mov eax, 0xCB7DDAA4 ; original SMI_Dispatcher !!!!!!!!!!!!!!!!!!!!! call rax add rsp, 0x18 ret @Trace_Disable: mov ecx, 0x570 ; IA32_RTIT_CTL rdmsr mov rax, qword ptr ss:[rsp+0x10] ; restore IA32_RTIT_STATUS wrmsr mov ecx, 0x571 ; IA32_RTIT_STATUS rdmsr mov rax, qword ptr ss:[rsp+0x8] ; restore IA32_RTIT_CTL wrmsr ret @Trace_Enable: mov ecx, 0x571 ; IA32_RTIT_STATUS rdmsr mov qword ptr ss:[rsp+0x8], rax ; save IA32_RTIT_STATUS and edx, 0xFFFF0000 ; IA32_RTIT_STATUS.PacketByteCnt = 0 wrmsr mov ecx, 0x570 ; IA32_RTIT_CTL rdmsr mov qword ptr ss:[rsp+0x10], rax ; save IA32_RTIT_CTL and eax, 0xFFFFFFBF ; IA32_RTIT_CTL.CR3Filter = 0 or eax, 0x5 ; IA32_RTIT_CTL.OS = 1; IA32_RTIT_CTL.User = 1; and edx, 0xFFFF0000 ; IA32_RTIT_CTL.ADDRx_CFG = 0 wrmsr ret</code> </pre> <br><p>  Ce code doit √™tre plac√© dans SMRAM, et la transition vers le gestionnaire SMI doit √™tre corrig√©e pour acc√©der √† notre code.  Tout cela se fait √† l'aide de SmmBackdoor. </p><br><h2 id="rabota-s-trassoy">  Travailler avec la piste </h2><br><p>  L'intercepteur du gestionnaire SMI nous a permis d'√©crire la premi√®re trace de code √† partir de SMM.  La commande suivante peut demander √† <strong>WinIPT</strong> d'enregistrer la <strong>trace</strong> dans un fichier: </p><br><p> <code>$ ipttool.exe --trace 1337 trace_file_name</code> </p> <br><p>  D√©sactiver le tra√ßage sur un processus: </p><br><p> <code>$ ipttool.exe --stop 1337</code> </p> <br><p>  Vous pouvez essayer de d√©sassembler la <strong>trace</strong> √† l'aide de l'utilitaire <a href="https://github.com/intel/libipt">dumppt</a> de <a href="https://github.com/intel/libipt">libipt</a> . </p><br><p> <code>$ ptdump.exe --no-pad ./examples/trace_smm_handler_33 &gt; ./examples/trace_smm_handler_33_pt_dump.txt</code> </p> <br><p>  Exemple de sortie: </p><br><p><img src="https://habrastorage.org/webt/rr/iq/0e/rriq0ex1jsozdb6yuvicvg0i_ao.png"><br>  Figure 7. Le premier chemin d'instruction SMM </p><br><p>  Nous pouvons voir certaines adresses, mais il est extr√™mement difficile d'utiliser ces informations, car elles sont de tr√®s bas niveau. </p><br><p>  Pour obtenir un aspect plus lisible, il existe un utilitaire <strong>ptxed</strong> (de libipt) qui convertit la trace en journal des instructions assembleur ex√©cut√©es.  Bien s√ªr, nous devrons fournir √† l'utilitaire un vidage de m√©moire SMRAM, car le journal IPT ne contient pas d'informations sur les valeurs des cellules de m√©moire ou les instructions qui ont √©t√© ex√©cut√©es;  il contient uniquement des informations sur les changements survenus dans le flux de contr√¥le. </p><br><p> <code>$ ptxed.exe --pt tracesmm_12 --raw SMRAM_dump_cb000000_cb7fffff.bin:0xcb000000 &gt; tracesmm_12_ptasm</code> </p> <br><p><img src="https://habrastorage.org/webt/zb/5q/mh/zb5qmhqp5rlqaa2xi6qydeu0i_o.png"><br>  Figure 8. Liste des assembleurs correspondant au journal IPT </p><br><p>  Cela semble d√©j√† beaucoup mieux, mais si le code contient une boucle, la sortie sera obstru√©e avec les m√™mes instructions. </p><br><h2 id="opredelyaem-pokrytie-koda-pri-pomoschi-trassy">  D√©finir la couverture du code √† l'aide de la trace </h2><br><p>  Pour obtenir la visualisation de la couverture, nous avons choisi le plugin <a href="https://github.com/gaasedelen/lighthouse">Lighthouse</a> pour IDA Pro, qui utilise le format drcov. </p><br><p>  Aucun outil pr√™t √† l'emploi n'a √©t√© trouv√©, nous avons donc modifi√© <strong>ptxed</strong> afin qu'il g√©n√®re √©galement un fichier de couverture dans le processus.  Le <strong>ptxed patch√©</strong> est disponible dans le <a href="https://github.com/sysenter-eip/smm_intel_pt/commit/8b7e23b3353fc04f886b9a226c1a34f768200822">r√©f√©rentiel</a> .  Jetez un ≈ìil √† l'historique des validations pour d√©terminer exactement ce qui a √©t√© ajout√©. </p><br><p>  Une fois ptxed termin√©, le fichier SMRAM_dump_cb000000_cb7fffff.bin.log appara√Æt, qui contiendra les informations de couverture au format drcov. </p><br><p>  <strong>Remarque:</strong> il y a un l√©ger probl√®me avec la synchronisation du d√©sassembleur sur le premier PSB.  Pour une raison pas tout √† fait claire, si le PSB est g√©n√©r√© avant PGE (le compteur est remis √† z√©ro avant que la trace ne soit √† nouveau activ√©e), alors <strong>ptxed</strong> ne peut pas √™tre synchronis√© sur celui-ci.  Pour contourner ce probl√®me, nous avons cr√©√© un petit correctif.  Il n'est pas clair si c'est un probl√®me pour <strong>ptxed</strong> lui-m√™me, ou si nous faisons quelque chose de mal en r√©initialisant IA32_RTIT_STATUS.PacketByteCnt. </p><br><p><img src="https://habrastorage.org/webt/pj/es/cq/pjescq_texdfmus7ljkpzxnrcaq.png"><br>  Figure 9. Un patch qui vous permet d'utiliser le PSB situ√© juste en face du PGE </p><br><p>  Les fichiers de couverture g√©n√©r√©s peuvent √™tre t√©l√©charg√©s dans IDA Pro et obtenir une belle mise en √©vidence, ainsi que des statistiques sur le pourcentage de couverture pour chaque fonction. </p><br><p><img src="https://habrastorage.org/webt/xl/7x/al/xl7xalcnynzuvjrrnrniamo-mzw.png"><br>  Figure 10. Plugin IDA Pro Lighthouse avec informations sur la couverture du code </p><br><p>  <strong>Remarque:</strong> Le plugin Lighthouse fonctionne un peu √©trangement sur des bases de donn√©es incompl√®tement analys√©es (le code ex√©cutable n'est pas √©tiquet√©, les fonctions n'ont pas √©t√© cr√©√©es).  Nous avons trac√© ce "probl√®me" √† la fonction get_instructions_slice dans le fichier \ lighthouse \ metadata.py, o√π il renvoie 0 instructions m√™me pour l'adresse o√π la fonction a √©t√© cr√©√©e manuellement.  Le plugin semble utiliser le cache et ignorer le nouveau code sp√©cifique.  Cela peut √™tre contourn√© en appelant Reanalyze sur le programme et en rouvrant IDB.  Ce n'est qu'apr√®s cela que le plugin pourra voir le nouveau code et commencer √† le consid√©rer.  √âtant donn√© que ce probl√®me est tr√®s g√™nant dans le cas d'un vidage SMRAM (qui au premier d√©marrage se compose presque enti√®rement de code non d√©fini), nous avons apport√© une petite modification au code Lighthouse afin que nous puissions d√©finir manuellement le nouveau code plus rapidement. </p><br><p><img src="https://habrastorage.org/webt/rq/4m/d8/rq4md80-4y5bjhzyqvpgmjeyjpe.png"><br>  Figure 11. Message de journal ajout√© pour aider √† identifier le nouveau code </p><br><h2 id="podderzhka-linux">  Prise en charge Linux </h2><br><p>  √âtant donn√© que tous nos tests ont √©t√© effectu√©s sur Windows 10 x64 (nous avions besoin d'ipt.sys, qui est apparu dans Windows October Creators Update 2018), disons quelques mots sur la possibilit√© de l'impl√©menter sous Linux. </p><br><ul><li>  Il existe un module de performance du noyau Linux qui peut effectuer des actions WinIPT (ipt.sys) similaires, y compris la possibilit√© de tracer du code en mode noyau. </li><li>  √âtant donn√© que l'interface SMM de porte d√©rob√©e est bas√©e sur le framework CHIPSEC multiplateforme, notre correctif fonctionnera sur un syst√®me Linux sans aucune modification. </li></ul><br><h2 id="vyvod">  Conclusion </h2><br><p>  Nous avons r√©ussi √† obtenir une trace de code ex√©cut√©e dans SMM √† l'aide de la technologie Intel Processor Trace.  Un r√©sultat similaire pourrait √™tre obtenu √† l'aide d'√©quipements et de logiciels co√ªteux qui ne sont pas vendus √† tout le monde.  Il nous suffisait d'avoir en main une carte m√®re et un programmeur SPI.  La vitesse de retrait de la piste est vraiment impressionnante, et il n'y a rien √† redire sur la pr√©cision du r√©sultat. </p><br><p>  Nous esp√©rons que cet article aidera les autres √† tirer parti de la technologie Intel PT pour enqu√™ter et rechercher les vuln√©rabilit√©s dans le code SMM.  L'adaptation de notre travail √† d'autres cartes m√®res ne devrait pas poser de probl√®mes (n'oubliez pas Intel Boot Guard).  L'essentiel est de bien comprendre comment cela fonctionne.  La partie la plus difficile est de d√©terminer comment intercepter le r√©partiteur SMI et √©crire un shellcode pour l'intercepteur.  Dans notre version, des adresses "c√¢bl√©es" √©taient utilis√©es, vous devez donc transf√©rer soigneusement le shellcode vers un autre syst√®me. </p><br><p>  Tous les outils et scripts utilis√©s sont disponibles dans le <a href="https://github.com/sysenter-eip/smm_intel_pt">r√©f√©rentiel sur GitHub</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr481692/">https://habr.com/ru/post/fr481692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr481676/index.html">Semaine de s√©curit√© 52: S√©curit√© des haut-parleurs intelligents et des cam√©ras IP</a></li>
<li><a href="../fr481678/index.html">Examen avant les vacances: lecteur N6IIT01 et casque YB04 Armature - Hi-Fi du sud de la Chine</a></li>
<li><a href="../fr481680/index.html">Ecrire TodoMVC sur dap. 2e partie</a></li>
<li><a href="../fr481684/index.html">Un ordinateur portable de Powerbank?</a></li>
<li><a href="../fr481688/index.html">Pourquoi apprendre Java et comment le faire efficacement. Rapport Yandex</a></li>
<li><a href="../fr481694/index.html">Ma fa√ßon de partitionner dans PostgreSQL</a></li>
<li><a href="../fr481696/index.html">r√®gle: contr√¥le dynamique de Go</a></li>
<li><a href="../fr481698/index.html">WebRTC en streaming dans et autour de la r√©alit√© virtuelle</a></li>
<li><a href="../fr481700/index.html">Une tante</a></li>
<li><a href="../fr481702/index.html">Du grille-pain au drone. Comment Internet des objets est-il n√© et pourquoi ne s'est-il d√©clench√© que 30 ans plus tard</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>